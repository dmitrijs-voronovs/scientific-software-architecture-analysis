quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Modifiability,". Understanding Collections. Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, collections of; points and lines might be managed by a graphics pad. A vertex will have a; collection of tracks. A detector geometry contains collections of shapes,; materials, rotation matrices and sub-detectors.; Collections act as flexible alternatives to traditional data structures; of computer science such as arrays, lists, and trees. Collections can be thought of as polymorphic containers that can contain; different types of elements. For this release of the ROOT system, elements; to be placed in collections must be instances of classes.; These may be classes defined by you or provided by ROOT. Collection elements; must be instances of classes descending from ; TObject. The dependence of collections on TObject may disappear; in the future when all C++ compilers used with the ROOT system fully; support templates. In the mean time, knowing the; role TObject plays in collections can be helpful. In general you don't need to worry about TObject. Many ROOT; classes have TObject as an ancestor. In fact, collections themselves; are descendants of TObject. This makes it possible for collections to; contain other collections (subcollections) in a tree structure. Such trees; are used in the ROOT system to implement components of the graphics system; (graphics pads containing pads), geometries (detectors in detectors), etc. The basic protocol TObject defines for collection elements is shown below:. IsEqual(); Compare(); IsSortable(); Hash(). How to use and override these member functions is shown in the; example program. Types of Collections. The ROOT system implements the following type of collections:; arrays, lists, sorted lists, B-trees, hashtables and maps.; The figure below shows the inheritance hierarchy for the primary; collection classes. Ordered Collections (Sequences). Sequenc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/Understanding_Collections.html:423,flexible,flexible,423,core/cont/doc/Understanding_Collections.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/Understanding_Collections.html,2,"['flexible', 'polymorphi']","['flexible', 'polymorphic']"
Modifiability,". When; contributing a patch specifically for reformatting Python files, use black,; which currently only supports formatting entire files. Here are some quick examples, but see the black and darker documentation for; details:. .. code-block:: bash. $ pip install black=='23.*' darker # install black 23.x and darker; $ darker test.py # format uncommitted changes; $ darker -r HEAD^ test.py # also format changes from last commit; $ black test.py # format entire file. Instead of individual file names, you can specify directories to; darker, and it will find the changed files. However, if a directory is; large, like a clone of the LLVM repository, darker can be painfully; slow. In that case, you might wish to use git to list changed files.; For example:. .. code-block:: bash. $ darker -r HEAD^ $(git diff --name-only --diff-filter=d HEAD^). Mechanical Source Issues; ========================. Source Code Formatting; ----------------------. Commenting; ^^^^^^^^^^. Comments are important for readability and maintainability. When writing comments,; write them as English prose, using proper capitalization, punctuation, etc.; Aim to describe what the code is trying to do and why, not *how* it does it at; a micro level. Here are a few important things to document:. .. _header file comment:. File Headers; """""""""""""""""""""""". Every source file should have a header on it that describes the basic purpose of; the file. The standard header looks like this:. .. code-block:: c++. //===-- llvm/Instruction.h - Instruction class definition -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the declaration of the Instruction class, which is the; /// base class for all of the VM instructions.; ///",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:6836,maintainab,maintainability,6836,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['maintainab'],['maintainability']
Modifiability,". _`gold linker`: http://sourceware.org/binutils; .. _`GCC LTO`: http://gcc.gnu.org/wiki/LinkTimeOptimization; .. _`gold plugin interface`: http://gcc.gnu.org/wiki/whopr/driver. .. _lto-how-to-build:. How to build it; ===============. You need to have gold with plugin support and build the LLVMgold plugin.; The gold linker is installed as ld.gold. To see whether gold is the default; on your system, run ``/usr/bin/ld -v``. It will report ""GNU; gold"" or else ""GNU ld"" if not. If gold is already installed at; ``/usr/bin/ld.gold``, one option is to simply make that the default by; backing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:1891,plugin,plugin,1891,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin']
Modifiability,". b = MemoryDef(a); c = MemoryDef(b); d = MemoryDef(c). ``d`` is connected directly with ``c`` and indirectly with ``b``.; This means that ``d`` potentially clobbers (see below) ``c`` *or*; ``b`` *or* both. This in turn implies that without the use of `The walker`_,; initially every ``MemoryDef`` clobbers every other ``MemoryDef``. ``MemoryPhi``\ s are ``PhiNode``\ s, but for memory operations. If at any; point we have two (or more) ``MemoryDef``\ s that could flow into a; ``BasicBlock``, the block's top ``MemoryAccess`` will be a; ``MemoryPhi``. As in LLVM IR, ``MemoryPhi``\ s don't correspond to any; concrete operation. As such, ``BasicBlock``\ s are mapped to ``MemoryPhi``\ s; inside ``MemorySSA``, whereas ``Instruction``\ s are mapped to ``MemoryUse``\ s; and ``MemoryDef``\ s. Note also that in SSA, Phi nodes merge must-reach definitions (that is,; definitions that *must* be new versions of variables). In MemorySSA, PHI nodes; merge may-reach definitions (that is, until disambiguated, the versions that; reach a phi node may or may not clobber a given variable). ``MemoryUse``\ s are operations which use but don't modify memory. An example of; a ``MemoryUse`` is a ``load``, or a ``readonly`` function call. Every function that exists has a special ``MemoryDef`` called ``liveOnEntry``.; It dominates every ``MemoryAccess`` in the function that ``MemorySSA`` is being; run on, and implies that we've hit the top of the function. It's the only; ``MemoryDef`` that maps to no ``Instruction`` in LLVM IR. Use of; ``liveOnEntry`` implies that the memory being used is either undefined or; defined before the function begins. An example of all of this overlaid on LLVM IR (obtained by running ``opt; -passes='print<memoryssa>' -disable-output`` on an ``.ll`` file) is below. When; viewing this example, it may be helpful to view it in terms of clobbers.; The operands of a given ``MemoryAccess`` are all (potential) clobbers of said; ``MemoryAccess``, and the value produced by a ``Mem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:3601,variab,variable,3601,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['variab'],['variable']
Modifiability,". clang -O2 -mllvm -opt-bisect-limit=256 my_file.c. The -opt-bisect-limit option may also be applied to link-time optimizations by; using a prefix to indicate that this is a plug-in option for the linker. The; following syntax will set a bisect limit for LTO transformations:. ::. # When using lld, or ld64 (macOS); clang -flto -Wl,-mllvm,-opt-bisect-limit=256 my_file.o my_other_file.o; # When using Gold; clang -flto -Wl,-plugin-opt,-opt-bisect-limit=256 my_file.o my_other_file.o. LTO passes are run by a library instance invoked by the linker. Therefore any; passes run in the primary driver compilation phase are not affected by options; passed via '-Wl,-plugin-opt' and LTO passes are not affected by options; passed to the driver-invoked LLVM invocation via '-mllvm'. Passing ``-opt-bisect-print-ir-path=path/foo.ll`` will dump the IR to; ``path/foo.ll`` when -opt-bisect-limit starts skipping passes. Bisection Index Values; ======================. The granularity of the optimizations associated with a single index value is; variable. Depending on how the optimization pass has been instrumented the; value may be associated with as much as all transformations that would have; been performed by an optimization pass on an IR unit for which it is invoked; (for instance, during a single call of runOnFunction for a FunctionPass) or as; little as a single transformation. The index values may also be nested so that; if an invocation of the pass is not skipped individual transformations within; that invocation may still be skipped. The order of the values assigned is guaranteed to remain stable and consistent; from one run to the next up to and including the value specified as the limit.; Above the limit value skipping of optimizations can cause a change in the; numbering, but because all optimizations above the limit are skipped this; is not a problem. When an opt-bisect index value refers to an entire invocation of the run; function for a pass, the pass will query whether or not",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst:3589,variab,variable,3589,interpreter/llvm-project/llvm/docs/OptBisect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst,1,['variab'],['variable']
Modifiability,". class A <dag d> {; dag the_dag = d;; }. def rec1 : A<(ops rec1)>;. The DAG ``(ops rec1)`` is passed as a template argument to class ``A``. Notice; that the DAG includes ``rec1``, the record being defined. The steps taken to create a new record are somewhat complex. See `How; records are built`_. See `Examples: classes and records`_ for examples. Examples: classes and records; -----------------------------. Here is a simple TableGen file with one class and two record definitions. .. code-block:: text. class C {; bit V = true;; }. def X : C;; def Y : C {; let V = false;; string Greeting = ""Hello!"";; }. First, the abstract class ``C`` is defined. It has one field named ``V``; that is a bit initialized to true. Next, two records are defined, derived from class ``C``; that is, with ``C``; as their parent class. Thus they both inherit the ``V`` field. Record ``Y``; also defines another string field, ``Greeting``, which is initialized to; ``""Hello!""``. In addition, ``Y`` overrides the inherited ``V`` field,; setting it to false. A class is useful for isolating the common features of multiple records in; one place. A class can initialize common fields to default values, but; records inheriting from that class can override the defaults. TableGen supports the definition of parameterized classes as well as; nonparameterized ones. Parameterized classes specify a list of variable; declarations, which may optionally have defaults, that are bound when the; class is specified as a parent class of another class or record. .. code-block:: text. class FPFormat <bits<3> val> {; bits<3> Value = val;; }. def NotFP : FPFormat<0>;; def ZeroArgFP : FPFormat<1>;; def OneArgFP : FPFormat<2>;; def OneArgFPRW : FPFormat<3>;; def TwoArgFP : FPFormat<4>;; def CompareFP : FPFormat<5>;; def CondMovFP : FPFormat<6>;; def SpecialFP : FPFormat<7>;. The purpose of the ``FPFormat`` class is to act as a sort of enumerated; type. It provides a single field, ``Value``, which holds a 3-bit number. Its; te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:29693,inherit,inherited,29693,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherited']
Modifiability,". code-block:: c++. /// ExprAST - Base class for all expression nodes.; class ExprAST {; public:; virtual ~ExprAST() = default;; };. /// NumberExprAST - Expression class for numeric literals like ""1.0"".; class NumberExprAST : public ExprAST {; double Val;. public:; NumberExprAST(double Val) : Val(Val) {}; };. The code above shows the definition of the base ExprAST class and one; subclass which we use for numeric literals. The important thing to note; about this code is that the NumberExprAST class captures the numeric; value of the literal as an instance variable. This allows later phases; of the compiler to know what the stored numeric value is. Right now we only create the AST, so there are no useful accessor; methods on them. It would be very easy to add a virtual method to pretty; print the code, for example. Here are the other expression AST node; definitions that we'll use in the basic form of the Kaleidoscope; language:. .. code-block:: c++. /// VariableExprAST - Expression class for referencing a variable, like ""a"".; class VariableExprAST : public ExprAST {; std::string Name;. public:; VariableExprAST(const std::string &Name) : Name(Name) {}; };. /// BinaryExprAST - Expression class for a binary operator.; class BinaryExprAST : public ExprAST {; char Op;; std::unique_ptr<ExprAST> LHS, RHS;. public:; BinaryExprAST(char Op, std::unique_ptr<ExprAST> LHS,; std::unique_ptr<ExprAST> RHS); : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {}; };. /// CallExprAST - Expression class for function calls.; class CallExprAST : public ExprAST {; std::string Callee;; std::vector<std::unique_ptr<ExprAST>> Args;. public:; CallExprAST(const std::string &Callee,; std::vector<std::unique_ptr<ExprAST>> Args); : Callee(Callee), Args(std::move(Args)) {}; };. This is all (intentionally) rather straight-forward: variables capture; the variable name, binary operators capture their opcode (e.g. '+'), and; calls capture a function name as well as a list of any argument; expressions. On",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:2513,variab,variable,2513,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['variab'],['variable']
Modifiability,". note::. ``-steens-aa`` is available in the optional ""poolalloc"" module. It is not part; of the LLVM core. The ``-ds-aa`` pass; ^^^^^^^^^^^^^^^^^^^. The ``-ds-aa`` pass implements the full Data Structure Analysis algorithm. Data; Structure Analysis is a modular unification-based, flow-insensitive,; context-**sensitive**, and speculatively field-**sensitive** alias; analysis that is also quite scalable, usually at ``O(n * log(n))``. This algorithm is capable of responding to a full variety of alias analysis; queries, and can provide context-sensitive mod/ref information as well. The; only major facility not implemented so far is support for must-alias; information. .. note::. ``-ds-aa`` is available in the optional ""poolalloc"" module. It is not part of; the LLVM core. The ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables than other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, which implements Aggressive Dead Code Elimination uses the; ``AliasAnalysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias inform",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:27048,variab,variables,27048,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['variab'],['variables']
Modifiability,". plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19390,plugin,plugin,19390,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['plugin'],['plugin']
Modifiability,". run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [install:epsmac]. M is entirely based on double precision. The actual floating point; precision of double precision (32–bit or 64–bit) is platform dependent; and can even vary on the same platform, depending on whether a f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:25729,variab,variable,25729,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,2,['variab'],['variable']
Modifiability,". scan-build: running the analyzer from the command line. scan-build: running the analyzer from the command line. What is it?; scan-build is a command line utility that enables a user to run the; static analyzer over their codebase as part of performing a regular build (from; the command line).; How does it work?; During a project build, as source files are compiled they are also analyzed; in tandem by the static analyzer.; Upon completion of the build, results are then presented to the user within a; web browser.; Will it work with any build system?; scan-build has little or no knowledge about how you build your code.; It works by overriding the CC and CXX environment variables to; (hopefully) change your build to use a ""fake"" compiler instead of the; one that would normally build your project. This fake compiler executes either; clang or gcc (depending on the platform) to compile your; code and then executes the static analyzer to analyze your code.; This ""poor man's interposition"" works amazingly well in many cases; and falls down in others. Please consult the information on this page on making; the best use of scan-build, which includes getting it to work when the; aforementioned hack fails to work. Viewing static analyzer results in a web browser. Contents. Getting Started. Basic Usage; For Windows Users; Other Options; Output of scan-build. Recommended Usage Guidelines. Always Analyze a Project in its ""Debug"" Configuration; Use Verbose Output when Debugging scan-build; Run './configure' through scan-build. Analyzing iPhone Projects. Getting Started; The scan-build command can be used to analyze an entire project by; essentially interposing on a project's build process. This means that to run the; analyzer using scan-build, you will use scan-build to analyze; the source files compiled by gcc/clang during a project build.; This means that any files that are not compiled will also not be analyzed.; Basic Usage; Basic usage of scan-build is designed to be simple: j",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:678,variab,variables,678,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['variab'],['variables']
Modifiability,". template class C<int>; // A; C<char> var; // B. templateSpecializationType() matches the type of the explicit; instantiation in A and the type of the variable declaration in B. Matcher<Type>templateTypeParmTypeMatcher<TemplateTypeParmType>...; Matches template type parameter types. Example matches T, but not int.; (matcher = templateTypeParmType()); template <typename T> void f(int i);. Matcher<Type>typeMatcher<Type>...; Matches Types in the clang AST. Matcher<Type>typedefTypeMatcher<TypedefType>...; Matches typedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53066,variab,variable,53066,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,". void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const char *path) {; int fd = open(path, O_CREAT);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void test() {; void *p = malloc(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = calloc(0, 42); // warn: allocation size of 0 bytes; }. void test() {; void *p = malloc(1);; p = realloc(p, 0); // warn: allocation size of 0 bytes; }. void test() {; void *p = alloca(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = valloc(0); // warn: allocation size of 0 bytes; }. unix.Malloc; (C); Check for memory leaks, double free, and use-after-free and offset problems; involving malloc. void test() {; int *p = malloc(1);; free(p);; free(p); // warn: attempt to free released memory; }. void test() {; int *p = malloc(sizeof(int));; free(p);; *p = 1; // warn: use after free; }. void test() {; int *p = malloc(1);; if (p); return; // warn: memory is never released; }. void test() {; int a[] = { 1 };; free(a); // warn: argument is not allocated by malloc; }. void test() {; int *p = malloc(sizeof(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:23751,variab,variable,23751,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['variab'],['variable']
Modifiability,".*""); set(LD_V_OUTPUT); execute_process(; COMMAND sh -c ""${CMAKE_LINKER} -v 2>&1 | head -1""; RESULT_VARIABLE HAD_ERROR; OUTPUT_VARIABLE LD_V_OUTPUT; ); if (HAD_ERROR); message(FATAL_ERROR ""${CMAKE_LINKER} failed with status ${HAD_ERROR}""); endif(); if (""${LD_V_OUTPUT}"" MATCHES "".*ld64-([0-9.]+).*""); string(REGEX REPLACE "".*ld64-([0-9.]+).*"" ""\\1"" HOST_LINK_VERSION ${LD_V_OUTPUT}); elseif (""${LD_V_OUTPUT}"" MATCHES ""[^0-9]*([0-9.]+).*""); string(REGEX REPLACE ""[^0-9]*([0-9.]+).*"" ""\\1"" HOST_LINK_VERSION ${LD_V_OUTPUT}); endif(); message(STATUS ""Host linker version: ${HOST_LINK_VERSION}""); endif(). include(CMakeParseArguments); include(AddClang). set(CMAKE_INCLUDE_CURRENT_DIR ON). include_directories(BEFORE; ${CMAKE_CURRENT_BINARY_DIR}/include; ${CMAKE_CURRENT_SOURCE_DIR}/include; ). if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY); install(DIRECTORY include/clang include/clang-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT clang-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""config.h"" EXCLUDE; ). install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/include/clang; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT clang-headers; FILES_MATCHING; PATTERN ""CMakeFiles"" EXCLUDE; PATTERN ""*.inc""; PATTERN ""*.h""; ). # Installing the headers needs to depend on generating any public; # tablegen'd headers.; add_custom_target(clang-headers DEPENDS clang-tablegen-targets); set_target_properties(clang-headers PROPERTIES FOLDER ""Misc""); if(NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-clang-headers; DEPENDS clang-headers; COMPONENT clang-headers); endif(). add_custom_target(bash-autocomplete DEPENDS utils/bash-autocomplete.sh); install(FILES utils/bash-autocomplete.sh; DESTINATION ""${CMAKE_INSTALL_DATADIR}/clang""; COMPONENT bash-autocomplete); if(NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-bash-autocomplete; DEPENDS bash-autocomplete; COMPONENT bash-autocomplete); endif(); endif(). option(CLANG_BUILD_TOOLS; ""Build the Clang tools. If OFF, just generate b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:13959,config,config,13959,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['config'],['config']
Modifiability,".++++++++; ........... .......++++++++; ......... ........+++++++; ......... ........+++++++; ......... ....+++++++; ........ ...+++++++; ....... ...+++++++; ....+++++++; .....+++++++; ....+++++++; ....+++++++; ....+++++++; Evaluated to 0.000000; ready> ^D. At this point, you may be starting to realize that Kaleidoscope is a; real and powerful language. It may not be self-similar :), but it can be; used to plot things that are!. With this, we conclude the ""adding user-defined operators"" chapter of; the tutorial. We have successfully augmented our language, adding the; ability to extend the language in the library, and we have shown how; this can be used to build a simple but interesting end-user application; in Kaleidoscope. At this point, Kaleidoscope can build a variety of; applications that are functional and can call functions with; side-effects, but it can't actually define and mutate a variable itself. Strikingly, variable mutation is an important feature of some languages,; and it is not at all obvious how to `add support for mutable; variables <LangImpl07.html>`_ without having to add an ""SSA construction""; phase to your front-end. In the next chapter, we will describe how you; can add variable mutation without building SSA in your front-end. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; the support for user-defined operators. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. On some platforms, you will need to specify -rdynamic or; -Wl,--export-dynamic when linking. This ensures that symbols defined in; the main executable are exported to the dynamic linker and so are; available for symbol resolution at run time. This is not needed if you; compile your support code into a shared library, although doing that; will cause problems on Windows. Here is the code:. .. li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:26391,variab,variable,26391,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,2,['variab'],"['variable', 'variables']"
Modifiability,".. Clang documentation master file, created by; sphinx-quickstart on Sun Dec 9 20:01:55 2012.; You can adapt this file completely to your liking, but it should at least; contain the root `toctree` directive. .. title:: Welcome to Clang's documentation!. .. toctree::; :maxdepth: 1. ReleaseNotes. Using Clang as a Compiler; =========================. .. toctree::; :maxdepth: 1. UsersManual; Toolchain; LanguageExtensions; ClangCommandLineReference; AttributeReference; DiagnosticsReference; CrossCompilation; ClangStaticAnalyzer; ThreadSafetyAnalysis; DataFlowAnalysisIntro; AddressSanitizer; ThreadSanitizer; MemorySanitizer; UndefinedBehaviorSanitizer; DataFlowSanitizer; LeakSanitizer; SanitizerCoverage; SanitizerStats; SanitizerSpecialCaseList; BoundsSafety; BoundsSafetyImplPlans; ControlFlowIntegrity; LTOVisibility; SafeStack; ShadowCallStack; SourceBasedCodeCoverage; StandardCPlusPlusModules; Modules; MSVCCompatibility; MisExpect; OpenCLSupport; OpenMPSupport; SYCLSupport; HIPSupport; HLSL/HLSLDocs; ThinLTO; APINotes; DebuggingCoroutines; AMDGPUSupport; CommandGuide/index; FAQ. Using Clang as a Library; ========================. .. toctree::; :maxdepth: 1. Tooling; ExternalClangExamples; IntroductionToTheClangAST; LibTooling; LibClang; LibFormat; ClangPlugins; RAVFrontendAction; LibASTMatchersTutorial; LibASTMatchers; ClangTransformerTutorial; LibASTImporter; HowToSetupToolingForLLVM; JSONCompilationDatabase; RefactoringEngine. Using Clang Tools; =================. .. toctree::; :maxdepth: 1. ClangTools; ClangCheck; ClangFormat; ClangFormatStyleOptions; ClangFormattedStatus; ClangLinkerWrapper; ClangOffloadBundler; ClangOffloadPackager; ClangRepl. Design Documents; ================. .. toctree::; :maxdepth: 1. CodeOwners; InternalsManual; DriverInternals; Multilib; OffloadingDesign; PCHInternals; ItaniumMangleAbiTags; HardwareAssistedAddressSanitizerDesign.rst; ConstantInterpreter. Indices and tables; ==================. * :ref:`genindex`; * :ref:`search`. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/index.rst:103,adapt,adapt,103,interpreter/llvm-project/clang/docs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/index.rst,1,['adapt'],['adapt']
Modifiability,".. FIXME: Introduce link to ASTMatchersCookbook.html. Writing your own matchers; -------------------------. There are multiple different ways to define a matcher, depending on its type; and flexibility. ``VariadicDynCastAllOfMatcher<Base, Derived>``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Those match all nodes of type *Base* if they can be dynamically casted to; *Derived*. The names of those matchers are nouns, which closely resemble; *Derived*. ``VariadicDynCastAllOfMatchers`` are the backbone of the matcher; hierarchy. Most often, your match expression will start with one of them, and; you can :ref:`bind <astmatchers-bind>` the node they represent to ids for later; processing. ``VariadicDynCastAllOfMatchers`` are callable classes that model variadic; template functions in C++03. They take an arbitrary number of; ``Matcher<Derived>`` and return a ``Matcher<Base>``. ``AST_MATCHER_P(Type, Name, ParamType, Param)``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Most matcher definitions use the matcher creation macros. Those define both; the matcher of type ``Matcher<Type>`` itself, and a matcher-creation function; named *Name* that takes a parameter of type *ParamType* and returns the; corresponding matcher. There are multiple matcher definition macros that deal with polymorphic return; values and different parameter counts. See `ASTMatchersMacros.h; <https://clang.llvm.org/doxygen/ASTMatchersMacros_8h.html>`_. .. _astmatchers-writing:. Matcher creation functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Matchers are generated by nesting calls to matcher creation functions. Most of; the time those functions are either created by using; ``VariadicDynCastAllOfMatcher`` or the matcher creation macros (see below).; The free-standing functions are an indication that this matcher is just a; combination of other matchers, as is for example the case with `callee; <LibASTMatchersReference.html#callee1Anchor>`_. .. FIXME: ""... macros (see below)"" --- there isn't anything below. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:5387,polymorphi,polymorphic,5387,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst,1,['polymorphi'],['polymorphic']
Modifiability,".. FIXME: move to the stylesheet or Sphinx plugin. .. raw:: html. <style>; .arc-term { font-style: italic; font-weight: bold; }; .revision { font-style: italic; }; .when-revised { font-weight: bold; font-style: normal; }. /*; * Automatic numbering is described in this article:; * https://dev.opera.com/articles/view/automatic-numbering-with-css-counters/; */; /*; * Automatic numbering for the TOC.; * This is wrong from the semantics point of view, since it is an ordered; * list, but uses ""ul"" tag.; */; div#contents.contents.local ul {; counter-reset: toc-section;; list-style-type: none;; }; div#contents.contents.local ul li {; counter-increment: toc-section;; background: none; // Remove bullets; }; div#contents.contents.local ul li a.reference:before {; content: counters(toc-section, ""."") "" "";; }. /* Automatic numbering for the body. */; body {; counter-reset: section subsection subsubsection;; }; .section h2 {; counter-reset: subsection subsubsection;; counter-increment: section;; }; .section h2 a.toc-backref:before {; content: counter(section) "" "";; }; .section h3 {; counter-reset: subsubsection;; counter-increment: subsection;; }; .section h3 a.toc-backref:before {; content: counter(section) ""."" counter(subsection) "" "";; }; .section h4 {; counter-increment: subsubsection;; }; .section h4 a.toc-backref:before {; content: counter(section) ""."" counter(subsection) ""."" counter(subsubsection) "" "";; }; </style>. .. role:: arc-term; .. role:: revision; .. role:: when-revised. ==============================================; Objective-C Automatic Reference Counting (ARC); ==============================================. .. contents::; :local:. .. _arc.meta:. About this document; ===================. .. _arc.meta.purpose:. Purpose; -------. The first and primary purpose of this document is to serve as a complete; technical specification of Automatic Reference Counting. Given a core; Objective-C compiler and runtime, it should be possible to write a compiler and; runtime which ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:43,plugin,plugin,43,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['plugin'],['plugin']
Modifiability,".. _amdgpu-dwarf-extensions-for-heterogeneous-debugging:. ********************************************; DWARF Extensions For Heterogeneous Debugging; ********************************************. .. contents::; :local:. .. warning::. This document describes **provisional extensions** to DWARF Version 5; [:ref:`DWARF <amdgpu-dwarf-DWARF>`] to support heterogeneous debugging. It is; not currently fully implemented and is subject to change. .. _amdgpu-dwarf-introduction:. 1. Introduction; ===============. AMD [:ref:`AMD <amdgpu-dwarf-AMD>`] has been working on supporting heterogeneous; computing. A heterogeneous computing program can be written in a high level; language such as C++ or Fortran with OpenMP pragmas, OpenCL, or HIP (a portable; C++ programming environment for heterogeneous computing [:ref:`HIP; <amdgpu-dwarf-HIP>`]). A heterogeneous compiler and runtime allows a program to; execute on multiple devices within the same native process. Devices could; include CPUs, GPUs, DSPs, FPGAs, or other special purpose accelerators.; Currently HIP programs execute on systems with CPUs and GPUs. The AMD [:ref:`AMD <amdgpu-dwarf-AMD>`] ROCm platform [:ref:`AMD-ROCm; <amdgpu-dwarf-AMD-ROCm>`] is an implementation of the industry standard for; heterogeneous computing devices defined by the Heterogeneous System Architecture; (HSA) Foundation [:ref:`HSA <amdgpu-dwarf-HSA>`]. It is open sourced and; includes contributions to open source projects such as LLVM [:ref:`LLVM; <amdgpu-dwarf-LLVM>`] for compilation and GDB for debugging [:ref:`GDB; <amdgpu-dwarf-GDB>`]. The LLVM compiler has upstream support for commercially available AMD GPU; hardware (AMDGPU) [:ref:`AMDGPU-LLVM <amdgpu-dwarf-AMDGPU-LLVM>`]. The open; source ROCgdb [:ref:`AMD-ROCgdb <amdgpu-dwarf-AMD-ROCgdb>`] GDB based debugger; also has support for AMDGPU which is being upstreamed. Support for AMDGPU is; also being added by third parties to the GCC [:ref:`GCC <amdgpu-dwarf-GCC>`]; compiler and the Perforce TotalView",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:738,portab,portable,738,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['portab'],['portable']
Modifiability,".. _amdgpu-dwarf-lexical-block-entries:. A.3.5 Lexical Block Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section is the same as DWARF Version 5 section 3.5. A.4 Data Object and Object List Entries; ---------------------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 4 sections. .. _amdgpu-dwarf-data-object-entries:. A.4.1 Data Object Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~. Program variables, formal parameters and constants are represented by debugging; information entries with the tags ``DW_TAG_variable``,; ``DW_TAG_formal_parameter`` and ``DW_TAG_constant``, respectively. *The tag DW_TAG_constant is used for languages that have true named constants.*. The debugging information entry for a program variable, formal parameter or; constant may have the following attributes:. 1. A ``DW_AT_location`` attribute, whose value is a DWARF expression E that; describes the location of a variable or parameter at run-time. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language thread of execution upon which; the user is focused, if any. The result of the evaluation is the location; description of the base of the data object. See :ref:`amdgpu-dwarf-control-flow-operations` for special evaluation rules; used by the ``DW_OP_call*`` operations. .. note::. Delete the description of how the ``DW_OP_call*`` operations evaluate a; ``DW_AT_location`` attribute as that is now described in the operations. .. note::. See the discussion about the ``DW_AT_location`` attribute in the; ``DW_OP_call*`` operation. Having each attribute only have a single; purpose and single execution semantics seems desirable. It makes it easier; for the co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:172867,variab,variable,172867,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability,".. _amdgpu_synid_src1_sel:. src1_sel; ~~~~~~~~. Controls which bits in the src1 are used. By default, all bits are used. ======================================== ================================================; Syntax Description; ======================================== ================================================; src1_sel:DWORD Use bits 31:0.; src1_sel:BYTE_0 Use bits 7:0.; src1_sel:BYTE_1 Use bits 15:8.; src1_sel:BYTE_2 Use bits 23:16.; src1_sel:BYTE_3 Use bits 31:24.; src1_sel:WORD_0 Use bits 15:0.; src1_sel:WORD_1 Use bits 31:16.; ======================================== ================================================. .. _amdgpu_synid_sdwa_operand_modifiers:. SDWA Operand Modifiers; ----------------------. Operand modifiers are not used separately. They are applied to source operands. abs; ~~~. See a description :ref:`here<amdgpu_synid_abs>`. neg; ~~~. See a description :ref:`here<amdgpu_synid_neg>`. .. _amdgpu_synid_sext:. sext; ~~~~. Sign-extends the value of a (sub-dword) integer operand to fill all 32 bits. Valid for integer operands only. ======================================== ================================================; Syntax Description; ======================================== ================================================; sext(<operand>) Sign-extend operand value.; ======================================== ================================================. Examples:. .. parsed-literal::. sext(v4); sext(v255). VOP3 Modifiers; --------------. .. _amdgpu_synid_vop3_op_sel:. op_sel; ~~~~~~. Selects the low [15:0] or high [31:16] operand bits for source and destination operands.; By default, low bits are used for all operands. The number of values specified with the op_sel modifier must match the number of instruction; operands (both source and destination). The first value controls src0, the second value controls src1; and so on, except that the last value controls destination.; The value 0 selects the low bits, while 1 selects the high bit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst:50379,extend,extends,50379,interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,1,['extend'],['extends']
Modifiability,".. _classes:. Classes; =======. Both Python and C++ support object-oriented code through classes and thus; it is logical to expose C++ classes as Python ones, including the full; inheritance hierarchy. The C++ code used for the examples below can be found; :doc:`here <cppyy_features_header>`, and it is assumed that that code is; loaded at the start of any session.; Download it, save it under the name ``features.h``, and load it:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('features.h'); >>>. `Basics`; --------. All bound C++ code starts off from the global C++ namespace, represented in; Python by ``gbl``.; This namespace, as any other namespace, is treated as a module after it has; been loaded.; Thus, we can import C++ classes that live underneath it:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> Concrete; <class cppyy.gbl.Concrete at 0x2058e30>; >>>. Placing classes in the same structure as imposed by C++ guarantees identity,; even if multiple Python modules bind the same class.; There is, however, no necessity to expose that structure to end-users: when; developing a Python package that exposes C++ classes through ``cppyy``,; consider ``cppyy.gbl`` an ""internal"" module, and expose the classes in any; structure you see fit.; The C++ names will continue to follow the C++ structure, however, as is needed; for e.g. pickling:. .. code-block:: python. >>> from cppyy.gbl import Namespace; >>> Concrete == Namespace.Concrete; False; >>> n = Namespace.Concrete.NestedClass(); >>> type(n); <class cppyy.gbl.Namespace.Concrete.NestedClass at 0x22114c0>; >>> type(n).__name__; NestedClass; >>> type(n).__module__; cppyy.gbl.Namespace.Concrete; >>> type(n).__cpp_name__; Namespace::Concrete::NestedClass; >>>. `Constructors`; --------------. Python and C++ both make a distinction between allocation (``__new__`` in; Python, ``operator new`` in C++) and initialization (``__init__`` in Python,; the constructor call in C++).; When binding, however, ther",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:179,inherit,inheritance,179,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['inherit'],['inheritance']
Modifiability,".. _cuda:. CUDA support; ============. .. warning::. This is an **experimental** feature, available starting with release; 2.3.0.; It is still incomplete and has only been tested on Linux on x86_64. CUDA is supported by passing all JITed code through two pipelines: one for the; CPU and one for the GPU.; Use of the ``__CUDA__`` pre-processor macro enables more fine-grained control; over which pipeline sees what, which is used e.g. in the pre-compiled header:; the GPU pipeline has the CUDA headers included, the CPU pipeline does not.; Building the pre-compiled header will also pick up common CUDA libraries such; as cuBLAS, if installed. Each version of CUDA requires specific versions of Clang and the system; compiler (e.g. gcc) for proper functioning; it's therefore best to build the; backend (``cppyy-cling``) from source for the specific combination of; interest.; The 3.x series of cppyy uses Clang13, the 2.x series Clang9, and this may; limit the CUDA versions supported (especially since CUDA has changed the APIs; for launching kernels in v11). There are three environment variables to control Cling's handling of CUDA:. * ``CLING_ENABLE_CUDA`` (required): set to ``1`` to enable the CUDA; backend. * ``CLING_CUDA_PATH`` (optional): set to the local CUDA installation if not; in a standard location. * ``CLING_CUDA_ARCH`` (optional): set the architecture to target; default is; ``sm_35`` (Clang9 is limited to ``sm_75``). After enabling CUDA with ``CLING_ENABLE_CUDA=1`` CUDA code can be used and; kernels can be launched from JITed code by in ``cppyy.cppdef()``.; There is currently no syntax or helpers yet to launch kernels from Python.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cuda.rst:1089,variab,variables,1089,bindings/pyroot/cppyy/cppyy/doc/source/cuda.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cuda.rst,1,['variab'],['variables']
Modifiability,".. _features:. Miscellaneous; =============. .. toctree::; :hidden:. cppyy_features_header. This is a collection of a few more features listed that do not have a proper; place yet in the rest of the documentation. The C++ code used for the examples below can be found; :doc:`here <cppyy_features_header>`, and it is assumed that that code is; loaded at the start of any session.; Download it, save it under the name ``features.h``, and load it:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('features.h'); >>>. `Special variables`; -------------------. There are several conventional ""special variables"" that control behavior of; functions or provide (internal) information.; Often, these can be set/used in pythonizations to handle memory management or; Global Interpreter Lock (GIL) release. * ``__python_owns__``: a flag that every bound instance carries and determines; whether Python or C++ owns the C++ instance (and associated memory).; If Python owns the instance, it will be destructed when the last Python; reference to the proxy disappears.; You can check/change the ownership with the __python_owns__ flag that every; bound instance carries.; Example:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> c = Concrete(); >>> c.__python_owns__ # True: object created in Python; True; >>>. * ``__creates__``: a flag that every C++ overload carries and determines; whether the return value is owned by C++ or Python: if ``True``, Python owns; the return value, otherwise C++. * ``__set_lifeline__``: a flag that every C++ overload carries and determines; whether the return value should place a back-reference on ``self``, to; prevent the latter from going out of scope before the return value does.; The default is ``False``, but will be automatically set at run-time if a; return value's address is a C++ object pointing into the memory of ``this``,; or if ``self`` is a by-value return. * ``__release_gil__``: a flag that every C++ overload carries and determine",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/misc.rst:535,variab,variables,535,bindings/pyroot/cppyy/cppyy/doc/source/misc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/misc.rst,2,['variab'],['variables']
Modifiability,".. _stl:. STL; ===. Parts of the Standard Template Library (STL), in particular its container; types, are the de facto equivalent of Python's builtin types.; STL is written in C++ and Python bindings of it are fully functional as-is,; but are much more useful when pluggable into idiomatic expressions where; Python builtin containers are expected (e.g. in list contractions). There are two extremes to achieve such drop-in behavior: copy into Python; builtins, so that the Python-side always deals with true Python objects; or; adjust the C++ interfaces to be the same as their Python equivalents.; Neither is very satisfactory: the former is not because of the existence of; global/static variables and return-by-reference.; If only a copy is available, then expected modifications do not propagate.; Copying is also either slow (when copying every time) or memory intensive (if; the results are cached).; Filling out the interfaces may look more appealing, but all operations then; involve C++ function calls, which can be slower than the Python equivalents,; and C++-style error handling. Given that neither choice will satisfy all cases, ``cppyy`` aims to maximize; functionality and minimum surprises based on common use.; Thus, for example, ``std::vector`` grows a pythonistic ``__len__`` method,; but does not lose its C++ ``size`` method.; Passing a Python container through a const reference to a ``std::vector``; will trigger automatic conversion, but such an attempt through a non-const; reference will fail since a non-temporary C++ object is required [#f1]_ to; return any updates/changes. ``std::string`` is almost always converted to Python's ``str`` on function; returns (the exception is return-by-reference when assigning), but not when; its direct use is more likely such as in the case of (global) variables or; when iterating over a ``std::vector<std::string>``. The rest of this section shows examples of how STL containers can be used in; a natural, pythonistic, way. `std::vec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst:691,variab,variables,691,bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,1,['variab'],['variables']
Modifiability,".. _toplevel:. Top Level; =========. cppyy provides a couple of helper functions at the module level that provide; (direct) access to the Cling interpreter (any C++ code is always accessed; through the global namespace ``cppyy.gbl``).; The documentation makes use of these helpers throughout, so they are listed; here first, but their documentation is more conveniently accessible through; the Python interpreter itself, using the ``help()`` function::. $ python; >>> import cppyy; >>> help(cppyy). `Loading C++`; -------------. C++ code can be loaded as text to be JITed, or be compiled ahead of time and; supplied in the form of a shared library.; In the latter case, C++ headers need to be loaded as well to declare; classes, functions, and variables to Cling.; Instead of headers, pre-compiled code can be used; in particular all of the; standard C++ headers and several system headers are pre-compiled at startup.; cppyy provides the following helpers to load C++ code:. * ``cppdef``: direct access to the interpreter.; This function accepts C++ declarations as a string and JITs them (bindings; are not created until actual use).; The code is loaded into the global scope, thus any previously loaded code; is available from one ``cppdef`` call to the next, as are all standard; C++ headers that have been loaded through pre-compiled headers.; Example::. >>> cppyy.cppdef(r""""""\; ... void hello() {; ... std::cout << ""Hello, World!"" << std::endl;; ... }""""""); True; >>> cppyy.gbl.hello(); Hello, World!; >>> . * ``cppexec``: direct access to the interpreter.; This function accepts C++ statements as a string, JITs and executes them.; Just like ``cppdef``, execution is in the global scope and all previously; loaded code is available.; If the statements are declarations, the effect is the same as ``cppdef``,; but ``cppexec`` also accepts executable lines.; Example::. >>> cppyy.cppexec(r""""""std::string hello = ""Hello, World!"";""""""); True; >>> cppyy.cppexec(""std::cout << hello << std::endl;""); He",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/toplevel.rst:744,variab,variables,744,bindings/pyroot/cppyy/cppyy/doc/source/toplevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/toplevel.rst,1,['variab'],['variables']
Modifiability,".. _utilities:. Utilities; =========. The ``cppyy-backend`` package brings in the following utilities to help; with repackaging and redistribution:. * cling-config: for compile time flags; * rootcling and genreflex: for dictionary generation; * cppyy-generator: part of the :doc:`CMake interface <cmake_interface>`. Compiler/linker flags; ---------------------. ``cling-config`` is a small utility to provide access to the as-installed; configuration, such as compiler/linker flags and installation directories, of; other components.; Usage examples::. $ cling-config --help; Usage: cling-config [--cflags] [--cppflags] [--cmake]; $ cling-config --cmake; /usr/local/lib/python2.7/dist-packages/cppyy_backend/cmake. .. _dictionaries:. Dictionaries; ------------. Loading header files or code directly into ``cling`` is fine for interactive; work and smaller packages, but large scale applications benefit from; pre-compiling code, using the automatic class loader, and packaging; dependencies in so-called ""dictionaries."". A `dictionary` is a generated C++ source file containing references to the; header locations used when building (and any additional locations provided),; a set of forward declarations to reduce the need of loading header files, and; a few I/O helper functions.; The name ""dictionary"" is historic: before ``cling`` was used, it contained; the complete generated C++ reflection information, whereas now that is; derived at run-time from the header files.; It is still possible to fully embed header files rather than only storing; their names and search locations, to make the dictionary more self-contained. After generating the dictionary, it should be compiled into a shared library.; This provides additional dependency control: by linking it directly with any; further libraries needed, you can use standard mechanisms such as ``rpath``; to locate those library dependencies.; Alternatively, you can add the additional libraries to load to the mapping; files of the class load",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:157,config,config,157,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,6,['config'],"['config', 'configuration']"
Modifiability,".. code-block:: c++. void bar(float *A, float* B, float K, int start, int end) {; for (int i = start; i < end; ++i); A[i] *= B[i] + K;; }. Runtime Checks of Pointers; ^^^^^^^^^^^^^^^^^^^^^^^^^^. In the example below, if the pointers A and B point to consecutive addresses,; then it is illegal to vectorize the code because some elements of A will be; written before they are read from array B. Some programmers use the 'restrict' keyword to notify the compiler that the; pointers are disjointed, but in our example, the Loop Vectorizer has no way of; knowing that the pointers A and B are unique. The Loop Vectorizer handles this; loop by placing code that checks, at runtime, if the arrays A and B point to; disjointed memory locations. If arrays A and B overlap, then the scalar version; of the loop is executed. .. code-block:: c++. void bar(float *A, float* B, float K, int n) {; for (int i = 0; i < n; ++i); A[i] *= B[i] + K;; }. Reductions; ^^^^^^^^^^. In this example the ``sum`` variable is used by consecutive iterations of; the loop. Normally, this would prevent vectorization, but the vectorizer can; detect that 'sum' is a reduction variable. The variable 'sum' becomes a vector; of integers, and at the end of the loop the elements of the array are added; together to create the correct result. We support a number of different; reduction operations, such as addition, multiplication, XOR, AND and OR. .. code-block:: c++. int foo(int *A, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); sum += A[i] + 5;; return sum;; }. We support floating point reduction operations when `-ffast-math` is used. Inductions; ^^^^^^^^^^. In this example the value of the induction variable ``i`` is saved into an; array. The Loop Vectorizer knows to vectorize induction variables. .. code-block:: c++. void bar(float *A, int n) {; for (int i = 0; i < n; ++i); A[i] = i;; }. If Conversion; ^^^^^^^^^^^^^. The Loop Vectorizer is able to ""flatten"" the IF statement in the code and; generate a single",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:5861,variab,variable,5861,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['variab'],['variable']
Modifiability,".. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interface to Clang, designed for; compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run; from the command-line, it should be executed inside a Visual S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:167648,config,configured,167648,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configured']
Modifiability,".. cppyy documentation master file, created by; sphinx-quickstart on Wed Jul 12 14:35:45 2017.; You can adapt this file completely to your liking, but it should at least; contain the root `toctree` directive. .. meta::; :description: cppyy: Automatic Python-C++ bindings; :keywords: Python, C++, llvm, cling, binding, bindings, automatic bindings, bindings generator, cross-language inheritance, calling C++ from Python, calling Python from C++, high performance, data science. cppyy: Automatic Python-C++ bindings; ====================================. cppyy is an automatic, run-time, Python-C++ bindings generator, for calling; C++ from Python and Python from C++.; Run-time generation enables detailed specialization for higher performance,; lazy loading for reduced memory use in large scale projects, Python-side; cross-inheritance and callbacks for working with C++ frameworks, run-time; template instantiation, automatic object downcasting, exception mapping, and; interactive exploration of C++ libraries.; cppyy delivers this without any language extensions, intermediate languages,; or the need for boiler-plate hand-written code.; For design and performance, see this `PyHPC'16 paper`_, albeit that the; CPython/cppyy performance has been vastly improved since, as well as this; `CAAS presentation`_.; For a quick teaser, see `Jason Turner's`_ introduction video. cppyy is based on `Cling`_, the C++ interpreter, to match Python's dynamism,; interactivity, and run-time behavior.; Consider this session, showing dynamic, interactive, mixing of C++ and Python; features (there are more examples throughout the documentation and in the; `tutorial`_):. .. code-block:: python. >>> import cppyy; >>> cppyy.cppdef(""""""; ... class MyClass {; ... public:; ... MyClass(int i) : m_data(i) {}; ... virtual ~MyClass() {}; ... virtual int add_int(int i) { return m_data + i; }; ... int m_data;; ... };""""""); True; >>> from cppyy.gbl import MyClass; >>> m = MyClass(42); >>> cppyy.cppdef(""""""; ... void sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/index.rst:104,adapt,adapt,104,bindings/pyroot/cppyy/cppyy/doc/source/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/index.rst,3,"['adapt', 'inherit']","['adapt', 'inheritance']"
Modifiability,".. raw:: html. <style type=""text/css"">; .none { background-color: #FFCCCC }; .part { background-color: #FFFF99 }; .good { background-color: #CCFF99 }; </style>. .. role:: none; .. role:: part; .. role:: good. .. contents::; :local:. =============; HIP Support; =============. HIP (Heterogeneous-Compute Interface for Portability) `<https://github.com/ROCm-Developer-Tools/HIP>`_ is; a C++ Runtime API and Kernel Language. It enables developers to create portable applications for; offloading computation to different hardware platforms from a single source code. AMD GPU Support; ===============. Clang provides HIP support on AMD GPUs via the ROCm platform `<https://rocm.docs.amd.com/en/latest/#>`_.; The ROCm runtime forms the base for HIP host APIs, while HIP device APIs are realized through HIP header; files and the ROCm device library. The Clang driver uses the HIPAMD toolchain to compile HIP device code; to AMDGPU ISA via the AMDGPU backend. The compiled code is then bundled and embedded in the host executables. Intel GPU Support; =================. Clang provides partial HIP support on Intel GPUs using the CHIP-Star project `<https://github.com/CHIP-SPV/chipStar>`_.; CHIP-Star implements the HIP runtime over oneAPI Level Zero or OpenCL runtime. The Clang driver uses the HIPSPV; toolchain to compile HIP device code into LLVM IR, which is subsequently translated to SPIR-V via the SPIR-V; backend or the out-of-tree LLVM-SPIRV translator. The SPIR-V is then bundled and embedded into the host executables. .. note::; While Clang does not directly provide HIP support for NVIDIA GPUs and CPUs, these platforms are supported via other means:. - NVIDIA GPUs: HIP support is offered through the HIP project `<https://github.com/ROCm-Developer-Tools/HIP>`_, which provides a header-only library for translating HIP runtime APIs into CUDA runtime APIs. The code is subsequently compiled using NVIDIA's `nvcc`. - CPUs: HIP support is available through the HIP-CPU runtime library `<https://",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:454,portab,portable,454,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['portab'],['portable']
Modifiability,".. raw:: html. <style type=""text/css"">; .none { background-color: #FFCCCC }; .part { background-color: #FFFF99 }; .good { background-color: #CCFF99 }; </style>. .. role:: none; .. role:: part; .. role:: good. .. contents::; :local:. ==============; OpenMP Support; ==============. Clang fully supports OpenMP 4.5, almost all of 5.0 and most of 5.1/2.; Clang supports offloading to X86_64, AArch64, PPC64[LE], NVIDIA GPUs (all models) and AMD GPUs (all models). In addition, the LLVM OpenMP runtime `libomp` supports the OpenMP Tools; Interface (OMPT) on x86, x86_64, AArch64, and PPC64 on Linux, Windows, and macOS.; OMPT is also supported for NVIDIA and AMD GPUs. For the list of supported features from OpenMP 5.0 and 5.1; see `OpenMP implementation details`_ and `OpenMP 51 implementation details`_. General improvements; ====================; - New collapse clause scheme to avoid expensive remainder operations.; Compute loop index variables after collapsing a loop nest via the; collapse clause by replacing the expensive remainder operation with; multiplications and additions. - When using the collapse clause on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:937,variab,variables,937,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['variab'],['variables']
Modifiability,".....+++++++; ....+++++++; ....+++++++; ....+++++++; Evaluated to 0.000000; ready> ^D. At this point, you may be starting to realize that Kaleidoscope is a; real and powerful language. It may not be self-similar :), but it can be; used to plot things that are!. With this, we conclude the ""adding user-defined operators"" chapter of; the tutorial. We have successfully augmented our language, adding the; ability to extend the language in the library, and we have shown how; this can be used to build a simple but interesting end-user application; in Kaleidoscope. At this point, Kaleidoscope can build a variety of; applications that are functional and can call functions with; side-effects, but it can't actually define and mutate a variable itself. Strikingly, variable mutation is an important feature of some languages,; and it is not at all obvious how to `add support for mutable; variables <LangImpl07.html>`_ without having to add an ""SSA construction""; phase to your front-end. In the next chapter, we will describe how you; can add variable mutation without building SSA in your front-end. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; the support for user-defined operators. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. On some platforms, you will need to specify -rdynamic or; -Wl,--export-dynamic when linking. This ensures that symbols defined in; the main executable are exported to the dynamic linker and so are; available for symbol resolution at run time. This is not needed if you; compile your support code into a shared library, although doing that; will cause problems on Windows. Here is the code:. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter6/toy.cpp; :language: c++. `Next: Extending the language: mutable variables / SSA; construction <LangImpl07.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:26670,variab,variable,26670,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,4,"['config', 'enhance', 'variab']","['config', 'enhanced', 'variable', 'variables']"
Modifiability,"......... ..++++++++++++; ++............ ...... ....++++++++++; .............. ...++++++++++; .............. ....+++++++++; .............. .....++++++++; ............. ......++++++++; ........... .......++++++++; ......... ........+++++++; ......... ........+++++++; ......... ....+++++++; ........ ...+++++++; ....... ...+++++++; ....+++++++; .....+++++++; ....+++++++; ....+++++++; ....+++++++; Evaluated to 0.000000; ready> ^D. At this point, you may be starting to realize that Kaleidoscope is a; real and powerful language. It may not be self-similar :), but it can be; used to plot things that are!. With this, we conclude the ""adding user-defined operators"" chapter of; the tutorial. We have successfully augmented our language, adding the; ability to extend the language in the library, and we have shown how; this can be used to build a simple but interesting end-user application; in Kaleidoscope. At this point, Kaleidoscope can build a variety of; applications that are functional and can call functions with; side-effects, but it can't actually define and mutate a variable itself. Strikingly, variable mutation is an important feature of some languages,; and it is not at all obvious how to `add support for mutable; variables <LangImpl07.html>`_ without having to add an ""SSA construction""; phase to your front-end. In the next chapter, we will describe how you; can add variable mutation without building SSA in your front-end. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; the support for user-defined operators. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. On some platforms, you will need to specify -rdynamic or; -Wl,--export-dynamic when linking. This ensures that symbols defined in; the main executable are exported to the dynamic linker and so are; available for symbol reso",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:26362,variab,variable,26362,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['variab'],['variable']
Modifiability,"..; !!!!NOTE!!!!; This file is automatically generated, in part. Do not edit the style options; in this file directly. Instead, modify them in include/clang/Format/Format.h; and run the docs/tools/dump_format_style.py script to update this file. .. raw:: html. <style type=""text/css"">; .versionbadge { background-color: #1c913d; height: 20px; display: inline-block; min-width: 120px; text-align: center; border-radius: 5px; color: #FFFFFF; font-family: ""Verdana,Geneva,DejaVu Sans,sans-serif""; }; </style>. .. role:: versionbadge. ==========================; Clang-Format Style Options; ==========================. :doc:`ClangFormatStyleOptions` describes configurable formatting style options; supported by :doc:`LibFormat` and :doc:`ClangFormat`. When using :program:`clang-format` command line utility or; ``clang::format::reformat(...)`` functions from code, one can either use one of; the predefined styles (LLVM, Google, Chromium, Mozilla, WebKit, Microsoft) or; create a custom style by configuring specific style options. Configuring Style with clang-format; ===================================. :program:`clang-format` supports two ways to provide custom style options:; directly specify style configuration in the ``-style=`` command line option or; use ``-style=file`` and put style configuration in the ``.clang-format`` or; ``_clang-format`` file in the project directory. When using ``-style=file``, :program:`clang-format` for each input file will; try to find the ``.clang-format`` file located in the closest parent directory; of the input file. When the standard input is used, the search is started from; the current directory. When using ``-style=file:<format_file_path>``, :program:`clang-format` for; each input file will use the format file located at `<format_file_path>`.; The path may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:656,config,configurable,656,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,['config'],"['configurable', 'configuring']"
Modifiability,"..; This work is licensed under a Creative Commons Attribution 3.0 Unported License.; SPDX-License-Identifier: CC-BY-3.0. ==============================; LLVM Community Code of Conduct; ==============================. The LLVM community has always worked to be a welcoming and respectful; community, and we want to ensure that doesn't change as we grow and evolve. To; that end, we have a few ground rules that we ask people to adhere to:. * `be friendly and patient`_,; * `be welcoming`_,; * `be considerate`_,; * `be respectful`_,; * `be careful in the words that you choose and be kind to others`_, and; * `when we disagree, try to understand why`_. This isn't an exhaustive list of things that you can't do. Rather, take it in; the spirit in which it's intended - a guide to make it easier to communicate; and participate in the community. This code of conduct applies to all spaces managed by the LLVM project or The; LLVM Foundation. This includes IRC channels, mailing lists, bug trackers, LLVM; events such as the developer meetings and socials, and any other forums created; by the project that the community uses for communication. It applies to all of; your communication and conduct in these spaces, including emails, chats, things; you say, slides, videos, posters, signs, or even t-shirts you display in these; spaces. . In rare cases, violations of this code outside of these spaces may affect a ; person’s ability to participate within these spaces. Important examples ; include `sexual and gender-based violence`_, `hate crimes`_, and `hate speech`_. ; We do not conduct proactive research, but we have an obligation to respond ; to any reported concerns. We are not interested in evaluating severity, ; responding punitively, or holding people accountable. Both the relevance ; and our response is instead focused on how a person’s continued participation ; impacts the community’s safety, wellbeing, and inclusivity. We specifically ; prioritize remaining a welcoming community to v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:357,evolve,evolve,357,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['evolve'],['evolve']
Modifiability,".; * ``strict`` The compiler ensures that all transformations strictly preserve the floating point exception semantics of the original code. .. option:: -ffp-eval-method=<value>. Specify the floating-point evaluation method for intermediate results within; a single expression of the code. Valid values are: ``source``, ``double``, and ``extended``.; For 64-bit targets, the default value is ``source``. For 32-bit x86 targets; however, in the case of NETBSD 6.99.26 and under, the default value is; ``double``; in the case of NETBSD greater than 6.99.26, with NoSSE, the; default value is ``extended``, with SSE the default value is ``source``.; Details:. * ``source`` The compiler uses the floating-point type declared in the source program as the evaluation method.; * ``double`` The compiler uses ``double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``double``.; * ``extended`` The compiler uses ``long double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``long double``. .. option:: -f[no-]protect-parens. This option pertains to floating-point types, complex types with; floating-point components, and vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesized and unparenthesized expression; express the same mathematical value. For example (a+b)+c is the same; mathematical value as a+(b+c), but the optimizer is free to evaluate the; additions in any order regardless of the parentheses. When enabled, this; option forces the optimizer to honor the order of operations with respect; to parentheses in all circumstances.; Defaults to ``-fno-protect-parens``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:64863,extend,extended,64863,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['extend'],['extended']
Modifiability,.; ; DATA AND CATEGORIES. rf401_importttreethx.C -Overview of advanced option for importing data from ROOT TTree and THx histograms; rf402_datahandling.C - Tools for manipulation of (un)binned datasets; rf403_weightedevts.C - Using weights in unbinned datasets; rf404_categories.C - Working with RooCategory objects to describe discrete variables; rf405_realtocatfuncs.C - Demonstration of real-->discrete mapping functions; rf406_cattocatfuncs.C - Demonstration of discrete-->discrete (invertable) functions; rf407_latextables.C - Latex printing of lists and sets of RooArgSets; ; ORGANIZATION AND SIMULTANEOUS FITS. rf501_simultaneouspdf.C - Using simultaneous p.d.f.s to describe simultaneous fits to multiple datasets; rf502_wspacewrite.C - Creating and writing a workspace; rf503_wspaceread.C - Reading and using a workspace; rf504_simwstool.C - Using RooSimWSTool to construct a simultaneous p.d.f that is built of variations of an input p.d.f; rf505_asciicfg.C - Reading and writing ASCII configuration files; rf506_msgservice.C - Tuning and customizing the RooFit message logging facility; rf507_debugtools.C - Using the RooFit memory tracing debug tool; rf508_listsetmanip.C - RooArgSet and RooArgList tools and tricks; ; LIKELIHOOD AND MINIMIZATION. rf601_intminuit.C - Interactive minimization with MINUIT; rf602_chi2fit.C - Setting up a binning chi^2 fit; rf603_multicpu.C - Setting up a multi-core parallelized unbinned maximum likelihood fit; rf604_constraints.C - Fitting with constraints; rf605_profilell.C - Working with the profile likelihood estimator; rf606_nllerrorhandling.C - Understanding and customizing error handling in likelihood evaluations; rf607_fitresult.C - Demonstration of options of the RooFitResult class; ; SPECIAL PDFS. rf701_efficiencyfit.C - Unbinned maximum likelihood fit of an efficiency eff(x) function; rf702_efficiencyfit_2D.C - Unbinned maximum likelihood fit of an efficiency eff(x) function to; rf703_effpdfprod.C - Using a product of an (acceptance),MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:4535,config,configuration,4535,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['config'],['configuration']
Modifiability,".; When JSROOT is used with THttpServer, the address looks like:. ```javascript; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; ```. Loading main module is enough to get public JSROOT functionality - reading files and drawing objects.; One also can load some special components directly like:. ```javascript; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; ```. After script loading one can configure different parameters in `gStyle` object.; It is instance of the `TStyle` object and behaves like `gStyle` variable in ROOT. For instance,; to change stat format using to display value in stats box:. ```javascript; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; ```. There is also `settings` object which contains all other JSROOT settings. For instance,; one can configure custom format for different axes:. ```javascript; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; ```. One also can use `build/jsroot.js` bundle to load all functionality at one and access it via `JSROOT` global handle:. ```javascript; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; ```. ### Use of JSON. It is strongly reco",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:35602,config,configure,35602,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configure']
Modifiability,".bzip2, for; example:. %indvar.next90 = add i64 %indvar89, 1 ;; Has 2 uses; %tmp96 = add i64 %tmp95, 1 ;; Has 1 use; %exitcond97 = icmp eq i64 %indvar.next90, %tmp96. We don't fold this because we don't want to introduce an overlapped live range; of the ivar. However if we can make this more aggressive without causing; performance issues in two ways:. 1. If *either* the LHS or RHS has a single use, we can definitely do the; transformation. In the overlapping liverange case we're trading one register; use for one fewer operation, which is a reasonable trade. Before doing this; we should verify that the llc output actually shrinks for some benchmarks.; 2. If both ops have multiple uses, we can still fold it if the operations are; both sinkable to *after* the icmp (e.g. in a subsequent block) which doesn't; increase register pressure. There are a ton of icmp's we aren't simplifying because of the reg pressure; concern. Care is warranted here though because many of these are induction; variables and other cases that matter a lot to performance, like the above.; Here's a blob of code that you can drop into the bottom of visitICmp to see some; missed cases:. { Value *A, *B, *C, *D;; if (match(Op0, m_Add(m_Value(A), m_Value(B))) && ; match(Op1, m_Add(m_Value(C), m_Value(D))) &&; (A == C || A == D || B == C || B == D)) {; errs() << ""OP0 = "" << *Op0 << "" U="" << Op0->getNumUses() << ""\n"";; errs() << ""OP1 = "" << *Op1 << "" U="" << Op1->getNumUses() << ""\n"";; errs() << ""CMP = "" << I << ""\n\n"";; }; }. //===---------------------------------------------------------------------===//. define i1 @test1(i32 %x) nounwind {; %and = and i32 %x, 3; %cmp = icmp ult i32 %and, 2; ret i1 %cmp; }. Can be folded to (x & 2) == 0. define i1 @test2(i32 %x) nounwind {; %and = and i32 %x, 3; %cmp = icmp ugt i32 %and, 1; ret i1 %cmp; }. Can be folded to (x & 2) != 0. SimplifyDemandedBits shrinks the ""and"" constant to 2 but instcombine misses the; icmp transform. //===------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:64691,variab,variables,64691,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['variab'],['variables']
Modifiability,".cern.ch/jira/browse/ROOT-5971) for a discussion.; As of v6.28, such declarations result in; ```; root [] int data;; ROOT_prompt_0:1:1: warning: 'data' shadows a declaration with the same name in the 'std' namespace; use '::data' to reference this declaration; int data;; ^; ```. - Line editing at the ROOT interactive prompt has been improved. This version introduces useful shortcuts for common actions, e.g. Xterm-like fast movement between words using Ctrl+Left and Ctrl+Right, Ctrl+Del to delete the word under the cursor, or clearing the screen using Ctrl+L. Most users coming from a GUI will find these shortcuts convenient.; A list of the available key bindings is printed by; ```; root [] .help edit; ```. ## I/O Libraries. ### Faster reading from EOS. A new cross-protocol redirection has been added to allow files on EOS mounts to be opened; by `TFile::Open` via XRootD protocol rather than via FUSE when that is possible. The; redirection uses the `eos.url.xroot` extended file attribute that is present on files in EOS.; The attribute can be viewed with `getfattr -n eos.url.xroot [file]` on the command line.; When the URL passed into `TFile::Open` is a for a file on an EOS mount, the extended; attribute is used to attempt the redirection to XRootD protocol. If the redirection fails,; the file is opened using the plain file path as before. This feature is controlled by the; pre-existing configuration option `TFile.CrossProtocolRedirects` and is enabled by default.; It can be disabled by setting `TFile.CrossProtocolRedirects` to `0` in `rootrc`. ## TTree Libraries. ## RNTuple; ROOT's experimental successor of TTree has seen many updates during the last few months. Specifically, v6.28 includes the following changes:. - Complete support for big-endian architectures (PR [#10402](https://github.com/root-project/root/pull/10402)). - Support for `std::pair<T1, T2>` and `std::tuple<Ts...>` fields. - Support for C array fields whose type is of the form `T[N]`. Note that only sing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:7888,extend,extended,7888,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['extend'],['extended']
Modifiability,".cgi?id=9760; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=9759; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=9703; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=9702; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=9663. http://www.inf.u-szeged.hu/gcc-arm/; http://citeseer.ist.psu.edu/debus04linktime.html. //===---------------------------------------------------------------------===//. gcc generates smaller code for this function at -O2 or -Os:. void foo(signed char* p) {; if (*p == 3); bar();; else if (*p == 4); baz();; else if (*p == 5); quux();; }. llvm decides it's a good idea to turn the repeated if...else into a; binary tree, as if it were a switch; the resulting code requires -1; compare-and-branches when *p<=2 or *p==5, the same number if *p==4; or *p>6, and +1 if *p==3. So it should be a speed win; (on balance). However, the revised code is larger, with 4 conditional; branches instead of 3. More seriously, there is a byte->word extend before; each comparison, where there should be only one, and the condition codes; are not remembered when the same two values are compared twice. //===---------------------------------------------------------------------===//. More LSR enhancements possible:. 1. Teach LSR about pre- and post- indexed ops to allow iv increment be merged; in a load / store.; 2. Allow iv reuse even when a type conversion is required. For example, i8; and i32 load / store addressing modes are identical. //===---------------------------------------------------------------------===//. This:. int foo(int a, int b, int c, int d) {; long long acc = (long long)a * (long long)b;; acc += (long long)c * (long long)d;; return (int)(acc >> 32);; }. Should compile to use SMLAL (Signed Multiply Accumulate Long) which multiplies; two signed 32-bit values to produce a 64-bit value, and accumulates this with; a 64-bit value. We currently get this with both v4 and v6:. _foo:; smull r1, r0, r1, r0; smull r3, r2, r3, r2; adds r3, r3, r1; adc r0, r2, r0; bx lr. //===--------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:12173,extend,extend,12173,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['extend'],['extend']
Modifiability,".com/civetweb/civetweb/tree/master/docs/api) - Additional documentation on the civetweb application programming interface ([civetweb.h](https://github.com/civetweb/civetweb/blob/master/include/civetweb.h)).; - [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md) - Release Notes; - [SECURITY.md](https://github.com/civetweb/civetweb/blob/master/SECURITY.md) - Security Policy; - [LICENSE.md](https://github.com/civetweb/civetweb/blob/master/LICENSE.md) - Copyright License. Overview; --------. CivetWeb keeps the balance between functionality and; simplicity by a carefully selected list of features:. - Liberal, commercial-friendly, permissive,; [MIT license](http://en.wikipedia.org/wiki/MIT_License); - Free from copy-left licenses, like GPL, because you should innovate without; restrictions.; - Forked from [Mongoose](https://code.google.com/p/mongoose/) in 2013, before; it changed the licence from MIT to commercial + GPL. A lot of enhancements; have been added since that time, see; [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md).; - Works on Windows, Mac, Linux, UNIX, iPhone, Android, Buildroot, and many; other platforms.; - Scripting and database support (CGI, SQLite database, Lua Server Pages,; Server side Lua scripts, Server side JavaScript).; This provides a ready to go, powerful web development platform in a one; single-click executable with **no dependencies**.0; - Support for CGI, SSI, HTTP digest (MD5) authorization, WebSocket,; WebDAV.; - HTTPS (SSL/TLS) support using [OpenSSL](https://www.openssl.org/).; - Optional support for authentication using client side X.509 certificates.; - Resumed download, URL rewrite, file blacklist, IP-based ACL.; - May run as Windows service.; - Download speed limit based on client subnet or URI pattern.; - Simple and clean embedding API.; - The source is in single file to make things easy.; - Embedding examples included.; - HTTP client capable of sending arbitrar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:5613,enhance,enhancements,5613,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['enhance'],['enhancements']
Modifiability,".cpp. Alternatively, a test name can be specified as the full test name; reported in LIT output. For example, we can adjust the previous; example not to treat the ``nvptx64-nvidia-cuda`` version of; ``offloading/memory_manager.cpp`` as XFAIL:. .. code-block:: none. LIT_XFAIL=""affinity/kmp-hw-subset.c;libomptarget :: x86_64-pc-linux-gnu :: offloading/memory_manager.cpp"". .. option:: --xfail-not=LIST. Do not treat the specified tests as ``XFAIL``. The environment variable; ``LIT_XFAIL_NOT`` can also be used in place of this option. The syntax is the; same as for :option:`--xfail` and ``LIT_XFAIL``. :option:`--xfail-not` and; ``LIT_XFAIL_NOT`` always override all other ``XFAIL`` specifications,; including an :option:`--xfail` appearing later on the command line. The; primary purpose is to suppress an ``XPASS`` result without modifying a test; case that uses the ``XFAIL`` directive. ADDITIONAL OPTIONS; ------------------. .. option:: --debug. Run :program:`lit` in debug mode, for debugging configuration issues and; :program:`lit` itself. .. option:: --show-suites. List the discovered test suites and exit. .. option:: --show-tests. List all of the discovered tests and exit. EXIT STATUS; -----------. :program:`lit` will exit with an exit code of 1 if there are any FAIL or XPASS; results. Otherwise, it will exit with the status 0. Other exit codes are used; for non-test related failures (for example a user error or an internal program; error). .. _test-discovery:. TEST DISCOVERY; --------------. The inputs passed to :program:`lit` can be either individual tests, or entire; directories or hierarchies of tests to run. When :program:`lit` starts up, the; first thing it does is convert the inputs into a complete list of tests to run; as part of *test discovery*. In the :program:`lit` model, every test must exist inside some *test suite*.; :program:`lit` resolves the inputs specified on the command line to test suites; by searching upwards from the input path until it finds a :f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:10479,config,configuration,10479,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['configuration']
Modifiability,".cpp; TimeProfiler.cpp; Timer.cpp; ToolOutputFile.cpp; Twine.cpp; TypeSize.cpp; Unicode.cpp; UnicodeCaseFold.cpp; UnicodeNameToCodepoint.cpp; UnicodeNameToCodepointGenerated.cpp; VersionTuple.cpp; VirtualFileSystem.cpp; WithColor.cpp; YAMLParser.cpp; YAMLTraits.cpp; raw_os_ostream.cpp; raw_ostream.cpp; raw_socket_stream.cpp; regcomp.c; regerror.c; regexec.c; regfree.c; regstrlcpy.c; xxhash.cpp; Z3Solver.cpp. ${ALLOCATOR_FILES}; $<TARGET_OBJECTS:LLVMSupportBlake3>. # System; Atomic.cpp; DynamicLibrary.cpp; Errno.cpp; Memory.cpp; Path.cpp; Process.cpp; Program.cpp; RWMutex.cpp; Signals.cpp; Threading.cpp; Valgrind.cpp; Watchdog.cpp. ADDITIONAL_HEADER_DIRS; Unix; Windows; ${LLVM_MAIN_INCLUDE_DIR}/llvm/ADT; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Support; ${Backtrace_INCLUDE_DIRS}. LINK_LIBS; ${system_libs} ${imported_libs} ${delayload_flags}. LINK_COMPONENTS; Demangle; ). set(llvm_system_libs ${system_libs}). # This block is only needed for llvm-config. When we deprecate llvm-config and; # move to using CMake export, this block can be removed.; if(LLVM_ENABLE_ZLIB); # CMAKE_BUILD_TYPE is only meaningful to single-configuration generators.; if(CMAKE_BUILD_TYPE); string(TOUPPER ${CMAKE_BUILD_TYPE} build_type); get_property(zlib_library TARGET ZLIB::ZLIB PROPERTY LOCATION_${build_type}); endif(); if(NOT zlib_library); get_property(zlib_library TARGET ZLIB::ZLIB PROPERTY LOCATION); endif(); get_library_name(${zlib_library} zlib_library); set(llvm_system_libs ${llvm_system_libs} ""${zlib_library}""); endif(). if(LLVM_ENABLE_ZSTD); # CMAKE_BUILD_TYPE is only meaningful to single-configuration generators.; if(CMAKE_BUILD_TYPE); string(TOUPPER ${CMAKE_BUILD_TYPE} build_type); get_property(zstd_library TARGET ${zstd_target} PROPERTY LOCATION_${build_type}); endif(); if(NOT zstd_library); get_property(zstd_library TARGET ${zstd_target} PROPERTY LOCATION); endif(); get_library_name(${zstd_library} zstd_library); set(llvm_system_libs ${llvm_system_libs} ""${zstd_library}""); endif(). if(LLVM_EN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt:8449,config,config,8449,interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,1,['config'],['config']
Modifiability,.cpp; libc/benchmarks/LibcFunctionPrototypes.h; libc/benchmarks/LibcMemoryBenchmark.cpp; libc/benchmarks/LibcMemoryBenchmark.h; libc/benchmarks/LibcMemoryBenchmarkMain.cpp; libc/benchmarks/LibcMemoryBenchmarkTest.cpp; libc/benchmarks/LibcMemoryGoogleBenchmarkMain.cpp; libc/benchmarks/MemorySizeDistributions.cpp; libc/benchmarks/MemorySizeDistributions.h; libc/benchmarks/automemcpy/include/automemcpy/CodeGen.h; libc/benchmarks/automemcpy/include/automemcpy/FunctionDescriptor.h; libc/benchmarks/automemcpy/include/automemcpy/RandomFunctionGenerator.h; libc/benchmarks/automemcpy/include/automemcpy/ResultAnalyzer.h; libc/benchmarks/automemcpy/lib/CodeGen.cpp; libc/benchmarks/automemcpy/lib/CodeGenMain.cpp; libc/benchmarks/automemcpy/lib/RandomFunctionGenerator.cpp; libc/benchmarks/automemcpy/lib/ResultAnalyzer.cpp; libc/benchmarks/automemcpy/lib/ResultAnalyzerMain.cpp; libc/benchmarks/automemcpy/unittests/CodeGenTest.cpp; libc/benchmarks/automemcpy/unittests/ResultAnalyzerTest.cpp; libc/config/linux/app.h; libc/fuzzing/math/Compare.h; libc/fuzzing/math/math_differential_fuzz.cpp; libc/fuzzing/math/nextafter_differential_fuzz.cpp; libc/fuzzing/math/RemQuoDiff.h; libc/fuzzing/math/SingleInputSingleOutputDiff.h; libc/fuzzing/math/TwoInputSingleOutputDiff.h; libc/fuzzing/stdlib/atof_differential_fuzz.cpp; libc/fuzzing/stdlib/qsort_fuzz.cpp; libc/fuzzing/stdlib/StringParserOutputDiff.h; libc/fuzzing/string/strcmp_fuzz.cpp; libc/fuzzing/string/strstr_fuzz.cpp; libc/include/__llvm-libc-common.h; libc/include/llvm-libc-macros/fcntl-macros.h; libc/include/llvm-libc-macros/stdio-macros.h; libc/include/llvm-libc-macros/linux/fcntl-macros.h; libc/include/llvm-libc-types/cnd_t.h; libc/include/llvm-libc-types/div_t.h; libc/include/llvm-libc-types/double_t.h; libc/include/llvm-libc-types/fenv_t.h; libc/include/llvm-libc-types/fexcept_t.h; libc/include/llvm-libc-types/FILE.h; libc/include/llvm-libc-types/float_t.h; libc/include/llvm-libc-types/imaxdiv_t.h; libc/include/llvm-libc-types/jm,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:130359,config,config,130359,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['config'],['config']
Modifiability,".e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7156,variab,variables,7156,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variables']
Modifiability,".foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've been somewhat vague in our; explanation of what the rewrite rules are actually rewriting. We've referred to; ""code"", but code can be represented both as raw source text and as an abstract; syntax tree. So, which one is it?. Ideally, we'd be rewriting the input AST to a new AST, but clang's AST is not; terribly amenable to this kind of transformation. So, we compromise: we express; our patterns and the names that they bind in terms of the AST, but our changes; in terms of source code text. We've designed Transformer's language to bridge; the gap between the two re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:9016,rewrite,rewrite,9016,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,".g.; $\mbox{MIGRAD}$, $\mbox{MINOS}$, $\mbox{CONTOURS}$), the; corresponding names of the classes are written using sans-serif font; type (MnMigrad, MnMinos, MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs to be written in for which M defines the pure abstract; base class FCNBase as interface. The user must define and implement the; $\mbox{FCN}$ function in a derived class from FCNBase. Sometimes; this is done by an intermediate program such as HippoDraw@bib-HippoDraw,; in which case M is being used under the control of such an intermediate; program[^1]. The value of the $\mbox{FCN}$ function will in general; depend on one or more variable parameters whose meaning is defined by; the user (or by the intermediate program), but whose trial values are; determined by M . To take a simple example, suppose the problem is to fit a polynomial; through a set of data points. Then the user would write a; $\mbox{FCN}$ which calculates the $\chi^2$ between a polynomial and; the data; the variable parameters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the user would request M to minimize the $\mbox{FCN}$ with respect; to the parameters, that is, find those values of the coefficients which; give the lowest value of chisquare. The user must therefore supply, in addition to the function to be; analyzed, via a set or sequence of M applications the instructions which; analysis is wanted. The instructions are coded in in the calling program; (main.cpp), which allows looping, conditional execution, and all the; other possibilities of , but not interactivity, since it must be; compiled before execution. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:2434,variab,variable,2434,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,.h; clang/include/clang/Tooling/Transformer/MatchConsumer.h; clang/include/clang/Tooling/Transformer/Parsing.h; clang/include/clang/Tooling/Transformer/RangeSelector.h; clang/include/clang/Tooling/Transformer/SourceCode.h; clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h; clang/include/clang/Tooling/Transformer/Transformer.h; clang/include/clang-c/ExternC.h; clang/include/clang-c/FatalErrorHandler.h; clang/include/clang-c/Index.h; clang/lib/Analysis/CalledOnceCheck.cpp; clang/lib/Analysis/CloneDetection.cpp; clang/lib/Analysis/CodeInjector.cpp; clang/lib/Analysis/FlowSensitive/ControlFlowContext.cpp; clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp; clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp; clang/lib/Analysis/FlowSensitive/DebugSupport.cpp; clang/lib/Analysis/FlowSensitive/Transfer.cpp; clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp; clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp; clang/lib/Analysis/plugins/CheckerDependencyHandling/CheckerDependencyHandling.cpp; clang/lib/Analysis/plugins/SampleAnalyzer/MainCallChecker.cpp; clang/lib/APINotes/APINotesFormat.h; clang/lib/APINotes/APINotesTypes.cpp; clang/lib/APINotes/APINotesYAMLCompiler.cpp; clang/lib/AST/DataCollection.cpp; clang/lib/AST/Linkage.h; clang/lib/AST/Interp/ByteCodeGenError.cpp; clang/lib/AST/Interp/ByteCodeGenError.h; clang/lib/AST/Interp/Context.cpp; clang/lib/AST/Interp/Context.h; clang/lib/AST/Interp/Descriptor.cpp; clang/lib/AST/Interp/Disasm.cpp; clang/lib/AST/Interp/EvalEmitter.h; clang/lib/AST/Interp/Frame.cpp; clang/lib/AST/Interp/Frame.h; clang/lib/AST/Interp/InterpState.h; clang/lib/AST/Interp/Opcode.h; clang/lib/AST/Interp/Pointer.cpp; clang/lib/AST/Interp/PrimType.cpp; clang/lib/AST/Interp/Record.h; clang/lib/AST/Interp/Source.cpp; clang/lib/AST/Interp/Source.h; clang/lib/AST/Interp/State.cpp; clang/lib/AST/Interp/State.h; clang/lib/ASTMatchers/GtestMatchers.cpp; clang/lib/ASTMatchers/Dynamic/Marshallers.cpp; clang/lib/Ba,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:15402,plugin,plugins,15402,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,.h; openmp/libomptarget/DeviceRTL/include/Types.h; openmp/libomptarget/DeviceRTL/include/Utils.h; openmp/libomptarget/DeviceRTL/src/Configuration.cpp; openmp/libomptarget/DeviceRTL/src/Kernel.cpp; openmp/libomptarget/DeviceRTL/src/Misc.cpp; openmp/libomptarget/DeviceRTL/src/Parallelism.cpp; openmp/libomptarget/DeviceRTL/src/Reduction.cpp; openmp/libomptarget/DeviceRTL/src/State.cpp; openmp/libomptarget/DeviceRTL/src/Synchronization.cpp; openmp/libomptarget/DeviceRTL/src/Tasking.cpp; openmp/libomptarget/DeviceRTL/src/Utils.cpp; openmp/libomptarget/include/Debug.h; openmp/libomptarget/include/device.h; openmp/libomptarget/include/DeviceEnvironment.h; openmp/libomptarget/include/interop.h; openmp/libomptarget/include/omptarget.h; openmp/libomptarget/include/omptargetplugin.h; openmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarg,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:406956,plugin,plugins,406956,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,".h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5590,variab,variable,5590,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,2,['variab'],['variable']
Modifiability,".in ${UNR_UNTARDIR}/config.h); else(); #---Define special compiler settings for unurun-----------------------------------------------------; set(UNR_CC ${CMAKE_C_COMPILER}); if(ROOT_ARCHITECTURE MATCHES hpuxia64acc); set(UNR_CC ""${UNR_CC} +DD64 -Ae""); elseif(ROOT_ARCHITECTURE MATCHES linuxppc64gcc); set(UNR_CC ""${UNR_CC} -m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664gcc); set(UNR_CFLAGS ""-m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxicc); set(UNR_CFLAGS ""-m32""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664icc); set(UNR_CFLAGS ""-m64""); elseif(ROOT_ARCHITECTURE MATCHES win32 OR ROOT_ARCHITECTURE MATCHES win64); set(UNR_CFLAGS ""-MD -G5 -GX""); endif(); if(CMAKE_OSX_SYSROOT); set(UNR_CFLAGS ""${UNR_CFLAGS} -isysroot ${CMAKE_OSX_SYSROOT}""); endif(). #---configure unuran (required for creating the config.h used by unuran source files)----------------; add_custom_command(OUTPUT ${UNR_UNTARDIR}/config.h; COMMAND GNUMAKE=make ./configure CC=${UNR_CC} CFLAGS=${UNR_CFLAGS} > /dev/null 2>& 1; WORKING_DIRECTORY ${UNR_UNTARDIR}); endif(). #---We need to disable some warnings-------------------------------------------------------------------; string(REPLACE -Wall """" CMAKE_C_FLAGS ""${CMAKE_C_FLAGS}""); if(${CMAKE_CXX_COMPILER_ID} MATCHES Clang); ROOT_ADD_C_FLAG(CMAKE_C_FLAGS -Wno-parentheses-equality); ROOT_ADD_C_FLAG(CMAKE_C_FLAGS -Wno-deprecated-non-prototype); endif(); if(${CMAKE_CXX_COMPILER_ID} MATCHES GNU); ROOT_ADD_C_FLAG(CMAKE_C_FLAGS -Wno-maybe-uninitialized); ROOT_ADD_C_FLAG(CMAKE_C_FLAGS -Wno-alloc-size-larger-than). endif(). set(unrsources ${UNR_UNTARDIR}/src/utils/*.c; ${UNR_UNTARDIR}/src/methods/*.c; ${UNR_UNTARDIR}/src/specfunct/*.c; ${UNR_UNTARDIR}/src/distr/*.c; ${UNR_UNTARDIR}/src/distributions/*.c; ${UNR_UNTARDIR}/src/parser/*.c; ${UNR_UNTARDIR}/src/tests/*.c; ${UNR_UNTARDIR}/src/uniform/*.c; ${UNR_UNTARDIR}/src/urng/*.c ); set(unrconfig ${UNR_UNTARDIR}/config.h). else(). set(unrsources); set(unrconfig). endif(builtin_unuran). ROOT_STANDARD_LIBRARY_P",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt:2390,config,configure,2390,math/unuran/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt,1,['config'],['configure']
Modifiability,".insert(Value); (void)NewToSet;; assert(NewToSet && ""The value shouldn't be in the set yet"");. Do Not Use ``using namespace std``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In LLVM, we prefer to explicitly prefix all identifiers from the standard; namespace with an ""``std::``"" prefix, rather than rely on ""``using namespace; std;``"". In header files, adding a ``'using namespace XXX'`` directive pollutes the; namespace of any source file that ``#include``\s the header, creating; maintenance issues. In implementation files (e.g. ``.cpp`` files), the rule is more of a stylistic; rule, but is still important. Basically, using explicit namespace prefixes; makes the code **clearer**, because it is immediately obvious what facilities; are being used and where they are coming from. And **more portable**, because; namespace clashes cannot occur between LLVM code and other namespaces. The; portability rule is important because different standard library implementations; expose different symbols (potentially ones they shouldn't), and future revisions; to the C++ standard will add more symbols to the ``std`` namespace. As such, we; never use ``'using namespace std;'`` in LLVM. The exception to the general rule (i.e. it's not an exception for the ``std``; namespace) is for implementation files. For example, all of the code in the; LLVM project implements code that lives in the 'llvm' namespace. As such, it is; ok, and actually clearer, for the ``.cpp`` files to have a ``'using namespace; llvm;'`` directive at the top, after the ``#include``\s. This reduces; indentation in the body of the file for source editors that indent based on; braces, and keeps the conceptual context cleaner. The general form of this rule; is that any ``.cpp`` file that implements code in any namespace may use that; namespace (and its parents'), but should not use any others. Provide a Virtual Method Anchor for Classes in Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If a class is defined in a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:49549,portab,portability,49549,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['portab'],['portability']
Modifiability,".json\nFiles/job1.root/hpxpy/root.json\nFiles/job1.root/hprof/root.json\n"");; for (let n = 0; n < res.length; ++n) {; console.log('Requested element of type', res[n]._typename);; // draw('drawid', res[n], 'hist');; }; ```. Here argument ""multi"" identifies, that server response should be parsed with `parseMulti()` function, which correctly interprets JSON code, produced by `multi.json` request. When sending such request to the server, one should provide list of objects names and not forget ""?number=N"" parameter in the request URL string. ## Using unix sockets. Starting from ROOT version 6.28, one can start server with unix socket. Just do:. Just call:; ```cpp; [root] new THttpServer(""socket:/tmp/root.socket""); ```; Name of socket should be unique and not match any existing files. Most easy way to access `THttpServer` running via unix socket is to configure ssh tunnel:; ```; [shell] ssh -L 7654:/tmp/root.socket localhost; ```. Once such tunnel is configured one can open following URL in web browser:; ```; [shell] xdg-open http://localhost:7654; ```. ## Websockets supports. Websockets support available starting from ROOT v6.12.; Minimal example provided in [$ROOTSYS/tutorials/http/ws.C](https://root.cern/doc/master/ws_8C.html) macro. To work with websockets, subclass of [THttpWSHandler](https://root.cern/doc/master/classTHttpWSHandler.html) should be created and registered to THttpServer:. ```cpp; #include ""THttpWSHandler.h"". class TUserHandler : public THttpWSHandler {; public:; TUserHandler(const char *name, const char *title) : THttpWSHandler(name, title) {}. // provide custom HTML page when open correspondent address; TString GetDefaultPageContent() override { return ""file:ws.htm""; }. Bool_t ProcessWS(THttpCallArg *arg) override;; };; ```. Central method is `TUserHandler::ProcessWS(THttpCallArg *arg)`, where four kinds of websockets events should be handled:. * WS_CONNECT - clients attempts to create websockets, return false when refusing connection; * WS_READY - co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:24696,config,configured,24696,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configured']
Modifiability,".local` file (create it if it does not; exists) with the following configuration bits:. ``` {.bash}; CVMFS_HTTP_PROXY=http://your-proxy-server.domain.ch:3128,DIRECT; CVMFS_REPOSITORIES=your-experiment.cern.ch,sft.cern.ch; CVMFS_QUOTA_LIMIT=50000; ```. You need to properly specify your closest HTTP caching proxy:; separate many of them via commas. The last fallback value, `DIRECT`,; tells cvmfs to connect directly without using any proxy at all. Among the list of repositories (comma-separated), always specify; `sft.cern.ch` and the one containing the software to your experiment; (e.g., `cms.cern.ch`). The quota limit is, in Megabytes, the amount of local disk space to; use as cache. - Check the configuration and repositories with:. # cvmfs_config chksetup; OK; # cvmfs_config probe; Probing /cvmfs/cms.cern.ch... OK; Probing /cvmfs/sft.cern.ch... OK. > You might need special configurations for some custom software; > repositories! Special cases are not covered in this guide. ### Firewall configuration. [PROOF on Demand](http://pod.gsi.de/) is very flexible in handling; various cases of network topologies. The best solution would be to allow; all TCP communications between the cluster machines. No other incoming communication is required from the outside. Configuration steps for the head node only; ------------------------------------------. ### Setup HTTPS+SSH (sshcertauth) authentication. > Latest recommended sshcertauth version is 0.8.5.; >; > [Download](https://github.com/dberzano/sshcertauth/archive/v0.8.5.zip); > and [read the; > instructions](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth). If you want your users to connect to the PROOF cluster using their Grid; user certificate and private key you might be interested in installing; sshcertauth. Please refer to the [installation; guide](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth); for further information. ### PROOF on Demand. > Latest recommended PROOF on Demand version",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:3682,config,configuration,3682,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['config'],['configuration']
Modifiability,".mjs"".; Files from ROOT install directory can be get via ""rootsys/"" path like ""http://localhost:8080/rootsys/icons/about.xpm"".; Also files from current directory where ROOT is running can be accessed via ""currentdir/"" path like ""http://localhost:8080/currentdir/file.txt"". If necessary, one can add custom path as well, using [THttpServer::AddLocation](https://root.cern/doc/master/classTHttpServer.html#a5322c3bbfddb8eb6849297d83ccaf87f) method:. ```cpp; serv->AddLocation(""mydir/"", ""/home/user/specials"");; ```. Then files from that directory could be addressed via URL like ""http://localhost:8080/mydir/myfile.root"". ## Command interface. THttpServer class provide simple interface to invoke command from web browser.; One just register command like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; ```. Element with name `DoSomething` will appear in the web browser and can be clicked.; It will result in `gROOT->ProcessLineSync(""SomeFunction()"")` call. One could configure argument(s) for the command.; For that one should use `%arg1`, `%arg2` and so on identifiers. Like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; ```. User will be requested to enter arguments values, when command element clicked in the browser.; Example of the command which executes arbitrary string in application via ProcessLine looks like:. ```cpp; serv->RegisterCommand(""/Process"", ""%arg1%"");; ```. When registering command, one could specify icon name which will be displayed with the command. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; ```. In example usage of images from `$ROOTSYS/icons` directory is shown. One could prepend `button;`; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:. ```cpp; serv->Hide(""/DoSomething"");; ```. One can find example of command interface usage in [tutorials/http/httpcontrol.C](https://gi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:5253,config,configure,5253,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configure']
Modifiability,".py --filter-short baseline.json experiment.json; ...; Program baseline experiment diff. SingleSour.../Benchmarks/Linpack/linpack-pc 5.16 4.30 -16.5%; MultiSourc...erolling-dbl/LoopRerolling-dbl 7.01 7.86 12.2%; SingleSour...UnitTests/Vectorizer/gcc-loops 3.89 3.54 -9.0%; ...; ```. - Merge multiple baseline and experiment result files by taking the minimum; runtime each:. ```bash; % test-suite/utils/compare.py base0.json base1.json base2.json vs exp0.json exp1.json exp2.json; ```. ### Continuous Tracking with LNT. LNT is a set of client and server tools for continuously monitoring; performance. You can find more information at; [https://llvm.org/docs/lnt](https://llvm.org/docs/lnt). The official LNT instance; of the LLVM project is hosted at [http://lnt.llvm.org](http://lnt.llvm.org). External Suites; ---------------. External suites such as SPEC can be enabled by either. - placing (or linking) them into the `test-suite/test-suite-externals/xxx` directory (example: `test-suite/test-suite-externals/speccpu2000`); - using a configuration option such as `-D TEST_SUITE_SPEC2000_ROOT=path/to/speccpu2000`. You can find further information in the respective README files such as; `test-suite/External/SPEC/README`. For the SPEC benchmarks you can switch between the `test`, `train` and; `ref` input datasets via the `TEST_SUITE_RUN_TYPE` configuration option.; The `train` dataset is used by default. Custom Suites; -------------. You can build custom suites using the test-suite infrastructure. A custom suite; has a `CMakeLists.txt` file at the top directory. The `CMakeLists.txt` will be; picked up automatically if placed into a subdirectory of the test-suite or when; setting the `TEST_SUITE_SUBDIRS` variable:. ```bash; % cmake -DTEST_SUITE_SUBDIRS=path/to/my/benchmark-suite ../test-suite; ```. Profile Guided Optimization; ---------------------------. Profile guided optimization requires to compile and run twice. First the; benchmark should be compiled with profile generation ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:9157,config,configuration,9157,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['config'],['configuration']
Modifiability,"/ bar.c; void bar(int *) { ... }. // foo.c; void foo(void) {; int *p; // implicitly `int *__bidi_indexable p`; extern void bar(typeof(p)); // creates an interface of type; // `void bar(int *__bidi_indexable)`; }. Doing this may break the ABI if the parameter is not ``__bidi_indexable`` at the; definition of function ``bar()`` which is likely the case because parameters are; ``__single`` by default without an explicit annotation. In order to avoid an implicitly wide pointer from silently breaking the ABI, the; compiler reports a warning when ``typeof()`` is used on an implicit wide pointer; at any ABI visible context (e.g., function prototype, struct definition, etc.). .. _Default pointer types in typeof:. Default pointer types in ``typeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``typeof()`` takes an expression, it respects the bounds annotation on; the expression type, including the bounds annotation is implcit. For example,; the global variable ``g`` in the following code is implicitly ``__single`` so; ``typeof(g)`` gets ``char *__single``. The similar is true for the parameter; ``p``, so ``typeof(p)`` returns ``void *__single``. The local variable ``l`` is; implicitly ``__bidi_indexable``, so ``typeof(l)`` becomes; ``int *__bidi_indexable``. .. code-block:: C. char *g; // typeof(g) == char *__single. void foo(void *p) {; // typeof(p) == void *__single. int *l; // typeof(l) == int *__bidi_indexable; }. When the type of expression has an ""external"" bounds annotation, e.g.,; ``__sized_by``, ``__counted_by``, etc., the compiler may report an error on; ``typeof`` if the annotation creates a dependency with another declaration or; variable. For example, the compiler reports an error on ``typeof(p1)`` shown in; the following code because allowing it can potentially create another type; dependent on the parameter ``size`` in a different context (Please note that an; external bounds annotation on a parameter may only refer to another parameter of; the same functio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:25648,variab,variable,25648,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variable']
Modifiability,"/ for instructions that have one register operand; ... // added to their opcode; break;; case X86II::MRMDestReg:// for instructions that use the Mod/RM byte; ... // to specify a destination (register); break;; case X86II::MRMDestMem:// for instructions that use the Mod/RM byte; ... // to specify a destination (memory); break;; case X86II::MRMSrcReg: // for instructions that use the Mod/RM byte; ... // to specify a source (register); break;; case X86II::MRMSrcMem: // for instructions that use the Mod/RM byte; ... // to specify a source (memory); break;; case X86II::MRM0r: case X86II::MRM1r: // for instructions that operate on; case X86II::MRM2r: case X86II::MRM3r: // a REGISTER r/m operand and; case X86II::MRM4r: case X86II::MRM5r: // use the Mod/RM byte and a field; case X86II::MRM6r: case X86II::MRM7r: // to hold extended opcode data; ...; break;; case X86II::MRM0m: case X86II::MRM1m: // for instructions that operate on; case X86II::MRM2m: case X86II::MRM3m: // a MEMORY r/m operand and; case X86II::MRM4m: case X86II::MRM5m: // use the Mod/RM byte and a field; case X86II::MRM6m: case X86II::MRM7m: // to hold extended opcode data; ...; break;; case X86II::MRMInitReg: // for instructions whose source and; ... // destination are the same register; break;; }. The implementations of these case statements often first emit the opcode and; then get the operand(s). Then depending upon the operand, helper methods may; be called to process the operand(s). For example, in ``X86CodeEmitter.cpp``,; for the ``X86II::AddRegFrm`` case, the first data emitted (by ``emitByte``) is; the opcode added to the register operand. Then an object representing the; machine operand, ``MO1``, is extracted. The helper methods such as; ``isImmediate``, ``isGlobalAddress``, ``isExternalSymbol``,; ``isConstantPoolIndex``, and ``isJumpTableIndex`` determine the operand type.; (``X86CodeEmitter.cpp`` also has private methods such as ``emitConstant``,; ``emitGlobalAddress``, ``emitExternalSymbolAddress`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:78991,extend,extended,78991,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['extend'],['extended']
Modifiability,"/ returned block; }. alpha.core.TestAfterDivZero; (C, C++, ObjC); Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. C++ Alpha Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that are destructed as; their base class. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. alpha.cplusplus.IteratorRange; (C++); Check for iterators used outside their valid ranges. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. alpha.cplusplus.MismatchedIterator; (C++); Check for use of iterators of different containers where iterators of the same; container are expected. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:5031,polymorphi,polymorphic,5031,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['polymorphi'],['polymorphic']
Modifiability,"/-Inf if the floating point type has enough exponent bits; to represent the largest integer value as < inf. //===---------------------------------------------------------------------===//. When optimizing a transformation that can change the sign of 0.0 (such as the; 0.0*val -> 0.0 transformation above), it might be provable that the sign of the; expression doesn't matter. For example, by the above rules, we can't transform; fmul(sitofp(x), 0.0) into 0.0, because x might be -1 and the result of the; expression is defined to be -0.0. If we look at the uses of the fmul for example, we might be able to prove that; all uses don't care about the sign of zero. For example, if we have:. fadd(fmul(sitofp(x), 0.0), 2.0). Since we know that x+2.0 doesn't care about the sign of any zeros in X, we can; transform the fmul to 0.0, and then the fadd to 2.0. //===---------------------------------------------------------------------===//. We should enhance memcpy/memcpy/memset to allow a metadata node on them; indicating that some bytes of the transfer are undefined. This is useful for; frontends like clang when lowering struct copies, when some elements of the; struct are undefined. Consider something like this:. struct x {; char a;; int b[4];; };; void foo(struct x*P);; struct x testfunc() {; struct x V1, V2;; foo(&V1);; V2 = V1;. return V2;; }. We currently compile this to:; $ clang t.c -S -o - -O0 -emit-llvm | opt -sroa -S. %struct.x = type { i8, [4 x i32] }. define void @testfunc(%struct.x* sret %agg.result) nounwind ssp {; entry:; %V1 = alloca %struct.x, align 4; call void @foo(%struct.x* %V1); %tmp1 = bitcast %struct.x* %V1 to i8*; %0 = bitcast %struct.x* %V1 to i160*; %srcval1 = load i160* %0, align 4; %tmp2 = bitcast %struct.x* %agg.result to i8*; %1 = bitcast %struct.x* %agg.result to i160*; store i160 %srcval1, i160* %1, align 4; ret void; }. This happens because SRoA sees that the temp alloca has is being memcpy'd into; and out of and it has holes and it has to be conserv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:62123,enhance,enhance,62123,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['enhance'],['enhance']
Modifiability,"// error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """"""""""""""""""""""""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:31096,variab,variable,31096,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"//===----------------------------------------------------------------------===//; // C Language Family Front-end; //===----------------------------------------------------------------------===//; Chris Lattner. I. Introduction:; ; clang: noun; 1. A loud, resonant, metallic sound.; 2. The strident call of a crane or goose.; 3. C-language family front-end toolkit. The world needs better compiler tools, tools which are built as libraries. This; design point allows reuse of the tools in new and novel ways. However, building; the tools as libraries isn't enough: they must have clean APIs, be as; decoupled from each other as possible, and be easy to modify/extend. This; requires clean layering, decent design, and avoiding tying the libraries to a; specific use. Oh yeah, did I mention that we want the resultant libraries to; be as fast as possible? :). This front-end is built as a component of the LLVM toolkit that can be used; with the LLVM backend or independently of it. In this spirit, the API has been; carefully designed as the following components:; ; libsupport - Basic support library, reused from LLVM. libsystem - System abstraction library, reused from LLVM.; ; libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction,; file system caching for input source files. This depends on; libsupport and libsystem. libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and; manipulating the AST (visitors, pretty printers, etc). This; library depends on libbasic. liblex - C/C++/ObjC lexing and preprocessing, identifier hash table,; pragma handling, tokens, and macros. This depends on libbasic. libparse - C (for now) parsing and local semantic analysis. This library; invokes coarse-grained 'Actions' provided by the client to do; stuff (e.g. libsema builds ASTs). This depends on liblex. libsema - Provides a set of parser actions to build a standardized AST; for programs. AST's are 'streamed' out a top-le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:659,extend,extend,659,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['extend'],['extend']
Modifiability,"//===----------------------------------------------------------------------===//; // Clang Static Analyzer; //===----------------------------------------------------------------------===//. = Library Structure =. The analyzer library has two layers: a (low-level) static analysis; engine (ExprEngine.cpp and friends), and some static checkers; (*Checker.cpp). The latter are built on top of the former via the; Checker and CheckerVisitor interfaces (Checker.h and; CheckerVisitor.h). The Checker interface is designed to be minimal; and simple for checker writers, and attempts to isolate them from much; of the gore of the internal analysis engine. = How It Works =. The analyzer is inspired by several foundational research papers ([1],; [2]). (FIXME: kremenek to add more links). In a nutshell, the analyzer is basically a source code simulator that; traces out possible paths of execution. The state of the program; (values of variables and expressions) is encapsulated by the state; (ProgramState). A location in the program is called a program point; (ProgramPoint), and the combination of state and program point is a; node in an exploded graph (ExplodedGraph). The term ""exploded"" comes; from exploding the control-flow edges in the control-flow graph (CFG). Conceptually the analyzer does a reachability analysis through the; ExplodedGraph. We start at a root node, which has the entry program; point and initial state, and then simulate transitions by analyzing; individual expressions. The analysis of an expression can cause the; state to change, resulting in a new node in the ExplodedGraph with an; updated program point and an updated state. A bug is found by hitting; a node that satisfies some ""bug condition"" (basically a violation of a; checking invariant). The analyzer traces out multiple paths by reasoning about branches and; then bifurcating the state: on the true branch the conditions of the; branch are assumed to be true and on the false branch the conditions; of the branc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt:242,layers,layers,242,interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,2,"['layers', 'variab']","['layers', 'variables']"
Modifiability,"//===----------------------------------------------------------------------===//; // Representing sign/zero extension of function results; //===----------------------------------------------------------------------===//. Mar 25, 2009 - Initial Revision. Most ABIs specify that functions which return small integers do so in a; specific integer GPR. This is an efficient way to go, but raises the question:; if the returned value is smaller than the register, what do the high bits hold?. There are three (interesting) possible answers: undefined, zero extended, or; sign extended. The number of bits in question depends on the data-type that; the front-end is referencing (typically i1/i8/i16/i32). Knowing the answer to this is important for two reasons: 1) we want to be able; to implement the ABI correctly. If we need to sign extend the result according; to the ABI, we really really do need to do this to preserve correctness. 2); this information is often useful for optimization purposes, and we want the; mid-level optimizers to be able to process this (e.g. eliminate redundant; extensions). For example, lets pretend that X86 requires the caller to properly extend the; result of a return (I'm not sure this is the case, but the argument doesn't; depend on this). Given this, we should compile this:. int a();; short b() { return a(); }. into:. _b:; 	subl	$12, %esp; 	call	L_a$stub; 	addl	$12, %esp; 	cwtl; 	ret. An optimization example is that we should be able to eliminate the explicit; sign extension in this example:. short y();; int z() {; return ((int)y() << 16) >> 16;; }. _z:; 	subl	$12, %esp; 	call	_y; 	;; movswl %ax, %eax -> not needed because eax is already sext'd; 	addl	$12, %esp; 	ret. //===----------------------------------------------------------------------===//; // What we have right now.; //===----------------------------------------------------------------------===//. Currently, these sorts of things are modelled by compiling a function to return; the small type a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt:552,extend,extended,552,interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,3,['extend'],"['extend', 'extended']"
Modifiability,"//===----------------------------------------------------------------------===/; // Kaleidoscope with MCJIT; //===----------------------------------------------------------------------===//. The files in this directory are meant to accompany the first blog in a series of; three blog posts that describe the process of porting the Kaleidoscope tutorial; to use the MCJIT execution engine instead of the older JIT engine. The link of blog post-; https://blog.llvm.org/posts/2013-07-22-using-mcjit-with-kaleidoscope-tutorial/. The source code in this directory demonstrates the initial working version of; the program before subsequent performance improvements are applied. To build the program you will need to have 'clang++' and 'llvm-config' in your ; path. If you attempt to build using the LLVM 3.3 release, some minor ; modifications will be required, as mentioned in the blog posts.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/README.txt:735,config,config,735,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/README.txt,1,['config'],['config']
Modifiability,"//===----------------------------------------------------------------------===/; // Kaleidoscope with MCJIT; //===----------------------------------------------------------------------===//. The files in this directory are meant to accompany the first in a series of; three blog posts that describe the process of porting the Kaleidoscope tutorial; to use the MCJIT execution engine instead of the older JIT engine. The source code in this directory combines all previous versions, including the; old JIT-based implementation, into a single file for easy comparison with; command line options to select between the various possibilities. To build the program you will need to have 'clang++' and 'llvm-config' in your ; path. If you attempt to build using the LLVM 3.3 release, some minor ; modifications will be required. This directory also contains a Python script that may be used to generate random; input for the program and test scripts to capture data for rough performance; comparisons. Another Python script will split generated input files into; definitions and function calls for the purpose of testing the IR input and; caching facilities.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/README.txt:701,config,config,701,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/README.txt,1,['config'],['config']
Modifiability,"//===----------------------------------------------------------------------===/; // Kaleidoscope with MCJIT; //===----------------------------------------------------------------------===//. The files in this directory are meant to accompany the second blog in a series of; three blog posts that describe the process of porting the Kaleidoscope tutorial; to use the MCJIT execution engine instead of the older JIT engine. The link of blog post-; https://blog.llvm.org/posts/2013-07-29-kaleidoscope-performance-with-mcjit/. The source code in this directory demonstrates the second version of the; program, now modified to implement a sort of 'lazy' compilation. The toy-jit.cpp file contains a version of the original JIT-based source code; that has been modified to disable most stderr output for timing purposes. To build the program you will need to have 'clang++' and 'llvm-config' in your ; path. If you attempt to build using the LLVM 3.3 release, some minor ; modifications will be required. This directory also contains a Python script that may be used to generate random; input for the program and test scripts to capture data for rough performance; comparisons.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/README.txt:878,config,config,878,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/README.txt,1,['config'],['config']
Modifiability,"//===----------------------------------------------------------------------===/; // Kaleidoscope with MCJIT; //===----------------------------------------------------------------------===//. The files in this directory are meant to accompany the third blog in a series of; three blog posts that describe the process of porting the Kaleidoscope tutorial; to use the MCJIT execution engine instead of the older JIT engine. The link of blog post-; https://blog.llvm.org/posts/2013-08-02-object-caching-with-kaleidoscope/. The source code in this directory demonstrates the third version of the; program, now modified to accept an input IR file on the command line and,; optionally, to use a basic caching mechanism to store generated object images. The toy-jit.cpp file contains a version of the original JIT-based source code; that has been modified to support the input IR file command line option. To build the program you will need to have 'clang++' and 'llvm-config' in your ; path. If you attempt to build using the LLVM 3.3 release, some minor ; modifications will be required. This directory also contains a Python script that may be used to generate random; input for the program and test scripts to capture data for rough performance; comparisons. Another Python script will split generated input files into; definitions and function calls for the purpose of testing the IR input and; caching facilities.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/README.txt:961,config,config,961,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/README.txt,1,['config'],['config']
Modifiability,"//===---------------------------------------------------------------------===//; // Random ideas for the ARM backend.; //===---------------------------------------------------------------------===//. Reimplement 'select' in terms of 'SEL'. * We would really like to support UXTAB16, but we need to prove that the; add doesn't need to overflow between the two 16-bit chunks. * Implement pre/post increment support. (e.g. PR935); * Implement smarter constant generation for binops with large immediates. A few ARMv6T2 ops should be pattern matched: BFI, SBFX, and UBFX. Interesting optimization for PIC codegen on arm-linux:; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43129. //===---------------------------------------------------------------------===//. Crazy idea: Consider code that uses lots of 8-bit or 16-bit values. By the; time regalloc happens, these values are now in a 32-bit register, usually with; the top-bits known to be sign or zero extended. If spilled, we should be able; to spill these to a 8-bit or 16-bit stack slot, zero or sign extending as part; of the reload. Doing this reduces the size of the stack frame (important for thumb etc), and; also increases the likelihood that we will be able to reload multiple values; from the stack with a single load. //===---------------------------------------------------------------------===//. The constant island pass is in good shape. Some cleanups might be desirable,; but there is unlikely to be much improvement in the generated code. 1. There may be some advantage to trying to be smarter about the initial; placement, rather than putting everything at the end. 2. There might be some compile-time efficiency to be had by representing; consecutive islands as a single block rather than multiple blocks. 3. Use a priority queue to sort constant pool users in inverse order of; position so we always process the one closed to the end of functions; first. This may simply CreateNewWater. //===----------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:950,extend,extended,950,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['extend'],['extended']
Modifiability,"/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you may need):. `$ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x versions suffice and are supported as; well. Versions older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:7015,config,configure,7015,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['config'],['configure']
Modifiability,/Semantics/check-purity.h; flang/lib/Semantics/check-return.cpp; flang/lib/Semantics/check-return.h; flang/lib/Semantics/check-select-rank.cpp; flang/lib/Semantics/check-select-rank.h; flang/lib/Semantics/check-select-type.cpp; flang/lib/Semantics/check-select-type.h; flang/lib/Semantics/check-stop.cpp; flang/lib/Semantics/check-stop.h; flang/lib/Semantics/compute-offsets.cpp; flang/lib/Semantics/compute-offsets.h; flang/lib/Semantics/data-to-inits.cpp; flang/lib/Semantics/mod-file.h; flang/lib/Semantics/pointer-assignment.cpp; flang/lib/Semantics/pointer-assignment.h; flang/lib/Semantics/program-tree.cpp; flang/lib/Semantics/program-tree.h; flang/lib/Semantics/resolve-directives.cpp; flang/lib/Semantics/resolve-directives.h; flang/lib/Semantics/resolve-labels.cpp; flang/lib/Semantics/resolve-labels.h; flang/lib/Semantics/resolve-names-utils.cpp; flang/lib/Semantics/resolve-names-utils.h; flang/lib/Semantics/resolve-names.h; flang/lib/Semantics/rewrite-parse-tree.cpp; flang/lib/Semantics/rewrite-parse-tree.h; flang/lib/Semantics/runtime-type-info.cpp; flang/lib/Semantics/scope.cpp; flang/lib/Semantics/semantics.cpp; flang/lib/Semantics/tools.cpp; flang/lib/Semantics/unparse-with-symbols.cpp; flang/module/omp_lib.h; flang/runtime/allocatable.cpp; flang/runtime/assign.cpp; flang/runtime/buffer.cpp; flang/runtime/buffer.h; flang/runtime/character.cpp; flang/runtime/command.cpp; flang/runtime/complex-reduction.h; flang/runtime/connection.cpp; flang/runtime/connection.h; flang/runtime/copy.cpp; flang/runtime/copy.h; flang/runtime/derived-api.cpp; flang/runtime/derived.h; flang/runtime/descriptor-io.cpp; flang/runtime/descriptor-io.h; flang/runtime/descriptor.cpp; flang/runtime/dot-product.cpp; flang/runtime/edit-input.cpp; flang/runtime/edit-input.h; flang/runtime/edit-output.cpp; flang/runtime/edit-output.h; flang/runtime/environment.cpp; flang/runtime/environment.h; flang/runtime/extensions.cpp; flang/runtime/extrema.cpp; flang/runtime/file.cpp; flang/runtime/file.h; f,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:123923,rewrite,rewrite-parse-tree,123923,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['rewrite'],['rewrite-parse-tree']
Modifiability,"/WLCG-AuthZ-WG/bearer-token-discovery/blob/master/specification.md). Short overview:. 1. If the `BEARER_TOKEN` environment variable is set, then the value is taken to be the token contents.; 2. If the `BEARER_TOKEN_FILE` environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; 3. If the `XDG_RUNTIME_DIR` environment variable is set, then take the token from the contents of `$XDG_RUNTIME_DIR/bt_u$ID`(this additional location is intended to provide improved security for shared login environments as `$XDG_RUNTIME_DIR` is defined to be user-specific as opposed to a system-wide directory.).; 4. Otherwise, take the token from `/tmp/bt_u$ID`. ## GUI Libraries. ### RBrowser improvements. - central factory methods to handle browsing, editing and drawing of different classes; - simple possibility to extend RBrowser on user-defined classes; - support of web-based geometry viewer; - better support of TTree drawing; - server-side handling of code editor and image viewer widgets; - rbrowser content is fully recovered when web-browser is reloaded; - load of widgets code only when really required (shorter startup time for RBrowser). ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ### Major JSROOT update to version 6. - update all used libraries `d3.js`, `three.js`, `MathJax.js`, openui5; - change to Promise based interface for all async methods, remove call-back arguments; - change scripts names, core scripts name now `JSRoot.core.js`; - unify function/methods naming conventions, many changes in method names; - provide central code loader via `JSROOT.require`, supporting 4 different loading engines; - many nice features and many bug fixes; see JSROOT v6 release notes. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - a new cmake variable, `CMAKE_INSTALL_PYTHONDIR`, has been added: it allows customization of the i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:26932,extend,extend,26932,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['extend'],['extend']
Modifiability,"/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows exactly where the diagnostic; occurs in your code [:ref:`-fshow-column <opt_fshow-column>`,; :ref:`-fshow-source-location <opt_fshow-source-location>`].; #",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35480,config,configuration,35480,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['config'],"['config', 'configuration']"
Modifiability,/index/dex/PostingList.cpp; clang-tools-extra/clangd/index/dex/PostingList.h; clang-tools-extra/clangd/index/dex/Token.h; clang-tools-extra/clangd/index/dex/Trigram.cpp; clang-tools-extra/clangd/index/dex/Trigram.h; clang-tools-extra/clangd/index/dex/dexp/Dexp.cpp; clang-tools-extra/clangd/index/remote/Client.cpp; clang-tools-extra/clangd/index/remote/Client.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/support/Function.h; clang-tools-extra/clangd/support/Logger.cpp; clang-tools-extra/clangd/support/M,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80263,refactor,refactor,80263,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,/libomptarget/include/interop.h; openmp/libomptarget/include/omptarget.h; openmp/libomptarget/include/omptargetplugin.h; openmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/deviceinfo/llvm-omp-device-info.cpp; openmp/runtime/doc/doxygen/libomp_interface.h; openmp/runtime/src/extractExternal.cpp;,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407622,plugin,plugins,407622,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"/lnt](https://llvm.org/docs/lnt). The official LNT instance; of the LLVM project is hosted at [http://lnt.llvm.org](http://lnt.llvm.org). External Suites; ---------------. External suites such as SPEC can be enabled by either. - placing (or linking) them into the `test-suite/test-suite-externals/xxx` directory (example: `test-suite/test-suite-externals/speccpu2000`); - using a configuration option such as `-D TEST_SUITE_SPEC2000_ROOT=path/to/speccpu2000`. You can find further information in the respective README files such as; `test-suite/External/SPEC/README`. For the SPEC benchmarks you can switch between the `test`, `train` and; `ref` input datasets via the `TEST_SUITE_RUN_TYPE` configuration option.; The `train` dataset is used by default. Custom Suites; -------------. You can build custom suites using the test-suite infrastructure. A custom suite; has a `CMakeLists.txt` file at the top directory. The `CMakeLists.txt` will be; picked up automatically if placed into a subdirectory of the test-suite or when; setting the `TEST_SUITE_SUBDIRS` variable:. ```bash; % cmake -DTEST_SUITE_SUBDIRS=path/to/my/benchmark-suite ../test-suite; ```. Profile Guided Optimization; ---------------------------. Profile guided optimization requires to compile and run twice. First the; benchmark should be compiled with profile generation instrumentation enabled; and setup for training data. The lit runner will merge the profile files; using `llvm-profdata` so they can be used by the second compilation run. Example:; ```bash; # Profile generation run using LLVM IR PGO:; % cmake -DTEST_SUITE_PROFILE_GENERATE=ON \; -DTEST_SUITE_USE_IR_PGO=ON \; -DTEST_SUITE_RUN_TYPE=train \; ../test-suite; % make; % llvm-lit .; # Use the profile data for compilation and actual benchmark run:; % cmake -DTEST_SUITE_PROFILE_GENERATE=OFF \; -DTEST_SUITE_PROFILE_USE=ON \; -DTEST_SUITE_RUN_TYPE=ref \; .; % make; % llvm-lit -o result.json .; ```. To use Clang frontend's PGO instead of LLVM IR PGO, set `-DTEST_SU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:9836,variab,variable,9836,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['variab'],['variable']
Modifiability,"/path/to/afdsmgrd-xrd-stage-verify.sh ""$URLTOSTAGE"" ""$TREENAME"". Return value of the command is ignored: standard output is; considered, as explained here. Defaults to `/bin/false`. dsmgrd.cmdtimeoutsecs *secs*; : Timeout on staging command, expressed in seconds: after this; timeout, the command is considered failed and it is killed (in first; place with `SIGSTOP`, then if it is unresponsive with `SIGKILL`).; Defaults to **0 (no timeout)**. dsmgrd.corruptafterfails *n*; : Set this to a number above zero to tell the daemon to mark files as; corrupted after a certain number of either download or verification; failures. A value of **0 (default)** tells the daemon to retry; forever. Configuring the MonALISA monitoring plugin; ------------------------------------------. The Dataset Stager supports generic monitoring plugins. The only plugin; distributed with the stager is the MonALISA monitoring plugin. dsmgrd.notifyplugin */path/to/libafdsmgrd\_notify\_apmon.so*; : Set it to the path of the MonALISA plugin shared object. By default,; notification plugin is disabled. dsmgrd.apmonurl *apmon://apmon.cern.ch*; : This variable tells the ApMon notification plugin how to contact one; or more MonALISA server(s) to activate monitoring via ApMon. It; supports two kinds of URLs:. - `http[s]://host/path/configuration_file.conf` (a remote file; where to fetch the list of servers from). - `apmon://[:password@]monalisahost[:8884]` (a single server to; contact directly). If the variable is not set, yet the plugin is loaded, MonALISA; monitoring is inhibited until a valid configuration variable is; provided. dsmgrd.apmonprefix *MY::CLUSTER::PREFIX*; : Since MonALISA organizes information in ""clusters"" and ""hosts"", here; you can specify what to use as cluster prefix for monitoring; datasets information and daemon status. If this variable is not set,; MonALISA monitoring is inhibited. Please note that the suffix; `_datasets` or `_status` is appended for each of the two types of; monitoring",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md:5040,plugin,plugin,5040,proof/doc/confman/DatasetStager.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md,1,['plugin'],['plugin']
Modifiability,"/res; ${CMAKE_SOURCE_DIR}/core/meta/inc; ${CMAKE_SOURCE_DIR}/core/metacling/res; ${CMAKE_SOURCE_DIR}/core/thread/inc; ${CMAKE_SOURCE_DIR}/core/zip/inc; ${CMAKE_SOURCE_DIR}/io/io/inc; ${CMAKE_BINARY_DIR}/ginclude; ). set_target_properties(MetaCling PROPERTIES; COMPILE_FLAGS ""${CMAKE_CXX_FLAGS} ${CLING_CXXFLAGS}""; VISIBILITY_INLINES_HIDDEN ""ON""; ). if(MSVC); target_include_directories(MetaCling PRIVATE; ${CMAKE_SOURCE_DIR}/core/winnt/inc; ); set_source_files_properties(TCling.cxx COMPILE_FLAGS /bigobj); endif(). add_dependencies(MetaCling CLING). ##### libCling #############################################################. if(NOT builtin_clang); set(prefixed_link_libraries); foreach(dep ${CLING_DEPEND_LIBS}); if(""${dep}"" MATCHES ""^clang""); set(dep ""${LLVM_LIBRARY_DIR}/lib${dep}.a""); endif(); list(APPEND prefixed_link_libraries ""${dep}""); endforeach(); set(LINK_LIBS ""${prefixed_link_libraries}""); link_directories(""${LLVM_LIBRARY_DIR}""); endif(). # We need to paste the content of the cling plugins disabling link symbol optimizations.; set(CLING_PLUGIN_LINK_LIBS); if (clad); if (APPLE); set(CLING_PLUGIN_LINK_LIBS -Wl,-force_load cladPlugin -Wl,-force_load cladDifferentiator); elseif(MSVC); set(CLING_PLUGIN_LINK_LIBS cladPlugin cladDifferentiator); set(CLAD_LIBS ""-WHOLEARCHIVE:cladPlugin.lib -WHOLEARCHIVE:cladDifferentiator.lib""); else(); set(CLING_PLUGIN_LINK_LIBS -Wl,--whole-archive cladPlugin cladDifferentiator -Wl,--no-whole-archive); endif(); if(TARGET clang); # Link our clad libraries to clang. If users use the clang from ROOT they will; # also be able to use clad out of the box.; add_dependencies(clang clad); target_link_libraries(clang PUBLIC ${CLING_PLUGIN_LINK_LIBS}); endif(); endif(). ROOT_LINKER_LIBRARY(Cling; $<TARGET_OBJECTS:ClingUtils>; $<TARGET_OBJECTS:Dictgen>; $<TARGET_OBJECTS:MetaCling>; LIBRARIES ${CLING_LIBRARIES} ${LINK_LIBS} ${CLING_PLUGIN_LINK_LIBS}). # When these two link at the same time, they can exhaust the RAM on many machines, since they both ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/CMakeLists.txt:2989,plugin,plugins,2989,core/metacling/src/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/CMakeLists.txt,1,['plugin'],['plugins']
Modifiability,"/root-project/root/blob/master/tutorials/http/httpcontrol.C) macro. ## Customize user interface. JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - [see example](https://root.cern/js/latest/httpserver.C/). JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items [item=Files/job1.root/hpxpy&opt=colz&monitoring=1000](https://root.cern/js/latest/httpserver.C/?item=Files/job1.root/hpxpy&opt=colz&monitoring=1000). Some of such parameters can be configured already on the server:. ```cpp; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; ```. In such case URL parameters are not required - specified item will be displayed automatically when web page is opened.; One also can configure to display several items at once. For that one also can configure layout of the drawing area:. ```cpp; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; ```. One also can change appearance of hierarchy browser on the left side of the web page:. ```cpp; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; ```. If necessary, one also can automatically open ROOT file when web page is opened:. ```cpp; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; ```. ## Configuring user access. By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:7261,config,configure,7261,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configure']
Modifiability,"/utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default); /Zc:sizedDealloc- Disable C++14 sized global deallocation functions; /Zc:sizedDealloc Enable C++14 sized global deallocation functions; /Zc:strictStrings Treat string literals as const; /Zc:threadSafeInit- Disable thread-safe initialization of static variables; /Zc:threadSafeInit Enable thread-safe initialization of static variables; /Zc:trigraphs- Disable trigraphs (default); /Zc:trigraphs Enable trigraphs; /Zc:twoPhase- Disable two-phase name lookup in templates; /Zc:twoPhase Enable two-phase name lookup in templates; /Zi Alias for /Z7.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:177056,variab,variables,177056,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['variab'],['variables']
Modifiability,"/www.desy.de/~sschmitt/tunfold.html) inside ROOT is upgraded from version 17.6 to version 17.9. ## Math Libraries. ### Usage of `std::span<const double>` in Minuit 2 interfaces. To avoid forcing the user to do manual memory allocations via `std::vector`, the interfaces of Minuit 2 function adapter classes like `ROOT::Minuit2::FCNBase` or `ROOT::Minuit2::FCNGradientBase` were changed to accept `std::span<const double>` arguments instead of `std::vector<double> const&`.; This should have minimal impact on users, since one should usual use Minuit 2 via the `ROOT::Math::Minimizer` interface, which is unchanged. ## RooFit Libraries. ### Miscellaneous. * Setting `useHashMapForFind(true)` is not supported for RooArgLists anymore, since hash-assisted finding by name hash can be ambiguous: a RooArgList is allowed to have different elements with the same name. If you want to do fast lookups by name, convert your RooArgList to a RooArgSet. * The function `RooFit::bindFunction()` now supports arbitrary many input variables when binding a Python function. * The `ExportOnly()` attribute of the `RooStats::HistFactory::Measurement` object is now switched on by default, and the associated getter and setter functions are deprecated. They will be removed in ROOT 6.36. If you want to fit the model as well instead of just exporting it to a RooWorkspace, please do so with your own code as demonstrated in the `hf001` tutorial. ### Deprecations. * The `RooStats::MarkovChain::GetAsDataSet` and `RooStats::MarkovChain::GetAsDataHist` functions are deprecated and will be removed in ROOT 6.36. The same functionality can be implemented by calling `RooAbsData::reduce` on the Markov Chain's `RooDataSet*` (obtained using `MarkovChain::GetAsConstDataSet`) and then obtaining its binned clone(for `RooDataHist`). An example in Python would be:. ```py; mcInt = mc.GetInterval() # Obtain the MCMCInterval from a configured MCMCCalculator; mkc = mcInt.GetChain() # Obtain the MarkovChain; mkcData = mkc.GetAs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:5100,variab,variables,5100,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['variab'],['variables']
Modifiability,"/y position in centimeters; public:; TMyClass() { fX = fY = -1; }; virtual void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y; }; };; void TMyClass::Print() const // parent print method; {; cout << ""fX = "" << fX << "", fY = "" << fY << endl;; }; class TChild : public TMyClass {; public:; void Print() const;; };; void TChild::Print() const // child print metod; {; cout << ""This is TChild::Print()"" << endl;; TMyClass::Print();; }; ```. To execute `script4.C` do:. ``` {.cpp}; root[] .L script4.C; root[] TMyClass *a = new TChild; root[] a->Print(); This is TChild::Print(); fX = -1, fY = -1; root[] a->SetX(10); root[] a->SetY(12); root[] a->Print(); This is TChild::Print(); fX = 10, fY = 12; root[] .class TMyClass; =====================================================; class TMyClass; size=0x8 FILE:script4.C LINE:3; List of base class-----------------------------------; List of member variable------------------------------; Defined in TMyClass; 0x0 private: float fX; 0x4 private: float fY; List of member function------------------------------; Defined in TMyClass; filename line:size busy function type and name; script4.C 16:5 0 public: class TMyClass TMyClass(void);; script4.C 22:4 0 public: void Print(void);; script4.C 12:1 0 public: void SetX(float x);; script4.C 13:1 0 public: void SetY(float y);; root[] .q; ```. As you can see, an interpreted class behaves just like a compiled; class.; See ""Adding a Class"" for ways how to add a class with a shared library; and with ACLiC. ## Inspecting Objects. An object of a class inheriting from `TObject` can be inspected,; with the `Inspect()` method. The `TObject::Inspect` method creates a; window listing the current values of the objects members. For example,; the next picture is of `TFile`. ``` {.cpp}; root[] TFile f(""staff.root""); root[] f.Inspect(); ```. You can see the pointers are in red and can be clicked on to follow; the pointer to the object. If you clicked on `fList`, the list of; objects in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:25582,variab,variable,25582,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['variab'],['variable']
Modifiability,"/your/path/to/llvm-project/clang/tools/scan-build-py/bin/analyze-build --ctu; analyze-build: Run 'scan-view /tmp/scan-build-2019-07-17-17-53-33-810365-7fqgWk' to examine bug reports.; $ /your/path/to/llvm-project/clang/tools/scan-view/bin/scan-view /tmp/scan-build-2019-07-17-17-53-33-810365-7fqgWk; Starting scan-view at: http://127.0.0.1:8181; Use Ctrl-C to exit.; [6336:6431:0717/175357.633914:ERROR:browser_process_sub_thread.cc(209)] Waited 5 ms for network service; Opening in existing browser session.; ^C; $. .. _ctu-on-demand:. On-demand analysis; __________________; The analysis produces the necessary AST structure of external TUs during analysis. This requires the; exact compiler invocations for each TU, which can be generated by hand, or by tools driving the analyzer.; The compiler invocation is a shell command that could be used to compile the TU-s main source file.; The mapping from absolute source file paths of a TU to lists of compilation command segments used to; compile said TU are given in YAML format referred to as `invocation list`, and must be passed as an; analyzer-config argument.; The index, which maps function USR names to source files containing them must also be generated by the; `clang-extdef-mapping`. Entries in the index must *not* have an `.ast` suffix if the goal; is to use On-demand analysis, as that extension signals that the entry is to be used as an PCH-dump.; The mapping of external definitions implicitly uses a; :doc:`compilation database <../../JSONCompilationDatabase>` to determine the compilation flags used.; The analysis invocation must be provided with the directory which contains the mapping; files, and the `invocation list` which is used to determine compiler flags. Manual CTU Analysis; ###################. Let's consider these source files in our minimal example:. .. code-block:: cpp. // main.cpp; int foo();. int main() {; return 3 / foo();; }. .. code-block:: cpp. // foo.cpp; int foo() {; return 0;; }. The compilation databa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:7285,config,config,7285,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,1,['config'],['config']
Modifiability,"0 x [20 x i32]], i8 }``' type, another; structure. The third index indexes into the second element of the; structure, yielding a '``[10 x [20 x i32]]``' type, an array. The two; dimensions of the array are subscripted into, yielding an '``i32``'; type. The '``getelementptr``' instruction returns a pointer to this; element. Note that it is perfectly legal to index partially through a structure,; returning a pointer to an inner element. Because of this, the LLVM code; for the given testcase is equivalent to:. .. code-block:: llvm. define ptr @foo(ptr %s) {; %t1 = getelementptr %struct.ST, ptr %s, i32 1; %t2 = getelementptr %struct.ST, ptr %t1, i32 0, i32 2; %t3 = getelementptr %struct.RT, ptr %t2, i32 0, i32 1; %t4 = getelementptr [10 x [20 x i32]], ptr %t3, i32 0, i32 5; %t5 = getelementptr [20 x i32], ptr %t4, i32 0, i32 13; ret ptr %t5; }. The indices are first converted to offsets in the pointer's index type. If the; currently indexed type is a struct type, the struct offset corresponding to the; index is sign-extended or truncated to the pointer index type. Otherwise, the; index itself is sign-extended or truncated, and then multiplied by the type; allocation size (that is, the size rounded up to the ABI alignment) of the; currently indexed type. The offsets are then added to the low bits of the base address up to the index; type width, with silently-wrapping two's complement arithmetic. If the pointer; size is larger than the index size, this means that the bits outside the index; type width will not be affected. The result value of the ``getelementptr`` may be outside the object pointed; to by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:436251,extend,extended,436251,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extended']
Modifiability,"0.html), it would have; been much easier, because the ghost field would only contain the actual; metadata, and the Store would always know about it. This example adds to my; belief that ghost fields are exactly what we need for most C++ checkers. **Devin:**. In this case, I would be fine with some sort of; AbstractStorageMemoryRegion that meant ""here is a memory region and somewhere; reachable from here exists another region of type T"". Or even multiple regions; with different identifiers. This wouldn't specify how the memory is reachable,; but it would allow for transfer functions to get at those regions and it would; allow for invalidation. For ``std::initializer_list`` this reachable region would the region for the backing; array and the transfer functions for begin() and end() yield the beginning and; end element regions for it. In my view this differs from ghost variables in that (1) this storage does; actually exist (it is just a library implementation detail where that storage; lives) and (2) it is perfectly valid for a pointer into that storage to be; returned and for another part of the program to read or write from that storage.; (Well, in this case just read since it is allowed to be read-only memory). What I'm not OK with is modeling abstract analysis state (for example, the count; of a NSMutableArray or the typestate of a file handle) as a value stored in some; ginned up region in the store. This takes an easy problem that the analyzer does; well at (modeling typestate) and turns it into a hard one that the analyzer is; bad at (reasoning about the contents of the heap). I think the key criterion here is: ""is the region accessible from outside the; library"". That is, does the library expose the region as a pointer that can be; read to or written from in the client program? If so, then it makes sense for; this to be in the store: we are modeling reachable storage as storage. But if; we're just modeling arbitrary analysis facts that need to be invalidated ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:8974,variab,variables,8974,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['variab'],['variables']
Modifiability,"00 Y1=0.000000 X2=0.000000 Y2=0.000000; root [3] l.SetX1(10); root [4] l.SetY1(11); root [5] l.Print(); TLine X1=10.000000 Y1=11.000000 X2=0.000000 Y2=0.000000; root [6] .g l; .g l; ROOT_prompt_0 1 (address: NA) class TLine l, size = 72; root [7] l.GetX1();; root [8] l.GetX1(); (Double_t) 1.000000e+01; ```. Note some of the features of the ROOT prompt:; - Terminating with ‘`;`‘ is not required, see ""C++ Extensions To Ease; Scripting"" below.; - `Emacs` style command line editing.; - Raw interpreter commands start with a dot; `.g l` for instance shows the; interpreter information on the global called `l`.; - To show the result of an expression just do not type the trailing `;`. For the further examples we will ""abbreviate"" `root [0]` etc by `root []`. ``` {.cpp}; root [] .class TLine; ===========================================================================; class TLine; SIZE: 72 FILE: TLine.h LINE: 39; Base classes: --------------------------------------------------------; 0x20 public TAttBBox2D; List of member variables --------------------------------------------------; TLine.h 42 0x28 protected: Double_t fX1; TLine.h 43 0x30 protected: Double_t fY1; TLine.h 44 0x38 protected: Double_t fX2; TLine.h 45 0x40 protected: Double_t fY2; TLine.h 50 0x0 public: enum TLine::<anonymous at /home/axel/build/root/trunk/obj/include/TLine.h:49:4> kLineNDC; TLine.h 51 0x0 public: enum TLine::<anonymous at /home/axel/build/root/trunk/obj/include/TLine.h:49:4> kVertical; TLine.h 52 0x0 public: enum TLine::<anonymous at /home/axel/build/root/trunk/obj/include/TLine.h:49:4> kHorizontal; TLine.h 94 0x0 private: static class TClass *fgIsA; List of member functions :---------------------------------------------------; filename line:size busy function type and name; (compiled) (NA):(NA) 0 public: TLine();; (compiled) (NA):(NA) 0 public: TLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2);; (compiled) (NA):(NA) 0 public: TLine(const TLine &line);; (compiled) (NA):(NA) 0 public: virt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:2025,variab,variables,2025,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['variab'],['variables']
Modifiability,00%`; * - clang/tools/clang-format/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-fuzzer; - `6`; - `4`; - `2`; - :part:`66%`; * - clang/tools/clang-fuzzer/fuzzer-initialize; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-cxx; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-llvm; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/tools/clang-fuzzer/proto-to-cxx; - `5`; - `0`; - `5`; - :none:`0%`; * - clang/tools/clang-fuzzer/proto-to-llvm; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/tools/clang-import-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-linker-wrapper; - `3`; - `2`; - `1`; - :part:`66%`; * - clang/tools/clang-nvlink-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-offload-bundler; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-offload-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-pseudo; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-refactor; - `4`; - `4`; - `0`; - :good:`100%`; * - clang/tools/clang-rename; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-repl; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-scan-deps; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/diagtool; - `9`; - `0`; - `9`; - :none:`0%`; * - clang/tools/driver; - `4`; - `1`; - `3`; - :part:`25%`; * - clang/tools/libclang; - `35`; - `5`; - `30`; - :part:`14%`; * - clang/tools/scan-build-py/tests/functional/src/include; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/unittests/Analysis; - `6`; - `2`; - `4`; - :part:`33%`; * - clang/unittests/Analysis/FlowSensitive; - `14`; - `13`; - `1`; - :part:`92%`; * - clang/unittests/AST; - `30`; - `8`; - `22`; - :part:`26%`; * - clang/unittests/ASTMatchers; - `6`; - `3`; - `3`; - :part:`50%`; * - clang/unittests/ASTMatchers/Dynamic; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/unittests/Basic; - `8`; - `4`; - `4`; - :p,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:12237,refactor,refactor,12237,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['refactor'],['refactor']
Modifiability,"000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable; ""`var`"" in the **`TTree`** `tree` versus variable `v1 in `TTree ft1`; versus variable `v2` in **`TTree`** `ft2`. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; ```. ![](pictures/02000102.jpg)The picture illustrates the access of the tree; and its friends with a `Draw` command. When `AddFriend` is called, the ROOT file is automatically opened and; the friend tree (`ft1)` header is read into memory. The new friend; (`ft1`) is added to the list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries of the; original tree. If the friend tree has fewer entries, a warning is given; and the missing entries are not included in the histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is written to file (`TTree::Write`), the friends list is; saved with it. Moreover, when the tree is retrieved, the trees on the; friends list are also r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:54174,variab,variable,54174,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,3,['variab'],['variable']
Modifiability,"001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; ```. #### Adding a Branch with a Fixed Length Array. At first, we create a tree and create branches for a subset of variables; in the C structure` Gctrak_t`. Then we add several types of branches.; The first branch reads seven floating-point values beginning at the; address of `'gstep.vect'`. You do not need to specify `&gstep.vect`,; because in C and C++ the array variable holds the address of the first; element. ``` {.cpp}; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; ```. #### Adding a Branch with a Variable Length Array. The next two branches are dependent on each other. The first holds the; length of the variable length array and the second holds the variable; length array. The `lmec` branch reads `nmec` number of integers; beginning at the address `gstep.lmec`. ``` {.cpp}; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; ```. The variable `nmec` is a random number and is reset for each entry. ``` {.cpp}; gstep.nmec = (Int_t)(5*gRandom->Rndm());; ```. #### Filling the Tree. In this emulation of Geant3, we generate and transport particles in a; magnetic field and store the particle parameters at each tracking step; in a ROOT tree. ### Analysis. In this analysis, we do not read the entire entry we only read one; branch. First,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:48123,variab,variable,48123,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _StatementMacros:. **StatementMacros** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <StatementMacros>`; A vector of macros that should be interpreted as complete; statements. Typical macros are expressions, and require a semi-colon to be; added; sometimes this is not the case, and this allows to make; clang-format aware of such cases. For example: Q_UNUSED. .. _TabWidth:. **TabWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <TabWidth>`; The number of columns used for tab stops. .. _TypeNames:. **TypeNames** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <TypeNames>`; A vector of non-keyword identifiers that should be interpreted as type; names. A ``*``, ``&``, or ``&&`` between a type name and another non-keyword; id",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:130256,variab,variable,130256,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['variab'],['variable']
Modifiability,"0324235020.49706-1-michael@platin.gs/>`_; whether similar functionality could be added to ``git blame`` itself. Minimising cost of downstream merges; ************************************. There are many forks of LLVM with downstream changes. Merging a large-scale; renaming change could be difficult for the fork maintainers. **Mitigation**: A large-scale renaming would be automated. A fork maintainer can; merge from the commit immediately before the renaming, then apply the renaming; script to their own branch. They can then merge again from the renaming commit,; resolving all conflicts by choosing their own version. This could be tested on; the [SVE]_ fork. Provisional Plan; ================. This is a provisional plan for the `Big bang`_ approach. It has not been agreed. #. Investigate improving ``git blame``. The extent to which it can be made to; ""look through"" commits may impact how big a change can be made. #. Write a script to expand acronyms. #. Experiment and perform dry runs of the various refactoring options.; Results can be published in forks of the LLVM Git repository. #. Consider the evidence and agree on the new policy. #. Agree & announce a date for the renaming of the starter project (LLD). #. Update the `policy page <../CodingStandards.html>`_. This will explain the; old and new rules and which projects each applies to. #. Refactor the starter project in two commits:. 1. Add or change the project's .clang-tidy to reflect the agreed rules.; (This is in a separate commit to enable the merging process described in; `Minimising cost of downstream merges`_).; Also update the project list on the policy page.; 2. Apply ``clang-tidy`` to the project's files, with only the; ``readability-identifier-naming`` rules enabled. ``clang-tidy`` will also; reformat the affected lines according to the rules in ``.clang-format``.; It is anticipated that this will be a good dog-fooding opportunity for; clang-tidy, and bugs should be fixed in the process, likely includin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:10760,refactor,refactoring,10760,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['refactor'],['refactoring']
Modifiability,"03_numintcache.C has been added to $ROOTSYS/tutorials/roofit; to illustrate the use of this feature. Representation of function and p.d.f. derivatives; A new class has been added that can represent the derivative of any p.d.f or function w.r.t. any; parameter or observable. To construct e.g. a first order derivative of a Gaussian p.d.f, do. RooAbsReal* dgdx = gauss.derivative(x,1) ;. A more complete example is available in the new tutorial macro rf111_derivatives.C. Improved handling of chi-squared fits; Chi-squared fits can now be performed through the same style of interface as likelihood fits,; through the newly added method RooAbsReal::chi2FitTo(const RooDataHist&,...). Functions that can be fitted with chi-squared minimization are any RooAbsReal based function; as well as RooAbsPdf based p.d.f.s. In case of non-extended p.d.f.s the probability density; calculated by the p.d.f. is multiplied with the number of events in the histogram to adjust; the scale of the function. In case of extended p.d.f.s, the adjustment is made with the expected; number of events, rather than the observed number of events. Tutorial macro rf602_chi2fit.C has been updated to use this new interface. Chi-squared fits to X-Y datasets now possible; In addition to the ability to perform chi-squared fits to histograms it is now also possible; to perform chi-squared fits to unbinned datasets containing a series of X and Y values; with associated errors on Y and optionally on X. These 'X-Y' chi-squared fits are interfaced through newly added method; RooAbsReal::chi2FitTo(const RooDataSet&,...). By default the event weight is; interpreted as the 'Y' value, but an YVar() argument can designate any other; dataset column as Y value. If X errors are defined, one can choose to integrate the fitted; function over the range of the X errors, rather than taking the central value by adding; an Integrate(true) argument to chi2FitTo(); Two new arguments, StoreError(const RooArgSet&) and StoreAsymError(const ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:7957,extend,extended,7957,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['extend'],['extended']
Modifiability,"0xa0463447. but would not match the text:. .. code-block:: gas. load r5, [r0]; load r7, [r1]; Loading from 0xa0463440 to 0xa0463443. Due to ``7`` being unequal to ``5 + 1`` and ``a0463443`` being unequal to; ``a0463440 + 7``. A numeric variable can also be defined to the result of a numeric expression,; in which case the numeric expression constraint is checked and if verified the; variable is assigned to the value. The unified syntax for both checking a; numeric expression and capturing its value into a numeric variable is thus; ``[[#%<fmtspec>,<NUMVAR>: <constraint> <expr>]]`` with each element as; described previously. One can use this syntax to make a testcase more; self-describing by using variables instead of values:. .. code-block:: gas. ; CHECK: mov r[[#REG_OFFSET:]], 0x[[#%X,FIELD_OFFSET:12]]; ; CHECK-NEXT: load r[[#]], [r[[#REG_BASE:]], r[[#REG_OFFSET]]]. which would match:. .. code-block:: gas. mov r4, 0xC; load r6, [r5, r4]. The ``--enable-var-scope`` option has the same effect on numeric variables as; on string variables. Important note: In its current implementation, an expression cannot use a; numeric variable defined earlier in the same CHECK directive. FileCheck Pseudo Numeric Variables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Sometimes there's a need to verify output that contains line numbers of the; match file, e.g. when testing compiler diagnostics. This introduces a certain; fragility of the match file structure, as ""``CHECK:``"" lines contain absolute; line numbers in the same file, which have to be updated whenever line numbers; change due to text addition or deletion. To support this case, FileCheck expressions understand the ``@LINE`` pseudo; numeric variable which evaluates to the line number of the CHECK pattern where; it is found. This way match patterns can be put near the relevant test lines and include; relative line number references, for example:. .. code-block:: c++. // CHECK: test.cpp:[[# @LINE + 4]]:6: error: expected ';' after top le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:33389,variab,variables,33389,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,2,['variab'],['variables']
Modifiability,"1, metadata !23, metadata !DIExpression()), !dbg !24; %value1 = add i32 %input, 1; br label %bb1. falsebr:; call void @llvm.dbg.value(metadata i32 %input, metadata !30, metadata !DIExpression()), !dbg !24; call void @llvm.dbg.value(metadata i32 2, metadata !23, metadata !DIExpression()), !dbg !24; %value2 = add i32 %input, 2; br label %bb1. exit:; ret i32 %value, !dbg !30; }. Here the difficulties are:. * The control flow is roughly the opposite of basic block order; * The value of the ``!23`` variable merges into ``%bb1``, but there is no PHI; node. As mentioned above, the ``llvm.dbg.value`` intrinsics essentially form an; imperative program embedded in the IR, with each intrinsic defining a variable; location. This *could* be converted to an SSA form by mem2reg, in the same way; that it uses use-def chains to identify control flow merges and insert phi; nodes for IR Values. However, because debug variable locations are defined for; every machine instruction, in effect every IR instruction uses every variable; location, which would lead to a large number of debugging intrinsics being; generated. Examining the example above, variable ``!30`` is assigned ``%input`` on both; conditional paths through the function, while ``!23`` is assigned differing; constant values on either path. Where control flow merges in ``%bb1`` we would; want ``!30`` to keep its location (``%input``), but ``!23`` to become undefined; as we cannot determine at runtime what value it should have in %bb1 without; inserting a PHI node. mem2reg does not insert the PHI node to avoid changing; codegen when debugging is enabled, and does not insert the other dbg.values; to avoid adding very large numbers of intrinsics. Instead, LiveDebugValues determines variable locations when control; flow merges. A dataflow analysis is used to propagate locations between blocks:; when control flow merges, if a variable has the same location in all; predecessors then that location is propagated into the successor. If ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:38572,variab,variable,38572,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['variab'],['variable']
Modifiability,"1->SetGrid();. Float_t bintime = 1;; // one bin = 1 second. change it to set the time scale; TH1F *ht = new TH1F(""ht"",""The ROOT seism"",10,0,10*bintime);; Float_t signal = 1000;; ht->SetMaximum(signal);; ht->SetMinimum(-signal);; ht->SetStats(0);; ht->SetLineColor(2);; ht->GetXaxis()->SetTimeDisplay(1);; ht->GetYaxis()->SetNdivisions(520);; ht->Draw();. for (Int_t i=1;i<2300;i++) {; // Build a signal : noisy damped sine; Float_t noise = gRandom->Gaus(0,120);; if (i > 700); noise += signal*sin((i-700.)*6.28/30)*exp((700.-i)/300.);; ht->SetBinContent(i,noise);; c1->Modified();; c1->Update();; gSystem->ProcessEvents();; //canvas can be edited during the loop; }; printf(""Real Time = %8.3fs,Cpu Time = %8.3fsn"",sw.RealTime(),; sw.CpuTime());; }; ```. ## Graphical Objects Attributes. ### Text Attributes. When a class contains text or derives from a text class, it needs to be; able to set text attributes like font type, size, and color. To do so,; the class inherits from the **`TAttText`** class (a secondary; inheritance), which defines text attributes. **`TLatex`** and; **`TText`** inherit from **`TAttText`**. #### Setting Text Alignment. Text alignment may be set by a method call. What is said here applies to; all objects deriving from **`TAttText`**, and there are many. We will; take an example that may be transposed to other types. Suppose ""`la`"" is; a **`TLatex`** object. The alignment is set with:. ``` {.cpp}; root[] la->SetTextAlign(align); ```. The parameter `align` is a `short` describing the alignment:. `align = 10*HorizontalAlign + VerticalAlign`. For horizontal alignment, the following convention applies:. - 1 = left. - 2 = centered. - 3 = right. For vertical alignment, the following convention applies:. - 1 = bottom. - 2 = centered. - 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right; adjusted and vertically centered. #### Setting Text Angle. Use `TAttText::SetTextAngle` to set the text angle. The `angle` is the; degrees of the horiz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:68963,inherit,inherits,68963,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,2,['inherit'],"['inheritance', 'inherits']"
Modifiability,"1.0; -----------------. * Support for vector calls with CPython 3.8 and newer; * Support for typed C++ literals as defaults when mixing with keywords; * Enable reshaping of multi-dim LowLevelViews; * Refactored multi-dim arrays and support for multi-dim assignment; * Support tuple-based indexing for multi-dim arrays; * Direct support for C's _Complex (_Complex_double/_float on Windows); * sizeof() forwards to ctypes.sizeof() for ctypes' types; * Upgrade cmake fragments for Clang9; * Prevent clash with Julia's LLVM when loading cppyy into PyCall; * Upgrade to latest Cling patch release. 2021-05-14: 2.0.0; -----------------. * Upgrade to latest Cling based on Clang/LLVM 9; * Make C++17 the default standard on Windows. 2021-04-28: 1.9.6; -----------------. * Reverse operators for ``std::complex`` targeting Python's ``complex``; * Version the precompiled header with the ``cppyy-cling`` package version; * Cover more iterator protocol use cases; * Add missing cppyy/__pyinstaller pkg to sdist; * Single-inheritance support for cross-inherited templated constructors; * Disallow ``float`` -> ``const long long&`` conversion; * Capture python exception message string in PyException from callbacks; * Thread safety in enum lookups. 2021-03-22: 1.9.5; -----------------. * Do not regulate direct smart pointers (many to one can lead to double deletion); * Use pkg_resources of ``CPyCppyy``, if available, to find the API include path. 2021-03-17: 1.9.4; -----------------. * Fix for installing into a directory that has a space in the name; * Fix empty collection printing through Cling on 64b Windows; * Fix accidental shadowing of derived class typedefs by same names in base; * Streamlined templated function lookups in namespaces; * Fix edge cases when decomposing std::function template arguments; * Enable multi-cross inheritance with non-C++ python bases; * Support Bound C++ functions as template argument; * Python functions as template arguments from ``__annotations__`` or ``__cpp_nam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:6539,inherit,inheritance,6539,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,2,['inherit'],"['inheritance', 'inherited']"
Modifiability,"1.link/P2864R2>`_. - Implemented `P2361R6 Template parameter initialization <https://wg21.link/P2308R1>`_.; This change is applied as a DR in all language modes. Resolutions to C++ Defect Reports; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. - Implemented `CWG2598 <https://wg21.link/CWG2598>`_ and `CWG2096 <https://wg21.link/CWG2096>`_,; making unions (that have either no members or at least one literal member) literal types.; (`#77924 <https://github.com/llvm/llvm-project/issues/77924>`_). C Language Changes; ------------------; - ``structs``, ``unions``, and ``arrays`` that are const may now be used as; constant expressions. This change is more consistent with the behavior of; GCC.; - Enums will now be represented in TBAA metadata using their actual underlying; integer type. Previously they were treated as chars, which meant they could; alias with all other types.; - Clang now supports the C-only attribute ``counted_by``. When applied to a; struct's flexible array member, it points to the struct field that holds the; number of elements in the flexible array member. This information can improve; the results of the array bound sanitizer and the; ``__builtin_dynamic_object_size`` builtin. C23 Feature Support; ^^^^^^^^^^^^^^^^^^^; - Clang now accepts ``-std=c23`` and ``-std=gnu23`` as language standard modes,; and the ``__STDC_VERSION__`` macro now expands to ``202311L`` instead of its; previous placeholder value. Clang continues to accept ``-std=c2x`` and; ``-std=gnu2x`` as aliases for C23 and GNU C23, respectively.; - Clang now supports `requires c23` for module maps.; - Clang now supports ``N3007 Type inference for object definitions``. - Clang now supports ``<stdckdint.h>`` which defines several macros for performing; checked integer arithmetic. It is also exposed in pre-C23 modes. - Completed the implementation of; `N2508 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2508.pdf>`_. We; previously implemented allowing a label at the end of a compound statement,; and now ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:12358,flexible,flexible,12358,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,2,['flexible'],['flexible']
Modifiability,"11003/histo;1"",h); ```. If file is written, a copy of `histo` will be in the top directory. This; is an effective way to copy an object from one directory to another. In; contrast, in the code box below, `histo` will be in memory in the; subdirectory because we changed the current directory. ``` {.cpp}; root[] f->cd(""Wed011003""); root[] TH1 *h; gDirectory->GetObject(""histo;1"",h); ```. Note that there is no warning if the retrieving was not successful. You; need to explicitly check the value of h, and if it is null, the object; could not be found. For example, if you did not give the path name the; histogram cannot be found and the pointer to h is null:. ``` {.cpp}; root[] TH1 *h; gDirectory->GetObject(""Wed011003/histo;1"",h); root[] h; (class TH1*)0x10767de0; root[] TH1 *h; gDirectory->GetObject(""histo;1"",h); root[] h; (class TH1*)0x0; ```. To remove a subdirectory you need to use `TDirectory::Delete`. There is; no **`TDirectory::rmdir`**. The Delete method takes a string containing; the variable name and cycle number as a parameter. ``` {.cpp}; void Delete(const char *namecycle); ```. The `namecycle` string has the format `name;cycle`. The next are some; rules to remember:. - `name` = \* means all, but don't remove the subdirectories. - `cycle` =\* means all cycles (memory and file). - `cycle` ="""" means apply to a memory object. - `cycle` = 9999 also means apply to a memory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:40752,variab,variable,40752,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability,"16 but in split encoding |; | 0x1D |10-31 | Real32Trunc | IEEE-754 single precision float with truncated mantissa |; | 0x1E | 1-32 | Real32Quant | Real value contained in a specified range with an underlying quantized integer representation |. The ""split encoding"" columns apply a byte transformation encoding to all pages of that column; and in addition, depending on the column type, delta or zigzag encoding:. Split (only); : Rearranges the bytes of elements: All the first bytes first, then all the second bytes, etc. Delta + split; : The first element is stored unmodified, all other elements store the delta to the previous element.; Followed by split encoding. Zigzag + split; : Used on signed integers only; it maps $x$ to $2x$ if $x$ is positive and to $-(2x+1)$ if $x$ is negative.; Followed by split encoding. **Note**: these encodings always happen within each page, thus decoding should be done page-wise,; not cluster-wise. The `Real32Trunc` type column is a variable-sized floating point column; with lower precision than `Real32` and `SplitReal32`.; It is an IEEE-754 single precision float with some of the mantissa's least significant bits truncated. The `Real32Quant` type column is a variable-sized real column that is internally represented as an integer within; a specified range of values. For this column type, flag 0x10 (column with range) is always set (see paragraphs below). Future versions of the file format may introduce additional column types; without changing the minimum version of the header or introducing a feature flag.; Old readers need to ignore these columns and fields constructed from such columns.; Old readers can, however, figure out the number of elements stored in such unknown columns. The ""flags"" field can have one of the following bits set. | Bit | Meaning |; |----------|-------------------------------------------------------------------|; | 0x08 | Deferred column: index of first element in the column is not zero |; | 0x10 | Column with a range",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:23307,variab,variable-sized,23307,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['variab'],['variable-sized']
Modifiability,"2 = INC32r %0, implicit-def dead $eflags, debug-location !5; DBG_VALUE %1, $noreg, !3, !DIExpression(), debug-location !5; %6:gr32 = ADD32rm %4, %2, 4, killed %5, 0, $noreg, implicit-def dead $eflags :: (load 4 from %ir.addr2); %7:gr32 = SUB32rr %6, %0, implicit-def $eflags, debug-location !5; JB_1 %bb.1, implicit $eflags, debug-location !5; JMP_1 %bb.2, debug-location !5. bb.2.bb2:; %8:gr32 = MOV32r0 implicit-def dead $eflags; $eax = COPY %8, debug-location !5; RET 0, $eax, debug-location !5. Observe first that there is a DBG_VALUE instruction for every ``llvm.dbg.value``; intrinsic in the source IR, ensuring no source level assignments go missing.; Then consider the different ways in which variable locations have been recorded:. * For the first dbg.value an immediate operand is used to record a zero value.; * The dbg.value of the PHI instruction leads to a DBG_VALUE of virtual register; ``%0``.; * The first GEP has its effect folded into the first load instruction; (as a 4-byte offset), but the variable location is salvaged by folding; the GEPs effect into the DIExpression.; * The second GEP is also folded into the corresponding load. However, it is; insufficiently simple to be salvaged, and is emitted as a ``$noreg``; DBG_VALUE, indicating that the variable takes on an undefined location.; * The final dbg.value has its Value placed in virtual register ``%1``. Instruction Scheduling; ----------------------. A number of passes can reschedule instructions, notably instruction selection; and the pre-and-post RA machine schedulers. Instruction scheduling can; significantly change the nature of the program -- in the (very unlikely) worst; case the instruction sequence could be completely reversed. In such; circumstances LLVM follows the principle applied to optimizations, that it is; better for the debugger not to display any state than a misleading state.; Thus, whenever instructions are advanced in order of execution, any; corresponding DBG_VALUE is kept in its origin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:32271,variab,variable,32271,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10215,config,configure,10215,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,2,['config'],"['configuration', 'configure']"
Modifiability,"2, $noreg, !3, !DIExpression(DW_OP_plus_uconst, 4, DW_OP_stack_value), debug-location !5; %4:gr32 = MOV32rm %2, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1); %5:gr64_nosp = MOVSX64rr32 %0, debug-location !5; DBG_VALUE $noreg, $noreg, !3, !DIExpression(), debug-location !5; %1:gr32 = INC32r %0, implicit-def dead $eflags, debug-location !5; DBG_VALUE %1, $noreg, !3, !DIExpression(), debug-location !5; %6:gr32 = ADD32rm %4, %2, 4, killed %5, 0, $noreg, implicit-def dead $eflags :: (load 4 from %ir.addr2); %7:gr32 = SUB32rr %6, %0, implicit-def $eflags, debug-location !5; JB_1 %bb.1, implicit $eflags, debug-location !5; JMP_1 %bb.2, debug-location !5. bb.2.bb2:; %8:gr32 = MOV32r0 implicit-def dead $eflags; $eax = COPY %8, debug-location !5; RET 0, $eax, debug-location !5. Observe first that there is a DBG_VALUE instruction for every ``llvm.dbg.value``; intrinsic in the source IR, ensuring no source level assignments go missing.; Then consider the different ways in which variable locations have been recorded:. * For the first dbg.value an immediate operand is used to record a zero value.; * The dbg.value of the PHI instruction leads to a DBG_VALUE of virtual register; ``%0``.; * The first GEP has its effect folded into the first load instruction; (as a 4-byte offset), but the variable location is salvaged by folding; the GEPs effect into the DIExpression.; * The second GEP is also folded into the corresponding load. However, it is; insufficiently simple to be salvaged, and is emitted as a ``$noreg``; DBG_VALUE, indicating that the variable takes on an undefined location.; * The final dbg.value has its Value placed in virtual register ``%1``. Instruction Scheduling; ----------------------. A number of passes can reschedule instructions, notably instruction selection; and the pre-and-post RA machine schedulers. Instruction scheduling can; significantly change the nature of the program -- in the (very unlikely) worst; case the instruction sequence could",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:31960,variab,variable,31960,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,2023-03-19: 3.0.0; -----------------. * Upgrade backend to Cling on top of LLVM 13; * Improve handling of `const char*` as template argument; * Fix regression in use of unnamed but typedef'ed enums; * Report C++ warnings from ``cppdef`` as ``SyntaxWarning``; * Add pythonizations for ``std::unordered_map``. 2023-01-21: 2.4.2; -----------------. * Added a generic ``cppyy.default`` object; * Support explicitly created initializer lists as arguments; * Pass instances by-ref in Numba traces; * Support non-POD by-value returns in Numba traces; * Nullify derived class Python proxy when the C++ object is deleted; * Add ``__cpp_template__`` back reference for instantiated templated classes; * Improved buffer checking for ``std::initializer_list``; * Add convenience functions ``argc()`` and ``argv()`` to ``cppyy.ll``; * Added ``nullptr`` comparisons for for typed ``nullptr``; * Support for ``using`` pointer types as template arguments; * Walk the full inheritance tree to find the overloads; * Allow ``__destruct__`` override in Python derived class; * Allow ``NULL`` function pointers to be returned as ``std::function`` objects; * Add Python traceback to C++ exception ``what()``. 2022-10-03: 2.4.1; -----------------. * Drop Numba extension entry point. 2022-06-29: 2.4.0; -----------------. * Support for free (templated) functions in Numba; * Basic support for unboxing C++ public data members in Numba; * Basic support for calling methods of C++ structs in Numba; * Added conventional `__cpp_reflex__` method for inspection in Numba; * Support for globally overloaded ordering operators; * Special cases for `__repr__`/`__str__` returning C++ stringy types; * Fix lookup of templates of function with template args; * Correct typing of int8_t/uint8_t enums; * Basic support for hidden enums; * Support function pointer returns and optimize function point variables; * Fix reuse of CPPOverload proxies in vector calls from different threads; * Use `-march=native` instead of checking the cpu,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:2969,inherit,inheritance,2969,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['inherit'],['inheritance']
Modifiability,"23; 0.621261; 0. ## CVS code repository ##. How to check out (–in) code from the CVS code repository is described at; the M homepage @bib-C++MINUIT. To get the source code from the CVS; repository one needs to do:. Kerberos IV authorization:. $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, var",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:24731,config,configure,24731,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['config'],['configure']
Modifiability,"253](https://github.com/root-project/root/issues/15253)] - C++ standard not propagated via CMake anymore; * [[#15197](https://github.com/root-project/root/issues/15197)] - RBDT does not support xgboost inference; * [[#15156](https://github.com/root-project/root/issues/15156)] - Segfault in TMVA::Experimental::SOFIE::RModel::Streamer; * [[#15139](https://github.com/root-project/root/issues/15139)] - cmake option -Dall=YES breaks the cmake; * [[#15118](https://github.com/root-project/root/issues/15118)] - jsoninterface does not build if provided with RapidYAML; * [[#15108](https://github.com/root-project/root/issues/15108)] - Turn off clang-format for Linkdef files; * [[#15090](https://github.com/root-project/root/issues/15090)] - TClass::GetClassInfo() is not thread safe; * [[#15077](https://github.com/root-project/root/issues/15077)] - Passing different floating point types to `RVec` utility functions; * [[#15048](https://github.com/root-project/root/issues/15048)] - [ntuple] Handling of virtual inheritance broken; * [[#15040](https://github.com/root-project/root/issues/15040)] - [RDataFrame] Inaccurate example of progress bar from documentation; * [[#15028](https://github.com/root-project/root/issues/15028)] - [RDataFrame] Unable to cacheread remote file; * [[#15027](https://github.com/root-project/root/issues/15027)] - spurrious cmake message about AfterImage with -Dminimal=ON; * [[#14981](https://github.com/root-project/root/issues/14981)] - RVecs leak memory with np.asarray in pyROOT; * [[#14964](https://github.com/root-project/root/issues/14964)] - ROOT-HEAD fails with ""cling interactive line includer >>>: fatal error: module file '[snip]/Vc.pcm' not found: module file not found""; * [[#14958](https://github.com/root-project/root/issues/14958)] - ROOT_HEAD failed with error message: Fail to detect cryptographic random generator; * [[#14921](https://github.com/root-project/root/issues/14921)] - ROOT Fails to build macOS 14.4 arm64 Xcode 15.3; * [[#14914](https://g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:27029,inherit,inheritance,27029,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['inherit'],['inheritance']
Modifiability,"2`,; `y2`. The default text attributes for the legend are:. - Alignment = 12 left adjusted and vertically centered. - Angle = 0 (degrees). - Color = 1 (black). - Size = calculate when number of entries is known. - Font = helvetica-medium-r-normal scalable font = 42, and bold = 62; for title. The title is a regular entry and supports **`TLatex`**. The default is; no title (`header = 0`). The options are the same as for **`TPave`**; by; default, they are ""`brand`"". Once the legend box is created, one has to; add the text with the `AddEntry()` method:. ``` {.cpp}; TLegendEntry* TLegend::AddEntry(TObject *obj,; const char *label,; Option_t *option); ```. The parameters are:. - `*obj `is a pointer to an object having marker, line, or fill; attributes (a histogram, or a graph). - `label` is the label to be associated to the object. - `option`:. - ""L"" draw line associated with line attributes of `obj`, if `obj`; inherits from **`TAttLine`**. - ""P"" draw poly-marker associated with marker attributes of `obj`, if; `obj` inherits **`TAttMarker`**. - ""F"" draw a box with fill associated with fill attributes of `obj`,; if `obj` inherits **`TAttFill`**. One may also use the other form of the method `AddEntry`:. ``` {.cpp}; TLegendEntry* TLegend::AddEntry(const char *name,; const char *label,; Option_t *option); ```. Here `name` is the name of the object in the pad. Other parameters are; as in the previous case. Next example shows how to create a legend:. ``` {.cpp}; leg = new TLegend(0.4,0.6,0.89,0.89);; leg->AddEntry(fun1,""One Theory"",""l"");; leg->AddEntry(fun3,""Another Theory"",""f"");; leg->AddEntry(gr,""The Data"",""p"");; leg->Draw();; // oops we forgot the blue line... add it after; leg->AddEntry(fun2,; ""#sqrt{2#pi} P_{T} (#gamma) latex formula"",""f"");; // and add a header (or ""title"") for the legend; leg->SetHeader(""The Legend Title"");; leg->Draw();; ```. Here `fun1`, `fun2`, `fun3` and `gr` are pre-existing functions and; graphs. You can edit the **`TLegend`** by right clicking on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:90969,inherit,inherits,90969,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inherits']
Modifiability,"3), !dbg !19; ; [debug line = 5:9] [debug variable = Z]. The third intrinsic ``%llvm.dbg.declare`` encodes debugging information for; variable ``Z``. The metadata ``!dbg !19`` attached to the intrinsic provides; scope information for the variable ``Z``. .. code-block:: text. !18 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5); !19 = !DILocation(line: 5, column: 11, scope: !18). Here ``!19`` indicates that ``Z`` is declared at line number 5 and column; number 11 inside of lexical scope ``!18``. The lexical scope itself resides; inside of subprogram ``!4`` described above. The scope information attached with each instruction provides a straightforward; way to find instructions covered by a scope. Object lifetime in optimized code; =================================. In the example above, every variable assignment uniquely corresponds to a; memory store to the variable's position on the stack. However in heavily; optimized code LLVM promotes most variables into SSA values, which can; eventually be placed in physical registers or memory locations. To track SSA; values through compilation, when objects are promoted to SSA values an; ``llvm.dbg.value`` intrinsic is created for each assignment, recording the; variable's new location. Compared with the ``llvm.dbg.declare`` intrinsic:. * A dbg.value terminates the effect of any preceding dbg.values for (any; overlapping fragments of) the specified variable.; * The dbg.value's position in the IR defines where in the instruction stream; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the program. For any; execution of the optimized program, the set of variable values presented to the; developer by the debugger should not show a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:18046,variab,variables,18046,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to he",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:196042,variab,variable,196042,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variable']
Modifiability,"3.7` :ref:`¶ <KeepEmptyLinesAtTheStartOfBlocks>`; If true, the empty line at the start of blocks is kept. .. code-block:: c++. true: false:; if (foo) { vs. if (foo) {; bar();; bar(); }; }. .. _LambdaBodyIndentation:. **LambdaBodyIndentation** (``LambdaBodyIndentationKind``) :versionbadge:`clang-format 13` :ref:`¶ <LambdaBodyIndentation>`; The indentation style of lambda bodies. ``Signature`` (the default); causes the lambda body to be indented one additional level relative to; the indentation level of the signature. ``OuterScope`` forces the lambda; body to be indented one additional level relative to the parent scope; containing the lambda signature. Possible values:. * ``LBI_Signature`` (in configuration: ``Signature``); Align lambda body relative to the lambda signature. This is the default. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:82729,config,configuration,82729,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"317337), the ""old"" version of the; allocator can be linked with a binary at compilation using the; ``-fsanitize=scudo`` command-line argument, if the target platform is supported.; Currently, the only other sanitizer Scudo is compatible with is UBSan; (eg: ``-fsanitize=scudo,undefined``). Compiling with Scudo will also enforce; PIE for the output binary. We will transition this to the standalone Scudo version in the future. Options; -------; Several aspects of the allocator can be configured on a per process basis; through the following ways:. - at compile time, by defining ``SCUDO_DEFAULT_OPTIONS`` to the options string; you want set by default;. - by defining a ``__scudo_default_options`` function in one's program that; returns the options string to be parsed. Said function must have the following; prototype: ``extern ""C"" const char* __scudo_default_options(void)``, with a; default visibility. This will override the compile time define;. - through the environment variable SCUDO_OPTIONS, containing the options string; to be parsed. Options defined this way will override any definition made; through ``__scudo_default_options``. - via the standard ``mallopt`` `API <https://man7.org/linux/man-pages/man3/mallopt.3.html>`_,; using parameters that are Scudo specific. When dealing with the options string, it follows a syntax similar to ASan, where; distinct options can be assigned in the same string, separated by colons. For example, using the environment variable:. .. code:: console. SCUDO_OPTIONS=""delete_size_mismatch=false:release_to_os_interval_ms=-1"" ./a.out. Or using the function:. .. code:: cpp. extern ""C"" const char *__scudo_default_options() {; return ""delete_size_mismatch=false:release_to_os_interval_ms=-1"";; }. The following ""string"" options are available:. +---------------------------------+----------------+-------------------------------------------------+; | Option | Default | Description |; +---------------------------------+----------------+----------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:7588,variab,variable,7588,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['variab'],['variable']
Modifiability,"32 %toret, metadata !1, metadata !2); ret i32 %toret; }. There are a few other dbg.value configurations that mean it terminates; dominating location definitions without adding a new location. The complete; list is:. * Any location operand is ``poison`` (or ``undef``).; * Any location operand is an empty metadata tuple (``!{}``) (which cannot; occur in a ``!DIArgList``).; * There are no location operands (empty ``DIArgList``) and the ``DIExpression``; is empty. This class of dbg.value that kills variable locations is called a ""kill; dbg.value"" or ""kill location"", and for legacy reasons the term ""undef; dbg.value"" may be used in existing code. The ``DbgVariableIntrinsic`` methods; ``isKillLocation`` and ``setKillLocation`` should be used where possible rather; than inspecting location operands directly to check or set whether a dbg.value; is a kill location. In general, if any dbg.value has its operand optimized out and cannot be; recovered, then a kill dbg.value is necessary to terminate earlier variable; locations. Additional kill dbg.values may be necessary when the debugger can; observe re-ordering of assignments. How variable location metadata is transformed during CodeGen; ============================================================. LLVM preserves debug information throughout mid-level and backend passes,; ultimately producing a mapping between source-level information and; instruction ranges. This; is relatively straightforwards for line number information, as mapping; instructions to line numbers is a simple association. For variable locations; however the story is more complex. As each ``llvm.dbg.value`` intrinsic; represents a source-level assignment of a value to a source variable, the; variable location intrinsics effectively embed a small imperative program; within the LLVM IR. By the end of CodeGen, this becomes a mapping from each; variable to their machine locations over ranges of instructions.; From IR to object emission, the major transformations wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:23701,variab,variable,23701,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"32 = SUB32rr %6, %0, implicit-def $eflags, debug-location !5; JB_1 %bb.1, implicit $eflags, debug-location !5; JMP_1 %bb.2, debug-location !5. bb.2.bb2:; %8:gr32 = MOV32r0 implicit-def dead $eflags; $eax = COPY %8, debug-location !5; RET 0, $eax, debug-location !5. Observe first that there is a DBG_VALUE instruction for every ``llvm.dbg.value``; intrinsic in the source IR, ensuring no source level assignments go missing.; Then consider the different ways in which variable locations have been recorded:. * For the first dbg.value an immediate operand is used to record a zero value.; * The dbg.value of the PHI instruction leads to a DBG_VALUE of virtual register; ``%0``.; * The first GEP has its effect folded into the first load instruction; (as a 4-byte offset), but the variable location is salvaged by folding; the GEPs effect into the DIExpression.; * The second GEP is also folded into the corresponding load. However, it is; insufficiently simple to be salvaged, and is emitted as a ``$noreg``; DBG_VALUE, indicating that the variable takes on an undefined location.; * The final dbg.value has its Value placed in virtual register ``%1``. Instruction Scheduling; ----------------------. A number of passes can reschedule instructions, notably instruction selection; and the pre-and-post RA machine schedulers. Instruction scheduling can; significantly change the nature of the program -- in the (very unlikely) worst; case the instruction sequence could be completely reversed. In such; circumstances LLVM follows the principle applied to optimizations, that it is; better for the debugger not to display any state than a misleading state.; Thus, whenever instructions are advanced in order of execution, any; corresponding DBG_VALUE is kept in its original position, and if an instruction; is delayed then the variable is given an undefined location for the duration; of the delay. To illustrate, consider this pseudo-MIR:. .. code-block:: text. %1:gr32 = MOV32rm %0, 1, $noreg, 4, $nor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:32531,variab,variable,32531,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"32>, <vscale x 2 x i64>}``; doesn't). These kinds of structs (we may call them homogeneous scalable vector; structs) are considered sized and can be used in loads, stores, allocas, but; not GEPs. Syntax::. @<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]; [DLLStorageClass] [ThreadLocal]; [(unnamed_addr|local_unnamed_addr)] [AddrSpace]; [ExternallyInitialized]; <global | constant> <Type> [<InitializerConstant>]; [, section ""name""] [, partition ""name""]; [, comdat [($name)]] [, align <Alignment>]; [, code_model ""model""]; [, no_sanitize_address] [, no_sanitize_hwaddress]; [, sanitize_address_dyninit] [, sanitize_memtag]; (, !name !N)*. For example, the following defines a global in a numbered address space; with an initializer, section, and alignment:. .. code-block:: llvm. @G = addrspace(5) constant float 1.0, section ""foo"", align 4. The following example just declares a global variable. .. code-block:: llvm. @G = external global i32. The following example defines a global variable with the; ``large`` code model:. .. code-block:: llvm. @G = internal global i32 0, code_model ""large"". The following example defines a thread-local global with the; ``initialexec`` TLS model:. .. code-block:: llvm. @G = thread_local(initialexec) global i32 0, align 4. .. _functionstructure:. Functions; ---------. LLVM function definitions consist of the ""``define``"" keyword, an; optional :ref:`linkage type <linkage>`, an optional :ref:`runtime preemption; specifier <runtime_preemption_model>`, an optional :ref:`visibility; style <visibility>`, an optional :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`calling convention <callingconv>`,; an optional ``unnamed_addr`` attribute, a return type, an optional; :ref:`parameter attribute <paramattrs>` for the return type, a function; name, a (possibly empty) argument list (each with optional :ref:`parameter; attributes <paramattrs>`), optional :ref:`function attributes <fnattrs>`,; an optional address space, an optional ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:37463,variab,variable,37463,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<VarDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. AST Traversal Matchers. Traversal matchers specify the relationship to other nodes that are; reachable from the current node.; Note that there are special traversal matchers (has, hasDescendant, forEach and; forEachDescendant) which work on all nodes and allow users to write more generic; match expressions. Return type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:128961,variab,variable,128961,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"4 points to an object of class: TH1F at 5038; ```. In addition to the list of keys, **`TFile`** also keeps two other lists:; **`TFile`**`::fFree` is a **`TList`** of free blocks used to recycle; freed up space in the file. ROOT tries to find the best free block. If a; free block matches the size of the new object to be stored, the object; is written in the free block and this free block is deleted from the; list. If not, the first free block bigger than the object is used.; `TFile::fListHead` contains a sorted list (**`TSortedList`**) of objects; in memory. The diagram below illustrates the logical view of the; **`TFile`** and **`TKey`**. ![ROOT File/Directory/Key description](pictures/030000E7.png). ### Viewing the Logical File Contents. **`TFile`** is a descendent of **`TDirectory`**, which means it behaves; like a **`TDirectory`**. We can list the contents, print the name, and; create subdirectories. In a ROOT session, you are always in a directory; and the directory you are in is called the current directory and is; stored in the global variable ***`gDirectory`***. Let us look at a more; detailed example of a ROOT file and its role as the current directory.; First, we create a ROOT file by executing a sample script. ``` {.cpp}; root[] .x $ROOTSYS/tutorials/hsimple.C; ```. Now you should have `hsimple.root` in your directory. The file was; closed by the script so we have to open it again to work with it. We; open the file with the intent to update it, and list its contents. ``` {.cpp}; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. It shows the two lines starting with **`TFile`** followed by four lines; starting with the word ""`KEY`"". The four keys tell us that there are; four objects on disk in this file. The syntax of the listing is:. ``` {.cpp}; KEY: <",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:20259,variab,variable,20259,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability,"4(i64 %base, i64 %n). Overview:; """""""""""""""""". Create a mask representing active and inactive vector lanes. Arguments:; """""""""""""""""""". Both operands have the same scalar integer type. The result is a vector with; the i1 element type. Semantics:; """""""""""""""""""". The '``llvm.get.active.lane.mask.*``' intrinsics are semantically equivalent; to:. ::. %m[i] = icmp ult (%base + i), %n. where ``%m`` is a vector (mask) of active/inactive lanes with its elements; indexed by ``i``, and ``%base``, ``%n`` are the two arguments to; ``llvm.get.active.lane.mask.*``, ``%icmp`` is an integer compare and ``ult``; the unsigned less-than comparison operator. Overflow cannot occur in; ``(%base + i)`` and its comparison against ``%n`` as it is performed in integer; numbers and not in machine numbers. If ``%n`` is ``0``, then the result is a; poison value. The above is equivalent to:. ::. %m = @llvm.get.active.lane.mask(%base, %n). This can, for example, be emitted by the loop vectorizer in which case; ``%base`` is the first element of the vector induction variable (VIV) and; ``%n`` is the loop tripcount. Thus, these intrinsics perform an element-wise; less than comparison of VIV with the loop tripcount, producing a mask of; true/false values representing active/inactive vector lanes, except if the VIV; overflows in which case they return false in the lanes where the VIV overflows.; The arguments are scalar types to accommodate scalable vector types, for which; it is unknown what the type of the step vector needs to be that enumerate its; lanes without overflow. This mask ``%m`` can e.g. be used in masked load/store instructions. These; intrinsics provide a hint to the backend. I.e., for a vector loop, the; back-edge taken count of the original scalar loop is explicit as the second; argument. Examples:; """""""""""""""""". .. code-block:: llvm. %active.lane.mask = call <4 x i1> @llvm.get.active.lane.mask.v4i1.i64(i64 %elem0, i64 429); %wide.masked.load = call <4 x i32> @llvm.masked.load.v4i32.p0v4i32(<4 x i3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:778234,variab,variable,778234,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"4(v=VS.100).aspx>`_,; as well as nearly all of the; `Embarcadero C++ type traits; <http://docwiki.embarcadero.com/RADStudio/Rio/en/Type_Trait_Functions_(C%2B%2B11)_Index>`_. The following type trait primitives are supported by Clang. Those traits marked; (C++) provide implementations for type traits specified by the C++ standard;; ``__X(...)`` has the same semantics and constraints as the corresponding; ``std::X_t<...>`` or ``std::X_v<...>`` type trait. * ``__array_rank(type)`` (Embarcadero):; Returns the number of levels of array in the type ``type``:; ``0`` if ``type`` is not an array type, and; ``__array_rank(element) + 1`` if ``type`` is an array of ``element``.; * ``__array_extent(type, dim)`` (Embarcadero):; The ``dim``'th array bound in the type ``type``, or ``0`` if; ``dim >= __array_rank(type)``.; * ``__can_pass_in_regs`` (C++); Returns whether a class can be passed in registers under the current; ABI. This type can only be applied to unqualified class types.; This is not a portable type trait.; * ``__has_nothrow_assign`` (GNU, Microsoft, Embarcadero):; Deprecated, use ``__is_nothrow_assignable`` instead.; * ``__has_nothrow_move_assign`` (GNU, Microsoft):; Deprecated, use ``__is_nothrow_assignable`` instead.; * ``__has_nothrow_copy`` (GNU, Microsoft):; Deprecated, use ``__is_nothrow_constructible`` instead.; * ``__has_nothrow_constructor`` (GNU, Microsoft):; Deprecated, use ``__is_nothrow_constructible`` instead.; * ``__has_trivial_assign`` (GNU, Microsoft, Embarcadero):; Deprecated, use ``__is_trivially_assignable`` instead.; * ``__has_trivial_move_assign`` (GNU, Microsoft):; Deprecated, use ``__is_trivially_assignable`` instead.; * ``__has_trivial_copy`` (GNU, Microsoft):; Deprecated, use ``__is_trivially_copyable`` instead.; * ``__has_trivial_constructor`` (GNU, Microsoft):; Deprecated, use ``__is_trivially_constructible`` instead.; * ``__has_trivial_move_constructor`` (GNU, Microsoft):; Deprecated, use ``__is_trivially_constructible`` instead.; * ``__ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:58613,portab,portable,58613,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['portab'],['portable']
Modifiability,"4(void) {; printf(""Foo4"");; }. .. code-block:: bash. --- command lines ---; $ clang -flto a.c -c -o a.o # <-- a.o is LLVM bitcode file; $ ar q a.a a.o # <-- a.a is an archive with LLVM bitcode; $ clang b.c -c -o b.o # <-- b.o is native object file; $ clang -flto a.a b.o -o main # <-- link with LLVMgold plugin. Gold informs the plugin that foo3 is never referenced outside the IR,; leading LLVM to delete that function. However, unlike in the :ref:`libLTO; example <libLTO-example>` gold does not currently eliminate foo4. Quickstart for using LTO with autotooled projects; =================================================. Once your system ``ld``, ``ar``, and ``nm`` all support LLVM bitcode,; everything is in place for an easy to use LTO build of autotooled projects:. * Follow the instructions :ref:`on how to build LLVMgold.so; <lto-how-to-build>`. * Install the newly built binutils to ``$PREFIX``. * Copy ``Release/lib/LLVMgold.so`` to ``$PREFIX/lib/bfd-plugins/``. * Set environment variables (``$PREFIX`` is where you installed clang and; binutils):. .. code-block:: bash. export CC=""$PREFIX/bin/clang -flto""; export CXX=""$PREFIX/bin/clang++ -flto""; export AR=""$PREFIX/bin/ar""; export NM=""$PREFIX/bin/nm""; export RANLIB=/bin/true #ranlib is not needed, and doesn't support .bc files in .a. * Or you can just set your path:. .. code-block:: bash. export PATH=""$PREFIX/bin:$PATH""; export CC=""clang -flto""; export CXX=""clang++ -flto""; export RANLIB=/bin/true; * Configure and build the project as usual:. .. code-block:: bash. % ./configure && make && make check. The environment variable settings may work for non-autotooled projects too,; but you may need to set the ``LD`` environment variable as well. Licensing; =========. Gold is licensed under the GPLv3. LLVMgold uses the interface file; ``plugin-api.h`` from gold which means that the resulting ``LLVMgold.so``; binary is also GPLv3. This can still be used to link non-GPLv3 programs; just as much as gold could without the plugin.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:5175,variab,variables,5175,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,6,"['config', 'plugin', 'variab']","['configure', 'plugin', 'plugin-api', 'variable', 'variables']"
Modifiability,"4.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; conf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31064,config,config,31064,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['config'],"['config', 'configuration']"
Modifiability,"40; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-classes; Unknown. 2548; NAD; Array prvalues and additive operators; Unknown. 2549; review; Implicitly moving the operand of a throw-expression in unevaluated contexts; Not resolved. 2550; DRWP; Type ""reference to cv void"" outside of a declarator; Unknown. 2551; review; ""Refers to allocated storage"" has no meaning; Not resolved. 2552; DRWP; Constant evaluation of non-defining variable declarations; Unknown. 2553; review; Restrictions on explicit object member functions; Clang 18. 2554; review; Overriding virtual functions, also with explicit object parameters; Clang 18. 2555; drafting; Ineffective redeclaration prevention for using-declarators; Not resolved. 2556; DR; Unusable promise::return_void; Unknown. 2557; drafting; Class member access referring to an unrelated class; Not resolved. 2558; C++23; Uninitialized subobjects as a result of an immediate invocation; Unknown. 2559; open; Defaulted consteval functions; Not resolved. 2560; tentatively ready; Parameter type determination in a requirement-parameter-list; Unknown. 2561; review; Conversion to function pointer for lambda with explicit object parameter; Clang 18. 2562; open; Exceptions thrown during coroutine startup; Not resolved. 2563; drafting; Initialization of coroutine result object; Not resolved. 2564; drafting; Conversion to function pointer with an explicit object parameter; Not res",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:175328,variab,variable,175328,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"4528](https://github.com/root-project/root/issues/14528)] - Bug in TFoam::GetIntNorm; * [[#14510](https://github.com/root-project/root/issues/14510)] - Large computation graphs cause serious memory and runtime overhead; * [[#14509](https://github.com/root-project/root/issues/14509)] - ROOT segfaults on riscv64; * [[#14508](https://github.com/root-project/root/issues/14508)] - Using LZMA compression with RNTupleWriter leads to memory corruption; * [[#14499](https://github.com/root-project/root/issues/14499)] - It is not possible to set the Title of the palette for a 3D axis; * [[#14462](https://github.com/root-project/root/issues/14462)] - Parser for I/O customization rule is too strict.; * [[#14458](https://github.com/root-project/root/issues/14458)] - Crash when doing Weighted Likelihood fit; * [[#14453](https://github.com/root-project/root/issues/14453)] - Implement IsInside for TEllipse; * [[#14401](https://github.com/root-project/root/issues/14401)] - The red frame around the selected pad of the webgui is not configurable; * [[#14385](https://github.com/root-project/root/issues/14385)] - Strange behavior with TF1 and SetParameters; * [[#14381](https://github.com/root-project/root/issues/14381)] - Legend entry for exclusion graph; * [[#14376](https://github.com/root-project/root/issues/14376)] - build failure with `mysql 8.3`; * [[#14372](https://github.com/root-project/root/issues/14372)] - File with mtime equal to 0 are ignored by Cling.; * [[#14333](https://github.com/root-project/root/issues/14333)] - ""Empty plot"" for df014_CSVDataSource.C ; * [[#14331](https://github.com/root-project/root/issues/14331)] - Unexpected behaviour when using the Project3D function to make a TH2 from a TH3; * [[#14329](https://github.com/root-project/root/issues/14329)] - [RF] RDataFrameToRooFit - Clarification on returned object; * [[#14324](https://github.com/root-project/root/issues/14324)] - Compatibility Issue with thisroot.sh and zsh ; * [[#14320](https://github.com/root-proj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:32205,config,configurable,32205,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['config'],['configurable']
Modifiability,"5 movl $0xffff, %rax <--- patched code at stack map address; 0x0a callq *%rax <---- end of 8-byte shadow. This way, after the normal call to the runtime returns, the code will; execute a patched call to a special entry point that can rebuild a; stack frame from the values located by the stack map. '``llvm.experimental.patchpoint.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void; @llvm.experimental.patchpoint.void(i64 <id>, i32 <numBytes>,; ptr <target>, i32 <numArgs>, ...); declare i64; @llvm.experimental.patchpoint.i64(i64 <id>, i32 <numBytes>,; ptr <target>, i32 <numArgs>, ...). Overview:; """""""""""""""""". The '``llvm.experimental.patchpoint.*``' intrinsics creates a function; call to the specified ``<target>`` and records the location of specified; values in the stack map. Operands:; """""""""""""""""". The first operand is an ID, the second operand is the number of bytes; reserved for the patchable region, the third operand is the target; address of a function (optionally null), and the fourth operand; specifies how many of the following variable operands are considered; function call arguments. The remaining variable number of operands are; the ``live values`` for which locations will be recorded in the stack; map. Semantics:; """""""""""""""""""". The patch point intrinsic generates a stack map. It also emits a; function call to the address specified by ``<target>`` if the address; is not a constant null. The function call and its arguments are; lowered according to the calling convention specified at the; intrinsic's callsite. Variants of the intrinsic with non-void return; type also return a value according to calling convention. On PowerPC, note that ``<target>`` must be the ABI function pointer for the; intended target of the indirect call. Specifically, when compiling for the; ELF V1 ABI, ``<target>`` is the function-descriptor address normally used as; the C/C++ function-pointer representation. Requesting zero patch point arguments",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:8117,variab,variable,8117,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['variab'],['variable']
Modifiability,"522 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | support full 'defaultmap' functionality | :good:`done` | D69204 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device specific functions | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: device_type | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: extended device | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: uses_allocators clause | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: in_reduction | :part:`worked on` | r308768 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_get_device_num() | :good:`done` | D54342,D128347 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:11889,extend,extended,11889,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['extend'],['extended']
Modifiability,5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144757,extend,extended,144757,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['extend'],['extended']
Modifiability,"5aeacc8 <col:17, col:21> 'int' '/'; | |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>; | | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVar 0x5aeaa90 'x' 'int'; | `-IntegerLiteral 0x5aeac90 <col:21> 'int' 42; `-ReturnStmt 0x5aead68 <line:3:3, col:10>; `-ImplicitCastExpr 0x5aead50 <col:10> 'int' <LValueToRValue>; `-DeclRefExpr 0x5aead28 <col:10> 'int' lvalue Var 0x5aeac10 'result' 'int'. The toplevel declaration in; a translation unit is always the `translation unit; declaration <https://clang.llvm.org/doxygen/classclang_1_1TranslationUnitDecl.html>`_.; In this example, our first user written declaration is the `function; declaration <https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html>`_; of ""``f``"". The body of ""``f``"" is a `compound; statement <https://clang.llvm.org/doxygen/classclang_1_1CompoundStmt.html>`_,; whose child nodes are a `declaration; statement <https://clang.llvm.org/doxygen/classclang_1_1DeclStmt.html>`_; that declares our result variable, and the `return; statement <https://clang.llvm.org/doxygen/classclang_1_1ReturnStmt.html>`_. AST Context; ===========. All information about the AST for a translation unit is bundled up in; the class; `ASTContext <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html>`_.; It allows traversal of the whole translation unit starting from; `getTranslationUnitDecl <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html#abd909fb01ef10cfd0244832a67b1dd64>`_,; or to access Clang's `table of; identifiers <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html#a4f95adb9958e22fbe55212ae6482feb4>`_; for the parsed translation unit. AST Nodes; =========. Clang's AST nodes are modeled on a class hierarchy that does not have a; common ancestor. Instead, there are multiple larger hierarchies for; basic node types like; `Decl <https://clang.llvm.org/doxygen/classclang_1_1Decl.html>`_ and; `Stmt <https://clang.llvm.org/doxygen/classclang_1_1Stmt.html>`_. Many; important AST nodes der",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:3179,variab,variable,3179,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,1,['variab'],['variable']
Modifiability,"6 static and JIT compilers; initial SparcV8 backend; D: Dynamic trace optimizer; D: FreeBSD/X86 compatibility fixes, the llvm-nm tool. N: Nicolas Geoffray; E: nicolas.geoffray@lip6.fr; W: http://www-src.lip6.fr/homepages/Nicolas.Geoffray/; D: PPC backend fixes for Linux. N: Louis Gerbarg; E: lgg@apple.com; D: Portions of the PowerPC backend. N: Saem Ghani; E: saemghani@gmail.com; D: Callgraph class cleanups. N: Mikhail Glushenkov; E: foldr@codedgers.com; D: Author of llvmc2. N: Dan Gohman; E: llvm@sunfishcode.online; D: Miscellaneous bug fixes; D: WebAssembly Backend. N: Renato Golin; E: rengolin@systemcall.eu; E: rengolin@gmail.com; D: ARM/AArch64 back-end improvements; D: Loop Vectorizer improvements; D: Regression and Test Suite improvements; D: Linux compatibility (GNU, musl, etc); D: Initial Linux kernel / Android support effort; I: rengolin. N: David Goodwin; E: david@goodwinz.net; D: Thumb-2 code generator. N: David Greene; E: greened@obbligato.org; D: Miscellaneous bug fixes; D: Register allocation refactoring. N: Gabor Greif; E: ggreif@gmail.com; D: Improvements for space efficiency. N: James Grosbach; E: grosbach@apple.com; I: grosbach; D: SjLj exception handling support; D: General fixes and improvements for the ARM back-end; D: MCJIT; D: ARM integrated assembler and assembly parser; D: Led effort for the backend formerly known as ARM64. N: Lang Hames; E: lhames@gmail.com; D: PBQP-based register allocator. N: Gordon Henriksen; E: gordonhenriksen@mac.com; D: Pluggable GC support; D: C interface; D: Ocaml bindings. N: Raul Fernandes Herbster; E: raul@dsc.ufcg.edu.br; D: JIT support for ARM. N: Paolo Invernizzi; E: arathorn@fastwebnet.it; D: Visual C++ compatibility fixes. N: Patrick Jenkins; E: patjenk@wam.umd.edu; D: Nightly Tester. N: Tony(Yanjun) Jiang; E: jtony@ca.ibm.com; D: PowerPC Backend Developer; D: Improvements to the PPC backend and miscellaneous bug fixes. N: Dale Johannesen; E: dalej@apple.com; D: ARM constant islands improvements; D: Tail mer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:4824,refactor,refactoring,4824,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,1,['refactor'],['refactoring']
Modifiability,"626/rf613__global_observables_8C.html) / [.py](https://root.cern/doc/v626/rf613__global_observables_8py.html) tutorial. ### Changes in `RooAbsPdf::fitTo` behaviour for multi-range fits. The `RooAbsPdf::fitTo` and `RooAbsPdf::createNLL` functions accept a command argument to specify the fit range.; One can also fit in multiple ranges simultaneously.; The definition of such multi-range likelihoods for non-extended fits changes in this release.; Previously, the individual likelihoods were normalized separately in each range, which meant that the relative number of events in each sub-range was not used to estimate the PDF parameters.; From now on, the likelihoods are normalized by the sum of integrals in each range. This implies that the likelihood takes into account all inter-range and intra-range information. ### Deprecation of the `RooMinuit` class. The `RooMinuit` class was the old interface between RooFit and minuit. With ROOT version 5.24, the more general `RooMinimizer` adapter was introduced, which became the default with ROOT 6.08. Before 6.26, it was possible to still use the `RooMinuit` by passing the `Minimizer(""OldMinuit"", ""minimizer"")` command argument to `RooAbsPdf::fitTo()`. This option is now removed. ### Increase of the `RooAbsArg` class version. The class version of `RooAbsArg` was incremented from 7 to 8 in this release. In some circumstances, this can cause warnings in `TStreamerInfo` for classes inheriting from `RooAbsArg` when reading; older RooFit models from a file. These warnings are harmless and can be avoided by incrementing also the class version of the inheriting class. ### Compile-time protection against creating empty `RooCmdArg`s from strings. The implicit [RooCmdArg](https://root.cern/doc/v626/classRooCmdArg.html) constructor from `const char*` was removed to avoid the accidental construction of meaningless RooCmdArgs that only have a name but no payload.; This causes new compiler errors in your code if you pass a string instead of a Roo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:30455,adapt,adapter,30455,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['adapt'],['adapter']
Modifiability,"67; Unknown. FLT_EVAL_METHOD and return; N1382; Unknown. Floating-point to int/_Bool conversions; N1391; Yes. Analyzability (along the lines); N1394; Unknown. Wide function returns (alternate proposal); N1396; Unknown. Alignment. N1397; Clang 3.2. N1447; Clang 3.2. Anonymous member-structures and unions (modulo ""name lookup""); N1406; Yes. Completeness of types; N1439; Yes. Generic macro facility; N1441; Yes. Dependency ordering for C memory model; N1444; Unknown. Subsetting the standard; N1460; Yes. Assumed types in F.9.2; N1468; Unknown. Supporting the 'noreturn' property in C1x; N1478; Clang 3.3. Updates to C++ memory model based on formalization; N1480; Unknown. Explicit initializers for atomics; N1482; Unknown. Atomics proposal (minus ternary op); N1485; Yes. UTF-8 string literals; N1488; Clang 3.3. Optimizing away infinite loops; N1509; Yes. Conditional normative status for Annex G; N1514; Unknown. Creation of complex value; N1464; Unknown. Recommendations for extended identifier characters for C and C++; N1518; Unknown. Atomic C1x/C++0x compatibility refinements (1st part only); N1526; Yes. Atomic bitfields implementation defined; N1530; Yes. Small fix for the effect of alignment on struct/union type compatibility; N1532; Yes. Synthesis re _Atomic; N1537; Unknown. Clarification for wide evaluation; N1531; Unknown. C17 implementation status; There are no major changes in this edition, only technical corrections and clarifications that are tracked by Defect Report.; You can use Clang in C17 mode with the -std=c17 or -std=c18 options (available in Clang 6 and later).; C23 implementation status; Clang has support for some of the features of the C standard following C17, informally referred to as C23.; You can use Clang in C23 mode with the -std=c23 option (available in Clang 18 and later) or with the; -std=c2x option (available in Clang 9 and later). List of features and minimum Clang version with support. Language Feature; C23 Proposal; Available in Clang?. Evalu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:6182,extend,extended,6182,interpreter/llvm-project/clang/www/c_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html,1,['extend'],['extended']
Modifiability,"7,9,12-]"" \; checksum=""[12345,123456]"" \; targetClass=""ClassB"" \; target=""m_x"" \; embed=""true"" \; include=""iostream,cstdlib"" \; code=""{m_x = onfile.m_a * onfile.m_b * onfile.m_c; }"" \. #pragma readraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }"". * For REFLEX dictionaries:. <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>. The variables in the rules have the following meaning:. * sourceClass - The field defines the on-disk class that is the input for the rule.; * source - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version - A list of versions of the source class that can be an input for this rule.; The list has to be enclosed in a square bracket and be a comma-separated; list of versions or version ranges. The version is an integer number, whereas; the version range is one of the following:; – ""a-b"" - a and b are integers and the expression means all the numbers between; and including a and b; – ""-a"" - a is an integer and the expression means all the version numbers smaller; than or equal to a; – ""a-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt:2819,variab,variables,2819,io/doc/DataModelEvolution.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt,1,['variab'],['variables']
Modifiability,"851; 10. Draw total histogram from TEfficiency when draw option starts with 'b'; 11. Let redraw TEfficiency, THStack and TMultiGraph with different draw options via hist context menu; 12. Support 'pads' draw options for TMultiGraph, support context menu for it; 13. Let drop object on sub-pads; 14. Properly loads ES6 modules for web canvas; 15. Improve performance of TH3/RH3 drawing by using THREE.InstancedMesh; 16. Implement batch mode with '&batch' URL parameter to create SVG/PNG images with default GUI; 17. Adjust node.js implementation to produce identical output with normal browser; 18. Create necessary infrastructure for testing with 'puppeteer'; 19. Support inject of ES6 modules via '&inject=path.mjs'; 20. Using importmap for 'jsroot' in all major HTML files and in demos; 21. Implement `settings.CutAxisLabels` flag to remove labels which may exceed graphical range; 22. Let disable usage of TAxis custom labels via context menu; 23. Let configure default draw options via context menu, they can be preserved in the local storage; 24. Let save canvas as JSON file from context menu, object as JSON from inspector; 25. Upgrade three.js r162 -> r168, use r162 only in node.js because of ""gl"" module; 26. Create unified svg2pdf/jspdf ES6 modules, integrate in jsroot builds; 27. Let create multipage PDF document - in TWebCanvas batch mode; 28. Let add external links via `#url[link]{label}` syntax - including jsPDF support; 29. Support TAttMarker style with line width bigger than 1; 30. Internals - upgrade to eslint 9; 31. Internals - do not select pad (aka gPad) for objects drawing, always use assigned pad painter; 32. Fix - properly save zoomed ranges in drawingJSON(); 33. Fix - properly redraw TMultiGraph; 34. Fix - show empty bin in TProfile2D if it has entries #316; 35. Fix - unzooming on log scale was extending range forevever; 36. Fix - do not force style 8 for hist markers; 37. Fix - ensure minimal hist title height; 38. Fix - disable Bloom effects on Android TGeo di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:1616,config,configure,1616,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configure']
Modifiability,"9);; n7->SetFillColor(kViolet-9);. // some edges ...; gs->AddEdge(n0,n1)->SetLineColor(kRed);; TGraphEdge *e06 = gs->AddEdge(n0,n6);; e06->SetLineColor(kRed-3);; e06->SetLineWidth(4);; gs->AddEdge(n1,n7);; gs->AddEdge(n4,n6);; gs->AddEdge(n3,n9);; gs->AddEdge(n6,n8);; gs->AddEdge(n7,n2);; gs->AddEdge(n8,n3);; gs->AddEdge(n2,n3);; gs->AddEdge(n9,n0);; gs->AddEdge(n1,n4);; gs->AddEdge(n1,n6);; gs->AddEdge(n2,n5);; gs->AddEdge(n3,n6);; gs->AddEdge(n4,n5);. TCanvas *c = new TCanvas(""c"",""c"",800,600);; c->SetFillColor(38);; gs->Draw();; return c;; }; . This new funtionnality relies on the graphivz package.; This package can be downloaded from; http://www.graphviz.org/. At installation time, to find graphviz, the ROOT's configure file looks in; standard locations. It is possible to define a specific location using the; configure flags:. --with-gviz-incdir=""the directory where gvc.h is""; --with-gviz-libdir=""the directory where the libgvc library is"". To install graphviz (if needed) it is recommended to use the following configure flags:. --enable-static=yes --enable-shared=no --with-pic --prefix=""graphviz installed here"". On 64 bits machines, the ROOT sources are compiled with the option -m64. In; that case graphviz should be also compiled in 64 bits mode. It might be the; default option, but on some machine it is not. In that case the environment; variable CC should be defined as:. CC=""gcc -m64"". before doing configure. On Windows machines it recommended to not install graphviz but to download the; pre-installed version from http://www.graphviz.org/. The ROOT configure command; remains the same.; Graphics Primitives; New class TGraphTime; TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax.; each time step has a new list of objects. This list can be identical to; the list of objects in the previous steps, but with different attributes.; see example of use in $ROOTSYS/tutorials/graphs/gtime.C. TLatex. In the following macro the #int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html:3787,config,configure,3787,graf2d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html,1,['config'],['configure']
Modifiability,"924)] - PyROOT: wrong overload resolution for C++ functions from python ; * [[#11901](https://github.com/root-project/root/issues/11901)] - Binary distribution for Ubutu 22.04 is broken (on WSL2); * [[#11750](https://github.com/root-project/root/issues/11750)] - FindXROOTD adds libraries to link against irrespective of xrootd version used; * [[#11746](https://github.com/root-project/root/issues/11746)] - TH2::Fill(const char *namex, const char *namey, Double_t w) doesn't update fTsumwxy; * [[#11743](https://github.com/root-project/root/issues/11743)] - CMake >= 3.24 fails to build LZMA: WARNING: 'aclocal-1.15' is missing on your system.; * [[#11673](https://github.com/root-project/root/issues/11673)] - [ntuple] Consider making `REntry::AddValue()` publicly accessible; * [[#11667](https://github.com/root-project/root/issues/11667)] - [cling] GetClassSharedLibs fails to find several classes; * [[#11653](https://github.com/root-project/root/issues/11653)] - TFile plugins :: pass meta4 extension files to TNetXNGFile and process it; * [[#11596](https://github.com/root-project/root/issues/11596)] - cppyy does not retrieve correct size of type when pythonizing vector; * [[#11484](https://github.com/root-project/root/issues/11484)] - roottest/root/meta/genreflex/ROOT-5768 needs to be enabled; * [[#11411](https://github.com/root-project/root/issues/11411)] - [PyROOT] Python list of strings -> std::initializer_list< std::string > conversion is broken; * [[#11395](https://github.com/root-project/root/issues/11395)] - Migrate to pcre2; * [[#11353](https://github.com/root-project/root/issues/11353)] - Compiled program with libNew.so crash; * [[#11304](https://github.com/root-project/root/issues/11304)] - WW option for fit functions as the W option; * [[#11238](https://github.com/root-project/root/issues/11238)] - an old bug in ROOT v6 TAB completion ?; * [[#11197](https://github.com/root-project/root/issues/11197)] - Build github release into version release procedure; * [[#11190",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:42977,plugin,plugins,42977,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['plugin'],['plugins']
Modifiability,"949. TFormula. Add support for the ternary condition operator ( cond ? if_expr : else_expr ). THStack. The following macro produced two sets of superimposed labels with different; text sizes:. {; TH1F *hgaus1 = new TH1F(""Hgaus1"", """", 100, -10, 10);; TH1F *hgaus2 = new TH1F(""Hgaus2"", """", 100, -20, 20);; THStack *hst = new THStack();; hgaus1->FillRandom(""gaus"", 30000); hst->Add(hgaus1, ""ep"");; hgaus2->FillRandom(""gaus"", 30000); hst->Add(hgaus2, ""ep"");; hst->Draw(""nostack"");; hst->GetHistogram()->SetLabelSize(0.07, ""xy"");; }. TH1. Fix problem in the resulting statistics of TH1::Add when the coeffient are negative, for an histogram subtraction. This fixes the issue; #55911.; In the implementation of TH1::ResetStats(), set the statistics to the one calculated using the bin center and also reset the number of entries to the; total bin content or to the effective entries in case of a weighted histogram.; Check the histogram compatibility, by comparing each bin, in the case of variable bin histogram, when using the histogram operation methods TH1::Add or TH1::Multiply or TH1::Divide. THistPainter. Round correctly the number of entries displayed in the statistics box to the closest integer value.; New plotting option SURF7. It is similar to SURF3 except; that the surface is plotted with colors and the contours on top with lines. TGraph. Fixed problem in <http://root.cern.ch/phpBB2/viewtopic.php?t=9208>. TGraphErrors. Add a new fitting option ""EX0"", to neglect the error in X when fitting; . TGraph2DErrors. New option ""ERR"" to draw TGraphErrors as error bars.; The following picture has been produced with the option ""ERR P0"". THnSparse. Make a function to generate a THnSparse from a corresponding TH1.; Fixed a problem with the division methods, as well as implement unit tests for them.; Remove some unnecessary parts of the methods Multiply and Divide.; Implement the multiplication proposal in; <http://root.cern.ch/phpBB2/viewtopic.php?t=7692>, as weel; as implemeting unit tests ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:3122,variab,variable,3122,hist/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html,1,['variab'],['variable']
Modifiability,": !1, line: 4, column: 5); !19 = !DILocation(line: 5, column: 11, scope: !18); !20 = !DILocation(line: 6, column: 11, scope: !18); !21 = !DILocation(line: 6, column: 9, scope: !18); !22 = !DILocation(line: 8, column: 9, scope: !4); !23 = !DILocation(line: 8, column: 7, scope: !4); !24 = !DILocation(line: 9, column: 3, scope: !4). This example illustrates a few important details about LLVM debugging; information. In particular, it shows how the ``llvm.dbg.declare`` intrinsic and; location information, which are attached to an instruction, are applied; together to allow a debugger to analyze the relationship between statements,; variable definitions, and the code used to implement the function. .. code-block:: llvm. call void @llvm.dbg.declare(metadata i32* %X, metadata !11, metadata !13), !dbg !14; ; [debug line = 2:7] [debug variable = X]. The first intrinsic ``%llvm.dbg.declare`` encodes debugging information for the; variable ``X``. The metadata ``!dbg !14`` attached to the intrinsic provides; scope information for the variable ``X``. .. code-block:: text. !14 = !DILocation(line: 2, column: 9, scope: !4); !4 = distinct !DISubprogram(name: ""foo"", scope: !1, file: !1, line: 1, type: !5,; isLocal: false, isDefinition: true, scopeLine: 1,; isOptimized: false, retainedNodes: !2). Here ``!14`` is metadata providing `location information; <LangRef.html#dilocation>`_. In this example, scope is encoded by ``!4``, a; `subprogram descriptor <LangRef.html#disubprogram>`_. This way the location; information attached to the intrinsics indicates that the variable ``X`` is; declared at line number 2 at a function level scope in function ``foo``. Now lets take another example. .. code-block:: llvm. call void @llvm.dbg.declare(metadata i32* %Z, metadata !17, metadata !13), !dbg !19; ; [debug line = 5:9] [debug variable = Z]. The third intrinsic ``%llvm.dbg.declare`` encodes debugging information for; variable ``Z``. The metadata ``!dbg !19`` attached to the intrinsic provides; scop",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:16322,variab,variable,16322,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,": !18, file: !1, line: 5, type: !12); !18 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5); !19 = !DILocation(line: 5, column: 11, scope: !18); !20 = !DILocation(line: 6, column: 11, scope: !18); !21 = !DILocation(line: 6, column: 9, scope: !18); !22 = !DILocation(line: 8, column: 9, scope: !4); !23 = !DILocation(line: 8, column: 7, scope: !4); !24 = !DILocation(line: 9, column: 3, scope: !4). This example illustrates a few important details about LLVM debugging; information. In particular, it shows how the ``llvm.dbg.declare`` intrinsic and; location information, which are attached to an instruction, are applied; together to allow a debugger to analyze the relationship between statements,; variable definitions, and the code used to implement the function. .. code-block:: llvm. call void @llvm.dbg.declare(metadata i32* %X, metadata !11, metadata !13), !dbg !14; ; [debug line = 2:7] [debug variable = X]. The first intrinsic ``%llvm.dbg.declare`` encodes debugging information for the; variable ``X``. The metadata ``!dbg !14`` attached to the intrinsic provides; scope information for the variable ``X``. .. code-block:: text. !14 = !DILocation(line: 2, column: 9, scope: !4); !4 = distinct !DISubprogram(name: ""foo"", scope: !1, file: !1, line: 1, type: !5,; isLocal: false, isDefinition: true, scopeLine: 1,; isOptimized: false, retainedNodes: !2). Here ``!14`` is metadata providing `location information; <LangRef.html#dilocation>`_. In this example, scope is encoded by ``!4``, a; `subprogram descriptor <LangRef.html#disubprogram>`_. This way the location; information attached to the intrinsics indicates that the variable ``X`` is; declared at line number 2 at a function level scope in function ``foo``. Now lets take another example. .. code-block:: llvm. call void @llvm.dbg.declare(metadata i32* %Z, metadata !17, metadata !13), !dbg !19; ; [debug line = 5:9] [debug variable = Z]. The third intrinsic ``%llvm.dbg.declare`` encodes debugging information for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:16218,variab,variable,16218,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,": ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - Name: ""<input>"", Values: {""t.c""}. After this stage is complete the command line should be broken down; into well defined option objects with their appropriate parameters.; Subsequent stages should rarely, if ever, need to do any string; processing. #. **Pipeline: Compilation Action Construction**. Once the arguments are parsed, the tree of subprocess jobs needed for; the desired compilation sequence are constructed. This involves; determining the input files and their types, what work is to be done; on them (preprocess, compile, assemble, link, etc.), and constructing; a list of Action instances for each task. The result is a list of one; or more top-level actions, each of which generally corresponds to a; single output (for example, an object or linked executable). The majority of Actions correspond to actual tasks, however there are; two special Actions. The first is InputAction, which simply serves to; adapt an input argument for use as an input to other Actions. The; second is BindArchAction, which conceptually alters the architecture; to be used for all of its input Actions. The clang driver can dump the results of this stage using the; ``-ccc-print-phases`` flag. For example:. .. code-block:: console. $ clang -ccc-print-phases -x c t.c -x assembler t.s; 0: input, ""t.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: input, ""t.s"", assembler; 5: assembler, {4}, object; 6: linker, {3, 5}, image. Here the driver is constructing seven distinct actions, four to; compile the ""t.c"" input into an object file, two to assemble the; ""t.s"" input, and one to link them together. A rather different compilation pipeline is shown here; in this; example there are two top level actions to compile the input files; into two separate object files, where each object file is built using; ``lipo`` to merge results built for two separate architectures. .. code-blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:6640,adapt,adapt,6640,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['adapt'],['adapt']
Modifiability,": ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };; ```. [^1]: ROOT @bib-ROOT uses its own version of the Fortran M when this; manual was written. However an interface for this version exists and; the library can be loaded dynamically on demand. [^2]: The *internal error matrix* maintained by M is transformed for the; user into *external coordinates*, but the numbering of rows and; columns is of course still according to internal parameter; numbering, since one does not want rows and columns corresponding to; parameters which are not variable. The transformation therefore; affects only parameters with limits; if there are no limits,; internal and external error matrices are the same. [^3]: For example, if $\mbox{a}$ and $\mbox{b}$ are double; precision variables, the statement $\mbox{a = 2*b}$ is not good; programming, but happens to do what the user probably intended,; whereas the statement $\mbox{a = b + 2/3}$ almost certainly will; not do what the user intended.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:83876,variab,variable,83876,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,2,['variab'],"['variable', 'variables']"
Modifiability,": Dumping of Win64 EH structures. N: Takumi Nakamura; I: chapuni; E: geek4civic@gmail.com; E: chapuni@hf.rim.or.jp; D: Maintaining the Git monorepo; W: https://github.com/llvm-project/; S: Ebina, Japan. N: Edward O'Callaghan; E: eocallaghan@auroraux.org; W: http://www.auroraux.org; D: Add Clang support with various other improvements to utils/NewNightlyTest.pl; D: Fix and maintain Solaris & AuroraUX support for llvm, various build warnings; D: and error clean ups. N: Morten Ofstad; E: morten@hue.no; D: Visual C++ compatibility fixes. N: Jakob Stoklund Olesen; E: stoklund@2pi.dk; D: Machine code verifier; D: Blackfin backend; D: Fast register allocator; D: Greedy register allocator. N: Richard Osborne; E: richard@xmos.com; D: XCore backend. N: Piotr Padlewski; E: piotr.padlewski@gmail.com; D: !invariant.group metadata and other intrinsics for devirtualization in clang. N: Devang Patel; E: dpatel@apple.com; D: LTO tool, PassManager rewrite, Loop Pass Manager, Loop Rotate; D: GCC PCH Integration (llvm-gcc), llvm-gcc improvements; D: Optimizer improvements, Loop Index Split. N: Ana Pazos; E: apazos@codeaurora.org; D: Fixes and improvements to the AArch64 backend. N: Wesley Peck; E: peckw@wesleypeck.com; W: http://wesleypeck.com/; D: MicroBlaze backend. N: Francois Pichet; E: pichet2000@gmail.com; D: MSVC support. N: Simon Pilgrim; E: llvm-dev@redking.me.uk; D: X86 backend, Selection DAG, Scheduler Models and Cost Tables. N: Adrian Prantl; E: aprantl@apple.com; D: Debug Information. N: Vladimir Prus; W: http://vladimir_prus.blogspot.com; E: ghost@cs.msu.su; D: Made inst_iterator behave like a proper iterator, LowerConstantExprs pass. N: QIU Chaofan; E: qiucofan@cn.ibm.com; D: PowerPC Backend Developer. N: Kalle Raiskila; E: kalle.rasikila@nokia.com; D: Some bugfixes to CellSPU. N: Xerxes Ranby; E: xerxes@zafena.se; D: Cmake dependency chain and various bug fixes. N: Alex Rosenberg; E: alexr@leftfield.org; I: arosenberg; D: ARM calling conventions rewrite, hard float suppo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:9873,rewrite,rewrite,9873,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,1,['rewrite'],['rewrite']
Modifiability,": LLVM's SmallVectorBase; is templated over the type of fSize and fCapacity. It contains the parts of `RVec` that do not depend on the value; type.; No other classes in the hierarchy can contain data members! We expect the memory after `SmallVectorBase` to be; occupied by the small inline buffer. `SmallVectorTemplateCommon<T>`; - `getFirstEl()`: returns the address of the beginning of the small buffer; - `begin()`, `end()`, `front()`, `back()`, etc. Basically the same as the corresponding LLVM class.; It contains the parts that are independent of whether T is a POD or not. `SmallVectorTemplateBase<T, bool TriviallyCopiable>` and the specialization `SmallVectorTemplateBase<T, true>`; - `grow()`, `uninitialized_copy`, `uninitialized_move`, `push_back()`, `pop_back()`. This class contains the parts of `RVec` that can be optimized for trivially copiable types.; In particular, destruction can be skipped and memcpy can be used in place of copy/move construction.; These optimizations are inherited from LLVM's SmallVector. `RVecImpl<T>`; The analogous of LLVM's `SmallVectorImpl`, it factors out of `RVec` the parts that are independent of; the small buffer size, to limit the amount of code generated and provide a way to slice the small buffer; size when passing around `RVec` objects. `RVecN<T, N>`; It aggregates `RVecImpl` and `SmallVectorStorage` (see below) through public inheritance.; `N` is the small buffer size. `RVec<T>`; Inherits from `RVecN` and fixes the small buffer size `N` to a reasonable default.; We expect most users to use this type and only very rarely switch to `RVecN` to tweak the small buffer size. ### Helper types. - `SmallVectorAlignmentAndSize`: used to figure out the offset of the first small-buffer element in; `SmallVectorTemplateCommon::getFirstEl`; - `SmallVectorStorage`: properly aligned ""small buffer"" storage. It's a separate type so that it can be specialized to; be properly aligned also for the case of small buffer size = 0; - `RVecInlineStorage",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/ARCHITECTURE.md:3005,inherit,inherited,3005,math/vecops/ARCHITECTURE.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/ARCHITECTURE.md,1,['inherit'],['inherited']
Modifiability,": NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8730,variab,variables,8730,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['variab'],['variables']
Modifiability,": [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old));. * ``BBIAS_Always`` (in configuration: ``Always``); Always break before inline ASM colon. .. code-block:: c++. asm volatile(""string"",; :; : val);. .. _BreakBeforeTernaryOperators:. **BreakBeforeTernaryOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeTernaryOperators>`; If ``true``, ternary operators will be placed after line breaks. .. code-block:: c++. true:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription; ? firstValue; : SecondValueVeryVeryVeryVeryLong;. false:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?; firstValue :; SecondValueVeryVeryVeryVeryLong;. .. _BreakConstructorInitializers:. **BreakConstructorInitializers** (``BreakConstructorInitializersStyle``) :versionbadge:`clang-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:54349,config,configuration,54349,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,": ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <Macros>`; A list of macros of the form ``<definition>=<expansion>`` . Code will be parsed with macros expanded, in order to determine how to; interpret and format the macro arguments. For example, the code:. .. code-bl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84764,config,configuration,84764,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,": a is an integer and the expression means all the version numbers smaller; than or equal to a; - ""a-"": a is an integer and the expression means all the version numbers greater; than or equal to a; * checksum; - A list of checksums of the source class that can be an input for this; rule. The list has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass; - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target; - A comma-separated list of target class data member names that this rule; is capable of calculating.; * embed; - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include; - A list of header files that should be included in order to provide the; functionality used in the code snippet; the list is comma delimited.; * code; - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj; - variable representing the target in-memory object, its type is that of the; target object; * oldObj; - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer; - in raw conversion rules, an object of TBuffer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx; - in normal conversion rules, names of the variables of basic types declared; in the source property of the r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:81350,variab,variables,81350,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variables']
Modifiability,": c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:2743,refactor,refactoring,2743,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactoring']
Modifiability,": c. // In this loop we load elements from A and store them consecutively in B; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); B[j++] = A[i]; }. .. code-block:: llvm. ; Load elements from A.; %Tmp = call <8 x double> @llvm.masked.load.v8f64.p0(ptr %Aptr, i32 8, <8 x i1> %Mask, <8 x double> poison); ; Store all selected elements consecutively in array B; call <void> @llvm.masked.compressstore.v8f64(<8 x double> %Tmp, ptr %Bptr, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it into a sequence of branches that guard scalar store operations. Memory Use Markers; ------------------. This class of intrinsics provides information about the; :ref:`lifetime of memory objects <objectlifetime>` and ranges where variables; are immutable. .. _int_lifestart:. '``llvm.lifetime.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.start(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.start``' intrinsic specifies the start of a memory; object's lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of; the object, the object is initially marked as dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. After '``llvm.lifetime.start``', the stack object that ``ptr`` points is marked; as aliv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:860981,variab,variables,860981,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,": no compression at all. | |; | | | |; | | 1: If the split level is set to zero, everything is | |; | | compressed according to the `gzip` level 1. If split | |; | | level is set to 1, leaves that are not floating point | |; | | numbers are compressed using the `gzip` level 1. | |; | | | |; | | 2: If the split level is set to zero, everything is | |; | | compressed according to the `gzip` level 2. If split | |; | | level is set to 1, all non floating point leaves are | |; | | compressed according to the `gzip` level 2 and the | |; | | floating point leaves are compressed according to the | |; | | `gzip` level 1 (`gzip` level -1). | |; | | | |; | | Floating point numbers are compressed differently | |; | | because the gain when compressing them is about 20 - | |; | | 30%. For other data types it is generally better and | |; | | around 100%. | |; +-----+---------------------------------------------------------+--------------+; | 3 | Split or not Split | 1 |; | | | |; | | 0: only one single branch is created and the complete | (Split) |; | | event is serialized in one single buffer | |; | | | |; | | 1: a branch per variable is created. | |; +-----+---------------------------------------------------------+--------------+; | 4 | Fill | 1 |; | | | |; | | 0: read the file | (Write, no |; | | | fill) |; | | 1: write the file, but don't fill the histograms | |; | | | |; | | 2: don't write, don't fill the histograms | |; | | | |; | | 10: fill the histograms, don't write the file | |; | | | |; | | 11: fill the histograms, write the file | |; | | | |; | | 20: read the file sequentially | |; | | | |; | | 25: read the file at random | |; +-----+---------------------------------------------------------+--------------+. #### Effect of Compression on File Size and Write Times. You may have noticed that a ROOT file has up to nine compression level,; but here only levels 0, 1, and 2 are described. Compression levels above; 2 are not competitive. They take up to much write time compared",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:8087,variab,variable,8087,documentation/users-guide/TutorialsandTests.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md,1,['variab'],['variable']
Modifiability,":. * Be building a supported configuration. Builders for experimental backends; should generally be attached to staging buildmaster.; * Be able to keep up with new commits to the main branch, or at a minimum; recover to tip of tree within a couple of days of falling behind. Additionally, we encourage all bot owners to point their bots towards the; staging master during maintenance windows, instability troubleshooting, and; such. Roles & Expectations; ====================. Each buildbot has an owner who is the responsible party for addressing problems; which arise with said buildbot. We generally expect the bot owner to be; reasonably responsive. For some bots, the ownership responsibility is split between a ""resource owner""; who provides the underlying machine resource, and a ""configuration owner"" who; maintains the build configuration. Generally, operational responsibility lies; with the ""config owner"". We do expect ""resource owners"" - who are generally; the contact listed in a workers attributes - to proxy requests to the relevant; ""config owner"" in a timely manner. Most issues with a buildbot should be addressed directly with a bot owner; via email. Please CC `Galina Kistanova <mailto:gkistanova@gmail.com>`_. Steps To Add Builder To LLVM Buildbot; =====================================; Volunteers can provide their build machines to work as build workers to; public LLVM Buildbot. Here are the steps you can follow to do so:. #. Check the existing build configurations to make sure the one you are; interested in is not covered yet or gets built on your computer much; faster than on the existing one. We prefer faster builds so developers; will get feedback sooner after changes get committed. #. The computer you will be registering with the LLVM buildbot; infrastructure should have all dependencies installed and be able to; build your configuration successfully. Please check what degree; of parallelism (-j param) would give the fastest build. You can build; multiple con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:2042,config,config,2042,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['config']
Modifiability,":. .. code-block:: c++. class KaleidoscopeJIT {; private:; ExecutionSession ES;; RTDyldObjectLinkingLayer ObjectLayer;; IRCompileLayer CompileLayer;; IRTransformLayer TransformLayer;. DataLayout DL;; MangleAndInterner Mangle;; ThreadSafeContext Ctx;. public:. KaleidoscopeJIT(JITTargetMachineBuilder JTMB, DataLayout DL); : ObjectLayer(ES,; []() { return std::make_unique<SectionMemoryManager>(); }),; CompileLayer(ES, ObjectLayer, ConcurrentIRCompiler(std::move(JTMB))),; TransformLayer(ES, CompileLayer, optimizeModule),; DL(std::move(DL)), Mangle(ES, this->DL),; Ctx(std::make_unique<LLVMContext>()) {; ES.getMainJITDylib().addGenerator(; cantFail(DynamicLibrarySearchGenerator::GetForCurrentProcess(DL.getGlobalPrefix())));; }. Our extended KaleidoscopeJIT class starts out the same as it did in Chapter 1,; but after the CompileLayer we introduce a new member, TransformLayer, which sits; on top of our CompileLayer. We initialize our OptimizeLayer with a reference to; the ExecutionSession and output layer (standard practice for layers), along with; a *transform function*. For our transform function we supply our classes; optimizeModule static method. .. code-block:: c++. // ...; return cantFail(OptimizeLayer.addModule(std::move(M),; std::move(Resolver)));; // ... Next we need to update our addModule method to replace the call to; ``CompileLayer::add`` with a call to ``OptimizeLayer::add`` instead. .. code-block:: c++. static Expected<ThreadSafeModule>; optimizeModule(ThreadSafeModule M, const MaterializationResponsibility &R) {; // Create a function pass manager.; auto FPM = std::make_unique<legacy::FunctionPassManager>(M.get());. // Add some optimizations.; FPM->add(createInstructionCombiningPass());; FPM->add(createReassociatePass());; FPM->add(createGVNPass());; FPM->add(createCFGSimplificationPass());; FPM->doInitialization();. // Run the optimizations over all functions in the module being added to; // the JIT.; for (auto &F : *M); FPM->run(F);. return M;; }. At the bot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:3961,layers,layers,3961,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['layers'],['layers']
Modifiability,":. .. code-block:: c++. static std::map<std::string, AllocaInst*> NamedValues;. Also, since we will need to create these allocas, we'll use a helper; function that ensures that the allocas are created in the entry block of; the function:. .. code-block:: c++. /// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.; static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction,; const std::string &VarName) {; IRBuilder<> TmpB(&TheFunction->getEntryBlock(),; TheFunction->getEntryBlock().begin());; return TmpB.CreateAlloca(Type::getDoubleTy(*TheContext), nullptr,; VarName);; }. This funny looking code creates an IRBuilder object that is pointing at; the first instruction (.begin()) of the entry block. It then creates an; alloca with the expected name and returns it. Because all values in; Kaleidoscope are doubles, there is no need to pass in a type to use. With this in place, the first functionality change we want to make belongs to; variable references. In our new scheme, variables live on the stack, so; code generating a reference to them actually needs to produce a load; from the stack slot:. .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; AllocaInst *A = NamedValues[Name];; if (!A); return LogErrorV(""Unknown variable name"");. // Load the value.; return Builder->CreateLoad(A->getAllocatedType(), A, Name.c_str());; }. As you can see, this is pretty straightforward. Now we need to update; the things that define the variables to set up the alloca. We'll start; with ``ForExprAST::codegen()`` (see the `full code listing <#id1>`_ for; the unabridged code):. .. code-block:: c++. Function *TheFunction = Builder->GetInsertBlock()->getParent();. // Create an alloca for the variable in the entry block.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);. // Emit the start code first, without 'variable' in scope.; Value *Start",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:13706,variab,variable,13706,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,":. .. code-block:: c. ^ { printf(""hello world\n""); }. would cause the following to be created on a 32-bit system:. .. code-block:: c. struct __block_literal_1 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_1 *);; struct __block_descriptor_1 *descriptor;; };. void __block_invoke_1(struct __block_literal_1 *_block) {; printf(""hello world\n"");; }. static struct __block_descriptor_1 {; unsigned long int reserved;; unsigned long int Block_size;; } __block_descriptor_1 = { 0, sizeof(struct __block_literal_1) };. and where the ``Block`` literal itself appears:. .. code-block:: c. struct __block_literal_1 _block_literal = {; &_NSConcreteStackBlock,; (1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. A ``Block`` imports other ``Block`` references, ``const`` copies of other; variables, and variables marked ``__block``. In Objective-C, variables may; additionally be objects. When a ``Block`` literal expression is used as the initial value of a global; or ``static`` local variable, it is initialized as follows:. .. code-block:: c. struct __block_literal_1 __block_literal_1 = {; &_NSConcreteGlobalBlock,; (1<<28)|(1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. that is, a different address is provided as the first value and a particular; (1<<28) bit is set in the ``flags`` field, and otherwise it is the same as for; stack based ``Block`` literals. This is an optimization that can be used for; any ``Block`` literal that imports no ``const`` or ``__block`` storage; variables. Imported Variables; ==================. Variables of ``auto`` storage class are imported as ``const`` copies. Variables; of ``__block`` storage class are imported as a pointer to an enclosing data; structure. Global variables are simply referenced and not considered as; imported. Imported ``const`` copy variables; ---------------------------------. Automatic storage variables not marked with ``__block`` are imported as; ``const`` cop",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:6081,variab,variable,6081,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variable']
Modifiability,":. .. code-block:: cmake. set(list_of_lists a b c); set(a 1 2 3); set(b 4 5 6); set(c 7 8 9). With this layout you can iterate through the list of lists printing each value; with the following code:. .. code-block:: cmake. foreach(list_name IN LISTS list_of_lists); foreach(value IN LISTS ${list_name}); message(${value}); endforeach(); endforeach(). You'll notice that the inner foreach loop's list is doubly dereferenced. This is; because the first dereference turns ``list_name`` into the name of the sub-list; (a, b, or c in the example), then the second dereference is to get the value of; the list. This pattern is used throughout CMake, the most common example is the compiler; flags options, which CMake refers to using the following variable expansions:; CMAKE_${LANGUAGE}_FLAGS and CMAKE_${LANGUAGE}_FLAGS_${CMAKE_BUILD_TYPE}. Other Types; -----------. Variables that are cached or specified on the command line can have types; associated with them. The variable's type is used by CMake's UI tool to display; the right input field. A variable's type generally doesn't impact evaluation,; however CMake does have special handling for some variables such as PATH.; You can read more about the special handling in `CMake's set documentation; <https://cmake.org/cmake/help/v3.5/command/set.html#set-cache-entry>`_. Scope; -----. CMake inherently has a directory-based scoping. Setting a variable in a; CMakeLists file, will set the variable for that file, and all subdirectories.; Variables set in a CMake module that is included in a CMakeLists file will be; set in the scope they are included from, and all subdirectories. When a variable that is already set is set again in a subdirectory it overrides; the value in that scope and any deeper subdirectories. The CMake set command provides two scope-related options. PARENT_SCOPE sets a; variable into the parent scope, and not the current scope. The CACHE option sets; the variable in the CMakeCache, which results in it being set in all sco",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:5813,variab,variable,5813,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variable']
Modifiability,":. This is an experimental flag, that might go away or be renamed. Do; not use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNamespaceComments>`; If ``true``, clang-format adds missing namespace end comments for; namespaces and fixes invalid existing ones. This doesn't affect short; namespaces, which are controlled by ``ShortNamespaceLines``. .. code-block:: c++. true: false:; namespace longNamespace { vs. namespace longNamespace {; void foo(); void foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. ForEachMacros: ['RANGES_FOR', 'FOREACH']. For example: BOOST_FOREACH. .. _IfMacros:. **IfMacros** (``List of Strings``) :versionbadge:`clang-format 13` :ref:`¶ <IfMacros>`; A vector of macros that should be interpreted as conditionals; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. IF(...); <conditional-body>; else IF(...); <conditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:64356,variab,variable-declaration,64356,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['variab'],['variable-declaration']
Modifiability,":. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6363,variab,variable,6363,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variable']
Modifiability,://github.com/llvm/llvm-project/issues/39319>`_) and; (`#60182 <https://github.com/llvm/llvm-project/issues/60182>`_) and; (`#62157 <https://github.com/llvm/llvm-project/issues/62157>`_) and; (`#64885 <https://github.com/llvm/llvm-project/issues/64885>`_) and; (`#65568 <https://github.com/llvm/llvm-project/issues/65568>`_); - Fix an issue where clang doesn't respect detault template arguments that; are added in a later redeclaration for CTAD.; Fixes (`#69987 <https://github.com/llvm/llvm-project/issues/69987>`_); - Fix an issue where CTAD fails for explicit type conversion.; Fixes (`#64347 <https://github.com/llvm/llvm-project/issues/64347>`_); - Fix crash when using C++ only tokens like ``::`` in C compiler clang.; Fixes (`#73559 <https://github.com/llvm/llvm-project/issues/73559>`_); - Clang now accepts recursive non-dependent calls to functions with deduced; return type.; Fixes (`#71015 <https://github.com/llvm/llvm-project/issues/71015>`_); - Fix assertion failure when initializing union containing struct with; flexible array member using empty initializer list.; Fixes (`#77085 <https://github.com/llvm/llvm-project/issues/77085>`_); - Fix assertion crash due to failed scope restoring caused by too-early VarDecl; invalidation by invalid initializer Expr.; Fixes (`#30908 <https://github.com/llvm/llvm-project/issues/30908>`_); - Clang now emits correct source location for code-coverage regions in `if constexpr`; and `if consteval` branches. Untaken branches are now skipped.; Fixes (`#54419 <https://github.com/llvm/llvm-project/issues/54419>`_); - Fix assertion failure when declaring a template friend function with; a constrained parameter in a template class that declares a class method; or lambda at different depth.; Fixes (`#75426 <https://github.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issue,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:43405,flexible,flexible,43405,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['flexible'],['flexible']
Modifiability,":: c++. // expected-error@path/include.h:15 {{error message}}. The path can be absolute or relative and the same search paths will be used as; for ``#include`` directives. The line number in an external file may be; substituted with ``*`` meaning that any line number will match (useful where; the included file is, for example, a system header where the actual line number; may change and is not critical). As an alternative to specifying a fixed line number, the location of a; diagnostic can instead be indicated by a marker of the form ``#<marker>``.; Markers are specified by including them in a comment, and then referenced by; appending the marker to the diagnostic with ``@#<marker>``, as with:. .. code-block:: c++. #warning some text // #1; // ... other code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ``expected-<type> <n> {{diag text}}``, where ``<type>`` is one of; ``error``, ``warning``, ``remark``, or ``note``, and ``<n>`` is a positive; integer. This allows the diagnostic to appear as many times as specified. For; example:. .. code-block:: c++. void f(); // expected-note 2 {{previous declaration is here}}. Where the diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note +",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:159540,extend,extended,159540,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['extend'],['extended']
Modifiability,":: c++. true: false; switch (x) { vs. switch (x) {; case 1 : break; case 1: break;; } }. .. _SpaceBeforeCpp11BracedList:. **SpaceBeforeCpp11BracedList** (``Boolean``) :versionbadge:`clang-format 7` :ref:`¶ <SpaceBeforeCpp11BracedList>`; If ``true``, a space will be inserted before a C++11 braced list; used to initialize an object (after the preceding identifier or type). .. code-block:: c++. true: false:; Foo foo { bar }; vs. Foo foo{ bar };; Foo {}; Foo{};; vector<int> { 1, 2, 3 }; vector<int>{ 1, 2, 3 };; new int[3] { 1, 2, 3 }; new int[3]{ 1, 2, 3 };. .. _SpaceBeforeCtorInitializerColon:. **SpaceBeforeCtorInitializerColon** (``Boolean``) :versionbadge:`clang-format 7` :ref:`¶ <SpaceBeforeCtorInitializerColon>`; If ``false``, spaces will be removed before constructor initializer; colon. .. code-block:: c++. true: false:; Foo::Foo() : a(a) {} Foo::Foo(): a(a) {}. .. _SpaceBeforeInheritanceColon:. **SpaceBeforeInheritanceColon** (``Boolean``) :versionbadge:`clang-format 7` :ref:`¶ <SpaceBeforeInheritanceColon>`; If ``false``, spaces will be removed before inheritance colon. .. code-block:: c++. true: false:; class Foo : Bar {} vs. class Foo: Bar {}. .. _SpaceBeforeJsonColon:. **SpaceBeforeJsonColon** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <SpaceBeforeJsonColon>`; If ``true``, a space will be added before a JSON colon. For other; languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead. .. code-block:: c++. true: false:; { {; ""key"" : ""value"" vs. ""key"": ""value""; } }. .. _SpaceBeforeParens:. **SpaceBeforeParens** (``SpaceBeforeParensStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceBeforeParens>`; Defines in which cases to put a space before opening parentheses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatement",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:115862,inherit,inheritance,115862,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['inherit'],['inheritance']
Modifiability,":: c++. true:; void myFunction(; int a, int b, int c, int d, int e);. false:; void myFunction(int a,; int b,; int c,; int d,; int e);. .. _AllowBreakBeforeNoexceptSpecifier:. **AllowBreakBeforeNoexceptSpecifier** (``BreakBeforeNoexceptSpecifierStyle``) :versionbadge:`clang-format 18` :ref:`¶ <AllowBreakBeforeNoexceptSpecifier>`; Controls if there could be a line break before a ``noexcept`` specifier. Possible values:. * ``BBNSS_Never`` (in configuration: ``Never``); No line break allowed. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2) noexcept(; noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_OnlyWithParen`` (in configuration: ``OnlyWithParen``); For a simple ``noexcept`` there is no line break allowed, but when we; have a condition it is. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; continue;; }. * ``SBS_Empty`` (in configuration: ``Empty``); Only merge empty blocks. .. code-block:: c++. while (true) {}; while (true) {; continue;; }. * ``SBS_Always`` (in configuration: ``Always``); Always merge short blocks into a single line. .. code-block:: c++. whil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:26421,config,configuration,26421,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,":: good. .. contents::; :local:. ==============; OpenMP Support; ==============. Clang fully supports OpenMP 4.5, almost all of 5.0 and most of 5.1/2.; Clang supports offloading to X86_64, AArch64, PPC64[LE], NVIDIA GPUs (all models) and AMD GPUs (all models). In addition, the LLVM OpenMP runtime `libomp` supports the OpenMP Tools; Interface (OMPT) on x86, x86_64, AArch64, and PPC64 on Linux, Windows, and macOS.; OMPT is also supported for NVIDIA and AMD GPUs. For the list of supported features from OpenMP 5.0 and 5.1; see `OpenMP implementation details`_ and `OpenMP 51 implementation details`_. General improvements; ====================; - New collapse clause scheme to avoid expensive remainder operations.; Compute loop index variables after collapsing a loop nest via the; collapse clause by replacing the expensive remainder operation with; multiplications and additions. - When using the collapse clause on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tunin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:1175,extend,extend,1175,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['extend'],['extend']
Modifiability,":: none. %0:_(s32) = G_CONSTANT i32 1. G_FCONSTANT; ^^^^^^^^^^^. A floating point constant. .. code-block:: none. %0:_(s32) = G_FCONSTANT float 1.0. G_FRAME_INDEX; ^^^^^^^^^^^^^. The address of an object in the stack frame. .. code-block:: none. %1:_(p0) = G_FRAME_INDEX %stack.0.ptr0. G_GLOBAL_VALUE; ^^^^^^^^^^^^^^. The address of a global value. .. code-block:: none. %0(p0) = G_GLOBAL_VALUE @var_local. G_BLOCK_ADDR; ^^^^^^^^^^^^. The address of a basic block. .. code-block:: none. %0:_(p0) = G_BLOCK_ADDR blockaddress(@test_blockaddress, %ir-block.block). G_CONSTANT_POOL; ^^^^^^^^^^^^^^^. The address of an object in the constant pool. .. code-block:: none. %0:_(p0) = G_CONSTANT_POOL %const.0. Integer Extension and Truncation; --------------------------------. G_ANYEXT; ^^^^^^^^. Extend the underlying scalar type of an operation, leaving the high bits; unspecified. .. code-block:: none. %1:_(s32) = G_ANYEXT %0:_(s16). G_SEXT; ^^^^^^. Sign extend the underlying scalar type of an operation, copying the sign bit; into the newly-created space. .. code-block:: none. %1:_(s32) = G_SEXT %0:_(s16). G_SEXT_INREG; ^^^^^^^^^^^^. Sign extend the value from an arbitrary bit position, copying the sign bit; into all bits above it. This is equivalent to a shl + ashr pair with an; appropriate shift amount. $sz is an immediate (MachineOperand::isImm(); returns true) to allow targets to have some bitwidths legal and others; lowered. This opcode is particularly useful if the target has sign-extension; instructions that are cheaper than the constituent shifts as the optimizer is; able to make decisions on whether it's better to hang on to the G_SEXT_INREG; or to lower it and optimize the individual shifts. .. code-block:: none. %1:_(s32) = G_SEXT_INREG %0:_(s32), 16. G_ZEXT; ^^^^^^. Zero extend the underlying scalar type of an operation, putting zero bits; into the newly-created space. .. code-block:: none. %1:_(s32) = G_ZEXT %0:_(s16). G_TRUNC; ^^^^^^^. Truncate the underlying scalar ty",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst:1360,extend,extend,1360,interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,1,['extend'],['extend']
Modifiability,"::SetTitle` will prompt you for a; string to use for the axis title. ![Context menus of different objects in a canvas](pictures/030000A0.png). #### Structure of the Context Menus. The curious reader will have noticed that each entry in the context menu; corresponds to a method of the class. Look for example to the menu named; `TAxis::xaxis`. `xaxis` is the name of the object and **`TAxis`** the; name of its class. If we look at the list of **`TAxis`** methods, for; example in <https://root.cern/doc/master/classTAxis.html>, we see the; methods `SetTimeDisplay()` and` UnZoom()`, which appear also in the; context menu. There are several divisions in the context menu, separated by lines. The; top division is a list of the class methods; the second division is a; list of the parent class methods. The subsequent divisions are the; methods other parent classes in case of multiple inheritance. For; example, see the `TPaveText::title context; menu.` A **`TPaveText`** inherits from **`TAttLine`**, which has the; method `SetLineAttributes()`. #### Adding Context Menus for a Class. For a method to appear in the context menu of the object it has to be; marked by `// *MENU*` in the header file. Below is the line from; `TAttLine.h` that adds the `SetLineAttribute` method to the context; menu. ``` {.cpp}; virtual void SetLineAttributes(); // *MENU*; ```. Nothing else is needed, since Cling knows the classes and their methods.; It takes advantage of that to create the context menu on the fly when; the object is clicking on. If you click on an axis, ROOT will ask the; interpreter what are the methods of the **`TAxis`** and which ones are; set for being displayed in a context menu. Now, how does the interpreter know this? Remember, when you build a; class that you want to use in the ROOT environment, you use `rootcling`; that builds the so-called stub functions and the dictionary. These; functions and the dictionary contain the knowledge of the used classes.; To do this, `rootcling` p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:5849,inherit,inherits,5849,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inherits']
Modifiability,"::move(M));; }),; CompileCallbackManager(; orc::createLocalCompileCallbackManager(TM->getTargetTriple(), 0)),; CODLayer(OptimizeLayer,; [this](Function &F) { return std::set<Function*>({&F}); },; *CompileCallbackManager,; orc::createLocalIndirectStubsManagerBuilder(; TM->getTargetTriple())) {; llvm::sys::DynamicLibrary::LoadLibraryPermanently(nullptr);; }. Next we have to update our constructor to initialize the new members. To create; an appropriate compile callback manager we use the; createLocalCompileCallbackManager function, which takes a TargetMachine and an; ExecutorAddr to call if it receives a request to compile an unknown; function. In our simple JIT this situation is unlikely to come up, so we'll; cheat and just pass '0' here. In a production quality JIT you could give the; address of a function that throws an exception in order to unwind the JIT'd; code's stack. Now we can construct our CompileOnDemandLayer. Following the pattern from; previous layers we start by passing a reference to the next layer down in our; stack -- the OptimizeLayer. Next we need to supply a 'partitioning function':; when a not-yet-compiled function is called, the CompileOnDemandLayer will call; this function to ask us what we would like to compile. At a minimum we need to; compile the function being called (given by the argument to the partitioning; function), but we could also request that the CompileOnDemandLayer compile other; functions that are unconditionally called (or highly likely to be called) from; the function being called. For KaleidoscopeJIT we'll keep it simple and just; request compilation of the function that was called. Next we pass a reference to; our CompileCallbackManager. Finally, we need to supply an ""indirect stubs; manager builder"": a utility function that constructs IndirectStubManagers, which; are in turn used to build the stubs for the functions in each module. The; CompileOnDemandLayer will call the indirect stub manager builder once for each; call to a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:6167,layers,layers,6167,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['layers'],['layers']
Modifiability,"::string foo{""foo""};; std::memcpy(st.char_buffer, foo.data(), foo.size());; }; """"""). struct = ROOT.Struct(); ROOT.fill_char_buffer(struct); char_buffer = struct.char_buffer. # With thew new cppyy, you get access to the lower level buffer instead of a; # Python string:; print(""struct.char_buffer : "", char_buffer). # However, you can turn the buffer into a string very easily with as_string():; print(""struct.char_buffer.as_string(): "", char_buffer.as_string()); ```; The output of this script with ROOT 6.32:; ```; struct.char_buffer : <cppyy.LowLevelView object at 0x74c7a2682fb0>; struct.char_buffer.as_string(): foo; ```. ### Deprecate the attribute pythonization of `TDirectory` in favor of item-getting syntax. The new recommended way to get objects from a `TFile` or any `TDirectory` in general is now via `__getitem__`:. ```python; tree = my_file[""my_tree""] # instead of my_file.my_tree; ```. This is more consistent with other Python collections (like dictionaries), makes sure that member functions can't be confused with branch names, and easily allows you to use string variables as keys. With the new dictionary-like syntax, you can also get objects with names that don't qualify as a Python variable. Here is a short demo:; ```python; import ROOT. with ROOT.TFile.Open(""my_file.root"", ""RECREATE"") as my_file:. # Populate the TFile with simple objects.; my_file.WriteObject(ROOT.std.string(""hello world""), ""my_string""); my_file.WriteObject(ROOT.vector[""int""]([1, 2, 3]), ""my vector""). print(my_file[""my_string""]) # new syntax; print(my_file.my_string) # old deprecated syntax. # With the dictionary syntax, you can also use names that don't qualify as; # a Python variable:; print(my_file[""my vector""]); # print(my_file.my vector) # the old syntax would not work here!; ```. The old pythonization with the `__getattr__` syntax still works, but emits a deprecation warning and will be removed from ROOT 6.34. ### Removal of Python 2 support. ROOT does no longer support Python 2. The mini",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:21572,variab,variables,21572,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['variab'],['variables']
Modifiability,":; `X`, `Y`, `Z`, `Rxy`, `Phi`, `Rxyz`. A given shape cannot be divided; however on any axis. The general rule is that that divisions are; possible on whatever axis that produces still known shapes as slices.; The division of shapes are performed by the call `TGeoShape::Divide()`,; but this operation can be done only via `TGeoVolume::Divide()` method.; In other words, the algorithm for dividing a specific shape is known by; the shape object, but is always invoked in a generic way from the volume; level. Details on how to do that can be found in the paragraph ‘Dividing; volumes'. One can see how all division options are interpreted and which; their result inside specific shape classes is. ### Parametric Shapes. Shapes generally have a set of parameters that is well defined at build; time. In fact, when the final geometrical hierarchy is assembled and the; geometry is closed, all constituent shapes `MUST`**have well defined and; valid parameters. In order to ease-up geometry creation, some; parameterizations are however allowed. For instance let's suppose that we need to define several volumes having; exactly the same properties but different sizes. A way to do this would; be to create as many different volumes and shapes. The modeller allows; however the definition of a single volume having undefined shape; parameters. ``` {.cpp}; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);; ```. - `name:` the name of the newly created volume;; - `shape:`the type of the associated shape. This has to contain the; case-insensitive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:54717,parameteriz,parameterizations,54717,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['parameteriz'],['parameterizations']
Modifiability,":; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made, clang-format analyzes whether there are other bin-packed cases in; the input file and act accordingly. .. note::. This is an experimental flag, that might go away or be renamed. Do; not use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNamespaceComments>`; If ``true``, clang-format adds missing namespace end comments for; namespaces and fixes invalid existing ones. This doesn't affect short; namespaces, which are controlled by ``ShortNamespaceLines``. .. code-block:: c++. true: false:; namespace longNamespace { vs. namespace longNamespace {; void foo(); void foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:63450,config,config,63450,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['config']
Modifiability,":Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:28551,config,configure,28551,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['config'],['configure']
Modifiability,":Minimizer class:; ; int Minimizer::CovMatrixStatus() : returning the status of the covariance matrix. Implemented by Minuit and Minuit2 and follows original Minuit code meaning: code = 0 (not calculated), 1 (approximated), 2 (matrix was made pos def) , 3 (accurate); ; bool Hesse(): to perform a full calculation of the Hessian matrix; . TMath. Fix a numerical problem in TMath::ErfcInverse for small input values. Now the normal quantile function is used for implementing it.; . MathMore. Fix 2 bugs in the quartic equation solver (see issue #49031).; ; A protection has been added against numerical errors which could cause NaN due to wrong inputs to an acos function. This problem appears also in the GSL cubic solver. A new GSL patched cubic function has been then added in MathMore.; ; A wrong statement (coming from the original CERNLIB code but not applicable in this case) has been removed.; . Add support for limited and fixed variables for all the GSL minimizers (""GSLMultiMin""), including the simulated annealing (""GSLSimAn"") and the non-linear least square fit methods (""GSLMultiFit"").; . SMatrix. Remove an unneeded check on the element value in the factorization routines used for inverting the matrices (both for the LU and for the Bunch-Kaufmann factorization). The check was preventing to inverting matrices when some of the matrix elements (like the diagonal) were smaller than an epsilon value set to ~ 10-15. This is not needed since it is enough to check that the values are not zero (i.e. when the matrix is singular). This bug was causing several failures in the CMS code when inverting matrices.; ; Add the Cholesky decomposition method for symmetric positive defined matrices (thanks to Manuel Schiller). A class has been introduced,; ROOT::Math::CholeskyDecomp which provaids methods for decomposing or inverting a matrix and also for solving a linear system.; . New methods have also been added in SMatrix: bool SMatrix::InvertChol() and SMatrix & SMatrix::InverseChol(ifa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:3070,variab,variables,3070,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,1,['variab'],['variables']
Modifiability,":Notify()`***. When building in interactive application the use of the **`TRint`**; object handles the `kSigInterrupt` signal. It causes the printing of the; message: ***`*** Break *** keyboard interrupt `***and makes a long jump; back to the ROOT command prompt. If no **`TRint`** object is created,; there will be no `kSigInterrupt` handling. All signals can be reset to; their default UNIX behavior via the call of; **`TSytem`**`::ResetSignal()`. All signals can be ignored via; `TSytem::IgnoreSignal()`. The **`TSytem::IgnoreInterrupt()`** is a method; to toggle the handling of the interrupt signal. Typically it is called; to prevent a `SIGINT` to interrupt some important call (like writing to; a ROOT file). If **`TRint`** is used and the default ROOT interrupt handler is not; desired, you should use `GetSignalHandler()` of **`TApplication`** to; get the interrupt handler and to remove it by `RemoveSignalHandler()`of; **`TSystem`** . ## Glossary. The following glossary is adapted from the description of the Rogue Wave; `Threads.h`++ package. A **`process`** is a program that is loaded into memory and prepared for; execution. Each process has a private address space. Processes begin; with a single thread. A **`thread`** is a sequence of instructions being executed in a; program. A thread has a program counter and a private stack to keep; track of local variables and return addresses. A multithreaded process; is associated with one or more threads. Threads execute independently.; All threads in a given process share the private address space of that; process. **`Concurrency`** exists when at least two threads are in progress at; the same time. A system with only a single processor can support; concurrency by switching execution contexts among multiple threads. **`Parallelism`** arises when at least two threads are executing; simultaneously. This requires a system with multiple processors.; Parallelism implies concurrency, but not vice-versa. A function is **`reentrant`*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:19570,adapt,adapted,19570,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['adapt'],['adapted']
Modifiability,":b::X"", ""b::X"", ""X""); namespace a { namespace b { class X; } }. Matcher<NamedDecl>matchesNameStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches NamedDecl nodes whose fully qualified names contain; a substring matched by the given RegExp. Supports specifying enclosing namespaces or classes by; prefixing the name with '<enclosing>::'. Does not match typedefs; of an underlying type with the given name. Example matches X (regexp == ""::X""); class X;. Example matches X (regexp is one of ""::X"", ""^foo::.*X"", among others); namespace foo { namespace bar { class X; } }. If the matcher is used in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<NamespaceDecl>isAnonymous; Matches anonymous namespace declarations. Given; namespace n {; namespace {} // #1; }; namespaceDecl(isAnonymous()) will match #1 but not ::n. Matcher<NamespaceDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<OMPDefaultClause>isFirstPrivateKind; Matches if the OpenMP ``default`` clause has ``firstprivate`` kind; specified. Given. #pragma omp parallel; #pragma omp parallel default(none); #pragma omp parallel default(shared); #pragma omp parallel default(private); #pragma omp parallel default(firstprivate). ``ompDefaultClause(isFirstPrivateKind())`` matches only; ``default(firstprivate)``. Matcher<OMPDefaultClause>isNoneKind; Matches if the OpenMP ``default`` clause has ``none`` kind specified. Given. #pragma omp parallel; #pragma omp parallel default(none); #pragma omp parallel default(shared); #pragma omp parallel default(private); #pragma omp parallel default(firstprivate). ``ompDefaultClause(isNon",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:102066,variab,variables,102066,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variables']
Modifiability,":basic_ios<T, Traits> {; };. template <class T, class Traits = std::char_traits<T> >; class my_stream2 : public std::basic_ios<T, Traits> {; class my_streambuf; : public std::basic_streambuf<T, Traits> {; };; public:; my_stream2() {; this->init(new my_streambuf);; }; };. void test() {; my_stream1<char> *p1 = new my_stream1<char>;; my_stream2<char> *p2 = new my_stream2<char>;; p1->narrow('a', 'b'); // warn; p2->narrow('a', 'b'); // ok; }. undefbehavior.MinusOnePosType; (C++); Undefined behavior: passing -1 to any streambuf/; istream/ostream member that accepts a value of; type traits::pos_type result in undefined behavior.; Source: C++03 27.4.3.2p3; C++11 27.5.4.2p3. #include <fstream>. class my_streambuf : public std::streambuf {; void f() {; seekpos(-1); // warn; }; };. #include <fstream>. void test() {; std::filebuf fb;; std::istream in(&fb);; std::filebuf::off_type pos(-1);; in.seekg(pos); // warn; }. different. Name, DescriptionExampleProgress. different.SuccessiveAssign; (C); Successive assign to a variable. int test() {; int i;; i=1;; i=2; // warn; return i;; }. different.NullDerefStmtOrder; (C); Dereferencing of the null pointer might take place. Checking the pointer for; null should be performed first.; Note: possibly an enhancement to ; core.NullDereference. struct S {; int x;; };. struct S* f();. void test() {; struct S *p1 = f();; int x1 = p1->x; // warn; if (p1) {};. struct S *p2 = f();; int x2 = p2->x; // ok; }. different.NullDerefCondOrder; (C); Dereferencing of the null pointer might take place. Checking the pointer for; null should be performed first.; Note: possibly an enhancement to ; core.NullDereference. struct S {int i;};. struct S* f();. void test() {; struct S *p = f();; if (p->i && p) {}; // warn; }. different.MultipleAccessors; (C++); Identical accessor bodies. Possibly a misprint. class A {; int i;; int j;; public:; int getI() { return i; }; int getJ() { return i; } // warn; };. class A {; int i;; int j;; public:; void setI(int& ii) { i = ii",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:19729,variab,variable,19729,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['variab'],['variable']
Modifiability,":list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not invalidate iterator or pointers to other elements; in the list. .. _dss_ilist:. llvm/ADT/ilist.h; ^^^^^^^^^^^^^^^^. ``ilist<T>`` implements an 'intrusive' doubly-linked list. It is intrusive,; because it requires the element to store and provide access to the prev/next; pointers for the list. ``ilist`` has the same drawbacks as ``std::list``, and additionally requires an; ``ilist_traits`` implementation for the element type, but it provides some novel; characteristics. In particular, it can efficiently store polymorphic objects,; the traits class is informed when an element is inserted or removed from the; list, and ``ilist``\ s are guaranteed to support a constant-time splice; operation. An ``ilist`` and an ``iplist`` are ``using`` aliases to one another and the; latter only currently exists for historical purposes. These properties are exactly what we want for things like ``Instruction``\ s and; basic blocks, which is why these are implemented with ``ilist``\ s. Related classes of interest are explained in the following subsections:. * :ref:`ilist_traits <dss_ilist_traits>`. * :ref:`llvm/ADT/ilist_node.h <dss_ilist_node>`. * :ref:`Sentinels <dss_ilist_sentinel>`. .. _dss_packedvector:. llvm/ADT/PackedVector.h; ^^^^^^^^^^^^^^^^^^^^^^^. Useful for storing a vector of values using only a few number of bits for each; value. Apart from the standard operations of a vector-like container, it can; also perform an 'or' set operation. For example:. .. code-block:: c++. enum State {; None = 0x0,; FirstCondition = 0x1,; SecondCondition = 0x2,; Both = 0x3; };. State get",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:67013,polymorphi,polymorphic,67013,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['polymorphi'],['polymorphic']
Modifiability,":local:. Overview; ========. Welcome to the LLVM project!. The LLVM project has multiple components. The core of the project is; itself called ""LLVM"". This contains all of the tools, libraries, and header; files needed to process intermediate representations and converts it into; object files. Tools include an assembler, disassembler, bitcode analyzer, and; bitcode optimizer. It also contains basic regression tests. C-like languages use the `Clang <https://clang.llvm.org/>`_ front end. This; component compiles C, C++, Objective C, and Objective C++ code into LLVM bitcode; -- and from there into object files, using LLVM. Other components include:; the `libc++ C++ standard library <https://libcxx.llvm.org>`_,; the `LLD linker <https://lld.llvm.org>`_, and more. Getting the Source Code and Building LLVM; =========================================. #. Check out LLVM (including subprojects like Clang):. * ``git clone https://github.com/llvm/llvm-project.git``; * Or, on windows:. ``git clone --config core.autocrlf=false; https://github.com/llvm/llvm-project.git``; * To save storage and speed-up the checkout time, you may want to do a; `shallow clone <https://git-scm.com/docs/git-clone#Documentation/git-clone.txt---depthltdepthgt>`_.; For example, to get the latest revision of the LLVM project, use. ``git clone --depth 1 https://github.com/llvm/llvm-project.git``. * You are likely only interested in the main branch moving forward, if; you don't want `git fetch` (or `git pull`) to download user branches, use:. ``sed 's#fetch = +refs/heads/\*:refs/remotes/origin/\*#fetch = +refs/heads/main:refs/remotes/origin/main#' -i llvm-project/.git/config``. #. Configure and build LLVM and Clang:. * ``cd llvm-project``; * ``cmake -S llvm -B build -G <generator> [options]``. Some common build system generators are:. * ``Ninja`` --- for generating `Ninja <https://ninja-build.org>`_; build files. Most llvm developers use Ninja.; * ``Unix Makefiles`` --- for generating make-compatible paralle",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:1131,config,config,1131,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['config']
Modifiability,":option:`--select`) or (:option:`--compare`) and its children. The **parents** layout includes the elements that match any given; criteria (:option:`--select`) or (:option:`--compare`) and its parents. The combined **view** layout includes the elements that match any given; criteria (:option:`--select`) or (:option:`--compare`), its parents; and children. **Notes**:. 1. When a selection criteria (:option:`--select`) is specified with no; report option, the **list** layout is selected.; 2. The comparison mode always uses the **view** layout. .. _select_:. SELECTION; ~~~~~~~~~; When printing an element, different data can be included and it varies; (:option:`--attribute`) from data directly associated with the binary; file (offset) to high level details such as coverage, lexical scope; level, location. As the printed output can reach a considerable size,; several selection options, enable printing of specific elements. The pattern matching can ignore the case (:option:`--select-nocase`); and be extended to use regular expressions (:option:`--select-regex`). ELEMENTS; ^^^^^^^^; The following options allow printing of elements that match the given; <pattern>, offset <value> or an element <condition>. .. option:: --select=<pattern>. Print all elements whose name or line number matches the given <pattern>. .. option:: --select-offsets=<value[,value,...]>. Print all elements whose offset matches the given values. See; :option:`--attribute` option. .. option:: --select-elements=<condition[,condition,...]>. Print all elements that satisfy the given <condition>. With **condition**; being one of the options in the following list. .. code-block:: text. =discarded: Discarded elements by the linker.; =global: Element referenced across Compile Units.; =optimized: Optimized inlined abstract references. .. option:: --select-nocase. Pattern matching is case-insensitive when using :option:`--select`. .. option:: --select-regex. Treat any <pattern> strings as regular expressions when se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:14655,extend,extended,14655,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['extend'],['extended']
Modifiability,":option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table debug information. This; allows for symbolicated backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:`-gmodules` Generate debug information that contains external; references to types defined in Clang modules or precompiled headers instead; of emitting redundant debug type information into every object file. This; option transparently switches the Clang module format to object file; containers that hold the Clang module together with the debug information.; When compiling a program that uses Clang modules or precompiled headers,; this option produces complete debug information with faster compile; times and much smaller object files. This option should not be used when building static libraries for; distribution to other machines because the debug info will contain; references to the module cache on the machine the object files in the; library were built on. .. option:: -fstandalone-debug -fno-standalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the bina",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:11988,variab,variables,11988,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['variab'],['variables']
Modifiability,":ref:`¶ <SpaceBeforeJsonColon>`; If ``true``, a space will be added before a JSON colon. For other; languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead. .. code-block:: c++. true: false:; { {; ""key"" : ""value"" vs. ""key"": ""value""; } }. .. _SpaceBeforeParens:. **SpaceBeforeParens** (``SpaceBeforeParensStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceBeforeParens>`; Defines in which cases to put a space before opening parentheses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatements``); Put a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Config",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:117007,config,configuration,117007,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"; """""""""""""""""". The '``llvm.ubsantrap``' intrinsic. Arguments:; """""""""""""""""""". An integer describing the kind of failure detected. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an execution trap,; embedding the argument into encoding of that trap somehow to discriminate; crashes if possible. Equivalent to ``@llvm.trap`` for targets that do not support this behaviour. '``llvm.stackprotector``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackprotector(ptr <guard>, ptr <slot>). Overview:; """""""""""""""""". The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it; onto the stack at ``slot``. The stack slot is adjusted to ensure that it; is placed on the stack before local variables. Arguments:; """""""""""""""""""". The ``llvm.stackprotector`` intrinsic requires two pointer arguments.; The first argument is the value loaded from the stack guard; ``@__stack_chk_guard``. The second variable is an ``alloca`` that has; enough space to hold the value of the guard. Semantics:; """""""""""""""""""". This intrinsic causes the prologue/epilogue inserter to force the position of; the ``AllocaInst`` stack slot to be before local variables on the stack. This is; to ensure that if a local variable on the stack is overwritten, it will destroy; the value of the guard. When the function exits, the guard on the stack is; checked against the original guard by ``llvm.stackprotectorcheck``. If they are; different, then ``llvm.stackprotectorcheck`` causes the program to abort by; calling the ``__stack_chk_fail()`` function. '``llvm.stackguard``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stackguard(). Overview:; """""""""""""""""". The ``llvm.stackguard`` intrinsic returns the system stack guard value. It should not be generated by frontends, since it is only for internal usage.; The reason why we create this intrinsic is that we still support IR form Stack; Protector in FastISel. Argument",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:930125,variab,variable,930125,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"; #endif. .. _PackConstructorInitializers:. **PackConstructorInitializers** (``PackConstructorInitializersStyle``) :versionbadge:`clang-format 14` :ref:`¶ <PackConstructorInitializers>`; The pack constructor initializers style to use. Possible values:. * ``PCIS_Never`` (in configuration: ``Never``); Always put each constructor initializer on its own line. .. code-block:: c++. Constructor(); : a(),; b(). * ``PCIS_BinPack`` (in configuration: ``BinPack``); Bin-pack constructor initializers. .. code-block:: c++. Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_CurrentLine`` (in configuration: ``CurrentLine``); Put all constructor initializers on the current line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; ddddddddddddd(). * ``PCIS_NextLine`` (in configuration: ``NextLine``); Same as ``PCIS_CurrentLine`` except that if all constructor initializers; do not fit on the current line, try to fit them on the next line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_NextLineOnly`` (in configuration: ``NextLineOnly``); Put all constructor initializers on the next line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor(); : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). .. _PenaltyBreakAssignment:. **PenaltyBreakAssignment** (``Unsigned``) :versionbadge:`clang-format 5` :ref:`¶ <PenaltyBreakAssignment>`; The penalty for breaking around an assignment operator. .. _PenaltyBreakBeforeFirstCallParameter:. **PenaltyBreakBeforeFirstCallParameter** (``Unsigned``) :v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:92856,config,configuration,92856,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"; $lex_1_start:; EXEC = %1 & %2; $if_1_then:; b;; %3 = EXEC; %4 = c2; $lex_1_1_start:; EXEC = %3 & %4; $lex_1_1_then:; c;; EXEC = ~EXEC & %3; $lex_1_1_else:; d;; EXEC = %3; $lex_1_1_end:; e;; EXEC = ~EXEC & %1; $lex_1_else:; f;; EXEC = %1; $lex_1_end:; g;; $lex_end:. To create the DWARF location list expression that defines the location; description of a vector of lane program locations, the LLVM MIR ``DBG_VALUE``; pseudo instruction can be used to annotate the linearized control flow. This can; be done by defining an artificial variable for the lane PC. The DWARF location; list expression created for it is used as the value of the; ``DW_AT_LLVM_lane_pc`` attribute on the subprogram's debugger information entry. A DWARF procedure is defined for each well nested structured control flow region; which provides the conceptual lane program location for a lane if it is not; active (namely it is divergent). The DWARF operation expression for each region; conceptually inherits the value of the immediately enclosing region and modifies; it according to the semantics of the region. For an ``IF/THEN/ELSE`` region the divergent program location is at the start of; the region for the ``THEN`` region since it is executed first. For the ``ELSE``; region the divergent program location is at the end of the ``IF/THEN/ELSE``; region since the ``THEN`` region has completed. The lane PC artificial variable is assigned at each region transition. It uses; the immediately enclosing region's DWARF procedure to compute the program; location for each lane assuming they are divergent, and then modifies the result; by inserting the current program location for each lane that the ``EXEC`` mask; indicates is active. By having separate DWARF procedures for each region, they can be reused to; define the value for any nested region. This reduces the total size of the DWARF; operation expressions. The following provides an example using pseudo LLVM MIR. .. code::; :number-lines:. $lex_start:; DEFINE_D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:103301,inherit,inherits,103301,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['inherit'],['inherits']
Modifiability,"; (e.g. the naming convention). This is because they are relatively new, and a; lot of code was written before they were put in place. Our long term goal is; for the entire codebase to follow the convention, but we explicitly *do not*; want patches that do large-scale reformatting of existing code. On the other; hand, it is reasonable to rename the methods of a class if you're about to; change it in some other way. Please commit such changes separately to; make code review easier. The ultimate goal of these guidelines is to increase the readability and; maintainability of our common source base. Languages, Libraries, and Standards; ===================================. Most source code in LLVM and other LLVM projects using these coding standards; is C++ code. There are some places where C code is used either due to; environment restrictions, historical restrictions, or due to third-party source; code imported into the tree. Generally, our preference is for standards; conforming, modern, and portable C++ code as the implementation language of; choice. For automation, build-systems and utility scripts Python is preferred and; is widely used in the LLVM repository already. C++ Standard Versions; ---------------------. Unless otherwise documented, LLVM subprojects are written using standard C++17; code and avoid unnecessary vendor-specific extensions. Nevertheless, we restrict ourselves to features which are available in the; major toolchains supported as host compilers (see :doc:`GettingStarted` page,; section `Software`). Each toolchain provides a good reference for what it accepts:. * Clang: https://clang.llvm.org/cxx_status.html. * libc++: https://libcxx.llvm.org/Status/Cxx17.html. * GCC: https://gcc.gnu.org/projects/cxx-status.html#cxx17. * libstdc++: https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.2017. * MSVC: https://msdn.microsoft.com/en-us/library/hh567368.aspx. C++ Standard Library; --------------------. Instead of implementing custom dat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:2112,portab,portable,2112,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['portab'],['portable']
Modifiability,"; * - `Compiler Research - Calling C++ libraries from a D-written DSL: A cling/cppyy-based approach <https://www.youtube.com/watch?v=7teqrCNzrD8>`_; - *Alexandru Militaru* 2021 Compiler-Research Meeting; - This video presents D and C++ interoperability through SIL-Cling architecture. .. list-table:: Interactive CUDA C++ with Cling:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Adding CUDA® Support to Cling: JIT Compile to GPUs <https://www.youtube.com/watch?v=XjjZRhiFDVs>`_; - *Simeon Ehrig* 2020 LLVM Developer Meeting; - Interactive CUDA-C++ through Cling is presented. Cling-CUDA architecture is discussed in detail, and an example of interactive simulation for laser plasma applications is shown. . .. list-table:: C++ in Jupyter Notebook - Xeus Cling:; :widths: 25 25 50; :header-rows: 1; ; * - Link; - Info ; - Description; * - `Interactive C++ code development using C++Explorer and GitHub Classroom for educational purposes <https://www.youtube.com/watch?v=HBgF2Yr0foA>`_; - *Patrick Diehl* 2020 Youtube; - C++Explorer is a novel teaching environment based on Jupyterhub and Cling, adapted to teaching C++ programming and source code management.; * - `Deep dive into the Xeus-based Cling kernel for Jupyter <https://www.youtube.com/watch?v=kx3wvKk4Qss>`_; - *Vassil Vassilev* 2021 Youtube; - Xeus-Cling is a Cling-based notebook kernel which delivers interactive C++. ; * - `Xeus-Cling: Run C++ code in Jupyter Notebook <https://www.youtube.com/watch?v=4fcKlJ_5QQk>`_ ; - *LearnOpenCV* 2019 Youtube; - In this demo, you will learn an example of C++ code in Jupyter Notebook using Xeus-Cling kernel. . .. list-table:: Clad:; :widths: 25 25 50; :header-rows: 1; ; * - Link; - Info ; - Description; * - `Clad: Automatic differentiation plugin for C++ <https://clad.readthedocs.io/en/latest/index.html>`_ ; - Read The Docs webpage; - Clad is a plugin for Cling. It allows to perform Automatic Differentiation (AD) on multivariate functions and functor objects. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:6976,adapt,adapted,6976,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,3,"['adapt', 'plugin']","['adapted', 'plugin']"
Modifiability,; * - mlir/unittests/Dialect/Utils; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/ExecutionEngine; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Interfaces; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/IR; - `7`; - `7`; - `0`; - :good:`100%`; * - mlir/unittests/Pass; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/Rewrite; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Support; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:121917,plugin,plugins,121917,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"; * The L2 cache has independent channels to service disjoint ranges of virtual; addresses.; * Each CU has a separate request queue per channel. Therefore, the vector and; scalar memory operations performed by wavefronts executing in different; work-groups (which may be executing on different CUs) of an agent can be; reordered relative to each other. A ``s_waitcnt vmcnt(0)`` is required to; ensure synchronization between vector memory operations of different CUs. It; ensures a previous vector memory operation has completed before executing a; subsequent vector memory or LDS operation and so can be used to meet the; requirements of acquire and release.; * The L2 cache can be kept coherent with other agents on some targets, or ranges; of virtual addresses can be set up to bypass it to ensure system coherence. Scalar memory operations are only used to access memory that is proven to not; change during the execution of the kernel dispatch. This includes constant; address space and global address space for program scope ``const`` variables.; Therefore, the kernel machine code does not have to maintain the scalar cache to; ensure it is coherent with the vector caches. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:209508,variab,variables,209508,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variables']
Modifiability,"; ++i); 		data.add(buffer[2*i+1]); // the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......; ```. Instead in this example we will create a 2-dim `UnBinData` object with the contents from a ROOT `TTree`. ``` {.cpp}; TFile * file = TFile::Open(""hsimple.root"");; TTree *ntuple = 0; file->GetObject(""ntuple"",ntuple);; 	// select from the tree the data we want to use for fitting; 	// we use TTree::Draw for this; 	int nevt = ntuple->Draw(""px:py"","""",""goff"");; 	double * x = ntuple->GetV1();; 	double * y = ntuple->GetV2();; ROOT::Fit::UnBinData data(nevt, x, y );; ```. ### Creating the Fit model. In order to fit a data sets we need a model to describe our data, e.g. a probability density function describing our observed data or; an hypothetical function describing the relation between the independent variables **`X`** and the single dependent variable `Y`.; We can have an arbitrary number `k` of independent variables. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:35627,variab,variables,35627,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['variab'],['variables']
Modifiability,"; - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:5387,plugin,plugin-opt,5387,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['plugin'],['plugin-opt']
Modifiability,; - `11`; - `3`; - :part:`78%`; * - llvm/tools/bugpoint; - `12`; - `1`; - `11`; - :part:`8%`; * - llvm/tools/bugpoint-passes; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/dsymutil; - `18`; - `16`; - `2`; - :part:`88%`; * - llvm/tools/gold; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llc; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/lli; - `4`; - `3`; - `1`; - :part:`75%`; * - llvm/tools/lli/ChildTarget; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-ar; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-as; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-as-fuzzer; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-bcanalyzer; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-c-test; - `2`; - `0`; - `2`; - :none:`0%`; * - llvm/tools/llvm-cat; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-cfi-verify; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-cfi-verify/lib; - `4`; - `1`; - `3`; - :part:`25%`; * - llvm/tools/llvm-config; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-cov; - `23`; - `12`; - `11`; - :part:`52%`; * - llvm/tools/llvm-cvtres; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-cxxdump; - `4`; - `1`; - `3`; - :part:`25%`; * - llvm/tools/llvm-cxxfilt; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-cxxmap; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-debuginfod-find; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-diff; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-diff/lib; - `6`; - `0`; - `6`; - :none:`0%`; * - llvm/tools/llvm-dis; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-dis-fuzzer; - `1`; - `1`; - `0`; - :good:`100%`; * - llvm/tools/llvm-dlang-demangle-fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - llvm/tools/llvm-dwarfdump; - `4`; - `3`; - `1`; - :part:`75%`; * - llvm/tools/llvm-dwarfdump/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-dwp; - `1`; - `0`; - `1`; - :none:`0%`; * - llvm/tools/llvm-exegesis; -,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:82573,config,config,82573,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['config'],['config']
Modifiability,; - `3`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring; - `15`; - `12`; - `3`; - :part:`80%`; * - clang/include/clang/Tooling/Refactoring/Extract; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring/Rename; - `6`; - `5`; - `1`; - :part:`83%`; * - clang/include/clang/Tooling/Syntax; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Syntax/Pseudo; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Transformer; - `8`; - `6`; - `2`; - :part:`75%`; * - clang/include/clang-c; - `10`; - `3`; - `7`; - :part:`30%`; * - clang/INPUTS; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/lib/Analysis; - `28`; - `3`; - `25`; - :part:`10%`; * - clang/lib/Analysis/FlowSensitive; - `7`; - `7`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerDependencyHandling; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerOptionHandling; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/Analysis/plugins/SampleAnalyzer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/APINotes; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/lib/ARCMigrate; - `22`; - `0`; - `22`; - :none:`0%`; * - clang/lib/AST; - `81`; - `2`; - `79`; - :part:`2%`; * - clang/lib/AST/Interp; - `44`; - `18`; - `26`; - :part:`40%`; * - clang/lib/ASTMatchers; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/lib/ASTMatchers/Dynamic; - `6`; - `1`; - `5`; - :part:`16%`; * - clang/lib/Basic; - `39`; - `13`; - `26`; - :part:`33%`; * - clang/lib/Basic/Targets; - `50`; - `25`; - `25`; - :part:`50%`; * - clang/lib/CodeGen; - `87`; - `9`; - `78`; - :part:`10%`; * - clang/lib/CrossTU; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/lib/DirectoryWatcher/default; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher/linux; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher/mac; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatche,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:6881,plugin,plugins,6881,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ```. See ""Example 2: A Tree with a C Structure"" below; (`$ROOTSYS/tutorials/tree/tree2.C`) and `staff.C` at the beginning of; this chapter. ## Adding a TBranch to Hold an Object. To write a branch to hold an event object, we need to load the; definition of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:22246,variab,variable,22246,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"; - `TRANSFORM2_WALSH_HAAR`; - `TRANSFORM2_COS_WALSH`; - `TRANSFORM2_COS_HAAR`; - `TRANSFORM2_SIN_WALSH`; - `TRANSFORM2_SIN_HAAR`; - **`direction`**: transform direction (forward, inverse); - **`degree`**: applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is; given in Figure 6.7. One can notice that the data are concentrated again; around the beginning of the coordinate system. This allows to apply; filtration, enhancement and compression techniques in the transform; domain. ![2-dimensional Cosine transform of data from Figure 5.6](figures/image208.png). In some cases, when the spectrum is smooth, the cosine transforms are very; efficient. In Figures 6.8, 6.9 we show original spectrum and transformed; coefficients using Cosine transform, respectively. ![Original spectrum](figures/image210.png). ![Transformed coefficients using Cosine transform](figures/image212.png). Similarly to 1-dimensional case we have also implemented the functions for zonal filtration, Gauss filtration and enhancement.; The zonal filtration function using classic transforms has the form of. ```{.cpp}; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter_coeff);; ```. This function transforms the source spectrum. The calling program should; fill in the input parameters. Then it sets transformed coefficients in the; given region to the given; `filter_coeff` and transforms it back. Filtered data are written into the dest; spectrum. Function parameters:. - **`source`**: pointer to the matrix of source spectrum, its size should be `sizex`*`sizey`; - **`dest`**: pointer to the matrix of destination data, its size should be `sizex`*`sizey`; - **`sizex,sizey`**: basic dimensions of source and dest spectra; - **`type`**: type of transform:; - `TRANSFORM2_HAAR`; - `TRANSFORM2_WALSH`; - `TRANSFORM2_COS`; - `TRANSFORM2_SIN`; - `TRANSFORM2_FOU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:67796,enhance,enhancement,67796,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['enhance'],['enhancement']
Modifiability,"; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function prototypes are considered ABI-visible. All ABI-visible pointers are treated as ``__single`` by default unless annotated; otherwise. This default both preserves ABI and makes these pointers safe by; default. This behavior can be controlled with macros, i.e.,; ``__ptrcheck_abi_assume_*ATTR*()``, to set the default annotation for; ABI-visible pointers to be either ``__single``, ``__bidi_indexable``,; ``__indexable``, or ``__unsafe_indexable``. For instance,; ``__ptrcheck_abi_assume_unsafe_indexable()`` will make all ABI-visible pointers; be ``__unsafe_indexable``. Non-ABI visible pointers — the outermost pointer; types of local variables — are ``__bidi_indexable`` by default, so that these; pointers have the bounds information necessary to perform bounds checks without; the need for a manual annotation. All ``const cha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:20984,variab,variables,20984,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variables']
Modifiability,; --hash=sha256:9aad3c1755095ce347e26488214ef77e0485a3c34a50c5a5e2471dff60b9dd9c \; --hash=sha256:9dcdfd0eaf283af041973bff14a2e143b8bd64e069f4c383416ecd79a81aab58 \; --hash=sha256:aa57bd9cf8ae831a362185ee444e15a93ecb2e344c8e52e4d721ea3ab6ef1823 \; --hash=sha256:aa7bd130efab1c280bed0f45501b7c8795f9fdbeb02e965371bbef3523627779 \; --hash=sha256:ab4a0df41e7c16a1392727727e7998a467472d0ad65f3ad5e6e765015df08636 \; --hash=sha256:ad9e82fb8f09ade1c3e1b996a6337afac2b8b9e365f926f5a61aacc71adc5b3c \; --hash=sha256:af598ed32d6ae86f1b747b82783958b1a4ab8f617b06fe68795c7f026abbdcad \; --hash=sha256:b076b6226fb84157e3f7c971a47ff3a679d837cf338547532ab866c57930dbee \; --hash=sha256:b7ff0f54cb4ff66dd38bebd335a38e2c22c41a8ee45aa608efc890ac3e3931bc \; --hash=sha256:bfce63a9e7834b12b87c64d6b155fdd9b3b96191b6bd334bf37db7ff1fe457f2 \; --hash=sha256:c011a4149cfbcf9f03994ec2edffcb8b1dc2d2aede7ca243746df97a5d41ce48 \; --hash=sha256:c9c804664ebe8f83a211cace637506669e7890fec1b4195b505c214e50dd4eb7 \; --hash=sha256:ca379055a47383d02a5400cb0d110cef0a776fc644cda797db0c5696cfd7e18e \; --hash=sha256:cb0932dc158471523c9637e807d9bfb93e06a95cbf010f1a38b98623b929ef2b \; --hash=sha256:cd0f502fe016460680cd20aaa5a76d241d6f35a1c3350c474bac1273803893fa \; --hash=sha256:ceb01949af7121f9fc39f7d27f91be8546f3fb112c608bc4029aef0bab86a2a5 \; --hash=sha256:d080e0a5eb2529460b30190fcfcc4199bd7f827663f858a226a81bc27beaa97e \; --hash=sha256:dd15ff04ffd7e05ffcb7fe79f1b98041b8ea30ae9234aed2a9168b5797c3effb \; --hash=sha256:df0be2b576a7abbf737b1575f048c23fb1d769f267ec4358296f31c2479db8f9 \; --hash=sha256:e09031c87a1e51556fdcb46e5bd4f59dfb743061cf93c4d6831bf894f125eb57 \; --hash=sha256:e4dd52d80b8c83fdce44e12478ad2e85c64ea965e75d66dbeafb0a3e77308fcc \; --hash=sha256:f698de3fd0c4e6972b92290a45bd9b1536bffe8c6759c62471efaa8acb4c37bc \; --hash=sha256:fec21693218efe39aa7f8599346e90c705afa52c5b31ae019b2e57e8f6542bb2 \; --hash=sha256:ffcc3f7c66b5f5b7931a5aa68fc9cecc51e685ef90282f4a82f0f5e9b704ad11; # via jinja2; mdit-py-plugins==0.,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:15064,plugin,plugins,15064,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['plugin'],['plugins']
Modifiability,"; .. _instructionselect:. InstructionSelect; -----------------. This pass transforms generic machine instructions into equivalent; target-specific instructions. It traverses the ``MachineFunction`` bottom-up,; selecting uses before definitions, enabling trivial dead code elimination. .. _api-instructionselector:. API: InstructionSelector; ^^^^^^^^^^^^^^^^^^^^^^^^. The target implements the ``InstructionSelector`` class, containing the; target-specific selection logic proper. The instance is provided by the subtarget, so that it can specialize the; selector by subtarget feature (with, e.g., a vector selector overriding parts; of a general-purpose common selector).; We might also want to parameterize it by MachineFunction, to enable selector; variants based on function attributes like optsize. The simple API consists of:. .. code-block:: c++. virtual bool select(MachineInstr &MI). This target-provided method is responsible for mutating (or replacing) a; possibly-generic MI into a fully target-specific equivalent.; It is also responsible for doing the necessary constraining of gvregs into the; appropriate register classes as well as passing through COPY instructions to; the register allocator. The ``InstructionSelector`` can fold other instructions into the selected MI,; by walking the use-def chain of the vreg operands.; As GlobalISel is Global, this folding can occur across basic blocks. SelectionDAG Rule Imports; ^^^^^^^^^^^^^^^^^^^^^^^^^. TableGen will import SelectionDAG rules and provide the following function to; execute them:. .. code-block:: c++. bool selectImpl(MachineInstr &MI). The ``--stats`` option can be used to determine what proportion of rules were; successfully imported. The easiest way to use this is to copy the; ``-gen-globalisel`` tablegen command from ``ninja -v`` and modify it. Similarly, the ``--warn-on-skipped-patterns`` option can be used to obtain the; reasons that rules weren't imported. This can be used to focus on the most; important rejec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst:695,parameteriz,parameterize,695,interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst,1,['parameteriz'],['parameterize']
Modifiability,"; .. _tblgen-mirpats:. ========================; MIR Patterns in TableGen; ========================. .. contents::; :local:. User's Guide; ============. This section is intended for developers who want to use MIR patterns in their; TableGen files. ``NOTE``:; This feature is still in active development. This document may become outdated; over time. If you see something that's incorrect, please update it. Use Cases; ---------. MIR patterns are supported in the following places:. * GlobalISel ``GICombineRule``; * GlobalISel ``GICombinePatFrag``. Syntax; ------. MIR patterns use the DAG datatype in TableGen. .. code-block:: text. (inst operand0, operand1, ...). ``inst`` must be a def which inherits from ``Instruction`` (e.g. ``G_FADD``); or ``GICombinePatFrag``. Operands essentially fall into one of two categories:. * immediates. * untyped, unnamed: ``0``; * untyped, named: ``0:$y``; * typed, unnamed: ``(i32 0)``; * typed, named: ``(i32 0):$y``. * machine operands. * untyped: ``$x``; * typed: ``i32:$x``. Semantics:. * A typed operand always adds an operand type check to the matcher.; * There is a trivial type inference system to propagate types. * e.g. You only need to use ``i32:$x`` once in any pattern of a; ``GICombinePatFrag`` alternative or ``GICombineRule``, then all; other patterns in that rule/alternative can simply use ``$x``; (``i32:$x`` is redundant). * A named operand's behavior depends on whether the name has been seen before. * For match patterns, reusing an operand name checks that the operands; are identical (see example 2 below).; * For apply patterns, reusing an operand name simply copies that operand into; the new instruction (see example 2 below). Operands are ordered just like they would be in a MachineInstr: the defs (outs); come first, then the uses (ins). Patterns are generally grouped into another DAG datatype with a dummy operator; such as ``match``, ``apply`` or ``pattern``. Finally, any DAG datatype in TableGen can be named. This also holds for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:695,inherit,inherits,695,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['inherit'],['inherits']
Modifiability,"; .. role:: block-term. =================================; Language Specification for Blocks; =================================. .. contents::; :local:. Revisions; =========. - 2008/2/25 --- created; - 2008/7/28 --- revised, ``__block`` syntax; - 2008/8/13 --- revised, Block globals; - 2008/8/21 --- revised, C++ elaboration; - 2008/11/1 --- revised, ``__weak`` support; - 2009/1/12 --- revised, explicit return types; - 2009/2/10 --- revised, ``__block`` objects need retain. Overview; ========. A new derived type is introduced to C and, by extension, Objective-C,; C++, and Objective-C++. The Block Type; ==============. Like function types, the :block-term:`Block type` is a pair consisting; of a result value type and a list of parameter types very similar to a; function type. Blocks are intended to be used much like functions with; the key distinction being that in addition to executable code they; also contain various variable bindings to automatic (stack) or managed; (heap) memory. The abstract declarator,. .. code-block:: c. int (^)(char, float). describes a reference to a Block that, when invoked, takes two; parameters, the first of type char and the second of type float, and; returns a value of type int. The Block referenced is of opaque data; that may reside in automatic (stack) memory, global memory, or heap; memory. Block Variable Declarations; ===========================. A :block-term:`variable with Block type` is declared using function; pointer style notation substituting ``^`` for ``*``. The following are; valid Block variable declarations:. .. code-block:: c. void (^blockReturningVoidWithVoidArgument)(void);; int (^blockReturningIntWithIntAndCharArguments)(int, char);; void (^arrayOfTenBlocksReturningVoidWithIntArgument[10])(int);. Variadic ``...`` arguments are supported. [variadic.c] A Block that; takes no arguments must specify void in the argument list [voidarg.c].; An empty parameter list does not represent, as K&R provide, an; unspecified argument li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:930,variab,variable,930,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variable']
Modifiability,"; ...; static int gettok() {; ...; if (IdentifierStr == ""in""); return tok_in;; if (IdentifierStr == ""binary""); return tok_binary;; if (IdentifierStr == ""unary""); return tok_unary;; if (IdentifierStr == ""var""); return tok_var;; return tok_identifier;; ... The next step is to define the AST node that we will construct. For; var/in, it looks like this:. .. code-block:: c++. /// VarExprAST - Expression class for var/in; class VarExprAST : public ExprAST {; std::vector<std::pair<std::string, std::unique_ptr<ExprAST>>> VarNames;; std::unique_ptr<ExprAST> Body;. public:; VarExprAST(std::vector<std::pair<std::string, std::unique_ptr<ExprAST>>> VarNames,; std::unique_ptr<ExprAST> Body); : VarNames(std::move(VarNames)), Body(std::move(Body)) {}. Value *codegen() override;; };. var/in allows a list of names to be defined all at once, and each name; can optionally have an initializer value. As such, we capture this; information in the VarNames vector. Also, var/in has a body, this body; is allowed to access the variables defined by the var/in. With this in place, we can define the parser pieces. The first thing we; do is add it as a primary expression:. .. code-block:: c++. /// primary; /// ::= identifierexpr; /// ::= numberexpr; /// ::= parenexpr; /// ::= ifexpr; /// ::= forexpr; /// ::= varexpr; static std::unique_ptr<ExprAST> ParsePrimary() {; switch (CurTok) {; default:; return LogError(""unknown token when expecting an expression"");; case tok_identifier:; return ParseIdentifierExpr();; case tok_number:; return ParseNumberExpr();; case '(':; return ParseParenExpr();; case tok_if:; return ParseIfExpr();; case tok_for:; return ParseForExpr();; case tok_var:; return ParseVarExpr();; }; }. Next we define ParseVarExpr:. .. code-block:: c++. /// varexpr ::= 'var' identifier ('=' expression)?; // (',' identifier ('=' expression)?)* 'in' expression; static std::unique_ptr<ExprAST> ParseVarExpr() {; getNextToken(); // eat the var. std::vector<std::pair<std::string, std::unique_ptr<Ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:24290,variab,variables,24290,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"; // var a = 1 in; // var a = a in ... # refers to outer 'a'.; Value *InitVal;; if (Init) {; InitVal = Init->codegen();; if (!InitVal); return nullptr;; } else { // If not specified, use 0.0.; InitVal = ConstantFP::get(*TheContext, APFloat(0.0));; }. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);; Builder->CreateStore(InitVal, Alloca);. // Remember the old variable binding so that we can restore the binding when; // we unrecurse.; OldBindings.push_back(NamedValues[VarName]);. // Remember this binding.; NamedValues[VarName] = Alloca;; }. There are more comments here than code. The basic idea is that we emit; the initializer, create the alloca, then update the symbol table to; point to it. Once all the variables are installed in the symbol table,; we evaluate the body of the var/in expression:. .. code-block:: c++. // Codegen the body, now that all vars are in scope.; Value *BodyVal = Body->codegen();; if (!BodyVal); return nullptr;. Finally, before returning, we restore the previous variable bindings:. .. code-block:: c++. // Pop all our variables from scope.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i); NamedValues[VarNames[i].first] = OldBindings[i];. // Return the body computation.; return BodyVal;; }. The end result of all of this is that we get properly scoped variable; definitions, and we even (trivially) allow mutation of them :). With this, we completed what we set out to do. Our nice iterative fib; example from the intro compiles and runs just fine. The mem2reg pass; optimizes all of our stack variables into SSA registers, inserting PHI; nodes where needed, and our front-end remains simple: no ""iterated; dominance frontier"" computation anywhere in sight. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; mutable variables and var/in support. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:28324,variab,variable,28324,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"; /// the function. This is used for mutable variables etc.; static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction,; const std::string &VarName) {; IRBuilder<> TmpB(&TheFunction->getEntryBlock(),; TheFunction->getEntryBlock().begin());; return TmpB.CreateAlloca(Type::getDoubleTy(*TheContext), nullptr,; VarName);; }. This funny looking code creates an IRBuilder object that is pointing at; the first instruction (.begin()) of the entry block. It then creates an; alloca with the expected name and returns it. Because all values in; Kaleidoscope are doubles, there is no need to pass in a type to use. With this in place, the first functionality change we want to make belongs to; variable references. In our new scheme, variables live on the stack, so; code generating a reference to them actually needs to produce a load; from the stack slot:. .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; AllocaInst *A = NamedValues[Name];; if (!A); return LogErrorV(""Unknown variable name"");. // Load the value.; return Builder->CreateLoad(A->getAllocatedType(), A, Name.c_str());; }. As you can see, this is pretty straightforward. Now we need to update; the things that define the variables to set up the alloca. We'll start; with ``ForExprAST::codegen()`` (see the `full code listing <#id1>`_ for; the unabridged code):. .. code-block:: c++. Function *TheFunction = Builder->GetInsertBlock()->getParent();. // Create an alloca for the variable in the entry block.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);. // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. // Store the value into the alloca.; Builder->CreateStore(StartVal, Alloca);; ... // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mut",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:14043,variab,variable,14043,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"; 3. Remember that you were warned twice about reading the documentation. Test LLVM on the command line:; ------------------------------; The LLVM tests can be run by changing directory to the llvm source; directory and running:. .. code-block:: bat. c:\llvm> python ..\build\Release\bin\llvm-lit.py llvm\test. This example assumes that Python is in your PATH variable, which would be; after **Add Python to the PATH** was selected during Python installation.; If you had opened a command window prior to Python installation, you would; have to close and reopen it to get the updated PATH. A specific test or test directory can be run with:. .. code-block:: bat. c:\llvm> python ..\build\Release\bin\llvm-lit.py llvm\test\Transforms\Util. Build the LLVM Suite:; ---------------------; * The projects may still be built individually, but to build them all do; not just select all of them in batch build (as some are meant as; configuration projects), but rather select and build just the; ``ALL_BUILD`` project to build everything, or the ``INSTALL`` project,; which first builds the ``ALL_BUILD`` project, then installs the LLVM; headers, libs, and other useful things to the directory set by the; ``CMAKE_INSTALL_PREFIX`` setting when you first configured CMake.; * The Fibonacci project is a sample program that uses the JIT. Modify the; project's debugging properties to provide a numeric command line argument; or run it from the command line. The program will print the; corresponding fibonacci value. Links; =====; This document is just an **introduction** to how to use LLVM to do some simple; things... there are many more interesting and complicated things that you can; do that aren't documented here (but we'll gladly accept a patch if you want to; write something up!). For more information about LLVM, check out:. * `LLVM homepage <https://llvm.org/>`_; * `LLVM doxygen tree <https://llvm.org/doxygen/>`_; * Additional information about the LLVM directory structure and tool chain; can be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:9732,config,configuration,9732,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,2,['config'],"['configuration', 'configured']"
Modifiability,"; 42} ptr is {&x}; }; ```. ## Example: finding output parameters. Let's explore how data flow analysis can help with a problem that is hard to; solve with other tools in Clang. ### Problem description. Output parameters are function parameters of pointer or reference type whose; pointee is completely overwritten by the function, and not read before it is; overwritten. They are common in pre-C++11 code due to the absence of move; semantics. In modern C++ output parameters are non-idiomatic, and return values; are used instead. Imagine that we would like to refactor output parameters to return values to; modernize old code. The first step is to identify refactoring candidates through; static analysis. For example, in the following code snippet the pointer `c` is an output; parameter:. ```c++; struct Customer {; int account_id;; std::string name;; }. void GetCustomer(Customer *c) {; c->account_id = ...;; if (...) {; c->name = ...;; } else {; c->name = ...;; }; }; ```. We would like to refactor this code into:. ```c++; Customer GetCustomer() {; Customer c;; c.account_id = ...;; if (...) {; c.name = ...;; } else {; c.name = ...;; }; return c;; }; ```. However, in the function below the parameter `c` is not an output parameter; because its field `name` is not overwritten on every path through the function. ```c++; void GetCustomer(Customer *c) {; c->account_id = ...;; if (...) {; c->name = ...;; }; }; ```. The code also cannot read the value of the parameter before overwriting it:. ```c++; void GetCustomer(Customer *c) {; use(c->account_id);; c->name = ...;; c->account_id = ...;; }; ```. Functions that escape the pointer also block the refactoring:. ```c++; Customer* kGlobalCustomer;. void GetCustomer(Customer *c) {; c->name = ...;; c->account_id = ...;; kGlobalCustomer = c;; }; ```. To identify a candidate function for refactoring, we need to do the following:. * Find a function with a non-const pointer or reference parameter. * Find the definition of that function. * Pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:15291,refactor,refactor,15291,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactor']
Modifiability,"; ; Added interface to simplify the creation of the performance; tree: two new methods TProof::SetPerfTree(""<file>"") and; TProof::SavePerfTree(""<file>"", ""<queryref>"") allow set; and/or save the information to a given file path. The perfomance tree; settim=ngs are diabled after each query, so they need to be enabled; each time.; Add support for a command line test run of 'proofserv'; this is; useful to test that the environment is setup correctly.; In TProofBench::DrawCPU, add possibility to extract of a couple; of numbers supposed to give an idea of the computing specs of the; cluster being benchmarked. These are the maximum rate for the standard; CPU intensive task and the normalized, per worker, rate. Both are; expressed in RNGPS (RaNdom Generation Per Second).; Add class TProofPerfAnalysis collecting a set of tools to; analyse the performance tree.; Add support for selector-by-object processing in PROOF. The; selector object, created and configured locally by the user, is added; to the input list and recuperated from there on the worker machines for; processing. Any input list setting in the selector itself is not; streamed but temporarly moved to then standard input list, so that user; can use the selector input list as container of processing information; if they find convenient to do so. Process(...) methods with the file; name argument replaced by 'TSelector *' have  introduced where; relevant (TProof, TProofPlayer and their derivatives, TDSet).  ; Add the possibility to force submerging at node level, i.e. one; submerger per physical machine. In this way the network traffic can be; minimized, for example when merging large output files. The new feature; is enabled by setting the Int_t parameter 'PROOF_MergersByHost' (or the; directive 'Proof.MergersByHost') to a non-null value.; Simplify enabling of basic feedback. In TProof::Process, add; support for switches ""fb=name1,name2,name3,... "" or; ""feedback=name1,name2,name3,... "" in the option field. This enables;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:990,config,configured,990,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,1,['config'],['configured']
Modifiability,"; ; CHECK: notw	[[REGISTER:%[a-z]+]]; ; CHECK: andw	{{.*}}[[REGISTER]]. The first check line matches a regex ``%[a-z]+`` and captures it into the; string variable ``REGISTER``. The second line verifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operands of ``op`` to be the same register,; and don't care exactly which register it is. If ``--enable-var-scope`` is in effect, variables with names that; start with ``$`` are considered to be global. All others variables are; local. All local variables get undefined at the beginning of each; CHECK-LABEL block. Global variables are not affected by CHECK-LABEL.; This makes it easier to ensure that individual tests are not affected; by variables set in preceding tests. FileCheck Numeric Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. :program:`FileCheck` also supports numeric substitution blocks that allow; defining numeric variables and checking for numeric values that satisfy a; numeric expression constraint based on those variables via a numeric; substitution. This allows ``CHECK:`` directives to verify a numeric relation; between two numbers, such as the need for consecutive registers to be used. The syntax to capture a numeric value is; ``[[#%<fmtspec>,<NUMVAR>:]]`` where:. * ``%<fmtspec>,`` is an optional format specifier to indicate what number; format to match and the minimum number of digits to expect. * ``<",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:27513,variab,variables,27513,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variables']
Modifiability,"; === TextInput. = Purpose. Read and edit text lines, and write what was read. This library is a simplistic alternative to readline / editline. It offers; less functionality but it has a more liberal license (see LICENSE.TXT in; the topmost) directory, it has no external dependencies, and it works on; all platforms that I tested:; - Linux; - Windows (probably >= 2000); - MacOS; - Solaris; Adding other platforms is trivial. = Internal Design. TextInput.h contains the main interface. The reading can be extended by; adding classes that derive from Reader; the displaying can be extended; by deriving from Display. There can be multiple readers and multiple displays. All displays are; equal, all readers are equal. All displays show the input of all; readers. The terminal / console implementations for readers and; displays are provided. Both readers and displays only attach while; textinput is acively reading input. As soon as the input is done (enter; was pressed), they detach from the terminal, allowing the application; to take control of the terminal, and even to crash without leaving the; terminal in a non-default state. The editor provides basic emacs-like keybinding, as known from e.g.; bash. It supports ^O, ^R (for now without regex), and most word-centric; editing commands. See KeyBinding for details. KeyBinding maps the InputData read from the Reader to Editor::Commands.; The Editor performs the requested editing actions, and the Displays; are informed about the changes. TextInput gives access to the read; state (""are we done?"") and the input. = Why no [N]Curses?. Because of platform independence (well, one could still have a; TerminalDisplayCurses) and because nowadays this is actually rarely; needed. Sure, it's the ""right"" way of interfacing terminals. But the; number of terminal types in the wild has siginifantly decreased, so; just hard-coding escape sequences became a viable alternative. = References. These pages helped when writing libtextinput:; http://tldp.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/doc/textinput.txt:506,extend,extended,506,core/textinput/src/textinput/doc/textinput.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/doc/textinput.txt,2,['extend'],['extended']
Modifiability,"; > **KVM**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.hdd.gz); >; > - [CernVM 2.7.1 batch 64-bit for; > **Xen**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.ext3.gz); >; > Images are gzipped. In most cases you'll need to gunzip them before; > registering to your image repository. ### Create VM configuration profiles. CernVM images are base images supporting boot-time customization via; configuration profiles called ""contexts"". Context creation can be; performed through the [CernVM Online](https://cernvm-online.cern.ch/); website. The site is immediately accessible if you have a CERN account. Go to your [CernVM Online; Dashboard](https://cernvm-online.cern.ch/dashboard), click on the; **Create new context...** dropdown and select **Virtual Analysis Facility; node**. There's only a few parameters to configure. Context name; : A name for your context (such as *VAF Master for ATLAS*). Any name; will work. Role; : Use this to configure either a *master* or a *slave*. VAF master (only available when configuring a slave); : IP address or FQDN of the Virtual Analysis Facility master. Auth method; : Choose between *ALICE LDAP* (useful only for ALICE users) or *Pool; accounts* (good for authenticating all the other Grid users). Num. pool accounts (only available when using pool accounts auth); : Number of pool accounts to create. Proxy for CVMFS; : An URL specifying the proxy server for CernVM-FS, such as; `http://ca-proxy.cern.ch:3128/`. If you leave it empty, proxy will; be automatically discovered. HTCondor shared secret; : VMs part of the same cluster should have the same value of this; field. It is used to mutually authenticate VMs and it is used like a; password. Context password; : Current profile will be saved on the [CernVM Online; repository](http://cernvm-online.cern.ch/). If you don't want the; information there to be publicly available to other users, type in; a value for protecting the context with an encryp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:2271,config,configure,2271,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['config'],['configure']
Modifiability,"; A new tutorial rs801_HypoTestInverter.C has been added in the tutorials/roostats directory to show the usage of this class. New class BayesianCalculator. New class for calculating Bayesian interval using numerical integration. It implements the IntervalCalculator interface and returns as result a SimpleInterval. . The BayesianCalculator::GetInterval() method returns a SimpleInterval which contains the lower and upper value of the bayesian interval obtained from the posterior probability for the given confidence level.; The class return also the posterior pdf (BayesianCalculator::GetPosteriorPdf()) obtained from integrating (marginalizing) on the nuisance parameters.; It works currently only for one-dimensional problems by relying on RooFit for performing analytical or numerical integration.; A plot of the posterior and the desired interval can be obtained using BayesianCalculator::GetPosteriorPlot().; A new tutorial rs701_BayesianCalculator.C has been added in the tutorials/roostats directory to show the usage of this class. MCMCCalculator. Add possibility to specify the prior function in the constructor of the class to have a signature similar to the BayesianCalculator class. When no prior is specified it is assumed is part of the global model (pdf) passed to the class. Improvements and Bug fixes. Various improvements and fixes have been applied also to all the calculator classes. Internally now the RooArgSet objects are used by value instead of a pointer.; All the calculator have a consistent way for being constructed, either by passing pdf pointers and the set defining the parameters or by passing a reference to a ModelConfig class.; The result classes are now more consistent and have similar constructors. In addition to a default constructor, all of them can be constructed by passing first a name and then all the quantities (objects or values) needed for the specific result type. The title can eventually be set using the SetTitle method inherited from TNamed. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:17770,inherit,inherited,17770,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['inherit'],['inherited']
Modifiability,; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions; Yes. 119; CD1; Object lifetime and aggregate initialization; N/A. 120; TC1; Nonexistent non-terminal qualified-name; N/A. 121; TC1; Dependent type names with non-dependent nested-name-specifiers; Yes. 122; CD1; template-ids as unqualified-ids; Yes. 123; TC1; Bad cross-reference; N/A. 124; CD1; Lifetime of temporaries in default initialization of class arrays; Duplicate of 201. 125; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:9249,variab,variables,9249,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"; DW_OP_deref_type 64, %__uint_64;; DW_OP_LLVM_select_bit_piece 64, 64;; ];; ];; DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc, DIExpression[; DW_OP_call_ref %__divergent_lane_pc_1_else;; DW_OP_call_ref %__active_lane_pc;; ];; f;; EXEC = %1;; $lex_1_end:; DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc DIExpression[; DW_OP_call_ref %__divergent_lane_pc;; DW_OP_call_ref %__active_lane_pc;; ];; g;; $lex_end:. The DWARF procedure ``%__active_lane_pc`` is used to update the lane pc elements; that are active, with the current program location. Artificial variables %__lex_1_save_exec and %__lex_1_1_save_exec are created for; the execution masks saved on entry to a region. Using the ``DBG_VALUE`` pseudo; instruction, location list entries will be created that describe where the; artificial variables are allocated at any given program location. The compiler; may allocate them to registers or spill them to memory. The DWARF procedures for each region use the values of the saved execution mask; artificial variables to only update the lanes that are active on entry to the; region. All other lanes retain the value of the enclosing region where they were; last active. If they were not active on entry to the subprogram, then will have; the undefined location description. Other structured control flow regions can be handled similarly. For example,; loops would set the divergent program location for the region at the end of the; loop. Any lanes active will be in the loop, and any lanes not active must have; exited the loop. An ``IF/THEN/ELSEIF/ELSEIF/...`` region can be treated as a nest of; ``IF/THEN/ELSE`` regions. The DWARF procedures can use the active lane artificial variable described in; :ref:`amdgpu-dwarf-amdgpu-dw-at-llvm-active-lane` rather than the actual; ``EXEC`` mask in order to support whole or quad wavefront mode. .. _amdgpu-dwarf-amdgpu-dw-at-llvm-active-lane:. ``DW_AT_LLVM_active_lane``; ~~~~~~~~~~~~~~~~~~~~~~~~~~. The ``DW_AT_LLVM_active_lane`` attribute on a subpr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:108357,variab,variables,108357,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variables']
Modifiability,; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Un,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:115884,variab,variable,115884,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,; Initializers for empty-class aggregrate members; Duplicate of 413. 492; CD1; typeid constness inconsistent with example; Unknown. 493; CD2; Type deduction from a bool context; Duplicate of 976. 494; CD1; Problems with the resolution of issue 45; Duplicate of 372. 495; CD2; Overload resolution with template and non-template conversion functions; Clang 3.5. 496; CD3; Is a volatile-qualified type really a POD?; Superseded by 2094. 497; CD1; Missing required initialization in example; Superseded by 253. 498; open; Storage class specifiers in definitions of class members; Not resolved. 499; CD2; Throwing an array of unknown size; Yes. 500; CD1; Access in base-specifiers of friend and nested classes; Duplicate of 372. 501; NAD; Visibility of friend declarations within the befriending class; Yes. 502; C++11; Dependency of nested enumerations and enumerators; Yes. 503; open; Cv-qualified function types in template argument deduction; Not resolved. 504; NAD; Should use of a variable in its own initializer require a diagnostic?; Unknown. 505; CD1; Conditionally-supported behavior for unknown character escapes; Yes. 506; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis; Yes. 507; dup; Ambiguity assigning class object to built-in type; Duplicate of 260. 508; C++11; Non-constructed value-initialized objects; N/A. 509; CD1; Dead code in the specification of default initialization; N/A. 510; CD1; Default initialization of POD classes?; N/A. 511; open; POD-structs with template assignment operators; Not resolved. 512; NAD; Union members with user-declared non-default constructors; Yes. 513; CD1; Non-class “most-derived” objects; N/A. 514; CD1; Is the initializer for a namespace member in the scope of the namespace?; Yes. 515; CD1; Non-dependent references to base class members; Superseded by 1017. 516; CD1; Use of signed in bit-field declarations; N/A. 517; CD1; Partial specialization following explicit instantiation; No. 518; CD1; Trailing comma follo,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:34494,variab,variable,34494,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"; Inter-Procedural Optimization. Refers to any variety of code optimization; that occurs between procedures, functions or compilation units (modules). **ISel**; Instruction Selection. L; -. **LCSSA**; Loop-Closed Static Single Assignment Form. **LGTM**; ""Looks Good To Me"". In a review thread, this indicates that the; reviewer thinks that the patch is okay to commit. **LICM**; Loop Invariant Code Motion. **LSDA**; Language Specific Data Area. C++ ""zero cost"" unwinding is built on top a; generic unwinding mechanism. As the unwinder walks each frame, it calls; a ""personality"" function to do language specific analysis. Each function's; FDE points to an optional LSDA which is passed to the personality function.; For C++, the LSDA contain info about the type and location of catch; statements in that function. **Load-VN**; Load Value Numbering. **LTO**; Link-Time Optimization. M; -. **MC**; Machine Code. N; -; .. _nfc:. **NFC**; ""No functional change"". Used in a commit message to indicate that a patch; is a pure refactoring/cleanup.; Usually used in the first line, so it is visible without opening the; actual commit email. O; -; .. _object pointer:; .. _object pointers:. **Object Pointer**; A pointer to an object such that the garbage collector is able to trace; references contained within the object. This term is used in opposition to; `derived pointer`_. P; -. **PGO**; Profile-Guided Optimization. **PR**; Problem report. A bug filed on `the LLVM Bug Tracking System; <https://bugs.llvm.org/enter_bug.cgi>`_. **PRE**; Partial Redundancy Elimination. R; -. **RAUW**. Replace All Uses With. The functions ``User::replaceUsesOfWith()``,; ``Value::replaceAllUsesWith()``, and; ``Constant::replaceUsesOfWithOnConstant()`` implement the replacement of one; Value with another by iterating over its def/use chain and fixing up all of; the pointers to point to the new value. See; also `def/use chains <ProgrammersManual.html#iterating-over-def-use-use-def-chains>`_. **Reassociation**; Rea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:5807,refactor,refactoring,5807,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,1,['refactor'],['refactoring']
Modifiability,"; JSROOT.draw(document.getElementsByTagName(""div"")[0], obj, ""hist"");; Normally unique identifier was used before, which is not required any longer.; Of course, old functionality with element identifier will work as well.; 2. TreePlayer can also be used for trees, which not yet read from the file.; Requires appropriate changes in TRootSniffer class.; 3. Fix error in I/O with members like: `Double_t *fArr; //[fN]`; 4. Introduce JSROOT.OpenFile function. It loads I/O functionality automatically,; therefore can be used directly after loading JSRootCore.js script; 5. Same is done with JSROOT.draw function. It is defined in the JSRootCore.js; and can be used directly. Makes usage of JSROOT easier; 6. Introduce JSRootPainter.more.js script, where painters for auxiliary classes; will be implemented.; 7. Implement painter for TEllipse, TLine, TArrow classes; 8. Fix several problems with markers drawing; implement plus, asterisk, mult symbols.; 9. Implement custom layout, which allows to configure user-defined layout for displayed objects; 10. Fix errors with scaling of axis labels.; 11. Support also Y axis with custom labels like: http://jsroot.gsi.de/dev/?nobrowser&file=../files/atlas.root&item=LEDShapeHeightCorr_Gain0;1&opt=col. ## Changes in 3.7; 1. Support of X axis with custom labels like: http://jsroot.gsi.de/dev/?nobrowser&json=../files/hist_xlabels.json; 2. Extend functionality of JSROOT.addDrawFunc() function. One could register type-specific; `make_request` and `after_request` functions; `icon`, `prereq`, `script`, `monitor` properties.; This let add more custom elements to the generic gui, implemented with JSROOT.HierarchyPainter; 3. Provide full support of require.js. One could load now JSRootCore.js script like:. <script type=""text/javascript"" src=""require.js"" data-main=""scripts/JSRootCore.js""></script>. After this several modules are defined and can be used with syntax like:. require(['JSRootPainter'], function(jsroot) { /*any user code*/});. Also inside JSROOT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:62783,config,configure,62783,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configure']
Modifiability,"; KF5::Config appears in Python via ""import KF5.Config"".; * (TBD) Load Pythonizations. Both of these need/can use the output of the; :ref:`cppyy-generator <cppyy-generator>` (included in the package) as well as; other runtime support included in ``cppyy``. CMake usage; -----------. The CMake usage is via two modules:. * FindLibClang.cmake provides some bootstrap support needed to locate clang.; This is provided mostly as a temporary measure; hopefully upstream support; will allow this to be eliminated in due course.; * FindCppyy.cmake provides the interface described further here. Details of the usage of these modules is within the modules themselves, but; here is a summary of the usage. ``FindLibClang.cmake`` sets the following; variables:. ::. LibClang_FOUND - True if libclang is found.; LibClang_LIBRARY - Clang library to link against.; LibClang_VERSION - Version number as a string (e.g. ""3.9"").; LibClang_PYTHON_EXECUTABLE - Compatible python version. ``FindCppyy.cmake`` sets the following variables:. ::. Cppyy_FOUND - set to true if Cppyy is found; Cppyy_DIR - the directory where Cppyy is installed; Cppyy_EXECUTABLE - the path to the Cppyy executable; Cppyy_INCLUDE_DIRS - Where to find the Cppyy header files.; Cppyy_VERSION - the version number of the Cppyy backend. and also defines the following functions::. cppyy_add_bindings - Generate a set of bindings from a set of header files.; cppyy_find_pips - Return a list of available pip programs. cppyy_add_bindings; ^^^^^^^^^^^^^^^^^^. Generate a set of bindings from a set of header files. Somewhat like CMake's; add_library(), the output is a compiler target. In addition ancillary files; are also generated to allow a complete set of bindings to be compiled,; packaged and installed::. cppyy_add_bindings(; pkg; pkg_version; author; author_email; [URL url]; [LICENSE license]; [LANGUAGE_STANDARD std]; [LINKDEFS linkdef...]; [IMPORTS pcm...]; [GENERATE_OPTIONS option...]; [COMPILE_OPTIONS option...]; [INCLUDE_DIRS dir...",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:3092,variab,variables,3092,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['variab'],['variables']
Modifiability,"; Reference version: TMVA-v-unknown. TMVA-version @ ROOT. Reference for configuration options defined in the option string of each MVA method booking, and for the definition of data sets used for training and testing (Factory). Table fields:. Option:; The option identifier in the option string (given, e.g., in ""factory->BookMethod(...)"" call). Array:; Can the option be set individually for each input variable via the ""[i]"" tag, where ""i"" is the ith variable?. Default value:; Value used if option is not explicitly set in the configuration option string. Predefined values:; Options can be categories of predefined values among which the user must choose. Description:; Info about the option. Colour codes:. Greenish rows:; Options shared by all MVA methods (through common base class). Bluish rows:; Specific MVA options. Yellowish rows:; Configuration options for minimiser (fitter) classes. Redish rows:; Options for other configurable classes. Available MVA methods (1st row), minimisation tools (2nd row), and other configurables (3rd row):. [MVA::HMatrix] [MVA::Fisher] [MVA::PDERS] [MVA::FDA] [MVA::LD] [MVA::SVM] [MVA::CFMlpANN] [MVA::KNN] [MVA::BDT] [MVA::Boost] [MVA::RuleFit] [MVA::Likelihood] [MVA::MLP] [MVA::Cuts] [MVA::PDEFoam] [MVA::TMlpANN]. [Fitter_SA] [Fitter_MC] [Fitter_Minuit] [Fitter_GA]. [DataSetFactory] [PDF] [Factory]. Configuration options for MVA method :. Configuration options reference for MVA method: HMatrix. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:1087,config,configurables,1087,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['config'],['configurables']
Modifiability,"; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; ```; #### ROOT::Math::GaussLegendreIntegrator. This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <=",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:54763,adapt,adaptive,54763,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['adapt'],['adaptive']
Modifiability,"; TProof::Open.; Add the possibility to save the perfomance information shown; by the dialog into a small ntuple included in the output list. The; ntuple contains 5 floats (processing time, number of active workers,; event rate, MBytes read, number of effective sessions on the cluster); and it is filled each time the number of active workers changes or at; max 100 regular intervals at least 5 secs apart; in this way the ntuple; has at most O(100 entries + number of workers). To enable the saving of; the ntuple execute the following:;         proof->SetParameter(""PROOF_SaveProgressPerf"", ""yes"");; before running the query. The ntuple is called 'PROOF_ProgressPerfNtuple'.; Add support for worker autodiscovery in PROOF using the; Avahi/Bonjour technology. The new functionality is supported on Mac; (MacOsX >= 10.4; no need of additional installs) and linux (requires; the Avahi framework, available by default on most of the; distributions). To use this functionality (instead-of or in-addition-to; the the static worker configuration via proof.conf or xpd.worker) the; new directive 'xpd.bonjour' must be used. Improvements. Improve support for valgrind runs in PROOF-Lite; Add the possibility to add files to a dataset. This is; achieved with a new option 'U' (for update) to RegisterDataSet.; Add; methof TProof::GetStatistics to allow the client to retrieve the; correct values of fBytesRead, fRealTime and fCpuTime at any moment;; this will be used to setup a sort of ROOTmarks in stressProof .; Several improvements in the test program 'stressProof'; and in the tutorials under 'tutorials/proof'; Avoid; contacting the DNS when initializing TProofMgr as base class of; TProofMgrLite: it is not needed and it may introduce long startup; delays.; Make TProof::LogViewer("""") start the viewer for; a Lite session, in parallel to whats happen for TProof::Open("""").; Several; improvements in the handling of wild cards in the dataset manager; for; example, issuing a GetDataSet(...) on a datas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:4026,config,configuration,4026,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['config'],['configuration']
Modifiability,"; The advantage of using open source analyzer builds (provided on this website); is that they are often newer than the analyzer provided with Xcode, and thus can; contain bug fixes, new checks, or simply better analysis.; On the other hand, new checks can be experimental, with results of variable; quality. Users are encouraged to file bug reports; (for any version of the analyzer) where they encounter false positives or other; issues.; set-xcode-analyzer; Starting with analyzer build checker-234, analyzer builds contain a command; line utility called set-xcode-analyzer that allows users to change what; copy of clang that Xcode uses for analysis:. $ set-xcode-analyzer -h; Usage: set-xcode-analyzer [options]. Options:; -h, --help show this help message and exit; --use-checker-build=PATH; Use the Clang located at the provided absolute path,; e.g. /Users/foo/checker-1; --use-xcode-clang Use the Clang bundled with Xcode. Operationally, set-xcode-analyzer edits Xcode's configuration files; to point it to use the version of clang you specify for static; analysis. Within this model it provides you two basic modes:. --use-xcode-clang: Switch Xcode (back) to using the clang that came bundled with it for static analysis.; --use-checker-build: Switch Xcode to using the clang provided by the specified analyzer build. Things to keep in mind. You should quit Xcode prior to running set-xcode-analyzer. You will need to run set-xcode-analyzer under; sudo in order to have write privileges to modify the Xcode; configuration files. Examples; Example 1: Telling Xcode to use checker-235:. $ pwd; /tmp; $ tar xjf checker-235.tar.bz2; $ sudo checker-235/set-xcode-analyzer --use-checker-build=/tmp/checker-235. Note that you typically won't install an analyzer build in /tmp, but; the point of this example is that set-xcode-analyzer just wants a full; path to an untarred analyzer build.; Example 2: Telling Xcode to use a very specific version of clang:. $ sudo set-xcode-analyzer --use-checker-bu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/xcode.html:2265,config,configuration,2265,interpreter/llvm-project/clang/www/analyzer/xcode.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/xcode.html,1,['config'],['configuration']
Modifiability,; Unknown. 1336; CD3; Definition of “converting constructor”; Unknown. 1337; dup; Partial ordering and non-deduced parameters; Unknown. 1338; CD4; Aliasing and allocation functions; Unknown. 1339; NAD; Parenthesized braced-init-list and arrays; Unknown. 1340; CD3; Complete type in member pointer expressions; Unknown. 1341; NAD; Bit-field initializers; Superseded by P0683R1. 1342; CD6; Order of initialization with multiple declarators; Unknown. 1343; C++17; Sequencing of non-class initialization; Unknown. 1344; C++14; Adding new special member functions to a class via default arguments; Unknown. 1345; CD3; Initialization of anonymous union class members; Unknown. 1346; CD3; expression-list initializers and the auto specifier; Clang 3.5. 1347; CD3; Consistency of auto in multiple-declarator declarations; Clang 3.1. 1348; drafting; Use of auto in a trailing-return-type; Not resolved. 1349; dup; Consistency of alias template redeclarations; Unknown. 1350; CD3; Incorrect exception specification for inherited constructors; Clang 3.5. 1351; CD4; Problems with implicitly-declared exception-specifications; Unknown. 1352; CD3; Inconsistent class scope and completeness rules; Unknown. 1353; DRWP; Array and variant members and deleted special member functions; Unknown. 1354; CD3; Destructor exceptions for temporaries in noexcept expressions; Unknown. 1355; CD3; Aggregates and “user-provided” constructors; Unknown. 1356; CD4; Exception specifications of copy assignment operators with virtual bases; Unknown. 1357; CD3; brace-or-equal-initializers for function and typedef members; Unknown. 1358; CD3; Unintentionally ill-formed constexpr function template instances; Clang 3.1. 1359; CD3; constexpr union constructors; Clang 3.5. 1360; CD6; constexpr defaulted default constructors; Unknown. 1361; CD3; Requirement on brace-or-equal-initializers of literal types; Unknown. 1362; CD3; Complete type required for implicit conversion to T&; Unknown. 1363; CD3; Triviality vs multiple default,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:90312,inherit,inherited,90312,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inherit'],['inherited']
Modifiability,"; Unknown. 2756; review; Completion of initialization by delegating constructor; Not resolved. 2757; review; Deleting or deallocating storage of an object during its construction; Not resolved. 2758; DR; What is ""access and ambiguity control""?; Unknown. 2759; DR; [[no_unique_address] and common initial sequence; Unknown. 2760; DR; Defaulted constructor that is an immediate function; Unknown. 2761; DR; Implicitly invoking the deleted destructor of an anonymous union member; Unknown. 2762; DR; Type of implicit object parameter; Unknown. 2763; DR; Ignorability of [[noreturn]] during constant evaluation; Unknown. 2764; DR; Use of placeholders affecting name mangling; Unknown. 2765; open; Address comparisons between potentially non-unique objects during constant evaluation; Not resolved. 2766; open; Repeated evaluation of a string-literal may yield different objects; Not resolved. 2767; open; Non-defining declarations of anonymous unions; Not resolved. 2768; DR; Assignment to enumeration variable with a braced-init-list; Unknown. 2769; open; Substitution into template parameters and default template arguments should be interleaved; Not resolved. 2770; open; Trailing requires-clause can refer to function parameters before they are substituted into; Not resolved. 2771; open; Transformation for unqualified-ids in address operator; Not resolved. 2772; DR; Missing Annex C entry for linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:191705,variab,variable,191705,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"; Users interact with and transfer block objects using :arc-term:`block; pointers`, which are represented like a normal pointer. A block may capture; values from local variables; when this occurs, memory must be dynamically; allocated. The initial allocation is done on the stack, but the runtime; provides a ``Block_copy`` function which, given a block pointer, either copies; the underlying block object to the heap, setting its reference count to 1 and; returning the new block pointer, or (if the block object is already on the; heap) increases its reference count by 1. The paired function is; ``Block_release``, which decreases the reference count by 1 and destroys the; object if the count reaches zero and is on the heap. Objective-C is a set of language extensions, significant enough to be; considered a different language. It is a strict superset of C. The extensions; can also be imposed on C++, producing a language called Objective-C++. The; primary feature is a single-inheritance object system; we briefly describe the; modern dialect. Objective-C defines a new type kind, collectively called the :arc-term:`object; pointer types`. This kind has two notable builtin members, ``id`` and; ``Class``; ``id`` is the final supertype of all object pointers. The validity; of conversions between object pointer types is not checked at runtime. Users; may define :arc-term:`classes`; each class is a type, and the pointer to that; type is an object pointer type. A class may have a superclass; its pointer; type is a subtype of its superclass's pointer type. A class has a set of; :arc-term:`ivars`, fields which appear on all instances of that class. For; every class *T* there's an associated metaclass; it has no fields, its; superclass is the metaclass of *T*'s superclass, and its metaclass is a global; class. Every class has a global object whose class is the class's metaclass;; metaclasses have no associated type, so pointers to this object have type; ``Class``. A class declaration ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:3391,inherit,inheritance,3391,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['inherit'],['inheritance']
Modifiability,"; Yes. 61; NAD; Address of static member function ""&p->f""; Clang 3.4. 62; CD1; Unnamed members of classes used as type parameters; Clang 2.9. 63; CD1; Class instantiation from pointer conversion to void*, null and self; Yes. 64; TC1; Partial ordering to disambiguate explicit specialization; Yes. 65; TC1; Typo in default argument example; N/A. 66; NAD; Visibility of default args vs overloads added after using-declaration; No. 67; TC1; Evaluation of left side of object-expression; N/A. 68; TC1; Grammar does not allow ""friend class A<int>;""; Clang 2.8. 69; TC1; Storage class specifiers on template declarations; Clang 9. 70; CD1; Is an array bound a nondeduced context?; Yes. 71; NAD; Incorrect cross reference; N/A. 72; dup; Linkage and storage class specifiers for templates; Duplicate of 69. 73; TC1; Pointer equality; Superseded by 1652. 74; TC1; Enumeration value in direct-new-declarator; Yes. 75; TC1; In-class initialized members must be const; Yes. 76; TC1; Are const volatile variables considered ""constant expressions""?; Yes. 77; CD1; The definition of friend does not allow nested classes to be friends; Yes. 78; CD1; Section 8.5 paragraph 9 should state it only applies to non-static objects; Superseded by ????. 79; dup; Alignment and placement new; N/A. 80; TC1; Class members with same name as class; Clang 2.9. 81; NAD; Null pointers and C compatibility; N/A. 82; dup; Definition of ""using"" a constant expression; Duplicate of 48. 83; TC1; Overloading and deprecated conversion of string literal; Yes. 84; TC1; Overloading and conversion loophole used by auto_ptr; Yes. 85; TC1; Redeclaration of member class; Clang 3.4. 86; CD1; Lifetime of temporaries in query expressions; Duplicate of 446. 87; CD1; Exception specifications on function parameters; No. 88; NAD; Specialization of member constant templates; Clang 2.8. 89; TC1; Object lifetime does not account for reference rebinding; N/A. 90; TC1; Should the enclosing class be an ""associated class"" too?; Yes. 91; NAD; A unio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:5664,variab,variables,5664,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83624,config,configuration,83624,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. One important issue that the code generator needs to be aware of is the presence; of fixed registers. In particular, there are often places in the instruction; stream where the register allocator *must* arrange for a particular value to be; in a particular register. This can occur due to limitations of the instruction; set (e.g., the X86 can only do a 32-bit divide with the ``EAX``/``EDX``; registers), or external factors like calling conventions. In any case, the; instruction selector should emit code that copies a virtual register into or out; of a physical register when needed. For example, consider this simple LLVM example:. .. code-block:: llvm. define i32 @test(i32 %X, i32 %Y) {; %Z = sdiv i32 %X, %Y; ret i32 %Z; }. The X86 instruction selector might produce this machine code for the ``div`` and; ``ret``:. .. code-block:: text. ;; Start of div; %EAX = mov %reg1024 ;; Copy X (in reg1024) into EAX; %reg1027 = sar %reg1024, 31; %EDX = mov %reg1027 ;; Sign extend X into EDX; idiv %reg1025 ;; Divide by Y (in reg1025); %reg1026 = mov %EAX ;; Read the result (Z) out of EAX. ;; Start of ret; %EAX = mov %reg1026 ;; 32-bit return value goes in EAX; ret. By the end of code generation, the register allocator would coalesce the; registers and delete the resultant identity moves producing the following; code:. .. code-block:: text. ;; X is in EAX, Y is in ECX; mov %EAX, %EDX; sar %EDX, 31; idiv %ECX; ret. This approach is extremely general (if it can handle the X86 architecture, it; can handle anything!) and allows all of the target specific knowledge about the; instruction stream to be isolated in the instruction selector. Note that; physical registers should have a short lifetime for good code generation, and; all physical registers are assumed dead on entry to and exit from basic blocks; (before register allocation). Thus, if you need a value to be live across basic; block boundaries, it *must* live in a virtual register. Call-clobbered r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:20227,extend,extend,20227,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['extend'],['extend']
Modifiability,"; `Event` also has two pointers, one to a **`TClonesArray`** of tracks and; one to a histogram. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; ```. ### The EventHeader Class. The `EventHeader` class (also defined in `Event.h`) does not inherit; from **`TObject`**. Beginning with ROOT 3.0, an object can be placed on; a branch even though it does not inherit from **`TObject`**. In previous; releases branches were restricted to objects inheriting from the; **`TObject`**. However, it has always been possible to write a class not; inheriting from **`TObject`** to a tree by encapsulating it in a; **`TObject`** descending class as is the case in `EventHeader` and; `Event`. ``` {.cpp}; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; ```. ### The Track Class. The `Track` class descends from **`TObject`** since tracks are in a; **`TClonesArray`** (i.e. a ROOT collection class) and contains a; selection of basic types and an array of vertices. Its **`TObject`**; inheritance enables `Track` to be in a collection and in `Event` is a; **`TClonesArray`** of `Tracks`. ``` {.cpp}; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:60259,inherit,inherit,60259,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['inherit'],['inherit']
Modifiability,"; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``sanitize_memtag``; This attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; suppression of certain optimisations, like GlobalMerge, as well as ensuring; extra directives are emitted in the assembly and extra bits of metadata are; placed in the object file so that the linker can ensure the accesses are; protected by MTE. This attribute is added by clang when; `-fsanitize=memtag-globals` is provided, as long as the global is not marked; with `__attribute__((no_sanitize(""memtag"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file. The AArch64 Globals Tagging pass may remove; this attribute when it's not possible to tag the global (e.g. it's a TLS; variable).; ``sanitize_address_dyninit``; This attribute indicates that the global variable, when instrumented with; AddressSanitizer, should be checked for ODR violations. This attribute is; applied to global variables that are dynamically initialized according to; C++ rules. .. _opbundles:. Operand Bundles; ---------------. Operand bundles are tagged sets of SSA values that can be associated; with certain LLVM instructions (currently only ``call`` s and; ``invoke`` s). In a way they are like metadata, but dropping them is; incorrect and will change program semantics. Syntax::. operand bundle set ::= '[' operand bundle (, operand bundle )* ']'; operand bundle ::= tag '(' [ bundle operand ] (, bundle operand )* ')'; bundle operand ::= SSA value; tag ::= string constant. Operand bundles are **not** part of a function's signature, and a; given function may be called from multiple places with different kinds; of operand bundles. This reflects the fact that the operand bundles; are conceptually a part of the ``call`` (or ``invoke``), not the; callee being dispatched to. Operand ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:116672,variab,variable,116672,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"; ``CHECK:`` directives only accept lines corresponding to the body of the; ``@C_ctor_base`` function, even if the patterns match lines found later in; the file. Furthermore, if one of these three ``CHECK:`` directives fail,; FileCheck will recover by continuing to the next block, allowing multiple test; failures to be detected in a single invocation. There is no requirement that ``CHECK-LABEL:`` directives contain strings that; correspond to actual syntactic labels in a source or output language: they must; simply uniquely match a single line in the file being verified. ``CHECK-LABEL:`` directives cannot contain variable definitions or uses. Directive modifiers; ~~~~~~~~~~~~~~~~~~~. A directive modifier can be append to a directive by following the directive; with ``{<modifier>}`` where the only supported value for ``<modifier>`` is; ``LITERAL``. The ``LITERAL`` directive modifier can be used to perform a literal match. The; modifier results in the directive not recognizing any syntax to perform regex; matching, variable capture or any substitutions. This is useful when the text; to match would require excessive escaping otherwise. For example, the; following will perform literal matches rather than considering these as; regular expressions:. .. code-block:: text. Input: [[[10, 20]], [[30, 40]]]; Output %r10: [[10, 20]]; Output %r10: [[30, 40]]. ; CHECK{LITERAL}: [[[10, 20]], [[30, 40]]]; ; CHECK-DAG{LITERAL}: [[30, 40]]; ; CHECK-DAG{LITERAL}: [[10, 20]]. FileCheck Regex Matching Syntax; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. All FileCheck directives take a pattern to match.; For most uses of FileCheck, fixed string matching is perfectly sufficient. For; some things, a more flexible form of matching is desired. To support this,; FileCheck allows you to specify regular expressions in matching strings,; surrounded by double braces: ``{{yourregex}}``. FileCheck implements a POSIX; regular expression matcher; it supports Extended POSIX regular expressions; (ERE). Because we w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:24095,variab,variable,24095,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability,"; ```. Example:. ``` {.cpp}; // Writing to a file geometry definition ending with:; root[] gGeoManager->CloseGeometry();; // geometry is ready; root[] gGeoManager->Export(""MyGeom.root"");; // file MyGeom.root produced; root[] gGeoManager->Export(""MyGeom.C"");; // C++ macro MyGeom.C produced; root[] gGeoManager->Export(""MyGeom.gdml"");; // GDML file MyGeom.gdml produced; root[] myVolume->SaveAs(""MyVolume.C"");; // C++ macro for the branch starting; // with MyVolume; // Reading from a file; root[] gSystem->Load(""libGeom"");; root[] TGeoManager::Import(""MyGeom.root""); // geometry is ready; ```. Note that not all-current information held by the modeller is written on; the file. For instance, the painter and checker objects are not written,; as well as the temporary current navigation properties: current node; path, point or direction. On the other hand, all objects belonging to; the geometrical hierarchy will always be written. The idea is to be able; to retrieve the geometry in a ready state, ignoring what the state; variables that can be always re-initialized. When the code is generated; for a given **`TGeoVolume`** in the geometry, just the branch starting; with that volume will be saved in the file. Executing the generated code; will create a geometry that has `MyVolume` as top volume. In this case,; only the materials/media/matrices used effectively in the `MyVolume`; branch are exported to file. Volumes can be made persistent in the same way the full geometry is.; Exporting is straightforward (module1, 2 are pointers to; **`TGeoVolume`** objects):. ``` {.cpp}; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; ```. Importing will append the volume to the current TGeoManager or will; create one:. ``` {.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:152713,variab,variables,152713,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['variab'],['variables']
Modifiability,"; ```. If you do not specify the second parameter, a file name is; automatically generated for you. If `hbookfile` is of the form; `file.hbook`, then the ROOT file will be called `file.root`. This; utility converts HBOOK histograms into ROOT histograms of the class; **`TH1F`**. HBOOK profile histograms are converted into ROOT profile; histograms (see class **`TProfile`**). HBOOK row-wise and column-wise; ntuples are automatically converted to ROOT Trees. See ""Trees"". Some; HBOOK column-wise ntuples may not be fully converted if the columns; are an array of fixed dimension (e.g. `var[6]`) or if they are a; multi-dimensional array. HBOOK integer identifiers are converted into ROOT named objects by; prefixing the integer identifier with the letter ""`h`"" if the; identifier is a positive integer and by `""h_""` if it is a negative; integer identifier. In case of row-wise or column-wise ntuples, each; column is converted to a branch of a tree. Note that `h2root` is able; to convert HBOOK files containing several levels of sub-directories.; Once you have converted your file, you can look at it and draw; histograms or process ntuples using the ROOT command line. An example; of session is shown below:. ``` {.cpp}; // this connects the file hbookconverted.root; root[] TFile f(""hbookconverted.root"");. // display histogram named h10 (was HBBOK id 10); root[] h10.Draw();. // display column ""var"" from ntuple h30; root[] h30.Draw(""var"");; ```. You can also use the ROOT browser (see **`TBrowser`**) to inspect this; file. The chapter on trees explains how to read a tree. ROOT includes a; function **`TTree`**`::MakeClass` to generate automatically the code; for a skeleton analysis function. See ""Example Analysis"". In case one of the ntuple columns has a variable length (e.g.; `px(ntrack)`), `h.Draw(""px"")` will histogram the `px` column for all; tracks in the same histogram. Use the script quoted above to generate; the skeleton function and create/fill the relevant histogram yourself.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:42524,variab,variable,42524,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['variab'],['variable']
Modifiability,"; ```; grabs all the root files with the path `/path/to/tree/somedir/file.root` (but not `/path/to/tree/file.root` and `/path/to/tree/somedir/anotherdir/file.root`). Another example:; ```; TChain::Add(""/path/to/tree/subdir[0-9]/*.root""); ```; This grabs all the root files in subdirectories that have a name starting with `subdir` and ending with some digit. ### Improved efficiency of TTree friends with indices. `TTreeIndex` and `TChainIndex` classes now implement the `Clone` method such that it does not use the ROOT I/O to clone the; index but just does a copy in memory. Notably, this improves processing efficiency for RDataFrame in multithreaded; execution since the same index must be copied over to all the threads and attached to the current tree for proper; event matching. ## RNTuple; ROOT's experimental successor of TTree has seen a number of updates since the last release. Specifically, 6.32 includes the following changes:. - A major refactoring of the interface, improving consistency across different parts and improving overall robustness. **Note that this is a breaking change with regard to 6.30!**; - The on-disk format has been updated to release candidate 2. **It will not be possible to read RNTuples written in the previous format anymore.**; - Support has been added for several new field types: `std::unordered_set<T>`, `std::map<K,V>`, `std::unordered_map<K,V>`; - Support has been added for on-disk half-precision (IEEE 754-2008 16-bit) float fields. This can be enabled through `RField<float>::SetHalfPrecision()`. On reading, values of such fields are represented as regular, 32-bit floats.; - A new `RNTupleInspector` utility class has been added, to provide information about the on-disk metadata of an RNTuple.; - A new `RNTupleParallelWriter` class has been added, providing (initial) support for parallel writing of RNTuples.; - A new static method `RFieldBase::Check()` has been added, which produces a support status report of a type with regards to RNTuple I/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:4446,refactor,refactoring,4446,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['refactor'],['refactoring']
Modifiability,"; against. If absent, both components of the format specifier are inferred from; the matching format of the numeric variable(s) used by the expression; constraint if any, and defaults to ``%u`` if no numeric variable is used,; denoting that the value should be unsigned with no leading zeros. In case of; conflict between format specifiers of several numeric variables, the; conversion specifier becomes mandatory but the precision specifier remains; optional. * ``<constraint>`` is the constraint describing how the value to match must; relate to the value of the numeric expression. The only currently accepted; constraint is ``==`` for an exact match and is the default if; ``<constraint>`` is not provided. No matching constraint must be specified; when the ``<expr>`` is empty. * ``<expr>`` is an expression. An expression is in turn recursively defined; as:. * a numeric operand, or; * an expression followed by an operator and a numeric operand. A numeric operand is a previously defined numeric variable, an integer; literal, or a function. Spaces are accepted before, after and between any of; these elements. Numeric operands have 64-bit precision. Overflow and underflow; are rejected. There is no support for operator precedence, but parentheses; can be used to change the evaluation order. The supported operators are:. * ``+`` - Returns the sum of its two operands.; * ``-`` - Returns the difference of its two operands. The syntax of a function call is ``<name>(<arguments>)`` where:. * ``name`` is a predefined string literal. Accepted values are:. * add - Returns the sum of its two operands.; * div - Returns the quotient of its two operands.; * max - Returns the largest of its two operands.; * min - Returns the smallest of its two operands.; * mul - Returns the product of its two operands.; * sub - Returns the difference of its two operands. * ``<arguments>`` is a comma separated list of expressions. For example:. .. code-block:: llvm. ; CHECK: load r[[#REG:]], [r0]; ; CHECK",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:31158,variab,variable,31158,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability,"; c->account_id = ...;; kGlobalCustomer = c;; }; ```. To identify a candidate function for refactoring, we need to do the following:. * Find a function with a non-const pointer or reference parameter. * Find the definition of that function. * Prove that the function completely overwrites the pointee on all paths; before returning. * Prove that the function reads the pointee only after overwriting it. * Prove that the function does not persist the pointer in a data structure; that is live after the function returns. There are also requirements that all usage sites of the candidate function must; satisfy, for example, that function arguments do not alias, that users are not; taking the address of the function, and so on. Let's consider verifying usage; site conditions to be a separate static analysis problem. ### Lattice design. To analyze the function body we can use a lattice which consists of normal; states and failure states. A normal state describes program points where we are; sure that no behaviors that block the refactoring have occurred. Normal states; keep track of all parameter's member fields that are known to be overwritten on; every path from function entry to the corresponding program point. Failure; states accumulate observed violations (unsafe reads and pointer escapes) that; block the refactoring. In the partial order of the lattice failure states compare greater than normal; states, which guarantees that they ""win"" when joined with normal states. Order; between failure states is determined by inclusion relation on the set of; accumulated violations (lattice's `⩽` is `⊆` on the set of violations). Order; between normal states is determined by reversed inclusion relation on the set of; overwritten parameter's member fields (lattice's `⩽` is `⊇` on the set of; overwritten fields). ![Lattice for data flow analysis that identifies output parameters](DataFlowAnalysisIntroImages/OutputParameterIdentificationLattice.svg). To determine whether a statement rea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:17083,refactor,refactoring,17083,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactoring']
Modifiability,"; call void @llvm.va_start(ptr %ap). ; Read a single integer argument; %tmp = va_arg ptr %ap, i32. ; Demonstrate usage of llvm.va_copy and llvm.va_end; %aq = alloca ptr; call void @llvm.va_copy(ptr %aq, ptr %ap); call void @llvm.va_end(ptr %aq). ; Stop processing of arguments.; call void @llvm.va_end(ptr %ap); ret i32 %tmp; }. declare void @llvm.va_start(ptr); declare void @llvm.va_copy(ptr, ptr); declare void @llvm.va_end(ptr). .. _int_va_start:. '``llvm.va_start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_start(ptr <arglist>). Overview:; """""""""""""""""". The '``llvm.va_start``' intrinsic initializes ``<arglist>`` for; subsequent use by ``va_arg``. Arguments:; """""""""""""""""""". The argument is a pointer to a ``va_list`` element to initialize. Semantics:; """""""""""""""""""". The '``llvm.va_start``' intrinsic works just like the ``va_start`` macro; available in C. In a target-dependent way, it initializes the; ``va_list`` element to which the argument points, so that the next call; to ``va_arg`` will produce the first variable argument passed to the; function. Unlike the C ``va_start`` macro, this intrinsic does not need; to know the last argument of the function as the compiler can figure; that out. '``llvm.va_end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_end(ptr <arglist>). Overview:; """""""""""""""""". The '``llvm.va_end``' intrinsic destroys ``<arglist>``, which has been; initialized previously with ``llvm.va_start`` or ``llvm.va_copy``. Arguments:; """""""""""""""""""". The argument is a pointer to a ``va_list`` to destroy. Semantics:; """""""""""""""""""". The '``llvm.va_end``' intrinsic works just like the ``va_end`` macro; available in C. In a target-dependent way, it destroys the ``va_list``; element to which the argument points. Calls to; :ref:`llvm.va_start <int_va_start>` and; :ref:`llvm.va_copy <int_va_copy>` must be matched exactly with calls to; ``llvm.va_end``. .. _int_va_copy:. '``llvm.va_copy``' Intrinsic; ^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:493696,variab,variable,493696,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"; case 1: { case 1:; bar(); {; } break; bar();; default: { }; plop(); break;; } default:; } {; plop();; }; }. .. _IndentCaseLabels:. **IndentCaseLabels** (``Boolean``) :versionbadge:`clang-format 3.3` :ref:`¶ <IndentCaseLabels>`; Indent case labels one level from the switch statement. When ``false``, use the same indentation level as for the switch; statement. Switch statement body is always indented one level more than; case labels (except the first block following the case label, which; itself indents the code - unless IndentCaseBlocks is enabled). .. code-block:: c++. false: true:; switch (fool) { vs. switch (fool) {; case 1: case 1:; bar(); bar();; break; break;; default: default:; plop(); plop();; } }. .. _IndentExternBlock:. **IndentExternBlock** (``IndentExternBlockStyle``) :versionbadge:`clang-format 11` :ref:`¶ <IndentExternBlock>`; IndentExternBlockStyle is the type of indenting of extern blocks. Possible values:. * ``IEBS_AfterExternBlock`` (in configuration: ``AfterExternBlock``); Backwards compatible with AfterExternBlock's indenting. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: true; extern ""C""; {; void foo();; }. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: false; extern ""C"" {; void foo();; }. * ``IEBS_NoIndent`` (in configuration: ``NoIndent``); Does not indent extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. * ``IEBS_Indent`` (in configuration: ``Indent``); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentSt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:71993,config,configuration,71993,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj - next to src).; . Click the Configure button and in the newly popped up window choose Visual Studio version that you have, then click Finish.; . After the configuring completes many red entries should appear in the Cmake window. You may want to change CMAKE_INSTALL_PREFIX to 'inst' (next to next to src and obj, otherwise the default is Program Files). Click Generate. Note: You may have to do it twice (on 2.8.5) in case after clicking Generate the box is still red.; . Navigate to your 'build' folder and open LLVM.sln using Visual Studio and build it.; . Navigate to CMakePredefined project in Visual Studio and right click INSTALL. Choose Project Only -> Build only INSTALL.; . The executables could be found in your CMAKE_INSTALL_PREFIX/bin/; ; More information about cmake in LLVM and Clang could be found here and here.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:2516,config,configuring,2516,interpreter/cling/www/old/download.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html,1,['config'],['configuring']
Modifiability,; clang-tools-extra/clang-tidy/performance/NoexceptMoveConstructorCheck.h; clang-tools-extra/clang-tidy/performance/NoIntToPtrCheck.cpp; clang-tools-extra/clang-tidy/performance/NoIntToPtrCheck.h; clang-tools-extra/clang-tidy/performance/PerformanceTidyModule.cpp; clang-tools-extra/clang-tidy/performance/TriviallyDestructibleCheck.cpp; clang-tools-extra/clang-tidy/performance/TriviallyDestructibleCheck.h; clang-tools-extra/clang-tidy/performance/TypePromotionInMathFnCheck.cpp; clang-tools-extra/clang-tidy/performance/TypePromotionInMathFnCheck.h; clang-tools-extra/clang-tidy/performance/UnnecessaryCopyInitialization.cpp; clang-tools-extra/clang-tidy/performance/UnnecessaryValueParamCheck.cpp; clang-tools-extra/clang-tidy/performance/UnnecessaryValueParamCheck.h; clang-tools-extra/clang-tidy/plugin/ClangTidyPlugin.cpp; clang-tools-extra/clang-tidy/portability/PortabilityTidyModule.cpp; clang-tools-extra/clang-tidy/portability/RestrictSystemIncludesCheck.cpp; clang-tools-extra/clang-tidy/portability/SIMDIntrinsicsCheck.cpp; clang-tools-extra/clang-tidy/readability/AvoidConstParamsInDecls.h; clang-tools-extra/clang-tidy/readability/BracesAroundStatementsCheck.cpp; clang-tools-extra/clang-tidy/readability/BracesAroundStatementsCheck.h; clang-tools-extra/clang-tidy/readability/ConstReturnTypeCheck.cpp; clang-tools-extra/clang-tidy/readability/ContainerContainsCheck.cpp; clang-tools-extra/clang-tidy/readability/ContainerContainsCheck.h; clang-tools-extra/clang-tidy/readability/ContainerDataPointerCheck.cpp; clang-tools-extra/clang-tidy/readability/ContainerDataPointerCheck.h; clang-tools-extra/clang-tidy/readability/ContainerSizeEmptyCheck.h; clang-tools-extra/clang-tidy/readability/ConvertMemberFunctionsToStatic.cpp; clang-tools-extra/clang-tidy/readability/ConvertMemberFunctionsToStatic.h; clang-tools-extra/clang-tidy/readability/DeleteNullPointerCheck.cpp; clang-tools-extra/clang-tidy/readability/DeleteNullPointerCheck.h; clang-tools-extra/clang-tidy/readability/Duplic,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:66584,portab,portability,66584,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['portab'],['portability']
Modifiability,"; compiled and loaded into the ROOT session on the fly. The code repository of RooWorkspace is designed to handle classes that; have either their own implementation and header file, or are part of a group; of classes that share a common header and implementation file. More complicated; structuring of source code into files is not supported. ; ; Also new accessors have been added for discrete-valued functions catfunc(); and stored category functions are now also printed under their own heading in Print(); Parameterized ranges. It is now possible to use RooAbsReal derived functions as range definition for variables; to construct ranges that vary as function of another variable. For example. RooRealVar x(""x"",""x"",-10,10) ; // variable with fixed range [-10,10] ; RooRealVar y(""y"",""y"",0,20) ; // variable with fixed range [-10,10] ; ; RooFormulaVar x_lo(""x_lo"",""y-20"",y) ; ; RooFormulaVar x_hi(""x_hi"",""sin(y)*5"",y) ; ; x.setRange(x_lo,x_hi) ; // Change x to have variable range depending on y; ; It is also possible to define parameterized named ranges in the same way. x.setRange(""signalRegion"",x_lo,x_hi) ;. There are no fundamental limits to the complexity of the parameterized ranges; that can be defined as long as the problem is uniquely defined. For example, given three observables ; x, y and z, one can define a parameterized named range 'R' of x in terms of y and of y in terms of z; and ask to calculate the three dimensional integral of any function or p.d.f in terms of (x,y,z); over that range 'R' and it will be calculated correctly, taking recursive range dependencies into; account. A definition of a range 'R' on the other hand where the bounds of x depend on y and; the bounds of y depend on x is not allowed, and an error message will be printed to complain about; the ambiguity of the problem definition. Integrals over non-rectangular regions are created the; same way as integrals over rectangular regions using the RooAbsReal::createIntegral() function, the; chosen mode ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:3620,variab,variable,3620,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,2,"['parameteriz', 'variab']","['parameterized', 'variable']"
Modifiability,"; each; level includes all the guarantees of the previous level except for; Acquire/Release. (See also `LangRef Ordering <LangRef.html#ordering>`_.). .. _NotAtomic:. NotAtomic; ---------. NotAtomic is the obvious, a load or store which is not atomic. (This isn't; really a level of atomicity, but is listed here for comparison.) This is; essentially a regular load or store. If there is a race on a given memory; location, loads from that location return undef. Relevant standard; This is intended to match shared variables in C/C++, and to be used in any; other context where memory access is necessary, and a race is impossible. (The; precise definition is in `LangRef Memory Model <LangRef.html#memmodel>`_.). Notes for frontends; The rule is essentially that all memory accessed with basic loads and stores; by multiple threads should be protected by a lock or other synchronization;; otherwise, you are likely to run into undefined behavior. If your frontend is; for a ""safe"" language like Java, use Unordered to load and store any shared; variable. Note that NotAtomic volatile loads and stores are not properly; atomic; do not try to use them as a substitute. (Per the C/C++ standards,; volatile does provide some limited guarantees around asynchronous signals, but; atomics are generally a better solution.). Notes for optimizers; Introducing loads to shared variables along a codepath where they would not; otherwise exist is allowed; introducing stores to shared variables is not. See; `Optimization outside atomic`_. Notes for code generation; The one interesting restriction here is that it is not allowed to write to; bytes outside of the bytes relevant to a store. This is mostly relevant to; unaligned stores: it is not allowed in general to convert an unaligned store; into two aligned stores of the same width as the unaligned store. Backends are; also expected to generate an i8 store as an i8 store, and not an instruction; which writes to surrounding bytes. (If you are writing a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:6835,variab,variable,6835,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['variab'],['variable']
Modifiability,"; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<FunctionDecl>isDeleted; Matches deleted function declarations. Given:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<FunctionDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<FunctionDecl>isMain; Determines whether the function is ""main"", which is the entry point; into an executable program. Matcher<FunctionDecl>isNoReturn; Matches FunctionDecls that have a noreturn attribute. Given; void nope();; [[noreturn]] void a();; __attribute__((noreturn)) void b(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:92678,variab,variable,92678,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"; formatting of the value. For example, to format a floating point value as a percentage,; you can use the style option ``P``. Custom formatting; ^^^^^^^^^^^^^^^^^. There are two ways to customize the formatting behavior for a type. 1. Provide a template specialization of ``llvm::format_provider<T>`` for your; type ``T`` with the appropriate static format method. .. code-block:: c++. namespace llvm {; template<>; struct format_provider<MyFooBar> {; static void format(const MyFooBar &V, raw_ostream &Stream, StringRef Style) {; // Do whatever is necessary to format `V` into `Stream`; }; };; void foo() {; MyFooBar X;; std::string S = formatv(""{0}"", X);; }; }. This is a useful extensibility mechanism for adding support for formatting your own; custom types with your own custom Style options. But it does not help when you want; to extend the mechanism for formatting a type that the library already knows how to; format. For that, we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-bl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:14194,adapt,adapter,14194,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,"['adapt', 'inherit']","['adapter', 'inheriting']"
Modifiability,"; if (DOXYGEN_FOUND); if (LLVM_ENABLE_DOXYGEN); set(abs_srcdir ${CMAKE_CURRENT_SOURCE_DIR}); set(abs_builddir ${CMAKE_CURRENT_BINARY_DIR}). if (HAVE_DOT); set(DOT ${LLVM_PATH_DOT}); endif(). if (LLVM_DOXYGEN_EXTERNAL_SEARCH); set(enable_searchengine ""YES""); set(searchengine_url ""${LLVM_DOXYGEN_SEARCHENGINE_URL}""); set(enable_server_based_search ""YES""); set(enable_external_search ""YES""); set(extra_search_mappings ""${LLVM_DOXYGEN_SEARCH_MAPPINGS}""); else(); set(enable_searchengine ""NO""); set(searchengine_url """"); set(enable_server_based_search ""NO""); set(enable_external_search ""NO""); set(extra_search_mappings """"); endif(). # If asked, configure doxygen for the creation of a Qt Compressed Help file.; if (LLVM_ENABLE_DOXYGEN_QT_HELP); set(CLANG_DOXYGEN_QCH_FILENAME ""org.llvm.clang.qch"" CACHE STRING; ""Filename of the Qt Compressed help file""); set(CLANG_DOXYGEN_QHP_NAMESPACE ""org.llvm.clang"" CACHE STRING; ""Namespace under which the intermediate Qt Help Project file lives""); set(CLANG_DOXYGEN_QHP_CUST_FILTER_NAME ""Clang ${CLANG_VERSION}"" CACHE STRING; ""See http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-filters""); set(CLANG_DOXYGEN_QHP_CUST_FILTER_ATTRS ""Clang,${CLANG_VERSION}"" CACHE STRING; ""See http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes""); set(clang_doxygen_generate_qhp ""YES""); set(clang_doxygen_qch_filename ""${CLANG_DOXYGEN_QCH_FILENAME}""); set(clang_doxygen_qhp_namespace ""${CLANG_DOXYGEN_QHP_NAMESPACE}""); set(clang_doxygen_qhelpgenerator_path ""${LLVM_DOXYGEN_QHELPGENERATOR_PATH}""); set(clang_doxygen_qhp_cust_filter_name ""${CLANG_DOXYGEN_QHP_CUST_FILTER_NAME}""); set(clang_doxygen_qhp_cust_filter_attrs ""${CLANG_DOXYGEN_QHP_CUST_FILTER_ATTRS}""); else(); set(clang_doxygen_generate_qhp ""NO""); set(clang_doxygen_qch_filename """"); set(clang_doxygen_qhp_namespace """"); set(clang_doxygen_qhelpgenerator_path """"); set(clang_doxygen_qhp_cust_filter_name """"); set(clang_doxygen_qhp_cust_filter_attrs """"); endif(). option(LLVM_DOXYGEN_SVG; ""Use svg ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CMakeLists.txt:641,config,configure,641,interpreter/llvm-project/clang/docs/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CMakeLists.txt,1,['config'],['configure']
Modifiability,"; if (DOXYGEN_FOUND); if (LLVM_ENABLE_DOXYGEN); set(abs_top_srcdir ${CMAKE_CURRENT_SOURCE_DIR}); set(abs_top_builddir ${CMAKE_CURRENT_BINARY_DIR}). if (HAVE_DOT); set(DOT ${LLVM_PATH_DOT}); endif(). if (LLVM_DOXYGEN_EXTERNAL_SEARCH); set(enable_searchengine ""YES""); set(searchengine_url ""${LLVM_DOXYGEN_SEARCHENGINE_URL}""); set(enable_server_based_search ""YES""); set(enable_external_search ""YES""); set(extra_search_mappings ""${LLVM_DOXYGEN_SEARCH_MAPPINGS}""); else(); set(enable_searchengine ""NO""); set(searchengine_url """"); set(enable_server_based_search ""NO""); set(enable_external_search ""NO""); set(extra_search_mappings """"); endif(). # If asked, configure doxygen for the creation of a Qt Compressed Help file.; option(LLVM_ENABLE_DOXYGEN_QT_HELP; ""Generate a Qt Compressed Help file."" OFF); if (LLVM_ENABLE_DOXYGEN_QT_HELP); set(LLVM_DOXYGEN_QCH_FILENAME ""org.llvm.qch"" CACHE STRING; ""Filename of the Qt Compressed help file""); set(LLVM_DOXYGEN_QHP_NAMESPACE ""org.llvm"" CACHE STRING; ""Namespace under which the intermediate Qt Help Project file lives""); set(LLVM_DOXYGEN_QHP_CUST_FILTER_NAME ""${PACKAGE_STRING}"" CACHE STRING; ""See http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-filters""); set(LLVM_DOXYGEN_QHP_CUST_FILTER_ATTRS ""${PACKAGE_NAME},${PACKAGE_VERSION}"" CACHE STRING; ""See http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes""); find_program(LLVM_DOXYGEN_QHELPGENERATOR_PATH qhelpgenerator; DOC ""Path to the qhelpgenerator binary""); if (NOT LLVM_DOXYGEN_QHELPGENERATOR_PATH); message(FATAL_ERROR ""Failed to find qhelpgenerator binary""); endif(). set(llvm_doxygen_generate_qhp ""YES""); set(llvm_doxygen_qch_filename ""${LLVM_DOXYGEN_QCH_FILENAME}""); set(llvm_doxygen_qhp_namespace ""${LLVM_DOXYGEN_QHP_NAMESPACE}""); set(llvm_doxygen_qhelpgenerator_path ""${LLVM_DOXYGEN_QHELPGENERATOR_PATH}""); set(llvm_doxygen_qhp_cust_filter_name ""${LLVM_DOXYGEN_QHP_CUST_FILTER_NAME}""); set(llvm_doxygen_qhp_cust_filter_attrs ""${LLVM_DOXYGEN_QHP_CUST_FILTER_ATTRS}""). else(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakeLists.txt:649,config,configure,649,interpreter/llvm-project/llvm/docs/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakeLists.txt,1,['config'],['configure']
Modifiability,"; if (LLVM_BUILTIN_TARGETS); set(builtins_dep_name ""${builtins_dep}-${name}""); else(); set(builtins_dep_name ${builtins_dep}); endif(); endif(). check_apple_target(${name} runtime). runtime_register_target(${name}; DEPENDS ${builtins_dep_name} ${hdrgen_deps}; CMAKE_ARGS -DLLVM_DEFAULT_TARGET_TRIPLE=${name} ${libc_cmake_args}; EXTRA_ARGS TARGET_TRIPLE ${name}); endforeach(). foreach(multilib ${LLVM_RUNTIME_MULTILIBS}); foreach(name ${LLVM_RUNTIME_MULTILIB_${multilib}_TARGETS}); runtime_register_target(${name}+${multilib}; DEPENDS runtimes-${name}; CMAKE_ARGS -DLLVM_DEFAULT_TARGET_TRIPLE=${name}; -DLLVM_RUNTIMES_PREFIX=${name}/; -DLLVM_RUNTIMES_LIBDIR_SUBDIR=${multilib}; BASE_NAME ${name}; EXTRA_ARGS TARGET_TRIPLE ${name}); endforeach(); endforeach(); endif(). if(NOT LLVM_BUILD_INSTRUMENTED AND CLANG_ENABLE_BOOTSTRAP); # TODO: This is a hack needed because the libcxx headers are copied into the; # build directory during configuration. Without that step the clang in the; # build directory cannot find the C++ headers in certain configurations.; # I need to build a mechanism for runtime projects to provide CMake code; # that executes at LLVM configuration time to handle this case.; add_dependencies(clang-bootstrap-deps runtimes-configure); # We need to add the runtimes as a dependency because compiler-rt can be; # built as part of runtimes and we need the profile runtime for PGO; add_dependencies(clang-bootstrap-deps runtimes); endif(). if(LLVM_INCLUDE_TESTS); set_property(GLOBAL APPEND PROPERTY LLVM_ALL_ADDITIONAL_TEST_DEPENDS runtimes-test-depends). set(RUNTIMES_TEST_DEPENDS; FileCheck; count; llvm-cov; llvm-lto; llvm-nm; llvm-objdump; llvm-profdata; llvm-size; llvm-xray; not; obj2yaml; opt; sancov; sanstats; llvm_gtest_main; llvm_gtest; split-file; ); foreach(target ${test_targets} ${SUB_CHECK_TARGETS}); add_dependencies(${target} ${RUNTIMES_TEST_DEPENDS}); endforeach(). set_property(GLOBAL APPEND PROPERTY LLVM_ALL_ADDITIONAL_TEST_TARGETS runtimes ${RUNTIMES_TEST_DEPEN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:18459,config,configurations,18459,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,1,['config'],['configurations']
Modifiability,"; in the reference guide, a direct link from this example to the full list of; predefined palettes given in `TColor` has been added.; - Revisited the TSpectrum2 documentation. All the static images have been replaced; by macros generating images at reference guide build time. These macros have; been added in the tutorial section of the reference guide.; - The Reference Guide can now be accessed directly from the ROOT prompt thanks to; a great extension (implemented by Desislava Kalaydjieva) of the `.help` command.; For example to access the Reference Guide for `TTree` it is enough to type:; ~~~ {.cpp}; root[0] .help TTree; ~~~; To open the reference guide for a function/member:; ~~~ {.cpp}; root[0] .help TTree::Draw; ~~~. ## Build, Configuration and Testing Infrastructure. - Make MLP optional via the `-Dmlp={OFF,ON}` switch for CMake; - Make Spectrum optional via the `-Dspectrum={OFF,ON}` switch for CMake; - ROOT now fails to configure when any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=ON` now switches the default value of all optional packages to `ON`; - The options `astiff`, `cling`, `pch`, `thread`, and `explicitlink` have been; removed and are now ignored. They either had no effect (their value was not; being used in the build system), or could not be disabled (like `cling` and; `explicitlink`).; - ROOT library targets now export which C++ standard they were built with via; the target compile features `cxx_std_11`, `cxx_std_14`, and `cxx_std_17`.; - The file `RootNewMacros.cmake` has been renamed to `RootMacros.cmake`.; Including the old file by name is deprecated and will generate a warning.; Including `RootMacros.cmake` is not necessary, as now it is already included; when calling `find_package(ROOT)`. If you still need to inherit ROOT's compile; options, however, you may use `include(${ROOT_USE_FILE})` as before.; - ROOT's internal CMake modules (e.g. CheckCompiler.cmake, SetUpLinux.cmake, etc); are no longer installed w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:8014,config,configure,8014,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['config'],['configure']
Modifiability,"; int count;; if (!readWrapper(fd, &count)); print(""%d"", count); // should not warn; }. PR18701. undefined behavior. Name, DescriptionExampleProgress. undefbehavior.ExitInDtor; (C++); Undefined behavior: std::exit() is called to end the program during; the destruction of an object with static storage duration.; Source: C++11 3.6.1p4. #include <cstdlib>. class A {; public:; ~A() {; std::exit(1); // warn; }; };. undefbehavior.LocalStaticDestroyed; (C++); Undefined behavior: function containing a definition of static local object is; called during the destruction of an object with static storage duration so that; flow of control passes through the definition of the previously destroyed; static local object.; Source: C++11 3.6.3p2. void f();. class A {; public:; ~A() {; f(); // warn; }; };. class B {};. A a;. void f() {; static B b;; }. undefbehavior.ZeroAllocDereference; (C, C++); The effect of dereferencing a pointer returned as a request for zero size is; undefined.; Note: possibly an enhancement to ; unix.Malloc.; Source: C++03 3.7.3.1p2; C++11 3.7.4.1p2. #include <stdlib.h>. void test() {; int *p = (int *)malloc(0);; *p = 1; // warn; free(p);; }. void f(int);. void test() {; int *p = new int[0];; f(*p); // warn; delete[] p;; }. D8273. undefbehavior.DeadReferenced; (C++); Undefined behavior: the following usage of the pointer to the object whose; lifetime has ended can result in undefined behavior:; The object will be or was of a class type with a non-trivial destructor and; the pointer is used as the operand of a delete-expression; The object will be or was of a non-POD class type (C++11: any class type) and; the pointer is used to access a non-static data member or call a; non-static member function of the object; the pointer is implicitly converted to a pointer to a base class; type; the pointer is used as the operand of a static_cast (except; when the conversion is to void*, or to void* and; subsequently to char*, or unsigned char*); the pointer is used as the o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:6235,enhance,enhancement,6235,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['enhance'],['enhancement']
Modifiability,"; level only variables that are of type ``Block`` or ones that have; ``__attribute__((NSObject))`` marked require helper functions. In Objective-C; objects require helper functions and in C++ stack based objects require helper; functions. Variables that require helper functions use the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct _block_byref_foo *forwarding;; int flags; //refcount;; int size;; // helper functions called via Block_copy() and Block_release(); void (*byref_keep)(void *dst, void *src);; void (*byref_dispose)(void *);; typeof(marked_variable) marked_variable;; };. The structure is initialized such that:. a. The ``forwarding`` pointer is set to the beginning of its enclosing; structure. b. The ``size`` field is initialized to the total size of the enclosing; structure. c. The ``flags`` field is set to either 0 if no helper functions are needed; or (1<<25) if they are. d. The helper functions are initialized (if present). e. The variable itself is set to its initial value. f. The ``isa`` field is set to ``NULL``. Access to ``__block`` variables from within its lexical scope; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In order to ""move"" the variable to the heap upon a ``copy_helper`` operation the; compiler must rewrite access to such a variable to be indirect through the; structures ``forwarding`` pointer. For example:. .. code-block:: c. int __block i = 10;; i = 11;. would be rewritten to be:. .. code-block:: c. struct _block_byref_i {; void *isa;; struct _block_byref_i *forwarding;; int flags; //refcount;; int size;; int captured_i;; } i = { NULL, &i, 0, sizeof(struct _block_byref_i), 10 };. i.forwarding->captured_i = 11;. In the case of a ``Block`` reference variable being marked ``__block`` the; helper code generated must use the ``_Block_object_assign`` and; ``_Block_object_dispose`` routines supplied by the runtime to make the; copies. For example:. .. code-block:: c. __block void (voidBlock)(void) = blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:12910,variab,variable,12910,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variable']
Modifiability,"; matcher to handle overloaded operators. There are AST matchers to match all the different nodes of the AST,; narrowing matchers to only match AST nodes fulfilling specific criteria,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will not match loops whose; variables are initialized to ``'\0'``, ``0.0``, ``NULL``, or any form of; zero besides the integer 0. The last step is giving the matcher a name and binding the ``ForStmt``; as we will want to do something with it:. .. code-block:: c++. StatementMatcher LoopMatcher =; forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0))))))))",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7721,variab,variable,7721,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,2,"['extend', 'variab']","['extend', 'variable']"
Modifiability,"; operand is concatenated to an empty string. `Appendix B: Paste Operator Examples`_ presents examples of the behavior of; the paste operator. Statements; ==========. The following statements may appear at the top level of TableGen source; files. .. productionlist::; TableGenFile: (`Statement` | `IncludeDirective`; :| `PreprocessorDirective`)*; Statement: `Assert` | `Class` | `Def` | `Defm` | `Defset` | `Defvar`; :| `Dump` | `Foreach` | `If` | `Let` | `MultiClass`. The following sections describe each of these top-level statements. ``class`` --- define an abstract record class; ---------------------------------------------. A ``class`` statement defines an abstract record class from which other; classes and records can inherit. .. productionlist::; Class: ""class"" `ClassID` [`TemplateArgList`] `RecordBody`; TemplateArgList: ""<"" `TemplateArgDecl` ("","" `TemplateArgDecl`)* "">""; TemplateArgDecl: `Type` `TokIdentifier` [""="" `Value`]. A class can be parameterized by a list of ""template arguments,"" whose values; can be used in the class's record body. These template arguments are; specified each time the class is inherited by another class or record. If a template argument is not assigned a default value with ``=``, it is; uninitialized (has the ""value"" ``?``) and must be specified in the template; argument list when the class is inherited (required argument). If an; argument is assigned a default value, then it need not be specified in the; argument list (optional argument). In the declaration, all required template; arguments must precede any optional arguments. The template argument default; values are evaluated from left to right. The :token:`RecordBody` is defined below. It can include a list of; parent classes from which the current class inherits, along with field; definitions and other statements. When a class ``C`` inherits from another; class ``D``, the fields of ``D`` are effectively merged into the fields of; ``C``. A given class can only be defined once. A ``cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:22047,parameteriz,parameterized,22047,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['parameteriz'],['parameterized']
Modifiability,"; prefix. For example, ``%foo``, ``@DivisionByZero``,; ``%a.really.long.identifier``. The actual regular expression used is; '``[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*``'. Identifiers that require other; characters in their names can be surrounded with quotes. Special; characters may be escaped using ``""\xx""`` where ``xx`` is the ASCII; code for the character in hexadecimal. In this way, any character can; be used in a name value, even quotes themselves. The ``""\01""`` prefix; can be used on global values to suppress mangling.; #. Unnamed values are represented as an unsigned numeric value with; their prefix. For example, ``%12``, ``@2``, ``%44``.; #. Constants, which are described in the section Constants_ below. LLVM requires that values start with a prefix for two reasons: Compilers; don't need to worry about name clashes with reserved words, and the set; of reserved words may be expanded in the future without penalty.; Additionally, unnamed identifiers allow a compiler to quickly come up; with a temporary variable without having to avoid symbol table; conflicts. Reserved words in LLVM are very similar to reserved words in other; languages. There are keywords for different opcodes ('``add``',; '``bitcast``', '``ret``', etc...), for primitive type names ('``void``',; '``i32``', etc...), and others. These reserved words cannot conflict; with variable names, because none of them start with a prefix character; (``'%'`` or ``'@'``). Here is an example of LLVM code to multiply the integer variable; '``%X``' by 8:. The easy way:. .. code-block:: llvm. %result = mul i32 %X, 8. After strength reduction:. .. code-block:: llvm. %result = shl i32 %X, 3. And the hard way:. .. code-block:: llvm. %0 = add i32 %X, %X ; yields i32:%0; %1 = add i32 %0, %0 ; yields i32:%1; %result = add i32 %1, %1. This last way of multiplying ``%X`` by 8 illustrates several important; lexical features of LLVM:. #. Comments are delimited with a '``;``' and go until the end of line.; #. Unnamed temporaries a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:4019,variab,variable,4019,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1412,variab,variables,1412,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['variab'],['variables']
Modifiability,"; run-time: recognize early the case at hand and select an optimized path.; For that reason, `PyPy`_ is so fast: JIT-ed traces operate on unboxed objects; and resolved overloads are baked into the trace, incurring no further cost.; Similarly, this is why pybind11 is so slow: its code generation is the C++; compiler's template engine, so complex path selection and specialization is; very hard to do in a performance-portable way. In cppyy, a great deal of attention has gone into built-in specialization; paths, which drives its performance.; For example, basic inheritance sequentially lines up classes, whereas; multiple (virtual) inheritance usually requires thunks.; Thus, when calling base class methods on a derived instance, the latter; requires offset calculations that depend on that instance, whereas the former; has fixed offsets fully determined by the class definitions themselves.; By labeling classes appropriately, single inheritance classes (by far the; most common case) do not incur the overhead in PyPy's JIT-ed traces that is; otherwise unavoidable for multiple virtual inheritance.; As another example, consider that the C++ standard does not allow modifying; a ``std::vector`` while looping over it, whereas Python has no such; restriction, complicating loops.; Thus, cppyy has specialized ``std::vector`` iteration for both PyPy and; CPython, easily outperforming looping over an equivalent numpy array. In CPython, the performance of `non-overloaded` function calls depends; greatly on the Python interpreter's internal specializations; and Python3; has many specializations specific to basic extension modules (C function; pointer calls), gaining a performance boost of more than 30% over Python2.; Only since Python3.8 is there also better support for closure objects (vector; calls) as cppyy uses, to short-cut through the interpreter's own overhead. As a practical consideration, whether a binder performs well on code that you; care about, depends `entirely` on whether",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:3184,inherit,inheritance,3184,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,2,['inherit'],['inheritance']
Modifiability,"; so you will have the same setting next time you look at the class documentation. Access (public / protected / private); Not all members are available to everyone (check any C++ introduction to learn why).; Public members have a green bar on their left, protected ones have a yellow one, and; private members are marked with a red bar. Of course you won't see any protected or; private members if you hide them in the display options. Inheritance; You can often access members of a class's base classes, just as if they are defined; in the derived class. A histogram,; for example, has a name, and you can access it using GetName() as defined in its base; class TNamed. If you want to see; all available members, and not just the ones defined in the current class, in the; display options. They will be prefixed with the name of; the class they are defined in. Class Charts; The class charts are shown in a tabbed box; click on the names ontop to select a tab. Inheritance; This chart shows the inheritance hierarchy for the current class. Arrows point to; base classes. You can click the classes to get to their reference page. Inherited Members; The second chart shows a list of all members of all base classes. You can see at what; level they are defined or at what level they are defined. Members that are accessible; (public) have a green background, protected ones have a yellow background, and private; members have a red background. Members with a dark gray background are re-implemented; or hidden by a derived class. Includes; The Includes chart shows which files are indirectly included by including the class's; header. Most headers will #include some files, so by #including that header you also; #include the #included files, and so on. A illegible chart often means you should; read a bit on the C++ trick known as ""forward declaration"". Including too many headers; has some nasty consequences, like compile time, additional dependencies, etc. Libraries; Each class is assumed to be in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:6981,inherit,inheritance,6981,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,1,['inherit'],['inheritance']
Modifiability,"; something goes wrong. As the method described here also works without; using PROOF, the development work on an analysis script can be done in; the standard way on a small subset of the data, and only for the full; processing one would use parallelism via PROOF. It is worth to remind the reader that the speed of typical data analysis; programs limited by the I/O speed (for example the latencies implied by; reading data from a hard drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:13691,variab,variable,13691,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['variab'],['variable']
Modifiability,"; static alloca in the function entry block. The second argument is a; `local variable <LangRef.html#dilocalvariable>`_ containing a description of; the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.declare` intrinsic describes the; *address* of a source variable. .. code-block:: text. %i.addr = alloca i32, align 4; call void @llvm.dbg.declare(metadata i32* %i.addr, metadata !1,; metadata !DIExpression()), !dbg !2; !1 = !DILocalVariable(name: ""i"", ...) ; int i; !2 = !DILocation(...); ...; %buffer = alloca [256 x i8], align 8; ; The address of i is buffer+64.; call void @llvm.dbg.declare(metadata [256 x i8]* %buffer, metadata !3,; metadata !DIExpression(DW_OP_plus, 64)), !dbg !4; !3 = !DILocalVariable(name: ""i"", ...) ; int i; !4 = !DILocation(...). A frontend should generate exactly one call to ``llvm.dbg.declare`` at the point; of declaration of a source variable. Optimization passes that fully promote the; variable from memory to SSA values will replace this call with possibly multiple; calls to `llvm.dbg.value`. Passes that delete stores are effectively partial; promotion, and they will insert a mix of calls to ``llvm.dbg.value`` to track; the source variable value when it is available. After optimization, there may be; multiple calls to ``llvm.dbg.declare`` describing the program points where the; variables lives in memory. All calls for the same concrete source variable must; agree on the memory location. ``llvm.dbg.value``; ^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.value(metadata, metadata, metadata). This intrinsic provides information when a user source variable is set to a new; value. The first argument is the new value (wrapped as metadata). The second; argument is a `local variable <LangRef.html#dilocalvariable>`_ containing a; description of the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a so",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:9640,variab,variable,9640,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"; the current event and the rest of the packet is reassigned to another workers).; It's done by a new method TPacketizerAdaptive::AddProcessed(TSlave *sl,; TProofProgressStatus *st, TList **) and TPacketizerAdaptive::ReassignPacket. ; Memory controlAdd; the possibility to display the memory footprint on workers and master as a; function of the entry processed (workers) or of the merging step; (master). A new button has been added to the PROOF dialog box to; retrieve and display the memory usage. On the workers about 100; measurements are recorded by default; this number can be changed with 'proof->SetParameter(""PROOF_MemLogFreq"", memlogfreq)';Add; the possibility to set upper limits on the virtual memory used by; processes; the session gets firts a warning when it reaches 80% of; the limit, and then processing is stopped whenit exceeds 95% of the; limit, sending back the results. Also, the memory footprint is notified; when the session is terminated. The limit in MBs is set by the; environment variable ""ROOTPROOFASSOFT"". An hard limit can be set via the; env ""ROOTPROOFASHARD"" (also in MBs): the process is automatically; killed by the system if it reaches this limit. Envs variables for the; PROOF processes can be set using the directive 'xpd.putenv' in the; xrootd config file.Input dataIntroduce the; concept of 'input data': these are objects that are distributed in; optimal way to the workers, which are available via the input list, but; which are not saved in the TQueryResult object. These are meant for big; objects whic can create a big overload when distributed via the; standard input list (which should mostly be used for job control; parameters).  To add an input-data object just use; TProof::AddInputData(TObject *); if the input-data objects are in a; file you can use TProof::SetInputDataFile(const char *file); the final; set of input-data objects is assembled from the objects added via; AddInputData and those found in the file defined bySetInputDataFile.  . Im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:2904,variab,variable,2904,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['variab'],['variable']
Modifiability,"; the indentation level of the signature. ``OuterScope`` forces the lambda; body to be indented one additional level relative to the parent scope; containing the lambda signature. Possible values:. * ``LBI_Signature`` (in configuration: ``Signature``); Align lambda body relative to the lambda signature. This is the default. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83272,config,configuration,83272,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"; this works adding the beginning of a path in the name; defining a new TFileNode (e.g. 'host://disk1' instead of 'host' only as; it was so far). These feature can be enabled by defining the rootrc; variable 'Packetizer.Partitions', e.g.;            Packetizer.Partitions  /disk1,/disk2,/disk3; Add to the output list the parameters used by the active packetizer. . In the PrintProgress function used to display a text progress; bar, show also the average reading rate in [k,M,G}bytes/s in addition; to the event processing rate. This is useful to have a feeling of the; rate when running of a remote machine in batch mode.; Add the possibility to control the resident and virtual; memory of a proofserv using 'ulimit', which has less limitations and; more flexibility than setrlimit.; Deactivate workers when the requested packages could not be enabled properly.; Add support for reconfiguring the group manager and the; {env,rootrc} settings. The related configuration files are checked for; changes during the regular checks done by the XrdProofdManager.; Add support for selective definition of env and rootrc; variables. Different values can be set for different users, groups, SVN; versions or ROOT versions.; Improve the diagnostic in case of exceptions. Information; about the event and file being processed at the moment the exception; was raised is sent to the client, e.g.;    0.5: caught exception triggered by signal '1' while; processing dset:'EventTree',; file:'http://root.cern.ch/files/data/event_3.root', event:1 - check; logs for possible stacktrace; The patch also fixes a problem with submergers observed when a worker; was stopped because above the memory limits: this worker was; established as merger but could not do the work, for obvious reasons,; freezing the session.; Add two new methods to TProof: ShowMissingFiles() to facilitate; the display of the list of missing files; and GetMissingFiles() to get; a TFileCollection (dataset) with the missing files for further; pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:8409,config,configuration,8409,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['config'],['configuration']
Modifiability,"; time.; ; * -parse-ast builds ASTs, but doesn't print them. This is most; useful for timing AST building vs -parse-noop.; ; * -parse-ast-print pretty prints most expression and statements nodes. * -parse-ast-check checks that diagnostic messages that are expected; are reported and that those which are reported are expected. * -dump-cfg builds ASTs and then CFGs. CFGs are then pretty-printed. * -view-cfg builds ASTs and then CFGs. CFGs are then visualized by; invoking Graphviz. For more information on getting Graphviz to work with clang/LLVM,; see: https://llvm.org/docs/ProgrammersManual.html#ViewGraph. III. Current advantages over GCC:. * Column numbers are fully tracked (no 256 col limit, no GCC-style pruning).; * All diagnostics have column numbers, includes 'caret diagnostics', and they; highlight regions of interesting code (e.g. the LHS and RHS of a binop).; * Full diagnostic customization by client (can format diagnostics however they; like, e.g. in an IDE or refactoring tool) through DiagnosticClient interface.; * Built as a framework, can be reused by multiple tools.; * All languages supported linked into same library (no cc1,cc1obj, ...).; * mmap's code in read-only, does not dirty the pages like GCC (mem footprint).; * LLVM License, can be linked into non-GPL projects.; * Full diagnostic control, per diagnostic. Diagnostics are identified by ID.; * Significantly faster than GCC at semantic analysis, parsing, preprocessing; and lexing.; * Defers exposing platform-specific stuff to as late as possible, tracks use of; platform-specific features (e.g. #ifdef PPC) to allow 'portable bytecodes'.; * The lexer doesn't rely on the ""lexer hack"": it has no notion of scope and; does not categorize identifiers as types or variables -- this is up to the; parser to decide. Potential Future Features:. * Fine grained diag control within the source (#pragma enable/disable warning).; * Better token tracking within macros? (Token came from this line, which is; a macro argumen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:5959,refactor,refactoring,5959,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['refactor'],['refactoring']
Modifiability,"; to manage data staging based on the dataset information (see; http://code.google.com/p/afdsmgrd/ for more info). The daemon is; located under $ROOTSYS/proof/afdsmgrd .; New PROOF bench suite, a framework to run CPU and IO benchmarks with; default selectors/data or with user-provided ones. The code is located; under proof/proofbench.; Add the possibility to access the files on the workers via the same; port used by PROOF. This is useful for cases when it is not possible to; start a file server daemon on a different port (because, for eample, of; a firewall or just inconvenience) and workers do not share a file; system. Internally this works by forking a 'rootd' after identifying a; file request and trasferring the connection to it. The client side is a; TNetFile and it is triggered by the protocol ""rootd://"" (the just; implemented etc/plugins/TFile/P120_TNetFile.C includes this; protocol).; Add support for log file truncation. Truncation is disabled by; default. Enabling is controlled by the rootrc variable.           ; ProofServ.LogFileMaxSize  ; {<bytes>|<kilobytes>K|<megabytes>M|<gigabytes>G}.  indicating the max number of bytes. The number can be followed by; a {K,M,G} to indicate KBytes, MBytes or GBytes, respectively.; Add new derivation of TList (TProofOutputList) to be used on the; PROOF client to filter out PROOF internal objects when displaying or; printing the list. By default objects was names start with 'PROOF_' are; not shown. The presence of a non empty missing file list is; notified.; In the PROOF monitoring to: send additional information about memory; usage during the query, the name and size (# of files) of the dataset; processed (if any); add possibility to send the information to multiple; monitoring collectors.; Add support for block activation/deactivation of workers.; Add possibility to start the proofserv with 'system()' instead of; 'fork()' as done in PROOF-Lite. A new switch 'usefrk' has been added to; 'xpd.proofservmgr' to control that. D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:1747,variab,variable,1747,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,1,['variab'],['variable']
Modifiability,"; weight reduced (*= 1/boostweight) rather than increased; (*= boostweight) as the other events do. Otherwise these; events tend to receive increasingly stronger boosts,; because their effects on the separation gain are as if; background events were selected as signal and vice versa; (hence the events tend to be ""wanted"" in signal nodes, but; are boosted as if they were misclassified). In addition,; the separation indices are protected against negative S or; S+B returning 0.5 (no separation at all) in case that; occurs.; ; BDT: In addition there is a new BDT option to; ignore events with negative event weights for the; training. This option could be used as a cross check of a; ""worst case"" solution for Monte Carlo samples with; negative weights. Note that the results of the testing; phase still include these events and are hence objective.; ; BDT: Added randomised trees: similar to the; ""Random Forests"" technique of Leo Breiman and Adele; Cutler, it uses the ""bagging"" algorithm and bases the; determination of the best node-split during the training; on a random subset of variables only, which is; individually chosen for each split.; ; BDT: Move to TRandom2 for the ""bagging"" algorithm; and throw random weights according to Poisson; statistics. (This way the random weights are closer to a; resampling with replacement algorithm.); ; TMlpANN: Extended options to; TMultilayerPerceptron learning methods. Added example for; reader application: TMVApplication.py; . GUI:. Parallel Coordinates: New GUI button for Parallel; Coordinate plotting.; . Application:. Added Python example for reader application: TMVApplication.py; . Bug fixes:. TMlpANN: fixed crash with ROOT>=5.17 when using; large number of test events; also corrected bias in cross; validation: before the test events were used, which led to; an overestimated performance evaluation in case of a small; number of degrees of freedom; separate now training tree; in two parts for training and validation with configurable;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html:3836,variab,variables,3836,tmva/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html,1,['variab'],['variables']
Modifiability,"; without inspecting the meta-data of all the previous clusters. The hierarchical structure of the frames in the page list envelope is as follows:. # this is `List frame of cluster group record frames` mentioned above; - Top-most cluster list frame (one item for each cluster in this RNTuple); |; |---- Cluster 1 column list frame (outer list frame, one item for each column in this RNTuple); | |---- Column 1 page list frame (inner list frame, one item for each page in this column); | | |---- Page 1 description (inner item); | | |---- Page 2 description (inner item); | | | ...; | |---- Column 1 element offset (Int64), negative if the column is suppressed; | |---- Column 1 compression settings (UInt32), available only if the column is not suppressed; | |---- Column 2 page list frame; | | ...; |; |---- Cluster 2 column list frame; | ... In order to save space, the page descriptions (inner items) are _not_ in a record frame.; If at a later point more information per page is needed,; the page list envelope can be extended by additional list and record frames. #### Suppressed Columns. If the element offset in the inner list frame is negative (sign bit set), the column is suppressed.; Writers should write the lowest int64_t value, readers should check for a negative value.; Suppressed columns always have an empty list of pages.; Suppressed columns omit the compression settings in the inner list frame. Suppressed columns belong to a secondary column representation (see Section ""Column Description""); that is inactive in the current cluster.; The number of columns; and the absolute values of the element offsets of primary and secondary representations are identical.; When reading a field of a certain entry, this assertion allows for searching the corresponding; cluster and column element indexes using any of the column representations.; It also means that readers need to get the element index offset and the number of elements of suppressed columns; from the corresponding column",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:36208,extend,extended,36208,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['extend'],['extended']
Modifiability,"; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Whitesmiths`` (in configuration: ``Whitesmiths``); Like ``Allman`` but always indent braces and line up code with braces. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_GNU`` (in configuration: ``GNU``); Always break before braces and add an extra level of indentation to; braces of control statements, not to those of class, function; or other definitions. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; }; while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_WebKit`` (in configuration: ``WebKit``); Like ``Attach``, but break before functions. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:50805,config,configuration,50805,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<VarDecl>hasAutomaticStorageDuration; Matches a variable declaration that has automatic storage duration. Example matches x, but not y, z, or a.; (matcher = varDecl(hasAutomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:124864,variab,variable,124864,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,";. ``defset`` --- create a definition set; --------------------------------------. The ``defset`` statement is used to collect a set of records into a global; list of records. .. productionlist::; Defset: ""defset"" `Type` `TokIdentifier` ""="" ""{"" `Statement`* ""}"". All records defined inside the braces via ``def`` and ``defm`` are defined; as usual, and they are also collected in a global list of the given name; (:token:`TokIdentifier`). The specified type must be ``list<``\ *class*\ ``>``, where *class* is some; record class. The ``defset`` statement establishes a scope for its; statements. It is an error to define a record in the scope of the; ``defset`` that is not of type *class*. The ``defset`` statement can be nested. The inner ``defset`` adds the; records to its own set, and all those records are also added to the outer; set. Anonymous records created inside initialization expressions using the; ``ClassID<...>`` syntax are not collected in the set. ``defvar`` --- define a variable; --------------------------------. A ``defvar`` statement defines a global variable. Its value can be used; throughout the statements that follow the definition. .. productionlist::; Defvar: ""defvar"" `TokIdentifier` ""="" `Value` "";"". The identifier on the left of the ``=`` is defined to be a global variable; whose value is given by the value expression on the right of the ``=``. The; type of the variable is automatically inferred. Once a variable has been defined, it cannot be set to another value. Variables defined in a top-level ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1);. Variables can also be defined with ``defvar`` in a record body. See; `Defvar in a Record Body`_ for more details. ``foreach`` --- iterate over a sequence of statements; -----------------------------------------------------. The ``foreach`` statement iterates ov",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:44724,variab,variable,44724,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability,";; ```. When employing this constructor, you will create a histogram with; constant (fixed) bin width on each axis. For the example above, the; interval `[0.0, 4.0]` is divided into 100 bins of the same width `w`; `X = 4.0 - 0.0 100 = 0.04` for the X axis (dimension). Likewise, for; the Y axis (dimension), we have bins of equal width `w`; `Y = 1.5 - (-3.0) 200 = 0.0225`. If you want to create histograms with variable bin widths, ROOT; provides another constructor suited for this purpose. Instead of; passing the data interval and the number of bins, you have to pass an; array (single or double precision) of bin edges. When the histogram; has `n` bins, then there are `n+1` distinct edges, so the array you; pass must be of size `n+1`. ``` {.cpp}; const Int_t NBINS = 5;; Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; // Bin 1 corresponds to range [0.0, 0.2]; // Bin 2 corresponds to range [0.2, 0.3] etc... TH1* h = new TH1D(; /* name */ ""h1"",; /* title */ ""Hist with variable bin width"",; /* number of bins */ NBINS,; /* edge array */ edges; );; ```. Each histogram object contains three **`TAxis`** objects: `fXaxis` ,; `fYaxis,` and `fZaxis`, but for one-dimensional histograms only the; X-axis is relevant, while for two-dimensional histograms the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetB",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:4935,variab,variable,4935,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variable']
Modifiability,";; if (!Variable); return LogErrorV(""Unknown variable name"");. Builder->CreateStore(Val, Variable);; return Val;; }; ... Once we have the variable, codegen'ing the assignment is; straightforward: we emit the RHS of the assignment, create a store, and; return the computed value. Returning a value allows for chained; assignments like ""X = (Y = Z)"". Now that we have an assignment operator, we can mutate loop variables; and arguments. For example, we can now run code like this:. ::. # Function to print a double.; extern printd(x);. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. def test(x); printd(x) :; x = 4 :; printd(x);. test(123);. When run, this example prints ""123"" and then ""4"", showing that we did; actually mutate the value! Okay, we have now officially implemented our; goal: getting this to work requires SSA construction in the general; case. However, to be really useful, we want the ability to define our; own local variables, let's add this next!. User-defined Local Variables; ============================. Adding var/in is just like any other extension we made to; Kaleidoscope: we extend the lexer, the parser, the AST and the code; generator. The first step for adding our new 'var/in' construct is to; extend the lexer. As before, this is pretty trivial, the code looks like; this:. .. code-block:: c++. enum Token {; ...; // var definition; tok_var = -13; ...; }; ...; static int gettok() {; ...; if (IdentifierStr == ""in""); return tok_in;; if (IdentifierStr == ""binary""); return tok_binary;; if (IdentifierStr == ""unary""); return tok_unary;; if (IdentifierStr == ""var""); return tok_var;; return tok_identifier;; ... The next step is to define the AST node that we will construct. For; var/in, it looks like this:. .. code-block:: c++. /// VarExprAST - Expression class for var/in; class VarExprAST : public ExprAST {; std::vector<std::pair<std::string, std::unique_ptr<ExprAST>>> VarNam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:22822,variab,variables,22822,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,";; movswl %ax, %eax -> not needed because eax is already sext'd; 	addl	$12, %esp; 	ret. //===----------------------------------------------------------------------===//; // What we have right now.; //===----------------------------------------------------------------------===//. Currently, these sorts of things are modelled by compiling a function to return; the small type and a signext/zeroext marker is used. For example, we compile; Z into:. define i32 @z() nounwind {; entry:; 	%0 = tail call signext i16 (...)* @y() nounwind; 	%1 = sext i16 %0 to i32; 	ret i32 %1; }. and b into:. define signext i16 @b() nounwind {; entry:; 	%0 = tail call i32 (...)* @a() nounwind		; <i32> [#uses=1]; 	%retval12 = trunc i32 %0 to i16		; <i16> [#uses=1]; 	ret i16 %retval12; }. This has some problems: 1) the actual precise semantics are really poorly; defined (see PR3779). 2) some targets might want the caller to extend, some; might want the callee to extend 3) the mid-level optimizer doesn't know the; size of the GPR, so it doesn't know that %0 is sign extended up to 32-bits ; here, and even if it did, it could not eliminate the sext. 4) the code; generator has historically assumed that the result is extended to i32, which is; a problem on PIC16 (and is also probably wrong on alpha and other 64-bit; targets). //===----------------------------------------------------------------------===//; // The proposal; //===----------------------------------------------------------------------===//. I suggest that we have the front-end fully lower out the ABI issues here to; LLVM IR. This makes it 100% explicit what is going on and means that there is; no cause for confusion. For example, the cases above should compile into:. define i32 @z() nounwind {; entry:; %0 = tail call i32 (...)* @y() nounwind; 	%1 = trunc i32 %0 to i16; %2 = sext i16 %1 to i32; ret i32 %2; }; define i32 @b() nounwind {; entry:; 	%0 = tail call i32 (...)* @a() nounwind; 	%retval12 = trunc i32 %0 to i16; 	%tmp = sext i16 %r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt:2532,extend,extend,2532,interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,3,['extend'],"['extend', 'extended']"
Modifiability,";; void (*copy_helper)(struct __block_literal_5 *dst, struct __block_literal_5 *src);; void (*dispose_helper)(struct __block_literal_5 *);; } __block_descriptor_5 = { 0, sizeof(struct __block_literal_5) __block_copy_5, __block_dispose_5 };. and:. .. code-block:: c. struct _block_byref_i i = {( .isa=NULL, .forwarding=&i, .flags=0, .size=sizeof(struct _block_byref_i), .captured_i=2 )};; struct __block_literal_5 _block_literal = {; &_NSConcreteStackBlock,; (1<<25)|(1<<29), <uninitialized>,; __block_invoke_5,; &__block_descriptor_5,; &i,; };. Importing ``__attribute__((NSObject))`` ``__block`` variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ``__block`` variable that is also marked ``__attribute__((NSObject))`` should; have ``byref_keep`` and ``byref_dispose`` helper functions that use; ``_Block_object_assign`` and ``_Block_object_dispose``. ``__block`` escapes; ^^^^^^^^^^^^^^^^^^^. Because ``Blocks`` referencing ``__block`` variables may have ``Block_copy()``; performed upon them the underlying storage for the variables may move to the; heap. In Objective-C Garbage Collection Only compilation environments the heap; used is the garbage collected one and no further action is required. Otherwise; the compiler must issue a call to potentially release any heap storage for; ``__block`` variables at all escapes or terminations of their scope. The call; should be:. .. code-block:: c. _Block_object_dispose(&_block_byref_foo, BLOCK_FIELD_IS_BYREF);. Nesting; ^^^^^^^. ``Blocks`` may contain ``Block`` literal expressions. Any variables used within; inner blocks are imported into all enclosing ``Block`` scopes even if the; variables are not used. This includes ``const`` imports as well as ``__block``; variables. Objective C Extensions to ``Blocks``; ====================================. Importing Objects; -----------------. Objects should be treated as ``__attribute__((NSObject))`` variables; all; ``copy_helper``, ``dispose_helper``, ``byref_keep``, and `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:17783,variab,variables,17783,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,2,['variab'],['variables']
Modifiability,";; while (i); } while (i);. .. _InsertNewlineAtEOF:. **InsertNewlineAtEOF** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <InsertNewlineAtEOF>`; Insert a newline at end of file if missing. .. _InsertTrailingCommas:. **InsertTrailingCommas** (``TrailingCommaStyle``) :versionbadge:`clang-format 11` :ref:`¶ <InsertTrailingCommas>`; If set to ``TCS_Wrapped`` will insert trailing commas in container; literals (arrays and objects) that wrap across multiple lines.; It is currently only available for JavaScript; and disabled by default ``TCS_None``.; ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``; as inserting the comma disables bin-packing. .. code-block:: c++. TSC_Wrapped:; const someArray = [; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; // ^ inserted; ]. Possible values:. * ``TCS_None`` (in configuration: ``None``); Do not insert trailing commas. * ``TCS_Wrapped`` (in configuration: ``Wrapped``); Insert trailing commas in container literals that were wrapped over; multiple lines. Note that this is conceptually incompatible with; bin-packing, because the trailing comma is used as an indicator; that a container should be formatted one-per-line (i.e. not bin-packed).; So inserting a trailing comma counteracts bin-packing. .. _IntegerLiteralSeparator:. **IntegerLiteralSeparator** (``IntegerLiteralSeparatorStyle``) :versionbadge:`clang-format 16` :ref:`¶ <IntegerLiteralSeparator>`; Format integer literal separators (``'`` for C++ and ``_`` for C#, Java,; and JavaScript). Nested configuration flags:. Separator format of integer literals of different bases. If negative, remove separators. If ``0``, leave the literal as is. If; positive, insert separators between digits starting from the rightmost; digit. For example, the config below will leave separators in binary literals; alone, insert separators in decimal literals to separate the digits into; groups of 3, and remove separators in hexadecimal lit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:76837,config,configuration,76837,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"<ReferenceType>...; Matches both lvalue and rvalue reference types. Given; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. referenceType() matches the types of b, c, d, e, and f. Matcher<Type>substTemplateTypeParmTypeMatcher<SubstTemplateTypeParmType>...; Matches types that represent the result of substituting a type for a; template type parameter. Given; template <typename T>; void F(T t) {; int i = 1 + t;; }. substTemplateTypeParmType() matches the type of 't' but not '1'. Matcher<Type>tagTypeMatcher<TagType>...; Matches tag types (record and enum types). Given; enum E {};; class C {};. E e;; C c;. tagType() matches the type of the variable declarations of both e; and c. Matcher<Type>templateSpecializationTypeMatcher<TemplateSpecializationType>...; Matches template specialization types. Given; template <typename T>; class C { };. template class C<int>; // A; C<char> var; // B. templateSpecializationType() matches the type of the explicit; instantiation in A and the type of the variable declaration in B. Matcher<Type>templateTypeParmTypeMatcher<TemplateTypeParmType>...; Matches template type parameter types. Example matches T, but not int.; (matcher = templateTypeParmType()); template <typename T> void f(int i);. Matcher<Type>typeMatcher<Type>...; Matches Types in the clang AST. Matcher<Type>typedefTypeMatcher<TypedefType>...; Matches typedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:52212,variab,variable,52212,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"<T>; void bar(T t) {... template <typename T>; void baz(T t); requires C<T>; {... * ``RCPS_WithPreceding`` (in configuration: ``WithPreceding``); Try to put the clause together with the preceding part of a declaration.; For class templates: stick to the template declaration.; For function templates: stick to the template declaration.; For function declaration followed by a requires clause: stick to the; parameter list. .. code-block:: c++. template <typename T> requires C<T>; struct Foo {... template <typename T> requires C<T>; void bar(T t) {... template <typename T>; void baz(T t) requires C<T>; {... * ``RCPS_WithFollowing`` (in configuration: ``WithFollowing``); Try to put the ``requires`` clause together with the class or function; declaration. .. code-block:: c++. template <typename T>; requires C<T> struct Foo {... template <typename T>; requires C<T> void bar(T t) {... template <typename T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <typename T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadge:`clang-format 16` :ref:`¶ <RequiresExpressionIndentation>`; The indentation used for requires expression bodies. Possible values:. * ``REI_OuterScope`` (in configuration: ``OuterScope``); Align requires expression body relative to the indentation level of the; outer scope the requires expression resides in.; This",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:105548,config,configuration,105548,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"<arc.family.semantics.init>``. .. admonition:: Rationale. The cost of retaining ``self`` in all methods was found to be prohibitive, as; it tends to be live across calls, preventing the optimizer from proving that; the retain and release are unnecessary --- for good reason, as it's quite; possible in theory to cause an object to be deallocated during its execution; without this retain and release. Since it's extremely uncommon to actually; do so, even unintentionally, and since there's no natural way for the; programmer to remove this retain/release pair otherwise (as there is for; other parameters by, say, making the variable ``objc_externally_retained`` or; qualifying it with ``__unsafe_unretained``), we chose to make this optimizing; assumption and shift some amount of risk to the user. .. _arc.misc.enumeration:. Fast enumeration iteration variables; ------------------------------------. If a variable is declared in the condition of an Objective-C fast enumeration; loop, and the variable has no explicit ownership qualifier, then it is; implicitly :ref:`externally-retained <arc.misc.externally_retained>` so that; objects encountered during the enumeration are not actually retained and; released. .. admonition:: Rationale. This is an optimization made possible because fast enumeration loops promise; to keep the objects retained during enumeration, and the collection itself; cannot be synchronously modified. It can be overridden by explicitly; qualifying the variable with ``__strong``, which will make the variable; mutable again and cause the loop to retain the objects it encounters. .. _arc.misc.blocks:. Blocks; ------. The implicit ``const`` capture variables created when evaluating a block; literal expression have the same ownership semantics as the local variables; they capture. The capture is performed by reading from the captured variable; and initializing the capture variable with that value; the capture variable is; destroyed when the block literal is, i.e. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:95453,variab,variable,95453,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['variab'],['variable']
Modifiability,"<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34569,config,config,34569,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['config']
Modifiability,"<script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; ```. Loading main module is enough to get public JSROOT functionality - reading files and drawing objects.; One also can load some special components directly like:. ```javascript; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; ```. After script loading one can configure different parameters in `gStyle` object.; It is instance of the `TStyle` object and behaves like `gStyle` variable in ROOT. For instance,; to change stat format using to display value in stats box:. ```javascript; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; ```. There is also `settings` object which contains all other JSROOT settings. For instance,; one can configure custom format for different axes:. ```javascript; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; ```. One also can use `build/jsroot.js` bundle to load all functionality at one and access it via `JSROOT` global handle:. ```javascript; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; ```. ### Use of JSON. It is strongly recommended to use JSON when communicating with ROOT application.; THttpServer provide",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:35718,variab,variable,35718,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['variab'],['variable']
Modifiability,"= ""\t.word\t"";; Data64bitsDirective = 0; // .xword is only supported by V9.; ZeroDirective = ""\t.skip\t"";; CommentString = ""!"";; ConstantPoolSection = ""\t.section \"".rodata\"",#alloc\n"";; }. The X86 assembly printer implementation (``X86TargetAsmInfo``) is an example; where the target specific ``TargetAsmInfo`` class uses an overridden methods:; ``ExpandInlineAsm``. A target-specific implementation of ``AsmPrinter`` is written in; ``XXXAsmPrinter.cpp``, which implements the ``AsmPrinter`` class that converts; the LLVM to printable assembly. The implementation must include the following; headers that have declarations for the ``AsmPrinter`` and; ``MachineFunctionPass`` classes. The ``MachineFunctionPass`` is a subclass of; ``FunctionPass``. .. code-block:: c++. #include ""llvm/CodeGen/AsmPrinter.h""; #include ""llvm/CodeGen/MachineFunctionPass.h"". As a ``FunctionPass``, ``AsmPrinter`` first calls ``doInitialization`` to set; up the ``AsmPrinter``. In ``SparcAsmPrinter``, a ``Mangler`` object is; instantiated to process variable names. In ``XXXAsmPrinter.cpp``, the ``runOnMachineFunction`` method (declared in; ``MachineFunctionPass``) must be implemented for ``XXXAsmPrinter``. In; ``MachineFunctionPass``, the ``runOnFunction`` method invokes; ``runOnMachineFunction``. Target-specific implementations of; ``runOnMachineFunction`` differ, but generally do the following to process each; machine function:. * Call ``SetupMachineFunction`` to perform initialization. * Call ``EmitConstantPool`` to print out (to the output stream) constants which; have been spilled to memory. * Call ``EmitJumpTableInfo`` to print out jump tables used by the current; function. * Print out the label for the current function. * Print out the code for the function, including basic block labels and the; assembly for the instruction (using ``printInstruction``). The ``XXXAsmPrinter`` implementation must also include the code generated by; TableGen that is output in the ``XXXGenAsmWriter.inc`` file. The c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:69096,variab,variable,69096,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['variab'],['variable']
Modifiability,"= 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<VarDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:128519,variab,variable,128519,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"= chain.GetEntries();; for (Int_t i=0;i<nevent;i++) {; // read complete accepted event in memory; chain.GetEvent(i);; // Fill histogram with number of segments; hnseg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; ```. ### TChain::AddFriend; \index{tree!friend}. `A `**`TChain`** has a list of friends similar to a tree (see; `TTree::AddFriend)`. You can add a friend to a chain with the; `TChain::AddFriend` method. With `TChain::GetListOfFriends` you can; retrieve the list of friends. The next example has four chains each has; 20 ROOT trees from 20 ROOT files. ``` {.cpp}; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; ```. Now we can add the friends to the first chain. ``` {.cpp}; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; ```. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created). The original chain has; access to all variables in its friends. We can use the `TChain::Draw`; method as if the values in the friends were in the original chain. To; specify the chain to use in the `Draw` method, use:. ``` {.cpp}; <chainname>.<branchname>.<varname>; ```. If the variable name is enough to identify uniquely the variable, you; can leave out the chain and/or branch name. For example, this generates; a 3-d scatter plot of variable ""`var`"" in the `TChain ch` versus; variable `v1 in `**`TChain t1` versus variable `v2` in `TChain`**` t2`. ``` {.cpp}; ch.Draw(""var:t1.v1:t2.v2"");; ```. When a `TChain::Draw` is executed, an automatic call to; `TTree::AddFriend `connects the trees in the chain. When a chain; is deleted, its friend elements are also deleted. ![](pictures/02000108.jpg). The number of entries in the friend must be equal or greater to the; number of entries of the original chain. If the friend has fewer entries; a warning is given and the resulting histogram will have missing; entries. For addition",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:143289,variab,variables,143289,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"=""0""` (default). Note that once the index is built, it can be saved with the **`TTree`**; object with:. ``` {.cpp}; tree.Write(); //if the file has been open in ""update"" mode; ```. The most convenient place to create the index is at the end of the; filling process just before saving the tree header. If a previous index; was computed, it is redefined by this new call. Note that this function can also be applied to a **`TChain`**. The; return value is the number of entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the foll",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18448,variab,variable,18448,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"=-all,+cl_khr_fp16 test.cl. Note that some generic targets e.g. SPIR/SPIR-V enable all extensions/features in; clang by default. OpenCL Targets; --------------. OpenCL targets are derived from the regular Clang target classes. The OpenCL; specific parts of the target representation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. More details can be found in :ref:`the SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for the kernels; to support multiple work-item execution. For this, a 3rd party toolchain,; such as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multip",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:145535,portab,portable,145535,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['portab'],['portable']
Modifiability,"==//; In order to have the same logical functionality as the ELF Reader, such; as:. - find scopes contribution to debug info; - sort by its physical location. The logical elements must have an unique offset (similar like the DWARF; DIE offset). //===----------------------------------------------------------------------===//; // Move 'initializeFileAndStringTables' to the COFF Library.; //===----------------------------------------------------------------------===//; There is some code in the CodeView reader that was extracted/adapted; from 'tools/llvm-readobj/COFFDumper.cpp' that can be moved to the COFF; library. We had a similar case with code shared with llvm-pdbutil that was moved; to the PDB library: https://reviews.llvm.org/D122226. //===----------------------------------------------------------------------===//; // Move 'getSymbolKindName'/'formatRegisterId' to the CodeView Library.; //===----------------------------------------------------------------------===//; There is some code in the CodeView reader that was extracted/adapted; from 'lib/DebugInfo/CodeView/SymbolDumper.cpp' that can be used. //===----------------------------------------------------------------------===//; // Use of std::unordered_set instead of std::set.; //===----------------------------------------------------------------------===//; https://reviews.llvm.org/D125784#inline-1221421. Replace the std::set usage for DeducedScopes, UnresolvedScopes and; IdentifiedNamespaces with std::unordered_set and get the benefit; of the O(1) while inserting/searching, as the order is not important. //===----------------------------------------------------------------------===//; // Optimize 'LVNamespaceDeduction::find' funtion.; //===----------------------------------------------------------------------===//; https://reviews.llvm.org/D125784#inline-1296195. Optimize the 'find' method to use the proposed code:. LVStringRefs::iterator Iter = std::find_if(Components.begin(), Components.end(),; [](StringRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/README.txt:6113,adapt,adapted,6113,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/README.txt,1,['adapt'],['adapted']
Modifiability,"===----------------------------------------------------------------------===//. I suggest that we have the front-end fully lower out the ABI issues here to; LLVM IR. This makes it 100% explicit what is going on and means that there is; no cause for confusion. For example, the cases above should compile into:. define i32 @z() nounwind {; entry:; %0 = tail call i32 (...)* @y() nounwind; 	%1 = trunc i32 %0 to i16; %2 = sext i16 %1 to i32; ret i32 %2; }; define i32 @b() nounwind {; entry:; 	%0 = tail call i32 (...)* @a() nounwind; 	%retval12 = trunc i32 %0 to i16; 	%tmp = sext i16 %retval12 to i32; 	ret i32 %tmp; }. In this model, no functions will return an i1/i8/i16 (and on a x86-64 target; that extends results to i64, no i32). This solves the ambiguity issue, allows us ; to fully describe all possible ABIs, and now allows the optimizers to reason; about and eliminate these extensions. The one thing that is missing is the ability for the front-end and optimizer to; specify/infer the guarantees provided by the ABI to allow other optimizations.; For example, in the y/z case, since y is known to return a sign extended value,; the trunc/sext in z should be eliminable. This can be done by introducing new sext/zext attributes which mean ""I know; that the result of the function is sign extended at least N bits. Given this,; and given that it is stuck on the y function, the mid-level optimizer could; easily eliminate the extensions etc with existing functionality. The major disadvantage of doing this sort of thing is that it makes the ABI; lowering stuff even more explicit in the front-end, and that we would like to; eventually move to having the code generator do more of this work. However,; the sad truth of the matter is that this is a) unlikely to happen anytime in; the near future, and b) this is no worse than we have now with the existing; attributes. C compilers fundamentally have to reason about the target in many ways. ; This is ugly and horrible, but a fact of life. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt:4160,extend,extended,4160,interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,2,['extend'],['extended']
Modifiability,"===. Can I modify LLVM source code and redistribute the modified source?; -------------------------------------------------------------------; Yes. The modified source distribution must retain the copyright notice and; follow the conditions listed in the `Apache License v2.0 with LLVM Exceptions; <https://github.com/llvm/llvm-project/blob/main/llvm/LICENSE.TXT>`_. Can I modify the LLVM source code and redistribute binaries or other tools based on it, without redistributing the source?; --------------------------------------------------------------------------------------------------------------------------; Yes. This is why we distribute LLVM under a less restrictive license than GPL,; as explained in the first question above. Source Code; ===========. In what language is LLVM written?; ---------------------------------; All of the LLVM tools and libraries are written in C++ with extensive use of; the STL. How portable is the LLVM source code?; -------------------------------------; The LLVM source code should be portable to most modern Unix-like operating; systems. LLVM also has excellent support on Windows systems.; Most of the code is written in standard C++ with operating system; services abstracted to a support library. The tools required to build and; test LLVM have been ported to a plethora of platforms. What API do I use to store a value to one of the virtual registers in LLVM IR's SSA representation?; ---------------------------------------------------------------------------------------------------. In short: you can't. It's actually kind of a silly question once you grok; what's going on. Basically, in code like:. .. code-block:: llvm. %result = add i32 %foo, %bar. , ``%result`` is just a name given to the ``Value`` of the ``add``; instruction. In other words, ``%result`` *is* the add instruction. The; ""assignment"" doesn't explicitly ""store"" anything to any ""virtual register"";; the ""``=``"" is more like the mathematical sense of equality. Longer explanation",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:1063,portab,portable,1063,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,2,['portab'],['portable']
Modifiability,"===. Required passes; ---------------. A pass that defines a static ``isRequired()`` method that returns true is a required pass. For example:. .. code-block:: c++. class HelloWorldPass : public PassInfoMixin<HelloWorldPass> {; public:; PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);. static bool isRequired() { return true; }; };. A required pass is a pass that may not be skipped. An example of a required; pass is ``AlwaysInlinerPass``, which must always be run to preserve; ``alwaysinline`` semantics. Pass managers are required since they may contain; other required passes. An example of how a pass can be skipped is the ``optnone`` function; attribute, which specifies that optimizations should not be run on the; function. Required passes will still be run on ``optnone`` functions. For more implementation details, see; ``PassInstrumentation::runBeforePass()``. Registering passes as plugins; -----------------------------. LLVM provides a mechanism to register pass plugins within various tools like; ``clang`` or ``opt``. A pass plugin can add passes to default optimization; pipelines or to be manually run via tools like ``opt``. For more information,; see :doc:`NewPassManager`. Create a CMake project at the root of the repo alongside; other projects. This project must contain the following minimal; ``CMakeLists.txt``:. .. code-block:: cmake. add_llvm_pass_plugin(MyPassName source.cpp). See the definition of ``add_llvm_pass_plugin`` for more CMake details. The pass must provide at least one of two entry points for the new pass manager,; one for static registration and one for dynamically loaded plugins:. - ``llvm::PassPluginLibraryInfo get##Name##PluginInfo();``; - ``extern ""C"" ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo() LLVM_ATTRIBUTE_WEAK;``. Pass plugins are compiled and linked dynamically by default. Setting; ``LLVM_${NAME}_LINK_INTO_TOOLS`` to ``ON`` turns the project into a statically; linked extension. For an in-tree example, see ``llvm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:7408,plugin,plugins,7408,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,1,['plugin'],['plugins']
Modifiability,"==== ==========================================. .. note::. #. Only needed if you want to run the automated test suite in the; ``llvm/test`` directory.; #. Optional, adds compression / uncompression capabilities to selected LLVM; tools.; #. Optional, you can use any other build tool supported by CMake. Additionally, your compilation host is expected to have the usual plethora of; Unix utilities. Specifically:. * **ar** --- archive library builder; * **bzip2** --- bzip2 command for distribution generation; * **bunzip2** --- bunzip2 command for distribution checking; * **chmod** --- change permissions on a file; * **cat** --- output concatenation utility; * **cp** --- copy files; * **date** --- print the current date/time; * **echo** --- print to standard output; * **egrep** --- extended regular expression search utility; * **find** --- find files/dirs in a file system; * **grep** --- regular expression search utility; * **gzip** --- gzip command for distribution generation; * **gunzip** --- gunzip command for distribution checking; * **install** --- install directories/files; * **mkdir** --- create a directory; * **mv** --- move (rename) files; * **ranlib** --- symbol table builder for archive libraries; * **rm** --- remove (delete) files and directories; * **sed** --- stream editor for transforming output; * **sh** --- Bourne shell for make build scripts; * **tar** --- tape archive for distribution generation; * **test** --- test things in file system; * **unzip** --- unzip command for distribution checking; * **zip** --- zip command for distribution generation. .. _below:; .. _check here:. Host C++ Toolchain, both Compiler and Standard Library; ------------------------------------------------------. LLVM is very demanding of the host C++ compiler, and as such tends to expose; bugs in the compiler. We also attempt to follow improvements and developments in; the C++ language and library reasonably closely. As such, we require a modern; host C++ toolchain, both compile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:11851,extend,extended,11851,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['extend'],['extended']
Modifiability,===== ============= =============; Feature Feature Test Macro Introduced In Backported To; ====================================== ================================ ============= =============; variadic templates __cpp_variadic_templates C++11 C++03; Alias templates __cpp_alias_templates C++11 C++03; Non-static data member initializers __cpp_nsdmi C++11 C++03; Range-based ``for`` loop __cpp_range_based_for C++11 C++03; RValue references __cpp_rvalue_references C++11 C++03; Attributes __cpp_attributes C++11 C++03; variable templates __cpp_variable_templates C++14 C++03; Binary literals __cpp_binary_literals C++14 C++03; Relaxed constexpr __cpp_constexpr C++14 C++11; ``if constexpr`` __cpp_if_constexpr C++17 C++11; fold expressions __cpp_fold_expressions C++17 C++03; Lambda capture of \*this by value __cpp_capture_star_this C++17 C++11; Attributes on enums __cpp_enumerator_attributes C++17 C++03; Guaranteed copy elision __cpp_guaranteed_copy_elision C++17 C++03; Hexadecimal floating literals __cpp_hex_float C++17 C++03; ``inline`` variables __cpp_inline_variables C++17 C++03; Attributes on namespaces __cpp_namespace_attributes C++17 C++11; Structured bindings __cpp_structured_bindings C++17 C++03; template template arguments __cpp_template_template_args C++17 C++03; ``static operator[]`` __cpp_multidimensional_subscript C++20 C++03; Designated initializers __cpp_designated_initializers C++20 C++03; Conditional ``explicit`` __cpp_conditional_explicit C++20 C++03; ``using enum`` __cpp_using_enum C++20 C++03; ``if consteval`` __cpp_if_consteval C++23 C++20; ``static operator()`` __cpp_static_call_operator C++23 C++03; Attributes on Lambda-Expressions C++23 C++11; -------------------------------------- -------------------------------- ------------- -------------; Designated initializers (N494) C99 C89; Array & element qualification (N2607) C23 C89; Attributes (N2335) C23 C89; ====================================== ================================ ============= =============.,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:55918,variab,variables,55918,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variables']
Modifiability,"=======. Generating LLVM code for expression nodes is very straightforward: less; than 45 lines of commented code for all four of our expression nodes.; First we'll do numeric literals:. .. code-block:: c++. Value *NumberExprAST::codegen() {; return ConstantFP::get(*TheContext, APFloat(Val));; }. In the LLVM IR, numeric constants are represented with the; ``ConstantFP`` class, which holds the numeric value in an ``APFloat``; internally (``APFloat`` has the capability of holding floating point; constants of Arbitrary Precision). This code basically just creates; and returns a ``ConstantFP``. Note that in the LLVM IR that constants; are all uniqued together and shared. For this reason, the API uses the; ""foo::get(...)"" idiom instead of ""new foo(..)"" or ""foo::Create(..)"". .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; Value *V = NamedValues[Name];; if (!V); LogErrorV(""Unknown variable name"");; return V;; }. References to variables are also quite simple using LLVM. In the simple; version of Kaleidoscope, we assume that the variable has already been; emitted somewhere and its value is available. In practice, the only; values that can be in the ``NamedValues`` map are function arguments.; This code simply checks to see that the specified name is in the map (if; not, an unknown variable is being referenced) and returns the value for; it. In future chapters, we'll add support for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:5746,variab,variables,5746,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variables']
Modifiability,"========; ABI tags; ========. Introduction; ============. This text tries to describe gcc semantic for mangling ""abi_tag"" attributes; described in https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html. There is no guarantee the following rules are correct, complete or make sense; in any way as they were determined empirically by experiments with gcc5. Declaration; ===========. ABI tags are declared in an abi_tag attribute and can be applied to a; function, variable, class or inline namespace declaration. The attribute takes; one or more strings (called tags); the order does not matter. See https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html for; details. Tags on an inline namespace are called ""implicit tags"", all other tags are; ""explicit tags"". Mangling; ========. All tags that are ""active"" on an <unqualified-name> are emitted after the; <unqualified-name>, before <template-args> or <discriminator>, and are part of; the same <substitution> the <unqualified-name> is. They are mangled as:. .. code-block:: none. <abi-tags> ::= <abi-tag>* # sort by name; <abi-tag> ::= B <tag source-name>. Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:470,variab,variable,470,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,1,['variab'],['variable']
Modifiability,"========; GWP-ASan; ========. .. contents::; :local:; :depth: 2. Introduction; ============. GWP-ASan is a sampled allocator framework that assists in finding use-after-free; and heap-buffer-overflow bugs in production environments. It informally is a; recursive acronym, ""**G**\WP-ASan **W**\ill **P**\rovide **A**\llocation; **SAN**\ity"". GWP-ASan is based on the classic; `Electric Fence Malloc Debugger <https://linux.die.net/man/3/efence>`_, with a; key adaptation. Notably, we only choose a very small percentage of allocations; to sample, and apply guard pages to these sampled allocations only. The sampling; is small enough to allow us to have very low performance overhead. There is a small, tunable memory overhead that is fixed for the lifetime of the; process. This is approximately ~40KiB per process using the default settings,; depending on the average size of your allocations. GWP-ASan vs. ASan; =================. Unlike `AddressSanitizer <https://clang.llvm.org/docs/AddressSanitizer.html>`_,; GWP-ASan does not induce a significant performance overhead. ASan often requires; the use of dedicated canaries to be viable in production environments, and as; such is often impractical. GWP-ASan is only capable of finding a subset of the memory issues detected by; ASan. Furthermore, GWP-ASan's bug detection capabilities are only probabilistic.; As such, we recommend using ASan over GWP-ASan in testing, as well as anywhere; else that guaranteed error detection is more valuable than the 2x execution; slowdown/binary size bloat. For the majority of production environments, this; impact is too high, and GWP-ASan proves extremely useful. Design; ======. **Please note:** The implementation of GWP-ASan is largely in-flux, and these; details are subject to change. There are currently other implementations of; GWP-ASan, such as the implementation featured in; `Chromium <https://cs.chromium.org/chromium/src/components/gwp_asan/>`_. The; long-term support goal is to ensure feature-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:459,adapt,adaptation,459,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['adapt'],['adaptation']
Modifiability,"========; Overview; ========. Clang Tools are standalone command line (and potentially GUI) tools; designed for use by C++ developers who are already using and enjoying; Clang as their compiler. These tools provide developer-oriented; functionality such as fast syntax checking, automatic formatting,; refactoring, etc. Only a couple of the most basic and fundamental tools are kept in the; primary Clang tree. The rest of the tools are kept in a separate; directory tree, `clang-tools-extra; <https://github.com/llvm/llvm-project/tree/main/clang-tools-extra>`_. This document describes a high-level overview of the organization of; Clang Tools within the project as well as giving an introduction to some; of the more important tools. However, it should be noted that this; document is currently focused on Clang and Clang Tool developers, not on; end users of these tools. Clang Tools Organization; ========================. Clang Tools are CLI or GUI programs that are intended to be directly; used by C++ developers. That is they are *not* primarily for use by; Clang developers, although they are hopefully useful to C++ developers; who happen to work on Clang, and we try to actively dogfood their; functionality. They are developed in three components: the underlying; infrastructure for building a standalone tool based on Clang, core; shared logic used by many different tools in the form of refactoring and; rewriting libraries, and the tools themselves. The underlying infrastructure for Clang Tools is the; :doc:`LibTooling <LibTooling>` platform. See its documentation for much; more detailed information about how this infrastructure works. The; common refactoring and rewriting toolkit-style library is also part of; LibTooling organizationally. A few Clang Tools are developed along side the core Clang libraries as; examples and test cases of fundamental functionality. However, most of; the tools are developed in a side repository to provide easy separation; from the core libraries",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:302,refactor,refactoring,302,interpreter/llvm-project/clang/docs/ClangTools.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst,1,['refactor'],['refactoring']
Modifiability,"=========. As mentioned above, we generally have a strong preference for; builders which can build every commit as they come in. This section; includes best practices and some recommendations as to how to achieve; that end. The goal; In 2020, the monorepo had just under 35 thousand commits. This works; out to an average of 4 commits per hour. Already, we can see that a; builder must cycle in less than 15 minutes to have a hope of being; useful. However, those commits are not uniformly distributed. They; tend to cluster strongly during US working hours. Looking at a couple; of recent (Nov 2021) working days, we routinely see ~10 commits per; hour during peek times, with occasional spikes as high as ~15 commits; per hour. Thus, as a rule of thumb, we should plan for our builder to; complete ~10-15 builds an hour. Resource Appropriately; At 10-15 builds per hour, we need to complete a new build on average every; 4 to 6 minutes. For anything except the fastest of hardware/build configs,; this is going to be well beyond the ability of a single machine. In buildbot; terms, we likely going to need multiple workers to build requests in parallel; under a single builder configuration. For some rough back of the envelope; numbers, if your build config takes e.g. 30 minutes, you will need something; on the order of 5-8 workers. If your build config takes ~2 hours, you'll; need something on the order of 20-30 workers. The rest of this section; focuses on how to reduce cycle times. Restrict what you build and test; Think hard about why you're setting up a bot, and restrict your build; configuration as much as you can. Basic functionality is probably; already covered by other bots, and you don't need to duplicate that; testing. You only need to be building and testing the *unique* parts; of the configuration. (e.g. For a multi-stage clang builder, you probably; don't need to be enabling every target or building all the various utilities.). It can sometimes be worthwhile splitting a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:8851,config,configs,8851,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['configs']
Modifiability,"=========. Bytecode is executed using a stack-based interpreter. The execution; context consists of an ``InterpStack``, along with a chain of; ``InterpFrame`` objects storing the call frames. Frames are built by; call instructions and destroyed by return instructions. They perform; one allocation to reserve space for all locals in a single block.; These objects store all the required information to emit stack traces; whenever evaluation fails. Memory Organisation; ===================. Memory management in the interpreter relies on 3 data structures: ``Block``; objects which store the data and associated inline metadata, ``Pointer``; objects which refer to or into blocks, and ``Descriptor`` structures which; describe blocks and subobjects nested inside blocks. Blocks; ------. Blocks contain data interleaved with metadata. They are allocated either; statically in the code generator (globals, static members, dummy parameter; values etc.) or dynamically in the interpreter, when creating the frame; containing the local variables of a function. Blocks are associated with a; descriptor that characterises the entire allocation, along with a few; additional attributes:. * ``IsStatic`` indicates whether the block has static duration in the; interpreter, i.e. it is not a local in a frame. * ``DeclID`` identifies each global declaration (it is set to an invalid; and irrelevant value for locals) in order to prevent illegal writes and; reads involving globals and temporaries with static storage duration. Static blocks are never deallocated, but local ones might be deallocated; even when there are live pointers to them. Pointers are only valid as; long as the blocks they point to are valid, so a block with pointers to; it whose lifetime ends is kept alive until all pointers to it go out of; scope. Since the frame is destroyed on function exit, such blocks are; turned into a ``DeadBlock`` and copied to storage managed by the; interpreter itself, not the frame. Reads and writes to th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:4534,variab,variables,4534,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,1,['variab'],['variables']
Modifiability,"=========. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1056,variab,variables,1056,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['variab'],['variables']
Modifiability,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:427,variab,variables,427,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['variab'],['variables']
Modifiability,"============; Debug Checks; ============. .. contents::; :local:. The analyzer contains a number of checkers which can aid in debugging. Enable; them by using the ""-analyzer-checker="" flag, followed by the name of the; checker. General Analysis Dumpers; ========================. These checkers are used to dump the results of various infrastructural analyses; to stderr. Some checkers also have ""view"" variants, which will display a graph; using a 'dot' format viewer (such as Graphviz on macOS) instead. - debug.DumpCallGraph, debug.ViewCallGraph: Show the call graph generated for; the current translation unit. This is used to determine the order in which to; analyze functions when inlining is enabled. - debug.DumpCFG, debug.ViewCFG: Show the CFG generated for each top-level; function being analyzed. - debug.DumpDominators: Shows the dominance tree for the CFG of each top-level; function. - debug.DumpLiveVars: Show the results of live variable analysis for each; top-level function being analyzed. - debug.DumpLiveExprs: Show the results of live expression analysis for each; top-level function being analyzed. - debug.ViewExplodedGraph: Show the Exploded Graphs generated for the; analysis of different functions in the input translation unit. When there; are several functions analyzed, display one graph per function. Beware; that these graphs may grow very large, even for small functions. Path Tracking; =============. These checkers print information about the path taken by the analyzer engine. - debug.DumpCalls: Prints out every function or method call encountered during a; path traversal. This is indented to show the call stack, but does NOT do any; special handling of branches, meaning different paths could end up; interleaved. - debug.DumpTraversal: Prints the name of each branch statement encountered; during a path traversal (""IfStmt"", ""WhileStmt"", etc). Currently used to check; whether the analysis engine is doing BFS or DFS. State Checking; ==============. These check",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:945,variab,variable,945,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,1,['variab'],['variable']
Modifiability,"=============; Clang Plugins; =============. Clang Plugins make it possible to run extra user defined actions during a; compilation. This document will provide a basic walkthrough of how to write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:492,plugin,plugin,492,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,3,['plugin'],['plugin']
Modifiability,"=============; Type Metadata; =============. Type metadata is a mechanism that allows IR modules to co-operatively build; pointer sets corresponding to addresses within a given set of globals. LLVM's; `control flow integrity`_ implementation uses this metadata to efficiently; check (at each call site) that a given address corresponds to either a; valid vtable or function pointer for a given class or function type, and its; whole-program devirtualization pass uses the metadata to identify potential; callees for a given virtual call. To use the mechanism, a client creates metadata nodes with two elements:. 1. a byte offset into the global (generally zero for functions); 2. a metadata object representing an identifier for the type. These metadata nodes are associated with globals by using global object; metadata attachments with the ``!type`` metadata kind. Each type identifier must exclusively identify either global variables; or functions. .. admonition:: Limitation. The current implementation only supports attaching metadata to functions on; the x86-32 and x86-64 architectures. An intrinsic, :ref:`llvm.type.test <type.test>`, is used to test whether a; given pointer is associated with a type identifier. .. _control flow integrity: https://clang.llvm.org/docs/ControlFlowIntegrity.html. Representing Type Information using Type Metadata; =================================================. This section describes how Clang represents C++ type information associated with; virtual tables using type metadata. Consider the following inheritance hierarchy:. .. code-block:: c++. struct A {; virtual void f();; };. struct B : A {; virtual void f();; virtual void g();; };. struct C {; virtual void h();; };. struct D : A, C {; virtual void f();; virtual void h();; };. The virtual table objects for A, B, C and D look like this (under the Itanium ABI):. .. csv-table:: Virtual Table Layout for A, B, C, D; :header: Class, 0, 1, 2, 3, 4, 5, 6. A, A::offset-to-top, &A::rtti, &A::f; B, B::",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst:928,variab,variables,928,interpreter/llvm-project/llvm/docs/TypeMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst,1,['variab'],['variables']
Modifiability,"==============; SanitizerStats; ==============. .. contents::; :local:. Introduction; ============. The sanitizers support a simple mechanism for gathering profiling statistics; to help understand the overhead associated with sanitizers. How to build and run; ====================. SanitizerStats can currently only be used with :doc:`ControlFlowIntegrity`.; In addition to ``-fsanitize=cfi*``, pass the ``-fsanitize-stats`` flag.; This will cause the program to count the number of times that each control; flow integrity check in the program fires. At run time, set the ``SANITIZER_STATS_PATH`` environment variable to direct; statistics output to a file. The file will be written on process exit.; The following substitutions will be applied to the environment variable:. - ``%b`` -- The executable basename.; - ``%p`` -- The process ID. You can also send the ``SIGUSR2`` signal to a process to make it write; sanitizer statistics immediately. The ``sanstats`` program can be used to dump statistics. It takes as a; command line argument the path to a statistics file produced by a program; compiled with ``-fsanitize-stats``. The output of ``sanstats`` is in four columns, separated by spaces. The first; column is the file and line number of the call site. The second column is; the function name. The third column is the type of statistic gathered (in; this case, the type of control flow integrity check). The fourth column is; the call count. Example:. .. code-block:: console. $ cat -n vcall.cc; 1 struct A {; 2 virtual void f() {}; 3 };; 4; 5 __attribute__((noinline)) void g(A *a) {; 6 a->f();; 7 }; 8; 9 int main() {; 10 A a;; 11 g(&a);; 12 }; $ clang++ -fsanitize=cfi -fvisibility=hidden -flto -fuse-ld=gold vcall.cc -fsanitize-stats -g; $ SANITIZER_STATS_PATH=a.stats ./a.out; $ sanstats a.stats; vcall.cc:6 _Z1gP1A cfi-vcall 1; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst:609,variab,variable,609,interpreter/llvm-project/clang/docs/SanitizerStats.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst,2,['variab'],['variable']
Modifiability,"==============; lit Examples; ==============. This directory contains examples of 'lit' test suite configurations. The test; suites they define can be run with 'lit examples/example-name', for more details; see the README in each example.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/examples/README.txt:99,config,configurations,99,interpreter/llvm-project/llvm/utils/lit/examples/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/examples/README.txt,1,['config'],['configurations']
Modifiability,"===============. Introduction; ============. For benchmarking a patch we want to reduce all possible sources of; noise as much as possible. How to do that is very OS dependent. Note that low noise is required, but not sufficient. It does not; exclude measurement bias. See; https://www.cis.upenn.edu/~cis501/papers/producing-wrong-data.pdf for; example. General; ================================. * Use a high resolution timer, e.g. perf under linux. * Run the benchmark multiple times to be able to recognize noise. * Disable as many processes or services as possible on the target system. * Disable frequency scaling, turbo boost and address space; randomization (see OS specific section). * Static link if the OS supports it. That avoids any variation that; might be introduced by loading dynamic libraries. This can be done; by passing ``-DLLVM_BUILD_STATIC=ON`` to cmake. * Try to avoid storage. On some systems you can use tmpfs. Putting the; program, inputs and outputs on tmpfs avoids touching a real storage; system, which can have a pretty big variability. To mount it (on linux and freebsd at least)::. mount -t tmpfs -o size=<XX>g none dir_to_mount. Linux; =====. * Disable address space randomization::. echo 0 > /proc/sys/kernel/randomize_va_space. * Set scaling_governor to performance::. for i in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do; echo performance > /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; done. * Use https://github.com/lpechacek/cpuset to reserve cpus for just the; program you are benchmarking. If using perf, leave at least 2 cores; so that perf runs in one and your program in another::. cset shield -c N1,N2 -k on. This will move all threads out of N1 and N2. The ``-k on`` means; that even kernel threads are moved out. * Disable the SMT pair of the cpus you will use for the benchmark. The; pair of cpu N can be found in; ``/sys/devices/system/cpu/cpuN/topology/thread_siblings_list`` and; disabled with::. echo 0 > /sys/devices/system/c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Benchmarking.rst:1128,variab,variability,1128,interpreter/llvm-project/llvm/docs/Benchmarking.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Benchmarking.rst,1,['variab'],['variability']
Modifiability,"===============; Support Library; ===============. Abstract; ========. This document provides some details on LLVM's Support Library, located in the; source at ``lib/Support`` and ``include/llvm/Support``. The library's purpose; is to shield LLVM from the differences between operating systems for the few; services LLVM needs from the operating system. Much of LLVM is written using; portability features of standard C++. However, in a few areas, system dependent; facilities are needed and the Support Library is the wrapper around those; system calls. By centralizing LLVM's use of operating system interfaces, we make it possible; for the LLVM tool chain and runtime libraries to be more easily ported to new; platforms since (theoretically) only ``lib/Support`` needs to be ported. This; library also unclutters the rest of LLVM from #ifdef use and special cases for; specific operating systems. Such uses are replaced with simple calls to the; interfaces provided in ``include/llvm/Support``. Note that the Support Library is not intended to be a complete operating system; wrapper (such as the Adaptive Communications Environment (ACE) or Apache; Portable Runtime (APR)), but only provides the functionality necessary to; support LLVM. The Support Library was originally referred to as the System Library, written; by Reid Spencer who formulated the design based on similar work originating; from the eXtensible Programming System (XPS). Several people helped with the; effort; especially, Jeff Cohen and Henrik Bach on the Win32 port. Keeping LLVM Portable; =====================. In order to keep LLVM portable, LLVM developers should adhere to a set of; portability rules associated with the Support Library. Adherence to these rules; should help the Support Library achieve its goal of shielding LLVM from the; variations in operating system interfaces and doing so efficiently. The; following sections define the rules needed to fulfill this objective. Don't Include System Headers; ------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:385,portab,portability,385,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['portab'],['portability']
Modifiability,"===============; The LLVM gold plugin; ====================. Introduction; ============. Building with link time optimization requires cooperation from; the system linker. LTO support on Linux systems is available via the; `gold linker`_ which supports LTO via plugins. This is the same mechanism; used by the `GCC LTO`_ project. The LLVM gold plugin implements the gold plugin interface on top of; :ref:`libLTO`. The same plugin can also be used by other tools such as; ``ar`` and ``nm``. Note that ld.bfd from binutils version 2.21.51.0.2; and above also supports LTO via plugins. However, usage of the LLVM; gold plugin with ld.bfd is not tested and therefore not officially; supported or recommended. As of LLVM 15, the gold plugin will ignore bitcode from the ``.llvmbc``; section inside of ELF object files. However, LTO with bitcode files; is still supported. .. _`gold linker`: http://sourceware.org/binutils; .. _`GCC LTO`: http://gcc.gnu.org/wiki/LinkTimeOptimization; .. _`gold plugin interface`: http://gcc.gnu.org/wiki/whopr/driver. .. _lto-how-to-build:. How to build it; ===============. You need to have gold with plugin support and build the LLVMgold plugin.; The gold linker is installed as ld.gold. To see whether gold is the default; on your system, run ``/usr/bin/ld -v``. It will report ""GNU; gold"" or else ""GNU ld"" if not. If gold is already installed at; ``/usr/bin/ld.gold``, one option is to simply make that the default by; backing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:994,plugin,plugin,994,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin']
Modifiability,"================; AddressSanitizer; ================. .. contents::; :local:. Introduction; ============. AddressSanitizer is a fast memory error detector. It consists of a compiler; instrumentation module and a run-time library. The tool can detect the; following types of bugs:. * Out-of-bounds accesses to heap, stack and globals; * Use-after-free; * Use-after-return (clang flag ``-fsanitize-address-use-after-return=(never|runtime|always)`` default: ``runtime``); * Enable with: ``ASAN_OPTIONS=detect_stack_use_after_return=1`` (already enabled on Linux).; * Disable with: ``ASAN_OPTIONS=detect_stack_use_after_return=0``.; * Use-after-scope (clang flag ``-fsanitize-address-use-after-scope``); * Double-free, invalid free; * Memory leaks (experimental). Typical slowdown introduced by AddressSanitizer is **2x**. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>` and enable; the ``compiler-rt`` runtime. An example CMake configuration that will allow; for the use/testing of AddressSanitizer:. .. code-block:: console. $ cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=""clang"" -DLLVM_ENABLE_RUNTIMES=""compiler-rt"" <path to source>/llvm. Usage; =====. Simply compile and link your program with ``-fsanitize=address`` flag. The; AddressSanitizer run-time library should be linked to the final executable, so; make sure to use ``clang`` (not ``ld``) for the final link step. When linking; shared libraries, the AddressSanitizer run-time is not linked, so; ``-Wl,-z,defs`` may cause link errors (don't use it with AddressSanitizer). To; get a reasonable performance add ``-O1`` or higher. To get nicer stack traces; in error messages add ``-fno-omit-frame-pointer``. To get perfect stack traces; you may need to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat example_UseAfterFree.cc; int main(int argc, char **argv) {; int *array = new int[100];; delete [] array;; r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:970,config,configuration,970,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['config'],['configuration']
Modifiability,"================; Syntax Description; ======================================== ================================================; src1_sel:DWORD Use bits 31:0.; src1_sel:BYTE_0 Use bits 7:0.; src1_sel:BYTE_1 Use bits 15:8.; src1_sel:BYTE_2 Use bits 23:16.; src1_sel:BYTE_3 Use bits 31:24.; src1_sel:WORD_0 Use bits 15:0.; src1_sel:WORD_1 Use bits 31:16.; ======================================== ================================================. .. _amdgpu_synid_sdwa_operand_modifiers:. SDWA Operand Modifiers; ----------------------. Operand modifiers are not used separately. They are applied to source operands. abs; ~~~. See a description :ref:`here<amdgpu_synid_abs>`. neg; ~~~. See a description :ref:`here<amdgpu_synid_neg>`. .. _amdgpu_synid_sext:. sext; ~~~~. Sign-extends the value of a (sub-dword) integer operand to fill all 32 bits. Valid for integer operands only. ======================================== ================================================; Syntax Description; ======================================== ================================================; sext(<operand>) Sign-extend operand value.; ======================================== ================================================. Examples:. .. parsed-literal::. sext(v4); sext(v255). VOP3 Modifiers; --------------. .. _amdgpu_synid_vop3_op_sel:. op_sel; ~~~~~~. Selects the low [15:0] or high [31:16] operand bits for source and destination operands.; By default, low bits are used for all operands. The number of values specified with the op_sel modifier must match the number of instruction; operands (both source and destination). The first value controls src0, the second value controls src1; and so on, except that the last value controls destination.; The value 0 selects the low bits, while 1 selects the high bits. Note: op_sel modifier affects 16-bit operands only. For 32-bit operands, the value specified; by op_sel must be 0. ======================================== ===================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst:50707,extend,extend,50707,interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,1,['extend'],['extend']
Modifiability,"=================; HLSL IR Reference; =================. .. contents::; :local:. Introduction; ============. The goal of this document is to provide a reference for all the special purpose; IR metadata and attributes used by the HLSL code generation path. IR Metadata; ===========. ``hlsl.uavs``; -------------. The ``hlsl.uavs`` metadata is a list of all the external global variables that; represent UAV resources. Function Attributes; ===================. ``hlsl.shader``; ---------------. The ``hlsl.shader`` function attribute is a string attribute applied to entry; functions. The value is the string representation of the shader stage (i.e.; ``compute``, ``pixel``, etc).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLIRReference.rst:376,variab,variables,376,interpreter/llvm-project/clang/docs/HLSL/HLSLIRReference.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLIRReference.rst,1,['variab'],['variables']
Modifiability,"=================; TableGen Overview; =================. .. contents::; :local:. .. toctree::; :hidden:. BackEnds; BackGuide; ProgRef. Introduction; ============. TableGen's purpose is to help a human develop and maintain records of; domain-specific information. Because there may be a large number of these; records, it is specifically designed to allow writing flexible descriptions and; for common features of these records to be factored out. This reduces the; amount of duplication in the description, reduces the chance of error, and makes; it easier to structure domain specific information. The TableGen front end parses a file, instantiates the declarations, and; hands the result off to a domain-specific `backend`_ for processing. See; the :doc:`TableGen Programmer's Reference <./ProgRef>` for an in-depth; description of TableGen. See :doc:`tblgen - Description to C++ Code; <../CommandGuide/tblgen>` for details on the ``*-tblgen`` commands; that run the various flavors of TableGen. The current major users of TableGen are :doc:`The LLVM Target-Independent; Code Generator <../CodeGenerator>` and the `Clang diagnostics and attributes; <https://clang.llvm.org/docs/UsersManual.html#controlling-errors-and-warnings>`_. Note that if you work with TableGen frequently and use emacs or vim,; you can find an emacs ""TableGen mode"" and a vim language file in the; ``llvm/utils/emacs`` and ``llvm/utils/vim`` directories of your LLVM; distribution, respectively. .. _intro:. The TableGen program; ====================. TableGen files are interpreted by the TableGen program: `llvm-tblgen` available; on your build directory under `bin`. It is not installed in the system (or where; your sysroot is set to), since it has no use beyond LLVM's build process. Running TableGen; ----------------. TableGen runs just like any other LLVM tool. The first (optional) argument; specifies the file to read. If a filename is not specified, ``llvm-tblgen``; reads from standard input. To be useful, one of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst:363,flexible,flexible,363,interpreter/llvm-project/llvm/docs/TableGen/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst,1,['flexible'],['flexible']
Modifiability,"==================+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | flags | Flags used to indicate some features, mostly unused. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | char* | psource | Program source information, stored as "";filename;function;line;column;;\\0"" |; +---------+------------+-----------------------------------------------------------------------------+. If debugging information is enabled, we will also create strings to indicate the; names and declarations of variables mapped in target regions. These have the; same format as the source location in the :ref:`identifier structure; <table-ident_t_structure>`, but the function name is replaced with the variable; name. .. _Device Compilation:. Offload Device Compilation; --------------------------. The input file is compiled for each active device toolchain. The device; compilation stage is performed differently from the host stage. Namely, we do; not generate any offloading entries. This is set by passing the; ``-fopenmp-is-target-device`` flag to the front-end. We use the host bitcode to; determine which symbols to export from the device. The bitcode file is passed in; from the previous stage using the ``-fopenmp-host-ir-file-path`` flag.; Compilation is otherwise performed as it would be for any other target triple. When compiling for the OpenMP device, we set the visibility of all device; symbols to be ``protected`` by default. This improves performance a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:9890,variab,variables,9890,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['variab'],['variables']
Modifiability,"==================; Advice on Packaging LLVM; ========================. .. contents::; :local:. Overview; ========. LLVM sets certain default configure options to make sure our developers don't; break things for constrained platforms. These settings are not optimal for most; desktop systems, and we hope that packagers (e.g., Redhat, Debian, MacPorts,; etc.) will tweak them. This document lists settings we suggest you tweak. LLVM's API changes with each release, so users are likely to want, for example,; both LLVM-2.6 and LLVM-2.7 installed at the same time to support apps developed; against each. Compile Flags; =============. LLVM runs much more quickly when it's optimized and assertions are removed.; However, such a build is currently incompatible with users who build without; defining ``NDEBUG``, and the lack of assertions makes it hard to debug problems; in user code. We recommend allowing users to install both optimized and debug; versions of LLVM in parallel. The following configure flags are relevant:. ``--disable-assertions``; Builds LLVM with ``NDEBUG`` defined. Changes the LLVM ABI. Also available; by setting ``DISABLE_ASSERTIONS=0|1`` in ``make``'s environment. This; defaults to enabled regardless of the optimization setting, but it slows; things down. ``--enable-debug-symbols``; Builds LLVM with ``-g``. Also available by setting ``DEBUG_SYMBOLS=0|1`` in; ``make``'s environment. This defaults to disabled when optimizing, so you; should turn it back on to let users debug their programs. ``--enable-optimized``; (For git checkouts) Builds LLVM with ``-O2`` and, by default, turns off; debug symbols. Also available by setting ``ENABLE_OPTIMIZED=0|1`` in; ``make``'s environment. This defaults to enabled when not in a; checkout. C++ Features; ============. RTTI; LLVM disables RTTI by default. Add ``REQUIRES_RTTI=1`` to your environment; while running ``make`` to re-enable it. This will allow users to build with; RTTI enabled and still inherit from LLVM classes. Sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Packaging.rst:999,config,configure,999,interpreter/llvm-project/llvm/docs/Packaging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Packaging.rst,1,['config'],['configure']
Modifiability,"===================; LLVM Bug Life Cycle; ===================. .. contents::; :local:. Introduction - Achieving consistency in how we deal with bug reports; ====================================================================. We aim to achieve a basic level of consistency in how reported bugs evolve from; being reported, to being worked on, and finally getting closed out. The; consistency helps reporters, developers and others to gain a better; understanding of what a particular bug state actually means and what to expect; might happen next. At the same time, we aim to not over-specify the life cycle of bugs in; `the LLVM Bug Tracking System <https://github.com/llvm/llvm-project/issues>`_,; as the overall goal is to make it easier to work with and understand the bug; reports. The main parts of the life cycle documented here are:. #. `Reporting`_; #. `Triaging`_; #. `Actively working on fixing`_; #. `Closing`_. Furthermore, some of the metadata in the bug tracker, such as what labels we; use, needs to be maintained. See the following for details:. #. `Maintenance of metadata`_. .. _Reporting:. Reporting bugs; ==============. See :doc:`HowToSubmitABug` on further details on how to submit good bug reports. You can apply `labels <https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels>`_; to the bug to provide extra information to make the bug easier to discover, such; as a label for the part of the project the bug pertains to. .. _Triaging:. Triaging bugs; =============. Open bugs that have not been marked with the ``confirmed`` label are bugs that; still need to be triaged. When triage is complete, the ``confirmed`` label; should be added along with any other labels that help to classify the report,; unless the issue is being :ref:`closed<Closing>`. The goal of triaging a bug is to make sure a newly reported bug ends up in a; good, actionable state. Try to answer the following questions while triaging:. * Is the reported behavior ac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst:295,evolve,evolve,295,interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,1,['evolve'],['evolve']
Modifiability,"===================; Variable Names Plan; ===================. .. contents::; :local:. This plan is *provisional*. It is not agreed upon. It is written with the; intention of capturing the desires and concerns of the LLVM community, and; forming them into a plan that can be agreed upon.; The original author is somewhat naïve in the ways of LLVM so there will; inevitably be some details that are flawed. You can help - you can edit this; page (preferably with a Phabricator review for larger changes) or reply to the; `Request For Comments thread; <http://lists.llvm.org/pipermail/llvm-dev/2019-February/130083.html>`_. Too Long; Didn't Read; =====================. Improve the readability of LLVM code. Introduction; ============. The current `variable naming rule; <../CodingStandards.html#name-types-functions-variables-and-enumerators-properly>`_; states:. Variable names should be nouns (as they represent state). The name should be; camel case, and start with an upper case letter (e.g. Leader or Boats). This rule is the same as that for type names. This is a problem because the; type name cannot be reused for a variable name [*]_. LLVM developers tend to; work around this by either prepending ``The`` to the type name::. Triple TheTriple;. ... or more commonly use an acronym, despite the coding standard stating ""Avoid; abbreviations unless they are well known""::. Triple T;. The proliferation of acronyms leads to hard-to-read code such as `this; <https://github.com/llvm/llvm-project/blob/0a8bc14ad7f3209fe702d18e250194cd90188596/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L7445>`_::. InnerLoopVectorizer LB(L, PSE, LI, DT, TLI, TTI, AC, ORE, VF.Width, IC,; &LVL, &CM);. Many other coding guidelines [LLDB]_ [Google]_ [WebKit]_ [Qt]_ [Rust]_ [Swift]_; [Python]_ require that variable names begin with a lower case letter in contrast; to class names which begin with a capital letter. This convention means that the; most readable variable name also requires the least thought::. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:747,variab,variable,747,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,2,['variab'],"['variable', 'variables-and-enumerators-properly']"
Modifiability,"====================; The LLVM gold plugin; ====================. Introduction; ============. Building with link time optimization requires cooperation from; the system linker. LTO support on Linux systems is available via the; `gold linker`_ which supports LTO via plugins. This is the same mechanism; used by the `GCC LTO`_ project. The LLVM gold plugin implements the gold plugin interface on top of; :ref:`libLTO`. The same plugin can also be used by other tools such as; ``ar`` and ``nm``. Note that ld.bfd from binutils version 2.21.51.0.2; and above also supports LTO via plugins. However, usage of the LLVM; gold plugin with ld.bfd is not tested and therefore not officially; supported or recommended. As of LLVM 15, the gold plugin will ignore bitcode from the ``.llvmbc``; section inside of ELF object files. However, LTO with bitcode files; is still supported. .. _`gold linker`: http://sourceware.org/binutils; .. _`GCC LTO`: http://gcc.gnu.org/wiki/LinkTimeOptimization; .. _`gold plugin interface`: http://gcc.gnu.org/wiki/whopr/driver. .. _lto-how-to-build:. How to build it; ===============. You need to have gold with plugin support and build the LLVMgold plugin.; The gold linker is installed as ld.gold. To see whether gold is the default; on your system, run ``/usr/bin/ld -v``. It will report ""GNU; gold"" or else ""GNU ld"" if not. If gold is already installed at; ``/usr/bin/ld.gold``, one option is to simply make that the default by; backing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:36,plugin,plugin,36,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,8,['plugin'],"['plugin', 'plugins']"
Modifiability,"====================; Writing an LLVM Pass; ====================. .. program:: opt. .. contents::; :local:. Introduction --- What is a pass?; ================================. The LLVM Pass Framework is an important part of the LLVM system, because LLVM; passes are where most of the interesting parts of the compiler exist. Passes; perform the transformations and optimizations that make up the compiler, they; build the analysis results that are used by these transformations, and they; are, above all, a structuring technique for compiler code. All LLVM passes are subclasses of the `Pass; <https://llvm.org/doxygen/classllvm_1_1Pass.html>`_ class, which implement; functionality by overriding virtual methods inherited from ``Pass``. Depending; on how your pass works, you should inherit from the :ref:`ModulePass; <writing-an-llvm-pass-ModulePass>` , :ref:`CallGraphSCCPass; <writing-an-llvm-pass-CallGraphSCCPass>`, :ref:`FunctionPass; <writing-an-llvm-pass-FunctionPass>` , or :ref:`LoopPass; <writing-an-llvm-pass-LoopPass>`, or :ref:`RegionPass; <writing-an-llvm-pass-RegionPass>` classes, which gives the system more; information about what your pass does, and how it can be combined with other; passes. One of the main features of the LLVM Pass Framework is that it; schedules passes to run in an efficient way based on the constraints that your; pass meets (which are indicated by which class they derive from). We start by showing you how to construct a pass, everything from setting up the; code, to compiling, loading, and executing it. After the basics are down, more; advanced features are discussed. .. warning::; This document deals with the legacy pass manager. LLVM uses the new pass; manager for the optimization pipeline (the codegen pipeline; still uses the legacy pass manager), which has its own way of defining; passes. For more details, see :doc:`WritingAnLLVMNewPMPass` and; :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:713,inherit,inherited,713,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,2,['inherit'],"['inherit', 'inherited']"
Modifiability,"====================; Writing an LLVM Pass; ====================. .. program:: opt. .. contents::; :local:. Introduction --- What is a pass?; ================================. The LLVM pass framework is an important part of the LLVM system, because LLVM; passes are where most of the interesting parts of the compiler exist. Passes; perform the transformations and optimizations that make up the compiler, they; build the analysis results that are used by these transformations, and they; are, above all, a structuring technique for compiler code. Unlike passes under the legacy pass manager where the pass interface is; defined via inheritance, passes under the new pass manager rely on; concept-based polymorphism, meaning there is no explicit interface (see; comments in ``PassManager.h`` for more details). All LLVM passes inherit from; the CRTP mix-in ``PassInfoMixin<PassT>``. The pass should have a ``run()``; method which returns a ``PreservedAnalyses`` and takes in some unit of IR; along with an analysis manager. For example, a function pass would have a; ``PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);`` method. We start by showing you how to construct a pass, from setting up the build,; creating the pass, to executing and testing it. Looking at existing passes is; always a great way to learn details. .. warning::; This document deals with the new pass manager. LLVM uses the legacy pass; manager for the codegen pipeline. For more details, see; :doc:`WritingAnLLVMPass` and :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""HelloWorld""; pass is designed to simply print out the name of non-external functions that; exist in the program being compiled. It does not modify the program at all,; it just inspects it. The code below already exists; feel free to create a pass with a different; name alongside the HelloWorld source files. .. _writing-an-llvm-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:633,inherit,inheritance,633,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,3,"['inherit', 'polymorphi']","['inherit', 'inheritance', 'polymorphism']"
Modifiability,"=====================; Debugging JIT-ed Code; =====================. Background; ==========. Without special runtime support, debugging dynamically generated code can be; quite painful. Debuggers generally read debug information from object files on; disk, but for JITed code there is no such file to look for. In order to hand over the necessary debug info, `GDB established an; interface <https://sourceware.org/gdb/onlinedocs/gdb/JIT-Interface.html>`_; for registering JITed code with debuggers. LLDB implements it in the; JITLoaderGDB plugin. On the JIT side, LLVM MCJIT does implement the interface; for ELF object files. At a high level, whenever MCJIT generates new machine code, it does so in an; in-memory object file that contains the debug information in DWARF format.; MCJIT then adds this in-memory object file to a global list of dynamically; generated object files and calls a special function; ``__jit_debug_register_code`` that the debugger knows about. When the debugger; attaches to a process, it puts a breakpoint in this function and associates a; special handler with it. Once MCJIT calls the registration function, the; debugger catches the breakpoint signal, loads the new object file from the; inferior's memory and resumes execution. This way it can obtain debug; information for pure in-memory object files. GDB Version; ===========. In order to debug code JIT-ed by LLVM, you need GDB 7.0 or newer, which is; available on most modern distributions of Linux. The version of GDB that; Apple ships with Xcode has been frozen at 6.3 for a while. LLDB Version; ============. Due to a regression in release 6.0, LLDB didn't support JITed code debugging for; a while. The bug was fixed in mainline recently, so that debugging JITed ELF; objects should be possible again from the upcoming release 12.0 on. On macOS the; feature must be enabled explicitly using the ``plugin.jit-loader.gdb.enable``; setting. Debugging MCJIT-ed code; =======================. The emerging MCJIT comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DebuggingJITedCode.rst:539,plugin,plugin,539,interpreter/llvm-project/llvm/docs/DebuggingJITedCode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DebuggingJITedCode.rst,1,['plugin'],['plugin']
Modifiability,"=====================; LLVM Coding Standards; =====================. .. contents::; :local:. Introduction; ============. This document describes coding standards that are used in the LLVM project.; Although no coding standards should be regarded as absolute requirements to be; followed in all instances, coding standards are; particularly important for large-scale code bases that follow a library-based; design (like LLVM). While this document may provide guidance for some mechanical formatting issues,; whitespace, or other ""microscopic details"", these are not fixed standards.; Always follow the golden rule:. .. _Golden Rule:. **If you are extending, enhancing, or bug fixing already implemented code,; use the style that is already being used so that the source is uniform and; easy to follow.**. Note that some code bases (e.g. ``libc++``) have special reasons to deviate; from the coding standards. For example, in the case of ``libc++``, this is; because the naming and other conventions are dictated by the C++ standard. There are some conventions that are not uniformly followed in the code base; (e.g. the naming convention). This is because they are relatively new, and a; lot of code was written before they were put in place. Our long term goal is; for the entire codebase to follow the convention, but we explicitly *do not*; want patches that do large-scale reformatting of existing code. On the other; hand, it is reasonable to rename the methods of a class if you're about to; change it in some other way. Please commit such changes separately to; make code review easier. The ultimate goal of these guidelines is to increase the readability and; maintainability of our common source base. Languages, Libraries, and Standards; ===================================. Most source code in LLVM and other LLVM projects using these coding standards; is C++ code. There are some places where C code is used either due to; environment restrictions, historical restrictions, or due to third-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:646,extend,extending,646,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['extend'],['extending']
Modifiability,"====================== =============; BasicBlock block; ConstantExpr expr; ExecutionEngine engine; MachineOperand operand; OptimizationRemarkEmitter remarker; PreservedAnalyses analyses; PreservedAnalysesChecker checker; TargetLowering lowering; TargetMachine machine; ========================= =============. Transition Options; ==================. There are three main options for transitioning:. 1. Keep the current coding standard; 2. Laissez faire; 3. Big bang. Keep the current coding standard; --------------------------------. Proponents of keeping the current coding standard (i.e. not transitioning at; all) question whether the cost of transition outweighs the benefit; [EmersonConcern]_ [ReamesConcern]_ [BradburyConcern]_.; The costs are that ``git blame`` will become less usable; and that merging the; changes will be costly for downstream maintainers. See `Big bang`_ for potential; mitigations. Laissez faire; -------------. The coding standard could allow both ``CamelCase`` and ``camelBack`` styles for; variable names [LattnerTransition]_. A code review to implement this is at https://reviews.llvm.org/D57896. Advantages; **********. * Very easy to implement initially. Disadvantages; *************. * Leads to inconsistency [BradburyConcern]_ [AminiInconsistent]_.; * Inconsistency means it will be hard to know at a guess what name a variable; will have [DasInconsistent]_ [CarruthInconsistent]_.; * Some large-scale renaming may happen anyway, leading to its disadvantages; without any mitigations. Big bang; --------. With this approach, variables will be renamed by an automated script in a series; of large commits. The principle advantage of this approach is that it minimises the cost of; inconsistency [BradburyTransition]_ [RobinsonTransition]_. It goes against a policy of avoiding large-scale reformatting of existing code; [GreeneDistinguish]_. It has been suggested that LLD would be a good starter project for the renaming; [Ueyama]_. Keeping git blame usable; ***",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:8021,variab,variable,8021,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability,"======================. In the example above, every variable assignment uniquely corresponds to a; memory store to the variable's position on the stack. However in heavily; optimized code LLVM promotes most variables into SSA values, which can; eventually be placed in physical registers or memory locations. To track SSA; values through compilation, when objects are promoted to SSA values an; ``llvm.dbg.value`` intrinsic is created for each assignment, recording the; variable's new location. Compared with the ``llvm.dbg.declare`` intrinsic:. * A dbg.value terminates the effect of any preceding dbg.values for (any; overlapping fragments of) the specified variable.; * The dbg.value's position in the IR defines where in the instruction stream; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the program. For any; execution of the optimized program, the set of variable values presented to the; developer by the debugger should not show a state that would never have existed; in the execution of the unoptimized program, given the same input. Doing so; risks misleading the developer by reporting a state that does not exist,; damaging their understanding of the optimized program and undermining their; trust in the debugger. Sometimes perfectly preserving variable locations is not possible, often when a; redundant calculation is optimized out. In such cases, a ``llvm.dbg.value``; with operand ``poison`` should be used, to terminate earlier variable locations; and let the debugger present ``optimized out`` to the developer. Withholding; these potentially stale variable values from the developer diminishes the; amount of available debug information, but increases the reliability of the; remaining inf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:18898,variab,variables,18898,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"======================. The inputs for a fuzz target are generated via random mutations of a; :ref:`corpus <libfuzzer-corpus>`. There are a few options for the kinds of; mutations that a fuzzer in LLVM might want. .. _fuzzing-llvm-generic:. Generic Random Fuzzing; ----------------------. The most basic form of input mutation is to use the built in mutators of; LibFuzzer. These simply treat the input corpus as a bag of bits and make random; mutations. This type of fuzzer is good for stressing the surface layers of a; program, and is good at testing things like lexers, parsers, or binary; protocols. Some of the in-tree fuzzers that use this type of mutator are `clang-fuzzer`_,; `clang-format-fuzzer`_, `llvm-as-fuzzer`_, `llvm-dwarfdump-fuzzer`_,; `llvm-mc-assemble-fuzzer`_, and `llvm-mc-disassemble-fuzzer`_. .. _fuzzing-llvm-protobuf:. Structured Fuzzing using ``libprotobuf-mutator``; ------------------------------------------------. We can use libprotobuf-mutator_ in order to perform structured fuzzing and; stress deeper layers of programs. This works by defining a protobuf class that; translates arbitrary data into structurally interesting input. Specifically, we; use this to work with a subset of the C++ language and perform mutations that; produce valid C++ programs in order to exercise parts of clang that are more; interesting than parser error handling. To build this kind of fuzzer you need `protobuf`_ and its dependencies; installed, and you need to specify some extra flags when configuring the build; with :doc:`CMake <CMake>`. For example, `clang-proto-fuzzer`_ can be enabled by; adding ``-DCLANG_ENABLE_PROTO_FUZZER=ON`` to the flags described in; :ref:`building-fuzzers`. The only in-tree fuzzer that uses ``libprotobuf-mutator`` today is; `clang-proto-fuzzer`_. .. _libprotobuf-mutator: https://github.com/google/libprotobuf-mutator; .. _protobuf: https://github.com/google/protobuf. .. _fuzzing-llvm-ir:. Structured Fuzzing of LLVM IR; ---------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:6548,layers,layers,6548,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['layers'],['layers']
Modifiability,"======================; Control Flow Integrity; ======================. .. toctree::; :hidden:. ControlFlowIntegrityDesign. .. contents::; :local:. Introduction; ============. Clang includes an implementation of a number of control flow integrity (CFI); schemes, which are designed to abort the program upon detecting certain forms; of undefined behavior that can potentially allow attackers to subvert the; program's control flow. These schemes have been optimized for performance,; allowing developers to enable them in release builds. To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``.; You can also enable a subset of available :ref:`schemes <cfi-schemes>`.; As currently implemented, all schemes rely on link-time optimization (LTO);; so it is required to specify ``-flto``, and the linker used must support LTO,; for example via the `gold plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:868,plugin,plugin,868,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['plugin'],['plugin']
Modifiability,"=======================; LLVM Common CMake Utils; =======================. What goes here; --------------. These are CMake modules to be shared between LLVM projects strictly at build; time. In other words, they must not be included from an installed CMake module,; such as the ``Add*.cmake`` ones. Modules that are reachable from installed; modules should instead go in ``${project}/cmake/modules`` of the most upstream; project that uses them. The advantage of not putting these modules in an existing location like; ``llvm/cmake/modules`` is two-fold:. - Since they are not installed, we don't have to worry about any out-of-tree; downstream usage, and thus there is no need for stability. - Since they are available as part of the source at build-time, we don't have; to do the usual stand-alone vs combined-build dances, avoiding much; complexity. How to use; ----------. For tools, please do:. .. code-block:: cmake. if(NOT DEFINED LLVM_COMMON_CMAKE_UTILS); set(LLVM_COMMON_CMAKE_UTILS ${CMAKE_CURRENT_SOURCE_DIR}/../cmake); endif(). # Add path for custom modules.; list(INSERT CMAKE_MODULE_PATH 0; # project-specific module dirs first; ""${LLVM_COMMON_CMAKE_UTILS}/Modules""; ). Notes:. - The ``if(NOT DEFINED ...)`` guard is there because in combined builds, LLVM; will set this variable. This is useful for legacy builds where projects are; found in ``llvm/tools`` instead. - ``INSERT ... 0`` ensures these new entries are prepended to the front of the; module path, so nothing might shadow them by mistake. For runtime libs, we skip the ``if(NOT DEFINED`` part:. .. code-block:: cmake. set(LLVM_COMMON_CMAKE_UTILS ${CMAKE_CURRENT_SOURCE_DIR}/../cmake). ... # same as before. If ``llvm/tools`` legacy-style combined builds are deprecated, we should then; skip it everywhere, bringing the tools and runtimes boilerplate back in line.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/cmake/README.rst:1285,variab,variable,1285,interpreter/llvm-project/cmake/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/cmake/README.rst,1,['variab'],['variable']
Modifiability,"========================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1116,config,configuration,1116,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['configuration']
Modifiability,"========================; Advice on Packaging LLVM; ========================. .. contents::; :local:. Overview; ========. LLVM sets certain default configure options to make sure our developers don't; break things for constrained platforms. These settings are not optimal for most; desktop systems, and we hope that packagers (e.g., Redhat, Debian, MacPorts,; etc.) will tweak them. This document lists settings we suggest you tweak. LLVM's API changes with each release, so users are likely to want, for example,; both LLVM-2.6 and LLVM-2.7 installed at the same time to support apps developed; against each. Compile Flags; =============. LLVM runs much more quickly when it's optimized and assertions are removed.; However, such a build is currently incompatible with users who build without; defining ``NDEBUG``, and the lack of assertions makes it hard to debug problems; in user code. We recommend allowing users to install both optimized and debug; versions of LLVM in parallel. The following configure flags are relevant:. ``--disable-assertions``; Builds LLVM with ``NDEBUG`` defined. Changes the LLVM ABI. Also available; by setting ``DISABLE_ASSERTIONS=0|1`` in ``make``'s environment. This; defaults to enabled regardless of the optimization setting, but it slows; things down. ``--enable-debug-symbols``; Builds LLVM with ``-g``. Also available by setting ``DEBUG_SYMBOLS=0|1`` in; ``make``'s environment. This defaults to disabled when optimizing, so you; should turn it back on to let users debug their programs. ``--enable-optimized``; (For git checkouts) Builds LLVM with ``-O2`` and, by default, turns off; debug symbols. Also available by setting ``ENABLE_OPTIMIZED=0|1`` in; ``make``'s environment. This defaults to enabled when not in a; checkout. C++ Features; ============. RTTI; LLVM disables RTTI by default. Add ``REQUIRES_RTTI=1`` to your environment; while running ``make`` to re-enable it. This will allow users to build with; RTTI enabled and still inherit from LLVM class",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Packaging.rst:148,config,configure,148,interpreter/llvm-project/llvm/docs/Packaging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Packaging.rst,1,['config'],['configure']
Modifiability,"========================; Building LLVM with CMake; ========================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted`; page. This page is geared for existing contributors moving from the; legacy configure/make system. If you are really anxious about getting a functional LLVM build, go to the; `Quick start`_ section. If you are a CMake novice, start with `Basic CMake usage`_; and then go back to the `Quick start`_ section once you know what you are doing. The; `Options and variables`_ section is a reference for customizing your build. If; you already have experience with CMake, this is the recommended starting point. This page is geared towards users of the LLVM CMake build. If you're looking for; information about modifying the LLVM CMake build system you may want to see the; :doc:`CMakePrimer` page. It has a basic overview of the CMake language. .. _Quick start:. Quick start; ===========. We use here the command-line, non-interactive CMake interface. #. `Download <http://www.cmake.org/cmake/resources/software.html>`_ and install; CMake. Version 3.20.0 is the minimum required. #. Open a shell. Your development tools must be reachable from this shell; through the PATH environment variable. #. Create a build directory. Building LLVM in the source; directory is not supported. cd to this directory:. .. code-block:: console. $ mkdir mybuilddir; $ cd mybuilddir. #. Execute this command in the shell replacing `path/to/llvm/source/root` with; the path to the root of your LLVM source tree:. .. code-block:: console. $ cmake path/to/llvm/source/root. CMake will detect your development environment, perform a series of tests, and; generate the files required for building LLVM. CMake w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:496,config,configure,496,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,2,"['config', 'variab']","['configure', 'variables']"
Modifiability,"========================; Creating an LLVM Project; ========================. .. contents::; :local:. Overview; ========. The LLVM build system is designed to facilitate the building of third party; projects that use LLVM header files, libraries, and tools. In order to use; these facilities, a ``Makefile`` from a project must do the following things:. * Set ``make`` variables. There are several variables that a ``Makefile`` needs; to set to use the LLVM build system:. * ``PROJECT_NAME`` - The name by which your project is known.; * ``LLVM_SRC_ROOT`` - The root of the LLVM source tree.; * ``LLVM_OBJ_ROOT`` - The root of the LLVM object tree.; * ``PROJ_SRC_ROOT`` - The root of the project's source tree.; * ``PROJ_OBJ_ROOT`` - The root of the project's object tree.; * ``PROJ_INSTALL_ROOT`` - The root installation directory.; * ``LEVEL`` - The relative path from the current directory to the; project's root ``($PROJ_OBJ_ROOT)``. * Include ``Makefile.config`` from ``$(LLVM_OBJ_ROOT)``. * Include ``Makefile.rules`` from ``$(LLVM_SRC_ROOT)``. There are two ways that you can set all of these variables:. * You can write your own ``Makefiles`` which hard-code these values. * You can use the pre-made LLVM sample project. This sample project includes; ``Makefiles``, a configure script that can be used to configure the location; of LLVM, and the ability to support multiple object directories from a single; source directory. If you want to devise your own build system, studying other projects and LLVM; ``Makefiles`` will probably provide enough information on how to write your own; ``Makefiles``. Source Tree Layout; ==================. In order to use the LLVM build system, you will want to organize your source; code so that it can benefit from the build system's features. Mainly, you want; your source tree layout to look similar to the LLVM source tree layout. Underneath your top level directory, you should have the following directories:. **lib**. This subdirectory should contain",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:369,variab,variables,369,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,3,"['config', 'variab']","['config', 'variables']"
Modifiability,========================; Many Tests lit Example; ========================. This directory contains a trivial lit test suite configuration that defines a; custom test format which just generates a large (N=10000) number of tests that; do a small amount of work in the Python test execution code. This test suite is useful for testing the performance of lit on large numbers of; tests.; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/examples/many-tests/README.txt:125,config,configuration,125,interpreter/llvm-project/llvm/utils/lit/examples/many-tests/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/examples/many-tests/README.txt,1,['config'],['configuration']
Modifiability,"==========================; Clang Transformer Tutorial; ==========================. A tutorial on how to write a source-to-source translation tool using Clang Transformer. .. contents::; :local:. What is Clang Transformer?; --------------------------. Clang Transformer is a framework for writing C++ diagnostics and program; transformations. It is built on the clang toolchain and the LibTooling library,; but aims to hide much of the complexity of clang's native, low-level libraries. The core abstraction of Transformer is the *rewrite rule*, which specifies how; to change a given program pattern into a new form. Here are some examples of; tasks you can achieve with Transformer:. * warn against using the name ``MkX`` for a declared function,; * change ``MkX`` to ``MakeX``, where ``MkX`` is the name of a declared function,; * change ``s.size()`` to ``Size(s)``, where ``s`` is a ``string``,; * collapse ``e.child().m()`` to ``e.m()``, for any expression ``e`` and method named; ``m``. All of the examples have a common form: they identify a pattern that is the; target of the transformation, they specify an *edit* to the code identified by; the pattern, and their pattern and edit refer to common variables, like ``s``,; ``e``, and ``m``, that range over code fragments. Our first and second examples also; specify constraints on the pattern that aren't apparent from the syntax alone,; like ""``s`` is a ``string``."" Even the first example (""warn ..."") shares this form,; even though it doesn't change any of the code -- it's ""edit"" is simply a no-op. Transformer helps users succinctly specify rules of this sort and easily execute; them locally over a collection of files, apply them to selected portions of; a codebase, or even bundle them as a clang-tidy check for ongoing application. Who is Clang Transformer for?; -----------------------------. Clang Transformer is for developers who want to write clang-tidy checks or write; tools to modify a large number of C++ files in (roughly) t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:531,rewrite,rewrite,531,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:36,refactor,refactoring,36,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,9,['refactor'],"['refactoring', 'refactorings']"
Modifiability,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:395,config,configuration,395,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,7,"['config', 'extend']","['configuration', 'configuration-overview', 'extending']"
Modifiability,"=============================; Advanced Build Configurations; =============================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:704,config,configurations,704,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,3,['config'],"['configuration', 'configurations']"
Modifiability,"=============================; Introduction to the Clang AST; =============================. This document gives a gentle introduction to the mysteries of the Clang; AST. It is targeted at developers who either want to contribute to; Clang, or use tools that work based on Clang's AST, like the AST; matchers. .. raw:: html. <center><iframe width=""560"" height=""315"" src=""https://www.youtube.com/embed/VqCkCDFLSsc?vq=hd720"" frameborder=""0"" allowfullscreen></iframe></center>. `Slides <https://llvm.org/devmtg/2013-04/klimek-slides.pdf>`_. Introduction; ============. Clang's AST is different from ASTs produced by some other compilers in; that it closely resembles both the written C++ code and the C++; standard. For example, parenthesis expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5ae",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:864,refactor,refactoring,864,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,1,['refactor'],['refactoring']
Modifiability,"=============================; Offloading Design & Internals; =============================. .. contents::; :local:. Introduction; ============. This document describes the Clang driver and code generation steps for creating; offloading applications. Clang supports offloading to various architectures; using programming models like CUDA, HIP, and OpenMP. The purpose of this; document is to illustrate the steps necessary to create an offloading; application using Clang. OpenMP Offloading; =================. Clang supports OpenMP target offloading to several different architectures such; as NVPTX, AMDGPU, X86_64, Arm, and PowerPC. Offloading code is generated by; Clang and then executed using the ``libomptarget`` runtime and the associated; plugin for the target architecture, e.g. ``libomptarget.rtl.cuda``. This section; describes the steps necessary to create a functioning device image that can be; loaded by the OpenMP runtime. More information on the OpenMP runtimes can be; found at the `OpenMP documentation page <https://openmp.llvm.org>`__. .. _Offloading Overview:. Offloading Overview; -------------------. The goal of offloading compilation is to create an executable device image that; can be run on the target device. OpenMP offloading creates executable images by; compiling the input file for both the host and the target device. The output; from the device phase then needs to be embedded into the host to create a fat; object. A special tool then needs to extract the device code from the fat; objects, run the device linking step, and embed the final image in a symbol the; host runtime library can use to register the library and access the symbols on; the device. Compilation Process; ^^^^^^^^^^^^^^^^^^^. The compiler performs the following high-level actions to generate OpenMP; offloading code:. * Compile the input file for the host to produce a bitcode file. Lower ``#pragma; omp target`` declarations to :ref:`offloading entries <Generating Offloading; Entries>` and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:748,plugin,plugin,748,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['plugin'],['plugin']
Modifiability,"===============================. Introduction; ------------. Using PROOF on Demand is our current recommended way of running a PROOF; cluster. The usage of PoD is in particular helpful for the following; reasons:. - **Sandboxing.** Each user get their own personal PROOF cluster,; separated from the others: a problem occurring on one personal; cluster does not affect the workflow of other users. - **Easier administration and self-servicing.** A user can restart their; personal PROOF cluster in case of troubles without waiting for a; system administrator's intervention. - **Efficient multiuser scheduling.** PROOF on Demand makes PROOF run on; top of an existing resource management system, moving the problem of; scheduling many concurrent users outside of PROOF. This guide particularly refers to the setup of a static PROOF cluster; running on physical hosts: the recommended setup is in practice the same; as the ready-to-go Virtual Analysis Facility. If you want to use PROOF; on the clouds there is no configuration to go through. Setup a resource management system; ----------------------------------. Although PROOF on Demand can run on a cluster of nodes without using a; resource management system (using `pod-ssh`), it is recommended to setup a; dedicated one to benefit from the scheduling in a multiuser environment, or a; dedicated queue on an existing one. As there's a variety of resource management systems, this guide does not cover; their setup. The RMS preconfigured for the Virtual Analysis Facility is; [HTCondor](http://research.cs.wisc.edu/htcondor/), which we recommend primarily; because it has dynamic addition of workers built in. Configuration steps for all nodes; ---------------------------------. ### Setup CernVM-FS. [CernVM-FS](http://cernvm.cern.ch/portal/filesystem) should be installed; on all machines as the preferred method for software distribution. > Configuration instructions for the latest CernVM-FS can be found; > [here](http://cernvm.cern.ch/portal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:1082,config,configuration,1082,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['config'],['configuration']
Modifiability,"===============================; Assembling a Complete Toolchain; ===============================. .. contents::; :local:; :depth: 2. Introduction; ============. Clang is only one component in a complete tool chain for C family; programming languages. In order to assemble a complete toolchain,; additional tools and runtime libraries are required. Clang is designed; to interoperate with existing tools and libraries for its target; platforms, and the LLVM project provides alternatives for a number; of these components. This document describes the required and optional components in a; complete toolchain, where to find them, and the supported versions; and limitations of each option. .. warning::. This document currently describes Clang configurations on POSIX-like; operating systems with the GCC-compatible ``clang`` driver. When; targeting Windows with the MSVC-compatible ``clang-cl`` driver, some; of the details are different. Tools; =====. .. FIXME: Describe DWARF-related tools. A complete compilation of C family programming languages typically; involves the following pipeline of tools, some of which are omitted; in some compilations:. * **Preprocessor**: This performs the actions of the C preprocessor:; expanding #includes and #defines.; The ``-E`` flag instructs Clang to stop after this step. * **Parsing**: This parses and semantically analyzes the source language and; builds a source-level intermediate representation (""AST""), producing a; :ref:`precompiled header (PCH) <usersmanual-precompiled-headers>`,; preamble, or; :doc:`precompiled module file (PCM) <Modules>`,; depending on the input.; The ``-precompile`` flag instructs Clang to stop after this step. This is; the default when the input is a header file. * **IR generation**: This converts the source-level intermediate representation; into an optimizer-specific intermediate representation (IR); for Clang, this; is LLVM IR.; The ``-emit-llvm`` flag instructs Clang to stop after this step. If combined; with ``-S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:744,config,configurations,744,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['config'],['configurations']
Modifiability,"===============================; lit - A Software Testing Tool; ===============================. About; =====. *lit* is a portable tool for executing LLVM and Clang style test suites,; summarizing their results, and providing indication of failures. *lit* is; designed to be a lightweight testing tool with as simple a user interface as; possible. Features; ========. * Portable!; * Flexible test discovery.; * Parallel test execution.; * Support for multiple test formats and test suite designs. Documentation; =============. The official *lit* documentation is in the man page, available online at the LLVM; Command Guide: http://llvm.org/cmds/lit.html. Source; ======. The *lit* source is available as part of LLVM, in the LLVM source repository:; https://github.com/llvm/llvm-project/tree/main/llvm/utils/lit. Contributing to lit; ===================. Please browse the issues labeled *tools:llvm-lit* in LLVM's issue tracker for; ideas on what to work on:; https://github.com/llvm/llvm-project/labels/tools%3Allvm-lit. Before submitting patches, run the test suite to ensure nothing has regressed::. # From within your LLVM source directory.; utils/lit/lit.py \; --path /path/to/your/llvm/build/bin \; utils/lit/tests. Note that lit's tests depend on ``not`` and ``FileCheck``, LLVM utilities.; You will need to have built LLVM tools in order to run lit's test suite; successfully. You'll also want to confirm that lit continues to work when testing LLVM.; Follow the instructions in http://llvm.org/docs/TestingGuide.html to run the; regression test suite:. make check-llvm. And be sure to run the llvm-lit wrapper script as well:. /path/to/your/llvm/build/bin/llvm-lit utils/lit/tests. Finally, make sure lit works when installed via setuptools:. python utils/lit/setup.py install; lit --path /path/to/your/llvm/build/bin utils/lit/tests. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/README.rst:122,portab,portable,122,interpreter/llvm-project/llvm/utils/lit/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/README.rst,1,['portab'],['portable']
Modifiability,"================================. Introduction; ============. This document contains information about building and testing the builtins part; of compiler-rt for an Arm target, from an x86_64 Linux machine. While this document concentrates on Arm and Linux the general principles should; apply to other targets supported by compiler-rt. Further contributions for other; targets are welcome. The instructions in this document depend on libraries and programs external to; LLVM, there are many ways to install and configure these dependencies so you; may need to adapt the instructions here to fit your own local situation. Prerequisites; =============. In this use case we'll be using cmake on a Debian-based Linux system,; cross-compiling from an x86_64 host to a hard-float Armv7-A target. We'll be; using as many of the LLVM tools as we can, but it is possible to use GNU; equivalents. * ``A build of LLVM/clang for the llvm-tools and llvm-config``; * ``A clang executable with support for the ARM target``; * ``compiler-rt sources``; * ``The qemu-arm user mode emulator``; * ``An arm-linux-gnueabihf sysroot``. In this example we will be using ninja. See https://compiler-rt.llvm.org/ for more information about the dependencies; on clang and LLVM. See https://llvm.org/docs/GettingStarted.html for information about obtaining; the source for LLVM and compiler-rt. Note that the getting started guide; places compiler-rt in the projects subdirectory, but this is not essential and; if you are using the BaremetalARM.cmake cache for v6-M, v7-M and v7-EM then; compiler-rt must be placed in the runtimes directory. ``qemu-arm`` should be available as a package for your Linux distribution. The most complicated of the prerequisites to satisfy is the arm-linux-gnueabihf; sysroot. In theory it is possible to use the Linux distributions multiarch; support to fulfill the dependencies for building but unfortunately due to; /usr/local/include being added some host includes are selected. The easiest w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:1097,config,config,1097,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['config'],['config']
Modifiability,"=================================; CodeView Type Records; =====================================. .. contents::; :local:. .. _types_intro:. Introduction; ============. This document describes the usage and serialization format of the various; CodeView type records that LLVM understands. This document does not describe; every single CodeView type record that is defined. In some cases, this is; because the records are clearly deprecated and can only appear in very old; software (e.g. the 16-bit types). On other cases, it is because the records; have never been observed in practice. This could be because they are only; generated for non-C++ code (e.g. Visual Basic, C#), or because they have been; made obsolete by newer records, or any number of other reasons. However, the; records we describe here should cover 99% of type records that one can expect; to encounter when dealing with modern C++ toolchains. Record Categories; =================. We can think of a sequence of CodeView type records as an array of variable length; `leaf records`. Each such record describes its own length as part of a fixed-size; header, as well as the kind of record it is. Leaf records are either padded to 4; bytes (if this type stream appears in a TPI/IPI stream of a PDB) or not padded at; all (if this type stream appears in the ``.debug$T`` section of an object file).; Padding is implemented by inserting a decreasing sequence of `<_padding_records>`; that terminates with ``LF_PAD0``. The final category of record is a ``member record``. One particular leaf type --; ``LF_FIELDLIST`` -- contains a series of embedded records. While the outer; ``LF_FIELDLIST`` describes its length (like any other leaf record), the embedded; records -- called ``member records`` do not. .. _leaf_types:. Leaf Records; ------------. All leaf records begin with the following 4 byte prefix:. .. code-block:: c++. struct RecordHeader {; uint16_t RecordLen; // Record length, not including this 2 byte field.; uint16_t Recor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewTypes.rst:1023,variab,variable,1023,interpreter/llvm-project/llvm/docs/PDB/CodeViewTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewTypes.rst,1,['variab'],['variable']
Modifiability,"==================================; Stack Safety Analysis; ==================================. Introduction; ============. The Stack Safety Analysis determines if stack allocated variables can be; considered 'safe' from memory access bugs. The primary purpose of the analysis is to be used by sanitizers to avoid; unnecessary instrumentation of 'safe' variables. SafeStack is going to be the; first user. 'safe' variables can be defined as variables that can not be used out-of-scope; (e.g. use-after-return) or accessed out of bounds. In the future it can be; extended to track other variable properties. E.g. we plan to extend; implementation with a check to make sure that variable is always initialized; before every read to optimize use-of-uninitialized-memory checks. How it works; ============. The analysis is implemented in two stages:. The intra-procedural, or 'local', stage performs a depth-first search inside; functions to collect all uses of each alloca, including loads/stores and uses as; arguments functions. After this stage we know which parts of the alloca are used; by functions itself but we don't know what happens after it is passed as; an argument to another function. The inter-procedural, or 'global', stage, resolves what happens to allocas after; they are passed as function arguments. This stage performs a depth-first search; on function calls inside a single module and propagates allocas usage through; functions calls. When used with ThinLTO, the global stage performs a whole program analysis over; the Module Summary Index. Testing; =======. The analysis is covered with lit tests. We expect that users can tolerate false classification of variables as; 'unsafe' when in-fact it's 'safe'. This may lead to inefficient code. However, we; can't accept false 'safe' classification which may cause sanitizers to miss actual; bugs in instrumented code. To avoid that we want additional validation tool. AddressSanitizer may help with this validation. We can instrument ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackSafetyAnalysis.rst:179,variab,variables,179,interpreter/llvm-project/llvm/docs/StackSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackSafetyAnalysis.rst,8,"['extend', 'variab']","['extend', 'extended', 'variable', 'variables']"
Modifiability,"===================================. :program:`clang-format` supports two ways to provide custom style options:; directly specify style configuration in the ``-style=`` command line option or; use ``-style=file`` and put style configuration in the ``.clang-format`` or; ``_clang-format`` file in the project directory. When using ``-style=file``, :program:`clang-format` for each input file will; try to find the ``.clang-format`` file located in the closest parent directory; of the input file. When the standard input is used, the search is started from; the current directory. When using ``-style=file:<format_file_path>``, :program:`clang-format` for; each input file will use the format file located at `<format_file_path>`.; The path may be absolute or relative to the working directory. The ``.clang-format`` file uses YAML format:. .. code-block:: yaml. key1: value1; key2: value2; # A comment.; ... The configuration file can consist of several sections each having different; ``Language:`` parameter denoting the programming language this section of the; configuration is targeted at. See the description of the **Language** option; below for the list of supported languages. The first section may have no; language set, it will set the default style options for all languages.; Configuration sections for specific language will override options set in the; default section. When :program:`clang-format` formats a file, it auto-detects the language using; the file name. When formatting standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; Point",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:1979,config,configuration,1979,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,['config'],['configuration']
Modifiability,"===================================; How To Setup Clang Tooling For LLVM; ===================================. Clang Tooling provides infrastructure to write tools that need syntactic; and semantic information about a program. This term also relates to a set; of specific tools using this infrastructure (e.g. ``clang-check``). This; document provides information on how to set up and use Clang Tooling for; the LLVM source code. Introduction; ============. Clang Tooling needs a compilation database to figure out specific build; options for each file. Currently it can create a compilation database; from the ``compile_commands.json`` file, generated by CMake. When; invoking clang tools, you can either specify a path to a build directory; using a command line parameter ``-p`` or let Clang Tooling find this; file in your source tree. In either case you need to configure your; build using CMake to use clang tools. Setup Clang Tooling Using CMake and Make; ========================================. If you intend to use make to build LLVM, you should have CMake 2.8.6 or; later installed (can be found `here <https://cmake.org>`_). First, you need to generate Makefiles for LLVM with CMake. You need to; make a build directory and run CMake from it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang To",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:866,config,configure,866,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,1,['config'],['configure']
Modifiability,"====================================; JITLink and ORC's ObjectLinkingLayer; ====================================. .. contents::; :local:. Introduction; ============. This document aims to provide a high-level overview of the design and API; of the JITLink library. It assumes some familiarity with linking and; relocatable object files, but should not require deep expertise. If you know; what a section, symbol, and relocation are you should find this document; accessible. If it is not, please submit a patch (:doc:`Contributing`) or file a; bug (:doc:`HowToSubmitABug`). JITLink is a library for :ref:`jit_linking`. It was built to support the :doc:`ORC JIT; APIs<ORCv2>` and is most commonly accessed via ORC's ObjectLinkingLayer API. JITLink was; developed with the aim of supporting the full set of features provided by each; object format; including static initializers, exception handling, thread local; variables, and language runtime registration. Supporting these features enables; ORC to execute code generated from source languages which rely on these features; (e.g. C++ requires object format support for static initializers to support; static constructors, eh-frame registration for exceptions, and TLV support for; thread locals; Swift and Objective-C require language runtime registration for; many features). For some object format features support is provided entirely; within JITLink, and for others it is provided in cooperation with the; (prototype) ORC runtime. JITLink aims to support the following features, some of which are still under; development:. 1. Cross-process and cross-architecture linking of single relocatable objects; into a target *executor* process. 2. Support for all object format features. 3. Open linker data structures (``LinkGraph``) and pass system. JITLink and ObjectLinkingLayer; ==============================. ``ObjectLinkingLayer`` is ORCs wrapper for JITLink. It is an ORC layer that; allows objects to be added to a ``JITDylib``, or emitted from",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:912,variab,variables,912,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['variab'],['variables']
Modifiability,"=====================================. Writing a new alias analysis implementation for LLVM is quite straight-forward.; There are already several implementations that you can use for examples, and the; following information should help fill in any details. For examples, take a; look at the `various alias analysis implementations`_ included with LLVM. Different Pass styles; ---------------------. The first step to determining what type of :doc:`LLVM pass <WritingAnLLVMPass>`; you need to use for your Alias Analysis. As is the case with most other; analyses and transformations, the answer should be fairly obvious from what type; of problem you are trying to solve:. #. If you require interprocedural analysis, it should be a ``Pass``.; #. If you are a function-local analysis, subclass ``FunctionPass``.; #. If you don't need to look at the program at all, subclass ``ImmutablePass``. In addition to the pass that you subclass, you should also inherit from the; ``AliasAnalysis`` interface, of course, and use the ``RegisterAnalysisGroup``; template to register as an implementation of ``AliasAnalysis``. Required initialization calls; -----------------------------. Your subclass of ``AliasAnalysis`` is required to invoke two methods on the; ``AliasAnalysis`` base class: ``getAnalysisUsage`` and; ``InitializeAliasAnalysis``. In particular, your implementation of; ``getAnalysisUsage`` should explicitly call into the; ``AliasAnalysis::getAnalysisUsage`` method in addition to doing any declaring; any pass dependencies your pass has. Thus you should have something like this:. .. code-block:: c++. void getAnalysisUsage(AnalysisUsage &AU) const {; AliasAnalysis::getAnalysisUsage(AU);; // declare your dependencies here.; }. Additionally, your must invoke the ``InitializeAliasAnalysis`` method from your; analysis run method (``run`` for a ``Pass``, ``runOnFunction`` for a; ``FunctionPass``, or ``InitializePass`` for an ``ImmutablePass``). For example; (as part of a ``Pass``):. .. code-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:10498,inherit,inherit,10498,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['inherit'],['inherit']
Modifiability,"=====================================; Cross Translation Unit (CTU) Analysis; =====================================. Normally, static analysis works in the boundary of one translation unit (TU).; However, with additional steps and configuration we can enable the analysis to inline the definition of a function from; another TU. .. contents::; :local:. Overview; ________; CTU analysis can be used in a variety of ways. The importing of external TU definitions can work with pre-dumped PCH; files or generating the necessary AST structure on-demand, during the analysis of the main TU. Driving the static; analysis can also be implemented in multiple ways. The most direct way is to specify the necessary commandline options; of the Clang frontend manually (and generate the prerequisite dependencies of the specific import method by hand). This; process can be automated by other tools, like `CodeChecker <https://github.com/Ericsson/codechecker>`_ and scan-build-py; (preference for the former). PCH-based analysis; __________________; The analysis needs the PCH dumps of all the translations units used in the project.; These can be generated by the Clang Frontend itself, and must be arranged in a specific way in the filesystem.; The index, which maps symbols' USR names to PCH dumps containing them must also be generated by the; `clang-extdef-mapping`. Entries in the index *must* have an `.ast` suffix if the goal; is to use PCH-based analysis, as the lack of that extension signals that the entry is to be used as a source-file, and parsed on-demand.; This tool uses a :doc:`compilation database <../../JSONCompilationDatabase>` to; determine the compilation flags used.; The analysis invocation must be provided with the directory which contains the dumps and the mapping files. Manual CTU Analysis; ###################; Let's consider these source files in our minimal example:. .. code-block:: cpp. // main.cpp; int foo();. int main() {; return 3 / foo();; }. .. code-block:: cpp. // foo.c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:231,config,configuration,231,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,1,['config'],['configuration']
Modifiability,"=====================================; Garbage Collection with LLVM; =====================================. .. contents::; :local:. Abstract; ========. This document covers how to integrate LLVM into a compiler for a language which; supports garbage collection. **Note that LLVM itself does not provide a; garbage collector.** You must provide your own. Quick Start; ============. First, you should pick a collector strategy. LLVM includes a number of built; in ones, but you can also implement a loadable plugin with a custom definition.; Note that the collector strategy is a description of how LLVM should generate; code such that it interacts with your collector and runtime, not a description; of the collector itself. Next, mark your generated functions as using your chosen collector strategy.; From c++, you can call:. .. code-block:: c++. F.setGC(<collector description name>);. This will produce IR like the following fragment:. .. code-block:: llvm. define void @foo() gc ""<collector description name>"" { ... }. When generating LLVM IR for your functions, you will need to:. * Use ``@llvm.gcread`` and/or ``@llvm.gcwrite`` in place of standard load and; store instructions. These intrinsics are used to represent load and store; barriers. If you collector does not require such barriers, you can skip; this step. * Use the memory allocation routines provided by your garbage collector's; runtime library. * If your collector requires them, generate type maps according to your; runtime's binary interface. LLVM is not involved in the process. In; particular, the LLVM type system is not suitable for conveying such; information though the compiler. * Insert any coordination code required for interacting with your collector.; Many collectors require running application code to periodically check a; flag and conditionally call a runtime function. This is often referred to; as a safepoint poll. You will need to identify roots (i.e. references to heap objects your collector; needs to kno",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:506,plugin,plugin,506,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"=====================================; How to start LLVM Social in your town; =====================================. Here are several ideas you can take into account when designing your specific; LLVM Social. Before you start, it is essential to make sure that the meetup is as welcoming; as any other event related to LLVM. Therefore you shall follow LLVM's; `Code of Conduct <https://llvm.org/docs/CodeOfConduct.html>`_. Other than that - your mileage may vary. Please adapt your social to what works; best for your specific situation. General suggestions; -------------------. * We highly recommend that you join the official LLVM meetup organization. In; addition to covering the cost of the meetup, all LLVM meetups are advertised; together and easily found by potential attendees. Please contact; arnaud.degrandmaison@llvm.org for more details.; * Beware of cultural differences: what works well in one region may not work in; other part of the world.; * Do not be alone to organize the meetup. Try to work with a couple other; organizers. This is more motivating as an organizer, and this makes the; meetup more resilient over time.; * Each event can have a different form such as a social event, or; a hackathon/workshop, or a 'mini-conference' with one or more talks. You do; not have to stick to one format forever.; * Whatever format you choose, `LLVM Weekly <http://llvmweekly.org/>`_ is an; excellent topic starter: go through the 3-4 recent LLVM Weekly posts and; prepare a list of the most interesting/notable news and discuss them with the; group. Advertisement; -------------. * Try to advertise via similar meetups/user groups; * Advertise your meetup on the mailing lists (llvm-dev, cfe-dev, lldb-dev,; ...). Feel free to post to all of them, or at least to llvm-dev.; But as these mailing lists have high traffic and some LLVM developers are not; very active on them, you may reach more interested people using the mailing; feature from meetup.com.; * Advertise the meetup on Twitt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MeetupGuidelines.rst:471,adapt,adapt,471,interpreter/llvm-project/llvm/docs/MeetupGuidelines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MeetupGuidelines.rst,1,['adapt'],['adapt']
Modifiability,"=====================================; LLVM Code-Review Policy and Practices; =====================================. LLVM's code-review policy and practices help maintain high code quality across; the project. Specifically, our code review process aims to:. * Improve readability and maintainability.; * Improve robustness and prevent the introduction of defects.; * Best leverage the experience of other contributors for each proposed change.; * Help grow and develop new contributors, through mentorship by community leaders. It is important for all contributors to understand our code-review; practices and participate in the code-review process. General Policies; ================. What Code Should Be Reviewed?; -----------------------------. All developers are required to have significant changes reviewed before they; are committed to the repository. Must Code Be Reviewed Prior to Being Committed?; -----------------------------------------------. Code can be reviewed either before it is committed or after. We expect; significant patches to be reviewed before being committed. Smaller patches; (or patches where the developer owns the component) that meet; likely-community-consensus requirements (as apply to all patch approvals) can; be committed prior to an explicit review. In situations where there is any; uncertainty, a patch should be reviewed prior to being committed. Please note that the developer responsible for a patch is also; responsible for making all necessary review-related changes, including; those requested during any post-commit review. .. _post_commit_review:. Can Code Be Reviewed After It Is Committed?; -------------------------------------------. Post-commit review is encouraged, and can be accomplished using any of the; tools detailed below. There is a strong expectation that authors respond; promptly to post-commit feedback and address it. Failure to do so is cause for; the patch to be :ref:`reverted <revert_policy>`. If a community member expresses a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:284,maintainab,maintainability,284,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['maintainab'],['maintainability']
Modifiability,"======================================. .. contents::; :local:. Chapter 5 Introduction; ======================. Welcome to Chapter 5 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. Parts 1-4 described the implementation of; the simple Kaleidoscope language and included support for generating; LLVM IR, followed by optimizations and a JIT compiler. Unfortunately, as; presented, Kaleidoscope is mostly useless: it has no control flow other; than call and return. This means that you can't have conditional; branches in the code, significantly limiting its power. In this episode; of ""build that compiler"", we'll extend Kaleidoscope to have an; if/then/else expression plus a simple 'for' loop. If/Then/Else; ============. Extending Kaleidoscope to support if/then/else is quite straightforward.; It basically requires adding support for this ""new"" concept to the; lexer, parser, AST, and LLVM code emitter. This example is nice, because; it shows how easy it is to ""grow"" a language over time, incrementally; extending it as new ideas are discovered. Before we get going on ""how"" we add this extension, let's talk about; ""what"" we want. The basic idea is that we want to be able to write this; sort of thing:. ::. def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2);. In Kaleidoscope, every construct is an expression: there are no; statements. As such, the if/then/else expression needs to return a value; like any other. Since we're using a mostly functional form, we'll have; it evaluate its conditional, then return the 'then' or 'else' value; based on how the condition was resolved. This is very similar to the C; ""?:"" expression. The semantics of the if/then/else expression is that it evaluates the; condition to a boolean equality value: 0.0 is considered to be false and; everything else is considered to be true. If the condition is true, the; first subexpression is evaluated and returned, if the condition is; false, the second subexpression is evaluated and retu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:1147,extend,extending,1147,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['extend'],['extending']
Modifiability,"======================================; Kaleidoscope: Adding Debug Information; ======================================. .. contents::; :local:. Chapter 9 Introduction; ======================. Welcome to Chapter 9 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. In chapters 1 through 8, we've built a; decent little programming language with functions and variables.; What happens if something goes wrong though, how do you debug your; program?. Source level debugging uses formatted data that helps a debugger; translate from binary and the state of the machine back to the; source that the programmer wrote. In LLVM we generally use a format; called `DWARF <http://dwarfstd.org>`_. DWARF is a compact encoding; that represents types, source locations, and variable locations. The short summary of this chapter is that we'll go through the; various things you have to add to a programming language to; support debug info, and how you translate that into DWARF. Caveat: For now we can't debug via the JIT, so we'll need to compile; our program down to something small and standalone. As part of this; we'll make a few modifications to the running of the language and; how programs are compiled. This means that we'll have a source file; with a simple program written in Kaleidoscope rather than the; interactive JIT. It does involve a limitation that we can only; have one ""top level"" command at a time to reduce the number of; changes necessary. Here's the sample program we'll be compiling:. .. code-block:: python. def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2);. fib(10). Why is this a hard problem?; ===========================. Debug information is a hard problem for a few different reasons - mostly; centered around optimized code. First, optimization makes keeping source; locations more difficult. In LLVM IR we keep the original source location; for each IR level instruction on the instruction. Optimization passes; should keep the source locations for newly cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:377,variab,variables,377,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"======================================; test-suite Makefile Guide (deprecated); ======================================. .. contents::; :local:. Overview; ========. First, all tests are executed within the LLVM object directory tree.; They *are not* executed inside of the LLVM source tree. This is because; the test suite creates temporary files during execution. To run the test suite, you need to use the following steps:. #. Check out the ``test-suite`` module with:. .. code-block:: bash. % git clone https://github.com/llvm/llvm-test-suite.git test-suite. #. FIXME: these directions are outdated and won't work. Figure out; what the correct thing to do is, and write it down here. #. Configure and build ``llvm``. #. Configure and build ``llvm-gcc``. #. Install ``llvm-gcc`` somewhere. #. *Re-configure* ``llvm`` from the top level of each build tree (LLVM; object directory tree) in which you want to run the test suite, just; as you do before building LLVM. During the *re-configuration*, you must either: (1) have ``llvm-gcc``; you just built in your path, or (2) specify the directory where your; just-built ``llvm-gcc`` is installed using; ``--with-llvmgccdir=$LLVM_GCC_DIR``. You must also tell the configure machinery that the test suite is; available so it can be configured for your build tree:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT ; $LLVM_SRC_ROOT/configure [--with-llvmgccdir=$LLVM_GCC_DIR]. [Remember that ``$LLVM_GCC_DIR`` is the directory where you; *installed* llvm-gcc, not its src or obj directory.]. #. You can now run the test suite from your build tree as follows:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT/projects/test-suite; % make. Note that the second and third steps only need to be done once. After; you have the suite checked out and configured, you don't need to do it; again (unless the test code or configure script changes). Configuring External Tests; ==========================. In order to run the External tests in the ``test-suite`` module, you; must s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:798,config,configure,798,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['config'],['configure']
Modifiability,"=======================================. Reading an object with RNTuple should be seen as _overwriting_ its persistent data members.; Given a properly constructed and valid object, the object must ensure that it stays valid when overwriting its persistent data members.; However, the object should not rely on its transient state to remain unchanged during reading:; it may be destructed and constructed again when it is read as part of a collection (see below). An object that is being read from disk may have been constructed by `RField::CreateValue()`.; In this case, the deleter returned by `RField::GetDeleter()` releases the resources. When reading collections of type `T` (`std::vector<T>`, `ROOT::RVec<T>`, ...), RNTuple uses `RField::CreateValue()` to construct elements of the inner type `T`.; As the size of a collection changes from event to event, this has the following effect on its elements; - If the collection shrinks, cut-off elements are destructed; - If the collection grows, new elements are constructed before reading them; - If the array buffer of the collection is reallocated (may happen for both shrinking and growing depending on the collection), all elements are destructed first in the old buffer; and the new number of elements is constructed in the new buffer. So unless the collection buffer needs to be reallocated, RNTuple tries to avoid unnecessary destruction/construction but instead overwrites existing objects.; Note that RNTuple currently does not copy or move existing objects when the collection buffer is reallocated. Naming Conventions; ==================. For byte arrays and collections of things, the RNTuple code uses the following variable name suffixes:; - `XyzSize` denotes the size of Xyz in bytes on disk, i.e. after compression. Example: `fPageListSize`.; - `XyzLength` denotes the size of Xyz in bytes in memory, i.e. uncompressed. Example: `fPageListLength`.; - `NXyz` denotes the number of Xyz items in a collection. Example: `fNPageLists`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:31739,variab,variable,31739,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['variab'],['variable']
Modifiability,"========================================; Building a JIT: Adding Optimizations -- An introduction to ORC Layers; =====================================================================. .. contents::; :local:. **This tutorial is under active development. It is incomplete and details may; change frequently.** Nonetheless we invite you to try it out as it stands, and; we welcome any feedback. Chapter 2 Introduction; ======================. **Warning: This tutorial is currently being updated to account for ORC API; changes. Only Chapters 1 and 2 are up-to-date.**. **Example code from Chapters 3 to 5 will compile and run, but has not been; updated**. Welcome to Chapter 2 of the ""Building an ORC-based JIT in LLVM"" tutorial. In; `Chapter 1 <BuildingAJIT1.html>`_ of this series we examined a basic JIT; class, KaleidoscopeJIT, that could take LLVM IR modules as input and produce; executable code in memory. KaleidoscopeJIT was able to do this with relatively; little code by composing two off-the-shelf *ORC layers*: IRCompileLayer and; ObjectLinkingLayer, to do much of the heavy lifting. In this layer we'll learn more about the ORC layer concept by using a new layer,; IRTransformLayer, to add IR optimization support to KaleidoscopeJIT. Optimizing Modules using the IRTransformLayer; =============================================. In `Chapter 4 <LangImpl04.html>`_ of the ""Implementing a language with LLVM""; tutorial series the llvm *FunctionPassManager* is introduced as a means for; optimizing LLVM IR. Interested readers may read that chapter for details, but; in short: to optimize a Module we create an llvm::FunctionPassManager; instance, configure it with a set of optimizations, then run the PassManager on; a Module to mutate it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In this Chapter we will make optimi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:1040,layers,layers,1040,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['layers'],['layers']
Modifiability,"==========================================; Format Meaning; ====================== =============================================; *value* argument value; *value*\ ``:``\ *name* argument value and associated name; *name* argument name with unset (uninitialized) value; ====================== =============================================. The *value* can be any TableGen value. The *name*, if present, must be a; :token:`TokVarName`, which starts with a dollar sign (``$``). The purpose of; a name is to tag an operator or argument in a DAG with a particular meaning,; or to associate an argument in one DAG with a like-named argument in another; DAG. The following bang operators are useful for working with DAGs:; ``!con``, ``!dag``, ``!empty``, ``!foreach``, ``!getdagarg``, ``!getdagname``,; ``!getdagop``, ``!setdagarg``, ``!setdagname``, ``!setdagop``, ``!size``. Defvar in a record body; -----------------------. In addition to defining global variables, the ``defvar`` statement can; be used inside the :token:`Body` of a class or record definition to define; local variables. Template arguments of ``class`` or ``multiclass`` can be; used in the value expression. The scope of the variable extends from the; ``defvar`` statement to the end of the body. It cannot be set to a different; value within its scope. The ``defvar`` statement can also be used in the statement; list of a ``foreach``, which establishes a scope. A variable named ``V`` in an inner scope shadows (hides) any variables ``V``; in outer scopes. In particular, there are several cases:. * ``V`` in a record body shadows a global ``V``. * ``V`` in a record body shadows template argument ``V``. * ``V`` in template arguments shadows a global ``V``. * ``V`` in a ``foreach`` statement list shadows any ``V`` in surrounding record or; global scopes. Variables defined in a ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:52127,variab,variables,52127,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,2,['variab'],['variables']
Modifiability,"============================================; Implementation plans for ``-fbounds-safety``; ============================================. .. contents::; :local:. External bounds annotations; ===========================. The bounds annotations are C type attributes appertaining to pointer types. If; an attribute is added to the position of a declaration attribute, e.g., ``int; *ptr __counted_by(size)``, the attribute appertains to the outermost pointer; type of the declaration (``int *``). New sugar types; ===============. An external bounds annotation creates a type sugar of the underlying pointer; types. We will introduce a new sugar type, ``DynamicBoundsPointerType`` to; represent ``__counted_by`` or ``__sized_by``. Using ``AttributedType`` would not; be sufficient because the type needs to hold the count or size expression as; well as some metadata necessary for analysis, while this type may be implemented; through inheritance from ``AttributedType``. Treating the annotations as type; sugars means two types with incompatible external bounds annotations may be; considered canonically the same types. This is sometimes necessary, for example,; to make the ``__counted_by`` and friends not participate in function; overloading. However, this design requires a separate logic to walk through the; entire type hierarchy to check type compatibility of bounds annotations. Late parsing for C; ==================. A bounds annotation such as ``__counted_by(count)`` can be added to type of a; struct field declaration where count is another field of the same struct; declared later. Similarly, the annotation may apply to type of a function; parameter declaration which precedes the parameter count in the same function.; This means parsing the argument of bounds annotations must be done after the; parser has the whole context of a struct or a function declaration. Clang has; late parsing logic for C++ declaration attributes that require late parsing,; while the C declaration attribut",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:932,inherit,inheritance,932,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['inherit'],['inheritance']
Modifiability,"==============================================; Kaleidoscope: Adding JIT and Optimizer Support; ==============================================. .. contents::; :local:. Chapter 4 Introduction; ======================. Welcome to Chapter 4 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. Chapters 1-3 described the implementation; of a simple language and added support for generating LLVM IR. This; chapter describes two new techniques: adding optimizer support to your; language, and adding JIT compiler support. These additions will; demonstrate how to get nice, efficient code for the Kaleidoscope; language. Trivial Constant Folding; ========================. Our demonstration for Chapter 3 is elegant and easy to extend.; Unfortunately, it does not produce wonderful code. The IRBuilder,; however, does give us obvious optimizations when compiling simple code:. ::. ready> def test(x) 1+2+x;; Read function definition:; define double @test(double %x) {; entry:; %addtmp = fadd double 3.000000e+00, %x; ret double %addtmp; }. This code is not a literal transcription of the AST built by parsing the; input. That would be:. ::. ready> def test(x) 1+2+x;; Read function definition:; define double @test(double %x) {; entry:; %addtmp = fadd double 2.000000e+00, 1.000000e+00; %addtmp1 = fadd double %addtmp, %x; ret double %addtmp1; }. Constant folding, as seen above, in particular, is a very common and; very important optimization: so much so that many language implementors; implement constant folding support in their AST representation. With LLVM, you don't need this support in the AST. Since all calls to; build LLVM IR go through the LLVM IR builder, the builder itself checked; to see if there was a constant folding opportunity when you call it. If; so, it just does the constant fold and return the constant instead of; creating an instruction. Well, that was easy :). In practice, we recommend always using; ``IRBuilder`` when generating code like this. It has no ""s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:739,extend,extend,739,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['extend'],['extend']
Modifiability,"==================================================; Kaleidoscope: Extending the Language: Control Flow; ==================================================. .. contents::; :local:. Chapter 5 Introduction; ======================. Welcome to Chapter 5 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. Parts 1-4 described the implementation of; the simple Kaleidoscope language and included support for generating; LLVM IR, followed by optimizations and a JIT compiler. Unfortunately, as; presented, Kaleidoscope is mostly useless: it has no control flow other; than call and return. This means that you can't have conditional; branches in the code, significantly limiting its power. In this episode; of ""build that compiler"", we'll extend Kaleidoscope to have an; if/then/else expression plus a simple 'for' loop. If/Then/Else; ============. Extending Kaleidoscope to support if/then/else is quite straightforward.; It basically requires adding support for this ""new"" concept to the; lexer, parser, AST, and LLVM code emitter. This example is nice, because; it shows how easy it is to ""grow"" a language over time, incrementally; extending it as new ideas are discovered. Before we get going on ""how"" we add this extension, let's talk about; ""what"" we want. The basic idea is that we want to be able to write this; sort of thing:. ::. def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2);. In Kaleidoscope, every construct is an expression: there are no; statements. As such, the if/then/else expression needs to return a value; like any other. Since we're using a mostly functional form, we'll have; it evaluate its conditional, then return the 'then' or 'else' value; based on how the condition was resolved. This is very similar to the C; ""?:"" expression. The semantics of the if/then/else expression is that it evaluates the; condition to a boolean equality value: 0.0 is considered to be false and; everything else is considered to be true. If the condition is true, the; first ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:750,extend,extend,750,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['extend'],['extend']
Modifiability,"=====================================================; Kaleidoscope: Kaleidoscope Introduction and the Lexer; =====================================================. .. contents::; :local:. The Kaleidoscope Language; =========================. This tutorial is illustrated with a toy language called; ""`Kaleidoscope <http://en.wikipedia.org/wiki/Kaleidoscope>`_"" (derived; from ""meaning beautiful, form, and view""). Kaleidoscope is a procedural; language that allows you to define functions, use conditionals, math,; etc. Over the course of the tutorial, we'll extend Kaleidoscope to; support the if/then/else construct, a for loop, user defined operators,; JIT compilation with a simple command line interface, debug info, etc. We want to keep things simple, so the only datatype in Kaleidoscope; is a 64-bit floating point type (aka 'double' in C parlance). As such,; all values are implicitly double precision and the language doesn't; require type declarations. This gives the language a very nice and; simple syntax. For example, the following simple example computes; `Fibonacci numbers: <http://en.wikipedia.org/wiki/Fibonacci_number>`_. ::. # Compute the x'th fibonacci number.; def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2). # This expression will compute the 40th number.; fib(40). We also allow Kaleidoscope to call into standard library functions - the; LLVM JIT makes this really easy. This means that you can use the; 'extern' keyword to define a function before you use it (this is also; useful for mutually recursive functions). For example:. ::. extern sin(arg);; extern cos(arg);; extern atan2(arg1 arg2);. atan2(sin(.4), cos(42)). A more interesting example is included in Chapter 6 where we write a; little Kaleidoscope application that `displays a Mandelbrot; Set <LangImpl06.html#kicking-the-tires>`_ at various levels of magnification. Let's dive into the implementation of this language!. The Lexer; =========. When it comes to implementing a language, the first thing n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:560,extend,extend,560,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,1,['extend'],['extend']
Modifiability,"======================================================; How To Add Your Build Configuration To LLVM Buildbot Infrastructure; ===================================================================. Introduction; ============. This document contains information about adding a build configuration and; buildbot-worker to private worker builder to LLVM Buildbot Infrastructure. Buildmasters; ============. There are two buildmasters running. * The main buildmaster at `<https://lab.llvm.org/buildbot>`_. All builders; attached to this machine will notify commit authors every time they break; the build.; * The staging buildmaster at `<https://lab.llvm.org/staging>`_. All builders; attached to this machine will be completely silent by default when the build; is broken. This buildmaster is reconfigured every two hours with any new; commits from the llvm-zorg repository. In order to remain connected to the main buildmaster (and thus notify; developers of failures), a builbot must:. * Be building a supported configuration. Builders for experimental backends; should generally be attached to staging buildmaster.; * Be able to keep up with new commits to the main branch, or at a minimum; recover to tip of tree within a couple of days of falling behind. Additionally, we encourage all bot owners to point their bots towards the; staging master during maintenance windows, instability troubleshooting, and; such. Roles & Expectations; ====================. Each buildbot has an owner who is the responsible party for addressing problems; which arise with said buildbot. We generally expect the bot owner to be; reasonably responsive. For some bots, the ownership responsibility is split between a ""resource owner""; who provides the underlying machine resource, and a ""configuration owner"" who; maintains the build configuration. Generally, operational responsibility lies; with the ""config owner"". We do expect ""resource owners"" - who are generally; the contact listed in a workers attributes - to proxy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:1020,config,configuration,1020,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['configuration']
Modifiability,"======================================================; How to set up LLVM-style RTTI for your class hierarchy; ======================================================. .. contents::. Background; ==========. LLVM avoids using C++'s built in RTTI. Instead, it pervasively uses its; own hand-rolled form of RTTI which is much more efficient and flexible,; although it requires a bit more work from you as a class author. A description of how to use LLVM-style RTTI from a client's perspective is; given in the `Programmer's Manual <ProgrammersManual.html#isa>`_. This; document, in contrast, discusses the steps you need to take as a class; hierarchy author to make LLVM-style RTTI available to your clients. Before diving in, make sure that you are familiar with the Object Oriented; Programming concept of ""`is-a`_"". .. _is-a: http://en.wikipedia.org/wiki/Is-a. Basic Setup; ===========. This section describes how to set up the most basic form of LLVM-style RTTI; (which is sufficient for 99.9% of the cases). We will set up LLVM-style; RTTI for this class hierarchy:. .. code-block:: c++. class Shape {; public:; Shape() {}; virtual double computeArea() = 0;; };. class Square : public Shape {; double SideLength;; public:; Square(double S) : SideLength(S) {}; double computeArea() override;; };. class Circle : public Shape {; double Radius;; public:; Circle(double R) : Radius(R) {}; double computeArea() override;; };. The most basic working setup for LLVM-style RTTI requires the following; steps:. #. In the header where you declare ``Shape``, you will want to ``#include; ""llvm/Support/Casting.h""``, which declares LLVM's RTTI templates. That; way your clients don't even have to think about it. .. code-block:: c++. #include ""llvm/Support/Casting.h"". #. In the base class, introduce an enum which discriminates all of the; different concrete classes in the hierarchy, and stash the enum value; somewhere in the base class. Here is the code after introducing this change:. .. code-block:: c++. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:342,flexible,flexible,342,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['flexible'],['flexible']
Modifiability,"============================================================; Extending LLVM: Adding instructions, intrinsics, types, etc.; ============================================================. Introduction and Warning; ========================. During the course of using LLVM, you may wish to customize it for your research; project or for experimentation. At this point, you may realize that you need to; add something to LLVM, whether it be a new fundamental type, a new intrinsic; function, or a whole new instruction. When you come to this realization, stop and think. Do you really need to extend; LLVM? Is it a new fundamental capability that LLVM does not support at its; current incarnation or can it be synthesized from already pre-existing LLVM; elements? If you are not sure, ask on the `LLVM forums; <https://discourse.llvm.org>`_. The reason is that; extending LLVM will get involved as you need to update all the different passes; that you intend to use with your extension, and there are ``many`` LLVM analyses; and transformations, so it may be quite a bit of work. Adding an `intrinsic function`_ is far easier than adding an; instruction, and is transparent to optimization passes. If your added; functionality can be expressed as a function call, an intrinsic function is the; method of choice for LLVM extension. Before you invest a significant amount of effort into a non-trivial extension,; **ask on the list** if what you are looking to do can be done with; already-existing infrastructure, or if maybe someone else is already working on; it. You will save yourself a lot of time and effort by doing so. .. _intrinsic function:. Adding a new intrinsic function; ===============================. Adding a new intrinsic function to LLVM is much easier than adding a new; instruction. Almost all extensions to LLVM should start as an intrinsic; function and then be turned into an instruction if warranted. #. ``llvm/docs/LangRef.html``:. Document the intrinsic. Decide whether it is cod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst:589,extend,extend,589,interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendingLLVM.rst,2,['extend'],"['extend', 'extending']"
Modifiability,"===================================================================; How To Add Your Build Configuration To LLVM Buildbot Infrastructure; ===================================================================. Introduction; ============. This document contains information about adding a build configuration and; buildbot-worker to private worker builder to LLVM Buildbot Infrastructure. Buildmasters; ============. There are two buildmasters running. * The main buildmaster at `<https://lab.llvm.org/buildbot>`_. All builders; attached to this machine will notify commit authors every time they break; the build.; * The staging buildmaster at `<https://lab.llvm.org/staging>`_. All builders; attached to this machine will be completely silent by default when the build; is broken. This buildmaster is reconfigured every two hours with any new; commits from the llvm-zorg repository. In order to remain connected to the main buildmaster (and thus notify; developers of failures), a builbot must:. * Be building a supported configuration. Builders for experimental backends; should generally be attached to staging buildmaster.; * Be able to keep up with new commits to the main branch, or at a minimum; recover to tip of tree within a couple of days of falling behind. Additionally, we encourage all bot owners to point their bots towards the; staging master during maintenance windows, instability troubleshooting, and; such. Roles & Expectations; ====================. Each buildbot has an owner who is the responsible party for addressing problems; which arise with said buildbot. We generally expect the bot owner to be; reasonably responsive. For some bots, the ownership responsibility is split between a ""resource owner""; who provides the underlying machine resource, and a ""configuration owner"" who; maintains the build configuration. Generally, operational responsibility lies; with the ""config owner"". We do expect ""resource owners"" - who are generally; the contact listed in a workers attribut",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:291,config,configuration,291,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['configuration']
Modifiability,"===================================================================; How to Cross Compile Compiler-rt Builtins For Arm; ===================================================================. Introduction; ============. This document contains information about building and testing the builtins part; of compiler-rt for an Arm target, from an x86_64 Linux machine. While this document concentrates on Arm and Linux the general principles should; apply to other targets supported by compiler-rt. Further contributions for other; targets are welcome. The instructions in this document depend on libraries and programs external to; LLVM, there are many ways to install and configure these dependencies so you; may need to adapt the instructions here to fit your own local situation. Prerequisites; =============. In this use case we'll be using cmake on a Debian-based Linux system,; cross-compiling from an x86_64 host to a hard-float Armv7-A target. We'll be; using as many of the LLVM tools as we can, but it is possible to use GNU; equivalents. * ``A build of LLVM/clang for the llvm-tools and llvm-config``; * ``A clang executable with support for the ARM target``; * ``compiler-rt sources``; * ``The qemu-arm user mode emulator``; * ``An arm-linux-gnueabihf sysroot``. In this example we will be using ninja. See https://compiler-rt.llvm.org/ for more information about the dependencies; on clang and LLVM. See https://llvm.org/docs/GettingStarted.html for information about obtaining; the source for LLVM and compiler-rt. Note that the getting started guide; places compiler-rt in the projects subdirectory, but this is not essential and; if you are using the BaremetalARM.cmake cache for v6-M, v7-M and v7-EM then; compiler-rt must be placed in the runtimes directory. ``qemu-arm`` should be available as a package for your Linux distribution. The most complicated of the prerequisites to satisfy is the arm-linux-gnueabihf; sysroot. In theory it is possible to use the Linux distributions multiarch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:667,config,configure,667,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,2,"['adapt', 'config']","['adapt', 'configure']"
Modifiability,"=======================================================================; Building a JIT: Extreme Laziness - Using LazyReexports to JIT from ASTs; =======================================================================. .. contents::; :local:. **This tutorial is under active development. It is incomplete and details may; change frequently.** Nonetheless we invite you to try it out as it stands, and; we welcome any feedback. Chapter 4 Introduction; ======================. Welcome to Chapter 4 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; chapter introduces custom MaterializationUnits and Layers, and the lazy; reexports API. Together these will be used to replace the CompileOnDemandLayer; from `Chapter 3 <BuildingAJIT3.html>`_ with a custom lazy-JITing scheme that JITs; directly from Kaleidoscope ASTs. **To be done:**. **(1) Describe the drawbacks of JITing from IR (have to compile to IR first,; which reduces the benefits of laziness).**. **(2) Describe CompileCallbackManagers and IndirectStubManagers in detail.**. **(3) Run through the implementation of addFunctionAST.**. Full Code Listing; =================. Here is the complete code listing for our running example that JITs lazily from; Kaleidoscope ASTS. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h; :language: c++. `Next: Remote-JITing -- Process-isolation and laziness-at-a-distance <BuildingAJIT5.html>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT4.rst:1325,config,config,1325,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT4.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT4.rst,1,['config'],['config']
Modifiability,"=> ""print""); | 0x00000002 | uint32_t HashData count; | 0x........ | uint32_t HashData[0] DIE offset; | 0x........ | uint32_t HashData[1] DIE offset; | 0x00000000 | uint32_t KeyType (end of hash chain); `------------'. Current testing with real world C++ binaries has shown that there is around 1; 32 bit hash collision per 100,000 name entries. Contents; ^^^^^^^^. As we said, we want to strictly define exactly what is included in the; different tables. For DWARF, we have 3 tables: ""``.apple_names``"",; ""``.apple_types``"", and ""``.apple_namespaces``"". ""``.apple_names``"" sections should contain an entry for each DWARF DIE whose; ``DW_TAG`` is a ``DW_TAG_label``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_subprogram`` that has address attributes: ``DW_AT_low_pc``,; ``DW_AT_high_pc``, ``DW_AT_ranges`` or ``DW_AT_entry_pc``. It also contains; ``DW_TAG_variable`` DIEs that have a ``DW_OP_addr`` in the location (global and; static variables). All global and static variables should be included,; including those scoped within functions and classes. For example using the; following code:. .. code-block:: c. static int var = 0;. void f (); {; static int var = 0;; }. Both of the static ``var`` variables would be included in the table. All; functions should emit both their full names and their basenames. For C or C++,; the full name is the mangled name (if available) which is usually in the; ``DW_AT_MIPS_linkage_name`` attribute, and the ``DW_AT_name`` contains the; function basename. If global or static variables have a mangled name in a; ``DW_AT_MIPS_linkage_name`` attribute, this should be emitted along with the; simple name found in the ``DW_AT_name`` attribute. ""``.apple_types``"" sections should contain an entry for each DWARF DIE whose; tag is one of:. * DW_TAG_array_type; * DW_TAG_class_type; * DW_TAG_enumeration_type; * DW_TAG_pointer_type; * DW_TAG_reference_type; * DW_TAG_string_type; * DW_TAG_structure_type; * DW_TAG_subroutine_type; * DW_TAG_typedef; * DW_TAG_union_typ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:77741,variab,variables,77741,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"=true`` this can allow for; tracing applications from start to end. Like all the other modes installed through ``__xray_log_select_mode(...)``, the; implementation can be configured through the ``__xray_log_init_mode(...)``; function, providing the mode string and the flag options. Basic-mode specific; defaults can be provided in the ``XRAY_BASIC_OPTIONS`` environment variable. Flight Data Recorder Mode; -------------------------. XRay supports a logging mode which allows the application to only capture a; fixed amount of memory's worth of events. Flight Data Recorder (FDR) mode works; very much like a plane's ""black box"" which keeps recording data to memory in a; fixed-size circular queue of buffers, and have the data available; programmatically until the buffers are finalized and flushed. To use FDR mode; on your application, you may set the ``xray_mode`` variable to ``xray-fdr`` in; the ``XRAY_OPTIONS`` environment variable. Additional options to the FDR mode; implementation can be provided in the ``XRAY_FDR_OPTIONS`` environment; variable. Programmatic configuration can be done by calling; ``__xray_log_init_mode(""xray-fdr"", <configuration string>)`` once it has been; selected/installed. When the buffers are flushed to disk, the result is a binary trace format; described by `XRay FDR format <XRayFDRFormat.html>`_. When FDR mode is on, it will keep writing and recycling memory buffers until; the logging implementation is finalized -- at which point it can be flushed and; re-initialised later. To do this programmatically, we follow the workflow; provided below:. .. code-block:: c++. // Patch the sleds, if we haven't yet.; auto patch_status = __xray_patch();. // Maybe handle the patch_status errors. // When we want to flush the log, we need to finalize it first, to give; // threads a chance to return buffers to the queue.; auto finalize_status = __xray_log_finalize();; if (finalize_status != XRAY_LOG_FINALIZED) {; // maybe retry, or bail out.; }. // At this point, w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:9428,variab,variable,9428,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['variab'],['variable']
Modifiability,"=x=9.09989, mean=m=-7.39713, sigma=sx=0.1; getLogVal() top-level p.d.f evaluates to zero or negative number @ x=x=6.04652, mean=m=-7.39713, sigma=sx=0.1; getLogVal() top-level p.d.f evaluates to zero or negative number @ x=x=2.48563, mean=m=-7.39713, sigma=sx=0.1. The new-style error logging is active whenever MINUIT is operating on such a p.d.f. The default value for N is 3.; Outside the MINUIT context the evaluation error each evualuation error will generate a separate message through; RooMsgService; Other new features. The RooAddPdf constructor has been augmented with an additional boolean argument that allows to; interpret the supplied fraction parameters as recursive fractions rather than plain fractions.; If activated, an example RooAddPdf with three input p.d.f. A,B,C and two fractions fA and fB will; result in the expression; fA*A + (1-fA)(fB*B + 1-fB*C) rather than fA*A + fB*B + (1-fA-fB)*C. Recursive fraction have the advantage that all fraction can be defined to be in the range [0-1]; without resulting in configuration where the sum of all fractions exceeds 1.; The low-level object printing interface printToStream() has been deprecated in favor of a new; printStream() method which allows much greater control over the information printed. ; The printing of almost all RooFit objects has been reworked to present a more uniform look and feel.; The standard one-line result of the high-level Print() method without option now looks like. // Variable; x.Print() ;; RooRealVar::x = 0 L(-10 - 10) . // Function or p.d.f; gx.Print() ;; RooGaussian::gx[ x=x mean=m sigma=sx ] = 1. // Dataset; d.Print() ;; RooDataSet::gData[x,y] = 1000 entries. // RooPlot; frame.Print() ;; framex[x] = (RooHist::h_gData,RooCurve::g_Int[y]_Norm[x,y]_Comp[g]). Inside class RooPlot the default name of contained curves and histograms has been ; reworked in something more self descriptive as is shown in the above example. A usual,; a user supplied name can always be set by supplying the Name(c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:18118,config,configuration,18118,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['config'],['configuration']
Modifiability,">. For all options that dump information from each module/compiland, limit to; the specified module. .. option:: -files. Dump the source files that contribute to each displayed module. .. option:: -il. Dump inlinee line information (DEBUG_S_INLINEELINES CodeView subsection). .. option:: -l. Dump line information (DEBUG_S_LINES CodeView subsection). .. option:: -modules. Dump compiland information. .. option:: -xme. Dump cross module exports (DEBUG_S_CROSSSCOPEEXPORTS CodeView subsection). .. option:: -xmi. Dump cross module imports (DEBUG_S_CROSSSCOPEIMPORTS CodeView subsection). Symbol Options; ++++++++++++++. .. option:: -globals. dump global symbol records. .. option:: -global-extras. dump additional information about the globals, such as hash buckets and hash; values. .. option:: -publics. dump public symbol records. .. option:: -public-extras. dump additional information about the publics, such as hash buckets and hash; values. .. option:: -symbols. dump symbols (functions, variables, etc) for each module dumped. .. option:: -sym-data. For each symbol record dumped as a result of the :option:`-symbols` option,; display the full bytes of the record in binary as well. Type Record Options; +++++++++++++++++++. .. option:: -types. Dump CodeView type records from TPI stream. .. option:: -type-extras. Dump additional information from the TPI stream, such as hashes and the type; index offsets array. .. option:: -type-data. For each type record dumped, display the full bytes of the record in binary as; well. .. option:: -type-index=<uint>. Only dump types with the specified type index. .. option:: -ids. Dump CodeView type records from IPI stream. .. option:: -id-extras. Dump additional information from the IPI stream, such as hashes and the type; index offsets array. .. option:: -id-data. For each ID record dumped, display the full bytes of the record in binary as; well. .. option:: -id-index=<uint>. only dump ID records with the specified hexadecimal type index. .. opt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst:8958,variab,variables,8958,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,1,['variab'],['variables']
Modifiability,">; ```. ### Variable Length Array. When the `Streamer `comes across a pointer to a simple type, it assumes; it is an array. Somehow, it has to know how many elements are in the; array to reserve enough space in the buffer and write out the; appropriate number of elements. This is done in the class definition.; For example:. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; ```. The array `fClosestDistance` is defined as a pointer of floating point; numbers. A comment mark (//), and the number in square brackets tell the; `Streamer `the length of the array for this object. In general the; syntax is:. ``` {.cpp}; <simple type> *<name>//[<length>]; ```. The length cannot be an expression. If a variable is used, it needs to; be an integer data member of the class. It must be defined ahead of its; use, or in a base class. The same notation also applies to variable length array of object and; variable length array of pointer to objects. ``` {.cpp}; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; ```. ### Double32\_t. Math operations very often require double precision, but on saving; single usually precision is sufficient. For this purpose we support the; typedef Double32\_t which is stored in memory as a double and on disk as; a float or integer. The actual size of disk (before compression) is; determined by the parameter next to the data member declaration. For; example:. ``` {.cpp}; Double32_t m_data; //[min,max<,nbits>]; ```. If the comment is absent or does not contain `min`, `max`,; `nbits`, the member is saved as a `float`. If `min` and `max` are present, they are saved with 32 bits precision.; `min` and `max` can be explicit values or expressions of values known; to Cling (e.g. `pi`). If `nbits` is present, the member is saved as `int` with `nbits` bits precision. For; more details see the io tutorials `double32.C`. ![Compression and precision ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:47637,variab,variable,47637,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,2,['variab'],['variable']
Modifiability,">`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; havin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6489,plugin,plugin,6489,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,1,['plugin'],['plugin']
Modifiability,">`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you may need):. `$ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x versions suffice and are supported as; well. Versions older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your system is too old, please obtain a; new version from <http://www.python.org>. Once configured, you continue the build process the normal way:. `$ make`. `$ make install`. After some time, a library called `libPyROOT.so` (or `libPyROOT.dll`, on; Windows) will be created in the; `$ROOTSYS/lib `(`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:7566,config,configuration,7566,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,2,"['config', 'variab']","['configuration', 'variable']"
Modifiability,">fitTo(data,Minimizer(""GSLMultiMin"",""conjugatefr"")) ;. Note that installation of GSL and the ROOT MathMore package is needed to access the GSL Minimizers and that the GSL; Minimizer do not implement error analysis. New numeric integration algorithms available; RooFit can now interface all MathCore numeric integration; algorithms. In this release ROOT::Math::AdaptiveIntegratorMultiDim,; which implements the 'Genz & Malik' algorithm has been interfaced; in RooAdaptiveIntegratorND and is now the default numeric integrator; for numeric integrations in two or more dimensions. This new default integrator has much improved stability and speed; for relatively smooth p.d.f.s in two or three dimensions and can; generally be used well for p.d.f. normalization integrals without; causing MINUIT converge problems due to numeric precision issues. In future release some more numeric integrators will be migrated to; a MathCore implementation. Interface to TFoam adaptive MC sampler added; RooFit can now use the TFoam adaptive MC sampler for event generation of p.d.f.s that; do not have an internal generator. The TFoam generator adaptively subdivides the; observable space and is generally more efficient both warmup and generation than the original; RooAcceptReject algorithm. In its current interface in RooFit, TFoam cannot; handle problems yet with discrete observables or conditional observables. For those problems; the original RooAcceptReject generator is still used. The choice of MC sampling algorithm can be steered through class RooNumGenConfig, which; is similar in style and structure, to RooNumIntConfig which configures the choice of; numeric integration algorithm. A new tutorial macro rf902_numgenconfig.C has been added to $ROOTSYS/tutorials/roofit; to illustrate the use of the steering. A macro that demonstrates of the power of these newly interface numeric algorithms is provided at the; end of the RooFit section of the release notes. Optional persistent caching of numeric int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:5267,adapt,adaptive,5267,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['adapt'],['adaptive']
Modifiability,"?; ---------------------------. Garbage collection is a widely used technique that frees the programmer from; having to know the lifetimes of heap objects, making software easier to produce; and maintain. Many programming languages rely on garbage collection for; automatic memory management. There are two primary forms of garbage collection:; conservative and accurate. Conservative garbage collection often does not require any special support from; either the language or the compiler: it can handle non-type-safe programming; languages (such as C/C++) and does not require any special information from the; compiler. The `Boehm collector; <https://hboehm.info/gc/>`__ is an example of a; state-of-the-art conservative collector. Accurate garbage collection requires the ability to identify all pointers in the; program at run-time (which requires that the source-language be type-safe in; most cases). Identifying pointers at run-time requires compiler support to; locate all places that hold live pointer variables at run-time, including the; :ref:`processor stack and registers <gcroot>`. Conservative garbage collection is attractive because it does not require any; special compiler support, but it does have problems. In particular, because the; conservative garbage collector cannot *know* that a particular word in the; machine is a pointer, it cannot move live objects in the heap (preventing the; use of compacting and generational GC algorithms) and it can occasionally suffer; from memory leaks due to integer values that happen to point to objects in the; program. In addition, some aggressive compiler transformations can break; conservative garbage collectors (though these seem rare in practice). Accurate garbage collectors do not suffer from any of these problems, but they; can suffer from degraded scalar optimization of the program. In particular,; because the runtime must be able to identify and update all pointers active in; the program, some optimizations are less effect",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:3741,variab,variables,3741,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['variab'],['variables']
Modifiability,"A a(&b, &c); // warning: 6 uninitialized fields; // after the constructor call; }. // With Pedantic set to false and; // CheckPointeeInitialization set to true; // (every field is uninitialized). struct A {; struct B {; int x;; int y;; };; int *iptr;; B b;; B *bptr;; char *cptr;. A (B *bptr, char *cptr) : bptr(bptr), cptr(cptr) {}; };. void f() {; A::B b;; char c;; A a(&b, &c); // no warning; }. // With Pedantic set to true and; // CheckPointeeInitialization set to false; // (pointees are regarded as initialized). struct A {; struct B {; int x; // note: uninitialized field 'this->b.x'; int y; // note: uninitialized field 'this->b.y'; };; int *iptr; // note: uninitialized pointer 'this->iptr'; B b;; B *bptr;; char *cptr;. A (B *bptr, char *cptr) : bptr(bptr), cptr(cptr) {}; };. void f() {; A::B b;; char c;; A a(&b, &c); // warning: 3 uninitialized fields; // after the constructor call; }. **Options**. This checker has several options which can be set from command line (e.g.; ``-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true``):. * ``Pedantic`` (boolean). If to false, the checker won't emit warnings for; objects that don't have at least one initialized field. Defaults to false. * ``NotesAsWarnings`` (boolean). If set to true, the checker will emit a; warning for each uninitialized field, as opposed to emitting one warning per; constructor call, and listing the uninitialized fields that belongs to it in; notes. *Defaults to false*. * ``CheckPointeeInitialization`` (boolean). If set to false, the checker will; not analyze the pointee of pointer/reference fields, and will only check; whether the object itself is initialized. *Defaults to false*. * ``IgnoreRecordsWithField`` (string). If supplied, the checker will not analyze; structures that have a field with a name or type name that matches the given; pattern. *Defaults to """"*. .. _optin-cplusplus-VirtualCall:. optin.cplusplus.VirtualCall (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check virtual function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:16099,config,config,16099,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['config']
Modifiability,"ABLE_PROJECTS`` define on the cmake; command-line. Regression test structure; =========================. The LLVM regression tests are driven by :program:`lit` and are located in the; ``llvm/test`` directory. This directory contains a large array of small tests that exercise; various features of LLVM and to ensure that regressions do not occur.; The directory is broken into several sub-directories, each focused on a; particular area of LLVM. Writing new regression tests; ----------------------------. The regression test structure is very simple, but does require some; information to be set. This information is gathered via ``cmake``; and is written to a file, ``test/lit.site.cfg.py`` in the build directory.; The ``llvm/test`` Makefile does this work for you. In order for the regression tests to work, each directory of tests must; have a ``lit.local.cfg`` file. :program:`lit` looks for this file to determine; how to run the tests. This file is just Python code and thus is very; flexible, but we've standardized it for the LLVM regression tests. If; you're adding a directory of tests, just copy ``lit.local.cfg`` from; another directory to get running. The standard ``lit.local.cfg`` simply; specifies which files to look in for tests. Any directory that contains; only directories does not need the ``lit.local.cfg`` file. Read the :doc:`Lit; documentation <CommandGuide/lit>` for more information. Each test file must contain lines starting with ""RUN:"" that tell :program:`lit`; how to run it. If there are no RUN lines, :program:`lit` will issue an error; while running a test. RUN lines are specified in the comments of the test program using the; keyword ``RUN`` followed by a colon, and lastly the command (pipeline); to execute. Together, these lines form the ""script"" that :program:`lit`; executes to run the test case. The syntax of the RUN lines is similar to a; shell's syntax for pipelines including I/O redirection and variable; substitution. However, even though these line",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:7845,flexible,flexible,7845,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['flexible'],['flexible']
Modifiability,AD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue con,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117083,variab,variable,117083,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"AG_dwarf_procedure[; DW_AT_name = ""__divergent_lane_pc_1_else"";; DW_AT_location = DIExpression[; DW_OP_call_ref %__divergent_lane_pc;; DW_OP_addrx &lex_1_end;; DW_OP_stack_value;; DW_OP_LLVM_extend 64, 64;; DW_OP_call_ref %__lex_1_save_exec;; DW_OP_deref_type 64, %__uint_64;; DW_OP_LLVM_select_bit_piece 64, 64;; ];; ];; DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc, DIExpression[; DW_OP_call_ref %__divergent_lane_pc_1_else;; DW_OP_call_ref %__active_lane_pc;; ];; f;; EXEC = %1;; $lex_1_end:; DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc DIExpression[; DW_OP_call_ref %__divergent_lane_pc;; DW_OP_call_ref %__active_lane_pc;; ];; g;; $lex_end:. The DWARF procedure ``%__active_lane_pc`` is used to update the lane pc elements; that are active, with the current program location. Artificial variables %__lex_1_save_exec and %__lex_1_1_save_exec are created for; the execution masks saved on entry to a region. Using the ``DBG_VALUE`` pseudo; instruction, location list entries will be created that describe where the; artificial variables are allocated at any given program location. The compiler; may allocate them to registers or spill them to memory. The DWARF procedures for each region use the values of the saved execution mask; artificial variables to only update the lanes that are active on entry to the; region. All other lanes retain the value of the enclosing region where they were; last active. If they were not active on entry to the subprogram, then will have; the undefined location description. Other structured control flow regions can be handled similarly. For example,; loops would set the divergent program location for the region at the end of the; loop. Any lanes active will be in the loop, and any lanes not active must have; exited the loop. An ``IF/THEN/ELSEIF/ELSEIF/...`` region can be treated as a nest of; ``IF/THEN/ELSE`` regions. The DWARF procedures can use the active lane artificial variable described in; :ref:`amdgpu-dwarf-amdgpu-dw-at-llvm-active-lane` rat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:108140,variab,variables,108140,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variables']
Modifiability,"AKE_CURRENT_BINARY_DIR}/utils/perf-training/clang.profdata); # Use the current tools for LTO instead of the instrumented ones; list(APPEND _BOOTSTRAP_DEFAULT_PASSTHROUGH; CMAKE_CXX_COMPILER; CMAKE_C_COMPILER; CMAKE_ASM_COMPILER; CMAKE_AR; CMAKE_RANLIB; DARWIN_LTO_LIBRARY; DYLD_LIBRARY_PATH). set(COMPILER_OPTIONS); set(LTO_LIBRARY); set(LTO_AR); set(LTO_RANLIB); endif(). # Populate the passthrough variables; foreach(variableName ${CLANG_BOOTSTRAP_PASSTHROUGH} ${_BOOTSTRAP_DEFAULT_PASSTHROUGH}); if(DEFINED ${variableName}); if(""${${variableName}}"" STREQUAL """"); set(value """"); else(); string(REPLACE "";"" ""|"" value ""${${variableName}}""); endif(); list(APPEND PASSTHROUGH_VARIABLES; -D${variableName}=${value}); endif(); endforeach(). # Find all variables that start with BOOTSTRAP_ and populate a variable with; # them.; get_cmake_property(variableNames VARIABLES); foreach(variableName ${variableNames}); if(variableName MATCHES ""^BOOTSTRAP_""); string(SUBSTRING ${variableName} 10 -1 varName); string(REPLACE "";"" ""|"" value ""${${variableName}}""); list(APPEND PASSTHROUGH_VARIABLES; -D${varName}=${value}); endif(); if(${variableName} AND variableName MATCHES ""LLVM_EXTERNAL_.*_SOURCE_DIR""); list(APPEND PASSTHROUGH_VARIABLES; -D${variableName}=${${variableName}}); endif(); endforeach(). # Build arguments for native tool used in CMake.; set(build_configuration ""$<CONFIG>""); set(build_tool_args ""${LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS}""); if(NOT build_tool_args STREQUAL """"); string(PREPEND build_tool_args ""-- ""); separate_arguments(build_tool_args UNIX_COMMAND ""${build_tool_args}""); endif(). ExternalProject_Add(${NEXT_CLANG_STAGE}; DEPENDS clang-bootstrap-deps; PREFIX ${NEXT_CLANG_STAGE}; SOURCE_DIR ${CMAKE_SOURCE_DIR}; STAMP_DIR ${STAMP_DIR}; BINARY_DIR ${BINARY_DIR}; EXCLUDE_FROM_ALL 1; CMAKE_ARGS; # We shouldn't need to set this here, but INSTALL_DIR doesn't; # seem to work, so instead I'm passing this through; -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}; ${PASSTHROUGH_VARIABLES",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:27259,variab,variableNames,27259,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,8,['variab'],"['variableName', 'variableNames']"
Modifiability,"ALUE``; pseudo instruction can be used to annotate the linearized control flow. This can; be done by defining an artificial variable for the lane PC. The DWARF location; list expression created for it is used as the value of the; ``DW_AT_LLVM_lane_pc`` attribute on the subprogram's debugger information entry. A DWARF procedure is defined for each well nested structured control flow region; which provides the conceptual lane program location for a lane if it is not; active (namely it is divergent). The DWARF operation expression for each region; conceptually inherits the value of the immediately enclosing region and modifies; it according to the semantics of the region. For an ``IF/THEN/ELSE`` region the divergent program location is at the start of; the region for the ``THEN`` region since it is executed first. For the ``ELSE``; region the divergent program location is at the end of the ``IF/THEN/ELSE``; region since the ``THEN`` region has completed. The lane PC artificial variable is assigned at each region transition. It uses; the immediately enclosing region's DWARF procedure to compute the program; location for each lane assuming they are divergent, and then modifies the result; by inserting the current program location for each lane that the ``EXEC`` mask; indicates is active. By having separate DWARF procedures for each region, they can be reused to; define the value for any nested region. This reduces the total size of the DWARF; operation expressions. The following provides an example using pseudo LLVM MIR. .. code::; :number-lines:. $lex_start:; DEFINE_DWARF %__uint_64 = DW_TAG_base_type[; DW_AT_name = ""__uint64"";; DW_AT_byte_size = 8;; DW_AT_encoding = DW_ATE_unsigned;; ];; DEFINE_DWARF %__active_lane_pc = DW_TAG_dwarf_procedure[; DW_AT_name = ""__active_lane_pc"";; DW_AT_location = [; DW_OP_regx PC;; DW_OP_LLVM_extend 64, 64;; DW_OP_regval_type EXEC, %uint_64;; DW_OP_LLVM_select_bit_piece 64, 64;; ];; ];; DEFINE_DWARF %__divergent_lane_pc = DW_TAG_dwarf_pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:103726,variab,variable,103726,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variable']
Modifiability,"ALWAYS analyze a project in its ""debug"" configuration; Most projects can be built in a ""debug"" mode that enables assertions.; Assertions are picked up by the static analyzer to prune infeasible paths, which; in some cases can greatly reduce the number of false positives (bogus error; reports) emitted by the tool.; Another option is to use --force-analyze-debug-code flag of; scan-build tool which would enable assertions automatically.; Use verbose output when debugging scan-build; scan-build takes a -v option to emit verbose output about; what it's doing; two -v options emit more information. Redirecting the; output of scan-build to a text file (make sure to redirect standard; error) is useful for filing bug reports against scan-build or the; analyzer, as we can see the exact options (and files) passed to the analyzer.; For more comprehensible logs, don't perform a parallel build.; Run './configure' through scan-build; If an analyzed project uses an autoconf generated configure script,; you will probably need to run configure script through; scan-build in order to analyze the project.; Example. $ scan-build ./configure; $ scan-build --keep-cc make. The reason configure also needs to be run through; scan-build is because scan-build scans your source files by; interposing on the compiler. This interposition is currently done by; scan-build temporarily setting the environment variable CC to; ccc-analyzer. The program ccc-analyzer acts like a fake; compiler, forwarding its command line arguments over to the compiler to perform; regular compilation and clang to perform static analysis.; Running configure typically generates makefiles that have hardwired; paths to the compiler, and by running configure through; scan-build that path is set to ccc-analyzer. Analyzing iPhone Projects; Conceptually Xcode projects for iPhone applications are nearly the same as; their cousins for desktop applications. scan-build can analyze these; projects as well, but users often encounter prob",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:7023,config,configure,7023,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,3,['config'],['configure']
Modifiability,"ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; the lists of names lexicographically, and within those groups, names are; in case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:110455,config,configuration,110455,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc"");; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");; auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/true);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. return 0;; };. We may extend the ``CMakeLists.txt`` under let's say ``clang/tools`` with the build and link instructions:. .. code-block:: bash. add_clang_executable(astimporter-demo ASTImporterDemo.cpp); clang_target_link_libraries(astimporter-demo; PRIVATE; LLVMSupport; clangAST; clangASTMatchers; clangBasic; clangFrontend; clangSerialization; clangTooling; ). Then we can build and execute the new tool. .. code-block:: bash. $ ninja astimporter-demo && ./bin/astimporter-demo. Errors during the import process; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Normally, either the source or the destination context contains the definition of a declaration.; However, there may be cases when both of the contexts have a definition for a given symbol.; If these definitions differ, then we have a name conflict, in C++ it is known as ODR (one definition rule) violation.; Let's modify the previous tool we had written and try to import a ``ClassTemplateSpecializationDecl`` with a conflicting definition:. .. code-block:: cpp. int main() {; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:10594,extend,extend,10594,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['extend'],['extend']
Modifiability,"ATA_DIR); file(TO_NATIVE_PATH ""${LLVM_BINARY_DIR}/csprofiles"" LLVM_CSPROFILE_DATA_DIR); endif(); file(TO_NATIVE_PATH ""${LLVM_CSPROFILE_DATA_DIR}/%${LLVM_PROFILE_MERGE_POOL_SIZE}m.profraw"" LLVM_CSPROFILE_FILE_PATTERN); endif(); endif(); endif(). if (LLVM_BUILD_STATIC); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -static""); # Remove shared library suffixes from use in find_library; foreach (shared_lib_suffix ${CMAKE_SHARED_LIBRARY_SUFFIX} ${CMAKE_IMPORT_LIBRARY_SUFFIX}); list(FIND CMAKE_FIND_LIBRARY_SUFFIXES ${shared_lib_suffix} shared_lib_suffix_idx); if(NOT ${shared_lib_suffix_idx} EQUAL -1); list(REMOVE_AT CMAKE_FIND_LIBRARY_SUFFIXES ${shared_lib_suffix_idx}); endif(); endforeach(); endif(). # Use libtool instead of ar if you are both on an Apple host, and targeting Apple.; if(CMAKE_HOST_APPLE AND APPLE); include(UseLibtool); endif(). # Override the default target with an environment variable named by LLVM_TARGET_TRIPLE_ENV.; set(LLVM_TARGET_TRIPLE_ENV CACHE STRING ""The name of environment variable to override default target. Disabled by blank.""); mark_as_advanced(LLVM_TARGET_TRIPLE_ENV). if(CMAKE_SYSTEM_NAME MATCHES ""BSD|Linux|OS390""); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default ON); else(); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default OFF); endif(); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR ${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default} CACHE BOOL; ""Enable per-target runtimes directory""). set(LLVM_PROFDATA_FILE """" CACHE FILEPATH; ""Profiling data file to use when compiling in order to improve runtime performance.""). if(LLVM_INCLUDE_TESTS); # Lit test suite requires at least python 3.6; set(LLVM_MINIMUM_PYTHON_VERSION 3.6); else(); # FIXME: it is unknown if this is the actual minimum bound; set(LLVM_MINIMUM_PYTHON_VERSION 3.0); endif(). # Find python before including config-ix, since it needs to be able to search; # for python modules.; find_package(Python3 ${LLVM_MINIMUM_PYTHON_VERSION} REQUIRED; COMPONENTS Interpreter). # All options referred to from Ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:36787,variab,variable,36787,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['variab'],['variable']
Modifiability,"ATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you may need):. `$ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x versions suffice and are supported as; well. Versions older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your sys",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:7115,config,configure,7115,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['config'],['configure']
Modifiability,"A`` 32; ============================== =====. ``NT_AMDGPU_METADATA``; Specifies extensible metadata associated with an AMDGPU code object. It is; encoded as a map in the Message Pack [MsgPack]_ binary data format. See; :ref:`amdgpu-amdhsa-code-object-metadata-v3`,; :ref:`amdgpu-amdhsa-code-object-metadata-v4` and; :ref:`amdgpu-amdhsa-code-object-metadata-v5` for the map keys defined for the; ``amdhsa`` OS. .. _amdgpu-symbols:. Symbols; -------. Symbols include the following:. .. table:: AMDGPU ELF Symbols; :name: amdgpu-elf-symbols-table. ===================== ================== ================ ==================; Name Type Section Description; ===================== ================== ================ ==================; *link-name* ``STT_OBJECT`` - ``.data`` Global variable; - ``.rodata``; - ``.bss``; *link-name*\ ``.kd`` ``STT_OBJECT`` - ``.rodata`` Kernel descriptor; *link-name* ``STT_FUNC`` - ``.text`` Kernel entry point; *link-name* ``STT_OBJECT`` - SHN_AMDGPU_LDS Global variable in LDS; ===================== ================== ================ ==================. Global variable; Global variables both used and defined by the compilation unit. If the symbol is defined in the compilation unit then it is allocated in the; appropriate section according to if it has initialized data or is readonly. If the symbol is external then its section is ``STN_UNDEF`` and the loader; will resolve relocations using the definition provided by another code object; or explicitly defined by the runtime. If the symbol resides in local/group memory (LDS) then its section is the; special processor specific section name ``SHN_AMDGPU_LDS``, and the; ``st_value`` field describes alignment requirements as it does for common; symbols. .. TODO::. Add description of linked shared object symbols. Seems undefined symbols; are marked as STT_NOTYPE. Kernel descriptor; Every HSA kernel has an associated kernel descriptor. It is the address of the; kernel descriptor that is used in the AQL dispa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:78068,variab,variable,78068,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variable']
Modifiability,"AccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made, clang-format analyzes whether there are other bin-packed cases in; the input file and act accordingly. .. note::. This is an experimental flag, that might go away or be renamed. Do; not use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62543,config,configuration,62543,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"Args: [0]; DstArgs: [-1]. Sinks:; # Sink functions; # If taint reaches any of the arguments specified, a warning is emitted. # Sink function; # int system(const char* command); #; # Result example:; # const char* command = read_command();; # system(command); // emit diagnostic if command is tainted; - Name: system; Args: [0]. In the example file above, the entries under the `Propagation` key implement the conceptual sources and propagations, and sinks have their dedicated `Sinks` key.; The user can define operations (function calls) where the tainted values should be cleansed by listing entries under the `Filters` key.; Filters model the sanitization of values done by the programmer, and providing these is key to avoiding false-positive findings. Configuration file syntax and semantics; _______________________________________. The configuration file should have valid `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ syntax. The configuration file can have the following top-level keys:; - Filters; - Propagations; - Sinks. Under the `Filters` key, the user can specify a list of operations that remove taint (see :ref:`clangsa-taint-filter-details` for details). Under the `Propagations` key, the user can specify a list of operations that introduce and propagate taint (see :ref:`clangsa-taint-propagation-details` for details).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) then all of the destination arguments (specified by indexes in `DstArgs`) also become tainted. Under the `Sinks` key, the user can specify a list of operations where the checker should emit a bug report if tainted data reaches it (see :ref:`clangsa-taint-sink-details` for details). .. _clangsa-taint-filter-de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:4240,config,configuration,4240,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['config'],['configuration']
Modifiability,"Attribute 'cf_returns_not_retained'; Attribute 'ns_consumed'; Attribute 'cf_consumed'; Attribute 'ns_consumes_self'. Libkern Memory Management Annotations. Attribute 'os_returns_retained'; Attribute 'os_returns_not_retained'; Attribute 'os_consumed'; Attribute 'os_consumes_this'; Out Parameters. Custom Assertion Handlers. Attribute 'noreturn'; Attribute 'analyzer_noreturn'. Annotations to Enhance Generic Checks. Null Pointer Checking; Attribute 'nonnull'; The analyzer recognizes the GCC attribute 'nonnull', which indicates that a; function expects that a given function parameter is not a null pointer. Specific; details of the syntax of using the 'nonnull' attribute can be found in GCC's; documentation.; Both the Clang compiler and GCC will flag warnings for simple cases where a; null pointer is directly being passed to a function with a 'nonnull' parameter; (e.g., as a constant). The analyzer extends this checking by using its deeper; symbolic analysis to track what pointer values are potentially null and then; flag warnings when they are passed in a function call via a 'nonnull'; parameter.; Example. $ cat test.m; int bar(int*p, int q, int *r) __attribute__((nonnull(1,3)));. int foo(int *p, int *q) {; return !p ? bar(q, 2, p); : bar(p, 2, q);; }. Running scan-build over this source produces the following; output:. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management; Annotations. The analyzer supports the proper management of retain counts for; both Cocoa and Core Foundation objects. This checking is largely based on; enforcing Cocoa and Core Foundation naming conventions for Objective-C methods; (Cocoa) and C functions (Core Foundation). Not strictly following these; conventions can cause the analyzer to miss bugs or flag false positives.; One can educate the analyzer (and others who read your code) about methods or; functions that deviate from the Cocoa and Core Foundation conventions using the; attributes described here. However, you should consid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:2064,extend,extends,2064,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['extend'],['extends']
Modifiability,"AttributeReference>`. The attributes are applied to all matching declarations individually, even when; the attribute is semantically incorrect. The attributes that aren't applied to; any declaration are not verified semantically. Specifying section names for global objects (#pragma clang section); ===================================================================. The ``#pragma clang section`` directive provides a means to assign section-names; to global variables, functions and static variables. The section names can be specified as:. .. code-block:: c++. #pragma clang section bss=""myBSS"" data=""myData"" rodata=""myRodata"" relro=""myRelro"" text=""myText"". The section names can be reverted back to default name by supplying an empty; string to the section kind, for example:. .. code-block:: c++. #pragma clang section bss="""" data="""" text="""" rodata="""" relro="""". The ``#pragma clang section`` directive obeys the following rules:. * The pragma applies to all global variable, statics and function declarations; from the pragma to the end of the translation unit. * The pragma clang section is enabled automatically, without need of any flags. * This feature is only defined to work sensibly for ELF targets. * If section name is specified through _attribute_((section(""myname""))), then; the attribute name gains precedence. * Global variables that are initialized to zero will be placed in the named; bss section, if one is present. * The ``#pragma clang section`` directive does not does try to infer section-kind; from the name. For example, naming a section ""``.bss.mySec``"" does NOT mean; it will be a bss section name. * The decision about which section-kind applies to each global is taken in the back-end.; Once the section-kind is known, appropriate section name, as specified by the user using; ``#pragma clang section`` directive, is applied to that global. Specifying Linker Options on ELF Targets; ========================================. The ``#pragma comment(lib, ...)`` directive ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:187042,variab,variable,187042,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variable']
Modifiability,"BEGIN_HTML. <center><h1>Gviz3d - Objects Data Structure visualisation in 3D space</h1></center>; <p><hr><p>. The Gviz3d module provides an interface for inspecting objects collections.; TStructViewer represents a class, a struct or any other type as an; object in 3D space.; At the top of the scene we can see objects depending on a pointer root. Under it we see; pointers and collection elements. Collections must inherit from TCollection; or be STL collections. We can change the number of visible levels or objects on the scene with the GUI or; methods. The Size of objects in the geometry scene is proportional to memory taken by this object; or to the number of objects inside this object. An easy way to find some class in the viewer is to change the color of a type.; We can connect for example TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigatiion in the viewer is very simple like in usual GLViewer. When you put mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operations are supported. END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/doc/index.txt:415,inherit,inherit,415,graf3d/gviz3d/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/doc/index.txt,3,['inherit'],"['inherit', 'inheriting']"
Modifiability,"BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <Macros>`; A list of macros of the form ``<definition>=<expansion>`` . Code will be parsed with macros expanded, in order to determine how to; interpret and format the macro arguments. For example, the code:. .. code-block:: c++. A(a*b);. will usually be interpreted as a call to a function A, and the; multiplication expression will be formatted as ``a * b``. If we specify the macro definition:. .. code-block:: yaml. Macros:; - A(x)=x. the code will now be parsed as a declaration of the variable b of type a*,; and formatted as ``a* b`` (depending on pointer-binding rules). Features and restrictions:; * Both function-like macros and object-like macros are supported.; * Macro arguments must be used exactly once in the expansion.; * No recursive expansion; macros referencing other macros will be; ignored.; * Overloading by arity is supported: for example, given the macro; definitions A=x, A()=y, A(a)=a. .. code-block:: c++. A; -> x;; A(); -> y;; A(z); -> z;; A(a, b); // will not be expanded. .. _MaxEmptyLinesToKeep:. **MaxEmptyLinesToKeep** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <MaxEmptyLinesToKeep>`; The maximum number of consecutive empty lines to keep. .. code-block:: c++. MaxEmptyLinesToKeep: 1 vs. MaxEmptyLinesToKeep: 0; int f() { int f() {; int = 1; int i = 1;; i = foo();; i = foo(); return i;; }; return i;; }. .. _NamespaceIndentation:. **NamespaceIndentation** (``NamespaceIndentationKind``) :versionbadge:`clang-format 3.7` :ref:`¶ <NamespaceIndentation>`; The in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:86071,variab,variable,86071,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['variab'],['variable']
Modifiability,"BI compatibility or don't; want to use Microsoft's C and C++ runtimes, the mingw32 toolchain might be a; better fit for your project. Second, Clang implements many MSVC language extensions, such as; ``__declspec(dllexport)`` and a handful of pragmas. These are typically; controlled by ``-fms-extensions``. Third, MSVC accepts some C++ code that Clang will typically diagnose as; invalid. When these constructs are present in widely included system headers,; Clang attempts to recover and continue compiling the user's program. Most; parsing and semantic compatibility tweaks are controlled by; ``-fms-compatibility`` and ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interesting; and distinct mangling. Fortunately, incorrect manglings usually do not result; in runtime errors. Non-inline functions with incorrect manglings usually; result in link errors, which are relatively easy to diagnose. Incorrect; manglings for inline functions and templates result in multiple copies in the; final image. The C++ standard requires that those addresses be equal, but few; programs rely on this. * Member pointers: :good:`Mostly complete`. Standard C++ member pointers are; fully implemented and should be ABI compatible. Bot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:1683,inherit,inheritance,1683,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,1,['inherit'],['inheritance']
Modifiability,"BINARY_SPECFILE}; ${LLVM_SRPM_BINARY_SPECFILE} @ONLY). add_custom_target(srpm; COMMAND cpack -G TGZ --config CPackSourceConfig.cmake -B ${LLVM_SRPM_DIR}/SOURCES; COMMAND rpmbuild -bs --define '_topdir ${LLVM_SRPM_DIR}' ${LLVM_SRPM_BINARY_SPECFILE}); set_target_properties(srpm PROPERTIES FOLDER ""Misc""). if(APPLE AND DARWIN_LTO_LIBRARY); set(CMAKE_EXE_LINKER_FLAGS; ""${CMAKE_EXE_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}""); set(CMAKE_SHARED_LINKER_FLAGS; ""${CMAKE_SHARED_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}""); set(CMAKE_MODULE_LINKER_FLAGS; ""${CMAKE_MODULE_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}""); endif(). # Build with _XOPEN_SOURCE on AIX, as stray macros in _ALL_SOURCE mode tend to; # break things. In this case we need to enable the large-file API as well.; if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES ""AIX""); add_compile_definitions(_XOPEN_SOURCE=700); add_compile_definitions(_LARGE_FILE_API). # Modules should be built with -shared -Wl,-G, so we can use runtime linking; # with plugins.; string(APPEND CMAKE_MODULE_LINKER_FLAGS "" -shared -Wl,-G""). # Also set the correct flags for building shared libraries.; string(APPEND CMAKE_SHARED_LINKER_FLAGS "" -shared""); endif(). # Build with _XOPEN_SOURCE on z/OS.; if (CMAKE_SYSTEM_NAME MATCHES ""OS390""); add_compile_definitions(_XOPEN_SOURCE=600); add_compile_definitions(_OPEN_SYS) # Needed for process information.; add_compile_definitions(_OPEN_SYS_FILE_EXT) # Needed for EBCDIC I/O.; add_compile_definitions(_EXT) # Needed for file data.; add_compile_definitions(_UNIX03_THREADS) # Multithreading support.; endif(). # Build with _FILE_OFFSET_BITS=64 on Solaris to match g++ >= 9.; if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES ""SunOS""); add_compile_definitions(_FILE_OFFSET_BITS=64); endif(). set(CMAKE_INCLUDE_CURRENT_DIR ON). include_directories( ${LLVM_INCLUDE_DIR} ${LLVM_MAIN_INCLUDE_DIR}). # when crosscompiling import the executable targets from a file; if(LLVM_USE_HOST_TOOLS); include(C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:46756,plugin,plugins,46756,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['plugin'],['plugins']
Modifiability,"Before this happens; we need to decide where it is appropriate to use memory locations and where we; must use a non-memory location (or no location) for each variable. In order to; make those decisions we run a standard fixed-point dataflow analysis that makes; the choice at each instruction, iteratively joining the results for each block. ### TODO list. As this is an experimental work in progress so there are some items we still need; to tackle:. * As mentioned in test llvm/test/DebugInfo/assignment-tracking/X86/diamond-3.ll,; the analysis should treat escaping calls like untagged stores. * The system expects locals to be backed by a local alloca. This isn't always; the case - sometimes a pointer to storage is passed into a function; (e.g. sret, byval). We need to be able to handle those cases. See; llvm/test/DebugInfo/Generic/assignment-tracking/track-assignments.ll and; clang/test/CodeGen/assignment-tracking/assignment-tracking.cpp for examples. * `trackAssignments` doesn't yet work for variables that have their; `llvm.dbg.declare` location modified by a `DIExpression`, e.g. when the; address of the variable is itself stored in an `alloca` with the; `llvm.dbg.declare` using `DIExpression(DW_OP_deref)`. See `indirectReturn` in; llvm/test/DebugInfo/Generic/assignment-tracking/track-assignments.ll and in; clang/test/CodeGen/assignment-tracking/assignment-tracking.cpp for an; example. * In order to solve the first bullet-point we need to be able to specify that a; memory location is available without using a `DIAssignID`. This is because; the storage address is not computed by an instruction (it's an argument; value) and therefore we have nowhere to put the metadata attachment. To solve; this we probably need another marker intrinsic to denote ""the variable's; stack home is X address"" - similar to `llvm.dbg.declare` except that it needs; to compose with `llvm.dbg.assign` intrinsics such that the stack home address; is only selected as a location for the variable when",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:10034,variab,variables,10034,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['variab'],['variables']
Modifiability,"Both are optional. The ""selection of target"" behavior is defined as follows:. (1) If the user does not specify -triple, we default to the host triple.; (2) If the user specifies a -arch, that overrides the arch in the host or; specified triple. //===---------------------------------------------------------------------===//. verifyInputConstraint and verifyOutputConstraint should not return bool. Instead we should return something like:. enum VerifyConstraintResult {; Valid,. // Output only; OutputOperandConstraintLacksEqualsCharacter,; MatchingConstraintNotValidInOutputOperand,. // Input only; InputOperandConstraintContainsEqualsCharacter,; MatchingConstraintReferencesInvalidOperandNumber,. // Both; PercentConstraintUsedWithLastOperand; };. //===---------------------------------------------------------------------===//. Blocks should not capture variables that are only used in dead code. The rule that we came up with is that blocks are required to capture; variables if they're referenced in evaluated code, even if that code; doesn't actually rely on the value of the captured variable. For example, this requires a capture:; (void) var;; But this does not:; if (false) puts(var);. Summary of <rdar://problem/9851835>: if we implement this, we should; warn about non-POD variables that are referenced but not captured, but; only if the non-reachability is not due to macro or template; metaprogramming. //===---------------------------------------------------------------------===//. We can still apply a modified version of the constructor/destructor; delegation optimization in cases of virtual inheritance where:; - there is no function-try-block,; - the constructor signature is not variadic, and; - the parameter variables can safely be copied and repassed; to the base constructor because either; - they have not had their addresses taken by the vbase initializers or; - they were passed indirectly. //===---------------------------------------------------------------------===//;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/NOTES.txt:2968,variab,variables,2968,interpreter/llvm-project/clang/NOTES.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/NOTES.txt,2,['variab'],"['variable', 'variables']"
Modifiability,"By Chris:. LLVM has been designed with two primary goals in mind. First we strive to ; enable the best possible division of labor between static and dynamic ; compilers, and second, we need a flexible and powerful interface ; between these two complementary stages of compilation. We feel that ; providing a solution to these two goals will yield an excellent solution ; to the performance problem faced by modern architectures and programming ; languages. A key insight into current compiler and runtime systems is that a ; compiler may fall in anywhere in a ""continuum of compilation"" to do its ; job. On one side, scripting languages statically compile nothing and ; dynamically compile (or equivalently, interpret) everything. On the far ; other side, traditional static compilers process everything statically and ; nothing dynamically. These approaches have typically been seen as a ; tradeoff between performance and portability. On a deeper level, however, ; there are two reasons that optimal system performance may be obtained by a; system somewhere in between these two extremes: Dynamic application ; behavior and social constraints. From a technical perspective, pure static compilation cannot ever give ; optimal performance in all cases, because applications have varying dynamic; behavior that the static compiler cannot take into consideration. Even ; compilers that support profile guided optimization generate poor code in ; the real world, because using such optimization tunes that application ; to one particular usage pattern, whereas real programs (as opposed to ; benchmarks) often have several different usage patterns. On a social level, static compilation is a very shortsighted solution to ; the performance problem. Instruction set architectures (ISAs) continuously ; evolve, and each implementation of an ISA (a processor) must choose a set ; of tradeoffs that make sense in the market context that it is designed for. ; With every new processor introduced, the vendor f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt:192,flexible,flexible,192,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt,2,"['flexible', 'portab']","['flexible', 'portability']"
Modifiability,"C must be; run after SSA construction (i.e. mem2ref). RewriteStatepointsForGC will ensure that appropriate base pointers are listed; for every relocation created. It will do so by duplicating code as needed to; propagate the base pointer associated with each pointer being relocated to; the appropriate safepoints. The implementation assumes that the following; IR constructs produce base pointers: loads from the heap, addresses of global; variables, function arguments, function return values. Constant pointers (such; as null) are also assumed to be base pointers. In practice, this constraint; can be relaxed to producing interior derived pointers provided the target; collector can find the associated allocation from an arbitrary interior; derived pointer. By default RewriteStatepointsForGC passes in ``0xABCDEF00`` as the statepoint; ID and ``0`` as the number of patchable bytes to the newly constructed; ``gc.statepoint``. These values can be configured on a per-callsite; basis using the attributes ``""statepoint-id""`` and; ``""statepoint-num-patch-bytes""``. If a call site is marked with a; ``""statepoint-id""`` function attribute and its value is a positive; integer (represented as a string), then that value is used as the ID; of the newly constructed ``gc.statepoint``. If a call site is marked; with a ``""statepoint-num-patch-bytes""`` function attribute and its; value is a positive integer, then that value is used as the 'num patch; bytes' parameter of the newly constructed ``gc.statepoint``. The; ``""statepoint-id""`` and ``""statepoint-num-patch-bytes""`` attributes; are not propagated to the ``gc.statepoint`` call or invoke if they; could be successfully parsed. In practice, RewriteStatepointsForGC should be run much later in the pass; pipeline, after most optimization is already done. This helps to improve; the quality of the generated code when compiled with garbage collection support. .. _RewriteStatepointsForGC_intrinsic_lowering:. RewriteStatepointsForGC intrinsic lowe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:28256,config,configured,28256,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['config'],['configured']
Modifiability,"C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Mat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47789,variab,variable,47789,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"C++ code; for computing derivatives of the function. It supports both forward-mode and; reverse-mode AD. 4. **Cling for live coding music and musical instruments:**. The artistic live coding community has been growing steadily since around the; year 2000. The Temporary Organisation for the Permanence of Live Art Programming; (TOPLAP) has been around since 2004, Algorave (algorithmic rave parties); recently celebrated its tenth birthday, and six editions of the International; Conference on Live Coding (ICLC) have been held. A great many live coding; systems have been developed during this time, many of them exhibiting exotic and; culturally specific features that professional software developers are mostly; unaware of. In this framework, Cling has been used as the basis for a C++ based; live coding synthesiser (`TinySpec-Cling; <https://github.com/nwoeanhinnogaehr/tinyspec-cling>`_). In another example,; Cling has been installed on a BeagleBoard to bring live coding to the Bela; interactive audio platform (`Using the Cling C++ Interpreter on the Bela; Platform; <https://gist.github.com/jarmitage/6e411ae8746c04d6ecbee1cbc1ebdcd4>`_). These; two examples show the potential mutual benefits for increased engagement between; the Cling community and the artistic live coding community. 5. **Clion:** The `CLion <https://www.jetbrains.com/clion/>`_ platform is a; Integrating Development Environment (`IDE; <https://en.wikipedia.org/wiki/Integrated_development_environment>`_) for C and; C++ by `JetBrains <https://www.jetbrains.com/>`_. It was developed with the aim; to enhance developer's productivity with a smart editor, code quality assurance,; automated refactorings and deep integration with the CMake build system. CLion; integrates Cling, which can be found by clicking on Tool. Cling enables; prototyping and learning C++ in CLion. You can find more information on `CLion's; building instructions; <https://www.jetbrains.com/help/clion/cling-integration.html#install-cling>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst:3812,enhance,enhance,3812,interpreter/cling/docs/chapters/applications.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst,2,"['enhance', 'refactor']","['enhance', 'refactorings']"
Modifiability,"C++ operator, and some functions; defined in **`TFormula`**, in the selection parameter. The value of the; selection is used as a weight when filling the histogram. If the; expression includes only Boolean operations as in the example above, the; result is 0 or 1. If the result is 0, the histogram is not filled. In; general, the expression is:. ``` {.cpp}; Selection = ""weight *(boolean expression)""; ```. If the Boolean expression evaluates to true, the histogram is filled; with a weight. If the weight is not explicitly specified it is assumed; to be 1. For example, this selection will add 1 to the histogram if x is less; than y and the square root of z is less than 3.2. ``` {.cpp}; ""x<y && sqrt(z)>3.2""; ```. On the other hand, this selection will add `x+y` to the histogram if the; square root of z is larger than 3.2. ``` {.cpp}; ""(x+y)*(sqrt(z)>3.2)""; ```. The `Draw` method has its own parser, and it only looks in the current; tree for variables. This means that any variable used in the selection; must be defined in the tree. You cannot use an arbitrary global variable; in the `TTree::Draw` method. ### Using TCut Objects in TTree::Draw. The `TTree::Draw` method also accepts **`TCutG`** objects. A; **`TCut`** is a specialized string object used for **`TTree`**; selections. A **`TCut`** object has a name and a title. It does not have; any data members in addition to what it inherits from **`TNamed`**. It; only adds a set of operators to do logical string concatenation. For; example, assume:. ``` {.cpp}; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; ```. then. ``` {.cpp}; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; ```. Operators =, +=, +, \*, !, &&, || are overloaded, here are some; examples:. ``` {.cpp}; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); ```. ### Accessing the Histogram in B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:72359,variab,variable,72359,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"C++11 alignas() keywords or compiler; attribute __attribute__((aligned ())). In other case (when this field is missing); alignment is considered default. This is used when producing DWARF output; for DW_AT_alignment value. C/C++ function information; --------------------------. Given a function declared as follows:. .. code-block:: c. int main(int argc, char *argv[]) {; return 0;; }. a C/C++ front-end would generate the following descriptors:. .. code-block:: text. ;;; ;; Define the anchor for subprograms.; ;;; !4 = !DISubprogram(name: ""main"", scope: !1, file: !1, line: 1, type: !5,; isLocal: false, isDefinition: true, scopeLine: 1,; flags: DIFlagPrototyped, isOptimized: false,; retainedNodes: !2). ;;; ;; Define the subprogram itself.; ;;; define i32 @main(i32 %argc, i8** %argv) !dbg !4 {; ...; }. C++ specific debug information; ==============================. C++ special member functions information; ----------------------------------------. DWARF v5 introduces attributes defined to enhance debugging information of C++ programs. LLVM can generate (or omit) these appropriate DWARF attributes. In C++ a special member function Ctors, Dtors, Copy/Move Ctors, assignment operators can be declared with C++11 keyword deleted. This is represented in LLVM using spFlags value DISPFlagDeleted. Given a class declaration with copy constructor declared as deleted:. .. code-block:: c. class foo {; public:; foo(const foo&) = deleted;; };. A C++ frontend would generate following:. .. code-block:: text. !17 = !DISubprogram(name: ""foo"", scope: !11, file: !1, line: 5, type: !18, scopeLine: 5, flags: DIFlagPublic | DIFlagPrototyped, spFlags: DISPFlagDeleted). and this will produce an additional DWARF attribute as:. .. code-block:: text. DW_TAG_subprogram [7] *; DW_AT_name [DW_FORM_strx1] (indexed (00000006) string = ""foo""); DW_AT_decl_line [DW_FORM_data1] (5); ...; DW_AT_deleted [DW_FORM_flag_present] (true). Fortran specific debug information; ==================================. Fortran",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:45012,enhance,enhance,45012,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['enhance'],['enhance']
Modifiability,"CC's libatomic library <https://gcc.gnu.org/wiki/Atomic/GCCMM>`_ can be; used to supply these when using libgcc_s. .. note::. Clang does not currently automatically link against libatomic when using; libgcc_s. You may need to manually add ``-latomic`` to support this; configuration when using non-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale/libunwind>`_. Sanitizer runtime; -----------------. The instrumentation added by Clang's sanitizers (``-fsanitize=...``) implicitly; makes calls to a runtime library, in order to maintain side state about the; execution of the program and to issue diagnostic messages when a problem is; detected. The only s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:8838,config,configure,8838,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['config'],['configure']
Modifiability,"CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clang 11. 2158; drafting; Polymorphic behavior during destruction; Not resolved. 2159; NAD; Lambda capture and local thread_local variables; Unknown. 2160; open; Issues with partial ordering; Not resolved. 2161; NAD; Explicit instantiation declaration and “preceding initialization”; Unknown. 2162; CD3; Capturing this by reference; Unknown. 2163; CD4; Labels in constexpr functions; Unknown. 2164; CD5; Name hiding and using-directives; Unknown. 2165; CD6; Namespaces, declarative regions, and translation units; N/A. 2166; drafting; Unclear meaning of “undefined constexpr function”; Not resolved. 2167; CD4; Non-member references with lifetimes within the current evaluation; Unknown. 2168; open; Narrowing conversions and +/- infinity; Not resolved. 2169; open; Narrowing conversions and overload resolution; Not resolved. 2170; CD5; Unclear definition of odr-use for arrays; Clang 9. 2171; CD4; Triviality of copy constructor with less-qualified parameter; Clang 15. 2172; drafting; Multiple exceptions with one exception object; Not resolved. 2173; open; Partial specialization with non-deduced contexts; Not ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:147097,variab,variables,147097,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"CERN/SFT,\; Lorenzo Moneta, CERN/SFT,\; Alja Mrak Tadel, UCSD/CMS,\; Axel Naumann, CERN/SFT,\; Danilo Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Oksana Shadura, UNL,\; Ravi Kiran Selvam, GSOC, \; Manos, Stergiadis, GSOC, \; Matevz Tadel, UCSD/CMS,\; Yuka Takahashi, Princeton,\; Massimo Tumolo, Politecnico di Torino,\; Mohammad Uzair, CERN/SFT, \; Xavier Valls, CERN/SFT,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/Atlas,\; Stefan Wunsch, CERN/SFT. ## Deprecation and Removal. ### Ruby bindings. The ruby binding has been unmaintained for several years; it does not build with current ruby versions.; Given that this effectively meant that Ruby was dysfunctional and given that nobody (but package maintainers) has complained, we decided to remove it. ### Removal of previously deprecated or disabled packages. The packages `afs`, `chirp`, `glite`, `sapdb`, `srp` and `ios` have been removed from ROOT.; They were deprecated before, or never ported from configure, make to CMake. ### Remove GLUtesselator forward declaration from TVirtualX.h. It was never used in TVirtualX interfaces. If GLUtesselator forward declaration is required, use TGLUtil.h include instead. ## C++ Modules Technology Preview. ROOT has several features which interact with libraries and require implicit; header inclusion. This can be triggered by reading or writing data on disk,; or user actions at the prompt. Often, the headers are immutable and reparsing is; redundant. C++ Modules are designed to minimize the reparsing of the same; header content by providing an efficient on-disk representation of C++ Code. This is an experimental feature which can be enabled by compiling ROOT with; `-Druntime_cxxmodules=On`. You can read more about the current state of the; feature [here](../../README.CXXMODULES.md). ## Core Libraries. ### New command line flag ""--version"" for root. `root --version` now displays ROOT version and build info and quits:. ```; ROOT Versi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:1686,config,configure,1686,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['config'],['configure']
Modifiability,"CGI interface. [FastCGI](http://en.wikipedia.org/wiki/FastCGI) is a protocol for interfacing interactive programs with a web server like `Apache`, `lighttpd`, `Microsoft ISS` and many others. When starting THttpServer, one could specify:. ```cpp; serv = new THttpServer(""fastcgi:9000"");; ```. In fact, the FastCGI interface can run in parallel to http server. One can just call:. ```cpp; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; ```. One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:. ```cpp; serv->CreateEngine(""fastcgi:9000?debug=1"");; ```. By default 10 threads are used to process FastCGI requests. This number can be changed with ""thrds"" url parameter:. ```cpp; serv->CreateEngine(""fastcgi:9000?thrds=20"");; ```. If `thrds=0` parameter specified, the only thread will be use to received and process all requests. All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer. ### Configure fastcgi with Apache2. Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more.; One only need to enable `mod_proxy` and `mod_proxy_fcgi` modules and add following line to **Apache2** configuration file:. ```; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; ```. More information can be found in [FastCGI proxy docu](https://httpd.apache.org/docs/2.4/mod/mod_proxy_fcgi.html).; After restarting apache server one should be able to open address: `http://apache_host_name/root.app/`.; There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:. ```; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; ```. ### Configure fastcgi with lighttpd. An example of configuration file",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:10984,config,configure,10984,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configure']
Modifiability,"CL.EXE COMPATIBILITY OPTIONS:; /? Display available options; /arch:<value> Set architecture for code generation; /Brepro- Emit an object file which cannot be reproduced over time; /Brepro Emit an object file which can be reproduced over time; /clang:<arg> Pass <arg> to the clang driver; /C Don't discard comments when preprocessing; /c Compile only; /d1PP Retain macro definitions in /E mode; /d1reportAllClassLayout Dump record layout information; /diagnostics:caret Enable caret and column diagnostics (on by default); /diagnostics:classic Disable column and caret diagnostics; /diagnostics:column Disable caret diagnostics but keep column info; /D <macro[=value]> Define macro; /EH<value> Exception handling model; /EP Disable linemarker output and preprocess to stdout; /execution-charset:<value>; Runtime encoding, supports only UTF-8; /E Preprocess to stdout; /FA Output assembly code file during compilation; /Fa<file or directory> Output assembly code to this file during compilation (with /FA); /Fe<file or directory> Set output executable file or directory (ends in / or \); /FI <value> Include file before parsing; /Fi<file> Set preprocess output file name (with /P); /Fo<file or directory> Set output object file, or directory (ends in / or \) (with /c); /fp:except-; /fp:except; /fp:fast; /fp:precise; /fp:strict; /Fp<filename> Set pch filename (with /Yc and /Yu); /GA Assume thread-local variables are defined in the executable; /Gd Set __cdecl as a default calling convention; /GF- Disable string pooling; /GF Enable string pooling (default); /GR- Disable emission of RTTI data; /Gregcall Set __regcall as a default calling convention; /GR Enable emission of RTTI data; /Gr Set __fastcall as a default calling convention; /GS- Disable buffer security check; /GS Enable buffer security check (default); /Gs Use stack probes (default); /Gs<value> Set stack probe size (default 4096); /guard:<value> Enable Control Flow Guard with /guard:cf,; or only the table with /guard:cf,nochecks.; E",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:172613,variab,variables,172613,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"CMake Caches; ============. This directory contains CMake cache scripts that pre-populate the CMakeCache in; a build directory with commonly used settings. You can use the caches files with the following CMake invocation:. cmake -G <build system>; -C <path to cache file>; [additional CMake options (i.e. -DCMAKE_INSTALL_PREFIX=<install path>)]; <path to llvm>. Options specified on the command line will override options in the cache files. The following cache files exist. Apple-stage1; ------------. The Apple stage1 cache configures a two stage build similar to how Apple builds; the clang shipped with Xcode. The build files generated from this invocation has; a target named ""stage2"" which performs an LTO build of clang. The Apple-stage2 cache can be used directly to match the build settings Apple; uses in shipping builds without doing a full bootstrap build. PGO; ---. The PGO CMake cache can be used to generate a multi-stage instrumented compiler.; You can configure your build directory with the following invocation of CMake:. cmake -G <generator> -C <path_to_clang>/cmake/caches/PGO.cmake <source dir>. After configuration the following additional targets will be generated:. stage2-instrumented:; Builds a stage1 x86 compiler, runtime, and required tools (llvm-config,; llvm-profdata) then uses that compiler to build an instrumented stage2 compiler. stage2-instrumented-generate-profdata:; Depends on ""stage2-instrumented"" and will use the instrumented compiler to; generate profdata based on the training files in <clang>/utils/perf-training. stage2:; Depends on ""stage2-instrumented-generate-profdata"" and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. stage2-check-llvm:; Depends on stage2 and runs check-llvm using the stage3 compiler. stage2-check-clang:; Depends on stage2 and runs check-clang using the stage3 compiler. stage2-check-all:; Depends on stage2 and runs check-all using the stage3 compiler. stage2-test-suite:; Depends on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/cmake/caches/README.txt:526,config,configures,526,interpreter/llvm-project/clang/cmake/caches/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/cmake/caches/README.txt,2,['config'],"['configure', 'configures']"
Modifiability,"CMake modules that contain definitions for useful functionality. The example below is the full CMake build for building a C++ ""Hello World""; program. The example uses only CMake language-defined functions. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(HelloWorld); add_executable(HelloWorld HelloWorld.cpp). The CMake language provides control flow constructs in the form of foreach loops; and if blocks. To make the example above more complicated you could add an if; block to define ""APPLE"" when targeting Apple platforms:. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(HelloWorld); add_executable(HelloWorld HelloWorld.cpp); if(APPLE); target_compile_definitions(HelloWorld PUBLIC APPLE); endif(). Variables, Types, and Scope; ===========================. Dereferencing; -------------. In CMake variables are ""stringly"" typed. All variables are represented as; strings throughout evaluation. Wrapping a variable in ``${}`` dereferences it; and results in a literal substitution of the name for the value. CMake refers to; this as ""variable evaluation"" in their documentation. Dereferences are performed; *before* the command being called receives the arguments. This means; dereferencing a list results in multiple separate arguments being passed to the; command. Variable dereferences can be nested and be used to model complex data. For; example:. .. code-block:: cmake. set(var_name var1); set(${var_name} foo) # same as ""set(var1 foo)""; set(${${var_name}}_var bar) # same as ""set(foo_var bar)"". Dereferencing an unset variable results in an empty expansion. It is a common; pattern in CMake to conditionally set variables knowing that it will be used in; code paths that the variable isn't set. There are examples of this throughout; the LLVM CMake build system. An example of variable empty expansion is:. .. code-block:: cmake. if(APPLE); set(extra_sources Apple.cpp); endif(); add_executable(HelloWorld HelloWorld.cpp ${extra_sources}). In t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:2963,variab,variable,2963,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variable']
Modifiability,"CODE_DEPLIB Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DEPLIB, ...string...]``. The ``DEPLIB`` record (code 6) contains a variable number of values representing; the bytes of a single dependent library name string, one of the libraries; mentioned in a ``deplibs`` declaration. There should be one ``DEPLIB`` record; for each library name referenced. MODULE_CODE_GLOBALVAR Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[GLOBALVAR, strtab offset, strtab size, pointer type, isconst, initid, linkage, alignment, section, visibility, threadlocal, unnamed_addr, externally_initialized, dllstorageclass, comdat, attributes, preemptionspecifier]``. The ``GLOBALVAR`` record (code 7) marks the declaration or definition of a; global variable. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the global variable.; See `STRTAB_BLOCK Contents`_. * *pointer type*: The type index of the pointer type used to point to this; global variable. * *isconst*: Non-zero if the variable is treated as constant within the module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: An encoding of the linkage type for this variable:. * ``external``: code 0; * ``weak``: code 1; * ``appending``: code 2; * ``internal``: code 3; * ``linkonce``: code 4; * ``dllimport``: code 5; * ``dllexport``: code 6; * ``extern_weak``: code 7; * ``common``: code 8; * ``private``: code 9; * ``weak_odr``: code 10; * ``linkonce_odr``: code 11; * ``available_externally``: code 12; * deprecated : code 13; * deprecated : code 14. * alignment*: The logarithm base 2 of the variable's requested alignment, plus 1. * *section*: If non-zero, the 1-based section index in the table of; `MODULE_CODE_SECTIONNAME`_ entries. .. _visibility:. * *visibility*: If present, an encoding of the visibility of this variable:. * ``default``: code 0; * ``hidden``: code 1; * ``protected``: code 2. .. _bcthreadlocal:. * *threadlocal*: If present",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:27563,variab,variable,27563,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"CUs), or the same; work-group if executing in tgsplit mode, of an agent can be reordered; relative to each other. A ``s_waitcnt vmcnt(0)`` is required to ensure; synchronization between vector memory operations of different CUs. It; ensures a previous vector memory operation has completed before executing a; subsequent vector memory or LDS operation and so can be used to meet the; requirements of acquire and release.; * The L2 cache of one agent can be kept coherent with other agents by:; using the MTYPE RW (read-write) or MTYPE CC (cache-coherent) with the PTE; C-bit for memory local to the L2; and using the MTYPE NC (non-coherent) with; the PTE C-bit set or MTYPE UC (uncached) for memory not local to the L2. * Any local memory cache lines will be automatically invalidated by writes; from CUs associated with other L2 caches, or writes from the CPU, due to; the cache probe caused by coherent requests. Coherent requests are caused; by GPU accesses to pages with the PTE C-bit set, by CPU accesses over; XGMI, and by PCIe requests that are configured to be coherent requests.; * XGMI accesses from the CPU to local memory may be cached on the CPU.; Subsequent access from the GPU will automatically invalidate or writeback; the CPU cache due to the L2 probe filter and and the PTE C-bit being set.; * Since all work-groups on the same agent share the same L2, no L2; invalidation or writeback is required for coherence.; * To ensure coherence of local and remote memory writes of work-groups in; different agents a ``buffer_wbl2`` is required. It will writeback dirty L2; cache lines of MTYPE RW (used for local coarse grain memory) and MTYPE NC; ()used for remote coarse grain memory). Note that MTYPE CC (used for local; fine grain memory) causes write through to DRAM, and MTYPE UC (used for; remote fine grain memory) bypasses the L2, so both will never result in; dirty L2 cache lines.; * To ensure coherence of local and remote memory reads of work-groups in; different agents a ``bu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:238230,config,configured,238230,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['config'],['configured']
Modifiability,"Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17; Problems with sized delete; Unknown. 2249; CD5; identifiers and id-expressions; Unknown. 2250; open; Implicit instantiation, destruction, and TUs; Not resolved. 2251; C++17; Unreachable enumeration list-initialization; Unknown. 2252; DR; Enumeration list-initialization from the same type; Unknown. 2253; CD5; Unnamed bit-fields and zero-initialization; Unknown. 2254; CD5; Standard-layout classes and bit-fields; Unknown. 2255; CD5; Instantiated static data member templates; Unknown. 2256; CD5; Lifetime of trivially-destructible objects; Unknown. 2257; CD5; Lifetime extension of references vs exceptions; Unknown. 2258; open; Storage deallocation during period of destruction; Not resolved. 2259; C++17; Unclear context describing ambiguity; Unknown. 2260; CD5; Explicit specializations of deleted member functions; Unknown. 2261; extension; Explicit instantiation of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:153169,variab,variable,153169,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"Clang 17 (Partial); 	 We do not support outside of defaulted special memeber functions the change that constexpr functions no; longer have to be constexpr compatible but rather support a less restricted requirements for constexpr; functions. Which include allowing non-literal types as return values and parameters, allow calling of; non-constexpr functions and constructors.; . Using unknown pointers and references in constant expressions; P2280R4 (DR); No. static operator(); P1169R4; Clang 16. Extended floating-point types and standard names; P1467R9; No. Class template argument deduction from inherited constructors; P2582R1; No. Portable assumptions; P1774R8; No. Support for UTF-8 as a portable source file encoding; P2295R6; Clang 15. char8_t Compatibility and Portability Fix; P2513R3; Clang 16. Relax requirements on wchar_t to match existing practices; P2460R2; Yes. Explicit lifetime management; P2590R2; No. static operator[]; P2589R1; Clang 16. Permitting static constexpr variables in constexpr functions; P2647R1; Clang 16. consteval needs to propagate up; P2564R3 (DR); Clang 17. Lifetime extension in range-based for loops; P2718R0; No. Referencing The Unicode Standard; P2736R2; Yes. C++20 implementation status; Clang has support for some of the features of the; ISO C++ 2020 standard.; You can use Clang in C++20 mode with the -std=c++20 option; (use -std=c++2a in Clang 9 and earlier). List of features and minimum Clang version with support. Language Feature; C++20 Proposal; Available in Clang?. Default member initializers for bit-fields; P0683R1; Clang 6. const&-qualified pointers to members; P0704R1; Clang 6. Allow lambda-capture [=, this]; P0409R2; Clang 6. __VA_OPT__ for preprocessor comma elision; P0306R4; Clang 6. ; P1042R1; Clang 9. Designated initializers; P0329R4; Clang 10. template-parameter-list for generic lambdas; P0428R2; Clang 9. Concepts; P0734R0; Clang 10. ; P0857R0; Clang 16. ; P1084R2; Clang 10. P1141R2. ; P0848R3. Clang 16 (Partial); Because of o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:5294,variab,variables,5294,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,1,['variab'],['variables']
Modifiability,"Cling Hist Tree Gpad Graf HistPainter move_artifacts); install(FILES ${CMAKE_BINARY_DIR}/tutorials/hsimple.root DESTINATION ${CMAKE_INSTALL_TUTDIR} COMPONENT tests). if(runtime_cxxmodules); add_dependencies(hsimple modules_idx); endif(). #---copy special headers required for building on Windows----------------------------------------; if(WIN32); file(COPY cmake/win/w32pragma.h DESTINATION ${CMAKE_BINARY_DIR}/include/); file(COPY cmake/win/sehmap.h DESTINATION ${CMAKE_BINARY_DIR}/include/); endif(). #---version--------------------------------------------------------------------------------------; if(NOT WIN32); add_custom_target(version COMMAND ${Python3_EXECUTABLE} ${CMAKE_SOURCE_DIR}/cmake/unix/makeversion.py; WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}); endif(). #---distribution commands------------------------------------------------------------------------; add_custom_target(distsrc COMMAND ${CMAKE_SOURCE_DIR}/cmake/unix/makedistsrc.sh ""${ROOT_FULL_VERSION}"" ""${CMAKE_SOURCE_DIR}""); add_custom_target(dist COMMAND cpack --config CPackConfig.cmake). #---Configure and install various files neded later and for clients -----------------------------; include(RootConfiguration). #---Installation of project-wise artifacts-------------------------------------------------------; if(NOT CMAKE_SOURCE_DIR STREQUAL CMAKE_INSTALL_PREFIX); install(FILES LICENSE DESTINATION ${CMAKE_INSTALL_DOCDIR}); if(gnuinstall); install(DIRECTORY README/ DESTINATION ${CMAKE_INSTALL_DOCDIR}); else(); install(DIRECTORY README DESTINATION ${CMAKE_INSTALL_DOCDIR}); endif(); install(DIRECTORY etc/ DESTINATION ${CMAKE_INSTALL_SYSCONFDIR} USE_SOURCE_PERMISSIONS; ${DIR_PERMISSIONS}; PATTERN ""system.rootrc"" EXCLUDE; PATTERN ""system.rootauthrc"" EXCLUDE; PATTERN ""system.rootdaemonrc"" EXCLUDE; PATTERN ""root.mimes"" EXCLUDE; PATTERN ""*.in"" EXCLUDE); install(DIRECTORY fonts/ DESTINATION ${CMAKE_INSTALL_FONTDIR} ${DIR_PERMISSIONS}); install(DIRECTORY icons/ DESTINATION ${CMAKE_INSTALL_ICONDIR} ${DIR_PERMISSIONS});",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:24724,config,config,24724,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['config'],['config']
Modifiability,"CodeGen function returns the phi node as the value computed; by the if/then/else expression. In our example above, this returned; value will feed into the code for the top-level function, which will; create the return instruction. Overall, we now have the ability to execute conditional code in; Kaleidoscope. With this extension, Kaleidoscope is a fairly complete; language that can calculate a wide variety of numeric functions. Next up; we'll add another useful expression that is familiar from non-functional; languages... 'for' Loop Expression; =====================. Now that we know how to add basic control flow constructs to the; language, we have the tools to add more powerful things. Let's add; something more aggressive, a 'for' expression:. ::. extern putchard(char);; def printstar(n); for i = 1, i < n, 1.0 in; putchard(42); # ascii 42 = '*'. # print 100 '*' characters; printstar(100);. This expression defines a new variable (""i"" in this case) which iterates; from a starting value, while the condition (""i < n"" in this case) is; true, incrementing by an optional step value (""1.0"" in this case). If; the step value is omitted, it defaults to 1.0. While the loop is true,; it executes its body expression. Because we don't have anything better; to return, we'll just define the loop as always returning 0.0. In the; future when we have mutable variables, it will get more useful. As before, let's talk about the changes that we need to Kaleidoscope to; support this. Lexer Extensions for the 'for' Loop; -----------------------------------. The lexer extensions are the same sort of thing as for if/then/else:. .. code-block:: c++. ... in enum Token ...; // control; tok_if = -6, tok_then = -7, tok_else = -8,; tok_for = -9, tok_in = -10. ... in gettok ...; if (IdentifierStr == ""def""); return tok_def;; if (IdentifierStr == ""extern""); return tok_extern;; if (IdentifierStr == ""if""); return tok_if;; if (IdentifierStr == ""then""); return tok_then;; if (IdentifierStr == ""else""); retu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:15537,variab,variable,15537,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability,"Constexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:126730,variab,variable,126730,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"Constructor(); : a(),; b(). * ``PCIS_BinPack`` (in configuration: ``BinPack``); Bin-pack constructor initializers. .. code-block:: c++. Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_CurrentLine`` (in configuration: ``CurrentLine``); Put all constructor initializers on the current line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; ddddddddddddd(). * ``PCIS_NextLine`` (in configuration: ``NextLine``); Same as ``PCIS_CurrentLine`` except that if all constructor initializers; do not fit on the current line, try to fit them on the next line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_NextLineOnly`` (in configuration: ``NextLineOnly``); Put all constructor initializers on the next line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor(); : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). .. _PenaltyBreakAssignment:. **PenaltyBreakAssignment** (``Unsigned``) :versionbadge:`clang-format 5` :ref:`¶ <PenaltyBreakAssignment>`; The penalty for breaking around an assignment operator. .. _PenaltyBreakBeforeFirstCallParameter:. **PenaltyBreakBeforeFirstCallParameter** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyBreakBeforeFirstCallParameter>`; The penalty for breaking a function call after ``call(``. .. _PenaltyBreakComment:. **PenaltyBreakComment** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyBreakComment>`; The penalty for each line break introduced inside a comment. .. _PenaltyBreakFirstLessLess:. **PenaltyBreakFirst",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:93274,config,configuration,93274,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"Cost `vs. `Age` for the entries where the nation is; equal to ""`FR`"". You can use any C++ operator, and some functions; defined in **`TFormula`**, in the selection parameter. The value of the; selection is used as a weight when filling the histogram. If the; expression includes only Boolean operations as in the example above, the; result is 0 or 1. If the result is 0, the histogram is not filled. In; general, the expression is:. ``` {.cpp}; Selection = ""weight *(boolean expression)""; ```. If the Boolean expression evaluates to true, the histogram is filled; with a weight. If the weight is not explicitly specified it is assumed; to be 1. For example, this selection will add 1 to the histogram if x is less; than y and the square root of z is less than 3.2. ``` {.cpp}; ""x<y && sqrt(z)>3.2""; ```. On the other hand, this selection will add `x+y` to the histogram if the; square root of z is larger than 3.2. ``` {.cpp}; ""(x+y)*(sqrt(z)>3.2)""; ```. The `Draw` method has its own parser, and it only looks in the current; tree for variables. This means that any variable used in the selection; must be defined in the tree. You cannot use an arbitrary global variable; in the `TTree::Draw` method. ### Using TCut Objects in TTree::Draw. The `TTree::Draw` method also accepts **`TCutG`** objects. A; **`TCut`** is a specialized string object used for **`TTree`**; selections. A **`TCut`** object has a name and a title. It does not have; any data members in addition to what it inherits from **`TNamed`**. It; only adds a set of operators to do logical string concatenation. For; example, assume:. ``` {.cpp}; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; ```. then. ``` {.cpp}; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; ```. Operators =, +=, +, \*, !, &&, || are overloaded, here are some; examples:. ``` {.cpp}; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2);",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:72328,variab,variables,72328,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"D and 3-D histograms. If **`TH1`**`::Sumw2()` has; been called before filling, the sum of squares is also stored. One can; increment a bin number directly by calling; **`TH1`**`::AddBinContent()`, replace the existing content via; **`TH1`**`::SetBinContent()` , and access the bin content of a given; bin via **`TH1`**`::GetBinContent()` . ``` {.cpp}; Double_t binContent = h->GetBinContent(bin);; ```. ### Automatic Re-binning Option. By default, the number of bins is computed using the range of the; axis. You can change this to re-bin automatically by setting the; automatic re-binning option:. ``` {.cpp}; h->SetBit(TH1::kCanRebin);; ```; \index{histogram!rebin}. Once this is set, the `Fill()` method will automatically extend the; axis range to accommodate the new value specified in the `Fill()`; argument. The used method is to double the bin size until the new; value fits in the range, merging bins two by two. The; **`TTree`**`::Draw()` method extensively uses this automatic binning; option when drawing histograms of variables in **`TTree`** with an; unknown range. The automatic binning option is supported for 1-D, 2-D; and 3-D histograms. During filling, some statistics parameters are; incremented to compute the mean value and root mean square with the; maximum precision. In case of histograms of type **`TH1C`**,; **`TH1S`**, **`TH2C`**, **`TH2S`**, **`TH3C`**, **`TH3S`** a check is; made that the bin contents do not exceed the maximum positive capacity; (127 or 65 535). Histograms of all types may have positive or/and; negative bin contents. ## Random Numbers and Histograms. **`TH1`**`::FillRandom()` can be used to randomly fill a histogram; using the contents of an existing **`TF1`** function or another; **`TH1`** histogram (for all dimensions). For example, the following; two statements create and fill a histogram 10 000 times with a default; Gaussian distribution of `mean` `0` and `sigma` `1` :. ``` {.cpp}; root[] TH1F h1(""h1"",""Histo from a Gaussian"",100,-3,3);; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:8709,variab,variables,8709,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variables']
Modifiability,"D has a ``DW_AT_location`` attribute, the DWARF expression E from the; ``DW_AT_location`` attribute is evaluated with the current context, except; that the result kind is a location description, the compilation unit is; the one that contains D, the object is unspecified, and the initial stack; is empty. RL is the expression result. *Note that E is evaluated with the context of the expression accessing; IPV, and not the context of the expression that contained the*; ``DW_OP_implicit_pointer`` *or* ``DW_OP_LLVM_aspace_implicit_pointer``; *operation that created L.*. * If D has a ``DW_AT_const_value`` attribute, then an implicit location; storage RLS is created from the ``DW_AT_const_value`` attribute's value; with a size matching the size of the ``DW_AT_const_value`` attribute's; value. RL comprises one implicit location description SRL. SRL specifies; RLS with a bit offset of 0. .. note::. If using ``DW_AT_const_value`` for variables and formal parameters is; deprecated and instead ``DW_AT_location`` is used with an implicit; location description, then this rule would not be required. * Otherwise, it is an evaluation error. The bit offset of RL is updated as if the ``DW_OP_LLVM_offset_uconst B``; operation was applied. If a ``DW_OP_stack_value`` operation pops a value that is the same as IPV,; then it pushes a location description that is the same as L. It is an evaluation error if LS or IPV is accessed in any other manner. *The restrictions on how an implicit pointer location description created; by* ``DW_OP_implicit_pointer`` *and* ``DW_OP_LLVM_aspace_implicit_pointer``; *can be used are to simplify the DWARF consumer. Similarly, for an implicit; pointer value created by* ``DW_OP_deref*`` *and* ``DW_OP_stack_value``\ *.*. 4. ``DW_OP_LLVM_aspace_implicit_pointer`` *New*. ``DW_OP_LLVM_aspace_implicit_pointer`` has two operands that are the same as; for ``DW_OP_implicit_pointer``. It pops one stack entry that must be an integral type value that represents; a target arc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:126677,variab,variables,126677,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variables']
Modifiability,"DED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed description. .. _debug-AnalysisOrder:. debug.AnalysisOrder; """"""""""""""""""""""""""""""""""""""; Print callbacks that are called during analysis in order. .. _debug-ConfigDumper:. debug.ConfigDumper; """"""""""""""""""""""""""""""""""""; Dump config table. .. _debug-DumpCFG Display:. debug.DumpCFG Display; """"""""""""""""""""""""""""""""""""""""""; Control-Flow Graphs. .. _debug-DumpCallGraph:. debug.DumpCallGraph; """"""""""""""""""""""""""""""""""""""; Display Call Graph. .. _debug-DumpCalls:. debug.DumpCalls; """"""""""""""""""""""""""""""; Print calls as they are traversed by the engine. .. _debug-DumpDominators:. debug.DumpDominators; """"""""""""""""""""""""""""""""""""""""; Print t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85722,variab,variable,85722,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,2,['variab'],['variable']
Modifiability,"DIR}/llvm-config; -DLLVM_LIT_ARGS=${LLVM_LIT_ARGS}; -DCOMPILER_RT_OUTPUT_DIR=${output_resource_dir}; -DCOMPILER_RT_EXEC_OUTPUT_DIR=${LLVM_RUNTIME_OUTPUT_INTDIR}; -DCOMPILER_RT_INSTALL_PATH:PATH=${install_resource_dir}; -DCOMPILER_RT_INCLUDE_TESTS=${LLVM_INCLUDE_TESTS}; -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}; -DLLVM_LIBDIR_SUFFIX=${LLVM_LIBDIR_SUFFIX}; -DLLVM_RUNTIME_OUTPUT_INTDIR=${LLVM_RUNTIME_OUTPUT_INTDIR}; -DCMAKE_OSX_DEPLOYMENT_TARGET=${CMAKE_OSX_DEPLOYMENT_TARGET}; -DCMAKE_OSX_SYSROOT:PATH=${CMAKE_OSX_SYSROOT}; ${COMPILER_RT_PASSTHROUGH_VARIABLES}; INSTALL_COMMAND """"; STEP_TARGETS configure build; USES_TERMINAL_CONFIGURE 1; USES_TERMINAL_BUILD 1; USES_TERMINAL_INSTALL 1; # Always run the build command so that incremental builds are correct.; BUILD_ALWAYS 1; ). get_ext_project_build_command(run_clean_compiler_rt clean); ExternalProject_Add_Step(compiler-rt clean; COMMAND ${run_clean_compiler_rt}; COMMENT ""Cleaning compiler-rt...""; DEPENDEES configure; DEPENDERS build; DEPENDS clang; WORKING_DIRECTORY ${BINARY_DIR}; ). install(CODE ""execute_process\(COMMAND \${CMAKE_COMMAND} -DCMAKE_INSTALL_PREFIX=\${CMAKE_INSTALL_PREFIX} -P ${BINARY_DIR}/cmake_install.cmake \)""; COMPONENT compiler-rt). add_llvm_install_targets(install-compiler-rt; DEPENDS compiler-rt; COMPONENT compiler-rt). # Add top-level targets that build specific compiler-rt runtimes.; set(COMPILER_RT_RUNTIMES fuzzer asan builtins dfsan lsan msan profile tsan ubsan ubsan-minimal); foreach(runtime ${COMPILER_RT_RUNTIMES}); get_ext_project_build_command(build_runtime_cmd ${runtime}); add_custom_target(${runtime}; COMMAND ${build_runtime_cmd}; DEPENDS compiler-rt-configure; WORKING_DIRECTORY ${BINARY_DIR}; VERBATIM USES_TERMINAL); endforeach(). if(LLVM_INCLUDE_TESTS); # Add binaries that compiler-rt tests depend on.; set(COMPILER_RT_TEST_DEPENDENCIES; FileCheck count not llvm-nm llvm-objdump llvm-symbolizer llvm-jitlink lli split-file). # Add top-level targets for various compiler-rt test suites.; set(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt:3998,config,configure,3998,interpreter/llvm-project/clang/runtime/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt,1,['config'],['configure']
Modifiability,"DISCOVERY; --------------. The inputs passed to :program:`lit` can be either individual tests, or entire; directories or hierarchies of tests to run. When :program:`lit` starts up, the; first thing it does is convert the inputs into a complete list of tests to run; as part of *test discovery*. In the :program:`lit` model, every test must exist inside some *test suite*.; :program:`lit` resolves the inputs specified on the command line to test suites; by searching upwards from the input path until it finds a :file:`lit.cfg` or; :file:`lit.site.cfg` file. These files serve as both a marker of test suites; and as configuration files which :program:`lit` loads in order to understand; how to find and run the tests inside the test suite. Once :program:`lit` has mapped the inputs into test suites it traverses the; list of inputs adding tests for individual files and recursively searching for; tests in directories. This behavior makes it easy to specify a subset of tests to run, while still; allowing the test suite configuration to control exactly how tests are; interpreted. In addition, :program:`lit` always identifies tests by the test; suite they are in, and their relative path inside the test suite. For; appropriately configured projects, this allows :program:`lit` to provide; convenient and flexible support for out-of-tree builds. .. _test-status-results:. TEST STATUS RESULTS; -------------------. Each test ultimately produces one of the following eight results:. **PASS**. The test succeeded. **FLAKYPASS**. The test succeeded after being re-run more than once. This only applies to; tests containing an ``ALLOW_RETRIES:`` annotation. **XFAIL**. The test failed, but that is expected. This is used for test formats which allow; specifying that a test does not currently work, but wish to leave it in the test; suite. **XPASS**. The test succeeded, but it was expected to fail. This is used for tests which; were specified as expected to fail, but are now succeeding (generally bec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:11987,config,configuration,11987,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['configuration']
Modifiability,"DLLVM_ENABLE_RUNTIMES=""libcxx;libcxxabi""``. **LLVM_LIBDIR_SUFFIX**:STRING; Extra suffix to append to the directory where libraries are to be; installed. On a 64-bit architecture, one could use ``-DLLVM_LIBDIR_SUFFIX=64``; to install libraries to ``/usr/lib64``. **LLVM_PARALLEL_{COMPILE,LINK}_JOBS**:STRING; Building the llvm toolchain can use a lot of resources, particularly; linking. These options, when you use the Ninja generator, allow you; to restrict the parallelism. For example, to avoid OOMs or going; into swap, permit only one link job per 15GB of RAM available on a; 32GB machine, specify ``-G Ninja -DLLVM_PARALLEL_LINK_JOBS=2``. **LLVM_TARGETS_TO_BUILD**:STRING; Control which targets are enabled. For example you may only need to enable; your native target with, for example, ``-DLLVM_TARGETS_TO_BUILD=X86``. .. _llvm_use_linker:. **LLVM_USE_LINKER**:STRING; Override the system's default linker. For instance use ``lld`` with; ``-DLLVM_USE_LINKER=lld``. Rarely-used CMake variables; ---------------------------. Here are some of the CMake variables that are rarely used, along with a brief; explanation and LLVM-related notes. For full documentation, consult the CMake; manual, or execute ``cmake --help-variable VARIABLE_NAME``. **CMAKE_CXX_STANDARD**:STRING; Sets the C++ standard to conform to when building LLVM. Possible values are; 17 and 20. LLVM Requires C++ 17 or higher. This defaults to 17. **CMAKE_INSTALL_BINDIR**:PATH; The path to install executables, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""bin"". **CMAKE_INSTALL_INCLUDEDIR**:PATH; The path to install header files, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""include"". **CMAKE_INSTALL_DOCDIR**:PATH; The path to install documentation, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""share/doc"". **CMAKE_INSTALL_MANDIR**:PATH; The path to install manpage files, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""share/man"". .. _LLVM-related variables:. LLVM-related variables; ------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:10324,variab,variables,10324,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"Data & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional; *extended* boolean flag as *false*. This method is implemented by the class `ROOT::Fit:::PoissonLikelihoodFCN`.; * **Un-Binned likelihood fit**: `Fitter::LikelihoodFit(const UnBindata &)`. The user needs to pass an `UnBinData` object. By default the fit is not extended (i.e. the normalization is not fitted to the; data). As above the user can select an extended likelihood fit by passing the optional; *extended* boolean flag as *true*. This method is implemented using the class `LogLikelihoodFCN`; * **Linear Fit**: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the *Matrix* library), if the model function is linear in the; parameters. #### Customised Fit methods. Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize.; In this case, the user does not really need to build as input a `ROOT::Fit` data set and model function as we described before. He can implements its own version of the method function using on its own; data set objects and functions. In this case `ROOT::Fit::Fitter::SetFCN` is used to set the method function and `ROOT::Fit::FitFCN` is used for fitting. The method function can be passed also in `ROOT::Fit::FitFCN`, but in this; case a pre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:46650,extend,extended,46650,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,2,['extend'],['extended']
Modifiability,"Date: Fri, 6 Jul 2001 16:56:56 -0500; From: Vikram S. Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <lattner@cs.uiuc.edu>; Subject: lowering the IR. BTW, I do think that we should consider lowering the IR as you said. I; didn't get time to raise it today, but it comes up with the SPARC; move-conditional instruction. I don't think we want to put that in the core; VM -- it is a little too specialized. But without a corresponding; conditional move instruction in the VM, it is pretty difficult to maintain a; close mapping between VM and machine code. Other architectures may have; other such instructions. What I was going to suggest was that for a particular processor, we define; additional VM instructions that match some of the unusual opcodes on the; processor but have VM semantics otherwise, i.e., all operands are in SSA; form and typed. This means that we can re-generate core VM code from the; more specialized code any time we want (so that portability is not lost). Typically, a static compiler like gcc would generate just the core VM, which; is relatively portable. Anyone (an offline tool, the linker, etc., or even; the static compiler itself if it chooses) can transform that into more; specialized target-specific VM code for a particular architecture. If the; linker does it, it can do it after all machine-independent optimizations.; This would be the most convenient, but not necessary. The main benefit of lowering will be that we will be able to retain a close; mapping between VM and machine code. --Vikram. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-07-06-LoweringIRForCodeGen.txt:952,portab,portability,952,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-07-06-LoweringIRForCodeGen.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-07-06-LoweringIRForCodeGen.txt,2,['portab'],"['portability', 'portable']"
Modifiability,"Date: Sat, 18 Nov 2000 09:19:35 -0600 (CST); From: Vikram Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <lattner@cs.uiuc.edu>; Subject: a few thoughts. I've been mulling over the virtual machine problem and I had some; thoughts about some things for us to think about discuss:. 1. We need to be clear on our goals for the VM. Do we want to emphasize; portability and safety like the Java VM? Or shall we focus on the; architecture interface first (i.e., consider the code generation and; processor issues), since the architecture interface question is also; important for portable Java-type VMs?. This is important because the audiences for these two goals are very; different. Architects and many compiler people care much more about; the second question. The Java compiler and OS community care much more; about the first one. Also, while the architecture interface question is important for; Java-type VMs, the design constraints are very different. 2. Design issues to consider (an initial list that we should continue; to modify). Note that I'm not trying to suggest actual solutions here,; but just various directions we can pursue:. a. A single-assignment VM, which we've both already been thinking about. b. A strongly-typed VM. One question is do we need the types to be; explicitly declared or should they be inferred by the dynamic compiler?. c. How do we get more high-level information into the VM while keeping; to a low-level VM design?. o Explicit array references as operands? An alternative is; to have just an array type, and let the index computations be; separate 3-operand instructions. o Explicit instructions to handle aliasing, e.g.s:; -- an instruction to say ""I speculate that these two values are not; aliased, but check at runtime"", like speculative execution in; EPIC?; -- or an instruction to check whether two values are aliased and; execute different code depending on the answer, somewhat like; predicated code in EPIC. o (This one is a difficult but powerful idea.); A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt:349,portab,portability,349,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt,2,['portab'],"['portability', 'portable']"
Modifiability,"Date: Sun, 19 Nov 2000 16:23:57 -0600 (CST); From: Chris Lattner <sabre@nondot.org>; To: Vikram Adve <vadve@cs.uiuc.edu>; Subject: Re: a few thoughts. Okay... here are a few of my thoughts on this (it's good to know that we; think so alike!):. > 1. We need to be clear on our goals for the VM. Do we want to emphasize; > portability and safety like the Java VM? Or shall we focus on the; > architecture interface first (i.e., consider the code generation and; > processor issues), since the architecture interface question is also; > important for portable Java-type VMs?. I forsee the architecture looking kinda like this: (which is completely; subject to change). 1. The VM code is NOT guaranteed safe in a java sense. Doing so makes it; basically impossible to support C like languages. Besides that,; certifying a register based language as safe at run time would be a; pretty expensive operation to have to do. Additionally, we would like; to be able to statically eliminate many bounds checks in Java; programs... for example. 2. Instead, we can do the following (eventually): ; * Java bytecode is used as our ""safe"" representation (to avoid; reinventing something that we don't add much value to). When the; user chooses to execute Java bytecodes directly (ie, not; precompiled) the runtime compiler can do some very simple; transformations (JIT style) to convert it into valid input for our; VM. Performance is not wonderful, but it works right.; * The file is scheduled to be compiled (rigorously) at a later; time. This could be done by some background process or by a second; processor in the system during idle time or something...; * To keep things ""safe"" ie to enforce a sandbox on Java/foreign code,; we could sign the generated VM code with a host specific private; key. Then before the code is executed/loaded, we can check to see if; the trusted compiler generated the code. This would be much quicker; than having to validate consistency (especially if bounds checks have; been remo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:321,portab,portability,321,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,2,['portab'],"['portability', 'portable']"
Modifiability,"Date: Wed, 20 Jun 2001 12:32:22 -0500; From: Vikram Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <lattner@cs.uiuc.edu>; Subject: .NET vs. our VM. One significant difference between .NET CLR and our VM is that the CLR; includes full information about classes and inheritance. In fact, I just; sat through the paper on adding templates to .NET CLR, and the speaker; indicated that the goal seems to be to do simple static compilation (very; little lowering or optimization). Also, the templates implementation in CLR; ""relies on dynamic class loading and JIT compilation"". This is an important difference because I think there are some significant; advantages to have a much lower level VM layer, and do significant static; analysis and optimization. I also talked to the lead guy for KAI's C++ compiler (Arch Robison) and he; said that SGI and other commercial compilers have included options to export; their *IR* next to the object code (i.e., .il files) and use them for; link-time code generation. In fact, he said that the .o file was nearly; empty and was entirely generated from the .il at link-time. But he agreed; that this limited the link-time interprocedural optimization to modules; compiled by the same compiler, whereas our approach allows us to link and; optimize modules from multiple different compilers. (Also, of course, they; don't do anything for runtime optimization). All issues to bring up in Related Work. --Vikram. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-20-.NET-Differences.txt:261,inherit,inheritance,261,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-20-.NET-Differences.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-20-.NET-Differences.txt,1,['inherit'],['inheritance']
Modifiability,"Date: Wed, 31 Jan 2001 12:04:33 -0600; From: Vikram S. Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <lattner@cs.uiuc.edu>; Subject: another thought. I have a budding idea about making LLVM a little more ambitious: a; customizable runtime system that can be used to implement language-specific; virtual machines for many different languages. E.g., a C vm, a C++ vm, a; Java vm, a Lisp vm, .. The idea would be that LLVM would provide a standard set of runtime features; (some low-level like standard assembly instructions with code generation and; static and runtime optimization; some higher-level like type-safety and; perhaps a garbage collection library). Each language vm would select the; runtime features needed for that language, extending or customizing them as; needed. Most of the machine-dependent code-generation and optimization; features as well as low-level machine-independent optimizations (like PRE); could be provided by LLVM and should be sufficient for any language,; simplifying the language compiler. (This would also help interoperability; between languages.) Also, some or most of the higher-level; machine-independent features like type-safety and access safety should be; reusable by different languages, with minor extensions. The language; compiler could then focus on language-specific analyses and optimizations. The risk is that this sounds like a universal IR -- something that the; compiler community has tried and failed to develop for decades, and is; universally skeptical about. No matter what we say, we won't be able to; convince anyone that we have a universal IR that will work. We need to; think about whether LLVM is different or if has something novel that might; convince people. E.g., the idea of providing a package of separable; features that different languages select from. Also, using SSA with or; without type-safety as the intermediate representation. One interesting starting point would be to discuss how a JVM would be; implemented on top of LLV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt:736,extend,extending,736,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,1,['extend'],['extending']
Modifiability,Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of explicit specializations; Unknown. 606; CD1; Template argument deduction for rvalue references; Clang 3.0. 607; CD6; Lookup of mem-initializer-ids; Yes. 608; CD2; Determining the final overrider of a virtual function; Yes. 609; CD4; What is a “top-level” cv-qualifier?; Unknown. 610; NAD; Computing the negative of 0U; Yes. 611; CD2; Zero-initializing references; Yes. 612; CD2; Requirements on a conforming implementation; N/A. 613; CD1; Unevaluated uses of non-static class members; Yes (C++11 onwards). 614; CD1; Results of integer / and %; Yes. 615; C++11; Incorrect description of variables that can be initialized; Yes. 616; CD3; Definition of “indeterminate value”; Clang 4. 617; NAD; Lvalue-to-rvalue conversions of uninitialized char objects; Unknown. 618; CD2; Casts in preprocessor conditional expressions; Yes. 619; C++11; Completeness of array types; Yes. 620; CD1; Declaration order in layout-compatible POD structs; Duplicate of 568. 621; C++11; Template argument deduction from function return types; Yes. 622; NAD; Relational comparisons of arbitrary pointers; Unknown. 623; CD3; Use of pointers to deallocated storage; N/A. 624; CD1; Overflow in calculating size of allocation; Unknown. 625; CD2; Use of auto as a template-argument; Yes. 626; CD2; Preprocessor string literals; Yes. 627; NAD; Values behaving as types; Yes. 628; CD2; The values of an enumeration with no enumerator; N/A. 629; CD1; auto parsing ambiguity; Clang 2.9. 630; CD2; Equality of narrow and wide character values in the basic character set; Yes. 631; CD3; Jumping into a “then” clause; N/A. 632,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:42096,variab,variables,42096,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"Deploying the Virtual Analysis Facility; =======================================. Introduction; ------------. Thanks to CernVM and PROOF on Demand, it is possible to deploy a ready; to use Virtual Analysis Facility on your cloud (either public, private; or even your desktop computer). On the server side, ""configuring"" the Virtual Analysis Facility is; simply a matter of starting a certain number of CernVM virtual machines; that will become part of your PROOF cluster. CernVM uses; contextualization to specialize each virtual machine to be either a head; node or a worker node. The Virtual Analysis Facility comes with many preconfigured things:. - a HTCondor cluster capable of running PROOF on Demand. - certificate authentication. - your experiment's software (if available on CernVM-FS). Obtain the CernVM image and contextualization; ---------------------------------------------. ### Download the CernVM bare image. The Virtual Analysis Facility currently works with *CernVM Batch 2.7.1; 64-bit*. This means that you need to have this CernVM image available; either on your local hard disk (in case of a desktop deployment) or in; your cloud's image repository. > For convenience we provide the direct link for the working versions:; >; > - [CernVM 2.7.1 batch 64-bit for; > **KVM**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.hdd.gz); >; > - [CernVM 2.7.1 batch 64-bit for; > **Xen**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.ext3.gz); >; > Images are gzipped. In most cases you'll need to gunzip them before; > registering to your image repository. ### Create VM configuration profiles. CernVM images are base images supporting boot-time customization via; configuration profiles called ""contexts"". Context creation can be; performed through the [CernVM Online](https://cernvm-online.cern.ch/); website. The site is immediately accessible if you have a CERN account. Go to your [CernVM Online; Dashboard](https://cernvm-online.cern.c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:307,config,configuring,307,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['config'],['configuring']
Modifiability,"Deprecated,; use :option:`--order` instead. .. option:: --per-test-coverage. Emit the necessary test coverage data, divided per test case (involves; setting a unique value to LLVM_PROFILE_FILE for each RUN). The coverage; data files will be emitted in the directory specified by `config.test_exec_root`. .. option:: --max-failures N. Stop execution after the given number ``N`` of failures.; An integer argument should be passed on the command line; prior to execution. .. option:: --max-tests=N. Run at most ``N`` tests and then terminate. .. option:: --max-time=N. Spend at most ``N`` seconds (approximately) running tests and then terminate.; Note that this is not an alias for :option:`--timeout`; the two are; different kinds of maximums. .. option:: --num-shards=M. Divide the set of selected tests into ``M`` equal-sized subsets or; ""shards"", and run only one of them. Must be used with the; ``--run-shard=N`` option, which selects the shard to run. The environment; variable ``LIT_NUM_SHARDS`` can also be used in place of this; option. These two options provide a coarse mechanism for partitioning large; testsuites, for parallel execution on separate machines (say in a large; testing farm). .. option:: --order={lexical,random,smart}. Define the order in which tests are run. The supported values are:. - lexical - tests will be run in lexical order according to the test file; path. This option is useful when predictable test order is desired. - random - tests will be run in random order. - smart - tests that failed previously will be run first, then the remaining; tests, all in descending execution time order. This is the default as it; optimizes concurrency. .. option:: --run-shard=N. Select which shard to run, assuming the ``--num-shards=M`` option was; provided. The two options must be used together, and the value of ``N``; must be in the range ``1..M``. The environment variable; ``LIT_RUN_SHARD`` can also be used in place of this option. .. option:: --timeout=N. Spend at ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:6836,variab,variable,6836,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['variab'],['variable']
Modifiability,DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122680,plugin,plugins,122680,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"Draw` method can also be used to fill a specific histogram.; The syntax is:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack >> myHisto""); root[] myHisto->Print(); TH1.Print Name= myHisto, Entries= 100, Total sum= 100; ```. As we can see, this created a **`TH1`**, called `myHisto`. If you want; to append more entries to the histogram, you can use this syntax:. ``` {.cpp}; root[] T->Draw(""fNtrack >>+ myHisto""); ```. If you do not create a histogram ahead of time, ROOT will create one at; the time of the Draw command (as is the case above). If you would like; to draw the variable into a specific histogram where you, for example,; set the range and bin number, you can define the histogram ahead of time; and use it in the Draw command. The histogram has to be in the same; directory as the tree. ``` {.cpp}; root[] TH1 *h1 = new TH1(""h1"",""h1"",50,0.,150.);; root[] T->Draw(""fNtrack>> h1"");; ```. When you project a **`TTree`** into a histogram, the histogram inherits; the **`TTree`** attributes and not the current style attributes. This; allows you to project two Trees with different attributes into the same; picture. You can call the method `TTree::UseCurrentStyle` to change the; histogram to use the current style ***`gStyle`***. See ""Graphics and the; Graphical User Interface. The binning of the newly created histogram can be specified in two ways.; You can set a default in the `.rootrc` and/or you can add the binning; information in the `TTree::Draw` command. To set number of bins default for the 1-D, 2-D, 3-D histograms can be; specified in the `.rootrc` file via the environment variables, e.g.:. ```; # default binnings Hist.Binning.1D.x: 100. Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100. Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; ```. To set the number of bins for a specific histogram when using; `TTree::Draw,` add up to nine number",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:116067,inherit,inherits,116067,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['inherit'],['inherits']
Modifiability,"E ""${CLANG_VENDOR} clang""); else(); set(TOOL_INFO_NAME ""clang""); endif(). set(TOOL_INFO_UTI ""${CLANG_VENDOR_UTI}""); set(TOOL_INFO_VERSION ""${CLANG_VERSION}""); set(TOOL_INFO_BUILD_VERSION ""${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}""). set(TOOL_INFO_PLIST_OUT ""${CMAKE_CURRENT_BINARY_DIR}/${TOOL_INFO_PLIST}""). if(LLVM_TOOL_LLVM_DRIVER_BUILD AND clang IN_LIST LLVM_DRIVER_TOOLS); set(TARGET_NAME llvm-driver); else(); set(TARGET_NAME clang); endif(). target_link_libraries(${TARGET_NAME}; PRIVATE; ""-Wl,-sectcreate,__TEXT,__info_plist,\""${TOOL_INFO_PLIST_OUT}\""""); configure_file(""${TOOL_INFO_PLIST}.in"" ""${TOOL_INFO_PLIST_OUT}"" @ONLY). set(TOOL_INFO_UTI); set(TOOL_INFO_NAME); set(TOOL_INFO_VERSION); set(TOOL_INFO_BUILD_VERSION); endif(). if(CLANG_ORDER_FILE AND; (LLVM_LINKER_IS_APPLE OR LLVM_LINKER_IS_GOLD OR LLVM_LINKER_IS_LLD)); include(LLVMCheckLinkerFlag). if (LLVM_LINKER_IS_APPLE OR (LLVM_LINKER_IS_LLD AND APPLE)); set(LINKER_ORDER_FILE_OPTION ""-Wl,-order_file,${CLANG_ORDER_FILE}""); elseif (LLVM_LINKER_IS_GOLD); set(LINKER_ORDER_FILE_OPTION ""-Wl,--section-ordering-file,${CLANG_ORDER_FILE}""); elseif (LLVM_LINKER_IS_LLD); set(LINKER_ORDER_FILE_OPTION ""-Wl,--symbol-ordering-file,${CLANG_ORDER_FILE}""); endif(). # This is a test to ensure the actual order file works with the linker.; llvm_check_linker_flag(CXX ${LINKER_ORDER_FILE_OPTION} LINKER_ORDER_FILE_WORKS). # Passing an empty order file disables some linker layout optimizations.; # To work around this and enable workflows for re-linking when the order file; # changes we check during configuration if the file is empty, and make it a; # configuration dependency.; file(READ ${CLANG_ORDER_FILE} ORDER_FILE LIMIT 20); if(""${ORDER_FILE}"" STREQUAL ""\n""); set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS ${CLANG_ORDER_FILE}); elseif(LINKER_ORDER_FILE_WORKS); target_link_libraries(clang PRIVATE ${LINKER_ORDER_FILE_OPTION}); set_target_properties(clang PROPERTIES LINK_DEPENDS ${CLANG_ORDER_FILE}); endif(); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/CMakeLists.txt:2918,config,configuration,2918,interpreter/llvm-project/clang/tools/driver/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/CMakeLists.txt,2,['config'],['configuration']
Modifiability,"E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_GNU`` (in configuration: ``GNU``); Always break before braces and add an extra level of indentation to; braces of control statements, not to those of class, function; or other definitions. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; }; while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_WebKit`` (in configuration: ``WebKit``); Like ``Attach``, but break before functions. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`` (in configuration: ``Custom``); Configure each individual brace in ``BraceWrapping``. .. _BreakBeforeConceptDeclarations:. **BreakBeforeConceptDeclarations** (``BreakBeforeConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``All",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:51408,config,configuration,51408,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"EFAULT_OPENMP_RUNTIME ""libomp"" CACHE STRING; ""Default OpenMP runtime used by -fopenmp.""). set(CLANG_SYSTEMZ_DEFAULT_ARCH ""z10"" CACHE STRING ""SystemZ Default Arch""). set(CLANG_VENDOR ${PACKAGE_VENDOR} CACHE STRING; ""Vendor-specific text for showing with version information.""). set(CLANG_REPOSITORY_STRING """" CACHE STRING; ""Vendor-specific text for showing the repository the source is taken from.""). if(CLANG_REPOSITORY_STRING); add_definitions(-DCLANG_REPOSITORY_STRING=""${CLANG_REPOSITORY_STRING}""); endif(). set(CLANG_VENDOR_UTI ""org.llvm.clang"" CACHE STRING; ""Vendor-specific uti.""). set(CLANG_PYTHON_BINDINGS_VERSIONS """" CACHE STRING; ""Python versions to install libclang python bindings for""). set(CLANG_LINK_CLANG_DYLIB ${LLVM_LINK_LLVM_DYLIB} CACHE BOOL; ""Link tools against libclang-cpp.so""). if (NOT LLVM_LINK_LLVM_DYLIB AND CLANG_LINK_CLANG_DYLIB); message(FATAL_ERROR ""Cannot set CLANG_LINK_CLANG_DYLIB=ON when ""; ""LLVM_LINK_LLVM_DYLIB=OFF""); endif(). # The libdir suffix must exactly match whatever LLVM's configuration used.; set(CLANG_LIBDIR_SUFFIX ""${LLVM_LIBDIR_SUFFIX}""). set(CLANG_TOOLS_INSTALL_DIR ""${CMAKE_INSTALL_BINDIR}"" CACHE PATH; ""Path for binary subdirectory (defaults to '${CMAKE_INSTALL_BINDIR}')""); mark_as_advanced(CLANG_TOOLS_INSTALL_DIR). set(CLANG_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}); set(CLANG_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}). if( CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR AND NOT MSVC_IDE ); message(FATAL_ERROR ""In-source builds are not allowed. ""; ""Please create a directory and run cmake ""; ""from there, passing the path to this source directory as the last argument. ""; ""This process created the file `CMakeCache.txt' and the directory ""; ""`CMakeFiles'. Please delete them.""); endif(). # If CLANG_VERSION_* is specified, use it, if not use LLVM_VERSION_*.; if(NOT DEFINED CLANG_VERSION_MAJOR); set(CLANG_VERSION_MAJOR ${LLVM_VERSION_MAJOR}); endif(); if(NOT DEFINED CLANG_VERSION_MINOR); set(CLANG_VERSION_MINOR ${LLVM_VERSION_MINOR}); endif(); if(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:10642,config,configuration,10642,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"ETUP.C, improving transparency; between normal ROOT and PROOF. The example PAR; 'tutorials/proof/event.par' has been modified to check the two; variables.; Fix a few issues in SQL PROOF monitoring: in; TSQLMonitoringWriter::SendParameters, drop ''' around field names in; the INSERT string; also use TString::Format(...) instead of Form(...); where relevant.  In TPerfStats: call 'proofgroup' instead of; 'group' the field with the PROOF group (interference with the 'group'; keyword in SQL); add new field 'querytag' VARCHAR(64) with the unique; query tag; in WriteQueryLog fill also the field 'totevents'; in; PacketEvent, add switch to control whether to send te information to; the monitoring system on per packet level (may be too much for SQL).; The switch is called fMonitorPerPacket and it is globally controlled by; the rootrc variable 'Proof.MonitorPerPacket' and at session level with; the parameter PROOF_MonitorPerPacket .; Improve treatment of the case when temporary files are asked to be; created on a shared file system not containing the sandboxes. This; case, which seems to be a rather common one, should be now fully; supported.; Correctly honour selector abort status settings; TSelector::kAbortProcess and TSelector::kAbortFile.; Improve reporting of the non-processed {files, events} in the final; 'MissingFiles' list.  ; Improved algorithm for TPacketizerUnit to fix issue with non; homogeneous machines.; Improve the way the information about log files is saved in case of; failures. The log paths for these failing now should be now correctly; saved and accessible via TProofLog.; Improve merging of histograms. Just use TH1::Add whne the axis are; equal; much faster than TH1::Merge. Fixes; ; In TDataSetManagerFile::NotifyUpdate fix handling of the case when; the global list file does not exist yet (new dataset directory). Fixes; error messages during editing dataset operations.; Fix issue with machine names consistency when working on a local; machine ('localhost' or",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:4588,sandbox,sandboxes,4588,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,1,['sandbox'],['sandboxes']
Modifiability,"ET_TRIPLE DIRECTORY llvm-project/llvm DEFINITION LLVM_TARGET_TRIPLE); #---Get back the potentially updated LLVM_TARGETS_TO_BUILD (expanding all/host/Native)---------------; get_directory_property(LLVM_TARGETS_TO_BUILD DIRECTORY llvm-project/llvm DEFINITION LLVM_TARGETS_TO_BUILD). if(MSVC); if(CMAKE_GENERATOR MATCHES Ninja); set(LLVM_TABLEGEN_EXE ""${LLVM_BINARY_DIR}/bin/llvm-tblgen.exe""); else(); set(LLVM_TABLEGEN_EXE ""${LLVM_BINARY_DIR}/$<CONFIG>/bin/llvm-tblgen.exe""); endif(); else(); set(LLVM_TABLEGEN_EXE ""${LLVM_BINARY_DIR}/bin/llvm-tblgen""); endif(); else(); # Rely on llvm-config.; set(CONFIG_OUTPUT); find_program(LLVM_CONFIG NAMES ""llvm-config-${ROOT_LLVM_VERSION_REQUIRED_MAJOR}"" ""llvm-config""); if(LLVM_CONFIG); message(STATUS ""Found LLVM_CONFIG as ${LLVM_CONFIG}""); set(CONFIG_COMMAND ${LLVM_CONFIG}; ""--assertion-mode""; ""--bindir""; ""--libdir""; ""--includedir""; ""--prefix""; ""--cmakedir""; ""--build-mode""; ""--version""); execute_process(; COMMAND ${CONFIG_COMMAND}; RESULT_VARIABLE HAD_ERROR; OUTPUT_VARIABLE CONFIG_OUTPUT; ); if(NOT HAD_ERROR); string(REGEX REPLACE; ""[ \t]*[\r\n]+[ \t]*"" "";""; CONFIG_OUTPUT ${CONFIG_OUTPUT}); else(); string(REPLACE "";"" "" "" CONFIG_COMMAND_STR ""${CONFIG_COMMAND}""); message(STATUS ""${CONFIG_COMMAND_STR}""); message(FATAL_ERROR ""llvm-config failed with status ${HAD_ERROR}""); endif(); else(); message(FATAL_ERROR ""llvm-config not found -- ${LLVM_CONFIG}""); endif(). list(GET CONFIG_OUTPUT 0 ENABLE_ASSERTIONS); list(GET CONFIG_OUTPUT 1 TOOLS_BINARY_DIR); list(GET CONFIG_OUTPUT 2 LIBRARY_DIR); list(GET CONFIG_OUTPUT 3 INCLUDE_DIR); list(GET CONFIG_OUTPUT 4 LLVM_OBJ_ROOT); list(GET CONFIG_OUTPUT 5 LLVM_CONFIG_CMAKE_PATH); list(GET CONFIG_OUTPUT 6 LLVM_BUILD_MODE); list(GET CONFIG_OUTPUT 7 LLVM_VERSION). message(STATUS ""External llvm built in ${LLVM_BUILD_MODE} mode.""). if(NOT MSVC_IDE); set(LLVM_ENABLE_ASSERTIONS ${ENABLE_ASSERTIONS}; CACHE BOOL ""Enable assertions""); # Assertions should follow llvm-config's.; mark_as_advanced(LLVM_ENABLE_ASSERTIONS",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:12577,config,config,12577,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,4,['config'],['config']
Modifiability,"E_BUILD_TYPE=RelWithDebInfo`` instead of; ``-DCMAKE_BUILD_TYPE=Release``. This will grant better coverage of; debug info pieces of clang, but will take longer to complete and will; result in a much larger build directory. It's recommended to build the ``all`` target with your instrumented Clang,; since more coverage is often better. b. You should now have a few ``*.profraw`` files in; ``path/to/stage2/profiles/``. You need to merge these using; ``llvm-profdata`` (even if you only have one! The profile merge transforms; profraw into actual profile data, as well). This can be done with; ``/path/to/stage1/llvm-profdata merge; -output=/path/to/output/profdata.prof path/to/stage2/profiles/*.profraw``. 4. Now, build your final, PGO-optimized Clang. To do this, you'll want to pass; the following additional arguments to CMake. - ``-DLLVM_PROFDATA_FILE=/path/to/output/profdata.prof`` - Use the PGO; profile from the previous step.; - ``-DCMAKE_C_COMPILER=/path/to/stage1/clang`` - Use the Clang we built in; step 1.; - ``-DCMAKE_CXX_COMPILER=/path/to/stage1/clang++`` - Same as above. From here, you can build whatever targets you need. .. note::; You may see warnings about a mismatched profile in the build output. These; are generally harmless. To silence them, you can add; ``-DCMAKE_C_FLAGS='-Wno-backend-plugin'; -DCMAKE_CXX_FLAGS='-Wno-backend-plugin'`` to your CMake invocation. Congrats! You now have a Clang built with profile-guided optimizations, and you; can delete all but the final build directory if you'd like. If this worked well for you and you plan on doing it often, there's a slight; optimization that can be made: LLVM and Clang have a tool called tblgen that's; built and run during the build process. While it's potentially nice to build; this for coverage as part of step 3, none of your other builds should benefit; from building it. You can pass the CMake option; ``-DLLVM_NATIVE_TOOL_DIR=/path/to/stage1/bin``; to steps 2 and onward to avoid these useless rebuilds.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst:6585,plugin,plugin,6585,interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,2,['plugin'],['plugin']
Modifiability,"E_LINKER=lld``. Rarely-used CMake variables; ---------------------------. Here are some of the CMake variables that are rarely used, along with a brief; explanation and LLVM-related notes. For full documentation, consult the CMake; manual, or execute ``cmake --help-variable VARIABLE_NAME``. **CMAKE_CXX_STANDARD**:STRING; Sets the C++ standard to conform to when building LLVM. Possible values are; 17 and 20. LLVM Requires C++ 17 or higher. This defaults to 17. **CMAKE_INSTALL_BINDIR**:PATH; The path to install executables, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""bin"". **CMAKE_INSTALL_INCLUDEDIR**:PATH; The path to install header files, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""include"". **CMAKE_INSTALL_DOCDIR**:PATH; The path to install documentation, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""share/doc"". **CMAKE_INSTALL_MANDIR**:PATH; The path to install manpage files, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""share/man"". .. _LLVM-related variables:. LLVM-related variables; -----------------------. These variables provide fine control over the build of LLVM and; enabled sub-projects. Nearly all of these variable names begin with; ``LLVM_``. **BUILD_SHARED_LIBS**:BOOL; Flag indicating if each LLVM component (e.g. Support) is built as a shared; library (ON) or as a static library (OFF). Its default value is OFF. On; Windows, shared libraries may be used when building with MinGW, including; mingw-w64, but not when building with the Microsoft toolchain. .. note:: BUILD_SHARED_LIBS is only recommended for use by LLVM developers.; If you want to build LLVM as a shared library, you should use the; ``LLVM_BUILD_LLVM_DYLIB`` option. **LLVM_ABI_BREAKING_CHECKS**:STRING; Used to decide if LLVM should be built with ABI breaking checks or; not. Allowed values are `WITH_ASSERTS` (default), `FORCE_ON` and; `FORCE_OFF`. `WITH_ASSERTS` turns on ABI breaking checks in an; assertion enabled build. `FORCE_ON` (`FORCE_OFF`) turns them on;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:11292,variab,variables,11292,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"Error reading body, remove function.; TheFunction->eraseFromParent();; return nullptr;; }. The only piece left here is handling of the error case. For simplicity,; we handle this by merely deleting the function we produced with the; ``eraseFromParent`` method. This allows the user to redefine a function; that they incorrectly typed in before: if we didn't delete it, it would; live in the symbol table, with a body, preventing future redefinition. This code does have a bug, though: If the ``FunctionAST::codegen()`` method; finds an existing IR Function, it does not validate its signature against the; definition's own prototype. This means that an earlier 'extern' declaration will; take precedence over the function definition's signature, which can cause; codegen to fail, for instance if the function arguments are named differently.; There are a number of ways to fix this bug, see what you can come up with! Here; is a testcase:. ::. extern foo(a); # ok, defines foo.; def foo(b) b; # Error: Unknown variable name. (decl using 'a' takes precedence). Driver Changes and Closing Thoughts; ===================================. For now, code generation to LLVM doesn't really get us much, except that; we can look at the pretty IR calls. The sample code inserts calls to; codegen into the ""``HandleDefinition``"", ""``HandleExtern``"" etc; functions, and then dumps out the LLVM IR. This gives a nice way to look; at the LLVM IR for simple functions. For example:. ::. ready> 4+5;; Read top-level expression:; define double @0() {; entry:; ret double 9.000000e+00; }. Note how the parser turns the top-level expression into anonymous; functions for us. This will be handy when we add `JIT; support <LangImpl04.html#adding-a-jit-compiler>`_ in the next chapter. Also note that the; code is very literally transcribed, no optimizations are being performed; except simple constant folding done by IRBuilder. We will `add; optimizations <LangImpl04.html#trivial-constant-folding>`_ explicitly in the ne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:17409,variab,variable,17409,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variable']
Modifiability,"Errors printed to stderr are shown. ```tablegen; %reset; This is not tablegen.; ```. <stdin>:1:1: error: Unexpected token at top level; This is not tablegen.; ^. Add some classes to get some output. ```tablegen; %reset; class Stuff {}; def thing : Stuff {}; ```. ------------- Classes -----------------; class Stuff {; }; ------------- Defs -----------------; def thing {	// Stuff; }. By default cells are connected. Meaning that we cache the code and magic directives from the previously run cells. This means that the next cell still sees the `Stuff` class. ```tablegen; def other_thing : Stuff {}; ```. ------------- Classes -----------------; class Stuff {; }; ------------- Defs -----------------; def other_thing {	// Stuff; }; def thing {	// Stuff; }. You can use the magic `%reset` to clear this cache and start fresh. ```tablegen; %reset; def other_thing : Stuff {}; ```. <stdin>:1:19: error: Couldn't find class 'Stuff'; def other_thing : Stuff {}; ^. You can also configure the default reset behaviour using the `%config` magic. ```tablegen; %config cellreset on; class Thing {}; ```. ------------- Classes -----------------; class Thing {; }; ------------- Defs -----------------. ```tablegen; // The cache is reset here so this is an error.; def AThing: Thing {}; ```. <stdin>:2:13: error: Couldn't find class 'Thing'; def AThing: Thing {}; ^. The default value is `off`, meaning cells are connected. If you want to override the default for one cell only, use the `%reset` or `%noreset` magic. These always override the default. ```tablegen; class Thing {}; ```. ------------- Classes -----------------; class Thing {; }; ------------- Defs -----------------. ```tablegen; %noreset; // This works because of the noreset above.; def AThing: Thing {}; ```. ------------- Classes -----------------; class Thing {; }; ------------- Defs -----------------; def AThing {	// Thing; }. ```tablegen; // This does not because we're not changing the default.; def AnotherThing: Thing {}; ```. <stdi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/LLVM_TableGen.md:1200,config,configure,1200,interpreter/llvm-project/llvm/utils/TableGen/jupyter/LLVM_TableGen.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/LLVM_TableGen.md,2,['config'],"['config', 'configure']"
Modifiability,"ExcessCharacter:. **PenaltyExcessCharacter** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyExcessCharacter>`; The penalty for each character outside of the column limit. .. _PenaltyIndentedWhitespace:. **PenaltyIndentedWhitespace** (``Unsigned``) :versionbadge:`clang-format 12` :ref:`¶ <PenaltyIndentedWhitespace>`; Penalty for each character of whitespace indentation; (counted relative to leading non-whitespace column). .. _PenaltyReturnTypeOnItsOwnLine:. **PenaltyReturnTypeOnItsOwnLine** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyReturnTypeOnItsOwnLine>`; Penalty for putting the return type of a function onto its own line. .. _PointerAlignment:. **PointerAlignment** (``PointerAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <PointerAlignment>`; Pointer and reference alignment style. Possible values:. * ``PAS_Left`` (in configuration: ``Left``); Align pointer to the left. .. code-block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:96245,config,configuration,96245,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"Expression field of the original debug intrinsic. The second form, ``DBG_VALUE_LIST``, appears thus:. .. code-block:: text. DBG_VALUE_LIST !123, !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_plus), %1, %2. And has the following operands:; * The first operand is the Variable field of the original debug intrinsic.; * The second operand is the Expression field of the original debug intrinsic.; * Any number of operands, from the 3rd onwards, record a sequence of variable; location operands, which may take any of the same values as the first; operand of the ``DBG_VALUE`` instruction above. These variable location; operands are inserted into the final DWARF Expression in positions indicated; by the DW_OP_LLVM_arg operator in the `DIExpression; <LangRef.html#diexpression>`_. The position at which the DBG_VALUEs are inserted should correspond to the; positions of their matching ``llvm.dbg.value`` intrinsics in the IR block. As; with optimization, LLVM aims to preserve the order in which variable; assignments occurred in the source program. However SelectionDAG performs some; instruction scheduling, which can reorder assignments (discussed below).; Function parameter locations are moved to the beginning of the function if; they're not already, to ensure they're immediately available on function entry. To demonstrate variable locations during instruction selection, consider; the following example:. .. code-block:: llvm. define i32 @foo(i32* %addr) {; entry:; call void @llvm.dbg.value(metadata i32 0, metadata !3, metadata !DIExpression()), !dbg !5; br label %bb1, !dbg !5. bb1: ; preds = %bb1, %entry; %bar.0 = phi i32 [ 0, %entry ], [ %add, %bb1 ]; call void @llvm.dbg.value(metadata i32 %bar.0, metadata !3, metadata !DIExpression()), !dbg !5; %addr1 = getelementptr i32, i32 *%addr, i32 1, !dbg !5; call void @llvm.dbg.value(metadata i32 *%addr1, metadata !3, metadata !DIExpression()), !dbg !5; %loaded1 = load i32, i32* %addr1, !dbg !5; %addr2 = getelementptr i32, i32",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:28959,variab,variable,28959,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"Expression(), debug-location !456. The operands to which respectively:. 1. Identifies a machine location such as a register, immediate, or frame index,. 2. Is either $noreg, or immediate value zero if an extra level of indirection is to be added to the first operand,. 3. Identifies a ``DILocalVariable`` metadata node,. 4. Specifies an expression qualifying the variable location, either inline or as a metadata node reference,. While the source location identifies the ``DILocation`` for the scope of the; variable. The second operand (``IsIndirect``) is deprecated and to be deleted.; All additional qualifiers for the variable location should be made through the; expression metadata. .. _instruction-referencing-locations:. Instruction referencing locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This experimental feature aims to separate the specification of variable; *values* from the program point where a variable takes on that value. Changes; in variable value occur in the same manner as ``DBG_VALUE`` meta instructions; but using ``DBG_INSTR_REF``. Variable values are identified by a pair of; instruction number and operand number. Consider the example below:. .. code-block:: text. $rbp = MOV64ri 0, debug-instr-number 1, debug-location !12; DBG_INSTR_REF !123, !DIExpression(DW_OP_LLVM_arg, 0), dbg-instr-ref(1, 0), debug-location !456. Instruction numbers are directly attached to machine instructions with an; optional ``debug-instr-number`` attachment, before the optional; ``debug-location`` attachment. The value defined in ``$rbp`` in the code; above would be identified by the pair ``<1, 0>``. The 3rd operand of the ``DBG_INSTR_REF`` above records the instruction; and operand number ``<1, 0>``, identifying the value defined by the ``MOV64ri``.; The first two operands to ``DBG_INSTR_REF`` are identical to ``DBG_VALUE_LIST``,; and the ``DBG_INSTR_REF`` s position records where the variable takes on the; designated value in the same way. More information about how these const",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:26683,variab,variable,26683,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability,"F', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Addi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132648,config,configuration,132648,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"FILL. In particular the default can be set back to the same as in version 5 by; setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill; (or ROOT_TTREECACHE_PREFILL) both to zero. TTree methods which are expected to modify a cache, like AddBranchToCache, will; attempt to setup a cache of default size if one does not exist, irrespective of; whether the auto cache creation is enabled. Additionally several methods giving; control of the cache have changed return type from void to Int_t, to be able to; return a code to indicate if there was an error. Usually TTree::SetCacheSize will no longer reset the list of branches to be; cached (either set or previously learnt) nor restart the learning phase.; The learning phase is restarted when a new cache is created, e.g. after having; removed a cache with SetCacheSize(0). ### TSelectorDraw. The axis titles in case of a `x:y:z` plot with the option `COLZ` were not correct. ### TParallelCoordVar. Change the format used to print the variables limit for ||-Coord to `%g`. It was; `%6.4f` before. ## Histogram Libraries. ### TFormula. - New version of the TFormula class based on Cling. Formula expressions are now used to create functions which are passed to Cling to be Just In Time compiled.; The expression is therefore compiled using Clang/LLVVM which will give execution time as compiled code and in addition correctness of the result obtained.; - This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as =ROOT::v5::TFormula=.; Some of the TFormula member funtions available in version 5, such as =Analyze= and =AnalyzeFunction= are not available in the new TFormula class.; On the other hand formula expressions which were valid in version 5 are still valid in TFormula version 6; - TFormula is not anymore a base class for TF1. ### TF1. - Change of its inheritance structure. `TF1` has not anymore `TFormula` as a base class, so this code. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:15092,variab,variables,15092,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['variab'],['variables']
Modifiability,"FP::get(*TheContext, APFloat(0.0));; }. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);; Builder->CreateStore(InitVal, Alloca);. // Remember the old variable binding so that we can restore the binding when; // we unrecurse.; OldBindings.push_back(NamedValues[VarName]);. // Remember this binding.; NamedValues[VarName] = Alloca;; }. There are more comments here than code. The basic idea is that we emit; the initializer, create the alloca, then update the symbol table to; point to it. Once all the variables are installed in the symbol table,; we evaluate the body of the var/in expression:. .. code-block:: c++. // Codegen the body, now that all vars are in scope.; Value *BodyVal = Body->codegen();; if (!BodyVal); return nullptr;. Finally, before returning, we restore the previous variable bindings:. .. code-block:: c++. // Pop all our variables from scope.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i); NamedValues[VarNames[i].first] = OldBindings[i];. // Return the body computation.; return BodyVal;; }. The end result of all of this is that we get properly scoped variable; definitions, and we even (trivially) allow mutation of them :). With this, we completed what we set out to do. Our nice iterative fib; example from the intro compiles and runs just fine. The mem2reg pass; optimizes all of our stack variables into SSA registers, inserting PHI; nodes where needed, and our front-end remains simple: no ""iterated; dominance frontier"" computation anywhere in sight. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; mutable variables and var/in support. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter7/toy.cpp; :language: c++. `Next: Compiling to Object Code <LangImpl08.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:28623,variab,variable,28623,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,5,"['config', 'enhance', 'variab']","['config', 'enhanced', 'variable', 'variables']"
Modifiability,"First; it searches all the modules that have already been added to the JIT, from the; most recent to the oldest, to find the newest definition. If no definition is; found inside the JIT, it falls back to calling ""``dlsym(""sin"")``"" on the; Kaleidoscope process itself. Since ""``sin``"" is defined within the JIT's; address space, it simply patches up calls in the module to call the libm; version of ``sin`` directly. But in some cases this even goes further:; as sin and cos are names of standard math functions, the constant folder; will directly evaluate the function calls to the correct result when called; with constants like in the ""``sin(1.0)``"" above. In the future we'll see how tweaking this symbol resolution rule can be used to; enable all sorts of useful features, from security (restricting the set of; symbols available to JIT'd code), to dynamic code generation based on symbol; names, and even lazy compilation. One immediate benefit of the symbol resolution rule is that we can now extend; the language by writing arbitrary C++ code to implement operations. For example,; if we add:. .. code-block:: c++. #ifdef _WIN32; #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif. /// putchard - putchar that takes a double and returns 0.; extern ""C"" DLLEXPORT double putchard(double X) {; fputc((char)X, stderr);; return 0;; }. Note, that for Windows we need to actually export the functions because; the dynamic symbol loader will use ``GetProcAddress`` to find the symbols. Now we can produce simple output to the console by using things like:; ""``extern putchard(x); putchard(120);``"", which prints a lowercase 'x'; on the console (120 is the ASCII code for 'x'). Similar code could be; used to implement file I/O, console input, and many other capabilities; in Kaleidoscope. This completes the JIT and optimizer chapter of the Kaleidoscope; tutorial. At this point, we can compile a non-Turing-complete; programming language, optimize and JIT compile it in a user-d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:23787,extend,extend,23787,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['extend'],['extend']
Modifiability,"Fonts. You can activate the True Type Fonts by adding the following line in; your `.rootrc` file. ``` {.cpp}; Unix.*.Root.UseTTFonts: true; ```. You can check that you indeed use the `TTF` in your Root session. When; the `TTF` is active, you get the following message at the start of a; session: ""Free Type Engine v1.x used to render TrueType fonts."" You can; also check with the command:. ``` {.cpp}; gEnv->Print(); ```. #### Setting Text Size. Use `TAttText::SetTextSize` to set the text size. ``` {.cpp}; root[] la->SetTextSize(size); ```. The `size` is the text size expressed in percentage of the current pad; size. The text size in pixels will be:. - If current pad is horizontal, the size in pixels =; `textsize * canvas_height`. - If current pad is vertical, the size in pixels =; `textsize * canvas_width`. ![](pictures/030000D0.png) The user interface for changing the text; color, size, font and alignment looks like shown in this picture. It; takes place in the editor frame anytime the selected object inherits the; class **`TAttText`**. ### Line Attributes. All classes manipulating lines have to deal with line attributes: color,; style and width. This is done by using secondary inheritance of the; class **`TAttLine`**. The line color may be set by a method call. What; is said here applies to all objects deriving from **`TAttLine`**, and; there are many (histograms, plots). We will take an example that may be; transposed to other types. Suppose ""`li`"" is a **`TLine`** object. The; line color is set with:. ``` {.cpp}; root[] li->SetLineColor(color); ```. The argument `color` is a color number. The colors are described in; ""Color and Color Palettes"". The line style may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and there are many; (histograms, plots). We will take an example that may be transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line style is; set with:. ``` {.cpp}; root[] li->SetLineStyle",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:75563,inherit,inherits,75563,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inherits']
Modifiability,"Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing the rounding mode, these conventions are not typically enforced in the ABI. Since the rounding mode changes the numerical result of operations, the compiler must understand something about it in order to optimize floating point operations. Note that floating-point operations performed as part of constant initialization are formally performed prior to the start of the program and are therefore not subject to the current rounding mode. This includes the initialization of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, alth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:61428,variab,variables,61428,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['variab'],['variables']
Modifiability,"Fraser U) for suggesting; this.; ; Methods:. BDT: New Decision Tree Pruning algorithm: Cost; Complexity Pruning a la CART. Written by Doug Schouten; (Fraser U.). It replaces the old CostComplexity and; CostComplexity2 algorithms.; . BDT: New no splitting option (choosable with; NCuts<0) that finds best split point by first sorting the; events for each variable and then looping through all; events, placing the cuts always in the middle between two; of the sorted events, and finding the true possible; maximum separation gain in the training sample by cutting; on this variable.; . BDT, AdaBoost The beta parameter is now an; option (default is 1).; . BDT: The node purity at which a node is; classified as signal (respective background node) for; determining the error fraction in the pruning became a; parameter that can be set via the option NodePurityLimit; (default is 0.5).; . Dataset preparation:. First implementation of a new preprocessing method: transformation of the; variables first into a Gaussian distribution, then performing a decorrelation of; the ""Gaussianised"" variables. The transformation is again done by default such that; (by default) the signal distributions become Gaussian and are decorrelated. Note ; that simultaneous Gaussianisation and decorrelation of signal and background is ; only possible (and done) for methods, such as Likelihood, which test both hypotheses.; . Bug fixes:. Fix in Expected error pruning: Rather than multiplying both sides, the error on ; the node and the sub-tree, with the prune strength, now only the expected error ; of the sub-tree is scaled.; . Fix in FDA parsing of the input formula. There were problems when treating; more than 10 parameters (thanks to Hugh Skottowe for reporting this).; . Calculation of ""Separation"": fixed bin-shift and; normalisation bugs. Thanks to Dag Gillberg (Fraser U) for; spotting these.; . Fixed problem in ""SetSignal(Background)WeightExpression"":; signal (background weight expressions not existing in t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v522/index.html:1309,variab,variables,1309,tmva/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v522/index.html,2,['variab'],['variables']
Modifiability,"GLabel(fFtop,""Top Frame"");; fLbottom = new TGLabel(fFbottom,""Bottom Frame"");. fFtop->AddFrame(fLtop, new TGLayoutHints(kLHintsLeft |; kLHintsCenterY,3,0,0,0));; fFbottom->AddFrame(fLbottom, new TGLayoutHints(kLHintsLeft |; kLHintsCenterY,3,0,0,0));; fH1->AddFrame(fFtop, new TGLayoutHints(kLHintsTop |; kLHintsExpandY | kLHintsExpandX,0,0,1,2));; fH2->AddFrame(fFbottom,new TGLayoutHints(kLHintsTop |; kLHintsExpandY | kLHintsExpandX,0,0,1,2));; fH1->Resize(fFtop->GetDefaultWidth(),fH1->GetDefaultHeight()+20);; fH2->Resize(fFbottom->GetDefaultWidth(),fH2->GetDefaultHeight()+20);; fVf->AddFrame(fH1, new TGLayoutHints(kLHintsTop | kLHintsExpandX));. TGHSplitter *hsplitter = new TGHSplitter(fVf);; hsplitter->SetFrame(fH1,kTRUE);; fVf->AddFrame(hsplitter,new TGLayoutHints(kLHintsTop |; kLHintsExpandX));; fVf->AddFrame(fH2, new TGLayoutHints(kLHintsBottom |; kLHintsExpandX | kLHintsExpandY));; ```. For a `vertical` splitter the rules are:. - the parent of a vertical splitter must inherit from; **`TGCompoziteFrame`** and must have a horizontal layout. - the `left` resized frame must have `kFixedWidth` option set. - use layout hints `kLHintsLeft | kLHintsExpandY` when adding the; `left` resized frame to the parent. - use layout hints `kLHintsRight|kLHintsExpandX |kLHintsExpandY` when; adding the right resized frame to the parent. - set the `left` frame to be resized using `SetFrame` method; the; second parameter should be `kTRUE`. Next is a sample code for a vertical splitter:. ``` {.cpp}; // Create vertical splitter; fHf = new TGHorizontalFrame(fMain, 50, 50);; fV1 = new TGVerticalFrame(fHf, 10, 10, kFixedWidth);; fV2 = new TGVerticalFrame(fHf, 10, 10);; fFleft = new TGCompositeFrame(fV1, 10, 10, kSunkenFrame);; fFright = new TGCompositeFrame(fV2, 10, 10, kSunkenFrame);. fLleft = new TGLabel(fFleft, ""Left Frame"");; fLright = new TGLabel(fFright, ""Right Frame"");. fFleft->AddFrame(fLleft, new TGLayoutHints(kLHintsLeft |; kLHintsCenterY,3,0,0,0));; fFright->AddFrame(fLright, new ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:96175,inherit,inherit,96175,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inherit']
Modifiability,"GOAL:. Provide http interface to arbitrary ROOT application. USAGE:. At any place of the code create http server:. root [0] serv = new THttpServer. By default, civetweb web server with port number 8080 will be started.; It gets access to files, canvases and trees, registered in gROOT.; One additionally could register other objects to the server:. root [1] serv->Register(""abc/fold1"", hpx);; root [2] serv->Register(""abc/fold2"", hpxpy);; root [3] serv->Register(""extra"", c1);. Once server running, just open in any browser page: http://yourhost:8080. Example macro: $ROOTSYS/tutorials/http/httpserver.C. FAST CGI:. Instead of running http server, one could use fast cgi interface; to normal web server like Apache or lighttpd or any other.; When creating server, one could specify:. root [0] serv = new THttpServer(""fastcgi:9000"");. This opens port 9000, which should be specified in web server configuration.; For instance, lighttpd.conf file could contain path like this:. fastcgi.server = (; ""/remote_scripts/"" =>; (( ""host"" => ""192.168.1.10"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ). In this case one should be able to access root application via address. http://your_lighttpd_host/remote_scripts/root.cgi/. AUTHOR:. Sergey Linev, S.Linev@gsi.de. CHANGES:. January 2015; - Provide exe.json request to execute arbitrary object method and return; result in JSON format. Server should run in non-readonly mode. Fall 2014; - Implement gzip for result of any submitted requests, automatically done ; when .gz extension is provided; - Provide access to arbitrary data member of objects, registered to the server; - Prevent data caching in the browser by setting no-cache header. April 2014; - In TCivetweb class support digest authentication method. User; can specify auth_file and auth_domain parameters to protect; access to the server; - Fix error in FastCgi, now correctly works with Apache; - Avoid direct usage of TASImage. March 2014; - Replace mongoose by civetwe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt:896,config,configuration,896,net/http/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt,1,['config'],['configuration']
Modifiability,"GlobalVariable; """""""""""""""""""""""""""""""". ``DIGlobalVariable`` nodes represent global variables in the source language. .. code-block:: text. @foo = global i32, !dbg !0; !0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression()); !1 = !DIGlobalVariable(name: ""foo"", linkageName: ""foo"", scope: !2,; file: !3, line: 7, type: !4, isLocal: true,; isDefinition: false, declaration: !5). DIGlobalVariableExpression; """""""""""""""""""""""""""""""""""""""""""""""""""". ``DIGlobalVariableExpression`` nodes tie a :ref:`DIGlobalVariable` together; with a :ref:`DIExpression`. .. code-block:: text. @lower = global i32, !dbg !0; @upper = global i32, !dbg !1; !0 = !DIGlobalVariableExpression(; var: !2,; expr: !DIExpression(DW_OP_LLVM_fragment, 0, 32); ); !1 = !DIGlobalVariableExpression(; var: !2,; expr: !DIExpression(DW_OP_LLVM_fragment, 32, 32); ); !2 = !DIGlobalVariable(name: ""split64"", linkageName: ""split64"", scope: !3,; file: !4, line: 8, type: !5, declaration: !6). All global variable expressions should be referenced by the `globals:` field of; a :ref:`compile unit <DICompileUnit>`. .. _DISubprogram:. DISubprogram; """""""""""""""""""""""". ``DISubprogram`` nodes represent functions from the source language. A distinct; ``DISubprogram`` may be attached to a function definition using ``!dbg``; metadata. A unique ``DISubprogram`` may be attached to a function declaration; used for call site debug info. The ``retainedNodes:`` field is a list of; :ref:`variables <DILocalVariable>` and :ref:`labels <DILabel>` that must be; retained, even if their IR counterparts are optimized out of the IR. The; ``type:`` field must point at an :ref:`DISubroutineType`. .. _DISubprogramDeclaration:. When ``spFlags: DISPFlagDefinition`` is not present, subprograms describe a; declaration in the type tree as opposed to a definition of a function. In this; case, the ``declaration`` field must be empty. If the scope is a composite type; with an ODR ``identifier:`` and that does not set ``flags: DIFwdDecl``, then; the subprogram declaration is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:257327,variab,variable,257327,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"H` for finding the; headers back at runtime. The ROOT stress suite is now updated to follow this behavior; see for instance the injection of; `$ROOTSYS/test` in `test/stressMathCore.cxx`, allowing ROOT to find the header at runtime, whether interpreted; (`R__ADD_INCLUDE_PATH`) or compiled (`TROOT::AddExtraInterpreterArgs({""-I...""})` before interpreter construction). If you called `ROOT_GENERATE_DICTIONARY(Dict ${CMAKE_CURRENT_SOURCE_DIR}/subdir/Header1.h LINKDEF LinkDef.h)` then update that; call to `ROOT_GENERATE_DICTIONARY(Dict Header1.h OPTIONS -I subdir LINKDEF LinkDef.h)` *if* the header is usually included as; `#include ""Header1.h""`, or to `ROOT_GENERATE_DICTIONARY(Dict subdir/Header1.h LINKDEF LinkDef.h)` *if* the header is usually; included as `#include ""subdir/Header1.h""`. I.e. the general rule is: pass to `ROOT_GENERATE_DICTIONARY` (or; `ROOT_STANDARD_LIBRARY_PACKAGE`) the spelling as `#include`ed. As an important side-effect, `ROOT_GENERATE_DICTIONARY` and thus `ROOT_STANDARD_LIBRARY_PACKAGE` now *require* the header to; be found at configuration time. We have seen too many cases where the header location was mis-stated, and as a consequence,; CMake did not generate the proper dependencies. If the header should not be taken into account for dependencies and / or if; the header will not be found (e.g. the standard library's `vector`) please pass the header through the `NODEPHEADERS` option; to `ROOT_GENERATE_DICTIONARY` or `ROOT_STANDARD_LIBRARY_PACKAGE`. We believe that this simplification / regularization of behavior, and the additional checks are worth the possible changes; on the user side. ## PyROOT. If the fix or new feature is a pythonization related to a C++ class, the change is added to the respective section above. ### Current PyROOT. - Fix compatibility with Python3.7 (ROOT-9922, ROOT-9871, ROOT-9809); - Fix lookup for templated methods (ROOT-9789); - Fix lookup for templated free functions (ROOT-9836). ### Experimental PyROOT. - All pythonisati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:25331,config,configuration,25331,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['config'],['configuration']
Modifiability,"Hello""' of type 'string'; let a=""Hello"";; ^. Above, the member `a` was defined but with a type of `int`. We therefore cannot `let` it have a value of type `string`. ```tablegen; class C {; int a = 9;; }; def X: C {; let b=5;; }; ```. <stdin>:5:11: error: Value 'b' unknown!; let b=5;; ^. Above, class `C` only has one member, `a`. Therefore we get an error trying to override the value of `b` which doesn't exist. If you have multiple let, the outer scope is applied first then on down to the narrowest scope. ```tablegen; class Base {; int var=4;; }; let var=5 in {; def X: Base {}; let var=6 in {; def Y: Base {}; }; def Z: Base { let var=7; }; }; ```. ------------- Classes -----------------; class Base {; int var = 4;; }; ------------- Defs -----------------; def X {	// Base; int var = 5;; }; def Y {	// Base; int var = 6;; }; def Z {	// Base; int var = 7;; }. The first `let` is at what we call the ""top level"". That means the outer most scope in terms of the source code. A bit like a global variable in a C file. This is applied first and changes `var` from `4` to `5` for all classes within that `let` (`4` came from the definition of `Base`). def `X` is within the global `let`, therefore `var` is `5` within `X`. Then we have a `let` inside the global `let`. This one changes `var` from `5` to `6`. The scope of the `let` only contains the def `Y` therefore within `Y`, `var` is `6`. Finally def `Z` is within the global `let`, so `var` starts as `5`. `Z` has an inner `let` that changes `var` to `7`. That example is quite complex just to demonstrate the feature. Let's look at something more practical. ```tablegen; class Register {; int size=4;; }; let size=8 in {; def X0: Register {}; // Repeats 30 times for X1...X31; }; def W0: Register {}; // Repeats 30 times for W1...W31; ```. ------------- Classes -----------------; class Register {; int size = 4;; }; ------------- Defs -----------------; def W0 {	// Register; int size = 4;; }; def X0 {	// Register; int size = 8;; }. (for a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:8823,variab,variable,8823,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['variab'],['variable']
Modifiability,"How to build it; ===============. You need to have gold with plugin support and build the LLVMgold plugin.; The gold linker is installed as ld.gold. To see whether gold is the default; on your system, run ``/usr/bin/ld -v``. It will report ""GNU; gold"" or else ""GNU ld"" if not. If gold is already installed at; ``/usr/bin/ld.gold``, one option is to simply make that the default by; backing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. Yo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:2058,config,configure,2058,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,2,"['config', 'plugin']","['configure', 'plugin']"
Modifiability,"I; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _gold plugin: https://llvm.org/docs/GoldPlugin.html. .. _cfi-schemes:. Available schemes; =================. Available schemes are:. - ``-fsanitize=cfi-cast-strict``: Enables :ref:`strict cast checks; <cfi-strictness>`.; - ``-fsanitize=cfi-derived-cast``: Base-to-derived cast to the wrong; dynamic type.; - ``-fsanitize=cfi-unrelated-cast``: Cast from ``void*`` or another; unrelated type to the wrong dynamic type.; - ``-fsanitize=cfi-nvcall``: Non-virtual call via an object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:2005,plugin,plugin,2005,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['plugin'],['plugin']
Modifiability,"IG_EXTRA_PATH_HINTS=${Clang_Config_ExtraPathHints}); endif(Clang_DIR). if (LLVM_FORCE_USE_OLD_TOOLCHAIN); list(APPEND _clad_extra_cmake_args -DLLVM_FORCE_USE_OLD_TOOLCHAIN=${LLVM_FORCE_USE_OLD_TOOLCHAIN}); endif(LLVM_FORCE_USE_OLD_TOOLCHAIN). list(APPEND _clad_extra_cmake_args -DCLAD_BUILD_STATIC_ONLY=ON). # Wrap download, configure and build steps in a script to log output; set(_clad_extra_settings; LOG_DOWNLOAD ON; LOG_CONFIGURE ON; LOG_BUILD ON; LOG_INSTALL ON; LOG_OUTPUT_ON_FAILURE ON; ). # If the CLAD_SOURCE_DIR variable is defined in the CMake configuration, we're; # skipping the download of the repository and use the passed directory.; if (DEFINED CLAD_SOURCE_DIR); list(APPEND _clad_extra_settings DOWNLOAD_COMMAND """"); list(APPEND _clad_extra_settings SOURCE_DIR ${CLAD_SOURCE_DIR}); endif(). #list(APPEND _clad_patches_list ""patch1.patch"" ""patch2.patch""); #set(_clad_patch_command; # ${CMAKE_COMMAND} -E copy_directory; # ${CMAKE_SOURCE_DIR}/interpreter/cling/tools/plugins/clad/patches <SOURCE_DIR>; # && git checkout <SOURCE_DIR>; # && git apply --ignore-space-change --ignore-whitespace ${_clad_patches_list}; # ). ExternalProject_Add(; clad; GIT_REPOSITORY https://github.com/vgvassilev/clad.git; GIT_TAG v1.7; UPDATE_COMMAND """"; PATCH_COMMAND ${_clad_patch_command}; CMAKE_ARGS -G ${CMAKE_GENERATOR}; -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}; -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}; -DCMAKE_C_FLAGS=${CMAKE_C_FLAGS}; -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}; -DCMAKE_CXX_FLAGS=${CLAD_CXX_FLAGS}; -DCMAKE_INSTALL_PREFIX=${clad_install_dir}/plugins; -DLLVM_DIR=${LLVM_BINARY_DIR}; -DCLANG_INCLUDE_DIRS=${CLANG_INCLUDE_DIRS}; ${_clad_extra_cmake_args}; # FIXME; # Building with 1 core is a temporary workaround for #16654 and has to be ; # there until the behaviour of the clad build on ubuntu 24.10 is understood.; # The performance penalty in the build is negligible.; BUILD_COMMAND ${CMAKE_COMMAND} --build . ${EXTRA_BUILD_ARGS} -j 1; INSTALL_COMMAND ${CMAKE_COMMAND} --build .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/plugins/clad/CMakeLists.txt:2810,plugin,plugins,2810,interpreter/cling/tools/plugins/clad/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/plugins/clad/CMakeLists.txt,1,['plugin'],['plugins']
Modifiability,"ILexicalBlockFile:. DILexicalBlockFile; """""""""""""""""""""""""""""""""""". ``DILexicalBlockFile`` nodes are used to discriminate between sections of a; :ref:`lexical block <DILexicalBlock>`. The ``file:`` field can be changed to; indicate textual inclusion, or the ``discriminator:`` field can be used to; discriminate between control flow within a single block in the source language. .. code-block:: text. !0 = !DILexicalBlock(scope: !3, file: !4, line: 7, column: 35); !1 = !DILexicalBlockFile(scope: !0, file: !4, discriminator: 0); !2 = !DILexicalBlockFile(scope: !0, file: !4, discriminator: 1). .. _DILocation:. DILocation; """""""""""""""""""". ``DILocation`` nodes represent source debug locations. The ``scope:`` field is; mandatory, and points at an :ref:`DILexicalBlockFile`, an; :ref:`DILexicalBlock`, or an :ref:`DISubprogram`. .. code-block:: text. !0 = !DILocation(line: 2900, column: 42, scope: !1, inlinedAt: !2). .. _DILocalVariable:. DILocalVariable; """""""""""""""""""""""""""""". ``DILocalVariable`` nodes represent local variables in the source language. If; the ``arg:`` field is set to non-zero, then this variable is a subprogram; parameter, and it will be included in the ``retainedNodes:`` field of its; :ref:`DISubprogram`. .. code-block:: text. !0 = !DILocalVariable(name: ""this"", arg: 1, scope: !3, file: !2, line: 7,; type: !3, flags: DIFlagArtificial); !1 = !DILocalVariable(name: ""x"", arg: 2, scope: !4, file: !2, line: 7,; type: !3); !2 = !DILocalVariable(name: ""y"", scope: !5, file: !2, line: 7, type: !3). .. _DIExpression:. DIExpression; """""""""""""""""""""""". ``DIExpression`` nodes represent expressions that are inspired by the DWARF; expression language. They are used in :ref:`debug intrinsics<dbg_intrinsics>`; (such as ``llvm.dbg.declare`` and ``llvm.dbg.value``) to describe how the; referenced LLVM variable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and eva",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:260358,variab,variables,260358,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"ILocalVariable`` nodes represent local variables in the source language. If; the ``arg:`` field is set to non-zero, then this variable is a subprogram; parameter, and it will be included in the ``retainedNodes:`` field of its; :ref:`DISubprogram`. .. code-block:: text. !0 = !DILocalVariable(name: ""this"", arg: 1, scope: !3, file: !2, line: 7,; type: !3, flags: DIFlagArtificial); !1 = !DILocalVariable(name: ""x"", arg: 2, scope: !4, file: !2, line: 7,; type: !3); !2 = !DILocalVariable(name: ""y"", scope: !5, file: !2, line: 7, type: !3). .. _DIExpression:. DIExpression; """""""""""""""""""""""". ``DIExpression`` nodes represent expressions that are inspired by the DWARF; expression language. They are used in :ref:`debug intrinsics<dbg_intrinsics>`; (such as ``llvm.dbg.declare`` and ``llvm.dbg.value``) to describe how the; referenced LLVM variable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and evaluate; opcodes from the DIExpression until the final variable description is produced. The current supported opcode vocabulary is limited:. - ``DW_OP_deref`` dereferences the top of the expression stack.; - ``DW_OP_plus`` pops the last two entries from the expression stack, adds; them together and appends the result to the expression stack.; - ``DW_OP_minus`` pops the last two entries from the expression stack, subtracts; the last entry from the second last entry and appends the result to the; expression stack.; - ``DW_OP_plus_uconst, 93`` adds ``93`` to the working expression.; - ``DW_OP_LLVM_fragment, 16, 8`` specifies the offset and size (``16`` and ``8``; here, respectively) of the variable fragment from the working expression. Note; that contrary to DW_OP_bit_piece, the offset is describing the location; within the described source variable.; - ``DW_OP_LLVM_convert, 16, DW_ATE_signed`` specifies a bit size and encoding; (``16`` and ``DW_ATE_signed`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:261406,variab,variable,261406,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"INATION ${CMAKE_INSTALL_MACRODIR} ${DIR_PERMISSIONS}); if(http); install(DIRECTORY js/ DESTINATION ${CMAKE_INSTALL_JSROOTDIR} ${DIR_PERMISSIONS}); endif(); if(webgui); install(DIRECTORY ui5/ DESTINATION ${CMAKE_INSTALL_OPENUI5DIR} ${DIR_PERMISSIONS}); endif(); set(MAN_PATT_EXCL); if(NOT fortran OR NOT CMAKE_Fortran_COMPILER); list(APPEND MAN_PATT_EXCL PATTERN h2root.1 EXCLUDE); list(APPEND MAN_PATT_EXCL PATTERN g2root.1 EXCLUDE); endif(); install(DIRECTORY man/ DESTINATION ${CMAKE_INSTALL_MANDIR} ${DIR_PERMISSIONS} ${MAN_PATT_EXCL}); install(DIRECTORY tutorials/ DESTINATION ${CMAKE_INSTALL_TUTDIR} ${DIR_PERMISSIONS} COMPONENT tests); install(FILES; cmake/modules/RootMacros.cmake; cmake/modules/RootTestDriver.cmake; DESTINATION ${CMAKE_INSTALL_CMAKEDIR}); install(FILES; ""cmake/modules/FindVdt.cmake""; DESTINATION ""${CMAKE_INSTALL_CMAKEDIR}/modules""); endif(). #---Add configuration files for kernel and jupyter----------------------------------------------; # Make sure the Jupyter ROOT C++ kernel runs with the same Python version as ROOT; set(root_jupyter_dir notebook); set(root_jupyter_config jupyter_notebook_config.py); configure_file(etc/${root_jupyter_dir}/${root_jupyter_config}.in etc/${root_jupyter_dir}/${root_jupyter_config}); install(FILES ${CMAKE_BINARY_DIR}/etc/${root_jupyter_dir}/${root_jupyter_config} DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/${root_jupyter_dir}). set(root_kernel_dir ${root_jupyter_dir}/kernels/root); set(root_kernel_file kernel.json); configure_file(etc/${root_kernel_dir}/${root_kernel_file}.in etc/${root_kernel_dir}/${root_kernel_file}); install(FILES ${CMAKE_BINARY_DIR}/etc/${root_kernel_dir}/${root_kernel_file} DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/${root_kernel_dir}). #---install clad header files-------------------------------------------------------------------; if(clad); install(DIRECTORY ${CMAKE_BINARY_DIR}/etc/cling/plugins/; DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/cling/plugins); endif(). #---Set flag for PyROOT tests that are exp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:26598,config,configuration,26598,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"ING; Defines the set of compile flags used to enable UBSan. Only used if; ``LLVM_USE_SANITIZER`` contains ``Undefined``. This can be used to override; the default set of UBSan flags. **LLVM_USE_INTEL_JITEVENTS**:BOOL; Enable building support for Intel JIT Events API. Defaults to OFF. **LLVM_USE_LINKER**:STRING; Add ``-fuse-ld={name}`` to the link invocation. The possible value depend on; your compiler, for clang the value can be an absolute path to your custom; linker, otherwise clang will prefix the name with ``ld.`` and apply its usual; search. For example to link LLVM with the Gold linker, cmake can be invoked; with ``-DLLVM_USE_LINKER=gold``. **LLVM_USE_OPROFILE**:BOOL; Enable building OProfile JIT support. Defaults to OFF. **LLVM_USE_PERF**:BOOL; Enable building support for Perf (linux profiling tool) JIT support. Defaults to OFF. **LLVM_USE_RELATIVE_PATHS_IN_FILES**:BOOL; Rewrite absolute source paths in sources and debug info to relative ones. The; source prefix can be adjusted via the LLVM_SOURCE_PREFIX variable. **LLVM_USE_RELATIVE_PATHS_IN_DEBUG_INFO**:BOOL; Rewrite absolute source paths in debug info to relative ones. The source prefix; can be adjusted via the LLVM_SOURCE_PREFIX variable. **LLVM_USE_SANITIZER**:STRING; Define the sanitizer used to build LLVM binaries and tests. Possible values; are ``Address``, ``Memory``, ``MemoryWithOrigins``, ``Undefined``, ``Thread``,; ``DataFlow``, and ``Address;Undefined``. Defaults to empty string. **LLVM_USE_SPLIT_DWARF**:BOOL; If enabled CMake will pass ``-gsplit-dwarf`` to the compiler. This option; reduces link-time memory usage by reducing the amount of debug information that; the linker needs to resolve. It is recommended for platforms using the ELF object; format, like Linux systems when linker memory usage is too high. **SPHINX_EXECUTABLE**:STRING; The path to the ``sphinx-build`` executable detected by CMake.; For installation instructions, see; https://www.sphinx-doc.org/en/master/usage/installation.html.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:36050,variab,variable,36050,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"IR ""${CMAKE_INSTALL_DOCDIR}/llvm/doxygen-html""; CACHE STRING ""Doxygen-generated HTML documentation install directory""); set(LLVM_INSTALL_OCAMLDOC_HTML_DIR ""${CMAKE_INSTALL_DOCDIR}/llvm/ocaml-html""; CACHE STRING ""OCamldoc-generated HTML documentation install directory""). option (LLVM_BUILD_EXTERNAL_COMPILER_RT; ""Build compiler-rt as an external project."" OFF). option (LLVM_VERSION_PRINTER_SHOW_HOST_TARGET_INFO; ""Show target and host info when tools are invoked with --version."" ON). # You can configure which libraries from LLVM you want to include in the; # shared library by setting LLVM_DYLIB_COMPONENTS to a semi-colon delimited; # list of LLVM components. All component names handled by llvm-config are valid.; if(NOT DEFINED LLVM_DYLIB_COMPONENTS); set(LLVM_DYLIB_COMPONENTS ""all"" CACHE STRING; ""Semicolon-separated list of components to include in libLLVM, or \""all\"".""); endif(). if(MSVC); option(LLVM_BUILD_LLVM_C_DYLIB ""Build LLVM-C.dll (Windows only)"" ON); # Set this variable to OFF here so it can't be set with a command-line; # argument.; set (LLVM_LINK_LLVM_DYLIB OFF); if (BUILD_SHARED_LIBS); message(FATAL_ERROR ""BUILD_SHARED_LIBS options is not supported on Windows.""); endif(); else(); option(LLVM_LINK_LLVM_DYLIB ""Link tools against the libllvm dynamic library"" OFF); option(LLVM_BUILD_LLVM_C_DYLIB ""Build libllvm-c re-export library (Darwin only)"" OFF); set(LLVM_BUILD_LLVM_DYLIB_default OFF); if(LLVM_LINK_LLVM_DYLIB OR LLVM_BUILD_LLVM_C_DYLIB); set(LLVM_BUILD_LLVM_DYLIB_default ON); endif(); option(LLVM_BUILD_LLVM_DYLIB ""Build libllvm dynamic library"" ${LLVM_BUILD_LLVM_DYLIB_default}); endif(). if (LLVM_LINK_LLVM_DYLIB AND BUILD_SHARED_LIBS); message(FATAL_ERROR ""Cannot enable BUILD_SHARED_LIBS with LLVM_LINK_LLVM_DYLIB. We recommend disabling BUILD_SHARED_LIBS.""); endif(). option(LLVM_OPTIMIZED_TABLEGEN ""Force TableGen to be built with optimization"" OFF); if(CMAKE_CROSSCOMPILING OR (LLVM_OPTIMIZED_TABLEGEN AND (LLVM_ENABLE_ASSERTIONS OR CMAKE_CONFIGURATION_TYPES)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:33671,variab,variable,33671,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['variab'],['variable']
Modifiability,"IRgen optimization opportunities. //===---------------------------------------------------------------------===//. The common pattern of; --; short x; // or char, etc; (x == 10); --; generates an zext/sext of x which can easily be avoided. //===---------------------------------------------------------------------===//. Bitfields accesses can be shifted to simplify masking and sign; extension. For example, if the bitfield width is 8 and it is; appropriately aligned then is is a lot shorter to just load the char; directly. //===---------------------------------------------------------------------===//. It may be worth avoiding creation of alloca's for formal arguments; for the common situation where the argument is never written to or has; its address taken. The idea would be to begin generating code by using; the argument directly and if its address is taken or it is stored to; then generate the alloca and patch up the existing code. In theory, the same optimization could be a win for block local; variables as long as the declaration dominates all statements in the; block. NOTE: The main case we care about this for is for -O0 -g compile time; performance, and in that scenario we will need to emit the alloca; anyway currently to emit proper debug info. So this is blocked by; being able to emit debug information which refers to an LLVM; temporary, not an alloca. //===---------------------------------------------------------------------===//. We should try and avoid generating basic blocks which only contain; jumps. At -O0, this penalizes us all the way from IRgen (malloc &; instruction overhead), all the way down through code generation and; assembly time. On 176.gcc:expr.ll, it looks like over 12% of basic blocks are just; direct branches!. //===---------------------------------------------------------------------===//; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/README.txt:1012,variab,variables,1012,interpreter/llvm-project/clang/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/README.txt,1,['variab'],['variables']
Modifiability,"IR}/bin/cling); endif(); ROOT_ADD_TEST(clingtest-check-cling COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target check-cling; ENVIRONMENT ${CLINGTEST_EXECUTABLE}); else(); #---Build LLVM/Clang with symbol visibility=hidden--------------------------------------------------; set(CMAKE_CXX_VISIBILITY_PRESET hidden); set(CMAKE_C_VISIBILITY_PRESET hidden); endif(); if (NOT MSVC AND NOT APPLE); # Requires the linker to resolve the symbol internally and prevents; # conflicts when linked with another software using also LLVM like in; # the problem reported for Julia in; # https://github.com/JuliaHEP/ROOT.jl/issues/17#issuecomment-882719292; # Only needed for Linux: Mac uses linker namespaces and Windows explicit export/import; string(APPEND CMAKE_SHARED_LINKER_FLAGS "" -Wl,-Bsymbolic""); ROOT_ADD_CXX_FLAG(CMAKE_CXX_FLAGS ""-fno-semantic-interposition""); endif(); set(CMAKE_VISIBILITY_INLINES_HIDDEN ""ON""). #--- Build LLVM/Clang with modules -----------------------------------------------------------------; if(cxxmodules); # LLVM knows how to configure its modules builds. We cannot just add the flags; # because the cxxmodules builds in llvm have different build dependency order.; string(REPLACE ""${ROOT_CXXMODULES_CXXFLAGS}"" """" CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS}); string(REPLACE ""${ROOT_CXXMODULES_CFLAGS}"" """" CMAKE_C_FLAGS ${CMAKE_C_FLAGS}); if(libcxx); # FIXME: We cannot build LLVM/clang with modules on with libstdc++, yet.; # FIXME: We cannot build LLVM/clang with modules on with libc++, too.; #set (LLVM_ENABLE_MODULES ON CACHE BOOL ""Override the default LLVM_ENABLE_MODULES option value."" ); endif(libcxx); endif(cxxmodules). if(gcctoolchain); ROOT_ADD_CXX_FLAG(CMAKE_CXX_FLAGS --gcc-toolchain=${gcctoolchain}); endif(). # We will not fix llvm or clang.; string(REPLACE ""-Werror "" """" CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} ""); # Turn off coverage - we don't need this for llvm.; string(REPLACE ""${GCC_COVERAGE_COMPILE_FLAGS}"" """" CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS}""). if(LLVM_SHA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:7911,config,configure,7911,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['config'],['configure']
Modifiability,"IST LLVM_ENABLE_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); set(PROJ_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}""); if(NOT EXISTS ""${PROJ_DIR}"" OR NOT IS_DIRECTORY ""${PROJ_DIR}""); message(FATAL_ERROR ""LLVM_ENABLE_PROJECTS requests ${proj} but directory not found: ${PROJ_DIR}""); endif(); if( LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR STREQUAL """" ); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """" FORCE); else(); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """"); endif(); elseif (""${proj}"" IN_LIST LLVM_EXTERNAL_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); else(); message(STATUS ""${proj} project is disabled""); set(SHOULD_ENABLE_PROJECT FALSE); endif(); # Force `LLVM_TOOL_${upper_proj}_BUILD` variables to have values that; # corresponds with `LLVM_ENABLE_PROJECTS`. This prevents the user setting; # `LLVM_TOOL_${upper_proj}_BUILD` variables externally. At some point; # we should deprecate allowing users to set these variables by turning them; # into normal CMake variables rather than cache variables.; set(LLVM_TOOL_${upper_proj}_BUILD; ${SHOULD_ENABLE_PROJECT}; CACHE; BOOL ""Whether to build ${upper_proj} as part of LLVM"" FORCE; ); endforeach(); endif(); unset(SHOULD_ENABLE_PROJECT). # Build llvm with ccache if the package is present; set(LLVM_CCACHE_BUILD OFF CACHE BOOL ""Set to ON for a ccache enabled build""); if(LLVM_CCACHE_BUILD); find_program(CCACHE_PROGRAM ccache); if(CCACHE_PROGRAM); set(LLVM_CCACHE_MAXSIZE """" CACHE STRING ""Size of ccache""); set(LLVM_CCACHE_DIR """" CACHE STRING ""Directory to keep ccached data""); set(LLVM_CCACHE_PARAMS ""CCACHE_CPP2=yes CCACHE_HASHDIR=yes""; CACHE STRING ""Parameters to pass through to ccache""). if(NOT CMAKE_SYSTEM_NAME MATCHES ""Windows""); set(CCACHE_PROGRAM ""${LLVM_CCACHE_PARAMS} ${CCACHE_PROGRAM}""); if (LLVM_CCACHE_MAXSIZE); set(CCACHE_PROGRAM ""CCACHE_MA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:10034,variab,variables,10034,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['variab'],['variables']
Modifiability,"I`` node of the current basic block, we simulate an assignment at; the end of the current basic block and traverse the successor basic blocks. If a; successor basic block has a ``PHI`` node and one of the ``PHI`` node's operands; is coming from the current basic block, then the variable is marked as *alive*; within the current basic block and all of its predecessor basic blocks, until; the basic block with the defining instruction is encountered. Live Intervals Analysis; ^^^^^^^^^^^^^^^^^^^^^^^. We now have the information available to perform the live intervals analysis and; build the live intervals themselves. We start off by numbering the basic blocks; and machine instructions. We then handle the ""live-in"" values. These are in; physical registers, so the physical register is assumed to be killed by the end; of the basic block. Live intervals for virtual registers are computed for some; ordering of the machine instructions ``[1, N]``. A live interval is an interval; ``[i, j)``, where ``1 >= i >= j > N``, for which a variable is live. .. note::; More to come... .. _Register Allocation:; .. _register allocator:. Register Allocation; -------------------. The *Register Allocation problem* consists in mapping a program; :raw-html:`<b><tt>` P\ :sub:`v`\ :raw-html:`</tt></b>`, that can use an unbounded; number of virtual registers, to a program :raw-html:`<b><tt>` P\ :sub:`p`\; :raw-html:`</tt></b>` that contains a finite (possibly small) number of physical; registers. Each target architecture has a different number of physical; registers. If the number of physical registers is not enough to accommodate all; the virtual registers, some of them will have to be mapped into memory. These; virtuals are called *spilled virtuals*. How registers are represented in LLVM; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In LLVM, physical registers are denoted by integer numbers that normally range; from 1 to 1023. To see how this numbering is defined for a particular; architecture, you can ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:57717,variab,variable,57717,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['variab'],['variable']
Modifiability,"Id(user_id);; ptrTrack = gGeoManager->GetTrack(index);; ~~~. Supposing a particle represented by a primary track decays or interacts,; one should not create new primaries as described before, but rather add; them as secondary:. ~~~{.cpp}; TVirtualGeoTrack *secondary =; ptrTrack->AddTrack(secondId,pdg,secondParticle);; ~~~. At any step made by the current track, one is able to add control points; to either primary or secondary:. ~~~{.cpp}; track->AddPoint(x,y,z,t);; ~~~. After tracks were defined and filled during tracking, one will be able; to browse directly the list of tracks held by the manager class. Any; track can be drawn using its `Draw()` and `Animate()` methods, but there; are also global methods for drawing or animation that can be accessed; from TGeoManager context menu:. ~~~{.cpp}; TGeoManager::DrawTracks(Option_t *option);; TGeoManager::AnimateTracks(Double_t tmin=0.,Double_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; ~~~. The drawing/animation time range is a global variable that can be; directly set:. ~~~{.cpp}; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; ~~~. Once set, the time range will be active both for individual or global; track drawing. For animation, this range is divided to the desired; number of frames and will be automatically updated at each frame in; order to get the animation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name=type` are drawn. Generally several options can be concatenated in the same string (E.g.; `""/D /Npion-""`). For animating tracks, additional options can be added:. `/G:`Geometry animate. Generally when drawing or animating tracks, one; has to first perform a normal drawing of the geometry as convenient.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:88487,variab,variable,88487,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['variab'],['variable']
Modifiability,"If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plugin`` option to; ``ld``. It will not look for an alternate linker without ``-fuse-ld=gold``,; which is why you otherwise need gold to be the installed system linker in; your path. ``ar`` and ``nm`` also accept the ``-plugin`` option and it's possible to; to install ``LLVMgold.so`` to ``/usr/lib/bfd-plugins`` for a seamless setup.; If you built your own gold, be sure to install the ``ar`` and ``nm-new`` you; built to ``/usr/bin``. Example of link time optimization; ---------------------------------. The following example shows a worked example of the gold plugin mixing LLVM; bitcode and native code. .. code-block:: c. --- a.c ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:2915,plugin,plugin,2915,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin']
Modifiability,"InTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). FitMethod No GA GA, SA, MC, MCEvents, MINUIT, EventScan Minimisation Method (GA, SA, and MC are the primary methods to be used; the others have been introduced for testing purposes and are depreciated). EffMethod No EffSel EffSel, EffPDF Selection Method. CutRangeMin Yes -1 − Minimum of allowed cut range (set per variable). CutRangeMax Yes -1 − Maximum of allowed cut range (set per variable). VarProp Yes NotEnforced NotEnforced, FMax, FMin, FSmart Categorisation of cuts. Configuration options for MVA method :. Configuration options reference for MVA method: PDEFoam. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). SigBgSeparate No False − Separate foams for signal and background. TailCut No 0.001 − Fraction of outlier events that are excluded from the foam in each dimension. VolFrac No 0.0666667 − Size of sampling box, used for density calculation during foam build-up (maximum value: 1.0 is equivalent to volume of entire foam). nActiveCells No 500 − Maximum number of active cells to be created by the foam. nSampl No 2000 − Num",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:26005,variab,variable,26005,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variable']
Modifiability,"Init = ParseExpression();; if (!Init) return nullptr;; }. VarNames.push_back(std::make_pair(Name, std::move(Init)));. // End of var list, exit loop.; if (CurTok != ',') break;; getNextToken(); // eat the ','. if (CurTok != tok_identifier); return LogError(""expected identifier list after var"");; }. Once all the variables are parsed, we then parse the body and create the; AST node:. .. code-block:: c++. // At this point, we have to have 'in'.; if (CurTok != tok_in); return LogError(""expected 'in' keyword after 'var'"");; getNextToken(); // eat 'in'. auto Body = ParseExpression();; if (!Body); return nullptr;. return std::make_unique<VarExprAST>(std::move(VarNames),; std::move(Body));; }. Now that we can parse and represent the code, we need to support; emission of LLVM IR for it. This code starts out with:. .. code-block:: c++. Value *VarExprAST::codegen() {; std::vector<AllocaInst *> OldBindings;. Function *TheFunction = Builder->GetInsertBlock()->getParent();. // Register all variables and emit their initializer.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i) {; const std::string &VarName = VarNames[i].first;; ExprAST *Init = VarNames[i].second.get();. Basically it loops over all the variables, installing them one at a; time. For each variable we put into the symbol table, we remember the; previous value that we replace in OldBindings. .. code-block:: c++. // Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.; Value *InitVal;; if (Init) {; InitVal = Init->codegen();; if (!InitVal); return nullptr;; } else { // If not specified, use 0.0.; InitVal = ConstantFP::get(*TheContext, APFloat(0.0));; }. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);; Builder->CreateStore(InitVal, Alloca);. // Remember the old variable binding so that we can restore the binding when; // we unrec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:26745,variab,variables,26745,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"Inlining; ========. There are several options that control which calls the analyzer will consider for; inlining. The major one is ``-analyzer-config ipa``:. * ``analyzer-config ipa=none`` - All inlining is disabled. This is the only mode; available in LLVM 3.1 and earlier and in Xcode 4.3 and earlier. * ``analyzer-config ipa=basic-inlining`` - Turns on inlining for C functions, C++; static member functions, and blocks -- essentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:142,config,config,142,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,5,['config'],['config']
Modifiability,"JIT compiler is to compile code ""on-the-fly"" as it is needed,; rather than compiling whole programs to disk ahead of time as a traditional; compiler does. To support that aim our initial, bare-bones JIT API will have; just two functions:. 1. ``Error addModule(std::unique_ptr<Module> M)``: Make the given IR module; available for execution.; 2. ``Expected<ExecutorSymbolDef> lookup()``: Search for pointers to; symbols (functions or variables) that have been added to the JIT. A basic use-case for this API, executing the 'main' function from a module,; will look like:. .. code-block:: c++. JIT J;; J.addModule(buildModule());; auto *Main = J.lookup(""main"").getAddress().toPtr<int(*)(int, char *[])>();; int Result = Main();. The APIs that we build in these tutorials will all be variations on this simple; theme. Behind this API we will refine the implementation of the JIT to add; support for concurrent compilation, optimization and lazy compilation.; Eventually we will extend the API itself to allow higher-level program; representations (e.g. ASTs) to be added to the JIT. KaleidoscopeJIT; ===============. In the previous section we described our API, now we examine a simple; implementation of it: The KaleidoscopeJIT class [1]_ that was used in the; `Implementing a language with LLVM <LangImpl01.html>`_ tutorials. We will use; the REPL code from `Chapter 7 <LangImpl07.html>`_ of that tutorial to supply the; input for our JIT: Each time the user enters an expression the REPL will add a; new IR module containing the code for that expression to the JIT. If the; expression is a top-level expression like '1+1' or 'sin(x)', the REPL will also; use the lookup method of our JIT class find and execute the code for the; expression. In later chapters of this tutorial we will modify the REPL to enable; new interactions with our JIT class, but for now we will take this setup for; granted and focus our attention on the implementation of our JIT itself. Our KaleidoscopeJIT class is defined i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:3595,extend,extend,3595,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['extend'],['extend']
Modifiability,"K_HAS_STRET = (1 << 29), // IFF BLOCK_HAS_SIGNATURE; BLOCK_HAS_SIGNATURE = (1 << 30),; };. In 10.6.ABI the (1<<29) was usually set and was always ignored by the runtime -; it had been a transitional marker that did not get deleted after the; transition. This bit is now paired with (1<<30), and represented as the pair; (3<<30), for the following combinations of valid bit settings, and their; meanings:. .. code-block:: c. switch (flags & (3<<29)) {; case (0<<29): 10.6.ABI, no signature field available; case (1<<29): 10.6.ABI, no signature field available; case (2<<29): ABI.2010.3.16, regular calling convention, presence of signature field; case (3<<29): ABI.2010.3.16, stret calling convention, presence of signature field,; }. The signature field is not always populated. The following discussions are presented as 10.6.ABI otherwise. ``Block`` literals may occur within functions where the structure is created in; stack local memory. They may also appear as initialization expressions for; ``Block`` variables of global or ``static`` local variables. When a ``Block`` literal expression is evaluated the stack based structure is; initialized as follows:. 1. A ``static`` descriptor structure is declared and initialized as follows:. a. The ``invoke`` function pointer is set to a function that takes the; ``Block`` structure as its first argument and the rest of the arguments (if; any) to the ``Block`` and executes the ``Block`` compound statement. b. The ``size`` field is set to the size of the following ``Block`` literal; structure. c. The ``copy_helper`` and ``dispose_helper`` function pointers are set to; respective helper functions if they are required by the ``Block`` literal. 2. A stack (or global) ``Block`` literal data structure is created and; initialized as follows:. a. The ``isa`` field is set to the address of the external; ``_NSConcreteStackBlock``, which is a block of uninitialized memory supplied; in ``libSystem``, or ``_NSConcreteGlobalBlock`` if this is a static",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:3739,variab,variables,3739,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,2,['variab'],['variables']
Modifiability,"L with; JSRootCore.js script, tries to avoid scripts caching problem by adding stamp parameter to all URLs; 4. New - provide simple drawing for TObjString (#164). ## Changes in 5.5.0; 1. Introduce JSROOT.StoreJSON() function. It creates JSON code for the; TCanvas with all drawn objects inside. Allows to store current canvas state; 2. Support ""item=img:file.png"" parameter to insert images in existing layout (#151); 3. Support TTree drawing into TGraph (#153), thanks @cozzyd; 4. Let configure ""&toolbar=right"" in URL to change position of tool buttons; 5. Let configure ""&divsize=500x400"" in URL of size of main div element (default - full browser); 6. Implement ""optstat1001"" and ""optfit101"" draw options for histograms; 7. Remove ""autocol"" options - standard ""plc"" should be used instead; 8. Provide drawing of artificial ""$legend"" item - it creates TLegend for all primitives in pad; Can be used when several histograms or several graphs superimposed; 9. Let configure ""&toolbar=vert"" in URL to change orientation of tool buttons; 10. Improve markers and error bars drawing for TH1/TProfile. ## Changes in 5.4.3; 1. Fix - draw functions also when histogram ""same"" option used (#159); 2. Fix - when draw histogram as markers improve optimization algorithm; 3. Fix - correct histogram Y-axis range selection in logarithmic scale; 4. Fix - for TH2 draw options allow combination ""colztext"" (#162); 5. Fix - PNG file generation with 3D drawings inside. ## Changes in 5.4.2; 1. Fix - take into account extra quotes in multipart http reply (#157); 2. Fix - display of labels on X axis with TProfile; 3. Fix - support time display in TMultiGraph; 4. Fix - correctly parse ""optstat"" and ""optfit"" in URL; 5. Fix - correctly update TGraph drawing when X range is changing; 6. Fix - return only TF1/TF2 object when searching function (#158). ## Changes in 5.4.1; 1. Fix - monitoring mode in draw.htm page; 2. Fix - zooming in colz palette; 3. Fix - support both 9.x and 10.x jsdom version in Node.js (#149",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:34244,config,configure,34244,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configure']
Modifiability,"L, .forwarding=&i, .flags=0, .size=sizeof(struct _block_byref_i), .captured_i=2 )};; struct __block_literal_5 _block_literal = {; &_NSConcreteStackBlock,; (1<<25)|(1<<29), <uninitialized>,; __block_invoke_5,; &__block_descriptor_5,; &i,; };. Importing ``__attribute__((NSObject))`` ``__block`` variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ``__block`` variable that is also marked ``__attribute__((NSObject))`` should; have ``byref_keep`` and ``byref_dispose`` helper functions that use; ``_Block_object_assign`` and ``_Block_object_dispose``. ``__block`` escapes; ^^^^^^^^^^^^^^^^^^^. Because ``Blocks`` referencing ``__block`` variables may have ``Block_copy()``; performed upon them the underlying storage for the variables may move to the; heap. In Objective-C Garbage Collection Only compilation environments the heap; used is the garbage collected one and no further action is required. Otherwise; the compiler must issue a call to potentially release any heap storage for; ``__block`` variables at all escapes or terminations of their scope. The call; should be:. .. code-block:: c. _Block_object_dispose(&_block_byref_foo, BLOCK_FIELD_IS_BYREF);. Nesting; ^^^^^^^. ``Blocks`` may contain ``Block`` literal expressions. Any variables used within; inner blocks are imported into all enclosing ``Block`` scopes even if the; variables are not used. This includes ``const`` imports as well as ``__block``; variables. Objective C Extensions to ``Blocks``; ====================================. Importing Objects; -----------------. Objects should be treated as ``__attribute__((NSObject))`` variables; all; ``copy_helper``, ``dispose_helper``, ``byref_keep``, and ``byref_dispose``; helper functions should use ``_Block_object_assign`` and; ``_Block_object_dispose``. There should be no code generated that uses; ``*-retain`` or ``*-release`` methods. ``Blocks`` as Objects; ---------------------. The compiler will treat ``Blocks`` as objects when synthesizing proper",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:18146,variab,variables,18146,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"L. L is left on the stack. * Otherwise, if the top stack entry is a location description or can be; converted to one, then it is popped and treated as a part location; description PL. Then:. * If the top stack entry (after popping PL) is a location description L; comprised of one incomplete composite location description SL, then the; incomplete composite location storage LS that SL specifies is updated to; append a new part P. P specifies the location description PL and has a; bit size of S scaled by 8 (the byte size). L is left on the stack. * Otherwise, a location description L comprised of one incomplete; composite location description SL is pushed on the stack. An incomplete composite location storage LS is created with a single; part P. P specifies the location description PL and has a bit size of S; scaled by 8 (the byte size). SL specifies LS with a bit offset of 0. * Otherwise, the DWARF expression is ill-formed. *Many compilers store a single variable in sets of registers or store a; variable partially in memory and partially in registers.* ``DW_OP_piece``; *provides a way of describing where a part of a variable is located.*. *If a non-0 byte displacement is required, the* ``DW_OP_LLVM_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_piece`` *operation.*. *The evaluation rules for the* ``DW_OP_piece`` *operation allow it to be; compatible with the DWARF Version 5 definition.*. .. note::. Since these extensions allow location descriptions to be entries on the; stack, a simpler operation to create composite location descriptions could; be defined. For example, just one operation that specifies how many parts,; and pops pairs of stack entries for the part size and location; description. Not only would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:135327,variab,variable,135327,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,2,['variab'],['variable']
Modifiability,"LBI_Signature`` (in configuration: ``Signature``); Align lambda body relative to the lambda signature. This is the default. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83468,config,configuration,83468,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"LES*/)));; ```. The resulting object will be a `RooSumL` containing a `RooSubsidiaryL` with the constrained parameters and `RooBinnedL` or `RooUnbinnedL` components for each simultaneous pdf component (depending on whether they are binned or unbinned pdfs).; Note that, just like for `fitTo`, the order of the parameters is arbitrary.; The difference is that `fitTo` has a step to analyze the `RooCmdArg` optional parameters for their content dynamically at runtime, while in `buildLikelihood` the arguments are statically typed and so no further runtime analysis is needed. As a side-note: one optional parameter of `RooNLLVar` that is not included in the `RooAbsL` tree is offsetting.; Offsetting has instead been implemented in the calculators that we'll describe next.; This is one of the consequences of the conceptual splitting of functionality into statistics and calculator classes.; Offsetting is a feature of calculation in a fitting context; it enhances numerical precision by subtracting the initial likelihood value from the value that the minimizer sees, thus setting it to zero for the minimizer.; Since this does not impact the derivative terms, it does not affect the fitting result, except for added numerical precision. ## Calculators; `RooFit::TestStatistics` provides two abstract base classes for likelihood calculation: `LikelihoodWrapper` and `LikelihoodGradientWrapper`.; These are used by the `RooAbsMinimizerFcn` implementation `MinuitFcnGrad` which expects them to, respectively, provide likelihood and likelihood gradient values for use by `Minuit2` in fitting the pdf to the dataset. The `Wrapper`s can be implemented for different kinds of algorithms, or with different kinds of optimization ""back-ends"" in mind.; One implementation of each is ready for use in `RooFit` currently:. 1. `LikelihoodSerial` is more or less simply a rewrite of the existing serial calculation of a `RooNLLVar`.; 2. `LikelihoodGradientJob` calculates the partial derivatives or the gradient i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:6228,enhance,enhances,6228,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['enhance'],['enhances']
Modifiability,"LF`` and ``DeriveCRLF`` of; ``LineEnding``. .. _DerivePointerAlignment:. **DerivePointerAlignment** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DerivePointerAlignment>`; If ``true``, analyze the formatted file for the most common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:60948,config,configuration,60948,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"LLVM Command Guide; ------------------. The following documents are command descriptions for all of the LLVM tools.; These pages describe how to use the LLVM commands and what their options are.; Note that these pages do not describe all of the options available for all; tools. To get a complete listing, pass the ``--help`` (general options) or; ``--help-hidden`` (general and debugging options) arguments to the tool you are; interested in. Basic Commands; ~~~~~~~~~~~~~~. .. toctree::; :maxdepth: 1. dsymutil; llc; lli; llvm-as; llvm-config; llvm-cov; llvm-cxxmap; llvm-debuginfo-analyzer; llvm-diff; llvm-dis; llvm-dwarfdump; llvm-dwarfutil; llvm-lib; llvm-libtool-darwin; llvm-link; llvm-lipo; llvm-mc; llvm-mca; llvm-opt-report; llvm-otool; llvm-profdata; llvm-readobj; llvm-reduce; llvm-stress; llvm-symbolizer; opt. GNU binutils replacements; ~~~~~~~~~~~~~~~~~~~~~~~~~. .. toctree::; :maxdepth: 1. llvm-addr2line; llvm-ar; llvm-cxxfilt; llvm-install-name-tool; llvm-nm; llvm-objcopy; llvm-objdump; llvm-ranlib; llvm-readelf; llvm-size; llvm-strings; llvm-strip. Debugging Tools; ~~~~~~~~~~~~~~~. .. toctree::; :maxdepth: 1. bugpoint; llvm-extract; llvm-bcanalyzer. Developer Tools; ~~~~~~~~~~~~~~~. .. toctree::; :maxdepth: 1. FileCheck; tblgen; clang-tblgen; lldb-tblgen; llvm-tblgen; mlir-tblgen; lit; llvm-exegesis; llvm-ifs; llvm-locstats; llvm-pdbutil; llvm-profgen; llvm-tli-checker. Remarks Tools; ~~~~~~~~~~~~~~. .. toctree::; :maxdepth: 1. llvm-remarkutil; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/index.rst:538,config,config,538,interpreter/llvm-project/llvm/docs/CommandGuide/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/index.rst,1,['config'],['config']
Modifiability,"LLVM_LIT=ON;-DCLANG_RESOURCE_DIR=${CLANG_RESOURCE_DIR}""); foreach(proj ${LLVM_ENABLE_RUNTIMES}); set(proj_dir ""${CMAKE_CURRENT_SOURCE_DIR}/../../${proj}""); if(IS_DIRECTORY ${proj_dir} AND EXISTS ${proj_dir}/CMakeLists.txt); list(APPEND runtimes ${proj_dir}); else(); message(FATAL_ERROR ""LLVM_ENABLE_RUNTIMES requests ${proj} but directory not found: ${proj_dir}""); endif(); string(TOUPPER ""${proj}"" canon_name); STRING(REGEX REPLACE ""-"" ""_"" canon_name ${canon_name}); set(LLVM_EXTERNAL_${canon_name}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../../${proj}""); endforeach(). function(get_compiler_rt_path path); foreach(entry ${runtimes}); get_filename_component(projName ${entry} NAME); if(""${projName}"" MATCHES ""compiler-rt""); set(${path} ${entry} PARENT_SCOPE); return(); endif(); endforeach(); endfunction(). include(LLVMExternalProjectUtils). if(NOT LLVM_BUILD_RUNTIMES); set(EXTRA_ARGS EXCLUDE_FROM_ALL); endif(). function(check_apple_target triple builtin_or_runtime); set(error ""\; compiler-rt for Darwin builds for all platforms and architectures using a \; single configuration. Specify only a single darwin triple (e.g. x86_64-apple-darwin) \; in your targets list (and not a triple for a specific platform such as macos). \; You can use variables such as COMPILER_RT_ENABLE_IOS and DARWIN_ios_ARCHS to \; control the specific platforms and architectures to build.""). set(seen_property ${builtin_or_runtime}_darwin_triple_seen); string(REPLACE ""-"" "";"" triple_components ${triple}); foreach(component ${triple_components}); string(TOLOWER ""${component}"" component_lower); if(component_lower MATCHES ""^darwin""); get_property(darwin_triple_seen GLOBAL PROPERTY ${seen_property}); if(darwin_triple_seen); message(FATAL_ERROR ""${error}""); endif(); set_property(GLOBAL PROPERTY ${seen_property} YES); if(NOT RUNTIMES_BUILD_ALLOW_DARWIN); message(FATAL_ERROR ""\; ${error} Set RUNTIMES_BUILD_ALLOW_DARWIN to allow a single darwin triple.""); endif(); elseif(component_lower MATCHES ""^ios|^macos|^tvos|^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:1348,config,configuration,1348,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"LLVM_PROFILE_FILE_PATTERN); endif(); if(NOT LLVM_CSPROFILE_FILE_PATTERN); if(NOT LLVM_CSPROFILE_DATA_DIR); file(TO_NATIVE_PATH ""${LLVM_BINARY_DIR}/csprofiles"" LLVM_CSPROFILE_DATA_DIR); endif(); file(TO_NATIVE_PATH ""${LLVM_CSPROFILE_DATA_DIR}/%${LLVM_PROFILE_MERGE_POOL_SIZE}m.profraw"" LLVM_CSPROFILE_FILE_PATTERN); endif(); endif(); endif(). if (LLVM_BUILD_STATIC); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -static""); # Remove shared library suffixes from use in find_library; foreach (shared_lib_suffix ${CMAKE_SHARED_LIBRARY_SUFFIX} ${CMAKE_IMPORT_LIBRARY_SUFFIX}); list(FIND CMAKE_FIND_LIBRARY_SUFFIXES ${shared_lib_suffix} shared_lib_suffix_idx); if(NOT ${shared_lib_suffix_idx} EQUAL -1); list(REMOVE_AT CMAKE_FIND_LIBRARY_SUFFIXES ${shared_lib_suffix_idx}); endif(); endforeach(); endif(). # Use libtool instead of ar if you are both on an Apple host, and targeting Apple.; if(CMAKE_HOST_APPLE AND APPLE); include(UseLibtool); endif(). # Override the default target with an environment variable named by LLVM_TARGET_TRIPLE_ENV.; set(LLVM_TARGET_TRIPLE_ENV CACHE STRING ""The name of environment variable to override default target. Disabled by blank.""); mark_as_advanced(LLVM_TARGET_TRIPLE_ENV). if(CMAKE_SYSTEM_NAME MATCHES ""BSD|Linux|OS390""); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default ON); else(); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default OFF); endif(); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR ${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default} CACHE BOOL; ""Enable per-target runtimes directory""). set(LLVM_PROFDATA_FILE """" CACHE FILEPATH; ""Profiling data file to use when compiling in order to improve runtime performance.""). if(LLVM_INCLUDE_TESTS); # Lit test suite requires at least python 3.6; set(LLVM_MINIMUM_PYTHON_VERSION 3.6); else(); # FIXME: it is unknown if this is the actual minimum bound; set(LLVM_MINIMUM_PYTHON_VERSION 3.0); endif(). # Find python before including config-ix, since it needs to be able to search; # for python modules.; find_package(Python3 $",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:36679,variab,variable,36679,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['variab'],['variable']
Modifiability,"LLVM_offset``. *This operation is supplied specifically to be able to encode more field; displacements in two bytes than can be done with* ``DW_OP_lit*;; DW_OP_LLVM_offset``\ *.*. .. note::. Should this be named ``DW_OP_LLVM_offset_uconst`` to match; ``DW_OP_plus_uconst``, or ``DW_OP_LLVM_offset_constu`` to match; ``DW_OP_constu``?. 3. ``DW_OP_LLVM_bit_offset`` *New*. ``DW_OP_LLVM_bit_offset`` pops two stack entries. The first must be an; integral type value that represents a bit displacement B. The second must be; a location description L. It adds the value of B to the bit offset of each single location description; SL of L, and pushes the updated L. It is an evaluation error if the updated bit offset of any SL is less than 0; or greater than or equal to the size of the location storage specified by; SL. 4. ``DW_OP_push_object_address``. ``DW_OP_push_object_address`` pushes the location description L of the; current object. *This object may correspond to an independent variable that is part of a; user presented expression that is being evaluated. The object location; description may be determined from the variable's own debugging information; entry or it may be a component of an array, structure, or class whose; address has been dynamically determined by an earlier step during user; expression evaluation.*. *This operation provides explicit functionality (especially for arrays; involving descriptors) that is analogous to the implicit push of the base; location description of a structure prior to evaluation of a*; ``DW_AT_data_member_location`` *to access a data member of a structure.*. .. note::. This operation could be removed and the object location description; specified as the initial stack as for ``DW_AT_data_member_location``. Or this operation could be used instead of needing to specify an initial; stack. The latter approach is more composable as access to the object may; be needed at any point of the expression, and passing it as the initial; stack requires ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:100012,variab,variable,100012,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability,"LLs provided with Windows. Each frame on the stack has an assigned EH; personality routine, which decides what actions to take to handle the exception.; There are a few major personalities for C and C++ code: the C++ personality; (``__CxxFrameHandler3``) and the SEH personalities (``_except_handler3``,; ``_except_handler4``, and ``__C_specific_handler``). All of them implement; cleanups by calling back into a ""funclet"" contained in the parent function. Funclets, in this context, are regions of the parent function that can be called; as though they were a function pointer with a very special calling convention.; The frame pointer of the parent frame is passed into the funclet either using; the standard EBP register or as the first parameter register, depending on the; architecture. The funclet implements the EH action by accessing local variables; in memory through the frame pointer, and returning some appropriate value,; continuing the EH process. No variables live in to or out of the funclet can be; allocated in registers. The C++ personality also uses funclets to contain the code for catch blocks; (i.e. all user code between the braces in ``catch (Type obj) { ... }``). The; runtime must use funclets for catch bodies because the C++ exception object is; allocated in a child stack frame of the function handling the exception. If the; runtime rewound the stack back to frame of the catch, the memory holding the; exception would be overwritten quickly by subsequent function calls. The use of; funclets also allows ``__CxxFrameHandler3`` to implement rethrow without; resorting to TLS. Instead, the runtime throws a special exception, and then uses; SEH (``__try / __except``) to resume execution with new information in the child; frame. In other words, the successive unwinding approach is incompatible with Visual; C++ exceptions and general purpose Windows exception handling. Because the C++; exception object lives in stack memory, LLVM cannot provide a custom personality;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:22555,variab,variables,22555,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['variab'],['variables']
Modifiability,"LUE %4, $noreg, !3, !4; %7:gr32 = SUB32rr %6, %5, implicit-def dead $eflags; DBG_VALUE %7, $noreg, !5, !6; %1:gr32 = MOV32rm %0, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1); DBG_VALUE %1, $noreg, !1, !2. Here, to avoid presenting a state in which the first assignment to ``!1``; disappears, the DBG_VALUE at the top of the block assigns the variable the; undefined location, until its value is available at the end of the block where; an additional DBG_VALUE is added. Were any other DBG_VALUE for ``!1`` to occur; in the instructions that the MOV32rm was sunk past, the DBG_VALUE for ``%1``; would be dropped and the debugger would never observe it in the variable. This; accurately reflects that the value is not available during the corresponding; portion of the original program. Variable locations during Register Allocation; ---------------------------------------------. To avoid debug instructions interfering with the register allocator, the; LiveDebugVariables pass extracts variable locations from a MIR function and; deletes the corresponding DBG_VALUE instructions. Some localized copy; propagation is performed within blocks. After register allocation, the; VirtRegRewriter pass re-inserts DBG_VALUE instructions in their original; positions, translating virtual register references into their physical; machine locations. To avoid encoding incorrect variable locations, in this; pass any DBG_VALUE of a virtual register that is not live, is replaced by; the undefined location. The LiveDebugVariables may insert redundant DBG_VALUEs; because of virtual register rewriting. These will be subsequently removed by; the RemoveRedundantDebugValues pass. LiveDebugValues expansion of variable locations; -----------------------------------------------. After all optimizations have run and shortly before emission, the; LiveDebugValues pass runs to achieve two aims:. * To propagate the location of variables through copies and register spills,; * For every block, to r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:35757,variab,variable,35757,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"LVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:2122,config,configure,2122,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['config'],['configure']
Modifiability,"LVM emits stack map data into the object code within a designated; :ref:`stackmap-section`. This stack map data contains a record for; each stack map. The record stores the stack map's instruction address; and contains an entry for each mapped value. Each entry encodes a; value's location as a register, stack offset, or constant. A patch point is an instruction address at which space is reserved for; patching a new instruction sequence at run time. Patch points look; much like calls to LLVM. They take arguments that follow a calling; convention and may return a value. They also imply stack map; generation, which allows the runtime to locate the patchpoint and; find the location of ``live values`` at that point. Motivation; ==========. This functionality is currently experimental but is potentially useful; in a variety of settings, the most obvious being a runtime (JIT); compiler. Example applications of the patchpoint intrinsics are; implementing an inline call cache for polymorphic method dispatch or; optimizing the retrieval of properties in dynamically typed languages; such as JavaScript. The intrinsics documented here are currently used by the JavaScript; compiler within the open source WebKit project, see the `FTL JIT; <https://trac.webkit.org/wiki/FTLJIT>`_, but they are designed to be; used whenever stack maps or code patching are needed. Because the; intrinsics have experimental status, compatibility across LLVM; releases is not guaranteed. The stack map functionality described in this document is separate; from the functionality described in; :ref:`stack-map`. `GCFunctionMetadata` provides the location of; pointers into a collected heap captured by the `GCRoot` intrinsic,; which can also be considered a ""stack map"". Unlike the stack maps; defined above, the `GCFunctionMetadata` stack map interface does not; provide a way to associate live register values of arbitrary type with; an instruction address, nor does it specify a format for the resulting; stack ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:1768,polymorphi,polymorphic,1768,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['polymorphi'],['polymorphic']
Modifiability,"LVMConstGEP2; LLVMConstInBoundsGEP -> LLVMConstInBoundsGEP2; LLVMAddAlias -> LLVMAddAlias2. Additionally, it will no longer be possible to call ``LLVMGetElementType()``; on a pointer type. It is possible to control whether opaque pointers are used (if you want to; override the default) using ``LLVMContext::setOpaquePointers``. Temporarily disabling opaque pointers; =====================================. In LLVM 15, opaque pointers are enabled by default, but it it still possible to; use typed pointers using a number of opt-in flags. For users of the clang driver interface, it is possible to temporarily restore; the old default using the ``-DCLANG_ENABLE_OPAQUE_POINTERS=OFF`` cmake option,; or by passing ``-Xclang -no-opaque-pointers`` to a single clang invocation. For users of the clang cc1 interface, ``-no-opaque-pointers`` can be passed.; Note that the ``CLANG_ENABLE_OPAQUE_POINTERS`` cmake option has no effect on; the cc1 interface. Usage for LTO can be disabled by passing ``-Wl,-plugin-opt=no-opaque-pointers``; to the clang driver. For users of LLVM as a library, opaque pointers can be disabled by calling; ``setOpaquePointers(false)`` on the ``LLVMContext``. For users of LLVM tools like opt, opaque pointers can be disabled by passing; ``-opaque-pointers=0``. Version Support; ===============. **LLVM 14:** Supports all necessary APIs for migrating to opaque pointers and deprecates/removes incompatible APIs. However, using opaque pointers in the optimization pipeline is **not** fully supported. This release can be used to make out-of-tree code compatible with opaque pointers, but opaque pointers should **not** be enabled in production. **LLVM 15:** Opaque pointers are enabled by default. Typed pointers are still; supported. **LLVM 16:** Opaque pointers are enabled by default. Typed pointers are; supported on a best-effort basis only and not tested. **LLVM 17:** Only opaque pointers are supported. Typed pointers are not; supported. Transition State; ================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:11372,plugin,plugin-opt,11372,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['plugin'],['plugin-opt']
Modifiability,"LVM_RUNTIME_OUTPUT_INTDIR}/llvm-strip); set(${CLANG_STAGE}_READELF -DCMAKE_READELF=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-readelf); endif(); endif(). if(BOOTSTRAP_LLVM_BUILD_INSTRUMENTED); add_dependencies(clang-bootstrap-deps llvm-profdata); set(PGO_OPT -DLLVM_PROFDATA=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-profdata); endif(). if(LLVM_BUILD_INSTRUMENTED); add_dependencies(clang-bootstrap-deps generate-profdata); set(PGO_OPT -DLLVM_PROFDATA_FILE=${CMAKE_CURRENT_BINARY_DIR}/utils/perf-training/clang.profdata); # Use the current tools for LTO instead of the instrumented ones; list(APPEND _BOOTSTRAP_DEFAULT_PASSTHROUGH; CMAKE_CXX_COMPILER; CMAKE_C_COMPILER; CMAKE_ASM_COMPILER; CMAKE_AR; CMAKE_RANLIB; DARWIN_LTO_LIBRARY; DYLD_LIBRARY_PATH). set(COMPILER_OPTIONS); set(LTO_LIBRARY); set(LTO_AR); set(LTO_RANLIB); endif(). # Populate the passthrough variables; foreach(variableName ${CLANG_BOOTSTRAP_PASSTHROUGH} ${_BOOTSTRAP_DEFAULT_PASSTHROUGH}); if(DEFINED ${variableName}); if(""${${variableName}}"" STREQUAL """"); set(value """"); else(); string(REPLACE "";"" ""|"" value ""${${variableName}}""); endif(); list(APPEND PASSTHROUGH_VARIABLES; -D${variableName}=${value}); endif(); endforeach(). # Find all variables that start with BOOTSTRAP_ and populate a variable with; # them.; get_cmake_property(variableNames VARIABLES); foreach(variableName ${variableNames}); if(variableName MATCHES ""^BOOTSTRAP_""); string(SUBSTRING ${variableName} 10 -1 varName); string(REPLACE "";"" ""|"" value ""${${variableName}}""); list(APPEND PASSTHROUGH_VARIABLES; -D${varName}=${value}); endif(); if(${variableName} AND variableName MATCHES ""LLVM_EXTERNAL_.*_SOURCE_DIR""); list(APPEND PASSTHROUGH_VARIABLES; -D${variableName}=${${variableName}}); endif(); endforeach(). # Build arguments for native tool used in CMake.; set(build_configuration ""$<CONFIG>""); set(build_tool_args ""${LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS}""); if(NOT build_tool_args STREQUAL """"); string(PREPEND build_tool_args ""-- ""); separate_arguments(build_tool_args",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:26816,variab,variables,26816,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,6,['variab'],"['variableName', 'variables']"
Modifiability,"LVM_TARGETS_TO_BUILD``,; which controls the LLVM target architectures that are included on the; build.; * CMake generates project files for all build types. To select a specific; build type, use the Configuration manager from the VS IDE or the; ``/property:Configuration`` command line option when using MSBuild.; * By default, the Visual Studio project files generated by CMake use the; 32-bit toolset. If you are developing on a 64-bit version of Windows and; want to use the 64-bit toolset, pass the ``-Thost=x64`` flag when; generating the Visual Studio solution. This requires CMake 3.8.0 or later. 13. Start Visual Studio and select configuration:. In the directory you created the project files will have an ``llvm.sln``; file, just double-click on that to open Visual Studio. The default Visual; Studio configuration is **Debug** which is slow and generates a huge amount; of debug information on disk. For now, we recommend selecting **Release**; configuration for the LLVM project which will build the fastest or; **RelWithDebInfo** which is also several time larger than Release.; Another technique is to build all of LLVM in Release mode and change; compiler flags, disabling optimization and enabling debug information, only; for specific libraries or source files you actually need to debug. 14. Test LLVM in Visual Studio:. You can run LLVM tests by merely building the project ""check-all"". The test; results will be shown in the VS output window. Once the build succeeds, you; have verified a working LLVM development environment!. You should not see any unexpected failures, but will see many unsupported; tests and expected failures:. ::. 114>Testing Time: 1124.66s; 114> Skipped : 39; 114> Unsupported : 21649; 114> Passed : 51615; 114> Expectedly Failed: 93; ========== Build: 114 succeeded, 0 failed, 321 up-to-date, 0 skipped ==========``. Alternatives to manual installation; ===================================; Instead of the steps above, to simplify the installation procedu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:7077,config,configuration,7077,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['config'],['configuration']
Modifiability,"Limits< double >::Max()=2.22507e-308); T TMath::Limits< T >::Epsilon() returning the epsilon (see Wikipedia for its definition) for the type T ( T; TMath::Limits< double >::Epsilon()=2.22045e-16). TRandom1 and TRandom3. Add an implementation of UInt_t GetSeed() to return the first element of the seed table. Before always a fixed; value was returned, independently of the random generator state; . ROOT::Fit::Fitter and related classes. Add new version of the Fitter class with various improvements:; ; add the possibility to just evaluate the objective function (FCN) one time (Fitter::EvalFCN) and fill the; result (class ROOT::Fit::FitResult using the obtained value of FCN plus the parameter values and errors from; the Fit configuration class (ROOT::Fit::FitConfig).; This required adding a nw constructor of FitResult from FitConfig.; This originated from the Savannah request. ; Add also new methods Fitter::SetFCN.; Update the configuration (parameter values and errors) after a fit with the FitResult values; So next fit will use improved parameter values and errors. This update can be switched on/off; by using FitConfig::SetUpdateAfterFit(on/off). By default is on.; Add new method FitConfig::SetFromFitResult.; Add possibility to run Hesse (Fitter:::CalculateHessErrors) without having done the minimization. Add support for weighted likelihood fits. Add a new method Fitter::ApplyWeightCorrection(fcn2); which corrects covariance matrix for the weights using the likelihood function built using the weight square; Add the support for weights for the binned Poisson likelihood fits (in the; ROOT::Fit::PoissonLikelihoodFCN class). A new option (WL) has been added also in TH1::Fit; for performing weighted fits of histograms (see ).; . ROOT::Math::Minimizer; Add new methods Minimizer::GetHessianMatrix(double * mat) and Minimizer::GetCovMatrix(double * mat) to return the full; matrices by filling the passed C arrays, which must have a dimension of at least n x n, where n is the; tot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html:1597,config,configuration,1597,math/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html,1,['config'],['configuration']
Modifiability,"LiveDebugVariables pass extracts variable locations from a MIR function and; deletes the corresponding DBG_VALUE instructions. Some localized copy; propagation is performed within blocks. After register allocation, the; VirtRegRewriter pass re-inserts DBG_VALUE instructions in their original; positions, translating virtual register references into their physical; machine locations. To avoid encoding incorrect variable locations, in this; pass any DBG_VALUE of a virtual register that is not live, is replaced by; the undefined location. The LiveDebugVariables may insert redundant DBG_VALUEs; because of virtual register rewriting. These will be subsequently removed by; the RemoveRedundantDebugValues pass. LiveDebugValues expansion of variable locations; -----------------------------------------------. After all optimizations have run and shortly before emission, the; LiveDebugValues pass runs to achieve two aims:. * To propagate the location of variables through copies and register spills,; * For every block, to record every valid variable location in that block. After this pass the DBG_VALUE instruction changes meaning: rather than; corresponding to a source-level assignment where the variable may change value,; it asserts the location of a variable in a block, and loses effect outside the; block. Propagating variable locations through copies and spills is; straightforwards: determining the variable location in every basic block; requires the consideration of control flow. Consider the following IR, which; presents several difficulties:. .. code-block:: text. define dso_local i32 @foo(i1 %cond, i32 %input) !dbg !12 {; entry:; br i1 %cond, label %truebr, label %falsebr. bb1:; %value = phi i32 [ %value1, %truebr ], [ %value2, %falsebr ]; br label %exit, !dbg !26. truebr:; call void @llvm.dbg.value(metadata i32 %input, metadata !30, metadata !DIExpression()), !dbg !24; call void @llvm.dbg.value(metadata i32 1, metadata !23, metadata !DIExpression()), !dbg !24; %value1 = ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:36680,variab,variables,36680,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"Lx.hwasan,unique,2; .Lx.hwasan.descriptor:; .word .Lx.hwasan-.Lx.hwasan.descriptor; .word 0x2d000004 // tag = 0x2d, size = 4. Error reporting; ---------------. Errors are generated by the `HLT` instruction and are handled by a signal handler. Attribute; ---------. HWASAN uses its own LLVM IR Attribute `sanitize_hwaddress` and a matching; C function attribute. An alternative would be to re-use ASAN's attribute; `sanitize_address`. The reasons to use a separate attribute are:. * Users may need to disable ASAN but not HWASAN, or vise versa,; because the tools have different trade-offs and compatibility issues.; * LLVM (ideally) does not use flags to decide which pass is being used,; ASAN or HWASAN are being applied, based on the function attributes. This does mean that users of HWASAN may need to add the new attribute; to the code that already uses the old attribute. Comparison with AddressSanitizer; ================================. HWASAN:; * Is less portable than :doc:`AddressSanitizer`; as it relies on hardware `Address Tagging`_ (AArch64).; Address Tagging can be emulated with compiler instrumentation,; but it will require the instrumentation to remove the tags before; any load or store, which is infeasible in any realistic environment; that contains non-instrumented code.; * May have compatibility problems if the target code uses higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:9243,portab,portable,9243,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,1,['portab'],['portable']
Modifiability,"M bitcode; files into a single archive library that can be linked into a program. However,; the archive can contain any kind of file. By default, :program:`llvm-ar`; generates a symbol table that makes linking faster because only the symbol; table needs to be consulted, not each individual file member of the archive. The :program:`llvm-ar` command can be used to *read* archive files in SVR4, GNU,; BSD , Big Archive, and Darwin format, and *write* in the GNU, BSD, Big Archive, and; Darwin style archive files. If an SVR4 format archive is used with the :option:`r`; (replace), :option:`d` (delete), :option:`m` (move) or :option:`q`; (quick update) operations, the archive will be reconstructed in the format; defined by :option:`--format`. Here's where :program:`llvm-ar` departs from previous :program:`ar`; implementations:. *The following option is not supported*. [f] - truncate inserted filenames. *The following options are ignored for compatibility*. --plugin=<string> - load a plugin which adds support for other file formats. [l] - ignored in :program:`ar`. *Symbol Table*. Since :program:`llvm-ar` supports bitcode files, the symbol table it creates; includes both native and bitcode symbols. *Deterministic Archives*. By default, :program:`llvm-ar` always uses zero for timestamps and UIDs/GIDs; to write archives in a deterministic mode. This is equivalent to the; :option:`D` modifier being enabled by default. If you wish to maintain; compatibility with other :program:`ar` implementations, you can pass the; :option:`U` modifier to write actual timestamps and UIDs/GIDs. *Windows Paths*. When on Windows :program:`llvm-ar` treats the names of archived *files* in the same; case sensitive manner as the operating system. When on a non-Windows machine; :program:`llvm-ar` does not consider character case. OPTIONS; -------. :program:`llvm-ar` operations are compatible with other :program:`ar`; implementations. However, there are a few modifiers (:option:`L`) that are not; found in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst:1309,plugin,plugin,1309,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,2,['plugin'],['plugin']
Modifiability,"M tools, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to *CMAKE_INSTALL_BINDIR*. **LLVM_UTILS_INSTALL_DIR**:STRING; The path to install auxiliary LLVM utilities, relative to the *CMAKE_INSTALL_PREFIX*.; Only matters if *LLVM_INSTALL_UTILS* is enabled.; Defaults to *LLVM_TOOLS_INSTALL_DIR*. **LLVM_EXAMPLES_INSTALL_DIR**:STRING; The path for examples of using LLVM, relative to the *CMAKE_INSTALL_PREFIX*.; Only matters if *LLVM_BUILD_EXAMPLES* is enabled.; Defaults to ""examples"". CMake Caches; ============. Recently LLVM and Clang have been adding some more complicated build system; features. Utilizing these new features often involves a complicated chain of; CMake variables passed on the command line. Clang provides a collection of CMake; cache scripts to make these features more approachable. CMake cache files are utilized using CMake's -C flag:. .. code-block:: console. $ cmake -C <path to cache file> <path to sources>. CMake cache scripts are processed in an isolated scope, only cached variables; remain set when the main configuration runs. CMake cached variables do not reset; variables that are already set unless the FORCE option is specified. A few notes about CMake Caches:. - Order of command line arguments is important. - -D arguments specified before -C are set before the cache is processed and; can be read inside the cache file; - -D arguments specified after -C are set after the cache is processed and; are unset inside the cache file. - All -D arguments will override cache file settings; - CMAKE_TOOLCHAIN_FILE is evaluated after both the cache file and the command; line arguments; - It is recommended that all -D options should be specified *before* -C. For more information about some of the advanced build configurations supported; via Cache files see :doc:`AdvancedBuilds`. Executing the Tests; ===================. Testing is performed when the *check-all* target is built. For instance, if you are; using Makefiles, execute this command in the root of you",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:39049,variab,variables,39049,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"MAKEDIR}/modules""); endif(). #---Add configuration files for kernel and jupyter----------------------------------------------; # Make sure the Jupyter ROOT C++ kernel runs with the same Python version as ROOT; set(root_jupyter_dir notebook); set(root_jupyter_config jupyter_notebook_config.py); configure_file(etc/${root_jupyter_dir}/${root_jupyter_config}.in etc/${root_jupyter_dir}/${root_jupyter_config}); install(FILES ${CMAKE_BINARY_DIR}/etc/${root_jupyter_dir}/${root_jupyter_config} DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/${root_jupyter_dir}). set(root_kernel_dir ${root_jupyter_dir}/kernels/root); set(root_kernel_file kernel.json); configure_file(etc/${root_kernel_dir}/${root_kernel_file}.in etc/${root_kernel_dir}/${root_kernel_file}); install(FILES ${CMAKE_BINARY_DIR}/etc/${root_kernel_dir}/${root_kernel_file} DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/${root_kernel_dir}). #---install clad header files-------------------------------------------------------------------; if(clad); install(DIRECTORY ${CMAKE_BINARY_DIR}/etc/cling/plugins/; DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/cling/plugins); endif(). #---Set flag for PyROOT tests that are expected to fail; if(pyroot); set(PYTESTS_WILLFAIL WILLFAIL); endif(). #---Configure Testing using CTest----------------------------------------------------------------; configure_file(${CMAKE_SOURCE_DIR}/cmake/modules/CTestCustom.cmake ${CMAKE_BINARY_DIR} COPYONLY); if(testing); include(RootCTest); set(upstreamprefix https://github.com/root-project). if(roottest); find_package(Git REQUIRED). # Check whether the repository exists in the source directory or its parent; get_filename_component(source_dir ${CMAKE_CURRENT_SOURCE_DIR} REALPATH); if(IS_DIRECTORY ${source_dir}/roottest/.git); set(repo_dir ${source_dir}/roottest); elseif(IS_DIRECTORY ${source_dir}/../roottest/.git); set(repo_dir ${source_dir}/../roottest); endif(); if(DEFINED repo_dir); execute_process(COMMAND ${GIT_EXECUTABLE} --git-dir=${repo_dir}/.git; remote get-url origi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:27603,plugin,plugins,27603,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,2,['plugin'],['plugins']
Modifiability,"MCJIT engine,; including the selection of MCJIT as the engine type to be created.; Of particular interest is the EngineBuilder::setMCJITMemoryManager; function. If the client does not explicitly create a memory manager at; this time, a default memory manager (specifically SectionMemoryManager); will be created when the MCJIT engine is instantiated. Once the options have been set, a client calls EngineBuilder::create to; create an instance of the MCJIT engine. If the client does not use the; form of this function that takes a TargetMachine as a parameter, a new; TargetMachine will be created based on the target triple associated with; the Module that was used to create the EngineBuilder. .. image:: MCJIT-engine-builder.png. EngineBuilder::create will call the static MCJIT::createJIT function,; passing in its pointers to the module, memory manager and target machine; objects, all of which will subsequently be owned by the MCJIT object. The MCJIT class has a member variable, Dyld, which contains an instance of; the RuntimeDyld wrapper class. This member will be used for; communications between MCJIT and the actual RuntimeDyldImpl object that; gets created when an object is loaded. .. image:: MCJIT-creation.png. Upon creation, MCJIT holds a pointer to the Module object that it received; from EngineBuilder but it does not immediately generate code for this; module. Code generation is deferred until either the; MCJIT::finalizeObject method is called explicitly or a function such as; MCJIT::getPointerToFunction is called which requires the code to have been; generated. Code Generation; ===============. When code generation is triggered, as described above, MCJIT will first; attempt to retrieve an object image from its ObjectCache member, if one; has been set. If a cached object image cannot be retrieved, MCJIT will; call its emitObject method. MCJIT::emitObject uses a local PassManager; instance and creates a new ObjectBufferStream instance, both of which it; passes to Targ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst:1690,variab,variable,1690,interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst,1,['variab'],['variable']
Modifiability,"MContext()), 0),; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 1),; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 2)};. This formatting scheme also makes it particularly easy to get predictable,; consistent, and automatic formatting with tools like `Clang Format`_. .. _Clang Format: https://clang.llvm.org/docs/ClangFormat.html. Language and Compiler Issues; ----------------------------. Treat Compiler Warnings Like Errors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Compiler warnings are often useful and help improve the code. Those that are; not useful, can be often suppressed with a small code change. For example, an; assignment in the ``if`` condition is often a typo:. .. code-block:: c++. if (V = getValue()) {; ...; }. Several compilers will print a warning for the code above. It can be suppressed; by adding parentheses:. .. code-block:: c++. if ((V = getValue())) {; ...; }. Write Portable Code; ^^^^^^^^^^^^^^^^^^^. In almost all cases, it is possible to write completely portable code. When; you need to rely on non-portable code, put it behind a well-defined and; well-documented interface. Do not use RTTI or Exceptions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In an effort to reduce code and executable size, LLVM does not use exceptions; or RTTI (`runtime type information; <https://en.wikipedia.org/wiki/Run-time_type_information>`_, for example,; ``dynamic_cast<>``). That said, LLVM does make extensive use of a hand-rolled form of RTTI that use; templates like :ref:`isa\<>, cast\<>, and dyn_cast\<> <isa>`.; This form of RTTI is opt-in and can be; :doc:`added to any class <HowToSetUpLLVMStyleRTTI>`. Prefer C++-style casts; ^^^^^^^^^^^^^^^^^^^^^^. When casting, use ``static_cast``, ``reinterpret_cast``, and ``const_cast``,; rather than C-style casts. There are two exceptions to this:. * When casting to ``void`` to suppress warnings about unused variables (as an; alternative to ``[[maybe_unused]]``). Prefer C-style casts in this instance. * Whe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:22070,portab,portable,22070,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['portab'],['portable']
Modifiability,"ME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR}; -DCMAKE_C_COMPILER_WORKS=ON; -DCMAKE_CXX_COMPILER_WORKS=ON; -DCMAKE_ASM_COMPILER_WORKS=ON; -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON; -DLLVM_RUNTIMES_TARGET=${name}; ${COMMON_CMAKE_ARGS}; ${${name}_extra_args}; EXTRA_TARGETS ${${name}_extra_targets}; ${${name}_test_targets}; USE_TOOLCHAIN; ${EXTRA_ARGS} ${ARG_EXTRA_ARGS}). add_dependencies(runtimes runtimes-${name}); add_dependencies(runtimes-configure runtimes-${name}-configure); add_dependencies(install-runtimes install-runtimes-${name}); add_dependencies(install-runtimes-stripped install-runtimes-${name}-stripped); if(LLVM_INCLUDE_TESTS); add_dependencies(check-runtimes check-runtimes-${name}); add_dependencies(runtimes-test-depends runtimes-test-depends-${name}); endif(); foreach(runtime_name ${runtime_names}); if(NOT TARGET ${runtime_name}); add_custom_target(${runtime_name}); endif(); add_dependencies(${runtime_name} ${runtime_name}-${name}); if(NOT TARGET install-${runtime_name}); add_custom_target(install-${runtime_name}); endif(); add_dependencies(install-${runtime_name} install-${runtime_name}-${name}); if(NOT TARGET install-${runtime_name}-stripped); add_custom_target(install-${runtime_name}-stripped); endif(); add_dependencies(install-${runtime_name}-stripped install-${runtime_name}-${name}-stripped); endforeach(); foreach(component ${LLVM_RUNTIME_DISTRIBUTION_COMPONENTS}); add_dependencies(${component} ${component}-${name}); add_dependencies(install-${component} install-${component}-${name}); add_dependencies(install-${component}-stripped install-${component}-${name}-stripped); endforeach(); endfunction(). if(runtimes); # Create a runtimes target that uses this file as its top-level CMake file.; # The runtimes target is a configuration of all the runtime libraries; # together in a single CMake invocation.; set(extra_deps """"); if(""openmp"" IN_LIST LLVM_ENABLE_RUNTIMES); foreach(dep opt llvm-link llvm-extract clang clang-offload-packager); if(TARGET ${dep} AND OPENMP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:13985,config,configure,13985,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,2,['config'],['configure']
Modifiability,"MINOS}$ uses the error matrix; to predict the values of all parameters at the various sub-minima which; it will have to find in the course of the calculation, and in the limit; that the problem is nearly linear, the predictions of $\mbox{MINOS}$; will be nearly exact, requiring very few iterations. On the other hand,; when the problem is very non-linear (i.e., $\mbox{FCN}$ is far from; a quadratic function of its parameters), is precisely the situation when; $\mbox{MINOS}$ is needed in order to indicate the correct parameter; errors. ### $\mbox{CONTOURS}$ plotting ###. M offers a procedure for finding $\mbox{FCN}$ $\mbox{CONTOURS}$; (provided via the class MnContours, see [api:contours]). The contour calculated by MnContours::operator() is dynamic, in the; sense that it represents the minimum of $\mbox{FCN}$ with respect to; all the other $\mbox{npar - 2}$ parameters (if any). In statistical; terms, this means that MnContours takes account of the correlations; between the two parameters being plotted, and all the other variable; parameters, using a procedure analogous to that of $\mbox{MINOS}$.; (If this feature is not wanted, then the other parameters must be fixed; before calling $\mbox{CONTOURS}$.) MnContours provides the actual; coordinates of the points around the contour, suitable for plotting with; a graphics routine or by hand (using MnPlot, see [api:plot]). The points; are given in counter-clockwise order around the contour. Only one; contour is calculated per command, and the level is; $\displaystyle F_{\mathrm{min}} + \mbox{up}$. where $\mbox{up}$; is the return value of FCNBase::up() specified by the user (usually 1.0; by default). The number of points to be calculated is chosen by the user; (default is 20). As a by-product, $\mbox{CONTOURS}$ provides the; $\mbox{MINOS}$ errors of the two parameters in question, since these; are just the extreme points of the contour (use the; MnContours::contour(...) method in order to get the points of the; contour and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:20144,variab,variable,20144,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"MVA method: TMlpANN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 200 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture (N stands for number of variables; any integers may also be used). ValidationFraction No 0.5 − Fraction of events in training tree used for cross validation. LearningMethod No Stochastic Stochastic, Batch, SteepestDescent, RibierePolak, FletcherReeves, BFGS Learning method. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Simulated Annealing (SA). Option Array Default value Predefined values Description. MaxCalls No 100000 − Maximum number of minimisation calls. InitialTemp No 1e+06 − Initial temperature. MinTemp No 1e-06 − Mimimum temperature. Eps No 1e-10 − Epsilon. TempScale No 1 − Temperature scale. AdaptiveSpeed No 1 − Adaptive speed. TempAdaptiveStep No 0.009875 − Step made in each generation temperature adaptive. UseDefaultScale No False − Use default temperature scale for temperature minimisation algorithm. UseDefaultTemp No False − Use default initial temperature. KernelTemp No IncAdaptive IncAdaptive, DecAda",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:28855,variab,variables,28855,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variables']
Modifiability,"M_DEFINITIONS``; A list of preprocessor defines that should be used when building against LLVM. ``LLVM_ENABLE_ASSERTIONS``; This is set to ON if LLVM was built with assertions, otherwise OFF. ``LLVM_ENABLE_EH``; This is set to ON if LLVM was built with exception handling (EH) enabled,; otherwise OFF. ``LLVM_ENABLE_RTTI``; This is set to ON if LLVM was built with run time type information (RTTI),; otherwise OFF. ``LLVM_INCLUDE_DIRS``; A list of include paths to directories containing LLVM header files. ``LLVM_PACKAGE_VERSION``; The LLVM version. This string can be used with CMake conditionals, e.g., ``if; (${LLVM_PACKAGE_VERSION} VERSION_LESS ""3.5"")``. ``LLVM_TOOLS_BINARY_DIR``; The path to the directory containing the LLVM tools (e.g. ``llvm-as``). Notice that in the above example we link ``simple-tool`` against several LLVM; libraries. The list of libraries is determined by using the; ``llvm_map_components_to_libnames()`` CMake function. For a list of available; components look at the output of running ``llvm-config --components``. Note that for LLVM < 3.5 ``llvm_map_components_to_libraries()`` was; used instead of ``llvm_map_components_to_libnames()``. This is now deprecated; and will be removed in a future version of LLVM. .. _cmake-out-of-source-pass:. Developing LLVM passes out of source; ------------------------------------. It is possible to develop LLVM passes out of LLVM's source tree (i.e. against an; installed or built LLVM). An example of a project layout is provided below. .. code-block:: none. <project dir>/; |; CMakeLists.txt; <pass name>/; |; CMakeLists.txt; Pass.cpp; ... Contents of ``<project dir>/CMakeLists.txt``:. .. code-block:: cmake. find_package(LLVM REQUIRED CONFIG). separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}); include_directories(${LLVM_INCLUDE_DIRS}). add_subdirectory(<pass name>). Contents of ``<project dir>/<pass name>/CMakeLists.txt``:. .. code-block:: cmake. ad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:44679,config,config,44679,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['config'],['config']
Modifiability,"Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory and you will be able to execute it simply by calling from; inside the interpreter:. ``` {.cpp}; root [2] macro1(); ```. ### Compile a Macro with the Compiler. A plethora of excellent compilers are available, both free and; commercial. We will refer to the `GCC` compiler in the following. In; this case, you have to include the appropriate headers in the code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keyboard events nor access to the graphics; windows of ROOT is available. If you want your stand-alone application; have display graphics output and respond to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:10238,config,config,10238,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['config'],['config']
Modifiability,"Make script files. They can contain code to execute on include as well as; definitions for commands. In CMake macros and functions are universally referred to as commands, and they; are the primary method of defining code that can be called multiple times. In LLVM we have several CMake modules that are included as part of our; distribution for developers who don't build our project from source. Those; modules are the fundamental pieces needed to build LLVM-based projects with; CMake. We also rely on modules as a way of organizing the build system's; functionality for maintainability and re-use within LLVM projects. Argument Handling; -----------------. When defining a CMake command handling arguments is very useful. The examples; in this section will all use the CMake ``function`` block, but this all applies; to the ``macro`` block as well. CMake commands can have named arguments that are required at every call site. In; addition, all commands will implicitly accept a variable number of extra; arguments (In C parlance, all commands are varargs functions). When a command is; invoked with extra arguments (beyond the named ones) CMake will store the full; list of arguments (both named and unnamed) in a list named ``ARGV``, and the; sublist of unnamed arguments in ``ARGN``. Below is a trivial example of; providing a wrapper function for CMake's built in function ``add_dependencies``. .. code-block:: cmake. function(add_deps target); add_dependencies(${target} ${ARGN}); endfunction(). This example defines a new macro named ``add_deps`` which takes a required first; argument, and just calls another function passing through the first argument and; all trailing arguments. CMake provides a module ``CMakeParseArguments`` which provides an implementation; of advanced argument parsing. We use this all over LLVM, and it is recommended; for any function that has complex argument-based behaviors or optional; arguments. CMake's official documentation for the module is in the; ``cmak",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:10594,variab,variable,10594,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variable']
Modifiability,"Member Records <member_types>`; as there are with types. Every symbol record describes is own length.; * Certain special symbol records begin a ""scope"". For these records, all following records; up until the next ``S_END`` record are ""children"" of this symbol record. For example,; given a symbol record which describes a certain function, all local variables of this; function would appear following the function up until the corresponding ``S_END`` record. Finally, there are three general categories of symbol record, grouped by where they are legal; to appear in a PDB file. Public Symbols (which appear only in the; :doc:`publics stream <PublicStream>`), Global Symbols (which appear only in the; :doc:`globals stream <GlobalStream>`) and module symbols (which appear in the; :doc:`module info stream <ModiStream>`). .. _public_symbols:. Public Symbols; --------------. Public symbols are the CodeView equivalent of DWARF ``.debug_pubnames``. There; is one public symbol record for every function or variable in the program that; has a mangled name. The :doc:`Publics Stream <PublicStream>`, which contains these; records, additionally contains a hash table that allows one to quickly locate a; record by mangled name. S_PUB32 (0x110e); ^^^^^^^^^^^^^^^^. There is only type of public symbol, an ``S_PUB32`` which describes a mangled; name, a flag indicating what kind of symbol it is (e.g. function, variable), and; the symbol's address. The :ref:`dbi_section_map_substream` of the; :doc:`DBI Stream <DbiStream>` can be consulted to determine what module this address; corresponds to, and from there that module's :doc:`module debug stream <ModiStream>`; can be consulted to locate full information for the symbol with the given address. .. _global_symbols:. Global Symbols; --------------. While there is one :ref:`public symbol <public_symbols>` for every symbol in the; program with `external` linkage, there is one global symbol for every symbol in the; program with linkage (including intern",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst:2545,variab,variable,2545,interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,1,['variab'],['variable']
Modifiability,"MemoryManagerAllocateDataSectionCallback()``. When LLVM creates; this section, it invokes the callback and passes the section name. The; JIT can record the in-memory address of the section at this time and; later parse it to recover the stack map data. For MachO (e.g. on Darwin), the stack map section name is; ""__llvm_stackmaps"". The segment name is ""__LLVM_STACKMAPS"". For ELF (e.g. on Linux), the stack map section name is; "".llvm_stackmaps"". The segment name is ""__LLVM_STACKMAPS"". Stack Map Usage; ===============. The stack map support described in this document can be used to; precisely determine the location of values at a specific position in; the code. LLVM does not maintain any mapping between those values and; any higher-level entity. The runtime must be able to interpret the; stack map record given only the ID, offset, and the order of the; locations, records, and functions, which LLVM preserves. Note that this is quite different from the goal of debug information,; which is a best-effort attempt to track the location of named; variables at every instruction. An important motivation for this design is to allow a runtime to; commandeer a stack frame when execution reaches an instruction address; associated with a stack map. The runtime must be able to rebuild a; stack frame and resume program execution using the information; provided by the stack map. For example, execution may resume in an; interpreter or a recompiled version of the same function. This usage restricts LLVM optimization. Clearly, LLVM must not move; stores across a stack map. However, loads must also be handled; conservatively. If the load may trigger an exception, hoisting it; above a stack map could be invalid. For example, the runtime may; determine that a load is safe to execute without a type check given; the current state of the type system. If the type system changes while; some activation of the load's function exists on the stack, the load; becomes unsafe. The runtime can prevent sub",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:17439,variab,variables,17439,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['variab'],['variables']
Modifiability,Multi-dimensional p.d.f.s with conditional p.d.fs in product; rf306_condpereventerrors.C - Complete example with use of conditional p.d.f. with per-event errors; rf307_fullpereventerrors.C -Complete example with use of full p.d.f. with per-event errors; rf308_normintegration2d.C - Examples on normalization of p.d.f.s in more than one dimension; rf309_ndimplot.C - Making 2 and 3 dimensional plots of p.d.f.s and datasets; rf310_sliceplot.C -Projecting p.d.f and data slices in discrete observables; rf311_rangeplot.C -Projecting p.d.f and data ranges in continuous observables; rf312_multirangefit.C - Performing fits in multiple (disjoint) ranges in one or more dimensions; rf313_paramranges.C - Working with parameterized ranges to define non-rectangular regions; rf314_paramfitrange.C - Working with parameterized ranges in a fit.; rf315_projectpdf.C - Marginizalization of multi-dimensional p.d.f.s through integration; rf316_llratioplot.C - Using the likelihood ratio technique to construct a signal enhanced 1-D projection of a multi-dimensional p.d.f.; ; DATA AND CATEGORIES. rf401_importttreethx.C -Overview of advanced option for importing data from ROOT TTree and THx histograms; rf402_datahandling.C - Tools for manipulation of (un)binned datasets; rf403_weightedevts.C - Using weights in unbinned datasets; rf404_categories.C - Working with RooCategory objects to describe discrete variables; rf405_realtocatfuncs.C - Demonstration of real-->discrete mapping functions; rf406_cattocatfuncs.C - Demonstration of discrete-->discrete (invertable) functions; rf407_latextables.C - Latex printing of lists and sets of RooArgSets; ; ORGANIZATION AND SIMULTANEOUS FITS. rf501_simultaneouspdf.C - Using simultaneous p.d.f.s to describe simultaneous fits to multiple datasets; rf502_wspacewrite.C - Creating and writing a workspace; rf503_wspaceread.C - Reading and using a workspace; rf504_simwstool.C - Using RooSimWSTool to construct a simultaneous p.d.f that is built of variations of an inp,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:3487,enhance,enhanced,3487,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['enhance'],['enhanced']
Modifiability,"Multiple types found on destructor lookup; Duplicate of 305. 415; CD1; Template deduction does not cause instantiation; Yes. 416; CD1; Class must be complete to allow operator lookup?; Yes. 417; CD1; Using derived-class qualified name in out-of-class nested class definition; No. 418; CD6; Imperfect wording on error on multiple default arguments on a called function; No. 419; open; Can cast to virtual base class be done on partially-constructed object?; Not resolved. 420; CD1; postfixexpression->scalar_type_dtor() inconsistent; Clang 9. 421; CD1; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:28822,variab,variables,28822,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"MyGC : public GCStrategy {; public:; MyGC() {}; };. GCRegistry::Add<MyGC>; X(""mygc"", ""My bespoke garbage collector."");; }. This boilerplate collector does nothing. More specifically:. * ``llvm.gcread`` calls are replaced with the corresponding ``load``; instruction. * ``llvm.gcwrite`` calls are replaced with the corresponding ``store``; instruction. * No safe points are added to the code. * The stack map is not compiled into the executable. Using the LLVM makefiles, this code; can be compiled as a plugin using a simple makefile:. .. code-block:: make. # lib/MyGC/Makefile. LEVEL := ../..; LIBRARYNAME = MyGC; LOADABLE_MODULE = 1. include $(LEVEL)/Makefile.common. Once the plugin is compiled, code using it may be compiled using ``llc; -load=MyGC.so`` (though MyGC.so may have some other platform-specific; extension):. ::. $ cat sample.ll; define void @f() gc ""mygc"" {; entry:; ret void; }; $ llvm-as < sample.ll | llc -load=MyGC.so. It is also possible to statically link the collector plugin into tools, such as; a language-specific compiler front-end. .. _collector-algos:. Overview of available features; ------------------------------. ``GCStrategy`` provides a range of features through which a plugin may do useful; work. Some of these are callbacks, some are algorithms that can be enabled,; disabled, or customized. This matrix summarizes the supported (and planned); features and correlates them with the collection techniques which typically; require them. .. |v| unicode:: 0x2714; :trim:. .. |x| unicode:: 0x2718; :trim:. +------------+------+--------+----------+-------+---------+-------------+----------+------------+; | Algorithm | Done | Shadow | refcount | mark- | copying | incremental | threaded | concurrent |; | | | stack | | sweep | | | | |; +============+======+========+==========+=======+=========+=============+==========+============+; | stack map | |v| | | | |x| | |x| | |x| | |x| | |x| |; +------------+------+--------+----------+-------+---------+-------------+---",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:25658,plugin,plugin,25658,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"N=OFF; -DENABLE_CEPH=OFF; -DXRDCL_LIB_ONLY=ON; -DCMAKE_INSTALL_RPATH:STRING=${XROOTD_PREFIX}/lib; -DOPENSSL_ROOT_DIR=${OPENSSL_ROOT_DIR}; INSTALL_COMMAND ${CMAKE_COMMAND} --build . --target install; LOG_DOWNLOAD 1 LOG_CONFIGURE 1 LOG_BUILD 1 LOG_INSTALL 1 LOG_OUTPUT_ON_FAILURE 1; BUILD_BYPRODUCTS ${XROOTD_CLIENT_LIBRARIES} ${XROOTD_UTILS_LIBRARIES}; TIMEOUT 600; ). # CMake checks for existence when a target is linked to XRootD; file(MAKE_DIRECTORY ${XROOTD_PREFIX}/include/xrootd). if(builtin_openssl); add_dependencies(BUILTIN_XROOTD OPENSSL); endif(). list(APPEND XROOTD_CLIENT_LIBRARIES OpenSSL::SSL); list(REMOVE_DUPLICATES XROOTD_CLIENT_LIBRARIES); list(APPEND XROOTD_UTILS_LIBRARIES OpenSSL::SSL); list(REMOVE_DUPLICATES XROOTD_UTILS_LIBRARIES). set(XROOTD_INCLUDE_DIRS ${XROOTD_PREFIX}/include/xrootd CACHE INTERNAL """" FORCE); set(XROOTD_CLIENT_LIBRARIES ${XROOTD_CLIENT_LIBRARIES} CACHE INTERNAL """" FORCE); set(XROOTD_UTILS_LIBRARIES ${XROOTD_UTILS_LIBRARIES} CACHE INTERNAL """" FORCE). list(APPEND CMAKE_BUILD_RPATH ${XROOTD_PREFIX}/lib); add_dependencies(XRootD BUILTIN_XROOTD). set_property(GLOBAL APPEND PROPERTY ROOT_BUILTIN_TARGETS BUILTIN_XROOTD). install(DIRECTORY ${XROOTD_PREFIX}/lib/ DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT libraries FILES_MATCHING PATTERN ""libXrd*""); install(DIRECTORY ${XROOTD_PREFIX}/include/xrootd/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/xrootd COMPONENT headers); if(APPLE); # XRootD libraries on mac need the LC_RPATH variable set. The build process already takes care of setting; # * BUILD_RPATH = build/XROOTD-prefix/../src; # * INSTALL_RPATH = build/lib; # Since the install directory for the builtin_xrootd target corresponds to the build directory of the main project.; # Use a post install script to change the LC_RPATH variable of the libraries in the ROOT install folder.; install(SCRIPT ${CMAKE_CURRENT_LIST_DIR}/XROOTDApplePostInstall.cmake; CODE ""xrootd_libs_change_rpath(${XROOTD_PREFIX}/lib ${CMAKE_INSTALL_FULL_LIBDIR})""; ); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xrootd/CMakeLists.txt:3046,variab,variable,3046,builtins/xrootd/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xrootd/CMakeLists.txt,2,['variab'],['variable']
Modifiability,"NABLE_RUNTIMES ${LLVM_DEFAULT_RUNTIMES}); endif(); foreach(proj IN LISTS LLVM_ENABLE_RUNTIMES); if (NOT ""${proj}"" IN_LIST LLVM_SUPPORTED_RUNTIMES); message(FATAL_ERROR ""Runtime \""${proj}\"" is not a supported runtime. Supported runtimes are: ${LLVM_SUPPORTED_RUNTIMES}""); endif(); endforeach(). if (""libc"" IN_LIST LLVM_ENABLE_RUNTIMES); # To build the libc runtime, we need to be able to build few libc build; # tools from the ""libc"" project. So, we add it to the list of enabled; # projects.; if (NOT ""libc"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""Enabling libc project to build libc build tools""); list(APPEND LLVM_ENABLE_PROJECTS ""libc""); endif(); endif(). # LLVM_ENABLE_PROJECTS_USED is `ON` if the user has ever used the; # `LLVM_ENABLE_PROJECTS` CMake cache variable. This exists for; # several reasons:; #; # * As an indicator that the `LLVM_ENABLE_PROJECTS` list is now the single; # source of truth for which projects to build. This means we will ignore user; # supplied `LLVM_TOOL_<project>_BUILD` CMake cache variables and overwrite; # them.; #; # * The case where the user previously had `LLVM_ENABLE_PROJECTS` set to a; # non-empty list but now the user wishes to disable building all other projects; # by setting `LLVM_ENABLE_PROJECTS` to an empty string. In that case we still; # need to set the `LLVM_TOOL_${upper_proj}_BUILD` variables so that we disable; # building all the projects that were previously enabled.; set(LLVM_ENABLE_PROJECTS_USED OFF CACHE BOOL """"); mark_as_advanced(LLVM_ENABLE_PROJECTS_USED). if (LLVM_ENABLE_PROJECTS_USED OR NOT LLVM_ENABLE_PROJECTS STREQUAL """"); set(LLVM_ENABLE_PROJECTS_USED ON CACHE BOOL """" FORCE); foreach(proj ${LLVM_KNOWN_PROJECTS} ${LLVM_EXTERNAL_PROJECTS}); string(TOUPPER ""${proj}"" upper_proj); string(REGEX REPLACE ""-"" ""_"" upper_proj ${upper_proj}); if (""${proj}"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); set(PROJ_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}""); if",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:8201,variab,variables,8201,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['variab'],['variables']
Modifiability,"NEXT_CLANG_STAGE}'""; DEPENDEES build; USES_TERMINAL 1; ); ExternalProject_Add_StepTargets(${NEXT_CLANG_STAGE} really-install); add_custom_target(${NEXT_CLANG_STAGE}-install DEPENDS ${NEXT_CLANG_STAGE}-really-install). if(NOT CLANG_BOOTSTRAP_TARGETS); set(CLANG_BOOTSTRAP_TARGETS check-llvm check-clang check-all); endif(); foreach(target ${CLANG_BOOTSTRAP_TARGETS}); # Install targets have side effects, so we always want to execute them.; # ""install"" is reserved by CMake and can't be used as a step name for; # ExternalProject_Add_Step, so we can match against ""^install-"" instead of; # ""^install"" to get a tighter match. CMake's installation scripts already; # skip up-to-date files, so there's no behavior change if you install to the; # same destination multiple times.; if(target MATCHES ""^install-""); set(step_always ON); else(); set(step_always OFF); endif(). ExternalProject_Add_Step(${NEXT_CLANG_STAGE} ${target}; COMMAND ${CMAKE_COMMAND} --build <BINARY_DIR> --target ${target}; COMMENT ""Performing ${target} for '${NEXT_CLANG_STAGE}'""; DEPENDEES configure; ALWAYS ${step_always}; EXCLUDE_FROM_MAIN ON; USES_TERMINAL 1; ). if(target MATCHES ""^stage[0-9]*""); add_custom_target(${target} DEPENDS ${NEXT_CLANG_STAGE}-${target}); endif(). ExternalProject_Add_StepTargets(${NEXT_CLANG_STAGE} ${target}); endforeach(); endif(). if (CLANG_BOLT_INSTRUMENT AND NOT LLVM_BUILD_INSTRUMENTED); set(CLANG_PATH ${LLVM_RUNTIME_OUTPUT_INTDIR}/clang); set(CLANG_INSTRUMENTED ${CLANG_PATH}-bolt.inst); set(BOLT_FDATA ${CMAKE_CURRENT_BINARY_DIR}/utils/perf-training/prof.fdata). # Instrument clang with BOLT; add_custom_target(clang-instrumented; DEPENDS ${CLANG_INSTRUMENTED}; ); add_custom_command(OUTPUT ${CLANG_INSTRUMENTED}; DEPENDS clang llvm-bolt; COMMAND llvm-bolt ${CLANG_PATH} -o ${CLANG_INSTRUMENTED}; -instrument --instrumentation-file-append-pid; --instrumentation-file=${BOLT_FDATA}; COMMENT ""Instrumenting clang binary with BOLT""; VERBATIM; ). # Optimize original (pre-bolt) Clang using the co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:30312,config,configure,30312,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['config'],['configure']
Modifiability,"NG_ENABLE_OPAQUE_POINTERS=OFF`` cmake option,; or by passing ``-Xclang -no-opaque-pointers`` to a single clang invocation. For users of the clang cc1 interface, ``-no-opaque-pointers`` can be passed.; Note that the ``CLANG_ENABLE_OPAQUE_POINTERS`` cmake option has no effect on; the cc1 interface. Usage for LTO can be disabled by passing ``-Wl,-plugin-opt=no-opaque-pointers``; to the clang driver. For users of LLVM as a library, opaque pointers can be disabled by calling; ``setOpaquePointers(false)`` on the ``LLVMContext``. For users of LLVM tools like opt, opaque pointers can be disabled by passing; ``-opaque-pointers=0``. Version Support; ===============. **LLVM 14:** Supports all necessary APIs for migrating to opaque pointers and deprecates/removes incompatible APIs. However, using opaque pointers in the optimization pipeline is **not** fully supported. This release can be used to make out-of-tree code compatible with opaque pointers, but opaque pointers should **not** be enabled in production. **LLVM 15:** Opaque pointers are enabled by default. Typed pointers are still; supported. **LLVM 16:** Opaque pointers are enabled by default. Typed pointers are; supported on a best-effort basis only and not tested. **LLVM 17:** Only opaque pointers are supported. Typed pointers are not; supported. Transition State; ================. As of July 2023:. Typed pointers are **not** supported on the ``main`` branch. The following typed pointer functionality has been removed:. * The ``CLANG_ENABLE_OPAQUE_POINTERS`` cmake flag is no longer supported.; * The ``-no-opaque-pointers`` cc1 clang flag is no longer supported.; * The ``-opaque-pointers`` opt flag is no longer supported.; * The ``-plugin-opt=no-opaque-pointers`` LTO flag is no longer supported.; * C APIs that do not support opaque pointers (like ``LLVMBuildLoad``) are no; longer supported. The following typed pointer functionality is still to be removed:. * Various APIs that are no longer relevant with opaque pointers.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:12731,plugin,plugin-opt,12731,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['plugin'],['plugin-opt']
Modifiability,"NIM, B34 (1988), 396-402. [3] D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; spectroscopy. NIM 214 (1983), 431-434. [4] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I.; Turzo.:Identification of peaks in multidimensional coincidence gamma-ray; spectra. NIM, A443 (2000) 108-125. [5] M.A. Mariscotti: A method for identification of peaks in the; presence of background and its application to spectrum analysis. NIM 50; (1967), 309-320. [6] Z.K. Silagadze, A new algorithm for automatic photopeak searches.; NIM A 376 (1996), 451. [7] P. Bandžuch, M. Morháč, J. Krištiak: Study of the VanCitter and Gold; iterative methods of deconvolution and their application in the; deconvolution of experimental spectra of positron annihilation, NIM A; 384 (1997) 506-515. [8] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I. Turzo.:; Efficient one- and two-dimensional Gold deconvolution and its; application to gamma-ray spectra decomposition. NIM, A401 (1997); 385-408. [9] I. A. Slavic: Nonlinear least-squares fitting without matrix; inversion applied to complex Gaussian spectra analysis. NIM 134 (1976); 285-289. [10] B. Mihaila: Analysis of complex gamma spectra, Rom. Jorn. Phys.,; Vol. 39, No. 2, (1994), 139-148. [11] T. Awaya: A new method for curve fitting to the data with low; statistics not using chi-square method. NIM 165 (1979) 317-323. [12] T. Hauschild, M. Jentschel: Comparison of maximum likelihood; estimation and chi-square statistics applied to counting experiments.; NIM A 457 (2001) 384-401. [13] M. Morháč, J. Kliman, M. Jandel, Ľ. Krupa, V. Matoušek: Study; of fitting algorithms applied to simultaneous analysis of large number; of peaks in $\gamma$-ray spectra. Applied Spectroscopy, Vol. 57, No. 7 (2003) 753-760. [14] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform; spectral enhancement techniques for gamma-ray spectroscopy. NIM A353; (1994) 280-284. [15] D. Hearn, M. P. Baker: Computer Graphics, Prentice-Hall; International, Inc., 1994.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:84026,enhance,enhancement,84026,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['enhance'],['enhancement']
Modifiability,Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:159096,variab,variable,159096,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,OD class; Unknown. 1141; NAD; Non-static data member initializers have not been implemented; Unknown. 1142; C++11; friend declaration of member function of containing class; Unknown. 1143; NAD; Move semantics for *this have not been implemented; Unknown. 1144; C++11; Remove access declarations; Unknown. 1145; C++11; Defaulting and triviality; Unknown. 1146; C++11; exception-specifications of defaulted functions; Unknown. 1147; C++11; Destructors should be default nothrow; Unknown. 1148; C++11; Copy elision and move construction of function parameters; Unknown. 1149; C++11; Trivial non-public copy operators in subobjects; Unknown. 1150; NAD; Inheriting constructors have not been implemented; Unknown. 1151; C++11; Overload resolution with initializer-list and non-list constructors; Unknown. 1152; C++11; Rules for determining existence of implicit conversion sequence; Unknown. 1153; C++11; Type matching in address of overloaded function; Unknown. 1154; C++11; Address of thread_local variable as non-type template argument; Unknown. 1155; C++11; Internal-linkage non-type template arguments; Unknown. 1156; C++11; Partial ordering in a non-call context; Unknown. 1157; open; Partial ordering of function templates is still underspecified; Not resolved. 1158; C++11; Recursive instantiation via alias template; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unkno,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:76687,variab,variable,76687,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"ODness; Unknown. 1053; NAD; Terminate vs undefined behavior for noexcept violation; Unknown. 1054; C++11; Lvalue-to-rvalue conversions in expression statements; No. 1055; C++11; Permissible uses of void; Unknown. 1056; C++11; Template aliases, member definitions, and the current instantiation; Unknown. 1057; C++11; decltype and the current instantiation; Unknown. 1058; NAD; Reference binding of incompatible array types; Unknown. 1059; CD3; Cv-qualified array types (with rvalues); Unknown. 1060; C++11; Scoped enumerators in integral constant expressions; Unknown. 1061; C++11; Negative array bounds in a new-expression; Unknown. 1062; C++11; Syntax of attribute-specifiers in lambdas; Unknown. 1063; C++11; [[hiding]] with non-attribute declarations; Unknown. 1064; C++11; Defaulted move constructor for a union; Unknown. 1065; C++11; [[hiding]] with [[override]]; Unknown. 1066; C++11; When is a copy/move assignment operator implicitly defined?; Unknown. 1067; NAD; [[hiding]], using-declarations, and multiple inheritance; Unknown. 1068; C++11; Template aliases with default arguments and template parameter packs; Unknown. 1069; C++11; Incorrect function type with trailing-return-type; Unknown. 1070; C++11; Missing initializer clauses in aggregate initialization; Clang 3.5. 1071; C++11; Literal class types and trivial default constructors; Unknown. 1072; C++11; Scoped enumerator with the same name as its containing class; Unknown. 1073; C++11; Merging dynamic-exception-specifications and noexcept-specifications; Unknown. 1074; C++11; Value-dependent noexcept-expressions; Unknown. 1075; C++11; Grammar does not allow template alias in type-name; Unknown. 1076; CD5; Value categories and lvalue temporaries; Unknown. 1077; NAD; Explicit specializations in non-containing namespaces; Unknown. 1078; NAD; Narrowing and the usual arithmetic conversions; Unknown. 1079; C++11; Overload resolution involving aggregate initialization; Unknown. 1080; C++11; Confusing relationship between te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:70512,inherit,inheritance,70512,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inherit'],['inheritance']
Modifiability,"OL; If enabled, the Z3 constraint solver is activated for the Clang static analyzer.; A recent version of the z3 library needs to be available on the system. **LLVM_ENABLE_ZLIB**:STRING; Used to decide if LLVM tools should support compression/decompression with; zlib. Allowed values are ``OFF``, ``ON`` (default, enable if zlib is found),; and ``FORCE_ON`` (error if zlib is not found). **LLVM_ENABLE_ZSTD**:STRING; Used to decide if LLVM tools should support compression/decompression with; zstd. Allowed values are ``OFF``, ``ON`` (default, enable if zstd is found),; and ``FORCE_ON`` (error if zstd is not found). **LLVM_EXPERIMENTAL_TARGETS_TO_BUILD**:STRING; Semicolon-separated list of experimental targets to build and linked into; llvm. This will build the experimental target without needing it to add to the; list of all the targets available in the LLVM's main CMakeLists.txt. **LLVM_EXTERNAL_{CLANG,LLD,POLLY}_SOURCE_DIR**:PATH; These variables specify the path to the source directory for the external; LLVM projects Clang, lld, and Polly, respectively, relative to the top-level; source directory. If the in-tree subdirectory for an external project; exists (e.g., llvm/tools/clang for Clang), then the corresponding variable; will not be used. If the variable for an external project does not point; to a valid path, then that project will not be built. **LLVM_EXTERNAL_PROJECTS**:STRING; Semicolon-separated list of additional external projects to build as part of; llvm. For each project LLVM_EXTERNAL_<NAME>_SOURCE_DIR have to be specified; with the path for the source code of the project. Example:; ``-DLLVM_EXTERNAL_PROJECTS=""Foo;Bar""; -DLLVM_EXTERNAL_FOO_SOURCE_DIR=/src/foo; -DLLVM_EXTERNAL_BAR_SOURCE_DIR=/src/bar``. **LLVM_EXTERNALIZE_DEBUGINFO**:BOOL; Generate dSYM files and strip executables and libraries (Darwin Only).; Defaults to OFF. **LLVM_FORCE_USE_OLD_TOOLCHAIN**:BOOL; If enabled, the compiler and standard library versions won't be checked. LLVM; may not compil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:26811,variab,variables,26811,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"OL_DIR**:STRING; Full path to a directory containing executables for the build host; (containing binaries such as ``llvm-tblgen`` and ``clang-tblgen``). This is; intended for cross-compiling: if the user sets this variable and the; directory contains executables with the expected names, no separate; native versions of those executables will be built. **LLVM_NO_INSTALL_NAME_DIR_FOR_BUILD_TREE**:BOOL; Defaults to ``OFF``. If set to ``ON``, CMake's default logic for library IDs; on Darwin in the build tree will be used. Otherwise the install-time library; IDs will be used in the build tree as well. Mainly useful when other CMake; library ID control variables (e.g., ``CMAKE_INSTALL_NAME_DIR``) are being; set to non-standard values. **LLVM_OPTIMIZED_TABLEGEN**:BOOL; If enabled and building a debug or asserts build the CMake build system will; generate a Release build tree to build a fully optimized tablegen for use; during the build. Enabling this option can significantly speed up build times; especially when building LLVM in Debug configurations. **LLVM_PARALLEL_COMPILE_JOBS**:STRING; Define the maximum number of concurrent compilation jobs. **LLVM_PARALLEL_LINK_JOBS**:STRING; Define the maximum number of concurrent link jobs. **LLVM_RAM_PER_COMPILE_JOB**:STRING; Calculates the amount of Ninja compile jobs according to available resources.; Value has to be in MB, overwrites LLVM_PARALLEL_COMPILE_JOBS. Compile jobs ; will be between one and amount of logical cores. **LLVM_RAM_PER_LINK_JOB**:STRING; Calculates the amount of Ninja link jobs according to available resources.; Value has to be in MB, overwrites LLVM_PARALLEL_LINK_JOBS. Link jobs will ; be between one and amount of logical cores. Link jobs will not run ; exclusively therefore you should add an offset of one or two compile jobs ; to be sure its not terminated in your memory restricted environment. On ELF; platforms also consider ``LLVM_USE_SPLIT_DWARF`` in Debug build. **LLVM_PROFDATA_FILE**:PATH; Path to a pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:32379,config,configurations,32379,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['config'],['configurations']
Modifiability,"OOT shell variable should be set appropriately.; During compilation library `$ROOTSYS/lib/libROOTCefDisplay.so` and executable `$ROOTSYS/bin/cef_main`; should be created. Also check that several files like `icudtl.dat`, `v8_context_snapshot_blob.bin`, `snapshot_blob.bin`; copied into ROOT library directory. 7. Run ROOT with `--web=cef` argument to use CEF web display like:. ~~~; $ root --web=cef $ROOTSYS/tutorials/rcanvas/rh2.cxx; ~~~. ## Compile libcef_dll_wrapper on Windows. 1. Download binary win32 build like https://cef-builds.spotifycdn.com/cef_binary_95.7.12%2Bg99c4ac0%2Bchromium-95.0.4638.54_windows32.tar.bz2. 2. Extract in directory without spaces like `C:\Soft\cef`. 3. Modify `cmake/cef_variables.cmake` to set dynamic linking, replace ""/MT"" by ""/MD"" in approx line 389. 4. Start ""x86 Native tools Command Prompt for VS 2019"". Do:; ~~~; $ cd C:\Soft\cef; $ mkdir build; $ cd build; $ cmake -G""Visual Studio 16 2019"" -A Win32 -Thost=x64 ..; $ cmake --build . --config Release --target libcef_dll_wrapper; ~~~. 5. Before compiling ROOT, `set CEF_ROOT=C:\Soft\cef` variable. ## Using plain CEF in ROOT batch mode on Linux. Default CEF builds, provided by [https://cef-builds.spotifycdn.com/index.html](https://cef-builds.spotifycdn.com/index.html), do; not include support of Ozone framework, which the only support headless mode in CEF. To run ROOT in headless (or batch) made with such CEF distribution,; one can use `Xvfb` server. Most simple way is to use `xvfb-run` utility like:. ~~~; $ xvfb-run --server-args='-screen 0, 1024x768x16' root.exe -l --web=cef $ROOTSYS/tutorials/rcanvas/rline.cxx -q; ~~~. Or run `Xvfb` before starting ROOT:. ~~~; $ Xvfb :99 &; $ export DISPLAY=:99; $ root.exe -l --web=cef $ROOTSYS/tutorials/rcanvas/rline.cxx -q; ~~~. ## Compile CEF with ozone support. Since March 2019 one can compile [CEF without X11](https://bitbucket.org/chromiumembedded/cef/issues/2296/), but such builds not provided.; Therefore to be able to use real headless mode in CEF,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/Readme.md:2298,config,config,2298,gui/cefdisplay/Readme.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/Readme.md,1,['config'],['config']
Modifiability,"OOT. The concepts of REPL and JIT compilation. Cling’s methods for handling errors, expression evaluation, streaming out of execution results, runtime dynamism.; * - `Interactive, Introspected C++ at CERN <https://www.youtube.com/watch?v=K2KqEV866Ro>`_; - *V Vasilev*, CERN PH-SFT, 2013; - Vassil Vasilev (Princeton University) explains how Cling enables interactivity in C++, and illustrates the type introspection mechanism provided by the interpreter.; * - `Introducing Cling, a C++ Interpreter Based on Clang/LLVM <https://www.youtube.com/watch?v=f9Xfh8pv3Fs>`_; - *Axel Naumann* 2012 Googletechtalks; - Axel Naumann (CERN) discusses Cling’s most relevant features: abstract syntax tree (AST) production, wrapped functions, global initialization of a function, delay expression evaluation at runtime, and dynamic scopes.; * - `Creating Cling, an interactive interpreter interface <https://www.youtube.com/watch?v=BjmGOMJWeAo>`_; - *Axel Naumann* 2010 LLVM Developers’ meeting; - This presentation introduces Cling, an ahead-of-time compiler that extends C++ for ease of use as an interpreter.; . ; .. list-table:: Demos, tutorials, Cling’s ecosystem:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Cling integration | CLion <https://www.jetbrains.com/help/clion/cling-integration.html#install-cling>`_; - 2022.2 Version; - CLion uses Cling to integrate the `Quick Documentation <https://www.jetbrains.com/help/clion/2022.2/viewing-inline-documentation.html>`_ popup by allowing you to view the value of the expressions evaluated at compile time.; * - `Interactive C++ for Data Science <https://www.youtube.com/watch?v=23E0S3miWB0&t=2716s>`_; - *Vassil Vassilev* 2021 CppCon (The C++ Conference); - In this video, the author discusses how Cling enables interactive C++ for Data Science projects. ; * - `Cling -- Beyond Just Interpreting C++ <https://blog.llvm.org/posts/2021-03-25-cling-beyond-just-interpreting-cpp/>`_; - *Vassil Vassilev* 2021 The LLVM Project Blog; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:1779,extend,extends,1779,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['extend'],['extends']
Modifiability,"OT shell. For more difficult problems the full FOAM may be better. ### How to run application programs ?. The application program can be run in two modes: it can be simply; interpreted by CLING or compiled. The first method is simpler but; results in slower execution. The second method employs ACLiC -; The Automatic Compiler of Libraries, which automatizes the; process of compilation and linking. In $(ROOTSYS)/tutorials there are 3 demonstration programs:. #### foam_kanwa.C; is a simple example how to run FOAM in interactive; mode. To run this macro issue the following simple command from the; Linux shell:. ```; root foam_kanwa.C; ```. or from CLING:. ```; root [0] .x foam_kanwa.C; ```. Simulation will start and graphical canvas with plot; of the distribution function appear. In this example; we defined the distribution function simply as a global; function function Camel2. #### foam_demo.C; shows usage of FOAM in compiled mode, which is; the preferred method. The integrand function is defined; now as a Density method from class TFDISTR inheriting from; abstract class TFoamIntegrand. User can modify interface to; integrand function according to their needs but they should; always remember to define Density method which provides the; density distribution.; Enter CLING interpreter and type:. ```; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; ```. to load FOAM library, compile and execute macro foam_demo.C.; A shared object foam_demo_C.so is created in the current; directory. At the end of exploration phase FOAM object; including distribution function will be written to disk. #### foam_demopers.C; demonstrates persistency of FOAM classes.; To run this macro type:. ```; root [0] .x foam_demopers.C; ```. Program reads the FOAM object from disk, checks its; consistency and prints geometry of cells. Next starts the; the generation. It can be interpreted directly by CLING; because compiled TFDISTR class is already available in; `foam_demo_C.so` library. @}",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md:1510,inherit,inheriting,1510,tutorials/foam/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md,1,['inherit'],['inheriting']
Modifiability,"OT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you get the access to every object; created in a ROOT program. The **`TROOT`** object has several lists; pointing to the main ROOT objects. During a ROOT session, the; ***`gROOT`*** keeps a series of collections to manage objects. They; can be accessed via ***`gROOT`***`::GetListOf...` methods. ``` {.cpp}; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFunctions(); gROOT->GetListOfSpecials(); gROOT->GetListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); ```. These methods return a **`TSeqCollection`**",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:32354,variab,variables,32354,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['variab'],['variables']
Modifiability,"OT; # but variables like ROOT_asimage_FOUND used here and produced in ROOTConfig.cmake; find_package(ROOT REQUIRED). if(DEFINED ROOT_SOURCE_DIR) # Testing using the binary tree; set(ROOT_root_CMD root.exe); if(NOT MSVC) # Ignore environment on Windows; set(ROOT_environ PATH=${CMAKE_BINARY_DIR}/bin:$ENV{PATH}; ${ld_library_path}=${CMAKE_BINARY_DIR}/lib:$ENV{${ld_library_path}}; ROOTSYS=${CMAKE_BINARY_DIR}; PYTHONPATH=${CMAKE_BINARY_DIR}/lib:$ENV{PYTHONPATH}); else(); set(ROOT_environ ROOTSYS=${CMAKE_BINARY_DIR}; PYTHONPATH=${CMAKE_BINARY_DIR}/bin;$ENV{PYTHONPATH}); endif(); else() # testing using an installation; include(${ROOT_USE_FILE}); if(DEFINED ROOT_CONFIG_EXECUTABLE) #---If ROOT was built with the classic configure/make---; set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/../cmake/modules); include(RootMacros); set(ROOT_root_CMD root.exe); endif(); enable_testing(); endif(). # Set the environment for the tutorials, which is the eventual ROOT_environ; # plus some environment variables related to limiting the number of threads; # used by NumPy.; # See: https://stackoverflow.com/questions/30791550/limit-number-of-threads-in-numpy; set(TUTORIAL_ENV ${ROOT_environ} OMP_NUM_THREADS=1 OPENBLAS_NUM_THREADS=1 MKL_NUM_THREADS=1). #---Copy the CTestCustom.cmake file into the build directory--------; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/CTestCustom.cmake ${CMAKE_CURRENT_BINARY_DIR} COPYONLY). #---Provide a rootlogon.C file in the current build directory that; # will affect the way we run all tutorials.; # This overwrites the existing rootlogon.C and rootalias.C in the; # tutorials directory which is copied to the build area.; #-------------------------------------------------------------------; file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/rootlogon.C ""{; // Needed by ACLiC to use the current directory for scratch area; gSystem->SetBuildDir(\"".\"", kTRUE);; }""); file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/rootalias.C """"); file(WRITE ${CMAKE_CURRENT_BINARY_DI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:1449,variab,variables,1449,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['variab'],['variables']
Modifiability,"OTFOUND; foreach(suffix FOUND INCLUDE_DIR INCLUDE_DIRS CRYPTO_LIBRARY SSL_LIBRARY LIBRARY LIBRARIES VERSION); unset(OPENSSL_${suffix} PARENT_SCOPE); endforeach(). set(OPENSSL_VERSION ""3.0.13""); set(OPENSSL_URL ""http://lcgpackages.web.cern.ch/lcgpackages/tarFiles/sources/openssl-${OPENSSL_VERSION}.tar.gz""); set(OPENSSL_URLHASH ""SHA256=88525753f79d3bec27d2fa7c66aa0b92b3aa9498dafd93d7cfa4b3780cdae313""); set(OPENSSL_PREFIX ${CMAKE_CURRENT_BINARY_DIR}/OPENSSL-prefix). foreach(lib ssl crypto); string(TOUPPER ${lib} libupper); set(libname ${CMAKE_STATIC_LIBRARY_PREFIX}${lib}${CMAKE_STATIC_LIBRARY_SUFFIX}); set(OPENSSL_${libupper}_LIBRARY ${OPENSSL_PREFIX}/lib/${libname}); endforeach(). if(APPLE); if(${ROOT_ARCHITECTURE} MATCHES ""macosxarm64""); set(OPENSSL_CONFIG_CMD ./Configure darwin64-arm64-cc); else(); set(OPENSSL_CONFIG_CMD ./Configure darwin64-x86_64-cc); endif(); if (CMAKE_OSX_SYSROOT); set(OSX_SYSROOT ""-isysroot ${CMAKE_OSX_SYSROOT}""); endif(); else(); set(OPENSSL_CONFIG_CMD ./config); endif(). ExternalProject_Add(OPENSSL; URL ${OPENSSL_URL} URL_HASH ${OPENSSL_URLHASH}; CONFIGURE_COMMAND ${OPENSSL_CONFIG_CMD} no-shared --prefix=<INSTALL_DIR>; BUILD_COMMAND make -j1 CC=${CMAKE_C_COMPILER}\ -fPIC\ ${OSX_SYSROOT}; INSTALL_COMMAND make install_sw; BUILD_IN_SOURCE 1; LOG_BUILD 1 LOG_CONFIGURE 1 LOG_DOWNLOAD 1 LOG_INSTALL 1; BUILD_BYPRODUCTS ${OPENSSL_CRYPTO_LIBRARY} ${OPENSSL_SSL_LIBRARY}; TIMEOUT 600). set(OPENSSL_FOUND TRUE CACHE BOOL """" FORCE); set(OPENSSL_VERSION ${OPENSSL_VERSION} CACHE INTERNAL """" FORCE); set(OPENSSL_VERSION_STRING ""${OPENSSL_VERSION}"" CACHE INTERNAL """" FORCE); set(OPENSSL_PREFIX ${OPENSSL_PREFIX} CACHE INTERNAL """" FORCE) # needed by Davix; set(OPENSSL_INCLUDE_DIR ${OPENSSL_PREFIX}/include CACHE INTERNAL """" FORCE); set(OPENSSL_INCLUDE_DIRS ${OPENSSL_PREFIX}/include CACHE INTERNAL """" FORCE); set(OPENSSL_CRYPTO_LIBRARY ${OPENSSL_CRYPTO_LIBRARY} CACHE INTERNAL """" FORCE); set(OPENSSL_SSL_LIBRARY ${OPENSSL_SSL_LIBRARY} CACHE INTERNAL """" FORCE); set(OPEN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/openssl/CMakeLists.txt:1340,config,config,1340,builtins/openssl/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/openssl/CMakeLists.txt,1,['config'],['config']
Modifiability,"Objective-C, variables may; additionally be objects. When a ``Block`` literal expression is used as the initial value of a global; or ``static`` local variable, it is initialized as follows:. .. code-block:: c. struct __block_literal_1 __block_literal_1 = {; &_NSConcreteGlobalBlock,; (1<<28)|(1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. that is, a different address is provided as the first value and a particular; (1<<28) bit is set in the ``flags`` field, and otherwise it is the same as for; stack based ``Block`` literals. This is an optimization that can be used for; any ``Block`` literal that imports no ``const`` or ``__block`` storage; variables. Imported Variables; ==================. Variables of ``auto`` storage class are imported as ``const`` copies. Variables; of ``__block`` storage class are imported as a pointer to an enclosing data; structure. Global variables are simply referenced and not considered as; imported. Imported ``const`` copy variables; ---------------------------------. Automatic storage variables not marked with ``__block`` are imported as; ``const`` copies. The simplest example is that of importing a variable of type ``int``:. .. code-block:: c. int x = 10;; void (^vv)(void) = ^{ printf(""x is %d\n"", x); }; x = 11;; vv();. which would be compiled to:. .. code-block:: c. struct __block_literal_2 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_2 *);; struct __block_descriptor_2 *descriptor;; const int x;; };. void __block_invoke_2(struct __block_literal_2 *_block) {; printf(""x is %d\n"", _block->x);; }. static struct __block_descriptor_2 {; unsigned long int reserved;; unsigned long int Block_size;; } __block_descriptor_2 = { 0, sizeof(struct __block_literal_2) };. and:. .. code-block:: c. struct __block_literal_2 __block_literal_2 = {; &_NSConcreteStackBlock,; (1<<29), <uninitialized>,; __block_invoke_2,; &__block_descriptor_2,; x; };. In summary, scalars, structures, unions, and funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:6920,variab,variables,6920,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"Operand's that represent the cumulative inputs and outputs of; the bundled MIs. Packing / bundling of MachineInstrs for VLIW architectures should; generally be done as part of the register allocation super-pass. More; specifically, the pass which determines what MIs should be bundled; together should be done after code generator exits SSA form; (i.e. after two-address pass, PHI elimination, and copy coalescing).; Such bundles should be finalized (i.e. adding BUNDLE MIs and input and; output register MachineOperands) after virtual registers have been; rewritten into physical registers. This eliminates the need to add; virtual register operands to BUNDLE instructions which would; effectively double the virtual register def and use lists. Bundles may; use virtual registers and be formed in SSA form, but may not be; appropriate for all use cases. .. _MC Layer:. The ""MC"" Layer; ==============. The MC Layer is used to represent and process code at the raw machine code; level, devoid of ""high level"" information like ""constant pools"", ""jump tables"",; ""global variables"" or anything like that. At this level, LLVM handles things; like label names, machine instructions, and sections in the object file. The; code in this layer is used for a number of important purposes: the tail end of; the code generator uses it to write a .s or .o file, and it is also used by the; llvm-mc tool to implement standalone machine code assemblers and disassemblers. This section describes some of the important classes. There are also a number; of important subsystems that interact at this layer, they are described later in; this manual. .. _MCStreamer:. The ``MCStreamer`` API; ----------------------. MCStreamer is best thought of as an assembler API. It is an abstract API which; is *implemented* in different ways (e.g. to output a .s file, output an ELF .o; file, etc) but whose API correspond directly to what you see in a .s file.; MCStreamer has one method per directive, such as EmitLabel, EmitSymbol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:26200,variab,variables,26200,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['variab'],['variables']
Modifiability,"Otherwise, the DWARF is ill-formed if SL is not a memory location; description in any of the target architecture specific address spaces. The resulting L is the *frame base* for the subprogram or entry point. *Typically, E will use the* ``DW_OP_call_frame_cfa`` *operation or be a; stack pointer register plus or minus some offset.*. *The frame base for a subprogram is typically an address relative to the; first unit of storage allocated for the subprogram's stack frame. The*; ``DW_AT_frame_base`` *attribute can be used in several ways:*. 1. *In subprograms that need location lists to locate local variables, the*; ``DW_AT_frame_base`` *can hold the needed location list, while all; variables' location descriptions can be simpler ones involving the frame; base.*. 2. *It can be used in resolving ""up-level"" addressing within; nested routines. (See also* ``DW_AT_static_link``\ *, below)*. *Some languages support nested subroutines. In such languages, it is; possible to reference the local variables of an outer subroutine from within; an inner subroutine. The* ``DW_AT_static_link`` *and* ``DW_AT_frame_base``; *attributes allow debuggers to support this same kind of referencing.*. 3. If a ``DW_TAG_subprogram`` or ``DW_TAG_entry_point`` debugger information; entry is lexically nested, it may have a ``DW_AT_static_link`` attribute,; whose value is a DWARF expression E. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language thread of execution upon which; the user is focused, if any. The result of the evaluation is the location; description L of the *canonical frame address* (see; :ref:`amdgpu-dwarf-call-frame-information`) of the relevant call frame of; the subprogram instance that immediately lexically encloses the current call; frame's subprogram or entry point.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:159303,variab,variables,159303,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variables']
Modifiability,"Our little language supports a couple of interesting features: it; supports user defined binary and unary operators, it uses JIT; compilation for immediate evaluation, and it supports a few control flow; constructs with SSA construction. Part of the idea of this tutorial was to show you how easy and fun it; can be to define, build, and play with languages. Building a compiler; need not be a scary or mystical process! Now that you've seen some of; the basics, I strongly encourage you to take the code and hack on it.; For example, try adding:. - **global variables** - While global variables have questionable value; in modern software engineering, they are often useful when putting; together quick little hacks like the Kaleidoscope compiler itself.; Fortunately, our current setup makes it very easy to add global; variables: just have value lookup check to see if an unresolved; variable is in the global variable symbol table before rejecting it.; To create a new global variable, make an instance of the LLVM; ``GlobalVariable`` class.; - **typed variables** - Kaleidoscope currently only supports variables; of type double. This gives the language a very nice elegance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to ac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:1779,variab,variable,1779,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['variab'],['variable']
Modifiability,"P register will be allowed, and any xmm; register will be allowed. Because regular expressions are enclosed with double braces, they are; visually distinct, and you don't need to use escape characters within the double; braces like you would in C. In the rare case that you want to match double; braces explicitly from the input, you can use something ugly like; ``{{[}][}]}}`` as your pattern. Or if you are using the repetition count; syntax, for example ``[[:xdigit:]]{8}`` to match exactly 8 hex digits, you; would need to add parentheses like this ``{{([[:xdigit:]]{8})}}`` to avoid; confusion with FileCheck's closing double-brace. FileCheck String Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. It is often useful to match a pattern and then verify that it occurs again; later in the file. For codegen tests, this can be useful to allow any; register, but verify that that register is used consistently later. To do; this, :program:`FileCheck` supports string substitution blocks that allow; string variables to be defined and substituted into patterns. Here is a simple; example:. .. code-block:: llvm. ; CHECK: test5:; ; CHECK: notw	[[REGISTER:%[a-z]+]]; ; CHECK: andw	{{.*}}[[REGISTER]]. The first check line matches a regex ``%[a-z]+`` and captures it into the; string variable ``REGISTER``. The second line verifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operand",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:26408,variab,variables,26408,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variables']
Modifiability,"PDF files are usually smaller because; some parts of them can be compressed. PDF also allows to define table of contents. This facility can be used; in ROOT. The following example shows how to proceed:. ``` {.cpp}; {; TCanvas* canvas = new TCanvas(""canvas"");; TH1F* histo = new TH1F(""histo"",""test 1"",10,0.,10.);; histo->SetFillColor(2);; histo->Fill(2.);; histo->Draw();; canvas->Print(""plots.pdf("",""Title:One bin filled"");; histo->Fill(4.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Two bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }; ```. Each character string following the keyword ""Title:"" makes a new entry; in the table of contents. ## Create or Modify a Style. All objects that can be drawn in a pad inherit from one or more; attribute classes like **`TAttLine`**, **`TAttFill`**, **`TAttText`**,; **`TAttMarker`**. When objects are created, their default attributes are; taken from the current style. The current style is an object of the; class **`TStyle`** and can be referenced via the global variable; ***`gStyle`*** (in `TStyle.h`). See the class **`TStyle`** for a; complete list of the attributes that can be set in one style. ROOT provides several styles called:. - ""`Default`"" - the default style. - ""`Plain`"" - the simple style (black and white). - ""`Bold`"" - bolder lines. - ""`Video`"" - suitable for html output or screen viewing. The ""`Default`"" style is created by:. ``` {.cpp}; TStyle *default = new TStyle(""Default"",""Default Style"");; ```. The ""`Plain`"" style can be used if you want to get a ""conventional""; PostScript output or if you are working on a monochrome display. The; following example shows how to create it. ``` {.cpp}; TStyle *plain = new TStyle(""Plain"",; ""Plain Style(no colors/fill areas)"");; plain->SetCan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:101387,inherit,inherit,101387,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inherit']
Modifiability,"PEND PROPERTY LLVM_EXPORTS tf_xla_runtime); # Once we add more modules, we should handle this more automatically.; if (DEFINED LLVM_OVERRIDE_MODEL_HEADER_INLINERSIZEMODEL); set(LLVM_INLINER_MODEL_PATH ""none""); elseif(NOT DEFINED LLVM_INLINER_MODEL_PATH; OR ""${LLVM_INLINER_MODEL_PATH}"" STREQUAL """"; OR ""${LLVM_INLINER_MODEL_PATH}"" STREQUAL ""autogenerate""); set(LLVM_INLINER_MODEL_PATH ""autogenerate""); set(LLVM_INLINER_MODEL_AUTOGENERATED 1); endif(); if (DEFINED LLVM_OVERRIDE_MODEL_HEADER_REGALLOCEVICTMODEL); set(LLVM_RAEVICT_MODEL_PATH ""none""); elseif(NOT DEFINED LLVM_RAEVICT_MODEL_PATH; OR ""${LLVM_RAEVICT_MODEL_PATH}"" STREQUAL """"; OR ""${LLVM_RAEVICT_MODEL_PATH}"" STREQUAL ""autogenerate""); set(LLVM_RAEVICT_MODEL_PATH ""autogenerate""); set(LLVM_RAEVICT_MODEL_AUTOGENERATED 1); endif(). endif(). # Configure the three LLVM configuration header files.; configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/config.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/config.h); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/llvm-config.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/llvm-config.h); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/abi-breaking.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/abi-breaking.h). # Add target for generating source rpm package.; set(LLVM_SRPM_USER_BINARY_SPECFILE ${CMAKE_CURRENT_SOURCE_DIR}/llvm.spec.in; CACHE FILEPATH "".spec file to use for srpm generation""); set(LLVM_SRPM_BINARY_SPECFILE ${CMAKE_CURRENT_BINARY_DIR}/llvm.spec); set(LLVM_SRPM_DIR ""${CMAKE_CURRENT_BINARY_DIR}/srpm""). get_source_info(${CMAKE_CURRENT_SOURCE_DIR} revision repository); string(LENGTH ""${revision}"" revision_length); set(LLVM_RPM_SPEC_REVISION ""${revision}""). configure_file(; ${LLVM_SRPM_USER_BINARY_SPECFILE}; ${LLVM_SRPM_BINARY_SPECFILE} @ONLY). add_custom_target(srpm; COMMAND cpack -G TGZ --config CPackSourceConfig.cmake -B ${LLVM_SRPM_DIR}/SOURCES; COMMAND rpmbuild -bs --define '_topdir ${LLVM_SRPM_DIR}' ${LLVM_SRPM_BINARY_SPECFILE}); set_target_properties(srpm PROPERTIE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:45031,config,config,45031,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config']
Modifiability,"PGO does best when the profiles gathered represent how the user plans to use the; compiler. Notably, highly accurate profiles of llc building x86_64 code aren't; incredibly helpful if you're going to be targeting ARM. By default, the script above does two things to get solid coverage. It:. - runs all of Clang and LLVM's lit tests, and; - uses the instrumented Clang to build Clang, LLVM, and all of the other; LLVM subprojects available to it. Together, these should give you:. - solid coverage of building C++,; - good coverage of building C,; - great coverage of running optimizations,; - great coverage of the backend for your host's architecture, and; - some coverage of other architectures (if other arches are supported backends). Altogether, this should cover a diverse set of uses for Clang and LLVM. If you; have very specific needs (e.g. your compiler is meant to compile a large browser; for four different platforms, or similar), you may want to do something else.; This is configurable in the script itself. Building Clang with PGO; =======================. If you prefer to not use the script or the cmake cache, this briefly goes over; how to build Clang/LLVM with PGO. First, you should have at least LLVM, Clang, and compiler-rt checked out; locally. Next, at a high level, you're going to need to do the following:. 1. Build a standard Release Clang and the relevant libclang_rt.profile library; 2. Build Clang using the Clang you built above, but with instrumentation; 3. Use the instrumented Clang to generate profiles, which consists of two steps:. - Running the instrumented Clang/LLVM/lld/etc. on tasks that represent how; users will use said tools.; - Using a tool to convert the ""raw"" profiles generated above into a single,; final PGO profile. 4. Build a final release Clang (along with whatever other binaries you need); using the profile collected from your benchmark. In more detailed steps:. 1. Configure a Clang build as you normally would. It's highly recommended th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst:2742,config,configurable,2742,interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,1,['config'],['configurable']
Modifiability,"PPLE); target_compile_definitions(HelloWorld PUBLIC APPLE); endif(). Variables, Types, and Scope; ===========================. Dereferencing; -------------. In CMake variables are ""stringly"" typed. All variables are represented as; strings throughout evaluation. Wrapping a variable in ``${}`` dereferences it; and results in a literal substitution of the name for the value. CMake refers to; this as ""variable evaluation"" in their documentation. Dereferences are performed; *before* the command being called receives the arguments. This means; dereferencing a list results in multiple separate arguments being passed to the; command. Variable dereferences can be nested and be used to model complex data. For; example:. .. code-block:: cmake. set(var_name var1); set(${var_name} foo) # same as ""set(var1 foo)""; set(${${var_name}}_var bar) # same as ""set(foo_var bar)"". Dereferencing an unset variable results in an empty expansion. It is a common; pattern in CMake to conditionally set variables knowing that it will be used in; code paths that the variable isn't set. There are examples of this throughout; the LLVM CMake build system. An example of variable empty expansion is:. .. code-block:: cmake. if(APPLE); set(extra_sources Apple.cpp); endif(); add_executable(HelloWorld HelloWorld.cpp ${extra_sources}). In this example the ``extra_sources`` variable is only defined if you're; targeting an Apple platform. For all other targets the ``extra_sources`` will be; evaluated as empty before add_executable is given its arguments. Lists; -----. In CMake lists are semi-colon delimited strings, and it is strongly advised that; you avoid using semi-colons in lists; it doesn't go smoothly. A few examples of; defining lists:. .. code-block:: cmake. # Creates a list with members a, b, c, and d; set(my_list a b c d); set(my_list ""a;b;c;d""). # Creates a string ""a b c d""; set(my_string ""a b c d""). Lists of Lists; --------------. One of the more complicated patterns in CMake is lists of lists. Bec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:3676,variab,variables,3676,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"P` to `RA`. This flavour of CFI is *precise*, i.e. the function is guaranteed to return; to the point exactly following the call. An alternative approach is to; copy `RA` from stack to `R` in the first instruction of `f()`,; then `JMP` to `R`.; This approach is simpler to implement (does not require changing the caller); but weaker (there is a small window when `RA` is actually stored on stack). Functions called once; ---------------------; Suppose `f()` is called in just one place in the program; (assuming we can verify this in LTO mode).; In this case we can replace the `RET` instruction with a `JMP` instruction; with the immediate constant for `RA`.; This will *precisely* enforce the return control flow no matter what is stored on stack. Another variant is to compare `RA` on stack with the known constant and abort; if they don't match; then `JMP` to the known constant address. Functions called in a small number of call sites; ------------------------------------------------; We may extend the above approach to cases where `f()`; is called more than once (but still a small number of times).; With LTO we know all possible values of `RA` and we check them; one-by-one (or using binary search) against the value on stack.; If the match is found, we `JMP` to the known constant address, otherwise abort. This protection is *near-precise*, i.e. it guarantees that the control flow will; be transferred to one of the valid return addresses for this function,; but not necessary to the point of the most recent `CALL`. General case; ------------; For functions called multiple times a *return jump table* is constructed; in the same manner as jump tables for indirect function calls (see above).; The correct jump table entry (or its index) is passed by `CALL` to `f()`; (as an extra argument) and then spilled to stack.; The `RET` instruction is replaced with a load of the jump table entry,; jump table range check, and `JMP` to the jump table entry. This protection is also *near-preci",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:25864,extend,extend,25864,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['extend'],['extend']
Modifiability,"P``. Note that in the LLVM IR that constants; are all uniqued together and shared. For this reason, the API uses the; ""foo::get(...)"" idiom instead of ""new foo(..)"" or ""foo::Create(..)"". .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; Value *V = NamedValues[Name];; if (!V); LogErrorV(""Unknown variable name"");; return V;; }. References to variables are also quite simple using LLVM. In the simple; version of Kaleidoscope, we assume that the variable has already been; emitted somewhere and its value is available. In practice, the only; values that can be in the ``NamedValues`` map are function arguments.; This code simply checks to see that the specified name is in the map (if; not, an unknown variable is being referenced) and returns the value for; it. In future chapters, we'll add support for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(TheContext),; ""booltmp"");; default:; return LogErrorV(""invalid binary operator"");; }; }. Binary operators start to get more interesting. The basic idea here is; that we recursively emit code for the left-hand side of the expression,; then the right-hand side, then we compute the result of the binary; expression. In this code, we do a simple switch on the opcode to create; the right LLVM instruction. In the example above, the LLVM builder class is starting to show its; value. IRBuilder knows where to i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:6359,variab,variables,6359,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variables']
Modifiability,"Phone Projects; Conceptually Xcode projects for iPhone applications are nearly the same as; their cousins for desktop applications. scan-build can analyze these; projects as well, but users often encounter problems with just building their; iPhone projects from the command line because there are a few extra preparative; steps they need to take (e.g., setup code signing).; Recommendation: use ""Build and Analyze""; The absolute easiest way to analyze iPhone projects is to use the; Analyze; feature in Xcode (which is based on the Clang Static Analyzer). There a; user can analyze their project right from a menu without most of the setup; described later.; Instructions are available on this; website on how to use open source builds of the analyzer as a replacement for; the one bundled with Xcode.; Using scan-build directly; If you wish to use scan-build with your iPhone project, keep the; following things in mind:. Analyze your project in the Debug configuration, either by setting; this as your configuration with Xcode or by passing -configuration; Debug to xcodebuild.; Analyze your project using the Simulator as your base SDK. It is; possible to analyze your code when targeting the device, but this is much; easier to do when using Xcode's Build and Analyze feature.; Check that your code signing SDK is set to the simulator SDK as well, and make sure this option is set to Don't Code Sign. Note that you can most of this without actually modifying your project. For; example, if your application targets iPhoneOS 2.2, you could run; scan-build in the following manner from the command line:. $ scan-build xcodebuild -configuration Debug -sdk iphonesimulator2.2. Alternatively, if your application targets iPhoneOS 3.0:. $ scan-build xcodebuild -configuration Debug -sdk iphonesimulator3.0. Gotcha: using the right compiler; Recall that scan-build analyzes your project by using a compiler to; compile the project and clang to analyze your project. The script uses; simple heuristics to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:8869,config,configuration,8869,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,3,['config'],['configuration']
Modifiability,"Principal` and; `CopyTree` methods to the entries in the list. In general, it affects; the `GetEntryNumber` method and all functions using it for looping over; the tree entries. The `GetEntry` and `GetEntries` methods are not; affected. Note, that in the `SetEventList` method, the **`TEventList`**; argument is internally transformed into a **`TEntryList`**, and this; operation, in case of a **`TChain`**, requires loading of all the tree; headers. In this example, we create a list with all entries with more; than 600 tracks and then set it so that the tree will use this list. To; reset the **`TTree`** to use all events use `SetEventList(0)` or; `SetEntryList(0)`. 1. Let's look at an example. First, open the file and draw the; `fNtrack`. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root"");; root[] TTree *T = (TTree*)f->Get(""T"");; root[] T->Draw(""fNtrack"");; ```. 2. Now, put the entries with over 600 tracks into a **`TEntryList`**; called `myList`. We get the list from the current directory and assign; it to a variable list. ``` {.cpp}; root[] T->Draw("">>myList"",""fNtrack > 600"",""entrylist"");; root[] TEntryList *list=(TEntryList*)gDirectory->Get(""myList"");; ```. 3. Instruct the tree **`T`** to use the new list and draw it again. Note; that this is exactly the same `Draw` command. The list limits the; entries. ``` {.cpp}; root[] T->SetEntryList(list);; root[] T->Draw(""fNtrack"");; ```. You should now see a canvas similar to this one. ![](pictures/03000105.png). #### Operations on TEntryLists. If you have entry lists that were created using different cuts, you can; combine the lists to get a new list, with entries passing at least one; of the cuts. Example:. ``` {.cpp}; root[] T->Draw("">>list1"",""fNtrack>600"",""entrylist"");; root[] TEntryList *list1 = (TEntryList*)gDirectory->Get(""list1"");; root[] T->Draw("">>list2"",""fNtrack<590"",""entrylist"");; root[] TEntryList *list2 = (TEntryList*)gDirectory->Get(""list2"");; root[] list1->Add(list2);; ```. `list1` now contains entries wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:111848,variab,variable,111848,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"Proof(10000,"""") ; // execute 10000 toys through PROOF-lite. gfs.summaryData()->Print() ;. Workspace and factory improvements. The workspace class RooWorkspace has been augmented with several; new features. The import() method now supports a new argument RenameAllVariablesExcept(const char* suffix, const char keepList) which; will rename all variables of the imported function by extended them with a supplied suffix,; except for a given list of variables, which are not renamed.; A new utility function importFromFile() has been added, which is similar to import, except that it take a string; specifier for the object to be imported rather than a reference. The string is expected to be of the form ; fileName:workspaceName:objectName and simplifies import of objects from other workspaces on file. The importFromFile; accepts all arguments accepted by the standard import() method.; Generic objects (inheriting from TObject) can now also be stored in the workspace under an alias name, rather; under their own name, which simplifies management of objects of types like TMatrixD that do not have a settable name. ws.import(matrix,""cov_matrix"") ;. New accessors have been added that return a RooArgSet of all elements of the workspace of a given type, e.g.; allVars(), allPdfs(). The Print() method now accepts option ""t"", which prints the contents tree-style instead of a flat list of components,; as illustrated below. *** Print() ***. p.d.f.s; -------; RooProdPdf::bkg[ ptBkgPdf * mllBkgPdf * effBkgPdf|pt ] = 0.267845; RooEfficiency::effBkgPdf[ cat=cut effFunc=effBkg ] = 0.76916; RooEfficiency::effSigPdf[ cat=cut effFunc=effSig ] = 0.899817; RooAddPdf::genmodel[ Nsig * sig + Nbkg * bkg ] = 0.502276; RooPolynomial::mllBkgPdf[ x=mll coefList=(mbkg_slope) ] = 0.775; RooGaussian::mllSigPdf[ x=mll mean=msig_mean sigma=msig_sigma ] = 1; RooExponential::ptBkgPdf[ x=pt c=pbkg_slope ] = 0.449329; RooExponential::ptSigPdf[ x=pt c=psig_slope ] = 0.818731; RooProdPdf::sig[ ptSigPdf * mllSigPdf * e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:2593,inherit,inheriting,2593,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['inherit'],['inheriting']
Modifiability,"Proxy` implementations classes. Several definition where moved from the global or ROOT namespace to the ROOT::Details namespace as they are intended to be used in 'expert' level code and have a lower level of backward compatibility requirement. This includes `TCollectionProxyInfo`, `TSchemaRuleSet`. ## Interpreter. ROOT can now dump the context of STL collections, for instance `map<string,int>`. A few ROOT types print their content, too. Fixed the handling of the current directory in `#include` of system headers, avoid problem with local files named `new` or `vector`. Fixed the issue with the ROOT special variable where the objects were read from the file at each and every access by caching those object. See [ROOT-7830] for example. This release contains several bug fixes and improvements, notably in unloading and performance. > NOTE: The GCC 5 ABI is *not* supported yet, due to a lack of support in clang. ## I/O Libraries. ### hadd. We extended the `hadd` options to allow more control on the compression settings use for the; output file. In particular the new option -fk allows for a copy of the input; files with no decompressions/recompression of the TTree baskets even if they; do not match the requested compression setting. New options:. - `-ff` allows to force the compression setting to match the one from the first input; - `-fk[0-209]` allows to keep all the basket compressed as is and to compress the meta data with the given compression setting or the compression setting of the first input file.; - `-a` option append to existing file; - The verbosity level is now optional after -v. ### Command line utilities. We added command line utilities to streamline very common operations performed on root files, like listing their content or creating directories.; The command line utilities are:; - `rootbrowse`: to open the file in a TBrowser; - `rootcp`: to copy content from one file to another; - `rooteventselector`: to select a subset of the events in a tree contained i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:6744,extend,extended,6744,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['extend'],['extended']
Modifiability,"Quad(Float_t a, Float_t b, Float_t c) {; fA = a;; fB = b;; fC = c;; }; Quad::~Quad() {; Cout <<""deleting object with coeffts: ""<< fA << "","" << fB << "",""; << fC << endl;; }; Float_t Quad::Evaluate(Float_t x) const {; return fA*x*x + fB*x + fC;; }; void Quad::Solve() const {; Float_t temp = fB*fB - 4.*fA*fC;; if ( temp > 0. ) {; temp = sqrt( temp );; cout << ""There are two roots: "" << ( -fB - temp ) / (2.*fA); << "" and "" << ( -fB + temp ) / (2.*fA) << endl;; } else {; if ( temp == 0. ) {; cout << ""There are two equal roots: "" << -fB / (2.*fA); << endl;; } else {; cout << ""There are no roots"" << endl;; }; }; }; ```. Let us first look how we create an object. When we create an object; by:. ``` {.cpp}; root[] Quad my_object(1.,2.,-3.);; ```. We are creating an object on the stack. A FORTRAN programmer may be; familiar with the idea; it is not unlike a local variable in a; function or subroutine. Although there are still a few old timers who; do not know it, FORTRAN is under no obligation to save local variables; once the function or subroutine returns unless the SAVE statement is; used. If not then it is likely that FORTRAN will place them on the; stack and they will ""pop off"" when the RETURN statement is reached. To; give an object more permanence it has to be placed on the heap. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. The second line declares a pointer to `Quad` called `my_objptr`. From; the syntax point of view, this is just like all the other declarations; we have seen so far, i.e. this is a stack variable. The value of the; pointer is set equal to. ``` {.cpp}; new Quad(1.,2.,-3.);; ```. `new`, despite its looks, is an operator and creates an object or; variable of the type that comes next, `Quad` in this case, on the; heap. Just as with stack objects it has to be initialized by calling; its constructor. The syntax requires that the argument list follows the; type. This one statement has brought two items into existence, one",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:9030,variab,variables,9030,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['variab'],['variables']
Modifiability,"QualType>pointsToMatcher<QualType> InnerMatcher; Matches if the matched type is a pointer type and the pointee type; matches the specified matcher. Example matches y->x(); (matcher = cxxMemberCallExpr(on(hasType(pointsTo; cxxRecordDecl(hasName(""Y""))))))); class Y { public: void x(); };; void z() { Y *y; y->x(); }. Matcher<QualType>referencesMatcher<Decl> InnerMatcher; Overloaded to match the referenced type's declaration. Matcher<QualType>referencesMatcher<QualType> InnerMatcher; Matches if the matched type is a reference type and the referenced; type matches the specified matcher. Example matches X &x and const X &y; (matcher = varDecl(hasType(references(cxxRecordDecl(hasName(""X"")))))); class X {; void a(X b) {; X &x = b;; const X &y = b;; }; };. Matcher<QualifiedTypeLoc>hasUnqualifiedLocMatcher<TypeLoc> InnerMatcher; Matches `QualifiedTypeLoc`s that have an unqualified `TypeLoc` matching; `InnerMatcher`. Given; int* const x;; const int y;; qualifiedTypeLoc(hasUnqualifiedLoc(pointerTypeLoc())); matches the `TypeLoc` of the variable declaration of `x`, but not `y`. Matcher<RecordType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:229230,variab,variable,229230,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"R LLVM_BUILD_TYPE MATCHES ""(Debug|RelWithDebInfo)""); set(LLVM_ENABLE_ASSERTIONS TRUE); else(); set(LLVM_ENABLE_ASSERTIONS FALSE); endif(); endif(). # Multi-configuration generators ignore CMAKE_BUILD_TYPE, so; # in that case we set the flags for all configurations to the; # flags of the build type assigned to LLVM_BUILD_TYPE. if(MSVC OR XCODE); string(TOUPPER ${LLVM_BUILD_TYPE} LLVM_BUILD_TYPE); set(LLVM_C_FLAGS ${CMAKE_C_FLAGS_${LLVM_BUILD_TYPE}}); set(LLVM_CXX_FLAGS ${CMAKE_CXX_FLAGS_${LLVM_BUILD_TYPE}}); # On Windows, use the same compiler flags than ROOT and not; # the other way around; if(NOT MSVC); foreach(CONFIG ${CMAKE_CONFIGURATION_TYPES}); string(TOUPPER ${CONFIG} CONFIG); set(CMAKE_C_FLAGS_${CONFIG} ${LLVM_C_FLAGS}); set(CMAKE_CXX_FLAGS_${CONFIG} ${LLVM_CXX_FLAGS}); endforeach(); endif(); elseif(NOT LLVM_BUILD_TYPE STREQUAL CMAKE_BUILD_TYPE); set(CMAKE_BUILD_TYPE ${LLVM_BUILD_TYPE}); endif(). set(BUILD_SHARED_LIBS FALSE). #---Remove the inherited include_directories(); set_directory_properties(PROPERTIES INCLUDE_DIRECTORIES """"). set(LLVM_ENABLE_PROJECTS ""clang"" CACHE STRING """"). #---Add the sub-directory excluding all the targets from all-----------------------------------------; if(CMAKE_GENERATOR MATCHES ""Xcode""); add_subdirectory(llvm-project/llvm); else(); add_subdirectory(llvm-project/llvm EXCLUDE_FROM_ALL); endif(). set(LLVM_INCLUDE_DIRS ${CMAKE_SOURCE_DIR}/interpreter/llvm-project/llvm/include; ${CMAKE_BINARY_DIR}/interpreter/llvm-project/llvm/include; CACHE STRING ""LLVM include directories.""; ); list(APPEND CMAKE_MODULE_PATH ""${CMAKE_CURRENT_SOURCE_DIR}/llvm-project/llvm/cmake/modules""); #---Set into parent scope LLVM_VERSION_MAJOR --------------------------------------------------------; get_directory_property(_llvm_version_major DIRECTORY llvm-project/llvm DEFINITION LLVM_VERSION_MAJOR); set(LLVM_VERSION_MAJOR ""${_llvm_version_major}"" PARENT_SCOPE); #---Forward LLVM_TARGET_TRIPLE for check-cling----------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:10851,inherit,inherited,10851,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['inherit'],['inherited']
Modifiability,"RAM and disk space and is; usually slower to run. You can improve RAM usage by using ``lld``, see; the :ref:`LLVM_USE_LINKER <llvm_use_linker>` option.; * Assertions are internal checks to help you find bugs. They typically slow; down LLVM and Clang when enabled, but can be useful during development.; You can manually set :ref:`LLVM_ENABLE_ASSERTIONS <llvm_enable_assertions>`; to override the default from `CMAKE_BUILD_TYPE`. If you are using an IDE such as Visual Studio or Xcode, you should use; the IDE settings to set the build type. **CMAKE_INSTALL_PREFIX**:PATH; Path where LLVM will be installed when the ""install"" target is built. **CMAKE_{C,CXX}_FLAGS**:STRING; Extra flags to use when compiling C and C++ source files respectively. **CMAKE_{C,CXX}_COMPILER**:STRING; Specify the C and C++ compilers to use. If you have multiple; compilers installed, CMake might not default to the one you wish to; use. .. _Frequently Used LLVM-related variables:. Frequently Used LLVM-related variables; --------------------------------------. The default configuration may not match your requirements. Here are; LLVM variables that are frequently used to control that. The full; description is in `LLVM-related variables`_ below. **LLVM_ENABLE_PROJECTS**:STRING; Control which projects are enabled. For example you may want to work on clang; or lldb by specifying ``-DLLVM_ENABLE_PROJECTS=""clang;lldb""``. **LLVM_ENABLE_RUNTIMES**:STRING; Control which runtimes are enabled. For example you may want to work on; libc++ or libc++abi by specifying ``-DLLVM_ENABLE_RUNTIMES=""libcxx;libcxxabi""``. **LLVM_LIBDIR_SUFFIX**:STRING; Extra suffix to append to the directory where libraries are to be; installed. On a 64-bit architecture, one could use ``-DLLVM_LIBDIR_SUFFIX=64``; to install libraries to ``/usr/lib64``. **LLVM_PARALLEL_{COMPILE,LINK}_JOBS**:STRING; Building the llvm toolchain can use a lot of resources, particularly; linking. These options, when you use the Ninja generator, allow you; to rest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:8778,variab,variables,8778,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"RAUW**. Replace All Uses With. The functions ``User::replaceUsesOfWith()``,; ``Value::replaceAllUsesWith()``, and; ``Constant::replaceUsesOfWithOnConstant()`` implement the replacement of one; Value with another by iterating over its def/use chain and fixing up all of; the pointers to point to the new value. See; also `def/use chains <ProgrammersManual.html#iterating-over-def-use-use-def-chains>`_. **Reassociation**; Rearranging associative expressions to promote better redundancy elimination; and other optimization. For example, changing ``(A+B-A)`` into ``(B+A-A)``,; permitting it to be optimized into ``(B+0)`` then ``(B)``. **RFC**; Request for Comment. An email sent to a project mailing list in order to; solicit feedback on a proposed change. .. _roots:; .. _stack roots:. **Root**; In garbage collection, a pointer variable lying outside of the `heap`_ from; which the collector begins its reachability analysis. In the context of code; generation, ""root"" almost always refers to a ""stack root"" --- a local or; temporary variable within an executing function. **RPO**; Reverse postorder. **RTTI**; Run-time Type Information. S; -. .. _safe point:. **Safe Point**; In garbage collection, it is necessary to identify `stack roots`_ so that; reachability analysis may proceed. It may be infeasible to provide this; information for every instruction, so instead the information is; calculated only at designated safe points. With a copying collector,; `derived pointers`_ must not be retained across safe points and `object; pointers`_ must be reloaded from stack roots. **SDISel**; Selection DAG Instruction Selection. **SCC**; Strongly Connected Component. **SCCP**; Sparse Conditional Constant Propagation. **SLP**; Superword-Level Parallelism, same as :ref:`Basic-Block Vectorization; <lexicon-bb-vectorization>`. **Splat**; Splat refers to a vector of identical scalar elements. The term is based on the PowerPC Altivec instructions that provided; this functionality in hardware. For e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:7398,variab,variable,7398,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,1,['variab'],['variable']
Modifiability,"RC; introduces. C++ programmers who have not already disabled exceptions are; much more likely to actual require exception-safety. ARC does end the lifetimes of ``__weak`` objects when an exception terminates; their scope unless exceptions are disabled in the compiler. .. admonition:: Rationale. The consequence of a local ``__weak`` object not being destroyed is very; likely to be corruption of the Objective-C runtime, so we want to be safer; here. Of course, potentially massive leaks are about as likely to take down; the process as this corruption is if the program does try to recover from; exceptions. .. _arc.misc.interior:. Interior pointers; -----------------. An Objective-C method returning a non-retainable pointer may be annotated with; the ``objc_returns_inner_pointer`` attribute to indicate that it returns a; handle to the internal data of an object, and that this reference will be; invalidated if the object is destroyed. When such a message is sent to an; object, the object's lifetime will be extended until at least the earliest of:. * the last use of the returned pointer, or any pointer derived from it, in the; calling function or; * the autorelease pool is restored to a previous state. .. admonition:: Rationale. Rationale: not all memory and resources are managed with reference counts; it; is common for objects to manage private resources in their own, private way.; Typically these resources are completely encapsulated within the object, but; some classes offer their users direct access for efficiency. If ARC is not; aware of methods that return such ""interior"" pointers, its optimizations can; cause the owning object to be reclaimed too soon. This attribute informs ARC; that it must tread lightly. The extension rules are somewhat intentionally vague. The autorelease pool; limit is there to permit a simple implementation to simply retain and; autorelease the receiver. The other limit permits some amount of; optimization. The phrase ""derived from"" is intende",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:99941,extend,extended,99941,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['extend'],['extended']
Modifiability,"REENAME"". Return value of the command is ignored: standard output is; considered, as explained here. Defaults to `/bin/false`. dsmgrd.cmdtimeoutsecs *secs*; : Timeout on staging command, expressed in seconds: after this; timeout, the command is considered failed and it is killed (in first; place with `SIGSTOP`, then if it is unresponsive with `SIGKILL`).; Defaults to **0 (no timeout)**. dsmgrd.corruptafterfails *n*; : Set this to a number above zero to tell the daemon to mark files as; corrupted after a certain number of either download or verification; failures. A value of **0 (default)** tells the daemon to retry; forever. Configuring the MonALISA monitoring plugin; ------------------------------------------. The Dataset Stager supports generic monitoring plugins. The only plugin; distributed with the stager is the MonALISA monitoring plugin. dsmgrd.notifyplugin */path/to/libafdsmgrd\_notify\_apmon.so*; : Set it to the path of the MonALISA plugin shared object. By default,; notification plugin is disabled. dsmgrd.apmonurl *apmon://apmon.cern.ch*; : This variable tells the ApMon notification plugin how to contact one; or more MonALISA server(s) to activate monitoring via ApMon. It; supports two kinds of URLs:. - `http[s]://host/path/configuration_file.conf` (a remote file; where to fetch the list of servers from). - `apmon://[:password@]monalisahost[:8884]` (a single server to; contact directly). If the variable is not set, yet the plugin is loaded, MonALISA; monitoring is inhibited until a valid configuration variable is; provided. dsmgrd.apmonprefix *MY::CLUSTER::PREFIX*; : Since MonALISA organizes information in ""clusters"" and ""hosts"", here; you can specify what to use as cluster prefix for monitoring; datasets information and daemon status. If this variable is not set,; MonALISA monitoring is inhibited. Please note that the suffix; `_datasets` or `_status` is appended for each of the two types of; monitoring. A sample configuration file; -----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md:5088,plugin,plugin,5088,proof/doc/confman/DatasetStager.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md,1,['plugin'],['plugin']
Modifiability,"RIER_HAAR`; - `TRANSFORM1_WALSH_HAAR`; - `TRANSFORM1_COS_WALSH`; - `TRANSFORM1_COS_HAAR`; - `TRANSFORM1_SIN_WALSH`; - `TRANSFORM1_SIN_HAAR`; - **`degree`**: applied only for mixed transforms; - **`xmin`**: low limit of filtered region; - **`xmax`**: high limit of filtered region; - **`filter_coeff`**: value which is set in filtered region. An example of the filtration using Cosine transform is given in the Figure 6.5.; It illustrates a part of the spectrum from Figure 6.1 and two spectra; after filtration preserving 2048 coefficients and 1536 coefficients. One; can observe a very good fidelity of the overall shape of both spectra with; the original data. However, some distortion can be observed in details of; the second spectrum after filtration preserving only 1536 coefficients.; The useful information in the transform domain can be compressed into; one half of the original space. ![Filtration using Cosine transform](figures/image204.png). In the transform domain one can also enhance (multiply with; the constant > 1) some regions. This way, one can change; peak-to-background ratio. This function has a form of. ```{.cpp}; char *Enhance1(const float *source,; float *dest,; int size,; int type,; int degree,; int xmin,; int xmax,; float enhance_coeff);; ```. This function transforms the source spectrum. The calling program; should fill in the input parameters. Then it multiplies transformed; coefficients in the given region (`xmin`, `xmax`) by the given; `enhance_coeff` and transforms it back. Processed data are written into; the dest spectrum. Function parameters:. - **`source`**: pointer to the vector of the source spectrum, its length should be equal to `size`; - **`dest`**: pointer to the vector of the dest data, its length should be equal to `size`; - **`size`**: basic length of the source and dest spectra; - **`type`**: type of transform; - `TRANSFORM1_HAAR`; - `TRANSFORM1_WALSH`; - `TRANSFORM1_COS`; - `TRANSFORM1_SIN`; - `TRANSFORM1_FOURIER`; - `TRANSFORM1_HARTLE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:63407,enhance,enhance,63407,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['enhance'],['enhance']
Modifiability,"RING; The path to install auxiliary LLVM utilities, relative to the *CMAKE_INSTALL_PREFIX*.; Only matters if *LLVM_INSTALL_UTILS* is enabled.; Defaults to *LLVM_TOOLS_INSTALL_DIR*. **LLVM_EXAMPLES_INSTALL_DIR**:STRING; The path for examples of using LLVM, relative to the *CMAKE_INSTALL_PREFIX*.; Only matters if *LLVM_BUILD_EXAMPLES* is enabled.; Defaults to ""examples"". CMake Caches; ============. Recently LLVM and Clang have been adding some more complicated build system; features. Utilizing these new features often involves a complicated chain of; CMake variables passed on the command line. Clang provides a collection of CMake; cache scripts to make these features more approachable. CMake cache files are utilized using CMake's -C flag:. .. code-block:: console. $ cmake -C <path to cache file> <path to sources>. CMake cache scripts are processed in an isolated scope, only cached variables; remain set when the main configuration runs. CMake cached variables do not reset; variables that are already set unless the FORCE option is specified. A few notes about CMake Caches:. - Order of command line arguments is important. - -D arguments specified before -C are set before the cache is processed and; can be read inside the cache file; - -D arguments specified after -C are set after the cache is processed and; are unset inside the cache file. - All -D arguments will override cache file settings; - CMAKE_TOOLCHAIN_FILE is evaluated after both the cache file and the command; line arguments; - It is recommended that all -D options should be specified *before* -C. For more information about some of the advanced build configurations supported; via Cache files see :doc:`AdvancedBuilds`. Executing the Tests; ===================. Testing is performed when the *check-all* target is built. For instance, if you are; using Makefiles, execute this command in the root of your build directory:. .. code-block:: console. $ make check-all. On Visual Studio, you may run tests by building the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:39118,variab,variables,39118,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,2,['variab'],['variables']
Modifiability,"RN/SFT,\; Axel Naumann, CERN/SFT,\; Danilo Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Vassil Vassilev, Fermilab/CMS,\; Wouter Verkerke, NIKHEF/Atlas, RooFit. ## Removed interfaces. The following interfaces have been removed, after deprecation in v6.08. ### CINT remnants, dysfunctional for ROOT 6. - `TInterpreter`'s `Getgvp()`, `Getp2f2funcname(void*)`, `Setgvp(Long_t)`, `SetRTLD_NOW()`, `SetRTLD_LAZY()`.; - `SetFCN(void*)` from TVirtualFitter, TFitter, TBackCompFitter, TMinuit; - `TFoam::SetRhoInt(void*)`. ### Core. - The enum constant `TRef::kNotComputed`, `TLink::kObjIsParent` were never used and have been removed.; - The enum constant `TClonesArray::kNoSplit` has not been used since v2.26 and has been removed. ## Interpreter. - Automatic declaration of variables (`h = new TH1F(...)`) is *only* available at the prompt. The side-effects of relying on this in source files is simply too grave. Due to a bug (ROOT-8538), automatically declared variables must currently reside on the top-most scope, i.e. not inside an `if` block etc.; - Improved the stack frame information generated by the JIT. By avoiding interleaving of the memory associated to multiple JIT module, the generation of stack trace involving jitted code and the catching of exception going through jitted code has been repaired.; - Interpreted code is now optimized; `.O 0/1/2/3` can be used to change the optimization level, as well as `#pragma cling optimize`.; - The prompt colors are now much more visible, both on terminals with light and dark background.; - Significant speedup of `TMethodCall`.; - One can now run `.x 12file-with@funny=name.C`; it will expect a function called `_12file_with_funny_name()`. ## Core Libraries. - See ""Build, Configuration and Testing Infrastructure"" below for changes in the directory structure.; - libCling now exports only a minimal set of symbols.; - Add support for std::array_view also for C++11 builds. The implementation has been modi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:1529,variab,variables,1529,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['variab'],['variables']
Modifiability,"RNTuple Code Architecture; =========================. > This document is meant for ROOT developers. It provides background information on the RNTuple code design and behavior. > The RNTuple code uses the nomenclature from the [RNTuple format specification](https://github.com/root-project/root/blob/master/tree/ntuple/v7/doc/BinaryFormatSpecification.md) (e.g. ""field"", ""column"", ""anchor"", etc.). General Principles; ------------------. The RNTuple classes provide the functionality to read, write, and describe RNTuple datasets.; The core classes, such as `RNTupleReader` and `RNTupleWriter`, are part of the RNTuple library.; Additional tools, such as the `RNTupleImporter` and the `RNTupleInspector`, are part of the RNTupleUtils library,; which depends on the RNTuple library. The RNTuple classes are organized in layers:; the storage layer, the primitives layer, the logical layer and the event iteration layer.; Most classes in the storage layer and the primitives layer are in the `ROOT::Internal` namespace (non-public interfaces),; with the notable exception of the descriptor classes (`RNTupleDescriptor`, `RFieldDescriptor`, etc.).; Most classes in the upper layers provide public interfaces. | Layer | Description | Example of classes |; |------------|---------------------------------------------------------------------|-------------------------------------------------------------|; | Storage | Read and write pages (physical: file, object store; virtual: e.g. buffered) | RPage{Source,Sink}, RNTupleDescriptor, RClusterPool |; | Primitives | Storage-backed columns of simple types | RColumn, RColumnElement, RPage |; | Logical | Mapping of C++ types onto columns | RField, RNTupleModel, REntry |; | Iteration | Reading and writing events / properties | RNTuple{Reader,Writer}, RNTupleView, RNTupleDS (RDataFrame) |; | Tooling | Higher-level, RNTuple related utility classes | RNTupleMerger, RNTupleImporter, RNTupleInspector |. The RNTuple classes are, unless explicitly stated otherwi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:818,layers,layers,818,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['layers'],['layers']
Modifiability,"ROOTQL; ======. This is a Quick Look plugin that allows quick inspection of the content; of ROOT files. Quick Look is available on MacOS X since version 10.5 (Leopard). To use QL; select a file icon in the Finder and hit the space bar. For all file types; supported by QL you will get a window showing the file content, for file types; not supported you will get a generic window showing some basic file info. The idea of QL is that file content can be shown without the heavy application; startup process. Generating a QL view of a ROOT file depends on the size of the; file and number of keys, but generally it is a quick operation. Get the binary for the ROOTQL plugin from:. ftp://root.cern/root/ROOTQL.tgz. To install the plugin, after untarring the above file, just drag the; ROOTQL.qlgenerator icon to either /Library/QuickLook or to ~/Library/QuickLook.; You may have to create that folder if it does not exist. Once installed; you may have to refresh the QL plugin cache by executing:; /usr/bin/qlmanage -r. To build from source, get it from git using:. git clone http://root.cern/git/root.git root; cd root/misc/rootql. Open the ROOTQL project in Xcode and click on ""Build"" (make sure the Active; Build Configuration is set to ""Release""). A command line short cut to open; the Xcode project is to type ""open ROOTQL.xcodeproj"" in the Terminal app.; Move the resulting plugin from the build/Release directory to either; the /Library/QuickLook or ~/Library/QuickLook directory. Cheers, Fons.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/ReadMe.txt:37,plugin,plugin,37,misc/rootql/ReadMe.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/ReadMe.txt,5,['plugin'],['plugin']
Modifiability,"ROOTSL; ======. This is a Spotlight plugin that allows ROOT files to be indexed by SL.; Once indexed SL can find ROOT files based on the names and titles of the; objects in the files. Spotlight is available on MacOS X since version 10.4 (Tiger). To use SL; select the SL icon on the top right of the menubar and type in a search string. Get the binary for the ROOTSL plugin from:. ftp://root.cern/root/ROOTSL.tgz. To install the plugin, after untarring the above file, just double click the; ROOTSL.mdimporter icon. If you have no admin rights you will be asked for; the admin password. The plugin will be installed in /Library/Spotlight.; You can also install the plugin in your private area by dragging the; plugin to ~/Library/Spotlight. You may have to create that folder if; it does not exist. Once installed you have to tell SL to import existing; files by executing:; /usr/bin/mdimport -r [~]/Library/Spotlight/ROOTSL.mdimporter; Spotlight will then, in the background, index all *.root files. To build from source, get it from svn using:. git clone http://root.cern/git/root.git root; cd root/misc/rootsl. Open the ROOTSL project in Xcode and click on ""Build"" (make sure the Active; Build Configuration is set to ""Release""). A command line short cut to open; the Xcode project is to type ""open ROOTSL.xcodeproj"" in the Terminal app.; Copy the resulting plugin from build/Release to the /Library/Spotlight; directory by double clicking the icon, or by typing in the shell; ""open ROOTSL.mdimporter"". Cheers, Fons.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootsl/ReadMe.txt:36,plugin,plugin,36,misc/rootsl/ReadMe.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootsl/ReadMe.txt,7,['plugin'],['plugin']
Modifiability,"RS). set(LLVM_CONFIG_LIBRARY_DIR ""${LLVM_LIBRARY_DIR}""); set(LLVM_CONFIG_LIBRARY_DIRS; ""${LLVM_CONFIG_LIBRARY_DIR}""; # FIXME: Should there be other entries here?; ); list(REMOVE_DUPLICATES LLVM_CONFIG_LIBRARY_DIRS). set(LLVM_CONFIG_BINARY_DIR ""${LLVM_BINARY_DIR}""); set(LLVM_CONFIG_CMAKE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}""); set(LLVM_CONFIG_TOOLS_BINARY_DIR ""${LLVM_TOOLS_BINARY_DIR}""). # Generate a default location for lit; if (LLVM_BUILD_UTILS); if (CMAKE_HOST_WIN32 AND NOT CYGWIN); set(LLVM_CONFIG_DEFAULT_EXTERNAL_LIT ""${LLVM_CONFIG_TOOLS_BINARY_DIR}/llvm-lit.py""); else(); set(LLVM_CONFIG_DEFAULT_EXTERNAL_LIT ""${LLVM_CONFIG_TOOLS_BINARY_DIR}/llvm-lit""); endif(); endif(). if (LLVM_LINK_LLVM_DYLIB); set(LLVM_CONFIG_LINK_LLVM_DYLIB; ""set(LLVM_LINK_LLVM_DYLIB ${LLVM_LINK_LLVM_DYLIB})""); endif(). # We need to use the full path to the LLVM Exports file to make sure we get the; # one from the build tree. This is due to our cmake files being split between; # this source dir and the binary dir in the build tree configuration and the; # LLVM_CONFIG_CMAKE_DIR being the source directory. In contrast in the install; # tree, both the generated LLVMExports.cmake file and the rest of the cmake; # source files are put in the same cmake directory.; set(LLVM_CONFIG_EXPORTS ""${LLVM_EXPORTS};${LLVM_EXPORTS_BUILDTREE_ONLY}""); set(LLVM_CONFIG_INCLUDE_EXPORTS ""include(\""${LLVM_EXPORTS_FILE}\"")""); set(llvm_config_include_buildtree_only_exports; ""include(\""${LLVM_BUILDTREEONLY_EXPORTS_FILE}\"")""); configure_file(; LLVMConfig.cmake.in; ${llvm_cmake_builddir}/LLVMConfig.cmake; @ONLY); set(llvm_config_include_buildtree_only_exports). # For compatibility with projects that include(LLVMConfig); # via CMAKE_MODULE_PATH, place API modules next to it.; # Copy without source permissions because the source could be read-only,; # but we need to write into the copied folder.; # This should be removed in the future.; file(COPY .; DESTINATION ${llvm_cmake_builddir}; NO_SOURCE_PERMISSIONS; FILES_MATCHING PAT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/cmake/modules/CMakeLists.txt:3476,config,configuration,3476,interpreter/llvm-project/llvm/cmake/modules/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/cmake/modules/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"RUN lines. After it finishes you can use :code:`find . -name clang.profdata` to find it, but it; should be at a path something like:. .. code-block:: console. <build dir>/tools/clang/stage2-instrumented-bins/utils/perf-training/clang.profdata. You can feed that file into the LLVM_PROFDATA_FILE option when you build your; optimized compiler. It may be necessary to build additional targets before running perf training, such as; builtins and runtime libraries. You can use the :code:`CLANG_PGO_TRAINING_DEPS` CMake; variable for that purpose:. .. code-block:: cmake. set(CLANG_PGO_TRAINING_DEPS builtins runtimes CACHE STRING """"). The PGO cache has a slightly different stage naming scheme than other; multi-stage builds. It generates three stages: stage1, stage2-instrumented, and; stage2. Both of the stage2 builds are built using the stage1 compiler. The PGO cache generates the following additional targets:. **stage2-instrumented**; Builds a stage1 compiler, runtime, and required tools (llvm-config,; llvm-profdata) then uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:8986,config,config,8986,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['config']
Modifiability,"RawStringFormats``) :versionbadge:`clang-format 6` :ref:`¶ <RawStringFormats>`; Defines hints for detecting supported languages code blocks in raw; strings. A raw string with a matching delimiter or a matching enclosing function; name will be reformatted assuming the specified language based on the; style for that language defined in the .clang-format file. If no style has; been defined in the .clang-format file for the specific language, a; predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not; found, the formatting is based on llvm style. A matching delimiter takes; precedence over a matching enclosing function name for determining the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :ve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:99389,config,configure,99389,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configure']
Modifiability,"ReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83922,config,configuration,83922,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"RefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the left-hand side is a reference to a; variable, and that the right-hand side has integer type. .. code-block:: c++. hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(declRefExpr(to(varDecl(hasType(isInteger()))))),; hasRHS(expr(hasType(isInteger()))))). Why? Because it doesn't work. Of the three loops provided in; ``test-files/simple.cpp``, zero of them",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:13069,variab,variable,13069,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,2,['variab'],['variable']
Modifiability,"Reference; =========. LLVM and API reference documentation. .. contents::; :local:. .. toctree::; :hidden:. Atomics; BitCodeFormat; BlockFrequencyTerminology; BranchWeightMetadata; Bugpoint; CommandGuide/index; ConvergenceAndUniformity; ConvergentOperations; Coroutines; DependenceGraphs/index; ExceptionHandling; Extensions; FaultMaps; FuzzingLLVM; GarbageCollection; GetElementPtr; GlobalISel/index; GwpAsan; HowToSetUpLLVMStyleRTTI; HowToUseAttributes; InAlloca; LangRef; LibFuzzer; MarkedUpDisassembly; MIRLangRef; OptBisect; PCSectionsMetadata; PDB/index; PointerAuth; ScudoHardenedAllocator; MemTagSanitizer; Security; SecurityTransparencyReports; SegmentedStacks; StackMaps; SpeculativeLoadHardening; Statepoints; SymbolizerMarkupFormat; SystemLibrary; TestingGuide; TransformMetadata; TypeMetadata; XRay; XRayExample; XRayFDRFormat; YamlIO. API Reference; -------------. `Doxygen generated documentation <https://llvm.org/doxygen/>`_; (`classes <https://llvm.org/doxygen/inherits.html>`_). :doc:`HowToUseAttributes`; Answers some questions about the new Attributes infrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:979,inherit,inherits,979,interpreter/llvm-project/llvm/docs/Reference.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst,1,['inherit'],['inherits']
Modifiability,"RooFit likelihoods.; Likelihood minimization is now up to 10x faster on a single CPU core. If you experience unexpected problems related to the likelihood evaluation, you; can revert back to the old backend by passing `RooFit::EvalBackend(""legacy"")`; to `RooAbsPdf::fitTo()` or `RooAbsPdf::createNLL()`. In case you observe any slowdowns with the new likelihood evaluation, please; open a GitHub issue about this, as such a performance regression is considered; a bug. ### Asymptotically correct uncertainties for extended unbinned likelihood fits. Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights.; This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the `RooFit::AsymptoticError()` command argument in [RooAbsPdf::fitTo()](https://root.cern.ch/doc/master/classRooAbsPdf.html#ab0721374836c343a710f5ff92a326ff5).; See also this [writeup on extended weighted fits](https://root.cern/files/extended_weighted_fits.pdf) that is also linked from the reference guide.; The [pull request](https://github.com/root-project/root/pull/14751) that introduced this feature might also be a good reference. ### Compile your code with memory safe interfaces. If you define the `ROOFIT_MEMORY_SAFE_INTERFACES` preprocessor macro, the; RooFit interface changes in a way such that memory leaks are avoided. The most prominent effect of this change is that many functions that used to; return an owning pointer (e.g., a pointer to an object that you need to; manually `delete`) are then returning a `std::unique_pt` for automatic memory; management. For example this code would not compile anymore, because there is the risk that; the caller forgets to `delete params`:; ```c++; RooArgSet * params = pdf.getParameters(nullptr);; ```; If you wrap such return values in a `std::unique_ptr`, then your code will; compile both with and without memory safe interfaces:; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:8125,extend,extended,8125,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['extend'],['extended']
Modifiability,"Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved identifiers to ensuring that code adheres to lifecycle; protocols for certain LibreOffice-specific classes. They may serve as; examples for writing RecursiveASTVisitor-based plugins.""; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:3596,plugin,plugin,3596,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,4,"['plugin', 'refactor']","['plugin', 'plugins', 'refactoring']"
Modifiability,"S bits is retrieved from the location storage LS specified by; one of the single location descriptions SL of L. *If L, or the location description of any composite location description; part that is a subcomponent of L, has more than one single location; description, then any one of them can be selected as they are required to; all have the same value. For any single location description SL, bits are; retrieved from the associated storage location starting at the bit offset; specified by SL. For a composite location description, the retrieved bits; are the concatenation of the N bits from each composite location part PL,; where N is limited to the size of PL.*. V is pushed on the stack with the type T. .. note::. This definition makes it an evaluation error if L is a register location; description that has less than TS bits remaining in the register storage.; Particularly since these extensions extend location descriptions to have; a bit offset, it would be odd to define this as performing sign extension; based on the type, or be target architecture dependent, as the number of; remaining bits could be any number. This matches the GDB implementation; for ``DW_OP_deref_type``. These extensions define ``DW_OP_*breg*`` in terms of; ``DW_OP_regval_type``. ``DW_OP_regval_type`` is defined in terms of; ``DW_OP_regx``, which uses a 0 bit offset, and ``DW_OP_deref_type``.; Therefore, it requires the register size to be greater or equal to the; address size of the address space. This matches the GDB implementation for; ``DW_OP_*breg*``. The DWARF is ill-formed if D is not in the current compilation unit, D is; not a ``DW_TAG_base_type`` debugging information entry, or if TS divided by; 8 (the byte size) and rounded up to a whole number is not equal to S. .. note::. This definition allows the base type to be a bit size since there seems no; reason to restrict it. It is an evaluation error if any bit of the value is retrieved from the; undefined location storage or the offset o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:91752,extend,extend,91752,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extend']
Modifiability,"S); set(builtins_dep_name ""${builtins_dep}-${name}""); else(); set(builtins_dep_name ${builtins_dep}); endif(); endif(). check_apple_target(${name} runtime). runtime_register_target(${name}; DEPENDS ${builtins_dep_name} ${hdrgen_deps}; CMAKE_ARGS -DLLVM_DEFAULT_TARGET_TRIPLE=${name} ${libc_cmake_args}; EXTRA_ARGS TARGET_TRIPLE ${name}); endforeach(). foreach(multilib ${LLVM_RUNTIME_MULTILIBS}); foreach(name ${LLVM_RUNTIME_MULTILIB_${multilib}_TARGETS}); runtime_register_target(${name}+${multilib}; DEPENDS runtimes-${name}; CMAKE_ARGS -DLLVM_DEFAULT_TARGET_TRIPLE=${name}; -DLLVM_RUNTIMES_PREFIX=${name}/; -DLLVM_RUNTIMES_LIBDIR_SUBDIR=${multilib}; BASE_NAME ${name}; EXTRA_ARGS TARGET_TRIPLE ${name}); endforeach(); endforeach(); endif(). if(NOT LLVM_BUILD_INSTRUMENTED AND CLANG_ENABLE_BOOTSTRAP); # TODO: This is a hack needed because the libcxx headers are copied into the; # build directory during configuration. Without that step the clang in the; # build directory cannot find the C++ headers in certain configurations.; # I need to build a mechanism for runtime projects to provide CMake code; # that executes at LLVM configuration time to handle this case.; add_dependencies(clang-bootstrap-deps runtimes-configure); # We need to add the runtimes as a dependency because compiler-rt can be; # built as part of runtimes and we need the profile runtime for PGO; add_dependencies(clang-bootstrap-deps runtimes); endif(). if(LLVM_INCLUDE_TESTS); set_property(GLOBAL APPEND PROPERTY LLVM_ALL_ADDITIONAL_TEST_DEPENDS runtimes-test-depends). set(RUNTIMES_TEST_DEPENDS; FileCheck; count; llvm-cov; llvm-lto; llvm-nm; llvm-objdump; llvm-profdata; llvm-size; llvm-xray; not; obj2yaml; opt; sancov; sanstats; llvm_gtest_main; llvm_gtest; split-file; ); foreach(target ${test_targets} ${SUB_CHECK_TARGETS}); add_dependencies(${target} ${RUNTIMES_TEST_DEPENDS}); endforeach(). set_property(GLOBAL APPEND PROPERTY LLVM_ALL_ADDITIONAL_TEST_TARGETS runtimes ${RUNTIMES_TEST_DEPENDS}); endif(); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:18574,config,configuration,18574,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,2,['config'],"['configuration', 'configure']"
Modifiability,"SANITIZER=Address -DLLVM_USE_SANITIZE_COVERAGE=On``. .. note:: If you have ``compiler-rt`` checked out in an LLVM tree when building; with sanitizers, you'll want to specify ``-DLLVM_BUILD_RUNTIME=Off``; to avoid building the sanitizers themselves with sanitizers enabled. .. note:: You may run into issues if you build with BFD ld, which is the; default linker on many unix systems. These issues are being tracked; in https://llvm.org/PR34636. Continuously Running and Finding Bugs; -------------------------------------. There used to be a public buildbot running LLVM fuzzers continuously, and while; this did find issues, it didn't have a very good way to report problems in an; actionable way. Because of this, we're moving towards using `OSS Fuzz`_ more; instead. You can browse the `LLVM project issue list`_ for the bugs found by; `LLVM on OSS Fuzz`_. These are also mailed to the `llvm-bugs mailing; list`_. .. _OSS Fuzz: https://github.com/google/oss-fuzz; .. _LLVM project issue list:; https://bugs.chromium.org/p/oss-fuzz/issues/list?q=Proj-llvm; .. _LLVM on OSS Fuzz:; https://github.com/google/oss-fuzz/blob/master/projects/llvm; .. _llvm-bugs mailing list:; http://lists.llvm.org/cgi-bin/mailman/listinfo/llvm-bugs. Utilities for Writing Fuzzers; =============================. There are some utilities available for writing fuzzers in LLVM. Some helpers for handling the command line interface are available in; ``include/llvm/FuzzMutate/FuzzerCLI.h``, including functions to parse command; line options in a consistent way and to implement standalone main functions so; your fuzzer can be built and tested when not built against libFuzzer. There is also some handling of the CMake config for fuzzers, where you should; use the ``add_llvm_fuzzer`` to set up fuzzer targets. This function works; similarly to functions such as ``add_llvm_tool``, but they take care of linking; to LibFuzzer when appropriate and can be passed the ``DUMMY_MAIN`` argument to; enable standalone testing.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:10037,config,config,10037,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['config'],['config']
Modifiability,"SD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7161,variab,variables,7161,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['variab'],['variables']
Modifiability,"SRC_DIR}); set(LLVM_OBJ_ROOT ${LLVM_BINARY_DIR}); set(LLVM_CPPFLAGS ""${LLVM_DEFINITIONS}""); set(LLVM_CFLAGS ""${LLVM_C_STD_FLAG} ${LLVM_DEFINITIONS}""); # The language standard potentially affects the ABI/API of LLVM, so we want; # to make sure it is reported by llvm-config.; set(LLVM_CXXFLAGS ""${CMAKE_CXX${CMAKE_CXX_STANDARD}_STANDARD_COMPILE_OPTION} ${LLVM_CXX_STDLIB_FLAG} ${COMPILE_FLAGS} ${LLVM_DEFINITIONS}""); set(LLVM_BUILD_SYSTEM cmake); set(LLVM_HAS_RTTI ${LLVM_CONFIG_HAS_RTTI}); set(LLVM_DYLIB_VERSION ""${LLVM_VERSION_MAJOR}${LLVM_VERSION_SUFFIX}""). # Use the C++ link flags, since they should be a superset of C link flags.; set(LLVM_LDFLAGS ""${CMAKE_CXX_LINK_FLAGS}""); set(LLVM_BUILDMODE ${CMAKE_BUILD_TYPE}); set(LLVM_SYSTEM_LIBS ${SYSTEM_LIBS}); string(REPLACE "";"" "" "" LLVM_TARGETS_BUILT ""${LLVM_TARGETS_TO_BUILD}""); llvm_canonicalize_cmake_booleans(; LLVM_BUILD_LLVM_DYLIB; LLVM_LINK_LLVM_DYLIB; LLVM_HAS_RTTI; BUILD_SHARED_LIBS); llvm_expand_pseudo_components(LLVM_DYLIB_COMPONENTS_expanded ""${LLVM_DYLIB_COMPONENTS}""); configure_file(${BUILDVARIABLES_SRCPATH} ${BUILDVARIABLES_OBJPATH} @ONLY). # Set build-time environment(s).; add_compile_definitions(CMAKE_CFG_INTDIR=""$<CONFIG>""). if(LLVM_ENABLE_MODULES); target_compile_options(llvm-config PUBLIC; ""-fmodules-ignore-macro=CMAKE_CFG_INTDIR""; ); endif(). # Add the dependency on the generation step.; add_file_dependencies(${CMAKE_CURRENT_SOURCE_DIR}/llvm-config.cpp ${BUILDVARIABLES_OBJPATH}). if(CMAKE_CROSSCOMPILING); if (LLVM_NATIVE_TOOL_DIR AND NOT LLVM_CONFIG_PATH); if (EXISTS ""${LLVM_NATIVE_TOOL_DIR}/llvm-config${LLVM_HOST_EXECUTABLE_SUFFIX}""); set(LLVM_CONFIG_PATH ""${LLVM_NATIVE_TOOL_DIR}/llvm-config${LLVM_HOST_EXECUTABLE_SUFFIX}""); endif(); endif(). if (NOT LLVM_CONFIG_PATH); build_native_tool(llvm-config LLVM_CONFIG_PATH); set(LLVM_CONFIG_PATH ""${LLVM_CONFIG_PATH}"" CACHE STRING """"). add_custom_target(NativeLLVMConfig DEPENDS ${LLVM_CONFIG_PATH}); add_dependencies(llvm-config NativeLLVMConfig); endif(); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt:3296,config,config,3296,interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt,6,['config'],['config']
Modifiability,"SUMMARY; -------. We met to discuss the LLVM instruction format and bytecode representation:. ISSUES RESOLVED; ---------------. 1. We decided that we shall use a flat namespace to represent our ; variables in SSA form, as opposed to having a two dimensional namespace; of the original variable and the SSA instance subscript. ARGUMENT AGAINST:; * A two dimensional namespace would be valuable when doing alias ; analysis because the extra information can help limit the scope of; analysis. ARGUMENT FOR:; * Including this information would require that all users of the LLVM; bytecode would have to parse and handle it. This would slow down the; common case and inflate the instruction representation with another; infinite variable space. REASONING:; * It was decided that because original variable sources could be; reconstructed from SSA form in linear time, that it would be an; unjustified expense for the common case to include the extra; information for one optimization. Alias analysis itself is typically; greater than linear in asymptotic complexity, so this extra analaysis; would not affect the runtime of the optimization in a significant; way. Additionally, this would be an unlikely optimization to do at; runtime. IDEAS TO CONSIDER; -----------------. 1. Including dominator information in the LLVM bytecode; representation. This is one example of an analysis result that may be; packaged with the bytecodes themselves. As a conceptual implementation ; idea, we could include an immediate dominator number for each basic block; in the LLVM bytecode program. Basic blocks could be numbered according; to the order of occurrence in the bytecode representation. 2. Including loop header and body information. This would facilitate; detection of intervals and natural loops. UNRESOLVED ISSUES ; ----------------- . 1. Will oSUIF provide enough of an infrastructure to support the research; that we will be doing? We know that it has less than stellar; performance, but hope that this will ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-12-06-MeetingSummary.txt:196,variab,variables,196,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-12-06-MeetingSummary.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-12-06-MeetingSummary.txt,4,['variab'],"['variable', 'variables']"
Modifiability,"SVC_RUNTIME_LIBRARY=MultiThreaded. **LLVM_INSTALL_DOXYGEN_HTML_DIR**:STRING; The path to install Doxygen-generated HTML documentation to. This path can; either be absolute or relative to the *CMAKE_INSTALL_PREFIX*. Defaults to; ``${CMAKE_INSTALL_DOCDIR}/llvm/doxygen-html``. **LLVM_LINK_LLVM_DYLIB**:BOOL; If enabled, tools will be linked with the libLLVM shared library. Defaults; to OFF. Setting LLVM_LINK_LLVM_DYLIB to ON also sets LLVM_BUILD_LLVM_DYLIB; to ON.; This option is not available on Windows. **LLVM_LIT_ARGS**:STRING; Arguments given to lit. ``make check`` and ``make clang-test`` are affected.; By default, ``'-sv --no-progress-bar'`` on Visual C++ and Xcode, ``'-sv'`` on; others. **LLVM_LIT_TOOLS_DIR**:PATH; The path to GnuWin32 tools for tests. Valid on Windows host. Defaults to; the empty string, in which case lit will look for tools needed for tests; (e.g. ``grep``, ``sort``, etc.) in your %PATH%. If GnuWin32 is not in your; %PATH%, then you can set this variable to the GnuWin32 directory so that; lit can find tools needed for tests in that directory. **LLVM_NATIVE_TOOL_DIR**:STRING; Full path to a directory containing executables for the build host; (containing binaries such as ``llvm-tblgen`` and ``clang-tblgen``). This is; intended for cross-compiling: if the user sets this variable and the; directory contains executables with the expected names, no separate; native versions of those executables will be built. **LLVM_NO_INSTALL_NAME_DIR_FOR_BUILD_TREE**:BOOL; Defaults to ``OFF``. If set to ``ON``, CMake's default logic for library IDs; on Darwin in the build tree will be used. Otherwise the install-time library; IDs will be used in the build tree as well. Mainly useful when other CMake; library ID control variables (e.g., ``CMAKE_INSTALL_NAME_DIR``) are being; set to non-standard values. **LLVM_OPTIMIZED_TABLEGEN**:BOOL; If enabled and building a debug or asserts build the CMake build system will; generate a Release build tree to build a fully optimize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:31221,variab,variable,31221,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"S_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old));. * ``BBIAS_Always`` (in configuration: ``Always``); Always break before inline ASM colon. .. code-block:: c++. asm volatile(""string"",; :; : val);. .. _BreakBeforeTernaryOperators:. **BreakBeforeTernaryOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeTernaryOperators>`; If ``true``, ternary operators will be placed after line breaks. .. code-block:: c++. true:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription; ? firstValue; : SecondValueVeryVeryVeryVeryLong;. false:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?; firstValue :; SecondValueVeryVeryVeryVeryLong;. .. _BreakConstructorInitializers:. **BreakConstructorInitializers** (``BreakConstructorInitializersStyle``) :versionbadge:`clang-format 5` :ref:`¶ <Bre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:53185,config,configuration,53185,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"S`. Collect internal LLVM statistics. Appends `-save-stats=obj` when invoking the; compiler and makes the lit runner collect and merge the statistic files. - `TEST_SUITE_RUN_BENCHMARKS`. If this is set to `OFF` then lit will not actually run the tests but just; collect build statistics like compile time and code size. - `TEST_SUITE_USE_PERF`. Use the `perf` tool for time measurement instead of the `timeit` tool that; comes with the test-suite. The `perf` is usually available on linux systems. - `TEST_SUITE_SPEC2000_ROOT`, `TEST_SUITE_SPEC2006_ROOT`, `TEST_SUITE_SPEC2017_ROOT`, ... Specify installation directories of external benchmark suites. You can find; more information about expected versions or usage in the README files in the; `External` directory (such as `External/SPEC/README`). ### Common CMake Flags. - `-GNinja`. Generate build files for the ninja build tool. - `-Ctest-suite/cmake/caches/<cachefile.cmake>`. Use a CMake cache. The test-suite comes with several CMake caches which; predefine common or tricky build configurations. Displaying and Analyzing Results; --------------------------------. The `compare.py` script displays and compares result files. A result file is; produced when invoking lit with the `-o filename.json` flag. Example usage:. - Basic Usage:. ```text; % test-suite/utils/compare.py baseline.json; Warning: 'test-suite :: External/SPEC/CINT2006/403.gcc/403.gcc.test' has No metrics!; Tests: 508; Metric: exec_time. Program baseline. INT2006/456.hmmer/456.hmmer 1222.90; INT2006/464.h264ref/464.h264ref 928.70; ...; baseline; count 506.000000; mean 20.563098; std 111.423325; min 0.003400; 25% 0.011200; 50% 0.339450; 75% 4.067200; max 1222.896800; ```. - Show compile_time or text segment size metrics:. ```bash; % test-suite/utils/compare.py -m compile_time baseline.json; % test-suite/utils/compare.py -m size.__text baseline.json; ```. - Compare two result files and filter short running tests:. ```bash; % test-suite/utils/compare.py --filter-short ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:7174,config,configurations,7174,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['config'],['configurations']
Modifiability,"Sel is a framework that provides a set of reusable passes and utilities; for instruction selection --- translation from LLVM IR to target-specific; Machine IR (MIR). GlobalISel is intended to be a replacement for SelectionDAG and FastISel, to; solve three major problems:. * **Performance** --- SelectionDAG introduces a dedicated intermediate; representation, which has a compile-time cost. GlobalISel directly operates on the post-isel representation used by the; rest of the code generator, MIR.; It does require extensions to that representation to support arbitrary; incoming IR: :ref:`gmir`. * **Granularity** --- SelectionDAG and FastISel operate on individual basic; blocks, losing some global optimization opportunities. GlobalISel operates on the whole function. * **Modularity** --- SelectionDAG and FastISel are radically different and share; very little code. GlobalISel is built in a way that enables code reuse. For instance, both the; optimized and fast selectors share the :ref:`pipeline`, and targets can; configure that pipeline to better suit their needs. Design and Implementation Reference; ===================================. More information on the design and implementation of GlobalISel can be found in; the following sections. .. toctree::; :maxdepth: 1. GMIR; GenericOpcode; MIRPatterns; Pipeline; Porting; Resources. More information on specific passes can be found in the following sections:. .. toctree::; :maxdepth: 1. IRTranslator; Legalizer; RegBankSelect; InstructionSelect; KnownBits. .. _progress:. Progress and Future Work; ========================. The initial goal is to replace FastISel on AArch64. The next step will be to; replace SelectionDAG as the optimized ISel. ``NOTE``:; While we iterate on GlobalISel, we strive to avoid affecting the performance of; SelectionDAG, FastISel, or the other MIR passes. For instance, the types of; :ref:`gmir-gvregs` are stored in a separate table in ``MachineRegisterInfo``,; that is destroyed after :ref:`instructions",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/index.rst:1339,config,configure,1339,interpreter/llvm-project/llvm/docs/GlobalISel/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/index.rst,1,['config'],['configure']
Modifiability,"SetInsertPoint(AfterBB);. With the code for the body of the loop complete, we just need to finish; up the control flow for it. This code remembers the end block (for the; phi node), then creates the block for the loop exit (""afterloop""). Based; on the value of the exit condition, it creates a conditional branch that; chooses between executing the loop again and exiting the loop. Any; future code is emitted in the ""afterloop"" block, so it sets the; insertion position to it. .. code-block:: c++. // Add a new entry to the PHI node for the backedge.; Variable->addIncoming(NextVar, LoopEndBB);. // Restore the unshadowed variable.; if (OldVal); NamedValues[VarName] = OldVal;; else; NamedValues.erase(VarName);. // for expr always returns 0.0.; return Constant::getNullValue(Type::getDoubleTy(*TheContext));; }. The final code handles various cleanups: now that we have the ""NextVar""; value, we can add the incoming value to the loop PHI node. After that,; we remove the loop variable from the symbol table, so that it isn't in; scope after the for loop. Finally, code generation of the for loop; always returns 0.0, so that is what we return from; ``ForExprAST::codegen()``. With this, we conclude the ""adding control flow to Kaleidoscope"" chapter; of the tutorial. In this chapter we added two control flow constructs,; and used them to motivate a couple of aspects of the LLVM IR that are; important for front-end implementors to know. In the next chapter of our; saga, we will get a bit crazier and add `user-defined; operators <LangImpl06.html>`_ to our poor innocent language. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; the if/then/else and for expressions. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter5/toy.c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:26119,variab,variable,26119,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability,"ShapeKind {; SK_Square,; + SK_SpecialSquare,; + SK_OtherSpecialSquare,; + SK_LastSquare,; SK_Circle; }; ...; // Square::classof(); - static bool classof(const Shape *S) {; - return S->getKind() == SK_Square;; - }; + static bool classof(const Shape *S) {; + return S->getKind() >= SK_Square &&; + S->getKind() <= SK_LastSquare;; + }. Then, adding new subclasses is easy:. .. code-block:: c++. enum ShapeKind {; SK_Square,; SK_SpecialSquare,; SK_OtherSpecialSquare,; + SK_SomewhatSpecialSquare,; SK_LastSquare,; SK_Circle; }. Notice that ``Square::classof`` does not need to be changed. .. _classof-contract:. The Contract of ``classof``; ---------------------------. To be more precise, let ``classof`` be inside a class ``C``. Then the; contract for ``classof`` is ""return ``true`` if the dynamic type of the; argument is-a ``C``"". As long as your implementation fulfills this; contract, you can tweak and optimize it as much as you want. For example, LLVM-style RTTI can work fine in the presence of; multiple-inheritance by defining an appropriate ``classof``.; An example of this in practice is; `Decl <https://clang.llvm.org/doxygen/classclang_1_1Decl.html>`_ vs.; `DeclContext <https://clang.llvm.org/doxygen/classclang_1_1DeclContext.html>`_; inside Clang.; The ``Decl`` hierarchy is done very similarly to the example setup; demonstrated in this tutorial.; The key part is how to then incorporate ``DeclContext``: all that is needed; is in ``bool DeclContext::classof(const Decl *)``, which asks the question; ""Given a ``Decl``, how can I determine if it is-a ``DeclContext``?"".; It answers this with a simple switch over the set of ``Decl`` ""kinds"", and; returning true for ones that are known to be ``DeclContext``'s. .. TODO::. Touch on some of the more advanced features, like ``isa_impl`` and; ``simplify_type``. However, those two need reference documentation in; the form of doxygen comments as well. We need the doxygen so that we can; say ""for full details, see https://llvm.org/doxyg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:11119,inherit,inheritance,11119,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['inherit'],['inheritance']
Modifiability,"Size()); // lays out frames; frame->MapSubwindows(); // maps subwindows; frame->HideFrame(hFrame2); // hides frame hFrame2; frame->MapWindow(); // maps main frame; ```. The state information about a child frame can be obtained from the; methods `GetState(TGframe *f)`, `IsArranged(TGFrame *f)`, and; `IsVisible(TGFrame *f)`. The method `Cleanup()` deletes all objects of the composite frame added; via `AddFrame()`. All **`TGFrameElement`** objects (frames and layout; hints) must be unique, i.e. cannot be shared. We already mentioned that **`TGMainFrame`** class defines top level; windows interacting with the system window manager. It handles; applications with a menu bar, toolbar, text entry fields and other; widgets surrounding a central area (e.g. a canvas widget). It lays out a; set of related widgets and provides the typical application main window; behavior. As you can see from the Figure above, it inherits from; **`TGCompositeFrame`** and is inherited by **`TGTransientFrame`** and; several ROOT interface classes: **`TViewerX3D`**,**` TRootBrowser`**,; **`TRootCanvas`**, **`TRootControlBar`**, **`TTreeViewer.`**. To fix the size of a top level window you have to use the method; `TGMainFrame::SetWMSize().` This call tells the Window Manager that it; should not resize the window. The option `kFixedSize` works only for; embedded frames like **`TGCompositeFrame`** and derived classes (in; combination with layout hints). The **`TGVerticalFrame`** and **`TGHorizontalFrame`** are composite; frames that lay out their child frames in vertical or horizontal way in; the same order as they were added and according to their hints; preferences. The **`TGTransientFrame`** class defines transient windows that; typically are used for dialogs. They extend and complete an interaction; within a limited context. Always transient frames are displayed from; another window or another dialog. They may appear because of a command; button being activated or a menu item being selected. They ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:31327,inherit,inherits,31327,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,['inherit'],"['inherited', 'inherits']"
Modifiability,"Spaces; --------------------------------------. AMDGPU needs to be able to describe addresses that are in different kinds of; memory. Optimized code may need to describe a variable that resides in pieces; that are in different kinds of storage which may include parts of registers,; memory that is in a mixture of memory kinds, implicit values, or be undefined. DWARF has the concept of segment addresses. However, the segment cannot be; specified within a DWARF expression, which is only able to specify the offset; portion of a segment address. The segment index is only provided by the entity; that specifies the DWARF expression. Therefore, the segment index is a property; that can only be put on complete objects, such as a variable. That makes it only; suitable for describing an entity (such as variable or subprogram code) that is; in a single kind of memory. AMDGPU uses multiple address spaces. For example, a variable may be allocated in; a register that is partially spilled to the call stack which is in the private; address space, and partially spilled to the local address space. DWARF mentions; address spaces, for example as an argument to the ``DW_OP_xderef*`` operations.; A new section that defines address spaces is added (see; :ref:`amdgpu-dwarf-address-spaces`). A new attribute ``DW_AT_LLVM_address_space`` is added to pointer and reference; types (see :ref:`amdgpu-dwarf-type-modifier-entries`). This allows the compiler; to specify which address space is being used to represent the pointer or; reference type. DWARF uses the concept of an address in many expression operations but does not; define how it relates to address spaces. For example,; ``DW_OP_push_object_address`` pushes the address of an object. Other contexts; implicitly push an address on the stack before evaluating an expression. For; example, the ``DW_AT_use_location`` attribute of the; ``DW_TAG_ptr_to_member_type``. The expression belongs to a source language type; which may apply to objects allocat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:17732,variab,variable,17732,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability,"String *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:18764,variab,variable,18764,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['variab'],['variable']
Modifiability,"Submit"" at the bottom of the; page. Updating your change; ~~~~~~~~~~~~~~~~~~~~. If you make changes in response to a reviewer's comments, simply update; your branch with more commits and push to your fork. It may be a good; idea to answer the comments from the reviewer explicitly. Accepting a revision; ~~~~~~~~~~~~~~~~~~~~. When the reviewer is happy with the change, they will **Accept** the; revision. They may leave some more minor comments that you should; address, but at this point the review is complete. It's time to get it; merged!. Commit by proxy; ---------------. As this is your first change, you won't have access to merge it; yourself yet. The reviewer **doesn't know this**, so you need to tell; them! Leave a message on the review like:. Thanks @somellvmdev. I don't have commit access, can you land this; patch for me?. The pull-request will be closed and you will be notified by GitHub. Review expectations; -------------------. In order to make LLVM a long-term sustainable effort, code needs to be; maintainable and well tested. Code reviews help to achieve that goal.; Especially for new contributors, that often means many rounds of reviews; and push-back on design decisions that do not fit well within the; overall architecture of the project. For your first patches, this means:. - be kind, and expect reviewers to be kind in return - LLVM has a `Code; of Conduct <https://llvm.org/docs/CodeOfConduct.html>`__;. - be patient - understanding how a new feature fits into the; architecture of the project is often a time consuming effort, and; people have to juggle this with other responsibilities in their; lives; **ping the review once a week** when there is no response;. - if you can't agree, generally the best way is to do what the reviewer; asks; we optimize for readability of the code, which the reviewer is; in a better position to judge; if this feels like it's not the right; option, you can contact the cfe-dev mailing list to get more feedback; on the directio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:11665,maintainab,maintainable,11665,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['maintainab'],['maintainable']
Modifiability,SymbolOrigin.cpp; clang-tools-extra/clangd/index/SymbolOrigin.h; clang-tools-extra/clangd/index/YAMLSerialization.cpp; clang-tools-extra/clangd/index/dex/Iterator.cpp; clang-tools-extra/clangd/index/dex/Iterator.h; clang-tools-extra/clangd/index/dex/PostingList.cpp; clang-tools-extra/clangd/index/dex/PostingList.h; clang-tools-extra/clangd/index/dex/Token.h; clang-tools-extra/clangd/index/dex/Trigram.cpp; clang-tools-extra/clangd/index/dex/Trigram.h; clang-tools-extra/clangd/index/dex/dexp/Dexp.cpp; clang-tools-extra/clangd/index/remote/Client.cpp; clang-tools-extra/clangd/index/remote/Client.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clan,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80025,refactor,refactor,80025,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"T.; This is aligned with the overall `design principle of the Clang AST <InternalsManual.html#immutability>`_: Clang AST nodes (types, declarations, statements, expressions, and so on) are generally designed to be **immutable once created**.; Thus, clients of the ASTImporter library should always check if there is any associated error for the node which they inspect in the destination context.; We recommend skipping the processing of those nodes which have an error associated with them. Using the ``-ast-merge`` Clang front-end action; -----------------------------------------------. The ``-ast-merge <pch-file>`` command-line switch can be used to merge from the given serialized AST file.; This file represents the source context.; When this switch is present then each top-level AST node of the source context is being merged into the destination context.; If the merge was successful then ``ASTConsumer::HandleTopLevelDecl`` is called for the Decl.; This results that we can execute the original front-end action on the extended AST. Example for C; ^^^^^^^^^^^^^. Let's consider the following three files:. .. code-block:: c. // bar.h; #ifndef BAR_H; #define BAR_H; int bar();; #endif /* BAR_H */. // bar.c; #include ""bar.h""; int bar() {; return 41;; }. // main.c; #include ""bar.h""; int main() {; return bar();; }. Let's generate the AST files for the two source files:. .. code-block:: bash. $ clang -cc1 -emit-pch -o bar.ast bar.c; $ clang -cc1 -emit-pch -o main.ast main.c. Then, let's check how the merged AST would look like if we consider only the ``bar()`` function:. .. code-block:: bash. $ clang -cc1 -ast-merge bar.ast -ast-merge main.ast /dev/null -ast-dump; TranslationUnitDecl 0x12b0738 <<invalid sloc>> <invalid sloc>; |-FunctionDecl 0x12b1470 </path/bar.h:4:1, col:9> col:5 used bar 'int ()'; |-FunctionDecl 0x12b1538 prev 0x12b1470 </path/bar.c:3:1, line:5:1> line:3:5 used bar 'int ()'; | `-CompoundStmt 0x12b1608 <col:11, line:5:1>; | `-ReturnStmt 0x12b15f8 <line:4:3, col:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:20967,extend,extended,20967,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['extend'],['extended']
Modifiability,"T>()``. Similarly, for statement attributes,; ``Sema::ProcessStmtAttributes()`` is called with a ``Stmt`` a list of; ``ParsedAttr`` objects to be converted into a semantic attribute. The structure of the semantic attribute is also governed by the attribute; definition given in Attr.td. This definition is used to automatically generate; functionality used for the implementation of the attribute, such as a class; derived from ``clang::Attr``, information for the parser to use, automated; semantic checking for some attributes, etc. ``include/clang/Basic/Attr.td``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The first step to adding a new attribute to Clang is to add its definition to; `include/clang/Basic/Attr.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/Attr.td>`_.; This tablegen definition must derive from the ``Attr`` (tablegen, not; semantic) type, or one of its derivatives. Most attributes will derive from the; ``InheritableAttr`` type, which specifies that the attribute can be inherited by; later redeclarations of the ``Decl`` it is associated with.; ``InheritableParamAttr`` is similar to ``InheritableAttr``, except that the; attribute is written on a parameter instead of a declaration. If the attribute; applies to statements, it should inherit from ``StmtAttr``. If the attribute is; intended to apply to a type instead of a declaration, such an attribute should; derive from ``TypeAttr``, and will generally not be given an AST representation.; (Note that this document does not cover the creation of type attributes.) An; attribute that inherits from ``IgnoredAttr`` is parsed, but will generate an; ignored attribute diagnostic when used, which may be useful when an attribute is; supported by another vendor but not supported by clang. The definition will specify several key pieces of information, such as the; semantic name of the attribute, the spellings the attribute supports, the; arguments the attribute expects, and more. Most members of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:127861,inherit,inherited,127861,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['inherit'],['inherited']
Modifiability,"TC1; Should the enclosing class be an ""associated class"" too?; Yes. 91; NAD; A union's associated types should include the union itself; Yes. 92; CD4; Should exception-specifications be part of the type system?; Clang 4 (C++17 onwards). 93; TC1; Missing word in 3.8 basic.life paragraph 2; N/A. 94; TC1; Inconsistencies in the descriptions of constant expressions; Yes. 95; NAD; Elaborated type specifiers referencing names declared in friend decls; Clang 3.3. 96; C++11; Syntactic disambiguation using the template keyword; No. 97; NAD; Use of bool constants in integral constant expressions; Yes. 98; TC1; Branching into try block; Yes. 99; NAD; Partial ordering, references and cv-qualifiers; Superseded by 214. 100; TC1; Clarify why string literals are not allowed as template arguments; Yes. 101; TC1; Redeclaration of extern ""C"" names via using-declarations; Clang 3.5. 102; NAD; Operator lookup rules do not work well with parts of the library; Yes. 103; TC1; Is it extended-namespace-definition or extension-namespace-definition ?; N/A. 104; NAD; Destroying the exception temp when no handler is found; N/A (Library DR). 105; TC1; Meaning of ""template function""; N/A. 106; CD1; Creating references to references during template deduction/instantiation; Superseded by 540. 107; NAD; Linkage of operator functions; Yes. 108; TC1; Are classes nested in templates dependent?; Clang 2.9. 109; NAD; Allowing ::template in using-declarations; Yes. 110; CD6; Can template functions and classes be declared in the same scope?; Unknown. 111; NAD; Copy constructors and cv-qualifiers; Duplicate of 535. 112; CD1; Array types and cv-qualifiers; Yes. 113; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:7565,extend,extended-namespace-definition,7565,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['extend'],['extended-namespace-definition']
Modifiability,"TClass`** class. It provides all the information about a class, a; full description of data members and methods, including the comment; field and the method parameter types. A class with the `ClassDef` macro; has the ability to obtain a **`TClass`** with the `IsA` method. ``` {.cpp}; TClass *cl = obj->IsA();; ```. It returns a **`TClass`**. In addition, an object can directly get the; class name and the base classes by:. ``` {.cpp}; const char* name = obj->ClassName();; ```. If the class is a descendent of **`TObject`**, you can check if an; object inherits from a specific class, you can use the `InheritsFrom`; method. This method returns `kTrue` if the object inherits from the; specified class name or **`TClass`**. ``` {.cpp}; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ```. ROOT and `Cling` rely on reflection and the class dictionary to identify; the type of a variable at run time. With **`TObject`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ROOT collection, it must be a descendent of; **`TObject`**. This is convenient if you want to store objects of; different classes in the same collection and execute the method of the; same name on all members of the collection. For example, the list of; graphics primitives are in a ROOT collection called **`TList`**. When; the canvas is drawn, the `Paint` method is executed on the entire; collection. Each member may be a different class, and if the `Paint`; method is not implemented, **`TObject::Paint`** will be executed. ### Input/Output. The `TObject::Write` method is the interface to the ROOT I/O system. It; stream",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:1584,inherit,inheritance,1584,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['inherit'],['inheritance']
Modifiability,"TEST DISCOVERY; ~~~~~~~~~~~~~~. Once test suites are located, :program:`lit` recursively traverses the source; directory (following *test_source_root*) looking for tests. When :program:`lit`; enters a sub-directory, it first checks to see if a nested test suite is; defined in that directory. If so, it loads that test suite recursively,; otherwise it instantiates a local test config for the directory (see; :ref:`local-configuration-files`). Tests are identified by the test suite they are contained within, and the; relative path inside that suite. Note that the relative path may not refer to; an actual file on disk; some test formats (such as *GoogleTest*) define; ""virtual tests"" which have a path that contains both the path to the actual; test file and a subpath to identify the virtual test. .. _local-configuration-files:. LOCAL CONFIGURATION FILES; ~~~~~~~~~~~~~~~~~~~~~~~~~. When :program:`lit` loads a subdirectory in a test suite, it instantiates a; local test configuration by cloning the configuration for the parent directory; --- the root of this configuration chain will always be a test suite. Once the; test configuration is cloned :program:`lit` checks for a *lit.local.cfg* file; in the subdirectory. If present, this file will be loaded and can be used to; specialize the configuration for each individual directory. This facility can; be used to define subdirectories of optional tests, or to change other; configuration parameters --- for example, to change the test format, or the; suffixes which identify test files. SUBSTITUTIONS; ~~~~~~~~~~~~~. :program:`lit` allows patterns to be substituted inside RUN commands. It also; provides the following base set of substitutions, which are defined in; TestRunner.py:. ======================= ==============; Macro Substitution; ======================= ==============; %s source path (path to the file currently being run); %S source dir (directory of the file currently being run); %p same as %S; %{pathsep} path separator; %{",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:18363,config,configuration,18363,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,3,['config'],['configuration']
Modifiability,"TGraphErrors`** are: `X, Y` (as in; **`TGraph`**), `X`-errors, and `Y`-errors - the size of the errors; in the `x` and `y` direction. Next example is; `$ROOTSYS/tutorials/graphs/gerrors.C.`. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; ```. ## Graphs with Asymmetric Error Bars. ![A graph with asymmetric error bars](pictures/03000052.png). A **`TGraphAsymmErrors`** is a **`TGraph`** with asymmetric error; bars. It inherits the various draw format options from **`TGraph`**.; Its method `Paint(Option_t *option)` paints the; **`TGraphAsymmErrors`** with the current attributes. You can set the; following additional options for drawing:. - ""`z`"" or ""`Z`""the horizontal and vertical small lines are not; drawn at the end of error bars. - ""`>`""an arrow is drawn at the end of the error bars. - ""`|>`""a full arrow is drawn at the end of the error bar; its size; is $\frac{2}{3}$ of the marker size. - ""`[]`""only the end vertical/horizontal lines of the error bars are; drawn; this option is interesting to superimpose systematic errors; on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as **TGraph**; and low X-errors and high X-errors, low Y-errors and high Y-errors.; The low value is the length of the error bar to the left and down,; the high value is the length of the error bar to the right and up. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:6862,inherit,inherits,6862,documentation/users-guide/Graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md,1,['inherit'],['inherits']
Modifiability,"TH ""${CMAKE_CURRENT_SOURCE_DIR}/llvm-project/llvm/cmake/modules""); #---Set into parent scope LLVM_VERSION_MAJOR --------------------------------------------------------; get_directory_property(_llvm_version_major DIRECTORY llvm-project/llvm DEFINITION LLVM_VERSION_MAJOR); set(LLVM_VERSION_MAJOR ""${_llvm_version_major}"" PARENT_SCOPE); #---Forward LLVM_TARGET_TRIPLE for check-cling-------------------------------------------------------; get_directory_property(LLVM_TARGET_TRIPLE DIRECTORY llvm-project/llvm DEFINITION LLVM_TARGET_TRIPLE); #---Get back the potentially updated LLVM_TARGETS_TO_BUILD (expanding all/host/Native)---------------; get_directory_property(LLVM_TARGETS_TO_BUILD DIRECTORY llvm-project/llvm DEFINITION LLVM_TARGETS_TO_BUILD). if(MSVC); if(CMAKE_GENERATOR MATCHES Ninja); set(LLVM_TABLEGEN_EXE ""${LLVM_BINARY_DIR}/bin/llvm-tblgen.exe""); else(); set(LLVM_TABLEGEN_EXE ""${LLVM_BINARY_DIR}/$<CONFIG>/bin/llvm-tblgen.exe""); endif(); else(); set(LLVM_TABLEGEN_EXE ""${LLVM_BINARY_DIR}/bin/llvm-tblgen""); endif(); else(); # Rely on llvm-config.; set(CONFIG_OUTPUT); find_program(LLVM_CONFIG NAMES ""llvm-config-${ROOT_LLVM_VERSION_REQUIRED_MAJOR}"" ""llvm-config""); if(LLVM_CONFIG); message(STATUS ""Found LLVM_CONFIG as ${LLVM_CONFIG}""); set(CONFIG_COMMAND ${LLVM_CONFIG}; ""--assertion-mode""; ""--bindir""; ""--libdir""; ""--includedir""; ""--prefix""; ""--cmakedir""; ""--build-mode""; ""--version""); execute_process(; COMMAND ${CONFIG_COMMAND}; RESULT_VARIABLE HAD_ERROR; OUTPUT_VARIABLE CONFIG_OUTPUT; ); if(NOT HAD_ERROR); string(REGEX REPLACE; ""[ \t]*[\r\n]+[ \t]*"" "";""; CONFIG_OUTPUT ${CONFIG_OUTPUT}); else(); string(REPLACE "";"" "" "" CONFIG_COMMAND_STR ""${CONFIG_COMMAND}""); message(STATUS ""${CONFIG_COMMAND_STR}""); message(FATAL_ERROR ""llvm-config failed with status ${HAD_ERROR}""); endif(); else(); message(FATAL_ERROR ""llvm-config not found -- ${LLVM_CONFIG}""); endif(). list(GET CONFIG_OUTPUT 0 ENABLE_ASSERTIONS); list(GET CONFIG_OUTPUT 1 TOOLS_BINARY_DIR); list(GET CONFIG_OUTPUT 2 LIBR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:12511,config,config,12511,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['config'],['config']
Modifiability,"THROUGH_VARIABLES; -D${varName}=${value}); endif(); if(${variableName} AND variableName MATCHES ""LLVM_EXTERNAL_.*_SOURCE_DIR""); list(APPEND PASSTHROUGH_VARIABLES; -D${variableName}=${${variableName}}); endif(); endforeach(). # Build arguments for native tool used in CMake.; set(build_configuration ""$<CONFIG>""); set(build_tool_args ""${LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS}""); if(NOT build_tool_args STREQUAL """"); string(PREPEND build_tool_args ""-- ""); separate_arguments(build_tool_args UNIX_COMMAND ""${build_tool_args}""); endif(). ExternalProject_Add(${NEXT_CLANG_STAGE}; DEPENDS clang-bootstrap-deps; PREFIX ${NEXT_CLANG_STAGE}; SOURCE_DIR ${CMAKE_SOURCE_DIR}; STAMP_DIR ${STAMP_DIR}; BINARY_DIR ${BINARY_DIR}; EXCLUDE_FROM_ALL 1; CMAKE_ARGS; # We shouldn't need to set this here, but INSTALL_DIR doesn't; # seem to work, so instead I'm passing this through; -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}; ${PASSTHROUGH_VARIABLES}; ${CLANG_BOOTSTRAP_CMAKE_ARGS}; -DCLANG_STAGE=${NEXT_CLANG_STAGE}; ${COMPILER_OPTIONS}; ${${CLANG_STAGE}_TABLEGEN}; ${LTO_LIBRARY} ${verbose} ${PGO_OPT}; ${${CLANG_STAGE}_LINKER}; ${${CLANG_STAGE}_AR}; ${${CLANG_STAGE}_RANLIB}; ${${CLANG_STAGE}_OBJCOPY}; ${${CLANG_STAGE}_STRIP}; BUILD_COMMAND ${CMAKE_COMMAND} --build ${BINARY_DIR}; --config ${build_configuration}; ${build_tool_args}; INSTALL_COMMAND """"; STEP_TARGETS configure build; USES_TERMINAL_CONFIGURE 1; USES_TERMINAL_BUILD 1; USES_TERMINAL_INSTALL 1; LIST_SEPARATOR |; ). # exclude really-install from main target; set_target_properties(${NEXT_CLANG_STAGE} PROPERTIES _EP_really-install_EXCLUDE_FROM_MAIN On); ExternalProject_Add_Step(${NEXT_CLANG_STAGE} really-install; COMMAND ${CMAKE_COMMAND} --build <BINARY_DIR> --target install; COMMENT ""Performing install step for '${NEXT_CLANG_STAGE}'""; DEPENDEES build; USES_TERMINAL 1; ); ExternalProject_Add_StepTargets(${NEXT_CLANG_STAGE} really-install); add_custom_target(${NEXT_CLANG_STAGE}-install DEPENDS ${NEXT_CLANG_STAGE}-really-install). if(NOT CLAN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:28754,config,config,28754,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,2,['config'],"['config', 'configure']"
Modifiability,TL/src/Configuration.cpp; openmp/libomptarget/DeviceRTL/src/Kernel.cpp; openmp/libomptarget/DeviceRTL/src/Misc.cpp; openmp/libomptarget/DeviceRTL/src/Parallelism.cpp; openmp/libomptarget/DeviceRTL/src/Reduction.cpp; openmp/libomptarget/DeviceRTL/src/State.cpp; openmp/libomptarget/DeviceRTL/src/Synchronization.cpp; openmp/libomptarget/DeviceRTL/src/Tasking.cpp; openmp/libomptarget/DeviceRTL/src/Utils.cpp; openmp/libomptarget/include/Debug.h; openmp/libomptarget/include/device.h; openmp/libomptarget/include/DeviceEnvironment.h; openmp/libomptarget/include/interop.h; openmp/libomptarget/include/omptarget.h; openmp/libomptarget/include/omptargetplugin.h; openmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plug,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407088,plugin,plugins,407088,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"TO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4045,config,configurations,4045,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['config'],['configurations']
Modifiability,"TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:10871,inherit,inherits,10871,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['inherit'],['inherits']
Modifiability,"TPUT_DIRECTORY}/tf_runtime); install(TARGETS tf_xla_runtime EXPORT LLVMExports; ARCHIVE DESTINATION lib${LLVM_LIBDIR_SUFFIX} COMPONENT tf_xla_runtime); set_property(GLOBAL APPEND PROPERTY LLVM_EXPORTS tf_xla_runtime); # Once we add more modules, we should handle this more automatically.; if (DEFINED LLVM_OVERRIDE_MODEL_HEADER_INLINERSIZEMODEL); set(LLVM_INLINER_MODEL_PATH ""none""); elseif(NOT DEFINED LLVM_INLINER_MODEL_PATH; OR ""${LLVM_INLINER_MODEL_PATH}"" STREQUAL """"; OR ""${LLVM_INLINER_MODEL_PATH}"" STREQUAL ""autogenerate""); set(LLVM_INLINER_MODEL_PATH ""autogenerate""); set(LLVM_INLINER_MODEL_AUTOGENERATED 1); endif(); if (DEFINED LLVM_OVERRIDE_MODEL_HEADER_REGALLOCEVICTMODEL); set(LLVM_RAEVICT_MODEL_PATH ""none""); elseif(NOT DEFINED LLVM_RAEVICT_MODEL_PATH; OR ""${LLVM_RAEVICT_MODEL_PATH}"" STREQUAL """"; OR ""${LLVM_RAEVICT_MODEL_PATH}"" STREQUAL ""autogenerate""); set(LLVM_RAEVICT_MODEL_PATH ""autogenerate""); set(LLVM_RAEVICT_MODEL_AUTOGENERATED 1); endif(). endif(). # Configure the three LLVM configuration header files.; configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/config.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/config.h); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/llvm-config.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/llvm-config.h); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/abi-breaking.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/abi-breaking.h). # Add target for generating source rpm package.; set(LLVM_SRPM_USER_BINARY_SPECFILE ${CMAKE_CURRENT_SOURCE_DIR}/llvm.spec.in; CACHE FILEPATH "".spec file to use for srpm generation""); set(LLVM_SRPM_BINARY_SPECFILE ${CMAKE_CURRENT_BINARY_DIR}/llvm.spec); set(LLVM_SRPM_DIR ""${CMAKE_CURRENT_BINARY_DIR}/srpm""). get_source_info(${CMAKE_CURRENT_SOURCE_DIR} revision repository); string(LENGTH ""${revision}"" revision_length); set(LLVM_RPM_SPEC_REVISION ""${revision}""). configure_file(; ${LLVM_SRPM_USER_BINARY_SPECFILE}; ${LLVM_SRPM_BINARY_SPECFILE} @ONLY). add_custom_target(srpm; COMMAND cpack -G TGZ --config CPac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:44830,config,configuration,44830,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"TRING; ""Path for binary subdirectory (defaults to '${CMAKE_INSTALL_BINDIR}')""); mark_as_advanced(LLVM_TOOLS_INSTALL_DIR). set(LLVM_UTILS_INSTALL_DIR ""${LLVM_TOOLS_INSTALL_DIR}"" CACHE STRING; ""Path to install LLVM utilities (enabled by LLVM_INSTALL_UTILS=ON) (defaults to LLVM_TOOLS_INSTALL_DIR)""); mark_as_advanced(LLVM_UTILS_INSTALL_DIR). set(LLVM_EXAMPLES_INSTALL_DIR ""examples"" CACHE STRING; ""Path for examples subdirectory (enabled by LLVM_BUILD_EXAMPLES=ON) (defaults to 'examples')""); mark_as_advanced(LLVM_EXAMPLES_INSTALL_DIR). # They are used as destination of target generators.; set(LLVM_RUNTIME_OUTPUT_INTDIR ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/bin); set(LLVM_LIBRARY_OUTPUT_INTDIR ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/lib${LLVM_LIBDIR_SUFFIX}); if(WIN32 OR CYGWIN); # DLL platform -- put DLLs into bin.; set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_RUNTIME_OUTPUT_INTDIR}); else(); set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_LIBRARY_OUTPUT_INTDIR}); endif(). # Each of them corresponds to llvm-config's.; set(LLVM_TOOLS_BINARY_DIR ${LLVM_RUNTIME_OUTPUT_INTDIR}) # --bindir; set(LLVM_LIBRARY_DIR ${LLVM_LIBRARY_OUTPUT_INTDIR}) # --libdir; set(LLVM_MAIN_SRC_DIR ${CMAKE_CURRENT_SOURCE_DIR} ) # --src-root; set(LLVM_MAIN_INCLUDE_DIR ${LLVM_MAIN_SRC_DIR}/include ) # --includedir; set(LLVM_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR} ) # --prefix. # Note: LLVM_CMAKE_DIR does not include generated files; set(LLVM_CMAKE_DIR ${LLVM_MAIN_SRC_DIR}/cmake/modules); set(LLVM_EXAMPLES_BINARY_DIR ${LLVM_BINARY_DIR}/examples); set(LLVM_INCLUDE_DIR ${CMAKE_CURRENT_BINARY_DIR}/include). # List of all targets to be built by default:; set(LLVM_ALL_TARGETS; AArch64; AMDGPU; ARM; AVR; BPF; Hexagon; Lanai; LoongArch; Mips; MSP430; NVPTX; PowerPC; RISCV; Sparc; SystemZ; VE; WebAssembly; X86; XCore; ). set(LLVM_ALL_EXPERIMENTAL_TARGETS; ARC; CSKY; DirectX; M68k; SPIRV; Xtensa; ). # List of targets with JIT support:; set(LLVM_TARGETS_WITH_JIT X86 PowerPC AArch64 ARM Mips SystemZ). set(LLVM_TARGETS_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:19331,config,config,19331,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config']
Modifiability,"Test, fMBItemLayout);; fMenuBar->AddPopup(""&Help"", fMenuHelp, fMBHelpLayout);; ```. Using the method `TGMenuBar::AddPopup` we add three **`TGPopupMenu`**; objects to the menu bar `fMenuBar`. The first parameter is a hot string; used by **`TGMenuTitle`** object. When you add a popup menu to the menu; bar, a **`TGMenuTitle`** object is created by the menu bar. It is the; name of the popup menu. A menu title should have a one-word name that; reflects the purpose of all items within the corresponding popup menu.; It should also have a defined character as its unique access key. The; second parameter is the popup menu we would like to add. The third one; is an object of **`TGLayoutHints`** type that defines how the menu title; will be laid out in the menu bar. In our example the *`File`* and `Test`; menus will be laid out to the left of the menu bar with 4 pixels; distance in between, the `Help` menu - will be laid out to the right. The menu classes provide a very flexible menu system: you can enable,; disable, add or remove menu items dynamically. The method; `HideEntry(menuID)` hides the menu entry (the entry will not be shown in; the popup menu). To enable a hidden entry you should call; `EnableEntry(menuID)` method. By default all entries are enabled. The; method `DisableEntry(menuID)` helps you to disable a menu entry - it; will appear in sunken relieve. The `DeleteEntry(menuID)` method will; delete the specified entry from the menu. A few words about the menu design. A menu should be kept consistent and; simple. All related items need to be in a popup menu. The cascade menus; should be used judiciously. Try to limit them to one, maximum two; levels. There are some rules for naming the menu objects:. - Define unique names within a menu. - Use capitalized one-word names allowing the quick scan of the menu. - Define unique access key for any menu item. - Indicate by ellipsis (...) after the title with no space when a menu; item will pop-up a dialog box. The proper kin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:72875,flexible,flexible,72875,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['flexible'],['flexible']
Modifiability,"The C API is, in general, a ""best effort"" for stability.; This means that we make every attempt to keep the C API stable, but that; stability will be limited by the abstractness of the interface and the; stability of the C++ API that it wraps. In practice, this means that things; like ""create debug info"" or ""create this type of instruction"" are likely to be; less stable than ""take this IR file and JIT it for my current machine"". * Release stability: We won't break the C API on the release branch with patches; that go on that branch, with the exception that we will fix an unintentional; C API break that will keep the release consistent with both the previous and; next release. * Testing: Patches to the C API are expected to come with tests just like any; other patch. * Including new things into the API: If an LLVM subcomponent has a C API already; included, then expanding that C API is acceptable. Adding C API for; subcomponents that don't currently have one needs to be discussed on the; `LLVM Discourse forums`_ for design and maintainability feedback prior to implementation. * Documentation: Any changes to the C API are required to be documented in the; release notes so that it's clear to external users who do not follow the; project how the C API is changing and evolving. .. _toolchain:. Updating Toolchain Requirements; -------------------------------. We intend to require newer toolchains as time goes by. This means LLVM's; codebase can use newer versions of C++ as they get standardized. Requiring newer; toolchains to build LLVM can be painful for those building LLVM; therefore, it; will only be done through the following process:. * It is a general goal to support LLVM and GCC versions from the last 3 years; at a minimum. This time-based guideline is not strict: we may support much; older compilers, or decide to support fewer versions. * An RFC is sent to the `LLVM Discourse forums`_. - Detail upsides of the version increase (e.g. which newer C++ language or; lib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:33645,maintainab,maintainability,33645,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['maintainab'],['maintainability']
Modifiability,"The CommandLine library would not be able to catch; this erroneous input for us. #. We would have to test 4 different variables to see which ones are set. #. This doesn't map to the numeric levels that we want... so we cannot easily; see if some level >= ""``-O1``"" is enabled. To cope with these problems, we can use an enum value, and have the CommandLine; library fill it in with the appropriate level directly, which is used like this:. .. code-block:: c++. enum OptLevel {; g, O1, O2, O3; };. cl::opt<OptLevel> OptimizationLevel(cl::desc(""Choose optimization level:""),; cl::values(; clEnumVal(g , ""No optimizations, enable debugging""),; clEnumVal(O1, ""Enable trivial optimizations""),; clEnumVal(O2, ""Enable default optimizations""),; clEnumVal(O3, ""Enable expensive optimizations"")));. ...; if (OptimizationLevel >= O2) doPartialRedundancyElimination(...);; ... This declaration defines a variable ""``OptimizationLevel``"" of the; ""``OptLevel``"" enum type. This variable can be assigned any of the values that; are listed in the declaration. The CommandLine library enforces that; the user can only specify one of the options, and it ensure that only valid enum; values can be specified. The ""``clEnumVal``"" macros ensure that the command; line arguments matched the enum values. With this option added, our help output; now is:. ::. USAGE: compiler [options] <input file>. OPTIONS:; Choose optimization level:; -g - No optimizations, enable debugging; -O1 - Enable trivial optimizations; -O2 - Enable default optimizations; -O3 - Enable expensive optimizations; -f - Enable binary output on terminals; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename; -quiet - Don't print informational messages. In this case, it is sort of awkward that flag names correspond directly to enum; names, because we probably don't want an enum definition named ""``g``"" in our; program. Because of this, we can alternatively write this example like this:. .. code-block",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:15142,variab,variable,15142,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"The Dataset Stager; ==================. Overview; --------. The [Dataset Stager (afdsmgrd)](http://afdsmgrd.googlecode.com/) is; a daemon that coordinates the transfer of data from a remote storage; to your local storage. For each file to transfer, a script is called. The script can be; customized to support your source and destination protocol. Staging requests are issued from the ROOT console, where you can also; control the progress of your staging. Installation; ------------. The Dataset Stager is distributed both on a repository on its own and as; part of ROOT. The easiest way to compile it is to do it inside ROOT. Installing from ROOT; --------------------. When configuring the ROOT source, enable the Dataset Stager by adding; `--enable-afdsmgrd`. Check in the list of enabled features if you have; ""afdsmgrd"". After running `make` (and, optionally, `make install`) you'll find the; daemon in the same directory of `root.exe`. The configuration file and init.d startup script will be in; `$ROOTSYS/etc/proof`. The daemon can and **must** run as unprivileged; user. Configuration; -------------. The Dataset Stager can share its configuration file with PROOF, as; some directives are the same and unknown directives are just ignored. Directives are one per line and lines beginning with a pound sign (`#`); are used for comments. > The configuration file is automatically checked at each loop: this; > means you can change configuration without restarting the daemon or; > stopping your current transfers. A detailed description of each directive follows. set *VARIABLE=value*; : This statement will substitute every occurrence of `$VARIABLE` with; its *value* in the rest of the configuration file. You can have; multiple `set` statements. xpd.stagereqrepo [dir:]*directory*; : This directive is shared with PROOF: *directory* is the full path to; the dataset repository. **Defaults to empty:** without this; directive the daemon is not operative. The `dir:` prefix is optional. dsmgrd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md:677,config,configuring,677,proof/doc/confman/DatasetStager.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md,2,['config'],"['configuration', 'configuring']"
Modifiability,"The LLVM Gold LTO Plugin; ========================. This directory contains a plugin that is designed to work with binutils; gold linker. At present time, this is not the default linker in; binutils, and the default build of gold does not support plugins. See docs/GoldPlugin.html for complete build and usage instructions. NOTE: libLTO and LLVMgold aren't built without PIC because they would fail; to link on x86-64 with a relocation error: PIC and non-PIC can't be combined.; As an alternative to passing --enable-pic, you can use 'make ENABLE_PIC=1' in; your entire LLVM build.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/README.txt:78,plugin,plugin,78,interpreter/llvm-project/llvm/tools/gold/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/README.txt,2,['plugin'],"['plugin', 'plugins']"
Modifiability,"The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:7872,config,configured,7872,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,2,"['config', 'plugin']","['configured', 'plugins']"
Modifiability,"The extra indent or outdent of access modifiers, e.g. ``public:``. .. _AlignAfterOpenBracket:. **AlignAfterOpenBracket** (``BracketAlignmentStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignAfterOpenBracket>`; If ``true``, horizontally aligns arguments after an open bracket. This applies to round brackets (parentheses), angle brackets and square; brackets. Possible values:. * ``BAS_Align`` (in configuration: ``Align``); Align parameters on the open bracket, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_DontAlign`` (in configuration: ``DontAlign``); Don't align, instead use ``ContinuationIndentWidth``, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_AlwaysBreak`` (in configuration: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; {7, 5, ""!!"" }; };. * ``AIAS_Right`` (in configuration: ``Right``); Align array column and right justify ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:7881,config,configuration,7881,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"The purpose of; a name is to tag an operator or argument in a DAG with a particular meaning,; or to associate an argument in one DAG with a like-named argument in another; DAG. The following bang operators are useful for working with DAGs:; ``!con``, ``!dag``, ``!empty``, ``!foreach``, ``!getdagarg``, ``!getdagname``,; ``!getdagop``, ``!setdagarg``, ``!setdagname``, ``!setdagop``, ``!size``. Defvar in a record body; -----------------------. In addition to defining global variables, the ``defvar`` statement can; be used inside the :token:`Body` of a class or record definition to define; local variables. Template arguments of ``class`` or ``multiclass`` can be; used in the value expression. The scope of the variable extends from the; ``defvar`` statement to the end of the body. It cannot be set to a different; value within its scope. The ``defvar`` statement can also be used in the statement; list of a ``foreach``, which establishes a scope. A variable named ``V`` in an inner scope shadows (hides) any variables ``V``; in outer scopes. In particular, there are several cases:. * ``V`` in a record body shadows a global ``V``. * ``V`` in a record body shadows template argument ``V``. * ``V`` in template arguments shadows a global ``V``. * ``V`` in a ``foreach`` statement list shadows any ``V`` in surrounding record or; global scopes. Variables defined in a ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1). How records are built; ---------------------. The following steps are taken by TableGen when a record is built. Classes are simply; abstract records and so go through the same steps. 1. Build the record name (:token:`NameValue`) and create an empty record. 2. Parse the parent classes in the :token:`ParentClassList` from left to; right, visiting each parent class's ancestor classes from top to bottom. a. Add the fields from",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:52607,variab,variable,52607,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"The tree1.root file and its tree in the browser and a leaf histogram](pictures/030000FC.png). In the right panel of the ROOT object browse are the branches: `ev`,; `px`, `py`, `pz`, and `random`. Note that these are shown as leaves; because they are ""end"" branches with only one leaf. To histogram a leaf,; we can simply double click on it in the browser. This is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if you call `mybranch.SetAutoDelete(kTRUE)`; (default is `kFALSE`). Consider the example in `$ROOTSYS/test/Event.h`. The top-level branch in; the tree `T` is declared with:. ``` {.cpp}; Event *event = 0;; // event must be null or point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; ```. When ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:38345,variab,variable,38345,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"The type of the second operand indicates whether the variable location is; directly referred to by the DBG_VALUE, or whether it is indirect. The; ``$noreg`` register signifies the former, an immediate operand (0) the; latter.; * Operand 3 is the Variable field of the original debug intrinsic.; * Operand 4 is the Expression field of the original debug intrinsic. The second form, ``DBG_VALUE_LIST``, appears thus:. .. code-block:: text. DBG_VALUE_LIST !123, !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_plus), %1, %2. And has the following operands:; * The first operand is the Variable field of the original debug intrinsic.; * The second operand is the Expression field of the original debug intrinsic.; * Any number of operands, from the 3rd onwards, record a sequence of variable; location operands, which may take any of the same values as the first; operand of the ``DBG_VALUE`` instruction above. These variable location; operands are inserted into the final DWARF Expression in positions indicated; by the DW_OP_LLVM_arg operator in the `DIExpression; <LangRef.html#diexpression>`_. The position at which the DBG_VALUEs are inserted should correspond to the; positions of their matching ``llvm.dbg.value`` intrinsics in the IR block. As; with optimization, LLVM aims to preserve the order in which variable; assignments occurred in the source program. However SelectionDAG performs some; instruction scheduling, which can reorder assignments (discussed below).; Function parameter locations are moved to the beginning of the function if; they're not already, to ensure they're immediately available on function entry. To demonstrate variable locations during instruction selection, consider; the following example:. .. code-block:: llvm. define i32 @foo(i32* %addr) {; entry:; call void @llvm.dbg.value(metadata i32 0, metadata !3, metadata !DIExpression()), !dbg !5; br label %bb1, !dbg !5. bb1: ; preds = %bb1, %entry; %bar.0 = phi i32 [ 0, %entry ], [ %add, %bb1 ]; call void",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:28563,variab,variable,28563,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"The; term ""statepoint"" as used in this document refers exclusively to the; former. This document focuses on the last item - compiler support for; safepoints in generated code. We will assume that an outside; mechanism has decided where to place safepoints. From our; perspective, all safepoints will be function calls. To support; relocation of objects directly reachable from values in compiled code,; the collector must be able to:. #. identify every copy of a pointer (including copies introduced by; the compiler itself) at the safepoint,; #. identify which object each pointer relates to, and; #. potentially update each of those copies. This document describes the mechanism by which an LLVM based compiler; can provide this information to a language runtime/collector, and; ensure that all pointers can be read and updated if desired. Abstract Machine Model; ^^^^^^^^^^^^^^^^^^^^^^^. At a high level, LLVM has been extended to support compiling to an abstract; machine which extends the actual target with a non-integral pointer type; suitable for representing a garbage collected reference to an object. In; particular, such non-integral pointer type have no defined mapping to an; integer representation. This semantic quirk allows the runtime to pick a; integer mapping for each point in the program allowing relocations of objects; without visible effects. This high level abstract machine model is used for most of the optimizer. As; a result, transform passes do not need to be extended to look through explicit; relocation sequence. Before starting code generation, we switch; representations to an explicit form. The exact location chosen for lowering; is an implementation detail. Note that most of the value of the abstract machine model comes for collectors; which need to model potentially relocatable objects. For a compiler which; supports only a non-relocating collector, you may wish to consider starting; with the fully explicit form. Warning: There is one currently known sema",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:4606,extend,extended,4606,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,2,['extend'],"['extended', 'extends']"
Modifiability,"There are three main groups of code that fit in this category:; * Code that is making its way into LLVM, via the `experimental <https://llvm.org/docs/DeveloperPolicy.html#introducing-new-components-into-llvm>`_; roadmap or similar efforts.; * Code that is making its way out of LLVM, via deprecation, replacement or; bit-rot, and will be removed if the sub-community that cares about it; cannot maintain it.; * Code that isn't meant to be in LLVM core and can coexist with the code in; the core tier (and others in the peripheral tier) long term, without causing; breakages or disturbances. What is covered; ---------------. The peripheral tier is composed of:; * Experimental targets and options that haven't been enable by default yet.; * Main repository projects that don't get released or regularly tested.; * Legacy tools and scripts that aren't used in upstream validation.; * Alternative build systems (ex. GN, Bazel) and related infrastructure.; * Tools support (ex. gdb scripts, editor configuration, helper scripts). Requirements; ------------. Code in this tier must:; * Have a clear benefit for residing in the main repository, catering to an; active sub-community (upstream or downstream).; * Be actively maintained by such sub-community and have its problems addressed; in a timely manner. Code in this tier must **not**:; * Break or invalidate core tier code or infrastructure. If that happens; accidentally, reverting functionality and working on the issues offline; is the only acceptable course of action.; * Negatively affect development of core tier code, with the sub-community; involved responsible for making changes to address specific concerns.; * Negatively affect other peripheral tier code, with the sub-communities; involved tasked to resolve the issues, still making sure the solution doesn't; break or invalidate the core tier.; * Impose sub-optimal implementation strategies on core tier components as a; result of idiosyncrasies in the peripheral component.; * Have b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:4694,config,configuration,4694,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['config'],['configuration']
Modifiability,"This directory contains a VSPackage project to generate a Visual Studio extension; for clang-format. Build prerequisites are:; - Visual Studio 2015; - Extensions SDK (you'll be prompted to install it if you open ClangFormat.sln). The extension is built using CMake to generate the usual LLVM.sln by setting; the following CMake vars:. - BUILD_CLANG_FORMAT_VS_PLUGIN=ON. - NUGET_EXE_DIR=path/to/nuget_dir (unless nuget.exe is already available in PATH). example:; cd /d C:\code\llvm; mkdir build & cd build; cmake -DBUILD_CLANG_FORMAT_VS_PLUGIN=ON -DNUGET_EXE_DIR=C:\nuget .. Once LLVM.sln is generated, build the clang_format_vsix target, which will build; ClangFormat.sln, the C# extension application. The CMake build will copy clang-format.exe and LICENSE.TXT into the ClangFormat/; directory so they can be bundled with the plug-in, as well as creating; ClangFormat/source.extension.vsixmanifest. Once the plug-in has been built with; CMake once, it can be built manually from the ClangFormat.sln solution in Visual; Studio. ===========; Debugging; ===========. Once you've built the clang_format_vsix project from LLVM.sln at least once,; open ClangFormat.sln in Visual Studio, then:. - Make sure the ""Debug"" target is selected; - Open the ClangFormat project properties; - Select the Debug tab; - Set ""Start external program:"" to where your devenv.exe is installed. Typically; it's ""C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\devenv.exe""; - Set ""Command line arguments"" to: /rootsuffix Exp; - You can now set breakpoints if you like; - Press F5 to build and run with debugger. If all goes well, a new instance of Visual Studio will be launched in a special; mode where it uses the experimental hive instead of the normal configuration hive.; By default, when you build a VSIX project in Visual Studio, it auto-registers the; extension in the experimental hive, allowing you to test it. In the new Visual Studio; instance, open or create a C++ solution, and you should now se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/README.txt:828,plug-in,plug-in,828,interpreter/llvm-project/clang/tools/clang-format-vs/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/README.txt,2,['plug-in'],['plug-in']
Modifiability,"This directory contains the ROOT::Math::GeneticMinimizer class; BEGIN_HTML; The GeneticMinimizer class is used to implement a genetic minimizer algorithm.; The algorithm is based on an algorithm implemented in the TMVA package; (TMVA::GeneticAlgorithm class).; <p>; The ROOT::Math:GeneticMinimizer class implements the; ROOT::Math::Minimizer interface, as a new plugin with name ""Genetic"".; The class can be used when fitting histograms or graph by selecting it; as default minimizer. This can be done via:; <pre>; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Genetic"");; </pre>; Via the MinimizerOptions, one can control the possible options for the; class. These are described in the TMVA user guide, Option Table 7.; A list of the default options can be obtained by doing:; <pre>; ROOT::Math::Minimizer * min =ROOT::Math::Factory::CreateMinimizer(""Genetic"");; min->Options().Print();; </pre>; The user can change a default option, like the population size to 500; and the steps to 60 by doing:; <pre>; ROOT::Math::MinimizerOptions::Default(""Genetic"").SetValue(""PopSize"",500);; ROOT::Math::MinimizerOptions::Default(""Genetic"").SetValue(""Steps"",60);; </pre>. END_HTML. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genetic/doc/index.txt:362,plugin,plugin,362,math/genetic/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genetic/doc/index.txt,1,['plugin'],['plugin']
Modifiability,"This directory contains three utilities for fuzzing Clang: clang-fuzzer,; clang-objc-fuzzer, and clang-proto-fuzzer. All use libFuzzer to generate inputs; to clang via coverage-guided mutation. The three utilities differ, however, in how they structure inputs to Clang.; clang-fuzzer makes no attempt to generate valid C++ programs and is therefore; primarily useful for stressing the surface layers of Clang (i.e. lexer, parser). clang-objc-fuzzer is similar but for Objective-C: it makes no attempt to; generate a valid Objective-C program. clang-proto-fuzzer uses a protobuf class to describe a subset of the C++; language and then uses libprotobuf-mutator to mutate instantiations of that; class, producing valid C++ programs in the process. As a result,; clang-proto-fuzzer is better at stressing deeper layers of Clang and LLVM. Some of the fuzzers have example corpuses inside the corpus_examples directory. ===================================; Building clang-fuzzer; ===================================; Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address. Then build the clang-fuzzer target. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZE_COVERAGE=YES -DLLVM_USE_SANITIZER=Address; ninja clang-fuzzer. ======================; Running clang-fuzzer; ======================; bin/clang-fuzzer CORPUS_DIR. ===================================; Building clang-objc-fuzzer; ===================================; Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address. Then build the clang-objc-fuzzer target. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt:393,layers,layers,393,interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,2,['layers'],['layers']
Modifiability,"This file is a partial list of people who have contributed to the LLVM; project. If you have contributed a patch or made some other contribution to; LLVM, please submit a patch to this file to add yourself, and it will be; done!. The list is sorted by surname and formatted to allow easy grepping and; beautification by scripts. The fields are: name (N), email (E), web-address; (W), PGP key ID and fingerprint (P), description (D), snail-mail address; (S), and (I) IRC handle. N: Vikram Adve; E: vadve@cs.uiuc.edu; W: http://www.cs.uiuc.edu/~vadve/; D: The Sparc64 backend, provider of much wisdom, and motivator for LLVM. N: Owen Anderson; E: resistor@mac.com; D: LCSSA pass and related LoopUnswitch work; D: GVNPRE pass, DataLayout refactoring, random improvements. N: Henrik Bach; D: MingW Win32 API portability layer. N: Aaron Ballman; E: aaron@aaronballman.com; D: Clang frontend, frontend attributes, Windows support, general bug fixing; I: AaronBallman. N: Alexey Bataev; E: a.bataev@outlook.com; D: Clang frontend, OpenMP in clang, SLP vectorizer, Loop vectorizer, InstCombine; I: ABataev. N: Nate Begeman; E: natebegeman@mac.com; D: PowerPC backend developer; D: Target-independent code generator and analysis improvements. N: Daniel Berlin; E: dberlin@dberlin.org; D: ET-Forest implementation.; D: Sparse bitmap. N: Geoff Berry; E: gberry@codeaurora.org; E: gcb@acm.org; D: AArch64 backend improvements; D: Added EarlyCSE MemorySSA support; D: CodeGen improvements. N: David Blaikie; E: dblaikie@gmail.com; D: General bug fixing/fit & finish, mostly in Clang. N: Neil Booth; E: neil@daikokuya.co.uk; D: APFloat implementation. N: Alex Bradbury; E: asb@igalia.com; D: RISC-V backend. N: Misha Brukman; E: brukman+llvm@uiuc.edu; W: http://misha.brukman.net; D: Portions of X86 and Sparc JIT compilers, PowerPC backend; D: Incremental bitcode loader. N: Cameron Buschardt; E: buschard@uiuc.edu; D: The `mem2reg' pass - promotes values stored in memory to registers. N: Brendon Cahoon; E: bcaho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:735,refactor,refactoring,735,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,2,"['portab', 'refactor']","['portability', 'refactoring']"
Modifiability,"This is a simple example demonstrating how to use clang's facility for; providing AST consumers using a plugin. Build the plugin by running `make` in this directory. Once the plugin is built, you can run it using:; --; Linux:; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.so -plugin print-fns some-input-file.c; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.so -plugin print-fns -plugin-arg-print-fns help -plugin-arg-print-fns --example-argument some-input-file.c; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.so -plugin print-fns -plugin-arg-print-fns -an-error some-input-file.c. Mac:; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.dylib -plugin print-fns some-input-file.c; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.dylib -plugin print-fns -plugin-arg-print-fns help -plugin-arg-print-fns --example-argument some-input-file.c; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.dylib -plugin print-fns -plugin-arg-print-fns -an-error some-input-file.c; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/PrintFunctionNames/README.txt:104,plugin,plugin,104,interpreter/llvm-project/clang/examples/PrintFunctionNames/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/PrintFunctionNames/README.txt,15,['plugin'],"['plugin', 'plugin-arg-print-fns']"
Modifiability,"This is the Minuit2 fitter standalone extractor, from the [ROOT] toolkit. It uses [CMake] 3.1+ to build.; See `README.md` for information about building Minuit2. ## Extracting from the ROOT source. To extract, run the following commands from the `math/minuit2/build` directory:. ```bash; cmake .. -Dminuit2_standalone=ON; ```. This will fill in the `math/minuit2` directory with all the files needed for Minuit2, copied from the corresponding ROOT files, as part of the configure step.; At this point, you could continue to build (using `make`). Note that the CMake option `minuit2_inroot` will automatically be set to `ON` if you are inside the ROOT source tree. Setting `minuit2_standalone` requires that this be inside the ROOT source tree. As always, any manual setting of a cached variable in CMake will be remembered as long as the `CMakeCache.txt` file is not removed. Remember that after building a tarball or a binary package you should remove the copied files using:. ```bash; make purge; ```. Otherwise git shows the file as untracked, unless you explicitly remove their tracking yourself with a .gitignore file. ## Building a tarball. Minuit2 standalone also has support for CPack to make installers for different platforms. To build a source package:. ```bash; make package_source; ```. This will create a source file in several formats that you can distribute. Reminder: You **must** have used `-Dminuit2_standalone=ON` when you configured CMake, or many of the files will be missing. ## Building a binary. To build a binary package (add other generators with `-G`):; ```bash; make; make package; ```. ## Maintenance. If new files are needed by Minuit2 due to additions to [ROOT], they should be added to the source files lists in `src/Math/CMakeLists.txt` and `src/Minuit2/CMakeLists.txt` (depending on if it's a new Math or Minuit2 requirement). For testing, the main `test/CMakeLists.txt` is used by ROOT, and the `test/*/CMakeLists.txt` files are used by the standalone build. ## How",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/DEVELOP.md:470,config,configure,470,math/minuit2/DEVELOP.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/DEVELOP.md,2,"['config', 'variab']","['configure', 'variable']"
Modifiability,"Tips.html>`_ recommends; this. Optimizations benefit from knowing about the target and data; layout. .. code-block:: c++. TheModule->setDataLayout(TargetMachine->createDataLayout());; TheModule->setTargetTriple(TargetTriple);. Emit Object Code; ================. We're ready to emit object code! Let's define where we want to write; our file to:. .. code-block:: c++. auto Filename = ""output.o"";; std::error_code EC;; raw_fd_ostream dest(Filename, EC, sys::fs::OF_None);. if (EC) {; errs() << ""Could not open file: "" << EC.message();; return 1;; }. Finally, we define a pass that emits object code, then we run that; pass:. .. code-block:: c++. legacy::PassManager pass;; auto FileType = CodeGenFileType::ObjectFile;. if (TargetMachine->addPassesToEmitFile(pass, dest, nullptr, FileType)) {; errs() << ""TargetMachine can't emit a file of this type"";; return 1;; }. pass.run(*TheModule);; dest.flush();. Putting It All Together; =======================. Does it work? Let's give it a try. We need to compile our code, but; note that the arguments to ``llvm-config`` are different to the previous chapters. ::. $ clang++ -g -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs all` -o toy. Let's run it, and define a simple ``average`` function. Press Ctrl-D; when you're done. ::. $ ./toy; ready> def average(x y) (x + y) * 0.5;; ^D; Wrote output.o. We have an object file! To test it, let's write a simple program and; link it with our output. Here's the source code:. .. code-block:: c++. #include <iostream>. extern ""C"" {; double average(double, double);; }. int main() {; std::cout << ""average of 3.0 and 4.0: "" << average(3.0, 4.0) << std::endl;; }. We link our program to output.o and check the result is what we; expected:. ::. $ clang++ main.cpp output.o -o main; $ ./main; average of 3.0 and 4.0: 3.5. Full Code Listing; =================. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter8/toy.cpp; :language: c++. `Next: Adding Debug Information <LangImpl09.html>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst:4673,config,config,4673,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,2,['config'],['config']
Modifiability,"To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've been somewhat vague in our; explanation of what the rewrite rules are actually rewriting. We've referred to; ""code"", but code can be represented both as raw source text and as an abstract; syntax tree. So, which one is it?. Ideally, we'd be rewriting the input AST to a new AST, but clang's AST is not; terribly amenable to this kind of transformation. So, we compromise: we express; our patterns and the names that they bind in terms of the AST, but our changes; in terms of source code text. We've designed Transformer's language to bridge; the gap between the two representations, in an attempt to minimize the user's; need to reason about source code locations and other, low-level syntactic; details. Range Selectors; ^^^^^^^^^^^^^^^. Transformer provides a small API for describing source ranges: the; ``RangeSelector`` combinators. These ranges are most c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:9289,rewrite,rewrite,9289,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,"ToCodeBody(resName + "" += "" + weightSumName + "" * std::log("" + simCountStr + "");\n"");; }; ... }; ```. > Source: - [RooNLLVarNew](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooNLLVarNew.cxx). The complexity of the `RooNLLVarNew::translate()` function in this example can; be attributed to the more complex scenarios/operations specific to the; computation of negative log-likelihood (NLL) values for probability density; functions (PDFs) in RooFit, especially for simultaneous fits (multiple; simultaneous PDFs being considered) and binned likelihoods (adding further; complexity). In this example, the `RooNLLVarNew::translate()` function generates code to; compute the Negative Log likelihood (NLL). We can see that the intermediate; result variable `resName` is added to the context so that it can be accessed; and used in the generated code. This variable is made available globally; (using `addToGlobalScope()`). If a weight sum is needed, then it creates a loop, and `weightSumName` is; accumulated with the weight variable. Otherwise, if there are multiple; simultaneous PDFs, then it adds a term to the result that scales with the; logarithm of the count of simultaneous PDFs. The rest of the function body; (including the loop scope with NLL computation) has omitted from this example; to keep it brief. Helper functions:. - `makeValidVarName()` helps get a valid name from the name of the respective; RooFit class. It then helps save it to the variable that represents the result; of this class (the squashed code/ C++ function that will be created). - `addToGlobalScope()` helps declare and initialize the results variable, so; that it can be available globally (throughout the function body). For local; variables, the `addToCodeBody()` function can be used to keep the variables in; the respective scope (for example, within a loop). - `beginLoop()` helps build the start and the end of a For loop for your; class. Simply place this function in the scope and pl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:16820,variab,variable,16820,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['variab'],['variable']
Modifiability,"ToUseJIT.o -c HowToUseJIT.cpp; g++ `llvm-config --ldflags` -o HowToUseJIT HowToUseJIT.o \; `llvm-config --libs engine bcreader scalaropts`. OPTIONS; -------. **--assertion-mode**. Print the assertion mode used when LLVM was built (ON or OFF). **--bindir**. Print the installation directory for LLVM binaries. **--build-mode**. Print the build mode used when LLVM was built (e.g. Debug or Release). **--build-system**. Print the build system used to build LLVM (e.g. `cmake` or `gn`). **--cflags**. Print the C compiler flags needed to use LLVM headers. **--cmakedir**. Print the installation directory for LLVM CMake modules. **--components**. Print all valid component names. **--cppflags**. Print the C preprocessor flags needed to use LLVM headers. **--cxxflags**. Print the C++ compiler flags needed to use LLVM headers. **--has-rtti**. Print whether or not LLVM was built with rtti (YES or NO). **--help**. Print a summary of **llvm-config** arguments. **--host-target**. Print the target triple used to configure LLVM. **--ignore-libllvm**. Ignore libLLVM and link component libraries instead. **--includedir**. Print the installation directory for LLVM headers. **--ldflags**. Print the flags needed to link against LLVM libraries. **--libdir**. Print the installation directory for LLVM libraries. **--libfiles**. Similar to **--libs**, but print the full path to each library file. This is; useful when creating makefile dependencies, to ensure that a tool is relinked if; any library it uses changes. **--libnames**. Similar to **--libs**, but prints the bare filenames of the libraries; without **-l** or pathnames. Useful for linking against a not-yet-installed; copy of LLVM. **--libs**. Print all the libraries needed to link against the specified LLVM; *components*, including any dependencies. **--link-shared**. Link the components as shared libraries. **--link-static**. Link the component libraries statically. **--obj-root**. Print the object root used to build LLVM. **--prefix**",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst:1485,config,configure,1485,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,1,['config'],['configure']
Modifiability,"Tracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression). This intrinsic marks the position in IR where a source assignment occurred. It; encodes the value of the variable. It references the store, if any, that; performs the assignment, and the destination address. The first three arguments are the same as for an ``llvm.dbg.value``. The fourth; argument is a ``DIAssignID`` used to reference a store. The fifth is the; destination of the store (wrapped as metadata), and the sixth is a `complex; expression <LangRef.html#diexpression>`_ that modifies it. The formal LLVM-IR signature is:. .. code-block:: llvm. void @llvm.dbg.assign(metadata, metadata, metadata, metadata, metadata, metadata). See :doc:`AssignmentTracking` for more info. Object lifetimes and scoping; ============================. In many languages, the local variables in functions can have their lifetimes or; scopes limited to a subset of a function. In the C family of languages, for; example, variables are only live (readable and writable) within the source; block that they are defined in. In functional languages, values are only; readable after they have been defined. Though this is a very obvious concept,; it is non-trivial to model in LLVM, because it has no notion of scoping in this; sense, and does not want to be tied to a language's scoping rules. In order to handle this, the LLVM debug format uses the metadata attached to; llvm instructions to encode line number and scoping information. Consider the; following C fragment, for example:. .. code-block:: c. 1. void foo() {; 2. int X = 21;; 3. int Y = 22;; 4. {; 5. int Z = 23;; 6. Z = X;; 7. }; 8. X = Y;; 9. }. Compiled to LLVM, this function would be represented like this:. .. code-block:: text. ; Function Attrs: nounwind ssp uwtable; define void @foo() #0 !dbg !4 {; entry:; %X = alloca i32, align 4; %Y = alloca i32",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:11934,variab,variables,11934,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"Tree (AST). Since clang's AST includes complete type information; (within the limits of single `Translation Unit (TU)`_,; these patterns can even encode rich constraints on the type properties of AST; nodes. .. _`Translation Unit (TU)`: https://en.wikipedia.org/wiki/Translation_unit_\(programming\). We assume a familiarity with the clang AST and the corresponding AST matchers; for the purpose of this tutorial. Users who are unfamiliar with either are; encouraged to start with the recommended references in `Related Reading`_. Example: style-checking names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which forbids functions from being named; ""MkX"" and you want to write a check that catches any violations of this rule. We; can express this a Transformer rewrite rule:. .. code-block:: c++. makeRule(functionDecl(hasName(""MkX"").bind(""fun""),; 	 noopEdit(node(""fun"")),; 	 cat(""The name ``MkX`` is not allowed for functions; please rename""));. ``makeRule`` is our go-to function for generating rewrite rules. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that the result of ``makeRule`` is a value of type; ``clang::transformer::RewriteRule``, but most users don't need to care about the; details of this type. Example: renaming a function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now, let's extend ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:3456,rewrite,rewrite,3456,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,"UILD_ARCHIVE``. By default, a library is a ``.o`` file that is linked directly into a; program. To build an archive (also known as a static library), set the; ``BUILD_ARCHIVE`` variable. ``SHARED_LIBRARY``. If ``SHARED_LIBRARY`` is defined in your Makefile, a shared (or dynamic); library will be built. Variables for Building Programs; -------------------------------. ``TOOLNAME``. This variable contains the name of the program that will be built. For; example, to build an executable named ``sample``, ``TOOLNAME`` should be set; to ``sample``. ``USEDLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be libraries that come from; your **lib** directory. The libraries must be specified without their; ``lib`` prefix. For example, to link ``libsample.a``, you would set; ``USEDLIBS`` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. Note that this works only for statically linked libraries. LLVM is split; into a large number of static libraries, and the list of libraries you; require may be much longer than the list above. To see a full list of; libraries use: ``llvm-config --libs all``. Using ``LINK_COMPONENTS`` as; described below, obviates the need to set ``LLVMLIBS``. ``LINK_COMPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:6466,variab,variable,6466,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,1,['variab'],['variable']
Modifiability,UITE_BENCHMARKING_ONLY` CMake; option to `ON` will disable them. Configuration; -------------. The test-suite has configuration options to customize building and running the; benchmarks. CMake can print a list of them:. ```bash; % cd test-suite-build; # Print basic options:; % cmake -LH; # Print all options:; % cmake -LAH; ```. ### Common Configuration Options. - `CMAKE_C_FLAGS`. Specify extra flags to be passed to C compiler invocations. The flags are; also passed to the C++ compiler and linker invocations. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html). - `CMAKE_C_COMPILER`. Select the C compiler executable to be used. Note that the C++ compiler is; inferred automatically i.e. when specifying `path/to/clang` CMake will; automatically use `path/to/clang++` as the C++ compiler. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html). - `CMAKE_Fortran_COMPILER`. Select the Fortran compiler executable to be used. Not set by default and not; required unless running the Fortran Test Suite. - `CMAKE_BUILD_TYPE`. Select a build type like `OPTIMIZE` or `DEBUG` selecting a set of predefined; compiler flags. These flags are applied regardless of the `CMAKE_C_FLAGS`; option and may be changed by modifying `CMAKE_C_FLAGS_OPTIMIZE` etc. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html). - `TEST_SUITE_FORTRAN`. Activate that Fortran tests. This is a work in progress. More information can be; found in the [Flang documentation](https://flang.llvm.org/docs/FortranLLVMTestSuite.html). - `TEST_SUITE_RUN_UNDER`. Prefix test invocations with the given tool. This is typically used to run; cross-compiled tests within a simulator tool. - `TEST_SUITE_BENCHMARKING_ONLY`. Disable tests that are unsuitable for performan,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:4648,variab,variable,4648,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['variab'],['variable']
Modifiability,"ULT_PATH). # We need to consider not just the direct link dependencies, but also the; # transitive link dependencies. Do this by starting with the set of direct; # dependencies, then the dependencies of those dependencies, and so on.; set(new_libs ""clingMetaProcessor""); set(link_libs ${new_libs}); while(NOT ""${new_libs}"" STREQUAL """"); foreach(lib ${new_libs}); if(TARGET ${lib}); get_target_property(lib_type ${lib} TYPE); if(""${lib_type}"" STREQUAL ""STATIC_LIBRARY""); list(APPEND static_libs ${lib}); else(); list(APPEND other_libs ${lib}); endif(); get_target_property(transitive_libs ${lib} INTERFACE_LINK_LIBRARIES); if (NOT transitive_libs); continue(); endif(); foreach(transitive_lib ${transitive_libs}); list(FIND link_libs ${transitive_lib} idx); #if(TARGET ${transitive_lib} AND idx EQUAL -1); if(idx EQUAL -1); list(APPEND newer_libs ${transitive_lib}); list(APPEND link_libs ${transitive_lib}); endif(); endforeach(transitive_lib); endif(); endforeach(lib); set(new_libs ${newer_libs}); set(newer_libs """"); endwhile(); set(CLING_DEPEND_LIBS ${link_libs} CACHE STRING """"); endif(builtin_cling). #---Avoid to dependencies to system (e.g. atomic) libraries without modifying the LLVM code----------; if(CMAKE_SYSTEM_NAME STREQUAL Darwin); get_target_property(__libs LLVMSupport INTERFACE_LINK_LIBRARIES); list(REMOVE_ITEM __libs atomic); set_target_properties(LLVMSupport PROPERTIES INTERFACE_LINK_LIBRARIES ""${__libs}""); endif(). #---Mark the LLVM/CLANG variables as advanced--------------------------------------------------------; get_cmake_property(variables CACHE_VARIABLES); foreach(var ${variables}); if(var MATCHES ""^(CLANG|LLVM|CLING)_""); mark_as_advanced(FORCE ${var}); endif(); endforeach(); mark_as_advanced(FORCE BUG_REPORT_URL BUILD_CLANG_FORMAT_VS_PLUGIN BUILD_SHARED_LIBS BUILD_TESTING; C_INCLUDE_DIRS DEFAULT_SYSROOT FFI_INCLUDE_DIR FFI_LIBRARY_DIR; GCC_INSTALL_PREFIX LIBCLANG_BUILD_STATIC TOOL_INFO_PLIST); mark_as_advanced(CLEAR LLVM_ENABLE_ASSERTIONS LLVM_BUILD_TYPE); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:24552,variab,variables,24552,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,3,['variab'],['variables']
Modifiability,"UNTIMES requests ${proj} but directory not found: ${proj_dir}""); endif(); string(TOUPPER ""${proj}"" canon_name); STRING(REGEX REPLACE ""-"" ""_"" canon_name ${canon_name}); set(LLVM_EXTERNAL_${canon_name}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../../${proj}""); endforeach(). function(get_compiler_rt_path path); foreach(entry ${runtimes}); get_filename_component(projName ${entry} NAME); if(""${projName}"" MATCHES ""compiler-rt""); set(${path} ${entry} PARENT_SCOPE); return(); endif(); endforeach(); endfunction(). include(LLVMExternalProjectUtils). if(NOT LLVM_BUILD_RUNTIMES); set(EXTRA_ARGS EXCLUDE_FROM_ALL); endif(). function(check_apple_target triple builtin_or_runtime); set(error ""\; compiler-rt for Darwin builds for all platforms and architectures using a \; single configuration. Specify only a single darwin triple (e.g. x86_64-apple-darwin) \; in your targets list (and not a triple for a specific platform such as macos). \; You can use variables such as COMPILER_RT_ENABLE_IOS and DARWIN_ios_ARCHS to \; control the specific platforms and architectures to build.""). set(seen_property ${builtin_or_runtime}_darwin_triple_seen); string(REPLACE ""-"" "";"" triple_components ${triple}); foreach(component ${triple_components}); string(TOLOWER ""${component}"" component_lower); if(component_lower MATCHES ""^darwin""); get_property(darwin_triple_seen GLOBAL PROPERTY ${seen_property}); if(darwin_triple_seen); message(FATAL_ERROR ""${error}""); endif(); set_property(GLOBAL PROPERTY ${seen_property} YES); if(NOT RUNTIMES_BUILD_ALLOW_DARWIN); message(FATAL_ERROR ""\; ${error} Set RUNTIMES_BUILD_ALLOW_DARWIN to allow a single darwin triple.""); endif(); elseif(component_lower MATCHES ""^ios|^macos|^tvos|^watchos""); message(FATAL_ERROR ""${error}""); endif(); endforeach(); endfunction(). macro(set_enable_per_target_runtime_dir); # May have been set by llvm/CMakeLists.txt.; if (NOT DEFINED LLVM_ENABLE_PER_TARGET_RUNTIME_DIR); # AIX should fold 32-bit & 64-bit arch libraries into a single archive.; if (L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:1523,variab,variables,1523,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,1,['variab'],['variables']
Modifiability,"Used Technology; ---------------. `LLVM <https://llvm.org/>`_ is a free, open-source compiler infrastructure under; the `Apache License 2.0 <https://www.apache.org/licenses/LICENSE-2.0>`_. It is; designed as a collection of tools including Front Ends parsers, Middle Ends; optimizers, and Back Ends to produce machine code out of those programs. `Clang <https://clang.llvm.org/>`_ is a front-end that uses a LLVM; license. Clang works by taking the source language (e.g. C++) and translating it; into an intermediate representation that is then received by the compiler back; end (i.e., the LLVM backend). Its library-based architecture makes it relatively; easy to adapt Clang and build new tools based on it. Cling inherits a number of; features from LLVM and Clang, such as: fast compiling and low memory use,; efficient C++ parsing, extremely clear and concise diagnostics, Just-In-Time; compilation, pluggable optimizers, and support for `GCC <https://gcc.gnu.org/>`_; extensions. Interpreters allow for exploration of software development at the rate of human; thought. Nevertheless, interpreter code can be slower than compiled code due to; the fact that translating code at run time adds to the overhead and therefore; causes the execution speed to be slower. This issue is overcome by exploiting; the *Just-In-Time* (`JIT; <https://en.wikipedia.org/wiki/Just-in-time_compilation>`_) compilation method,; which allows an efficient memory management (for example, by evaluating whether; a certain part of the source code is executed often, and then compile this part,; therefore reducing the overall execution time). With the JIT approach, the developer types the code in Cling's command; prompt. The input code is then lowered to Clang, where is compiled and; eventually transformed in order to attach specific behavior. Clang compiles then; the input into an AST representation, that is then lowered to LLVM IR, an; `intermediate language; <https://en.wikipedia.org/wiki/Common_Intermediate_L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/implementation.rst:666,adapt,adapt,666,interpreter/cling/docs/chapters/implementation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/implementation.rst,2,"['adapt', 'inherit']","['adapt', 'inherits']"
Modifiability,"Using the Virtual Analysis Facility; ===================================. Introduction; ------------. The Virtual Analysis Facility can be easily used by having installed on; your client the following software:. - [ROOT](http://root.cern.ch/). - [PROOF on Demand](http://pod.gsi.de/). - The VAF client *(see below)*: a convenience tool that sets up the; environment for your experiment's software both on your client and; on the PROOF worker nodes. > If you are the end user, you'll probably might skip the part that; > concerns how to configure the VAF client: your system administrator; > has probably and conveniently set it up for you. The Virtual Analysis Facility client; ------------------------------------. The Virtual Analysis Facility client takes care of setting the; environment for the end user required by your software's experiment. The; environment will both be set on the client and on each PROOF node. Technically it is a Bash shell script which provides shortcuts for PROOF; on Demand commands and ensures local and remote environment consistency:; by executing it you enter a new clean environment where all your; software dependencies have already been set up. Local and remote environment configuration is split into a series of; files, which give the possibility to:. - have a system-wide, sysadmin-provided experiment configuration. - execute user actions either *before* or *after* the execution of the; system-wide script (for instance, choosing the preferred version of; the experiment's software). - transfer a custom user **payload** on each PROOF worker (for instance,; user's client-generated Grid credentials to make PROOF workers; capable of accessing a remote authenticated storage). Configuration files are searched for in two different locations:. - a system-wide directory: `<client_install_dir>/etc`. - user's home directory: `~/.vaf`. > A system-wide configuration file always has precedence over user's; > configuration. It is thus possible for the sysadmin to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:536,config,configure,536,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['config'],['configure']
Modifiability,"VAR`` record (code 7) marks the declaration or definition of a; global variable. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the global variable.; See `STRTAB_BLOCK Contents`_. * *pointer type*: The type index of the pointer type used to point to this; global variable. * *isconst*: Non-zero if the variable is treated as constant within the module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: An encoding of the linkage type for this variable:. * ``external``: code 0; * ``weak``: code 1; * ``appending``: code 2; * ``internal``: code 3; * ``linkonce``: code 4; * ``dllimport``: code 5; * ``dllexport``: code 6; * ``extern_weak``: code 7; * ``common``: code 8; * ``private``: code 9; * ``weak_odr``: code 10; * ``linkonce_odr``: code 11; * ``available_externally``: code 12; * deprecated : code 13; * deprecated : code 14. * alignment*: The logarithm base 2 of the variable's requested alignment, plus 1. * *section*: If non-zero, the 1-based section index in the table of; `MODULE_CODE_SECTIONNAME`_ entries. .. _visibility:. * *visibility*: If present, an encoding of the visibility of this variable:. * ``default``: code 0; * ``hidden``: code 1; * ``protected``: code 2. .. _bcthreadlocal:. * *threadlocal*: If present, an encoding of the thread local storage mode of the; variable:. * ``not thread local``: code 0; * ``thread local; default TLS model``: code 1; * ``localdynamic``: code 2; * ``initialexec``: code 3; * ``localexec``: code 4. .. _bcunnamedaddr:. * *unnamed_addr*: If present, an encoding of the ``unnamed_addr`` attribute of this; variable:. * not ``unnamed_addr``: code 0; * ``unnamed_addr``: code 1; * ``local_unnamed_addr``: code 2. .. _bcdllstorageclass:. * *dllstorageclass*: If present, an encoding of the DLL storage class of this variable:. * ``default``: code 0; * ``dllimport``: code 1; * ``dllexport``: code 2. * *comdat*: An encodi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:28229,variab,variable,28229,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"VC_IDE ); message(FATAL_ERROR ""In-source builds are not allowed.; Please create a directory and run cmake from there, passing the path; to this source directory as the last argument.; This process created the file `CMakeCache.txt' and the directory `CMakeFiles'.; Please delete them.""); endif(). string(TOUPPER ""${CMAKE_BUILD_TYPE}"" uppercase_CMAKE_BUILD_TYPE). option(LLVM_ADDITIONAL_BUILD_TYPES ""Additional build types that are allowed to be passed into CMAKE_BUILD_TYPE"" """"). set(ALLOWED_BUILD_TYPES DEBUG RELEASE RELWITHDEBINFO MINSIZEREL ${LLVM_ADDITIONAL_BUILD_TYPES}); string (REPLACE "";"" ""|"" ALLOWED_BUILD_TYPES_STRING ""${ALLOWED_BUILD_TYPES}""); string (TOUPPER ""${ALLOWED_BUILD_TYPES_STRING}"" uppercase_ALLOWED_BUILD_TYPES). if (CMAKE_BUILD_TYPE AND; NOT uppercase_CMAKE_BUILD_TYPE MATCHES ""^(${uppercase_ALLOWED_BUILD_TYPES})$""); message(FATAL_ERROR ""Unknown value for CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}""); endif(). # LLVM_INSTALL_PACKAGE_DIR needs to be declared prior to adding the tools; # subdirectory in order to have the value available for llvm-config.; include(GNUInstallPackageDir); set(LLVM_INSTALL_PACKAGE_DIR ""${CMAKE_INSTALL_PACKAGEDIR}/llvm"" CACHE STRING; ""Path for CMake subdirectory for LLVM (defaults to '${CMAKE_INSTALL_PACKAGEDIR}/llvm')""). set(LLVM_TOOLS_INSTALL_DIR ""${CMAKE_INSTALL_BINDIR}"" CACHE STRING; ""Path for binary subdirectory (defaults to '${CMAKE_INSTALL_BINDIR}')""); mark_as_advanced(LLVM_TOOLS_INSTALL_DIR). set(LLVM_UTILS_INSTALL_DIR ""${LLVM_TOOLS_INSTALL_DIR}"" CACHE STRING; ""Path to install LLVM utilities (enabled by LLVM_INSTALL_UTILS=ON) (defaults to LLVM_TOOLS_INSTALL_DIR)""); mark_as_advanced(LLVM_UTILS_INSTALL_DIR). set(LLVM_EXAMPLES_INSTALL_DIR ""examples"" CACHE STRING; ""Path for examples subdirectory (enabled by LLVM_BUILD_EXAMPLES=ON) (defaults to 'examples')""); mark_as_advanced(LLVM_EXAMPLES_INSTALL_DIR). # They are used as destination of target generators.; set(LLVM_RUNTIME_OUTPUT_INTDIR ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:18049,config,config,18049,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config']
Modifiability,"VF.Width, IC,; &LVL, &CM);. Many other coding guidelines [LLDB]_ [Google]_ [WebKit]_ [Qt]_ [Rust]_ [Swift]_; [Python]_ require that variable names begin with a lower case letter in contrast; to class names which begin with a capital letter. This convention means that the; most readable variable name also requires the least thought::. Triple triple;. There is some agreement that the current rule is broken [LattnerAgree]_; [ArsenaultAgree]_ [RobinsonAgree]_ and that acronyms are an obstacle to reading; new code [MalyutinDistinguish]_ [CarruthAcronym]_ [PicusAcronym]_. There are; some opposing views [ParzyszekAcronym2]_ [RicciAcronyms]_. This work-in-progress proposal is to change the coding standard for variable; names to require that they start with a lower case letter. .. [*] In `some cases; <https://github.com/llvm/llvm-project/blob/8b72080d4d7b13072f371712eed333f987b7a18e/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp#L2727>`_; the type name *is* reused as a variable name, but this shadows the type name; and confuses many debuggers [DenisovCamelBack]_. Variable Names Coding Standard Options; ======================================. There are two main options for variable names that begin with a lower case; letter: ``camelBack`` and ``lower_case``. (These are also known by other names; but here we use the terminology from clang-tidy). ``camelBack`` is consistent with [WebKit]_, [Qt]_ and [Swift]_ while; ``lower_case`` is consistent with [LLDB]_, [Google]_, [Rust]_ and [Python]_. ``camelBack`` is already used for function names, which may be considered an; advantage [LattnerFunction]_ or a disadvantage [CarruthFunction]_. Approval for ``camelBack`` was expressed by [DenisovCamelBack]_; [LattnerFunction]_ [IvanovicDistinguish]_.; Opposition to ``camelBack`` was expressed by [CarruthCamelBack]_; [TurnerCamelBack]_.; Approval for ``lower_case`` was expressed by [CarruthLower]_; [CarruthCamelBack]_ [TurnerLLDB]_.; Opposition to ``lower_case`` was expressed by [LattnerLow",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:2639,variab,variable,2639,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability,"VM IR can have a wide variety of tools; applied to it. For example, you can run optimizations on it (as we did; above), you can dump it out in textual or binary forms, you can compile; the code to an assembly file (.s) for some target, or you can JIT; compile it. The nice thing about the LLVM IR representation is that it; is the ""common currency"" between many different parts of the compiler. In this section, we'll add JIT compiler support to our interpreter. The; basic idea that we want for Kaleidoscope is to have the user enter; function bodies as they do now, but immediately evaluate the top-level; expressions they type in. For example, if they type in ""1 + 2;"", we; should evaluate and print out 3. If they define a function, they should; be able to call it from the command line. In order to do this, we first prepare the environment to create code for; the current native target and declare and initialize the JIT. This is; done by calling some ``InitializeNativeTarget\*`` functions and; adding a global variable ``TheJIT``, and initializing it in; ``main``:. .. code-block:: c++. static std::unique_ptr<KaleidoscopeJIT> TheJIT;; ...; int main() {; InitializeNativeTarget();; InitializeNativeTargetAsmPrinter();; InitializeNativeTargetAsmParser();. // Install standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;; BinopPrecedence['*'] = 40; // highest. // Prime the first token.; fprintf(stderr, ""ready> "");; getNextToken();. TheJIT = std::make_unique<KaleidoscopeJIT>();. // Run the main ""interpreter loop"" now.; MainLoop();. return 0;; }. We also need to setup the data layout for the JIT:. .. code-block:: c++. void InitializeModuleAndPassManager(void) {; // Open a new context and module.; TheContext = std::make_unique<LLVMContext>();; TheModule = std::make_unique<Module>(""my cool jit"", TheContext);; TheModule->setDataLayout(TheJIT->getDataLayout());. // Create a new builder for the module.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:10649,variab,variable,10649,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['variab'],['variable']
Modifiability,VM IR. .. option:: -gen-llvmir-conversions. Generate LLVM IR conversions. .. option:: -gen-llvmir-intrinsics. Generate LLVM IR intrinsics. .. option:: -llvmir-intrinsics-filter. Only keep the intrinsics with the specified substring in their record name. .. option:: -dialect-opclass-base. The base class for the ops in the dialect we are to emit. .. option:: -gen-op-decls. Generate operation declarations. .. option:: -gen-op-defs. Generate operation definitions. .. option:: -asmformat-error-is-fatal. Emit a fatal error if format parsing fails. .. option:: -op-exclude-regex. Regular expression of name of ops to exclude (no filter if empty). .. option:: -op-include-regex. Regular expression of name of ops to include (no filter if empty). .. option:: -gen-op-doc. Generate operation documentation. .. option:: -gen-pass-decls. Generate operation documentation. .. option:: -name namestring. The name of this group of passes. .. option:: -gen-pass-doc. Generate pass documentation. .. option:: -gen-rewriters. Generate pattern rewriters. .. option:: -gen-spirv-avail-impls. Generate SPIR-V operation utility definitions. .. option:: -gen-spirv-capability-implication. Generate utility function to return implied capabilities for a given capability. .. option:: -gen-spirv-enum-avail-decls. Generate SPIR-V enum availability declarations. .. option:: -gen-spirv-enum-avail-defs. Generate SPIR-V enum availability definitions. .. option:: -gen-spirv-op-utils. Generate SPIR-V operation utility definitions. .. option:: -gen-spirv-serialization. Generate SPIR-V (de)serialization utilities and functions. .. option:: -gen-struct-attr-decls. Generate struct utility declarations. .. option:: -gen-struct-attr-defs. Generate struct utility definitions. .. option:: -gen-typedef-decls. Generate TypeDef declarations. .. option:: -gen-typedef-defs. Generate TypeDef definitions. .. option:: -typedefs-dialect name. Generate types for this dialect. EXIT STATUS; -----------. If :program:`*-tblgen` succeed,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst:14539,rewrite,rewriters,14539,interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,1,['rewrite'],['rewriters']
Modifiability,"Val) {; io.mapOptional(""Foo"", Val.Foo);; io.mapOptional(""Bar"", Val.Bar);; }; };. No Normalization; ----------------. The ``mapping()`` method is responsible, if needed, for normalizing and; denormalizing. In a simple case where the native data structure requires no; normalization, the mapping method just uses mapOptional() or mapRequired() to; bind the struct's fields to YAML key names. For example:. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. template <>; struct MappingTraits<Person> {; static void mapping(IO &io, Person &info) {; io.mapRequired(""name"", info.name);; io.mapOptional(""hat-size"", info.hatSize);; }; };. Normalization; ----------------. When [de]normalization is required, the mapping() method needs a way to access; normalized values as fields. To help with this, there is; a template MappingNormalization<> which you can then use to automatically; do the normalization and denormalization. The template is used to create; a local variable in your mapping() method which contains the normalized keys. Suppose you have native data type; Polar which specifies a position in polar coordinates (distance, angle):. .. code-block:: c++. struct Polar {; float distance;; float angle;; };. but you've decided the normalized YAML for should be in x,y coordinates. That; is, you want the yaml to look like:. .. code-block:: yaml. x: 10.3; y: -4.7. You can support this by defining a MappingTraits that normalizes the polar; coordinates to x,y coordinates when writing YAML and denormalizes x,y; coordinates into polar when reading YAML. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. template <>; struct MappingTraits<Polar> {. class NormalizedPolar {; public:; NormalizedPolar(IO &io); : x(0.0), y(0.0) {; }; NormalizedPolar(IO &, Polar &polar); : x(polar.distance * cos(polar.angle)),; y(polar.distance * sin(polar.angle)) {; }; Polar denormalize(IO &) {; return Polar(sqrt(x*x+y*y), arctan(x,y));; }. float x;; float y;; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:17409,variab,variable,17409,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['variab'],['variable']
Modifiability,"Valentine](palette_106.png); ![VisibleSpectrum](palette_107.png); ![WaterMelon](palette_108.png); ![Cool](palette_109.png); ![Copper](palette_110.png); ![GistEart](palette_111.png). ### Interpreter Library. Many, many bugs have been fixed; thanks to everyone who has reported them!. #### Cling. Cling is now using a new just-in-time compilation engine called OrcJIT, a development based on MCJIT. It enables interpretation of inline assembly and exceptions; it will hopefully in the near future also support interpreting thread local storage (but doesn't at the moment). Thanks to the new JIT, cling also comes with debug symbols for interpreted code; you can enable them with "".debug"". #### Function evaluation. Function calls through TMethodCall etc have been accelerated. #### llvm / clang. llvm / clang were updated to r227800. This includes everything from the clang 3.6 release. ### Dictionary Generation. Detect usage of #pragma once for inlined headers. Turn on verbosity of genreflex if the VERBOSE environment variable is defined. Optimise forward declarations in rootmap files in order to make their interpretation faster. Propagate attributes specified in xml selection files to selected classes even when selected through typedefs. Optimise selection procedure caching selected declarations in the selection rules, therewith avoiding to query the AST twice. Include in the PCH all the STL and C headers to guarantee portability of binaries from SLC6 to CC7. ## I/O Libraries. ### I/O New functionalities. - Support for forward_list and I/O of unordered stl containers.; - Support for std::complex. ### I/O Behavior change. - The I/O now properly skip the content of base class onfile that have been removed from the in-memory class layout. - The scheduling the I/O customization rules within a StreamerInfo is now as soon as possible, i.e. after all sources have been read. One significant consequence is that now when an object is stored in a split branch; the rule is associtated with t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:7990,variab,variable,7990,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['variab'],['variable']
Modifiability,"Valid : Bool_t *; *Entries : 20 : Total Size= 582 bytes File Size = 92 *; *Baskets : 1 : Basket Size= 16000 bytes Compression= 1.00 *. Add a new function TBranch::SetStatus It is much faster to call this function in case of a Tree with many branches; instead of calling TTree::SetBranchStatus.; Implement TTreeCache::Print that shows information like:; // ******TreeCache statistics for file: cms2.root ******; // Number of branches in the cache ...: 1093; // Cache Efficiency ..................: 0.997372; // Cache Efficiency Rel...............: 1.000000; // Learn entries......................: 100; // Reading............................: 72761843 bytes in 7 transactions; // Readahead..........................: 256000 bytes with overhead = 0 bytes; // Average transaction................: 10394.549000 Kbytes; // Number of blocks in current cache..: 210, total size: 6280352; This function can be called directly from TTree: T->PrintCacheStats();. Add support for variable size array of object in a TTree (when the owner of the array is split.); And many other bug fixes, security fixes, thread safety and performance improvements ; see the svn log for details. TTree Scan and Draw. Insured that the generated histogram as an integral bin width when plotting a string or integer.; Improved the output of TTree::Scan by inserting a blank space whenever a value is not available because there is no proper row in a friend.; (Previously it was re-printing the previous value). This required changes in ; When the draw option to TTree::Draw contains ""norm"" the output histogram is normalized to 1.; Improve the selection of the leaf used for size of an array in a leaflist by giving preference; for the leaf inside the same branch and by adding support for explicit full path name. For example the following now works properly:; tree->Branch(""JET1"", &JET1, ""njets/I:et[njets]/F:pt[njets]/F"");; tree->BranchBranch(""JET2"", &JET2, ""njets/I:et[njets]/F:pt[njets]/F"");; ...; tree->Scan(""njets/I:et[JETS1.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html:6316,variab,variable,6316,tree/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html,1,['variab'],['variable']
Modifiability,"Validation*. Assembler checks if the input value may be truncated; without loss to the required *truncation width* (see the table below).; There are two cases when this operation is enabled:. * The truncated bits are all 0.; * The truncated bits are all 1 and the value after truncation has its MSB bit set. In all other cases, the assembler triggers an error. 2. *Conversion*. The input value is converted to the expected type; as described in the table below. Depending on operand kind, this conversion; is performed by either assembler or AMDGPU H/W (or both). ============== ================= =============== ====================================================================; Expected type Truncation Width Conversion Description; ============== ================= =============== ====================================================================; i16, u16, b16 16 num.u16 Truncate to 16 bits.; i32, u32, b32 32 num.u32 Truncate to 32 bits.; i64 32 {-1,num.i32} Truncate to 32 bits and then sign-extend the result to 64 bits.; u64, b64 32 {0,num.u32} Truncate to 32 bits and then zero-extend the result to 64 bits.; f16 16 num.u16 Use low 16 bits as an f16 value.; f32 32 num.u32 Use low 32 bits as an f32 value.; f64 32 {num.u32,0} Use low 32 bits of the number as high 32 bits; of the result; low 32 bits of the result are zeroed.; ============== ================= =============== ====================================================================. Examples of enabled conversions:. .. parsed-literal::. // GFX9. v_add_u16 v0, -1, 0 // src0 = 0xFFFF; v_add_f16 v0, -1, 0 // src0 = 0xFFFF (NaN); //; v_add_u32 v0, -1, 0 // src0 = 0xFFFFFFFF; v_add_f32 v0, -1, 0 // src0 = 0xFFFFFFFF (NaN); //; v_add_u16 v0, 0xff00, v0 // src0 = 0xff00; v_add_u16 v0, 0xffffffffffffff00, v0 // src0 = 0xff00; v_add_u16 v0, -256, v0 // src0 = 0xff00; //; s_bfe_i64 s[0:1], 0xffefffff, s3 // src0 = 0xffffffffffefffff; s_bfe_u64 s[0:1], 0xffefffff, s3 // src0 = 0x00000000ffefffff; v_ceil_f64_e32 v[0:1], 0x",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst:35671,extend,extend,35671,interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,1,['extend'],['extend']
Modifiability,"When aligning pointers up or down, the resulting value must be within the same; underlying allocation or one past the end (see C17 6.5.6p8, C++ [expr.add]).; This means that arbitrary integer values stored in pointer-type variables must; not be passed to these builtins. For those use cases, the builtins can still be; used, but the operation must be performed on the pointer cast to ``uintptr_t``. If Clang can determine that the alignment is not a power of two at compile time,; it will result in a compilation failure. If the alignment argument is not a; power of two at run time, the behavior of these builtins is undefined. Non-standard C++11 Attributes; =============================. Clang's non-standard C++11 attributes live in the ``clang`` attribute; namespace. Clang supports GCC's ``gnu`` attribute namespace. All GCC attributes which; are accepted with the ``__attribute__((foo))`` syntax are also accepted as; ``[[gnu::foo]]``. This only extends to attributes which are specified by GCC; (see the list of `GCC function attributes; <https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html>`_, `GCC variable; attributes <https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html>`_, and; `GCC type attributes; <https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html>`_). As with the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaration or; immediately after the name being declared. For example, this applies the GNU ``unused`` attribute to ``a`` and ``f``, and; also applies the GNU ``noreturn`` attribute to ``f``. .. code-block:: c++. [[gnu::unused]] int a, f [[gnu::noreturn]] ();. Target-Specific Extensions; ==========================. Clang supports some language features conditionally on some targets. ARM/AArch64 Language Extensions; -------------------------------. Memory Barrier Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^; Clang implements the ``__dmb``, ``__dsb`` an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:153620,extend,extends,153620,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['extend'],['extends']
Modifiability,"When the flag ImplicitCode is true then it means that the Instruction has been; added by the front-end but doesn't correspond to source code written by the user. For example. .. code-block:: c++. if (MyBoolean) {; MyObject MO;; ...; }. At the end of the scope the MyObject's destructor is called but it isn't written; explicitly. This information is useful to avoid to have counters on brackets when; making code coverage. C/C++ global variable information; ---------------------------------. Given an integer global variable declared as follows:. .. code-block:: c. _Alignas(8) int MyGlobal = 100;. a C/C++ front-end would generate the following descriptors:. .. code-block:: text. ;;; ;; Define the global itself.; ;;; @MyGlobal = global i32 100, align 8, !dbg !0. ;;; ;; List of debug info of globals; ;;; !llvm.dbg.cu = !{!1}. ;; Some unrelated metadata.; !llvm.module.flags = !{!6, !7}; !llvm.ident = !{!8}. ;; Define the global variable itself; !0 = distinct !DIGlobalVariable(name: ""MyGlobal"", scope: !1, file: !2, line: 1, type: !5, isLocal: false, isDefinition: true, align: 64). ;; Define the compile unit.; !1 = distinct !DICompileUnit(language: DW_LANG_C99, file: !2,; producer: ""clang version 4.0.0"",; isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug,; enums: !3, globals: !4). ;;; ;; Define the file; ;;; !2 = !DIFile(filename: ""/dev/stdin"",; directory: ""/Users/dexonsmith/data/llvm/debug-info""). ;; An empty array.; !3 = !{}. ;; The Array of Global Variables; !4 = !{!0}. ;;; ;; Define the type; ;;; !5 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed). ;; Dwarf version to output.; !6 = !{i32 2, !""Dwarf Version"", i32 4}. ;; Debug info schema version.; !7 = !{i32 2, !""Debug Info Version"", i32 3}. ;; Compiler identification; !8 = !{!""clang version 4.0.0""}. The align value in DIGlobalVariable description specifies variable alignment in; case it was forced by C11 _Alignas(), C++11 alignas() keywords or compiler; attribute __attribute__((aligned ())). In ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:43027,variab,variable,43027,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"When using its own, implementations of the atomic; operations are provided as macros. In the cases where C11 also requires a real; function, this header provides only the declaration of that function (along; with a shadowing macro implementation), and you must link to a library which; provides a definition of the function if you use it instead of the macro. C11 generic selections; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_generic_selections)`` or; ``__has_extension(c_generic_selections)`` to determine if support for generic; selections is enabled. As an extension, the C11 generic selection expression is available in all; languages supported by Clang. The syntax is the same as that given in the C11; standard. In C, type compatibility is decided according to the rules given in the; appropriate standard, but in C++, which lacks the type compatibility rules used; in C, types are considered compatible only if they are equivalent. Clang also supports an extended form of ``_Generic`` with a controlling type; rather than a controlling expression. Unlike with a controlling expression, a; controlling type argument does not undergo any conversions and thus is suitable; for use when trying to match qualified types, incomplete types, or function; types. Variable-length array types lack the necessary compile-time information; to resolve which association they match with and thus are not allowed as a; controlling type argument. Use ``__has_extension(c_generic_selection_with_controlling_type)`` to determine; if support for this extension is enabled. C11 ``_Static_assert()``; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_static_assert)`` or ``__has_extension(c_static_assert)``; to determine if support for compile-time assertions using ``_Static_assert`` is; enabled. C11 ``_Thread_local``; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_thread_local)`` or ``__has_extension(c_thread_local)``; to determine if support for ``_Thread_local`` variables is enabled. Modules; -------. Use ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:53435,extend,extended,53435,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['extend'],['extended']
Modifiability,"Why interpreting C++ with Cling?; -----------------------------------. 1. **Learning C++:**; ; One use case of Cling is to aid the C++ learning process. Offering imediate; feedback the user can easily get familiar with the structures and spelling of; the language. 2. **Creating scripts:**; ; The power of an interpreter lays as well in the compactness and ease of; repeatedly running a small snippet of code - aka a script. This can be done in; Cling by inserting the bash-like style line:. .. code:: bash; ; #!/usr/bin/cling; ; 3. **Rapid Application Development (RAD):**. Cling can be used successfully for Rapid Application Development allowing for; prototyping and proofs of concept taking advantage of dynamicity and feedback; during the implementation process. 4. **Runtime-Generated Code**. Sometime it's convenient to create code as a reaction to input; (user/network/configuration). Runtime-generated code can interface with C++; libraries. 5. **Embedding Cling:**. The functionality of an application can be enriched by embedding Cling. To embed; Cling, the main program has to be provided. One of the things this main program; has to do is initialize the Cling interpreter. There are optional calls to pass; command line arguments to Cling. Afterwards, you can call the interpreter from; any anywhere within the application. For compilation and linkage the application needs the path to the Clang and LLVM; libraries and the invocation is order dependent since the linker cannot do; backward searches. .. code:: bash. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding Cling requires the creation of the interpreter. Optionally compile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/why_interpreting.rst:877,config,configuration,877,interpreter/cling/docs/chapters/why_interpreting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/why_interpreting.rst,1,['config'],['configuration']
Modifiability,"Widget. -(void)wobble:(WobbleAmount *)amount; __attribute__((objc_externally_retained)) {; // 'amount' and 'alias' aren't retained on entry, nor released on exit.; __attribute__((objc_externally_retained)) WobbleAmount *alias = amount;; }; @end. Annotating a function with this attribute makes every parameter with strong; retainable object pointer type externally-retained, unless the variable was; explicitly qualified with ``__strong``. For instance, ``first_param`` is; externally-retained (and therefore ``const``) below, but not ``second_param``:. .. code-block:: objc. __attribute__((objc_externally_retained)); void f(NSArray *first_param, __strong NSArray *second_param) {; // ...; }. You can test if your compiler has support for ``objc_externally_retained`` with; ``__has_attribute``:. .. code-block:: objc. #if __has_attribute(objc_externally_retained); // Use externally retained...; #endif. .. _arc.misc.self:. ``self``; --------. The ``self`` parameter variable of an non-init Objective-C method is considered; :ref:`externally-retained <arc.misc.externally_retained>` by the implementation.; It is undefined behavior, or at least dangerous, to cause an object to be; deallocated during a message send to that object. In an init method, ``self``; follows the :ref:``init family rules <arc.family.semantics.init>``. .. admonition:: Rationale. The cost of retaining ``self`` in all methods was found to be prohibitive, as; it tends to be live across calls, preventing the optimizer from proving that; the retain and release are unnecessary --- for good reason, as it's quite; possible in theory to cause an object to be deallocated during its execution; without this retain and release. Since it's extremely uncommon to actually; do so, even unintentionally, and since there's no natural way for the; programmer to remove this retain/release pair otherwise (as there is for; other parameters by, say, making the variable ``objc_externally_retained`` or; qualifying it with ``__unsafe_unre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:94213,variab,variable,94213,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"Will it work with any build system?; scan-build has little or no knowledge about how you build your code.; It works by overriding the CC and CXX environment variables to; (hopefully) change your build to use a ""fake"" compiler instead of the; one that would normally build your project. This fake compiler executes either; clang or gcc (depending on the platform) to compile your; code and then executes the static analyzer to analyze your code.; This ""poor man's interposition"" works amazingly well in many cases; and falls down in others. Please consult the information on this page on making; the best use of scan-build, which includes getting it to work when the; aforementioned hack fails to work. Viewing static analyzer results in a web browser. Contents. Getting Started. Basic Usage; For Windows Users; Other Options; Output of scan-build. Recommended Usage Guidelines. Always Analyze a Project in its ""Debug"" Configuration; Use Verbose Output when Debugging scan-build; Run './configure' through scan-build. Analyzing iPhone Projects. Getting Started; The scan-build command can be used to analyze an entire project by; essentially interposing on a project's build process. This means that to run the; analyzer using scan-build, you will use scan-build to analyze; the source files compiled by gcc/clang during a project build.; This means that any files that are not compiled will also not be analyzed.; Basic Usage; Basic usage of scan-build is designed to be simple: just place the; word ""scan-build"" in front of your build command:. $ scan-build make; $ scan-build xcodebuild. In the first case scan-build analyzes the code of a project built; with make and in the second case scan-build analyzes a project; built using xcodebuild.; Here is the general format for invoking scan-build:. $ scan-build [scan-build options] <command> [command options]. Operationally, scan-build literally runs <command> with all of the; subsequent options passed to it. For example, one can pass -j4 to; make",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:1507,config,configure,1507,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['config'],['configure']
Modifiability,"WorkerHint` is a superior alternative.; - `TTree::GetEntry()` and `TTree::GetEvent()` no longer have 0 as the default value for the first parameter `entry`. We are not aware of correct uses of this function without providing an entry number. If you have one, please simply pass `0` from now on.; - `TBufferMerger` is now out of the `Experimental` namespace (`ROOT::Experimental::TBufferMerger` is deprecated, please use `ROOT::TBufferMerger` instead); - RooFit container classes marked as deprecated with this release: `RooHashTable`, `RooNameSet`, `RooSetPair`, and `RooList`. These classes are still available in this release, but will be removed in the next one. Please migrate to STL container classes, such as `std::unordered_map`, `std::set`, and `std::vector`.; - The `RooFit::FitOptions(const char*)` command to steer [RooAbsPdf::fitTo()](https://root.cern.ch/doc/v628/classRooAbsPdf.html) with an option string in now deprecated and will be removed in ROOT v6.28. Please migrate to the RooCmdArg-based fit configuration. The former character flags map to RooFit command arguments as follows:; - `'h'` : RooFit::Hesse(); - `'m'` : RooFit::Minos(); - `'o'` : RooFit::Optimize(1); - `'r'` : RooFit::Save(); - `'t'` : RooFit::Timer(); - `'v'` : RooFit::Verbose(); - `'0'` : RooFit::Strategy(0); Subsequently, the `RooMinimizer::fit(const char*)` function and the [RooMCStudy](https://root.cern.ch/doc/v626/classRooMCStudy.html) constructor that takes an option string is deprecated as well. ## Core Libraries. ### Interpreter. - As of v6.26, cling diagnostic messages can be redirected to the ROOT error handler. Users may enable/disable this via `TCling::ReportDiagnosticsToErrorHandler()`, e.g.; ```cpp; root [1] gInterpreter->ReportDiagnosticsToErrorHandler();; root [2] int f() { return; }; Error in <cling>: ROOT_prompt_2:1:11: non-void function 'f' should return a value [-Wreturn-type]; int f() { return; }; ^; ```; More details at [PR #8737](https://github.com/root-project/root/pull/8737",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:3052,config,configuration,3052,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['config'],['configuration']
Modifiability,"XBaseSpecifier>. Matcher<ValueDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; matcher. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and U (matcher = typedefDecl(hasType(asString(""int""))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<VarDecl>hasInitializerMatcher<Expr> InnerMatcher; Matches a variable declaration that has an initializer expression; that matches the given matcher. Example matches x (matcher = varDecl(hasInitializer(callExpr()))); bool y() { return true; }; bool x = y();. Matcher<VariableArrayType>hasSizeExprMatcher<Expr> InnerMatcher; Matches VariableArrayType nodes that have a specific size; expression. Given; void f(int b) {; int a[b];; }; variableArrayType(hasSizeExpr(ignoringImpCasts(declRefExpr(to(; varDecl(hasName(""b""))))))); matches ""int a[b]"". Matcher<WhileStmt>hasBodyMatcher<Stmt> InnerMatcher; Matches a 'for', 'while', 'while' statement or a function or coroutine; definition that has a given body. Note that in case of functions or; coroutines this matcher only matches the definition itself and not the; other declarations of the same function or coroutine. Given; for (;;) {}; forStmt(hasBody(compoundStmt())); matches 'for (;;) {}'; with compoundStmt(); matching '{}'. Given; void f();; void f() {}; functionDecl(hasBody(compoundStmt())); matches 'void f() {}'; with compoundStmt(); matching '{}'; but does not match 'void f();'. Matcher<WhileStmt>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:254072,variab,variableArrayType,254072,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variableArrayType']
Modifiability,"YAML for should be in x,y coordinates. That; is, you want the yaml to look like:. .. code-block:: yaml. x: 10.3; y: -4.7. You can support this by defining a MappingTraits that normalizes the polar; coordinates to x,y coordinates when writing YAML and denormalizes x,y; coordinates into polar when reading YAML. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. template <>; struct MappingTraits<Polar> {. class NormalizedPolar {; public:; NormalizedPolar(IO &io); : x(0.0), y(0.0) {; }; NormalizedPolar(IO &, Polar &polar); : x(polar.distance * cos(polar.angle)),; y(polar.distance * sin(polar.angle)) {; }; Polar denormalize(IO &) {; return Polar(sqrt(x*x+y*y), arctan(x,y));; }. float x;; float y;; };. static void mapping(IO &io, Polar &polar) {; MappingNormalization<NormalizedPolar, Polar> keys(io, polar);. io.mapRequired(""x"", keys->x);; io.mapRequired(""y"", keys->y);; }; };. When writing YAML, the local variable ""keys"" will be a stack allocated; instance of NormalizedPolar, constructed from the supplied polar object which; initializes it x and y fields. The mapRequired() methods then write out the x; and y values as key/value pairs. When reading YAML, the local variable ""keys"" will be a stack allocated instance; of NormalizedPolar, constructed by the empty constructor. The mapRequired; methods will find the matching key in the YAML document and fill in the x and y; fields of the NormalizedPolar object keys. At the end of the mapping() method; when the local keys variable goes out of scope, the denormalize() method will; automatically be called to convert the read values back to polar coordinates,; and then assigned back to the second parameter to mapping(). In some cases, the normalized class may be a subclass of the native type and; could be returned by the denormalize() method, except that the temporary; normalized instance is stack allocated. In these cases, the utility template; MappingNormalizationHeap<> can be used instead. It just like; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:18633,variab,variable,18633,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['variab'],['variable']
Modifiability,"[Activating the tree viewer](pictures/030000EF.png). The tree viewer is a quick and easy way to examine a tree. To start the; tree viewer, open a file and object browser. Right click on a; **`TTree`** and select `StartViewer`. You can also start the tree viewer; from the command line. First load the viewer library. ``` {.cpp}; root[] TFile f(""cernstaff.root""); root[] T->StartViewer(); ```. If you want to start a tree viewer without a tree, you need to load the; tree player library first:. ``` {.cpp}; root[] gSystem->Load(""libTreeViewer.so""); root[] new TTreeViewer(); ```. The figure above shows how the tree viewer looks like for the example file; `cernstaff.root`. The left panel contains the list of trees and their; branches; in this case there is only one tree. You can add more trees; with the File-Open command to open the file containing the new tree,; then use the context menu on the right panel, select `SetTreeName` and; enter the name of the tree to add. On the right are the leaves or; variables in the tree. You can double click on any leaf to a histogram; it. The toolbar in the upper part can be used for user commands, changing; the drawing option and the histogram name. The lower part contains three; picture buttons that draw a histogram, stop the current command, and; refresh the tree. The three check buttons toggle the following:. `Hist`- the histogram drawing mode;. `Scan`- enables redirecting of `TTree::Scan `command in an ASCII file;. `Rec` - enables recording of the last issued command. - ![](pictures/020000F1.jpg) To draw more than one dimension you can drag; and drop any leaf to the `X,Y,Z` boxes"". Then push the Draw button,; witch is marked with the purple icon on the bottom left. - ![](pictures/030000F2.png) All commands can be interrupted at any time; by pressing this button. - ![](pictures/030000F3.png) The method **`TTree::Refresh`** is called by; pressing the refresh button in `TTreeViewer`. It redraws the current; exposed expression. Calling `TT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:7336,variab,variables,7336,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"[] AStruct<float> S0; // #1: implicit loading of libA. Full descriptor required.; root [] AStruct<float>* S1; // #2: implicit loading of libA. No full descriptor required.; root [] if (gFile) S1->doIt(); // #3: implicit loading of libA. Full descriptor required.; root [] gSystem->Load(""libA""); // #4: explicit loading of libA. No full descriptor required.; root [] do(); // #5: error: implicit loading of libA is currently unsupported. ```. This pattern is not only used in the ROOT prompt but in I/O hotspots such as; `ShowMembers` and `TClass::IsA`. A naive implementation of this feature would require inclusion of all reachable; library descriptors (aka header files) at ROOT startup time. Of course this is; not feasible and ROOT inserts a set of optimizations to fence itself from the; costly full header inclusion. Unfortunately, several of them are home-grown and; in a few cases inaccurate (eg line #5) causing a noticeable technical debt. Here we will briefly describe the three common layers of optimizations: ROOT PCH,; ROOTMAP and RDICT. The ROOT precompiled header (PCH) reduces the CPU and memory cost for ROOT's; most used libraries. The precompiled header technology is well-understood since; decades [[4]]. It is an efficient on-disk representation of the state of the; compiler after parsing a set of headers. It can be loaded before starting the; next instance to avoid doing redundant work. At build time, rootcling (ROOT's; dictionary generator) creates such PCH file which is attached at ROOT startup; time. Its major drawback is the fact that if third-party users want to include; their libraries, they have to recompile it every time there is a change. RDICT files store some useful information (in particular about class offsets) in; ROOT files to avoid the potentially expensive call to the interpreter if the; information is not the PCH. For example, ROOT's libGeom and other third-party; code. This is done to circumvent the costly call to `ShowMembers` which will; requ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:5813,layers,layers,5813,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['layers'],['layers']
Modifiability,"\_GCCXML\_\_*. This means in particular that data members that were; made transient by hiding them from rootcint or genreflex now *must* be; *explicitly* marked as transient. For rootcint or rootcling use:. ``` {.cpp}; sometype datamember; //! The exclamation mark signals the transientness; ```. and for genreflex. ``` {.cpp}; <class name=""edm::Particle"" >; <field name=""m_calculated"" transient=""true"" />; </class>; ```. or. ``` {.cpp}; <class name=""edm::Particle"" >; <field name=""m_calculated"" persistent=""false"" />; </class>. ```. This new set of executables are responsible also for the generation of pcm; files. These are crucial for the functioning of ROOT and must reside in the; same directory of the libraries which contain the compiled dictionaries. ### rlibmap. The tools used to generate rootmap files are rootcling and genreflex. The; rlibmap tool is not present any more in ROOT starting from release 6.00.00. ### Rootmap files. To enhance the set of functionalities offered by ROOT and its new interpreter,; the format of the rootmaps evolved. Rootmap in the old format cannot be; produced anymore but only read. The new rootmaps can be still be concatenated.; A rootmap file now contains:. - One (or more) section for forward declarations. These are real C++; forward declarations of templates and namespaces. This is needed for Cling; to be able to parse templates' instantiations and for some autoloading; functionalities.; - One (or more) libraries sections. These sections describe the ensamble of; the autoload keys related to one or more shared libraries. An autoload key; can be a class name, a namespace name, a typedef or alias or a header file name.; - Single line comments, which start with a ""#"" character. At ROOT startup, a check is performed on autoload keys. If the same key (which is not a template instantiation) refers to two different libraries (or sets of libraries) a warning is issued.; A typical Rootmap file look like:; ``` {.cpp}; { decls }; fwd declaration ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:9358,enhance,enhance,9358,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,2,"['enhance', 'evolve']","['enhance', 'evolved']"
Modifiability,"\defgroup Containers Containers; \ingroup Core; \brief The containers and generators the ROOT framework offers. Collections are a key feature of the ROOT system. Many, if not most, of; the applications you write will use collections. If you have used; polymorphic C++ collections before, some of this material will be review.; However, much of [this tutorial](https://github.com/root-project/root/blob/master/test/tcollex.cxx); covers aspects of collections specific to the ROOT system.; In this tutorial the following features will be demonstrated:. - Using collections; - How to create instances of collections; - The difference between lists, ordered collections, hash-tables, maps, etc.; - How to add and remove elements of a collection; - How to search a collection for a specific element; - How to access and modify collection elements; - How to iterate over a collection; - How to manage memory for collections and collection elements; - How collection elements are tested for equality (`IsEqual()`); - How collection elements are compared (`Compare()`) in case of sorted collections; - How collection elements are hashed (`Hash()`) in hash tables. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/index.md:252,polymorphi,polymorphic,252,core/cont/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/index.md,1,['polymorphi'],['polymorphic']
Modifiability,"\defgroup Core Core ROOT classes; \brief The Core classes of ROOT.; \defgroup Base Base ROOT classes; \ingroup Core; \brief The Base classes of ROOT. The base classes of the ROOT system provide the core of the system. They; are available to all other classes. They range from a set of abstract; interfaces (TVirtualXXXXX classes), to a wide range of basic utility; classes providing basic services like strings, regular expression,; timers, date/time, md5 checksumming, signal/slots event handling,; plugin handler, run-config resource processor, etc. etc. \defgroup StdExt std Extension classes; \brief Extension classes within libCore to backport or complement missing std:: features. \defgroup Parallelism Parallelized classes; \brief Classes implement parallelism within ROOT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/doc/index.md:500,plugin,plugin,500,core/base/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/doc/index.md,2,"['config', 'plugin']","['config', 'plugin']"
Modifiability,"\defgroup Geometry_gdml GDML tools; \ingroup Geometry; \brief GDML tools for geometry classes. The `$ROOTSYS/gdml` directory contains a set of Python modules designed; for writing out Geometry Description Markup Language (GDML) files.; There is also a C++ implementation for the import of GDML into ROOT.; They act as a converter between the GDML geometry files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geome",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:538,config,configure,538,geom/gdml/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md,2,['config'],['configure']
Modifiability,"\defgroup Graphics Graphics; \brief The graphics related classes; \defgroup Graphics2D 2D Graphics; \ingroup Graphics; \brief The 2D graphics related classes; \defgroup gpad Graphics pad; \ingroup Graphics2D; \brief The TPad related classes. TPad and TPad's related classes' usages are illustrated by the following examples:. - [The Graphics Pad.](https://root.cern/doc/master/classTPad.html); - [How to Draw objects.](https://root-forum.cern.ch/t/how-to-draw-objects/28249); - [How to Pick objects.](https://root-forum.cern.ch/t/how-to-pick-objects/28251); - [Dividing a canvas with no margins between pads.](https://root.cern/doc/master/zones_8C.html); - [Using transparent pads.](https://root.cern/doc/master/transpad_8C.html). \defgroup GraphicsAtt Graphics attributes; \ingroup Graphics; \brief The graphics attributes related classes. Graphics attributes, are parameters that affect the way; [graphics primitives](https://root.cern.ch/basic-graphics-primitives) are displayed. A ROOT object get graphics attributes by inheritance from the `TAttXXX` classes. For example, lines can be dotted or dashed, fat or thin, blue or orange. If; an object inherits form the class TAttLine it will get these attributes.; Areas might be filled with one color or with a multicolor pattern. If; an object inherits form the class TAttFill it will get these attribute.; Text can appear with an angle, displayed in different fonts, colors, and sizes.; If an object inherits form the class TAttText it will get these attribute. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/doc/index.md:1024,inherit,inheritance,1024,graf2d/gpad/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/doc/index.md,4,['inherit'],"['inheritance', 'inherits']"
Modifiability,"\defgroup HistFactory HistFactory; \brief Factory classes to create RooFit workspaces from histograms; \ingroup Roostats. <p>; This is a package that creates a RooFit probability density function from ROOT histograms ; of expected distributions and histograms that represent the +/- 1 sigma variations ; from systematic effects. The resulting probability density function can then be used; with any of the statistical tools provided within RooStats, such as the profile ; likelihood ratio, Feldman-Cousins, etc. In this version, the model is directly; fed to a likelihood ratio test, but it needs to be further factorized.</p>. <p>; The user needs to provide histograms (in picobarns per bin) and configure the job; with XML. The configuration XML is defined in the file `$ROOTSYS/config/HistFactorySchema.dtd`, but essentially; it is organized as follows (see the examples in `${ROOTSYS}/tutorials/histfactory/`)</p>. <ul>; <li> a top level 'Combination' that is composed of:</li>; <ul>; <li> several 'Channels' (eg. ee, emu, mumu), which are composed of:</li>; <ul>; <li> several 'Samples' (eg. signal, bkg1, bkg2, ...), each of which has:</li>; <ul>; <li> a name</li>; <li> if the sample is normalized by theory (eg N = L*sigma) or not (eg. data driven)</li>; <li> a nominal expectation histogram</li>; <li> a named 'Normalization Factor' (which can be fixed or allowed to float in a fit)</li>; <li> several 'Overall Systematics' in normalization with:</li>; <ul>; <li> a name</li>; <li> +/- 1 sigma variations (eg. 1.05 and 0.95 for a 5% uncertainty)</li>; </ul>; <li> several 'Histogram Systematics' in shape with:</li>; <ul>; <li> a name (which can be shared with the OverallSyst if correlated)</li>; <li> +/- 1 sigma variational histograms</li>; </ul>; </ul>; </ul>; <li> several 'Measurements' (corresponding to a full fit of the model) each of which specifies</li>; <ul>; <li> a name for this fit to be used in tables and files</li>; <li> what is the luminosity associated to the measurement ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/doc/index.md:697,config,configure,697,roofit/histfactory/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/doc/index.md,3,['config'],"['config', 'configuration', 'configure']"
Modifiability,"\defgroup Roofitmain RooFit; \brief RooFit is a package for building likelihood models and fitting these to data. For an introduction check the \ref tutorial_roofit, [user's guides](https://root.cern.ch/root-user-guides-and-manuals),; [courses](https://root.cern.ch/learn/courses) or [the RooFit chapter of the Manual](https://root.cern/manual/roofit/). For developers, there is also the \ref roofit_dev_docs, which serves as a reference on how to extend %RooFit with custom classes or for contributing to %RooFit itself. \defgroup roofit_dev_docs RooFit Developer Documentation; \brief How-to guides on how to extend \ref Roofitmain with custom classes or to work on %RooFit itself.; \ingroup Roofitmain; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/index.md:448,extend,extend,448,roofit/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/index.md,2,['extend'],['extend']
Modifiability,"\defgroup roofit_dev_docs_ad How to extend the use of Automatic Differentiation in RooFit; \ingroup roofit_dev_docs; \date October 2023; \brief Developer guide on how to add support for Automatic Differentiation via code generation. # How to extend the use of Automatic Differentiation in RooFit. ## What is RooFit?. [RooFit] is a statistical data analysis tool, widely used in scientific; research, especially in the high-energy physics (HEP) field. It is an; extension of the ROOT framework, a C++ based data analysis framework that; provides tools for data storage, analysis, and visualization. RooFit provides; a set of tools/classes to define and evaluate probability density functions; (PDFs), perform maximum likelihood fits, perform statistical tests, etc. ## Proof of Concept: Speeding up RooFit using Automatic Differentiation (AD). RooFit is used to reduce statistical models (functions) to find a set of; parameters that minimize the value of the function. This minimization happens; via one of several methods relying heavily on the computation of derivatives; of the function with respect to its free parameters. Currently, the; computation of Numerical Derivatives is the most time-consuming component of; RooFit [^1]. On the other hand, derivatives computed using the Automatic; Differentiation tool [Clad] have been shown to be far more efficient [^2]. \htmlonly; <div class=""pyrootbox"">; \endhtmlonly. Main Advantage of using AD with RooFit: efficient and more precise; derivatives. It computes derivatives with high precision, avoiding the errors; that may arise from approximating derivatives using finite differences. \htmlonly; </div>; \endhtmlonly. ### AD Support essentially requires Code Generation. As we'll discuss in upcoming sections, *AD support* can be added using *C++; Code generation*.; These two terms may be used interchangeably in this document, since the term; *Code Generation* better helps visualize the transformation that is enabling; AD support. ## Current S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:36,extend,extend,36,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,2,['extend'],['extend']
Modifiability,"\defgroup roofit_dev_docs_test_statistics New RooFit TestStatistics usage notes; \ingroup roofit_dev_docs; \date December 2021; \author Patrick Bos; \brief Notes on the new `RooFit::TestStatistics` classes. # RooFit::TestStatistics usage notes. The `RooFit::TestStatistics` namespace contains a major refactoring of the `RooAbsTestStatistic`-`RooAbsOptTestStatistic`-`RooNLLVar` inheritance tree into:. 1. statistics-based classes on the one hand;; 2. calculation/evaluation/optimization based classes on the other hand. The motivation for this refactoring was also twofold:. 1. These test statistics classes make a cleaner separation of concerns than the existing `RooAbsTestStatistic` based tree and are hence more maintainable and future proof.; 2. They provided a place for us to try out new parallelized gradient calculation methods using the `RooFit::MultiProcess` module. See the usage example below on how to use this. ## Statistics; The likelihood is the central unit on the statistics side.; The `RooAbsL` class is implemented for four kinds of likelihoods: binned, unbinned, ""subsidiary"" (an optimization for numerical stability that gathers components like global observables) and ""sum"" (over multiple components of the other types), in the correspondingly named classes `RooBinnedL`, `RooUnbinnedL`, `RooSubsidiaryL` and `RooSumL`.; These classes provide a `evaluatePartition` function that allows for computing them in parallelizable chunks that can be used by the calculator classes as they see fit. On top of the likelihood classes, we also provide for convenience a likelihood builder `buildLikelihood`, as a free function in the namespace.; This function analyzes the `pdf` and automatically constructs the proper likelihood, built; up from the available `RooAbsL` subclasses. The new classes are not per se meant to be used outside of `RooMinimizer`, although they can be.; The main reason is that they do not behave as regular `RooAbsReal` objects, but have their own interface whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:301,refactor,refactoring,301,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,4,"['inherit', 'maintainab', 'refactor']","['inheritance', 'maintainable', 'refactoring']"
Modifiability,"\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10324,variab,variables,10324,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,2,['variab'],['variables']
Modifiability,"\page rootio %ROOT files layout. \tableofcontents. ## ROOTIO files. A ROOTIO file consists of one ""file header"", one or more ""data; records,"" and zero or more ""free segments"". The file header is always; at the beginning of the file, while the data records and free segments; may in principle appear in any order. The file header is fixed length (64 bytes in the current; release.) It's detailed format is given in \ref header. A free segment is of variable length. One free segment is a set; of contiguous bytes that are unused, and are available for ROOTIO to use; for new or resized data records. The first four bytes of a a free; segment contain the negative of the number of bytes in the segment. The; contents of the remainder of the free segment are irrelevant. A data record represents either user data or data used; internally by ROOTIO. All data records have two portions, a ""key""; portion and a ""data"" portion. The key portion precedes the data; portion. The format of the key portion is the same for all data.; (The key portion corresponds to a class TKey object). The object name; and they key cycle are together sufficient to uniquely determine the; record within the file. The \ref dobject page describes the format; of the data portion of a record for an object that uses the default; streamer. ## Data record types. ### ""core"" record types. There are several types of data records used internally by; ROOTIO to support the storage of byte sequences. These record types; are TFile, TDirectory, ""KeysList"", and ""FreeSegments"". These types; can be considered to be in the ""core"" layer of ROOTIO. A file always contains exactly one TFile data record, which; (nearly?) always immediately follows the file header. The TFile record; consists of either data pertaining to the file as a whole, or data; pertaining to the root ""directory"" of records in the file. Its detailed; format is given in \ref tfile. A file contains zero or more TDirectory data records, each; representing a subdirectory",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:448,variab,variable,448,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['variab'],['variable']
Modifiability,"\page tobject Format of the DATA for a TObject object. Here is the format of the DATA for a TObject object in Release 3.02.06. <div style=""background-color: lightgrey; font-size: 0.9vw;""><pre>; --------; 0->1 Version = Version of TObject Class; 2->5 fUniqueID = Unique ID of object. Currently, unless this object is or was; | referenced by a TRef or TRefArray, or is itself a TRef or TRefArray,; | this field is not used by ROOT.; 6->9 fBits = A 32 bit mask containing status bits for the object.; | The bits relevant to ROOTIO are:; | 0x00000001 - if object in a list can be deleted.; | 0x00000008 - if other objects may need to be deleted when this one is.; | 0x00000010 - if object is referenced by pointer to persistent object.; | 0x00002000 - if object ctor succeeded but object shouldn't be used; | 0x01000000 - if object is on Heap.; | 0x02000000 - if object has not been deleted.; The ""pidf"" field below is present only if this TObject object (or an object inheriting; from it) is referenced by a pointer to persistent object.; 10->11 pidf = An identifier of the TProcessID record for the process that wrote the; | object. This identifier is an unsigned short. The relevant record; | has a name that is the string ""ProcessID"" concatenated with the ASCII; | decimal representation of ""pidf"" (no leading zeros). 0 is a valid pidf.; -------; No object in the StreamerInfo record will be a reference or referenced, and all objects; are on the heap. So, for each occurrence in the StreamerInfo record, fUniqueID will be 0,; fBits will be 0x03000000, and pidf will be absent.; </pre></div>; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/tobject.md:965,inherit,inheriting,965,io/doc/TFile/tobject.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/tobject.md,1,['inherit'],['inheriting']
Modifiability,"\s are; not updated to match the ``Kind`` enum when adding (or removing) classes to; (from) the hierarchy. Continuing the example above, suppose we add a ``SomewhatSpecialSquare`` as; a subclass of ``Square``, and update the ``ShapeKind`` enum like so:. .. code-block:: c++. enum ShapeKind {; SK_Square,; SK_SpecialSquare,; SK_OtherSpecialSquare,; + SK_SomewhatSpecialSquare,; SK_Circle; }. Now, suppose that we forget to update ``Square::classof()``, so it still; looks like:. .. code-block:: c++. static bool classof(const Shape *S) {; // BUG: Returns false when S->getKind() == SK_SomewhatSpecialSquare,; // even though SomewhatSpecialSquare ""is a"" Square.; return S->getKind() >= SK_Square &&; S->getKind() <= SK_OtherSpecialSquare;; }. As the comment indicates, this code contains a bug. A straightforward and; non-clever way to avoid this is to introduce an explicit ``SK_LastSquare``; entry in the enum when adding the first subclass(es). For example, we could; rewrite the example at the beginning of `Concrete Bases and Deeper; Hierarchies`_ as:. .. code-block:: c++. enum ShapeKind {; SK_Square,; + SK_SpecialSquare,; + SK_OtherSpecialSquare,; + SK_LastSquare,; SK_Circle; }; ...; // Square::classof(); - static bool classof(const Shape *S) {; - return S->getKind() == SK_Square;; - }; + static bool classof(const Shape *S) {; + return S->getKind() >= SK_Square &&; + S->getKind() <= SK_LastSquare;; + }. Then, adding new subclasses is easy:. .. code-block:: c++. enum ShapeKind {; SK_Square,; SK_SpecialSquare,; SK_OtherSpecialSquare,; + SK_SomewhatSpecialSquare,; SK_LastSquare,; SK_Circle; }. Notice that ``Square::classof`` does not need to be changed. .. _classof-contract:. The Contract of ``classof``; ---------------------------. To be more precise, let ``classof`` be inside a class ``C``. Then the; contract for ``classof`` is ""return ``true`` if the dynamic type of the; argument is-a ``C``"". As long as your implementation fulfills this; contract, you can tweak and optimize it ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:9995,rewrite,rewrite,9995,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['rewrite'],['rewrite']
Modifiability,"]?. The ``module`` field includes the summary entry id for the module containing; this definition, and the ``flags`` field contains information such as; the linkage type, a flag indicating whether it is legal to import the; definition, whether it is globally live and whether the linker resolved it; to a local definition (the latter two are populated during the thin link).; The ``insts`` field contains the number of IR instructions in the function.; Finally, there are several optional fields: :ref:`FuncFlags<funcflags_summary>`,; :ref:`Calls<calls_summary>`, :ref:`TypeIdInfo<typeidinfo_summary>`,; :ref:`Params<params_summary>`, :ref:`Refs<refs_summary>`. .. _variable_summary:. Global Variable Summary; ^^^^^^^^^^^^^^^^^^^^^^^. If the global value is a variable, the ``Summary`` entry will look like:. .. code-block:: text. variable: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0)[, Refs]?. The variable entry contains a subset of the fields in a; :ref:`function summary <function_summary>`, see the descriptions there. .. _alias_summary:. Alias Summary; ^^^^^^^^^^^^^. If the global value is an alias, the ``Summary`` entry will look like:. .. code-block:: text. alias: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), aliasee: ^2). The ``module`` and ``flags`` fields are as described for a; :ref:`function summary <function_summary>`. The ``aliasee`` field; contains a reference to the global value summary entry of the aliasee. .. _funcflags_summary:. Function Flags; ^^^^^^^^^^^^^^. The optional ``FuncFlags`` field looks like:. .. code-block:: text. funcFlags: (readNone: 0, readOnly: 0, noRecurse: 0, returnDoesNotAlias: 0, noInline: 0, alwaysInline: 0, noUnwind: 1, mayThrow: 0, hasUnknownCall: 0). If unspecified, flags are assumed to hold the conservative ``false`` value of; ``0``. .. _calls_summary:. Calls; ^^^^^. The optional ``Calls`` field looks like:. .. code-block:: text. calls: ((Callee)[, (Callee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:342574,variab,variable,342574,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"^(float x) { return functionPointer; }. [returnfunctionptr.c]. The compound statement body establishes a new lexical scope within; that of its parent. Variables used within the scope of the compound; statement are bound to the Block in the normal manner with the; exception of those in automatic (stack) storage. Thus one may access; functions and global variables as one would expect, as well as static; local variables. [testme]. Local automatic (stack) variables referenced within the compound; statement of a Block are imported and captured by the Block as const; copies. The capture (binding) is performed at the time of the Block; literal expression evaluation. The compiler is not required to capture a variable if it can prove; that no references to the variable will actually be evaluated.; Programmers can force a variable to be captured by referencing it in a; statement at the beginning of the Block, like so:. .. code-block:: c. (void) foo;. This matters when capturing the variable has side-effects, as it can; in Objective-C or C++. The lifetime of variables declared in a Block is that of a function;; each activation frame contains a new copy of variables declared within; the local scope of the Block. Such variable declarations should be; allowed anywhere [testme] rather than only when C99 parsing is; requested, including for statements. [testme]. Block literal expressions may occur within Block literal expressions; (nest) and all variables captured by any nested blocks are implicitly; also captured in the scopes of their enclosing Blocks. A Block literal expression may be used as the initialization value for; Block variables at global or local static scope. The Invoke Operator; ===================. Blocks are :block-term:`invoked` using function call syntax with a; list of expression parameters of types corresponding to the; declaration and returning a result type also according to the; declaration. Given:. .. code-block:: c. int (^x)(char);; void (^z)(void);; int (^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:5081,variab,variable,5081,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variable']
Modifiability,^^^^. Use ``__has_feature(cxx_deleted_functions)`` or; ``__has_extension(cxx_deleted_functions)`` to determine if support for deleted; function definitions (with ``= delete``) is enabled. C++11 explicit conversion functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_explicit_conversions)`` to determine if support for; ``explicit`` conversion functions is enabled. C++11 generalized initializers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_generalized_initializers)`` to determine if support for; generalized initializers (using braced lists and ``std::initializer_list``) is; enabled. C++11 implicit move constructors/assignment operators; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_implicit_moves)`` to determine if Clang will implicitly; generate move constructors and move assignment operators where needed. C++11 inheriting constructors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_inheriting_constructors)`` to determine if support for; inheriting constructors is enabled. C++11 inline namespaces; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_inline_namespaces)`` or; ``__has_extension(cxx_inline_namespaces)`` to determine if support for inline; namespaces is enabled. C++11 lambdas; ^^^^^^^^^^^^^. Use ``__has_feature(cxx_lambdas)`` or ``__has_extension(cxx_lambdas)`` to; determine if support for lambdas is enabled. C++11 local and unnamed types as template arguments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_local_type_template_args)`` or; ``__has_extension(cxx_local_type_template_args)`` to determine if support for; local and unnamed types as template arguments is enabled. C++11 noexcept; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_noexcept)`` or ``__has_extension(cxx_noexcept)`` to; determine if support for noexcept exception specifications is enabled. C++11 in-class non-static data member initialization; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:43809,inherit,inheriting,43809,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['inherit'],['inheriting']
Modifiability,"^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic function. You can use bswap on any; integer type that is an even number of bytes (i.e. BitWidth % 16 == 0). ::. declare i16 @llvm.bswap.i16(i16 <id>); declare i32 @llvm.bswap.i32(i32 <id>); declare i64 @llvm.bswap.i64(i64 <id>); declare <4 x i32> @llvm.bswap.v4i32(<4 x i32> <id>). Overview:; """""""""""""""""". The '``llvm.bswap``' family of intrinsics is used to byte swap an integer; value or vector of integer values with an even number of bytes (positive; multiple of 16 bits). Semantics:; """""""""""""""""""". The ``llvm.bswap.i16`` intrinsic returns an i16 value that has the high; and low byte of the input i16 swapped. Similarly, the ``llvm.bswap.i32``; intrinsic returns an i32 value that has the four bytes of the input i32; swapped, so that if the input bytes are numbered 0, 1, 2, 3 then the; returned i32 will have its bytes in 3, 2, 1, 0 order. The; ``llvm.bswap.i48``, ``llvm.bswap.i64`` and other intrinsics extend this; concept to additional even-byte lengths (6 bytes, 8 bytes and more,; respectively). The vector intrinsics, such as ``llvm.bswap.v4i32``,; operate on a per-element basis and the element order is not affected. .. _int_ctpop:. '``llvm.ctpop.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use llvm.ctpop on any integer; bit width, or on any vector with integer elements. Not all targets; support all bit widths or vector types, however. ::. declare i8 @llvm.ctpop.i8(i8 <src>); declare i16 @llvm.ctpop.i16(i16 <src>); declare i32 @llvm.ctpop.i32(i32 <src>); declare i64 @llvm.ctpop.i64(i64 <src>); declare i256 @llvm.ctpop.i256(i256 <src>); declare <2 x i32> @llvm.ctpop.v2i32(<2 x i32> <src>). Overview:; """""""""""""""""". The '``llvm.ctpop``' family of intrinsics counts the number of bits set; in a value. Arguments:; """""""""""""""""""". The only argument is the value to be counted. The argument may be of any; integer type, or a vector with integer elements. The return type mus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:592227,extend,extend,592227,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extend']
Modifiability,"^^^^^^^^; - Implemented `P0847R7: Deducing this <https://wg21.link/P0847R7>`_. Some related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_extension(cxx_explicit_this_parameter)``. - Added a separate warning to warn the use of attributes on lambdas as a C++23 extension; in previous language versions: ``-Wc++23-lambda-attributes``. C++2c Feature Support; ^^^^^^^^^^^^^^^^^^^^^. - Implemented `P2169R4: A nice placeholder with no name <https://wg21.link/P2169R4>`_. This allows using ``_``; as a variable name multiple times in the same scope and is supported in all C++ language modes as an extension.; An extension warning is produced when multiple variables are introduced by ``_`` in the same scope.; Unused warnings are no longer produced for variables named ``_``.; Currently, inspecting placeholders variables in a debugger when more than one are declared in the same scope; is not supported. .. code-block:: cpp. struct S {; int _, _; // Was invalid, now OK; };; void func() {; int _, _; // Was invalid, now OK; }; void other() {; int _; // Previously diagnosed under -Wunused, no longer diagnosed; }. - Attributes now expect unevaluated strings in attributes parameters that are string literals.; This is applied to both C++ standard attributes, and other attributes supported by Clang.; This completes the implementation of `P2361R6 Unevaluated Strings <https://wg21.link/P2361R6>`_. - Implemented `P2864R2 Remove Deprecated Arithmetic Conversion on Enumerations From C++26 <https://wg21.link/P2864R2>`_. - Implemented `P2361R6 Template parameter initialization <https://wg21.link/P2308R1>`_.; This change is applied as a DR in all language mo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:10557,variab,variables,10557,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"^^^^^^^^^^. * ``Module::Module(std::string name = """")``. Constructing a Module_ is easy. You can optionally provide a name for it; (probably based on the name of the translation unit). * | ``Module::iterator`` - Typedef for function list iterator; | ``Module::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's :ref:`Function <c_Function>` list. * ``Module::FunctionListType &getFunctionList()``. Returns the list of :ref:`Function <c_Function>`\ s. This is necessary to use; when you need to update the list or perform a complex action that doesn't have; a forwarding method. ----------------. * | ``Module::global_iterator`` - Typedef for global variable list iterator; | ``Module::const_global_iterator`` - Typedef for const_iterator.; | ``Module::insertGlobalVariable()`` - Inserts a global variable to the list.; | ``Module::removeGlobalVariable()`` - Removes a global variable from the list.; | ``Module::eraseGlobalVariable()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTable_ for this ``Module``. ----------------. * ``Function *getFunction(StringRef Name) const``. Look up the specified function in the ``Module`` SymbolTable_. If it does not; exist, return ``null``. * ``FunctionCallee getOrInsertFunction(const std::string &Name,; const FunctionType *T)``. Look up the specified function in the ``Module`` SymbolTable_. If; it does not exist, add an external declaration for the function and; return it. Note that the function signature already present may not; match the requested signature. Thus, in order to enable the common; usage of passin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:139203,variab,variable,139203,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"^^^^^^^^^^^^^^^^^^. These reductions are relaxed variants which may reduce the elements in any order. G_VECREDUCE_FMAX, G_VECREDUCE_FMIN, G_VECREDUCE_FMAXIMUM, G_VECREDUCE_FMINIMUM; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. FMIN/FMAX/FMINIMUM/FMAXIMUM nodes can have flags, for NaN/NoNaN variants. Integer/bitwise reductions; ^^^^^^^^^^^^^^^^^^^^^^^^^^. * G_VECREDUCE_ADD; * G_VECREDUCE_MUL; * G_VECREDUCE_AND; * G_VECREDUCE_OR; * G_VECREDUCE_XOR; * G_VECREDUCE_SMAX; * G_VECREDUCE_SMIN; * G_VECREDUCE_UMAX; * G_VECREDUCE_UMIN. Integer reductions may have a result type larger than the vector element type.; However, the reduction is performed using the vector element type and the value; in the top bits is unspecified. Memory Operations; -----------------. G_LOAD, G_SEXTLOAD, G_ZEXTLOAD; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Generic load. Expects a MachineMemOperand in addition to explicit; operands. If the result size is larger than the memory size, the; high bits are undefined, sign-extended, or zero-extended respectively. Only G_LOAD is valid if the result is a vector type. If the result is larger; than the memory size, the high elements are undefined (i.e. this is not a; per-element, vector anyextload). Unlike in SelectionDAG, atomic loads are expressed with the same; opcodes as regular loads. G_LOAD, G_SEXTLOAD and G_ZEXTLOAD may all; have atomic memory operands. G_INDEXED_LOAD; ^^^^^^^^^^^^^^. Generic indexed load. Combines a GEP with a load. $newaddr is set to $base + $offset.; If $am is 0 (post-indexed), then the value is loaded from $base; if $am is 1 (pre-indexed); then the value is loaded from $newaddr. G_INDEXED_SEXTLOAD; ^^^^^^^^^^^^^^^^^^. Same as G_INDEXED_LOAD except that the load performed is sign-extending, as with G_SEXTLOAD. G_INDEXED_ZEXTLOAD; ^^^^^^^^^^^^^^^^^^. Same as G_INDEXED_LOAD except that the load performed is zero-extending, as with G_ZEXTLOAD. G_STORE; ^^^^^^^. Generic store. Expects a MachineMemOperand in addit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst:15663,extend,extended,15663,interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,2,['extend'],['extended']
Modifiability,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``alignof()`` only takes a type name as the argument and it doesn't take an; expression. Similar to ``sizeof()`` and ``typeof``, the compiler doesn't apply; an implicit bounds annotation on the pointer types named inside ``alignof()``.; Therefore, ``alignof(T *)`` remains the same with or without; ``-fbounds-safety``, evaluating into the alignment of the raw pointer ``T *``.; The programmers can explicitly add a bounds annotation to the types, e.g.,; ``alignof(int *__bidi_indexable)``, which returns the alignment of ``int; *__bidi_indexable``. A bounds annotation including an internal bounds annotation; (i.e., ``__indexable`` and ``__bidi_indexable``) doesn't affect the alignment of; the original pointer. Therefore, ``alignof(int *__bidi_indexable)`` is equal to; ``alignof(int *)``. Default pointer types used in C-style casts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer type used in a C-style cast (e.g., ``(int *)src``) inherits the same; pointer attribute in the type of src. For instance, if the type of src is ``T; *__single`` (with ``T`` being an arbitrary C type), ``(int *)src`` will be ``int; *__single``. The reasoning behind this behavior is so that a C-style cast; doesn't introduce any unexpected side effects caused by an implicit cast of; bounds attribute. Pointer casts can have explicit bounds annotations. For instance, ``(int; *__bidi_indexable)src`` casts to ``int *__bidi_indexable`` as long as src has a; bounds annotation that can implicitly convert to ``__bidi_indexable``. If; ``src`` has type ``int *__single``, it can implicitly convert to ``int; *__bidi_indexable`` which then will have the upper bound pointing to one past; the first element. However, if src has type ``int *__unsafe_indexable``, the; explicit cast ``(int *__bidi_indexable)src`` will cause an error because; ``__unsafe_indexable`` cannot cast to ``__bidi_indexable`` as; ``__unsafe_indexable`` doesn't have bounds information. `Cast rules`_ des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:30210,inherit,inherits,30210,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['inherit'],['inherits']
Modifiability,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The scheduling phase takes the DAG of target instructions from the selection; phase and assigns an order. The scheduler can pick an order depending on; various constraints of the machines (i.e. order for minimal register pressure or; try to cover instruction latencies). Once an order is established, the DAG is; converted to a list of :raw-html:`<tt>` `MachineInstr`_\s :raw-html:`</tt>` and; the SelectionDAG is destroyed. Note that this phase is logically separate from the instruction selection phase,; but is tied to it closely in the code because it operates on SelectionDAGs. Future directions for the SelectionDAG; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. #. Optional function-at-a-time selection. #. Auto-generate entire selector from ``.td`` file. .. _SSA-based Machine Code Optimizations:. SSA-based Machine Code Optimizations; ------------------------------------. To Be Written. Live Intervals; --------------. Live Intervals are the ranges (intervals) where a variable is *live*. They are; used by some `register allocator`_ passes to determine if two or more virtual; registers which require the same physical register are live at the same point in; the program (i.e., they conflict). When this situation occurs, one virtual; register must be *spilled*. Live Variable Analysis; ^^^^^^^^^^^^^^^^^^^^^^. The first step in determining the live intervals of variables is to calculate; the set of registers that are immediately dead after the instruction (i.e., the; instruction calculates the value, but it is never used) and the set of registers; that are used by the instruction, but are never used after the instruction; (i.e., they are killed). Live variable information is computed for; each *virtual* register and *register allocatable* physical register; in the function. This is done in a very efficient manner because it uses SSA to; sparsely compute lifetime information for virtual registers (which are in SSA; form) and only has to tra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:54524,variab,variable,54524,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['variab'],['variable']
Modifiability,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ``__block`` variable that is also marked ``__attribute__((NSObject))`` should; have ``byref_keep`` and ``byref_dispose`` helper functions that use; ``_Block_object_assign`` and ``_Block_object_dispose``. ``__block`` escapes; ^^^^^^^^^^^^^^^^^^^. Because ``Blocks`` referencing ``__block`` variables may have ``Block_copy()``; performed upon them the underlying storage for the variables may move to the; heap. In Objective-C Garbage Collection Only compilation environments the heap; used is the garbage collected one and no further action is required. Otherwise; the compiler must issue a call to potentially release any heap storage for; ``__block`` variables at all escapes or terminations of their scope. The call; should be:. .. code-block:: c. _Block_object_dispose(&_block_byref_foo, BLOCK_FIELD_IS_BYREF);. Nesting; ^^^^^^^. ``Blocks`` may contain ``Block`` literal expressions. Any variables used within; inner blocks are imported into all enclosing ``Block`` scopes even if the; variables are not used. This includes ``const`` imports as well as ``__block``; variables. Objective C Extensions to ``Blocks``; ====================================. Importing Objects; -----------------. Objects should be treated as ``__attribute__((NSObject))`` variables; all; ``copy_helper``, ``dispose_helper``, ``byref_keep``, and ``byref_dispose``; helper functions should use ``_Block_object_assign`` and; ``_Block_object_dispose``. There should be no code generated that uses; ``*-retain`` or ``*-release`` methods. ``Blocks`` as Objects; ---------------------. The compiler will treat ``Blocks`` as objects when synthesizing property setters; and getters, will characterize them as objects when generating garbage; collection strong and weak layout information in the same manner as objects, and; will issue strong and weak write-barrier assignments in the same manner as; objects. ``__weak __block`` Support; --------------------------. Objective-C ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:18385,variab,variables,18385,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,2,['variab'],['variables']
Modifiability,"^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific exam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6886,variab,variables,6886,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variables']
Modifiability,"_' identifier in item name, one can easily draw or superimpose; similar items from different files. Could be used in URL like:; `...&files=[file1.root,file2.root]&items=[file1.root/hpx, file2.root/_same_]`; `...&files=[file1.root,file2.root]&item=file1.root/hpx+file2.root/_same_`; Main limitation - file names should have similar length.; - When 'autozoom' specified in draw options, histogram zoomed into; non-empty content. Same command available via context menu.; - Item of 'Text' kind can be created. It is displayed as; lain text in the browser. If property 'mathjax' specified,; MathJax.js library will be loaded and used for rendering.; See tutorials/http/httpcontrol.C macro for example.; - When using foreignObject, provide workaround for absolute positioning; problem in Chrome/Safari, see <http://bit.ly/1wjqCQ9>; - Support usage of minimized versions of .js and .css files.; Minimized scripts used by default on web servers.; - Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; - Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; - Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; - Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE. ## TTree Libraries. ### TTree Behavior change. #### Merging. Added fast cloning support to TTree::MergeTrees and TTree::Merge(TCollection*,Option_t*). #### TTreeCache. The TTreeCache is now enabled by default. The default size of the TTreeCache; is the estimated size of a cluster size for the TTree. The TTreeCache; prefilling is also enabled by default; when in learning phase rather than; reading each requested branch individually, the TTreeCache will read all the; branches thus trading off the latencies inherent to multiple small reads for; the potential of requesting more data than needed by read from the d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:11981,extend,extend,11981,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['extend'],['extend']
Modifiability,"_1 = { 0, sizeof(struct __block_literal_1) };. and where the ``Block`` literal itself appears:. .. code-block:: c. struct __block_literal_1 _block_literal = {; &_NSConcreteStackBlock,; (1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. A ``Block`` imports other ``Block`` references, ``const`` copies of other; variables, and variables marked ``__block``. In Objective-C, variables may; additionally be objects. When a ``Block`` literal expression is used as the initial value of a global; or ``static`` local variable, it is initialized as follows:. .. code-block:: c. struct __block_literal_1 __block_literal_1 = {; &_NSConcreteGlobalBlock,; (1<<28)|(1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. that is, a different address is provided as the first value and a particular; (1<<28) bit is set in the ``flags`` field, and otherwise it is the same as for; stack based ``Block`` literals. This is an optimization that can be used for; any ``Block`` literal that imports no ``const`` or ``__block`` storage; variables. Imported Variables; ==================. Variables of ``auto`` storage class are imported as ``const`` copies. Variables; of ``__block`` storage class are imported as a pointer to an enclosing data; structure. Global variables are simply referenced and not considered as; imported. Imported ``const`` copy variables; ---------------------------------. Automatic storage variables not marked with ``__block`` are imported as; ``const`` copies. The simplest example is that of importing a variable of type ``int``:. .. code-block:: c. int x = 10;; void (^vv)(void) = ^{ printf(""x is %d\n"", x); }; x = 11;; vv();. which would be compiled to:. .. code-block:: c. struct __block_literal_2 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_2 *);; struct __block_descriptor_2 *descriptor;; const int x;; };. void __block_invoke_2(struct __block_literal_2 *_block) {; printf(""x is %d\n"", _block->x);; }. static str",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:6604,variab,variables,6604,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"_1RDF_1_1RInterface.html#a25026681111897058299161a70ad9bb2).; - Improve RDF node ownership model. The net effect is that users do not have to worry about keeping the first node of a computation graph in scope anymore.; - Make RResultPtr copy/move-assignable and copy/move-constructible.; - Add [GetColumnType](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#ad3ccd813d9fed014ae6a080411c5b5a8a) utility method to query the type of a RDF column (returned as a string).; - Add [PassAsVec](https://root.cern/doc/master/namespaceROOT_1_1RDF.html#a1ecc8a41e8f12e65e1bf0d2e65aec36d) helper function.; - Add [SaveGraph](https://root.cern/doc/master/namespaceROOT_1_1RDF.html#adc17882b283c3d3ba85b1a236197c533) helper function to write out the RDF computation graph as a graphviz file.; - Add a [tutorial for RDataFrame helper functions](https://root.cern/doc/master/df020__helpers_8C.html).; - Throw if name of a custom column is not a valid C++ name.; - Allow every RDataFrame variable be cast to a common type `ROOT::RDF::RNode`.; - Speed up just-in-time compilation (and therefore runtime) of Snapshots with a large number of branches.; - Create names for histograms and graphs based on the input columns if no model is provided.; - RCutFlowReport can print cumulative efficiency of cuts.; - Reading and writing of columns holding `vector<bool>` instances and `bool` C arrays.; - Support `rdfentry_` and `rdfslot_` implicit columns (`tdfentry_` and `tdfslot_` kept for backwards compatibility).; - Remove `RDataFrame` from the 32-bit builds.; - Speed up interpreted usage of RDataFrame (i.e. in macros or from ROOT prompt) by removing certain cling runtime safety checks.; - Streamline and better document usage of multi-thread RDataFrame: edge cases in which processing of an event could start; before processing of another event finished have been removed, making it easier for user to write safe parallel RDF operations.; See the [relevant documentation](https://root.cern.ch/doc/maste",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:9031,variab,variable,9031,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['variab'],['variable']
Modifiability,"_AR; CMAKE_RANLIB; DARWIN_LTO_LIBRARY; DYLD_LIBRARY_PATH). set(COMPILER_OPTIONS); set(LTO_LIBRARY); set(LTO_AR); set(LTO_RANLIB); endif(). # Populate the passthrough variables; foreach(variableName ${CLANG_BOOTSTRAP_PASSTHROUGH} ${_BOOTSTRAP_DEFAULT_PASSTHROUGH}); if(DEFINED ${variableName}); if(""${${variableName}}"" STREQUAL """"); set(value """"); else(); string(REPLACE "";"" ""|"" value ""${${variableName}}""); endif(); list(APPEND PASSTHROUGH_VARIABLES; -D${variableName}=${value}); endif(); endforeach(). # Find all variables that start with BOOTSTRAP_ and populate a variable with; # them.; get_cmake_property(variableNames VARIABLES); foreach(variableName ${variableNames}); if(variableName MATCHES ""^BOOTSTRAP_""); string(SUBSTRING ${variableName} 10 -1 varName); string(REPLACE "";"" ""|"" value ""${${variableName}}""); list(APPEND PASSTHROUGH_VARIABLES; -D${varName}=${value}); endif(); if(${variableName} AND variableName MATCHES ""LLVM_EXTERNAL_.*_SOURCE_DIR""); list(APPEND PASSTHROUGH_VARIABLES; -D${variableName}=${${variableName}}); endif(); endforeach(). # Build arguments for native tool used in CMake.; set(build_configuration ""$<CONFIG>""); set(build_tool_args ""${LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS}""); if(NOT build_tool_args STREQUAL """"); string(PREPEND build_tool_args ""-- ""); separate_arguments(build_tool_args UNIX_COMMAND ""${build_tool_args}""); endif(). ExternalProject_Add(${NEXT_CLANG_STAGE}; DEPENDS clang-bootstrap-deps; PREFIX ${NEXT_CLANG_STAGE}; SOURCE_DIR ${CMAKE_SOURCE_DIR}; STAMP_DIR ${STAMP_DIR}; BINARY_DIR ${BINARY_DIR}; EXCLUDE_FROM_ALL 1; CMAKE_ARGS; # We shouldn't need to set this here, but INSTALL_DIR doesn't; # seem to work, so instead I'm passing this through; -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}; ${PASSTHROUGH_VARIABLES}; ${CLANG_BOOTSTRAP_CMAKE_ARGS}; -DCLANG_STAGE=${NEXT_CLANG_STAGE}; ${COMPILER_OPTIONS}; ${${CLANG_STAGE}_TABLEGEN}; ${LTO_LIBRARY} ${verbose} ${PGO_OPT}; ${${CLANG_STAGE}_LINKER}; ${${CLANG_STAGE}_AR}; ${${CLANG_STAGE}_RANLIB}; ${${",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:27649,variab,variableName,27649,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,2,['variab'],['variableName']
Modifiability,"_CURRENT_SOURCE_DIR}/config.guess_patch1 ${UNR_UNTARDIR}/autoconf/config.guess; WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR} ); endif(). if(WIN32); configure_file(${CMAKE_CURRENT_SOURCE_DIR}/config.h.win.in ${UNR_UNTARDIR}/config.h); else(); #---Define special compiler settings for unurun-----------------------------------------------------; set(UNR_CC ${CMAKE_C_COMPILER}); if(ROOT_ARCHITECTURE MATCHES hpuxia64acc); set(UNR_CC ""${UNR_CC} +DD64 -Ae""); elseif(ROOT_ARCHITECTURE MATCHES linuxppc64gcc); set(UNR_CC ""${UNR_CC} -m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664gcc); set(UNR_CFLAGS ""-m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxicc); set(UNR_CFLAGS ""-m32""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664icc); set(UNR_CFLAGS ""-m64""); elseif(ROOT_ARCHITECTURE MATCHES win32 OR ROOT_ARCHITECTURE MATCHES win64); set(UNR_CFLAGS ""-MD -G5 -GX""); endif(); if(CMAKE_OSX_SYSROOT); set(UNR_CFLAGS ""${UNR_CFLAGS} -isysroot ${CMAKE_OSX_SYSROOT}""); endif(). #---configure unuran (required for creating the config.h used by unuran source files)----------------; add_custom_command(OUTPUT ${UNR_UNTARDIR}/config.h; COMMAND GNUMAKE=make ./configure CC=${UNR_CC} CFLAGS=${UNR_CFLAGS} > /dev/null 2>& 1; WORKING_DIRECTORY ${UNR_UNTARDIR}); endif(). #---We need to disable some warnings-------------------------------------------------------------------; string(REPLACE -Wall """" CMAKE_C_FLAGS ""${CMAKE_C_FLAGS}""); if(${CMAKE_CXX_COMPILER_ID} MATCHES Clang); ROOT_ADD_C_FLAG(CMAKE_C_FLAGS -Wno-parentheses-equality); ROOT_ADD_C_FLAG(CMAKE_C_FLAGS -Wno-deprecated-non-prototype); endif(); if(${CMAKE_CXX_COMPILER_ID} MATCHES GNU); ROOT_ADD_C_FLAG(CMAKE_C_FLAGS -Wno-maybe-uninitialized); ROOT_ADD_C_FLAG(CMAKE_C_FLAGS -Wno-alloc-size-larger-than). endif(). set(unrsources ${UNR_UNTARDIR}/src/utils/*.c; ${UNR_UNTARDIR}/src/methods/*.c; ${UNR_UNTARDIR}/src/specfunct/*.c; ${UNR_UNTARDIR}/src/distr/*.c; ${UNR_UNTARDIR}/src/distributions/*.c; ${UNR_UNTARDIR}/src/parser/*.c; ${UNR_UNTARDIR}/src/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt:2216,config,configure,2216,math/unuran/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt,2,['config'],"['config', 'configure']"
Modifiability,"_HTTPLIB**:BOOL; Enables the optional cpp-httplib dependency which is used by llvm-debuginfod; to serve debug info over HTTP. `cpp-httplib <https://github.com/yhirose/cpp-httplib>`_; must be installed, or `httplib_ROOT` must be set. Defaults to OFF. **LLVM_ENABLE_FFI**:BOOL; Indicates whether the LLVM Interpreter will be linked with the Foreign Function; Interface library (libffi) in order to enable calling external functions.; If the library or its headers are installed in a custom; location, you can also set the variables FFI_INCLUDE_DIR and; FFI_LIBRARY_DIR to the directories where ffi.h and libffi.so can be found,; respectively. Defaults to OFF. **LLVM_ENABLE_IDE**:BOOL; Tell the build system that an IDE is being used. This in turn disables the; creation of certain convenience build system targets, such as the various; ``install-*`` and ``check-*`` targets, since IDEs don't always deal well with; a large number of targets. This is usually autodetected, but it can be; configured manually to explicitly control the generation of those targets. **LLVM_ENABLE_LIBCXX**:BOOL; If the host compiler and linker supports the stdlib flag, -stdlib=libc++ is; passed to invocations of both so that the project is built using libc++; instead of stdlibc++. Defaults to OFF. **LLVM_ENABLE_LLVM_LIBC**: BOOL; If the LLVM libc overlay is installed in a location where the host linker; can access it, all built executables will be linked against the LLVM libc; overlay before linking against the system libc. Defaults to OFF. **LLVM_ENABLE_LIBPFM**:BOOL; Enable building with libpfm to support hardware counter measurements in LLVM; tools.; Defaults to ON. **LLVM_ENABLE_LLD**:BOOL; This option is equivalent to `-DLLVM_USE_LINKER=lld`, except during a 2-stage; build where a dependency is added from the first stage to the second ensuring; that lld is built before stage2 begins. **LLVM_ENABLE_LTO**:STRING; Add ``-flto`` or ``-flto=`` flags to the compile and link command; lines, enabling link-ti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:22417,config,configured,22417,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['config'],['configured']
Modifiability,"_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2392,variab,variables,2392,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,2,['variab'],"['variable', 'variables']"
Modifiability,"_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <Macros>`; A list of macros of the form ``<definition>=<expansion>`` . Code will be parsed with macros",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84647,config,configuration,84647,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"_SUFFIX} COMPONENT tf_xla_runtime); set_property(GLOBAL APPEND PROPERTY LLVM_EXPORTS tf_xla_runtime); # Once we add more modules, we should handle this more automatically.; if (DEFINED LLVM_OVERRIDE_MODEL_HEADER_INLINERSIZEMODEL); set(LLVM_INLINER_MODEL_PATH ""none""); elseif(NOT DEFINED LLVM_INLINER_MODEL_PATH; OR ""${LLVM_INLINER_MODEL_PATH}"" STREQUAL """"; OR ""${LLVM_INLINER_MODEL_PATH}"" STREQUAL ""autogenerate""); set(LLVM_INLINER_MODEL_PATH ""autogenerate""); set(LLVM_INLINER_MODEL_AUTOGENERATED 1); endif(); if (DEFINED LLVM_OVERRIDE_MODEL_HEADER_REGALLOCEVICTMODEL); set(LLVM_RAEVICT_MODEL_PATH ""none""); elseif(NOT DEFINED LLVM_RAEVICT_MODEL_PATH; OR ""${LLVM_RAEVICT_MODEL_PATH}"" STREQUAL """"; OR ""${LLVM_RAEVICT_MODEL_PATH}"" STREQUAL ""autogenerate""); set(LLVM_RAEVICT_MODEL_PATH ""autogenerate""); set(LLVM_RAEVICT_MODEL_AUTOGENERATED 1); endif(). endif(). # Configure the three LLVM configuration header files.; configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/config.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/config.h); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/llvm-config.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/llvm-config.h); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/abi-breaking.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/abi-breaking.h). # Add target for generating source rpm package.; set(LLVM_SRPM_USER_BINARY_SPECFILE ${CMAKE_CURRENT_SOURCE_DIR}/llvm.spec.in; CACHE FILEPATH "".spec file to use for srpm generation""); set(LLVM_SRPM_BINARY_SPECFILE ${CMAKE_CURRENT_BINARY_DIR}/llvm.spec); set(LLVM_SRPM_DIR ""${CMAKE_CURRENT_BINARY_DIR}/srpm""). get_source_info(${CMAKE_CURRENT_SOURCE_DIR} revision repository); string(LENGTH ""${revision}"" revision_length); set(LLVM_RPM_SPEC_REVISION ""${revision}""). configure_file(; ${LLVM_SRPM_USER_BINARY_SPECFILE}; ${LLVM_SRPM_BINARY_SPECFILE} @ONLY). add_custom_target(srpm; COMMAND cpack -G TGZ --config CPackSourceConfig.cmake -B ${LLVM_SRPM_DIR}/SOURCES; COMMAND rpmbuild -bs --define '_topdir ${LLVM_SRPM_DIR}' ${LLVM_SR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:44961,config,config,44961,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config']
Modifiability,"_SeparateDefinitionBlocks:. **SeparateDefinitionBlocks** (``SeparateDefinitionStyle``) :versionbadge:`clang-format 14` :ref:`¶ <SeparateDefinitionBlocks>`; Specifies the use of empty lines to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private:; } int t;; enum List {; ITEM1, int method1() {; ITEM2 // ...; }; }; template<typename T>; int method2(T x) { enum List {; // ... ITEM1,; } ITEM2; int i, j, k; };; int method3(int par) {; // ... template<typename T>; } int method2(T x) {; }; // ...; class C {}; }; }; int i, j, k;. int method3(int par) {; // ...; }; };. class C {};; }. Possible values:. * ``SDS_Leave`` (in configuration: ``Leave``); Leave definition blocks as they are. * ``SDS_Always`` (in configuration: ``Always``); Insert an empty line between definition blocks. * ``SDS_Never`` (in configuration: ``Never``); Remove any empty line between definition blocks. .. _ShortNamespaceLines:. **ShortNamespaceLines** (``Unsigned``) :versionbadge:`clang-format 13` :ref:`¶ <ShortNamespaceLines>`; The maximal number of unwrapped lines that a short namespace spans.; Defaults to 1. This determines the maximum length of short namespaces by counting; unwrapped lines (i.e. containing neither opening nor closing; namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:107857,config,configuration,107857,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"_VARIABLES}; INSTALL_COMMAND """"; STEP_TARGETS configure build; USES_TERMINAL_CONFIGURE 1; USES_TERMINAL_BUILD 1; USES_TERMINAL_INSTALL 1; # Always run the build command so that incremental builds are correct.; BUILD_ALWAYS 1; ). get_ext_project_build_command(run_clean_compiler_rt clean); ExternalProject_Add_Step(compiler-rt clean; COMMAND ${run_clean_compiler_rt}; COMMENT ""Cleaning compiler-rt...""; DEPENDEES configure; DEPENDERS build; DEPENDS clang; WORKING_DIRECTORY ${BINARY_DIR}; ). install(CODE ""execute_process\(COMMAND \${CMAKE_COMMAND} -DCMAKE_INSTALL_PREFIX=\${CMAKE_INSTALL_PREFIX} -P ${BINARY_DIR}/cmake_install.cmake \)""; COMPONENT compiler-rt). add_llvm_install_targets(install-compiler-rt; DEPENDS compiler-rt; COMPONENT compiler-rt). # Add top-level targets that build specific compiler-rt runtimes.; set(COMPILER_RT_RUNTIMES fuzzer asan builtins dfsan lsan msan profile tsan ubsan ubsan-minimal); foreach(runtime ${COMPILER_RT_RUNTIMES}); get_ext_project_build_command(build_runtime_cmd ${runtime}); add_custom_target(${runtime}; COMMAND ${build_runtime_cmd}; DEPENDS compiler-rt-configure; WORKING_DIRECTORY ${BINARY_DIR}; VERBATIM USES_TERMINAL); endforeach(). if(LLVM_INCLUDE_TESTS); # Add binaries that compiler-rt tests depend on.; set(COMPILER_RT_TEST_DEPENDENCIES; FileCheck count not llvm-nm llvm-objdump llvm-symbolizer llvm-jitlink lli split-file). # Add top-level targets for various compiler-rt test suites.; set(COMPILER_RT_TEST_SUITES; check-asan; check-asan-dynamic; check-cfi; check-cfi-and-supported; check-dfsan; check-fuzzer; check-gwp_asan; check-hwasan; check-lsan; check-msan; check-profile; check-safestack; check-sanitizer; check-tsan; check-ubsan; check-ubsan-minimal; ); foreach(test_suite ${COMPILER_RT_TEST_SUITES}); get_ext_project_build_command(run_test_suite ${test_suite}); add_custom_target(${test_suite}; COMMAND ${run_test_suite}; DEPENDS compiler-rt-build ${COMPILER_RT_TEST_DEPENDENCIES}; WORKING_DIRECTORY ${BINARY_DIR}; VERBATIM; USES_TERMIN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt:4686,config,configure,4686,interpreter/llvm-project/clang/runtime/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt,1,['config'],['configure']
Modifiability,"_arg with aggregate; types on any target. .. _i_landingpad:. '``landingpad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = landingpad <resultty> <clause>+; <resultval> = landingpad <resultty> cleanup <clause>*. <clause> := catch <type> <value>; <clause> := filter <array constant type> <array constant>. Overview:; """""""""""""""""". The '``landingpad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.html#overview>`_ to specify that a basic block; is a landing pad --- one where the exception lands, and corresponds to the; code found in the ``catch`` portion of a ``try``/``catch`` sequence. It; defines values supplied by the :ref:`personality function <personalityfn>` upon; re-entry to the function. The ``resultval`` has the type ``resultty``. Arguments:; """""""""""""""""""". The optional; ``cleanup`` flag indicates that the landing pad block is a cleanup. A ``clause`` begins with the clause type --- ``catch`` or ``filter`` --- and; contains the global variable representing the ""type"" that may be caught; or filtered respectively. Unlike the ``catch`` clause, the ``filter``; clause takes an array constant as its argument. Use; ""``[0 x ptr] undef``"" for a filter which cannot throw. The; '``landingpad``' instruction must contain *at least* one ``clause`` or; the ``cleanup`` flag. Semantics:; """""""""""""""""""". The '``landingpad``' instruction defines the values which are set by the; :ref:`personality function <personalityfn>` upon re-entry to the function, and; therefore the ""result type"" of the ``landingpad`` instruction. As with; calling conventions, how the personality function results are; represented in LLVM IR is target specific. The clauses are applied in order from top to bottom. If two; ``landingpad`` instructions are merged together through inlining, the; clauses from the calling function are appended to the list of clauses.; When the call stack is being unwound due to an exception being thrown,; the exception is compared a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:481412,variab,variable,481412,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"_as<int>;; };. .. _AllowShortEnumsOnASingleLine:. **AllowShortEnumsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <AllowShortEnumsOnASingleLine>`; Allow short enums on a single line. .. code-block:: c++. true:; enum { A, B } myEnum;. false:; enum {; A,; B; } myEnum;. .. _AllowShortFunctionsOnASingleLine:. **AllowShortFunctionsOnASingleLine** (``ShortFunctionStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortFunctionsOnASingleLine>`; Dependent on the value, ``int f() { return 0; }`` can be put on a; single line. Possible values:. * ``SFS_None`` (in configuration: ``None``); Never merge functions into a single line. * ``SFS_InlineOnly`` (in configuration: ``InlineOnly``); Only merge functions defined inside a class. Same as ""inline"",; except it does not implies ""empty"": i.e. top level empty functions; are not merged either. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {; }. * ``SFS_Empty`` (in configuration: ``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:29300,config,configuration,29300,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"_assert(!__builtin_is_aligned(123, 64), """");. **Description**:. The builtins ``__builtin_align_up``, ``__builtin_align_down``, return their; first argument aligned up/down to the next multiple of the second argument.; If the value is already sufficiently aligned, it is returned unchanged.; The builtin ``__builtin_is_aligned`` returns whether the first argument is; aligned to a multiple of the second argument.; All of these builtins expect the alignment to be expressed as a number of bytes. These builtins can be used for all integer types as well as (non-function); pointer types. For pointer types, these builtins operate in terms of the integer; address of the pointer and return a new pointer of the same type (including; qualifiers such as ``const``) with an adjusted address.; When aligning pointers up or down, the resulting value must be within the same; underlying allocation or one past the end (see C17 6.5.6p8, C++ [expr.add]).; This means that arbitrary integer values stored in pointer-type variables must; not be passed to these builtins. For those use cases, the builtins can still be; used, but the operation must be performed on the pointer cast to ``uintptr_t``. If Clang can determine that the alignment is not a power of two at compile time,; it will result in a compilation failure. If the alignment argument is not a; power of two at run time, the behavior of these builtins is undefined. Non-standard C++11 Attributes; =============================. Clang's non-standard C++11 attributes live in the ``clang`` attribute; namespace. Clang supports GCC's ``gnu`` attribute namespace. All GCC attributes which; are accepted with the ``__attribute__((foo))`` syntax are also accepted as; ``[[gnu::foo]]``. This only extends to attributes which are specified by GCC; (see the list of `GCC function attributes; <https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html>`_, `GCC variable; attributes <https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html>`_, and; `GCC t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:152889,variab,variables,152889,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variables']
Modifiability,"_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. Similar to the conditional statements, these generally behave how you would; expect, and they do not have their own scope. CMake also supports ``while`` loops, although they are not widely used in LLVM. Modules, Functions and Macros; =============================. Modules; -------. Modules are CMake's vehicle for enabling code reuse. CMake modules are just; CMake script files. They can contain code to execute on include as well as; definitions for commands. In CMake macros and functions are universally referred to as commands, and they; are the primary method of defining code that can be called multiple times. In LLVM we have several CMake modules that are included as part of our; distribution for developers who don't build our project from source. Those; modules are the fundamental pieces needed to build LLVM-based projects with; CMake. We also rely on modules as a way of organizing the build system's; functionality for maintainability and re-use within LLVM projects. Argument Handling; -----------------. When defining a CMake command handling arguments is very useful. The examples; in this section will all use the CMake ``function`` block, but this all applies; to the ``macro`` block as well. CMake commands can have named arguments that are required at every call site. In; addition, all commands will implicitly accept a variable number of extra; arguments (In C parlance, all commands are varargs functions). When a command is; invoked with extra arguments (beyond the named ones) CMake will store the full; list of arguments (both named and unnamed) in a list named ``ARGV``, and the; sublist of unnamed arguments in ``ARGN``. Below is a trivial example of; providing a wrapper function for CMake's built in function ``add_dependencies``. .. code-block:: cmake. function(add_deps target); add_dependencies(${target} ${ARGN}); endfunction(). This example defines a new macro named ``add_deps`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:10185,maintainab,maintainability,10185,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['maintainab'],['maintainability']
Modifiability,"_length>); declare <vscale x 4 x i32> @llvm.vp.zext.nxv4i32.nxv4i16 (<vscale x 4 x i16> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.zext``' intrinsic zero extends its first operand to the return; type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.zext``' intrinsic takes a value to cast as its first operand.; The return type is the type to cast the value to. Both types must be vectors of; :ref:`integer <t_integer>` type. The bit size of the value must be smaller than; the bit size of the return type. The second operand is the vector mask. The; return type, the value to cast, and the vector mask have the same number of; elements. The third operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.zext``' intrinsic fill the high order bits of the value with zero; bits until it reaches the size of the return type. When zero extending from i1,; the result will always be either 0 or 1. The conversion is performed on lane; positions below the explicit vector length and where the vector mask is true.; Masked-off lanes are ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x i32> @llvm.vp.zext.v4i32.v4i16(<4 x i16> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = zext <4 x i16> %a to <4 x i32>; %also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> poison. .. _int_vp_sext:. '``llvm.vp.sext.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llvm.vp.sext.v16i32.v16i16 (<16 x i16> <op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x i32> @llvm.vp.sext.nxv4i32.nxv4i16 (<vscale x 4 x i16> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.sext``' intrinsic sign extends its first operand to the return; type. The operation has a mask and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:798764,extend,extending,798764,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extending']
Modifiability,"_ref %__divergent_lane_pc;; DW_OP_call_ref %__active_lane_pc;; ];; e;; EXEC = ~EXEC & %1;; $lex_1_else:; DEFINE_DWARF %__divergent_lane_pc_1_else = DW_TAG_dwarf_procedure[; DW_AT_name = ""__divergent_lane_pc_1_else"";; DW_AT_location = DIExpression[; DW_OP_call_ref %__divergent_lane_pc;; DW_OP_addrx &lex_1_end;; DW_OP_stack_value;; DW_OP_LLVM_extend 64, 64;; DW_OP_call_ref %__lex_1_save_exec;; DW_OP_deref_type 64, %__uint_64;; DW_OP_LLVM_select_bit_piece 64, 64;; ];; ];; DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc, DIExpression[; DW_OP_call_ref %__divergent_lane_pc_1_else;; DW_OP_call_ref %__active_lane_pc;; ];; f;; EXEC = %1;; $lex_1_end:; DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc DIExpression[; DW_OP_call_ref %__divergent_lane_pc;; DW_OP_call_ref %__active_lane_pc;; ];; g;; $lex_end:. The DWARF procedure ``%__active_lane_pc`` is used to update the lane pc elements; that are active, with the current program location. Artificial variables %__lex_1_save_exec and %__lex_1_1_save_exec are created for; the execution masks saved on entry to a region. Using the ``DBG_VALUE`` pseudo; instruction, location list entries will be created that describe where the; artificial variables are allocated at any given program location. The compiler; may allocate them to registers or spill them to memory. The DWARF procedures for each region use the values of the saved execution mask; artificial variables to only update the lanes that are active on entry to the; region. All other lanes retain the value of the enclosing region where they were; last active. If they were not active on entry to the subprogram, then will have; the undefined location description. Other structured control flow regions can be handled similarly. For example,; loops would set the divergent program location for the region at the end of the; loop. Any lanes active will be in the loop, and any lanes not active must have; exited the loop. An ``IF/THEN/ELSEIF/ELSEIF/...`` region can be treated as a nest of; ``IF/T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:107902,variab,variables,107902,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variables']
Modifiability,"_t ReadSequence(const TStreamerInfoActions::TActionSequence &sequence,; void *start_collection, void *end_collection);. The 1st version is optimized to read a single object. The 2nd version is optimized to read the content of TClonesArrays and vectors of pointers to objects. The 3rd version is used to streamed any collections. TBufferXML and TBufferSQL overload the loops to introduce extra code to help the buffer keep track of which streamer element is being streamed (this functionality is not used by TBufferFile.). A TStreamerInfoActions::TActionSequence is an ordered sequence of configured actions. A configured action has both an action which is a free standing function and a configuration object deriving; from TStreamerInfoActions::TConfiguration. The configuration contains information that is specific to the action; but varies from use to use, including the offset from the beginning of the object that needs to be updated.; Other examples of configuration include the number of bits requested for storing a Double32_t or its factor and minimum. When the sequence is intended for a collection, the sequence has a configuration object deriving; from TStreamerInfoActions::TLoopConfiguration which contains for example the size of the element of; a vector or the pointers to the iterators functions (see below). Each TStreamerInfo has 2 reading sequences, one for object-wise reading (GetReadObjectWiseActions); and one for member-wise reading (GetReadMemberWiseActions) which is used when streaming a TClonesArray; of a vector of pointer to the type of objects described by the TClass. Each collection proxy has at least one reading sequences, one for the reading each version of the; contained class layout. Each case of the TStreamerInfo::ReadBuffer switch statement is replaced by 4 new action functions,; one for the object wise reading, one for the member wise reading for TClonesArray and vector of pointers,; one for the member wise reading for a vector of object and one for al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:4568,config,configuration,4568,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,1,['config'],['configuration']
Modifiability,"_t doEval(Double_t x) {; return f(x);; }; private:; Function f;; Bool_t status;; };; //this macro exposes the class into R's environment; // and lets you pass objects directly.; ROOTR_EXPOSED_CLASS(MyFunctor). //Macro to create a module; ROOTR_MODULE(MyFunctorModule) {; ROOT::R::class_<MyFunctor>( ""MyFunctor"" ); //creating a default constructor; .constructor(); //adding the method doEval to evaluate the internal function; .method( ""doEval"", &MyFunctor::doEval ); .method( ""getStatus"", &MyFunctor::getStatus); ;; }. void Functor(); {; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; ////////////////////////////////////////////////////////////; //Creating a functor with default function TMath::BesselY1//; // and status false from R's environment //; ////////////////////////////////////////////////////////////; //Loading module into R's environment; r[""MyFunctorModule""]<<LOAD_ROOTR_MODULE(MyFunctorModule);. //creating a class variable from the module; r<<""MyFunctor <- MyFunctorModule$MyFunctor"";; //creating a MyFunctor's object; r<<""u <- new(MyFunctor)"";. //printing status; r<<""print(u$getStatus())"";. //printing values from Functor and Function; r<<""print(sprintf('value in R = %f',u$doEval( 1 )))"";; std::cout<<""value in ROOT = ""<<TMath::BesselY1(1)<<std::endl;. ////////////////////////////////////////////////////////////; //creating a MyFunctor's object and passing object to R's //; //environment, the status should be true because is not //; //using the default function //; ////////////////////////////////////////////////////////////; MyFunctor functor;; functor.setFunction(TMath::Erf);; r[""functor""]<<functor;; //printing the status that should be true; r<<""print(functor$getStatus())"";; r<<""print(sprintf('value in R = %f',functor$doEval( 1 )))"";; std::cout<<""value in ROOT = ""<<TMath::Erf(1)<<std::endl;; }; ~~~. ## Simple fitting in R and plot in ROOT; The next example creates an exponential fit.; The idea is to create a set of numbers x,y with noise from ROOT,; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:13573,variab,variable,13573,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,1,['variab'],['variable']
Modifiability,"_unique<RField<float>>(""f"");; // assuming we have an array of floats stored in `myFloats`:; auto [minV, maxV] = std::minmax_element(myFloats.begin(), myFloats.end());; constexpr auto nBits = 24;; field->SetQuantized(*minV, *maxV, nBits);; model->AddField(std::move(field));; auto f = model->GetDefaultEntry().GetPtr<float>(""f"");. // Now we can write our floats.; auto writer = RNTupleWriter::Recreate(std::move(model), ""myNtuple"", ""myFile.root"");; for (float val : myFloats) {; *f = val;; writer->Fill();; }; ```. Relationship to other ROOT components; -------------------------------------. The RNTuple classes have the following relationship to other parts of ROOT. The RNTuple classes use core ROOT infrastructure classes, such as error handling and logging.; When necessary, RNTuple uses a `TFile` for reading and writing.; The cases of writing to a local file and reading from a local file, a file from XRootD or from HTTP, do _not_ require `TFile`.; For these cases, RNTuple depends on the `RRawFile` class and its XRootD and Davix plugins. For user-defined classes as well as sets and maps, RNTuple uses `TClass`.; Simple types and other stdlib classes are natively supported and do not require dictionaries.; See the format specification for an exhaustive list of types supported in RNTuple.; The streamer field uses the standard ROOT streaming machinery. Integration to RDataFrame is provided through an RNTuple data source.; A universal RDataFrame constructor can create a data frame from either a TTree or an RNTuple with the same syntax. The RBrowser uses RNTuple classes to display RNTuple dataset information. Future Features; ---------------. The following features are planned for after the first RNTuple production version:; - RNTupleProcessor: advanced RNTupleReader that allows for free combination of chains and (indexed/unaligned) friends; - Horizontal merging: persistified friends, analogous to a classical merge being a persistified chain; - An interface for bulk writing; - M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:28859,plugin,plugins,28859,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['plugin'],['plugins']
Modifiability,"` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global variables, functions and aliases may have an optional runtime preemption; specifie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25980,variab,variables,25980,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash screen and calls `root.exe` |; +---------------+------------------------------------------------------------+; | `root.exe` | the executable that `root` calls, if you use a debugger |; | | such as `gdb`, you will need to run `root.exe` directly |; +---------------+------------------------------------------------------------+; | `rootcling` | is the utility ROOT uses to create a class dictionary for |; | | Cling |; +---------------+------------------------------------------------------------+; | `rmkdepend` | a modified version of `makedepend` that is used by the |; | | ROOT build system |; +---------------+------------------------------------------------------------+; | `root-config` | a script returning the needed compile flags and libraries |; | | for projects that compile and link with ROOT |; +---------------+------------------------------------------------------------+; | `proofd` | a small daemon used to authenticate a user of ROOT |; | | parallel processing capability (PROOF) |; +---------------+------------------------------------------------------------+; | `proofserv` | the actual PROOF process, which is started by `proofd` |; | | after a user, has successfully been authenticated |; +---------------+------------------------------------------------------------+; | `rootd` | is the daemon for remote ROOT file access (see the |; | | **`TNetFile`**) |; +---------------+------------------------------------------------------------+. ### \$ROOTSYS/lib. There are several ways to use ROOT, one way is to run the executable; by typing `root` at the system prompt another way is to link with the; ROOT libraries and make the ROOT classes available in your own program. Here is a short description of the most relevant libraries, the ones; marked with a \* are only installed when the options specified them. - `libAsImage`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:12205,config,config,12205,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['config'],['config']
Modifiability,"` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:84473,variab,variable,84473,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variable']
Modifiability,"` mode.; - ``typeof`` and ``typeof_unqual`` are supported, only ``*23`` mode.; - Bit-precise integers (``_BitInt(N)``) are supported by default in ``*23``; mode, and as an extension in ``*17`` and earlier modes.; - ``[[]]`` attributes are supported by default in ``*23`` mode, and as an; extension in ``*17`` and earlier modes. GCC extensions not implemented yet; ----------------------------------. clang tries to be compatible with gcc as much as possible, but some gcc; extensions are not implemented yet:. - clang does not support decimal floating point types (``_Decimal32`` and; friends) yet.; - clang does not support nested functions; this is a complex feature; which is infrequently used, so it is unlikely to be implemented; anytime soon. In C++11 it can be emulated by assigning lambda; functions to local variables, e.g:. .. code-block:: cpp. auto const local_function = [&](int parameter) {; // Do something; };; ...; local_function(1);. - clang only supports global register variables when the register specified; is non-allocatable (e.g. the stack pointer). Support for general global; register variables is unlikely to be implemented soon because it requires; additional LLVM backend support.; - clang does not support static initialization of flexible array; members. This appears to be a rarely used extension, but could be; implemented pending user demand.; - clang does not support; ``__builtin_va_arg_pack``/``__builtin_va_arg_pack_len``. This is; used rarely, but in some potentially interesting places, like the; glibc headers, so it may be implemented pending user demand. Note; that because clang pretends to be like GCC 4.2, and this extension; was introduced in 4.3, the glibc headers will not try to use this; extension with clang at the moment.; - clang does not support the gcc extension for forward-declaring; function parameters; this has not shown up in any real-world code; yet, though, so it might never be implemented. This is not a complete list; if you find an u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:133918,variab,variables,133918,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"` on the example prints the following definitions:. .. code-block:: text. def bar { // Value; bit isMod = 0;; bit isRef = 1;; }; def foo { // Value; bit isMod = 1;; bit isRef = 0;; }; def snork { // Value; bit isMod = 1;; bit isRef = 1;; }. ``let`` --- override fields in classes or records; -------------------------------------------------. A ``let`` statement collects a set of field values (sometimes called; *bindings*) and applies them to all the classes and records defined by; statements within the scope of the ``let``. .. productionlist::; Let: ""let"" `LetList` ""in"" ""{"" `Statement`* ""}""; :| ""let"" `LetList` ""in"" `Statement`; LetList: `LetItem` ("","" `LetItem`)*; LetItem: `TokIdentifier` [""<"" `RangeList` "">""] ""="" `Value`. The ``let`` statement establishes a scope, which is a sequence of statements; in braces or a single statement with no braces. The bindings in the; :token:`LetList` apply to the statements in that scope. The field names in the :token:`LetList` must name fields in classes inherited by; the classes and records defined in the statements. The field values are; applied to the classes and records *after* the records inherit all the fields from; their parent classes. So the ``let`` acts to override inherited field; values. A ``let`` cannot override the value of a template argument. Top-level ``let`` statements are often useful when a few fields need to be; overridden in several records. Here are two examples. Note that ``let``; statements can be nested. .. code-block:: text. let isTerminator = true, isReturn = true, isBarrier = true, hasCtrlDep = true in; def RET : I<0xC3, RawFrm, (outs), (ins), ""ret"", [(X86retflag 0)]>;. let isCall = true in; // All calls clobber the non-callee saved registers...; let Defs = [EAX, ECX, EDX, FP0, FP1, FP2, FP3, FP4, FP5, FP6, ST0,; MM0, MM1, MM2, MM3, MM4, MM5, MM6, MM7, XMM0, XMM1, XMM2,; XMM3, XMM4, XMM5, XMM6, XMM7, EFLAGS] in {; def CALLpcrel32 : Ii32<0xE8, RawFrm, (outs), (ins i32imm:$dst, variable_ops),; ""call\t${dst:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:33437,inherit,inherited,33437,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherited']
Modifiability,"` or `TThreadExecutor`.; - Add `T RVec<T>::at>(size_t, T)` method to allow users to specify a default value to be returned in case the vector is shorter than the position specified. No exception is thrown.; - Add the `Concatenate` helper to merge the content of two `RVec<T>` instances.; - Generalise the `VecOps::Map` utility allowing to apply a callable on a set of RVecs and not only to one.; - Add the `DeltaR2`, `DeltaR` and `DeltaPhi` helpers for RVec.; - Add the `InvariantMass(es)` helpers computing the invariant mass from particle kinematics stored in RVecs.; - Add the `Max`, `Min`, `ArgMax`, and `ArgMin` helpers for RVec.; - Add the `Construct` helper to build an `RVec<T>` starting from N `RVec<P_i>`, where a constructor `T::T(P_0, P_1, ..., P_Nm1)` exists.; - Experimental PyROOT: Add `AsRVec` helper to adopt memory owned by numpy arrays with RVecs. ### [Clad](https://github.com/vgvassilev/clad); - Upgrade Clad to 0.5 The new release includes some improvements in both; Forward and Reverse mode:; * Extend the way to specify a dependent variables. Consider function,; `double f(double x, double y, double z) {...}`, `clad::differentiate(f, ""z"")`; is equivalent to `clad::differentiate(f, 2)`. `clad::gradient(f, ""x, y"")`; differentiates with respect to `x` and `y` but not `z`. The gradient results; are stored in a `_result` parameter in the same order as `x` and `y` were; specified. Namely, the result of `x` is stored in `_result[0]` and the result; of `y` in `_result[1]`. If we invert the arguments specified in the string to; `clad::gradient(f, ""y, x"")` the results will be stored inversely.; * Enable recursive differentiation.; * Support single- and multi-dimensional arrays -- works for arrays with constant; size like `double A[] = {1, 2, 3};`, `double A[3];` or `double A[1][2][3][4];`. ## RooFit Libraries; ### RooJohnson PDF; The Johnson SU PDF has been added to RooFit. It comes with an analytical integral and a generator function,; which make it superior (faster an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:13492,variab,variables,13492,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['variab'],['variables']
Modifiability,"` or ``multiclass``; definition (see `NAME`_). * A field local to a ``class``, such as the use of ``Bar`` in::. class Foo {; int Bar = 5;; int Baz = Bar;; }. * The name of a record definition, such as the use of ``Bar`` in the; definition of ``Foo``::. def Bar : SomeClass {; int X = 5;; }. def Foo {; SomeClass Baz = Bar;; }. * A field local to a record definition, such as the use of ``Bar`` in::. def Foo {; int Bar = 5;; int Baz = Bar;; }. Fields inherited from the record's parent classes can be accessed the same way. * A template argument of a ``multiclass``, such as the use of ``Bar`` in::. multiclass Foo <int Bar> {; def : SomeClass<Bar>;; }. * A variable defined with the ``defvar`` or ``defset`` statements. * The iteration variable of a ``foreach``, such as the use of ``i`` in::. foreach i = 0...5 in; def Foo#i;. .. productionlist::; SimpleValue8: `ClassID` ""<"" `ArgValueList` "">"". This form creates a new anonymous record definition (as would be created by an; unnamed ``def`` inheriting from the given class with the given template; arguments; see `def`_) and the value is that record. A field of the record can be; obtained using a suffix; see `Suffixed Values`_. Invoking a class in this manner can provide a simple subroutine facility.; See `Using Classes as Subroutines`_ for more information. .. productionlist::; SimpleValue9: `BangOperator` [""<"" `Type` "">""] ""("" `ValueListNE` "")""; :| `CondOperator` ""("" `CondClause` ("","" `CondClause`)* "")""; CondClause: `Value` "":"" `Value`. The bang operators provide functions that are not available with the other; simple values. Except in the case of ``!cond``, a bang operator takes a list; of arguments enclosed in parentheses and performs some function on those; arguments, producing a value for that bang operator. The ``!cond`` operator; takes a list of pairs of arguments separated by colons. See `Appendix A:; Bang Operators`_ for a description of each bang operator. Suffixed values; ---------------. The :token:`SimpleValue` value",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:17707,inherit,inheriting,17707,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inheriting']
Modifiability,"` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. Note that this works only for statically linked libraries. LLVM is split; into a large number of static libraries, and the list of libraries you; require may be much longer than the list above. To see a full list of; libraries use: ``llvm-config --libs all``. Using ``LINK_COMPONENTS`` as; described below, obviates the need to set ``LLVMLIBS``. ``LINK_COMPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add options that tell the compiler; the location of additional directories to search for header files. It is highly suggested that you append to ``CFLAGS`` and ``CPPFLAGS`` as; opposed to overwriting them. The LLVM ``Makefile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:7295,variab,variable,7295,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,2,"['config', 'variab']","['config', 'variable']"
Modifiability,"`!19`` indicates that ``Z`` is declared at line number 5 and column; number 11 inside of lexical scope ``!18``. The lexical scope itself resides; inside of subprogram ``!4`` described above. The scope information attached with each instruction provides a straightforward; way to find instructions covered by a scope. Object lifetime in optimized code; =================================. In the example above, every variable assignment uniquely corresponds to a; memory store to the variable's position on the stack. However in heavily; optimized code LLVM promotes most variables into SSA values, which can; eventually be placed in physical registers or memory locations. To track SSA; values through compilation, when objects are promoted to SSA values an; ``llvm.dbg.value`` intrinsic is created for each assignment, recording the; variable's new location. Compared with the ``llvm.dbg.declare`` intrinsic:. * A dbg.value terminates the effect of any preceding dbg.values for (any; overlapping fragments of) the specified variable.; * The dbg.value's position in the IR defines where in the instruction stream; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the program. For any; execution of the optimized program, the set of variable values presented to the; developer by the debugger should not show a state that would never have existed; in the execution of the unoptimized program, given the same input. Doing so; risks misleading the developer by reporting a state that does not exist,; damaging their understanding of the optimized program and undermining their; trust in the debugger. Sometimes perfectly preserving variable locations is not possible, often when a; redundant calculation is optimized ou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:18500,variab,variable,18500,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"`) and the option name:. .. code-block:: diff. // Options.td. + def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">;. Then, specify additional attributes via mix-ins:. * ``HelpText`` holds the text that will be printed besides the option name when; the user requests help (e.g. via ``clang --help``).; * ``Group`` specifies the ""category"" of options this option belongs to. This is; used by various tools to categorize and sometimes filter options.; * ``Flags`` may contain ""tags"" associated with the option. These may affect how; the option is rendered, or if it's hidden in some contexts.; * ``Visibility`` should be used to specify the drivers in which a particular; option would be available. This attribute will impact tool --help; * ``Alias`` denotes that the option is an alias of another option. This may be; combined with ``AliasArgs`` that holds the implied value. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; + Group<f_Group>, Visibility<[ClangOption, CC1Option]>,; + HelpText<""Load pass plugin from a dynamic shared object file."">;. New options are recognized by the ``clang`` driver mode if ``Visibility`` is; not specified or contains ``ClangOption``. Options intended for ``clang -cc1``; must be explicitly marked with the ``CC1Option`` flag. Flags that specify; ``CC1Option`` but not ``ClangOption`` will only be accessible via ``-cc1``.; This is similar for other driver modes, such as ``clang-cl`` or ``flang``. Next, parse (or manufacture) the command line arguments in the Clang driver and; use them to construct the ``-cc1`` job:. .. code-block:: diff. void Clang::ConstructJob(const ArgList &Args /*...*/) const {; ArgStringList CmdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:30797,plugin,plugin,30797,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['plugin'],['plugin']
Modifiability,"`); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directives after the hash. .. code-block:: c++. #if FOO; # if BAR; # include <foo>; # endif; #endif. * ``PPDIS_BeforeHash`` (in configuration: ``BeforeHash``); Indents directives before the hash. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. .. _IndentRequiresClause:. **IndentRequiresClause** (``Boolean``) :versionbadge:`clang-format 15` :ref:`¶ <IndentRequiresClause>`; Indent the requires clause in a template. This only applies when; ``RequiresClausePosition`` is ``OwnLine``, or ``WithFollowing``. In clang-format 12, 13 and 14 it was named ``IndentRequires``. .. code-block:: c++. true:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. false:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. .. _IndentWidth:. **IndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <IndentWidth>`; The number of columns to use for indentation. .. code-block:: c++. IndentWidth: 3. void f() {; someFunction();; if (true, false) {; f();; }; }. .. _IndentWrappedFunctionNames:. **IndentWrappedFunctionNames** (``Boolean``) :versionbadge:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:73504,config,configuration,73504,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"`, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73120,config,configuration,73120,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['configuration']
Modifiability,"`, but not in nested namespaces. Given; class vector {};; namespace foo {; class vector {};; namespace std {; class vector {};; }; }; namespace std {; inline namespace __1 {; class vector {}; // #1; namespace experimental {; class vector {};; }; }; }; cxxRecordDecl(hasName(""vector""), isInStdNamespace()) will match only #1. Matcher<Decl>isInstantiated; Matches declarations that are template instantiations or are inside; template instantiations. Given; template<typename T> void A(T t) { T i; }; A(0);; A(0U);; functionDecl(isInstantiated()); matches 'A(int) {...};' and 'A(unsigned) {...}'. Matcher<Decl>isPrivate; Matches private C++ declarations and C++ base specifers that specify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<Decl>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<Decl>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<DesignatedInitExpr>designatorCountIsunsigned N; Matches designated initializer expressions that contain; a specific number of designators. Example: Given; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };; point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };; designatorCountIs(2); matches '{ [2].y = 1.0, [0].x = 1.0 }',; but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:84957,inherit,inheritance,84957,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['inherit'],['inheritance']
Modifiability,"`. Continuing the example:. .. code-block:: cpp. foo[i] = i;; foo[0] = 0;. After this latest assignment, nothing can be said about the value of ``foo[i]``,; because ``foo[0]`` may have overwritten it! *Binding to a region R with a; concrete offset invalidates any symbolic offset bindings whose concrete offset; region is a super-region **or** sub-region of R.* All we know about ``foo[i]``; is that it is somewhere within ``foo``, so changing *anything* within ``foo``; might change ``foo[i]``, and changing *all* of ``foo`` (or its base region) will; *definitely* change ``foo[i]``. This logic could be improved by using the current constraints on ``i``, at the; cost of speed. The latter case could also be improved by matching region kinds,; i.e. changing ``foo[0].a`` is unlikely to affect ``foo[i].b``, no matter what; ``i`` is. For more detail, read through ``RegionStoreManager::removeSubRegionBindings`` in; RegionStore.cpp. ObjCIvarRegions; ---------------. Objective-C instance variables require a bit of special handling. Like struct; fields, they are not base regions, and when their parent object region is; invalidated, all the instance variables must be invalidated as well. However,; they have no concrete compile-time offsets (in the modern, ""non-fragile""; runtime), and so cannot easily be represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Consequently, although the base region of an ObjCIvarRegion is the entire; object, RegionStore offsets are computed from the start of the instance; variable. Thus it is not valid to assume that all bindings with non-symbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the enti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:2681,variab,variables,2681,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,1,['variab'],['variables']
Modifiability,"`. General purpose structured; exceptions (SEH) are more analogous to Linux signals, and they are dispatched by; userspace DLLs provided with Windows. Each frame on the stack has an assigned EH; personality routine, which decides what actions to take to handle the exception.; There are a few major personalities for C and C++ code: the C++ personality; (``__CxxFrameHandler3``) and the SEH personalities (``_except_handler3``,; ``_except_handler4``, and ``__C_specific_handler``). All of them implement; cleanups by calling back into a ""funclet"" contained in the parent function. Funclets, in this context, are regions of the parent function that can be called; as though they were a function pointer with a very special calling convention.; The frame pointer of the parent frame is passed into the funclet either using; the standard EBP register or as the first parameter register, depending on the; architecture. The funclet implements the EH action by accessing local variables; in memory through the frame pointer, and returning some appropriate value,; continuing the EH process. No variables live in to or out of the funclet can be; allocated in registers. The C++ personality also uses funclets to contain the code for catch blocks; (i.e. all user code between the braces in ``catch (Type obj) { ... }``). The; runtime must use funclets for catch bodies because the C++ exception object is; allocated in a child stack frame of the function handling the exception. If the; runtime rewound the stack back to frame of the catch, the memory holding the; exception would be overwritten quickly by subsequent function calls. The use of; funclets also allows ``__CxxFrameHandler3`` to implement rethrow without; resorting to TLS. Instead, the runtime throws a special exception, and then uses; SEH (``__try / __except``) to resume execution with new information in the child; frame. In other words, the successive unwinding approach is incompatible with Visual; C++ exceptions and general purpose Wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:22438,variab,variables,22438,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['variab'],['variables']
Modifiability,`; - :good:`100%`; * - mlir/unittests/Dialect/SPIRV; - `2`; - `2`; - `0`; - :good:`100%`; * - mlir/unittests/Dialect/Utils; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/ExecutionEngine; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Interfaces; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/IR; - `7`; - `7`; - `0`; - :good:`100%`; * - mlir/unittests/Pass; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/Rewrite; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Support; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/li,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:121829,plugin,plugins,121829,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Always break after the return type of function definitions. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int f();; int; f() {; return 1;; }. * ``RTBS_TopLevelDefinitions`` (in configuration: ``TopLevelDefinitions``); Always break after the return type of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int; f() {; return 1;; }. .. _AlwaysBreakBeforeMultilineStrings:. **AlwaysBreakBeforeMultilineStrings** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakBeforeMultilineStrings>`; If ``true``, always break before multiline string literals. This flag is mean to make cases where there are multiple multiline strings; in a file look more consistent. Thus, it will only take effect if wrapping; the string at that point leads to it being indented; ``ContinuationIndentWidth`` spaces from the start of the line. .. code-block:: c++. true: false:; aaaa = vs. aaaa = ""bbbb""; ""bbbb"" ""cccc"";; ""cccc"";. .. _AlwaysBreakTemplateDeclarations:. **AlwaysBreakTemplateDeclarations** (``BreakTemplateDeclarationsStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakTemplateDeclarations>`; The template declaration breaking style to use. Possible value",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:33997,config,configuration,33997,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"`; are used, or for the reasons defined in ``SIFrameLowering``.; 2. Runtime stack alignment is supported. SGPR34 is used as a base pointer (BP); to access the incoming stack arguments in the function. The BP is needed; only when the function requires the runtime stack alignment. 3. Allocating SGPR arguments on the stack are not supported. 4. No CFI is currently generated. See; :ref:`amdgpu-dwarf-call-frame-information`. .. note::. CFI will be generated that defines the CFA as the unswizzled address; relative to the wave scratch base in the unswizzled private address space; of the lowest address stack allocated local variable. ``DW_AT_frame_base`` will be defined as the swizzled address in the; swizzled private address space by dividing the CFA by the wavefront size; (since CFA is always at least dword aligned which matches the scratch; swizzle element size). If no dynamic stack alignment was performed, the stack allocated arguments; are accessed as negative offsets relative to ``DW_AT_frame_base``, and the; local variables and register spill slots are accessed as positive offsets; relative to ``DW_AT_frame_base``. 5. Function argument passing is implemented by copying the input physical; registers to virtual registers on entry. The register allocator can spill if; necessary. These are copied back to physical registers at call sites. The; net effect is that each function call can have these values in entirely; distinct locations. The IPRA can help avoid shuffling argument registers.; 6. Call sites are implemented by setting up the arguments at positive offsets; from SP. Then SP is incremented to account for the known frame size before; the call and decremented after the call. .. note::. The CFI will reflect the changed calculation needed to compute the CFA; from SP. 7. 4 byte spill slots are used in the stack frame. One slot is allocated for an; emergency spill slot. Buffer instructions are used for stack accesses and; not the ``flat_scratch`` instruction. .. TODO::. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:399094,variab,variables,399094,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variables']
Modifiability,"`LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no arguments and returning a ``bool``. Attributes that do not require custom semantic handling should set the; ``SemaHandler`` field to ``0``. Note that anything inheriting from; ``IgnoredAttr`` automatically do not get a semantic handler. All other; attributes are assumed to use a semantic handler by default. Attributes; without a semantic handler are not given a parsed attribute ``Kind`` enumerator. ""Simple"" attributes, that require no custom semantic processing aside from what; is automatically provided, should set the ``SimpleHandler`` field to ``1``. Target-specific attributes may share a spelling with other attributes in; different targets. For instance, the ARM and MSP430 targets both have an; attribute spelled ``GNU<""interrupt"">``, but with different parsing and semantic; requirements. To support this feature, an attribute inheriting from; ``TargetSpecificAttribute`` may specify a ``ParseKind`` field. This field; should be the same value between all arguments sharing a spelling, and; corresponds to the parsed attribute's ``Kind`` enumerator. This allows; attributes to share a parsed attribute kind, but have distinct semantic; attribute classes. For instance, ``Pars",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:139976,inherit,inheriting,139976,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['inherit'],['inheriting']
Modifiability,"`NumArgs`` and ``OptArgs``, which set the number of required and optional; arguments to the attribute.; * ``diagAppertainsToDecl``, which checks if the attribute has been used on the; right kind of declaration and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional para",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4419,plugin,plugin,4419,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,1,['plugin'],['plugin']
Modifiability,"`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented wrapping in C++ the GNU Scientific Library ( <GSL>).; Building `MathMore` requires a version of GSL larger or equal 1.8. The; source code of `MathMore` is distributed under the GNU General Public; License. `MathMore` (and its ROOT Cling dictionary) can be built within ROOT; whenever a GSL library is found in the system. The GSL library and; header file location can be specified in the ROOT configure script, by; doing:. ```; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; ```. `MathMore` can be built also a stand-alone library (without requiring; ROOT) downloding the tar file from the Web at this link. In this case; the library will not contain the dictionary information and therefore; cannot be used interactively. More information on the classes and functions present in `MathMore` is; available in the; [online reference documentation](online reference documentation). ## TMath. In the namespace, **`TMath`**, a collection of free functions is provided for the following functionality:. - numerical constants (like `pi`, `e`, `h`, etc.);. - trigonometric and elementary mathematical functions;. - functions to work with arrays and collections (e.g. functions to find `min` and `max` of arrays);. - statistic functions to work on array of data (e.g. mean and `RMS` of arrays);. - algorithms for binary search/hashing sorting;. - special mathematical fun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:5291,config,configure,5291,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['config'],['configure']
Modifiability,"`ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.; 3. Configure the fit.; 4. Perform the data fitting.; 5. Examine the result. ### Creating the input fit data. We have two types of input data, binned data (class `ROOT::Fit::BinData`) used for least square (chi-square) fits of histograms or `TGraph` objects; or un-binned data (class `ROOT::Fit::UnBinData`) used for; fitting vectors of data points (e.g. from a `TTree`). #### Using Binned data. Let's suppose we have an histogram, represented as a **`TH1`** type object (it can be one or multi-dimensional). The following shows how to create and; fill a `ROOT:Fit::BinData` object. ``` {.cpp}; ROOT:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:29179,extend,extended,29179,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['extend'],['extended']
Modifiability,"`Rxy`, `Phi`, `Rxyz`. A given shape cannot be divided; however on any axis. The general rule is that that divisions are; possible on whatever axis that produces still known shapes as slices.; The division of shapes are performed by the call `TGeoShape::Divide()`,; but this operation can be done only via `TGeoVolume::Divide()` method.; In other words, the algorithm for dividing a specific shape is known by; the shape object, but is always invoked in a generic way from the volume; level. Details on how to do that can be found in the paragraph ‘Dividing; volumes'. One can see how all division options are interpreted and which; their result inside specific shape classes is. \anchor SHAPES05; ### Parametric Shapes. Shapes generally have a set of parameters that is well defined at build; time. In fact, when the final geometrical hierarchy is assembled and the; geometry is closed, all constituent shapes `MUST`**have well defined and; valid parameters. In order to ease-up geometry creation, some; parameterizations are however allowed. For instance let's suppose that we need to define several volumes having; exactly the same properties but different sizes. A way to do this would; be to create as many different volumes and shapes. The modeller allows; however the definition of a single volume having undefined shape; parameters. ~~~ {.cpp}; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);; ~~~. - `name:` the name of the newly created volume;; - `shape:`the type of the associated shape. This has to contain the; case-insensitive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:8487,parameteriz,parameterizations,8487,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['parameteriz'],['parameterizations']
Modifiability,"`V``. * ``V`` in a ``foreach`` statement list shadows any ``V`` in surrounding record or; global scopes. Variables defined in a ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1). How records are built; ---------------------. The following steps are taken by TableGen when a record is built. Classes are simply; abstract records and so go through the same steps. 1. Build the record name (:token:`NameValue`) and create an empty record. 2. Parse the parent classes in the :token:`ParentClassList` from left to; right, visiting each parent class's ancestor classes from top to bottom. a. Add the fields from the parent class to the record.; b. Substitute the template arguments into those fields.; c. Add the parent class to the record's list of inherited classes. 3. Apply any top-level ``let`` bindings to the record. Recall that top-level; bindings only apply to inherited fields. 4. Parse the body of the record. * Add any fields to the record.; * Modify the values of fields according to local ``let`` statements.; * Define any ``defvar`` variables. 5. Make a pass over all the fields to resolve any inter-field references. 6. Add the record to the final record list. Because references between fields are resolved (step 5) after ``let`` bindings are; applied (step 3), the ``let`` statement has unusual power. For example:. .. code-block:: text. class C <int x> {; int Y = x;; int Yplus1 = !add(Y, 1);; int xplus1 = !add(x, 1);; }. let Y = 10 in {; def rec1 : C<5> {; }; }. def rec2 : C<5> {; let Y = 10;; }. In both cases, one where a top-level ``let`` is used to bind ``Y`` and one; where a local ``let`` does the same thing, the results are:. .. code-block:: text. def rec1 { // C; int Y = 10;; int Yplus1 = 11;; int xplus1 = 6;; }; def rec2 { // C; int Y = 10;; int Yplus1 = 11;; int xplus1 = 6;; }. ``Yplus1`` is 11 because the ``let Y`` is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:53911,inherit,inherited,53911,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherited']
Modifiability,"`X2`` in the; respective thread is convergence-before ``X1``,; - without assuming that ``X1`` is converged with ``X2``. .. _controlled_m_converged:. **Controlled m-converged Static Instances**. A node ``X`` in a given CFG is reported to be m-converged if and only if:. 1. For any token definition ``D`` such that ``X`` is inside the convergence region; of ``D``, ``D`` itself is m-converged, and,; 2. Every cycle that contains ``X`` satisfies the following necessary; conditions:. a. Every divergent branch inside the cycle satisfies the :ref:`diverged; entry criterion<convergence-diverged-entry>`, and,; b. There are no :ref:`diverged paths reaching the; cycle<convergence-diverged-outside>` from a divergent branch outside it. Temporal Divergence at Cycle Exit; ---------------------------------. When a cycle has a divergent exit, maximal convergence assumes that all threads; converge at the exit block. But if a controlled convergent operation outside the; cycle uses a token defined by an operation ``D`` inside the cycle, the; convergence region of ``D`` now extends outside the cycle. If two threads; executed converged dynamic instances of ``D`` before exiting the cycle, then; they continue to execute converged dynamic instances of nodes in the convergence; region of ``D`` outside the cycle. Thus, for a value ``V`` defined inside the; cycle, any use ``U`` of ``V`` within the convergence region of ``T`` uses the; output of converged dynamic instances of ``V``. If ``V`` is uniform, then its; use at such a ``U`` is also uniform. In other words, temporal divergence applies; only to a use of ``V`` that is outside the convergence region of ``D``. Rationales for Static rules about cycles; ========================================. (This section is informative.). .. note::. For convenience, we use the operator ``==`` to represent the relation; ``converged-with`` and the operator ``!=`` to represent its negation. Consider a loop with (incorrect!) convergence control as in the followin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:38338,extend,extends,38338,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['extend'],['extends']
Modifiability,"`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; sour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5004,plugin,plugin,5004,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,2,['plugin'],['plugin']
Modifiability,"`_. See `Examples: classes and records`_ for examples. Examples: classes and records; -----------------------------. Here is a simple TableGen file with one class and two record definitions. .. code-block:: text. class C {; bit V = true;; }. def X : C;; def Y : C {; let V = false;; string Greeting = ""Hello!"";; }. First, the abstract class ``C`` is defined. It has one field named ``V``; that is a bit initialized to true. Next, two records are defined, derived from class ``C``; that is, with ``C``; as their parent class. Thus they both inherit the ``V`` field. Record ``Y``; also defines another string field, ``Greeting``, which is initialized to; ``""Hello!""``. In addition, ``Y`` overrides the inherited ``V`` field,; setting it to false. A class is useful for isolating the common features of multiple records in; one place. A class can initialize common fields to default values, but; records inheriting from that class can override the defaults. TableGen supports the definition of parameterized classes as well as; nonparameterized ones. Parameterized classes specify a list of variable; declarations, which may optionally have defaults, that are bound when the; class is specified as a parent class of another class or record. .. code-block:: text. class FPFormat <bits<3> val> {; bits<3> Value = val;; }. def NotFP : FPFormat<0>;; def ZeroArgFP : FPFormat<1>;; def OneArgFP : FPFormat<2>;; def OneArgFPRW : FPFormat<3>;; def TwoArgFP : FPFormat<4>;; def CompareFP : FPFormat<5>;; def CondMovFP : FPFormat<6>;; def SpecialFP : FPFormat<7>;. The purpose of the ``FPFormat`` class is to act as a sort of enumerated; type. It provides a single field, ``Value``, which holds a 3-bit number. Its; template argument, ``val``, is used to set the ``Value`` field. Each of the; eight records is defined with ``FPFormat`` as its parent class. The; enumeration value is passed in angle brackets as the template argument. Each; record will inherent the ``Value`` field with the appropriate enumeration;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:29984,parameteriz,parameterized,29984,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['parameteriz'],['parameterized']
Modifiability,"`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors for types with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:1484,config,config,1484,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['config'],['config']
Modifiability,"`` / ``__finally``) mostly; work on x86 and x64.; LLVM does not model asynchronous exceptions, so it is currently impossible to; catch an asynchronous exception generated in the same frame as the catching; ``__try``. * Thread-safe initialization of local statics: :good:`Complete`. MSVC 2015; added support for thread-safe initialization of such variables by taking an; ABI break.; We are ABI compatible with both the MSVC 2013 and 2015 ABI for static local; variables. * Lambdas: :good:`Mostly complete`. Clang is compatible with Microsoft's; implementation of lambdas except for providing overloads for conversion to; function pointer for different calling conventions. However, Microsoft's; extension is non-conforming. Template instantiation and name lookup; ======================================. MSVC allows many invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:5194,extend,extended,5194,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,1,['extend'],['extended']
Modifiability,"`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function prototypes are considered ABI-visible. All ABI-visible pointers are treated as ``__single`` by default unless annotated; otherwise. This default both preserves ABI and makes these pointers safe by; default. This behavior can be controlled with macros, i.e.,; ``__ptrcheck_abi_assume_*ATTR*()``, to set the default annotation for; ABI-visible pointers to be either ``__single``, ``__bidi_indexable``,; ``__indexable``, or ``__unsafe_indexable``. For instance,; ``__ptrcheck_abi_assume_unsafe_indexable()`` will make all ABI-visible pointers; be ``__unsafe_indexable``. Non-ABI visible pointers — the outermost pointer; types of local variables — are ``__bidi_indexable`` by default, so that these; pointers have the bounds information necessary to perform bounds checks without; the need for a manual annotation. All ``const char`` pointers or any typedefs; equivalent to ``const char`` pointers are ``__null_terminated`` by default. This; means that ``char8_t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:21095,variab,variables,21095,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variables']
Modifiability,"`` determines *where* the definitions; reside, the layers determine *how* the definitions will be compiled.; Linkage relationships between ``JITDylibs`` determine how inter-module; references are resolved, and symbol resolvers are no longer used. See the; section `Design Overview`_ for more details. Unless multiple JITDylibs are needed to model linkage relationships, ORCv1; clients should place all code in a single JITDylib.; MCJIT clients should use LLJIT (see `LLJIT and LLLazyJIT`_), and can place; code in LLJIT's default created main JITDylib (See; ``LLJIT::getMainJITDylib()``). 2. All JIT stacks now need an ``ExecutionSession`` instance. ExecutionSession; manages the string pool, error reporting, synchronization, and symbol; lookup. 3. ORCv2 uses uniqued strings (``SymbolStringPtr`` instances) rather than; string values in order to reduce memory overhead and improve lookup; performance. See the subsection `How to manage symbol strings`_. 4. IR layers require ThreadSafeModule instances, rather than; std::unique_ptr<Module>s. ThreadSafeModule is a wrapper that ensures that; Modules that use the same LLVMContext are not accessed concurrently.; See `How to use ThreadSafeModule and ThreadSafeContext`_. 5. Symbol lookup is no longer handled by layers. Instead, there is a; ``lookup`` method on JITDylib that takes a list of JITDylibs to scan. .. code-block:: c++. ExecutionSession ES;; JITDylib &JD1 = ...;; JITDylib &JD2 = ...;. auto Sym = ES.lookup({&JD1, &JD2}, ES.intern(""_main""));. 6. The removeModule/removeObject methods are replaced by; ``ResourceTracker::remove``.; See the subsection `How to remove code`_. For code examples and suggestions of how to use the ORCv2 APIs, please see; the section `How-tos`_. How-tos; =======. How to manage symbol strings; ----------------------------. Symbol strings in ORC are uniqued to improve lookup performance, reduce memory; overhead, and allow symbol names to function as efficient keys. To get the; unique ``SymbolStringPtr`` for a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:21183,layers,layers,21183,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['layers'],['layers']
Modifiability,"`` file. .. _langref_datalayout:. Data Layout; -----------. A module may specify a target specific data layout string that specifies; how data is to be laid out in memory. The syntax for the data layout is; simply:. .. code-block:: llvm. target datalayout = ""layout specification"". The *layout specification* consists of a list of specifications; separated by the minus sign character ('-'). Each specification starts; with a letter and may include other information after the letter to; define some aspect of the data layout. The specifications accepted are; as follows:. ``E``; Specifies that the target lays out data in big-endian form. That is,; the bits with the most significance have the lowest address; location.; ``e``; Specifies that the target lays out data in little-endian form. That; is, the bits with the least significance have the lowest address; location.; ``S<size>``; Specifies the natural alignment of the stack in bits. Alignment; promotion of stack variables is limited to the natural stack; alignment to avoid dynamic stack realignment. The stack alignment; must be a multiple of 8-bits. If omitted, the natural stack; alignment defaults to ""unspecified"", which does not prevent any; alignment promotions.; ``P<address space>``; Specifies the address space that corresponds to program memory.; Harvard architectures can use this to specify what space LLVM; should place things such as functions into. If omitted, the; program memory space defaults to the default address space of 0,; which corresponds to a Von Neumann architecture that has code; and data in the same space.; ``G<address space>``; Specifies the address space to be used by default when creating global; variables. If omitted, the globals address space defaults to the default; address space 0.; Note: variable declarations without an address space are always created in; address space 0, this property only affects the default value to be used; when creating globals without additional contextual information (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:131857,variab,variables,131857,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"`` removes a defined symbol, but *does not* remove; its target block. * ``removeBlock`` removes the given block. * ``splitBlock`` split a given block in two at a given index (useful where; it is known that a block contains decomposable records, e.g. CFI records; in an eh-frame section). * Graph utility operations. * ``getName`` returns the name of this graph, which is usually based on the; name of the input object file. * ``getTargetTriple`` returns an `llvm::Triple` for the executor process. * ``getPointerSize`` returns the size of a pointer (in bytes) in the executor; process. * ``getEndinaness`` returns the endianness of the executor process. * ``allocateString`` copies data from a given ``llvm::Twine`` into the; link graph's internal allocator. This can be used to ensure that content; created inside a pass outlives that pass's execution. .. _generic_link_algorithm:. Generic Link Algorithm; ======================. JITLink provides a generic link algorithm which can be extended / modified at; certain points by the introduction of JITLink :ref:`passes`. At the end of each phase the linker packages its state into a *continuation*; and calls the ``JITLinkContext`` object to perform a (potentially high-latency); asynchronous operation: allocating memory, resolving external symbols, and; finally transferring linked memory to the executing process. #. Phase 1. This phase is called immediately by the ``link`` function as soon as the; initial configuration (including the pass pipeline setup) is complete. #. Run pre-prune passes. These passes are called on the graph before it is pruned. At this stage; ``LinkGraph`` nodes still have their original vmaddrs. A mark-live pass; (supplied by the ``JITLinkContext``) will be run at the end of this; sequence to mark the initial set of live symbols. Notable use cases: marking nodes live, accessing/copying graph data that; will be pruned (e.g. metadata that's important for the JIT, but not needed; for the link process). #. Prune (dea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:17458,extend,extended,17458,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['extend'],['extended']
Modifiability,"``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``' is stronger than '``undef``'. .. code-block:: llvm. %A = xor undef, undef. %B = undef; %C = xor %B, %B. %D = undef; %E = icmp slt %D, 4; %F = icmp gte %D, 4. Safe:; %A = undef; %B = undef; %C = undef; %D = undef; %E = undef; %F = undef. This example points out that two '``undef``' operands are not; necessarily the same. This can be surprising to people (and also matches; C semantics) where they assume that ""``X^X``"" is always zero, even if; ``X`` is undefined. This isn't true for a number of reasons, but the; short answer is that an '``undef``' ""variable"" can arbitrarily change; its value over its ""live range"". This is true because the variable; doesn't actually *have a live range*. Instead, the value is logically; read from arbitrary registers that happen to be around when needed, so; the value is not necessarily consistent over time. In fact, ``%A`` and; ``%C`` need to have the same semantics or the core LLVM ""replace all; uses with"" concept would not hold. To ensure all uses of a given register observe the same value (even if; '``undef``'), the :ref:`freeze instruction <i_freeze>` can be used. .. code-block:: llvm. %A = sdiv undef, %X; %B = sdiv %X, undef; Safe:; %A = 0; b: unreachable. These examples show the crucial difference between an *undefined value*; and *undefined behavior*. An undefined value (like '``undef``') is; allowed to have an arbitrary bit-pattern. This means that the ``%A``; operation can be constant folded to '``0``', because the '``undef``'; could be zero, and zero divided by any value is zero.; However, in the second example, we can make a more aggressive; assumption: because the ``undef`` is allowed to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:194106,variab,variable,194106,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"``); will build all of LLVM. * The ``check-all`` target (i.e. ``ninja check-all``) will run the; regression tests to ensure everything is in working order. * CMake will generate build targets for each tool and library, and most; LLVM sub-projects generate their own ``check-<project>`` target. * Running a serial build will be **slow**. To improve speed, try running a; parallel build. That's done by default in Ninja; for ``make``, use the; option ``-j NN``, where ``NN`` is the number of parallel jobs, e.g. the; number of available CPUs. * A basic CMake and build/test invocation which only builds LLVM and no other; subprojects:. ``cmake -S llvm -B build -G Ninja -DCMAKE_BUILD_TYPE=Debug``. ``ninja -C build check-llvm``. This will setup an LLVM build with debugging info, then compile LLVM and; run LLVM tests. * For more detailed information on CMake options, see `CMake <CMake.html>`__. * If you get build or test failures, see `below`_. Consult the `Getting Started with LLVM`_ section for detailed information on; configuring and compiling LLVM. Go to `Directory Layout`_ to learn about the; layout of the source code tree. Stand-alone Builds; ------------------. Stand-alone builds allow you to build a sub-project against a pre-built; version of the clang or llvm libraries that is already present on your; system. You can use the source code from a standard checkout of the llvm-project; (as described above) to do stand-alone builds, but you may also build; from a :ref:`sparse checkout<workflow-multicheckout-nocommit>` or from the; tarballs available on the `releases <https://github.com/llvm/llvm-project/releases/>`_; page. For stand-alone builds, you must have an llvm install that is configured; properly to be consumable by stand-alone builds of the other projects.; This could be a distro provided LLVM install, or you can build it yourself,; like this:. .. code-block:: console. cmake -G Ninja -S path/to/llvm-project/llvm -B $builddir \; -DLLVM_INSTALL_UTILS=ON \; -DCMAKE_INS",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:5016,config,configuring,5016,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configuring']
Modifiability,"``*23`` mode.; - ``ATOMIC_VAR_INIT`` is removed from ``*23`` mode.; - ``bool``, ``true``, ``false``, ``alignas``, ``alignof``, ``static_assert``,; and ``thread_local` are now first-class keywords, only in ``*23`` mode.; - ``typeof`` and ``typeof_unqual`` are supported, only ``*23`` mode.; - Bit-precise integers (``_BitInt(N)``) are supported by default in ``*23``; mode, and as an extension in ``*17`` and earlier modes.; - ``[[]]`` attributes are supported by default in ``*23`` mode, and as an; extension in ``*17`` and earlier modes. GCC extensions not implemented yet; ----------------------------------. clang tries to be compatible with gcc as much as possible, but some gcc; extensions are not implemented yet:. - clang does not support decimal floating point types (``_Decimal32`` and; friends) yet.; - clang does not support nested functions; this is a complex feature; which is infrequently used, so it is unlikely to be implemented; anytime soon. In C++11 it can be emulated by assigning lambda; functions to local variables, e.g:. .. code-block:: cpp. auto const local_function = [&](int parameter) {; // Do something; };; ...; local_function(1);. - clang only supports global register variables when the register specified; is non-allocatable (e.g. the stack pointer). Support for general global; register variables is unlikely to be implemented soon because it requires; additional LLVM backend support.; - clang does not support static initialization of flexible array; members. This appears to be a rarely used extension, but could be; implemented pending user demand.; - clang does not support; ``__builtin_va_arg_pack``/``__builtin_va_arg_pack_len``. This is; used rarely, but in some potentially interesting places, like the; glibc headers, so it may be implemented pending user demand. Note; that because clang pretends to be like GCC 4.2, and this extension; was introduced in 4.3, the glibc headers will not try to use this; extension with clang at the moment.; - clang does n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:133746,variab,variables,133746,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"``, ``mbtowc``, ``pread``, ``qsort``,; ``qsort_r``, ``rawmemchr``, ``read``, ``recv``, ``recvfrom``, ``rindex``,; ``strcasestr``, ``strchr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:72871,config,configuration,72871,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['configuration']
Modifiability,"``, spaces will be inserted after ``(`` and before ``)``.; This option is **deprecated**. The previous behavior is preserved by using; ``SpacesInParens`` with ``Custom`` and by setting all; ``SpacesInParensOptions`` to ``true`` except for ``InCStyleCasts`` and; ``InEmptyParentheses``. .. _SpacesInSquareBrackets:. **SpacesInSquareBrackets** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; Statement",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129147,config,configuration,129147,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11043,config,configuration,11043,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['config'],['configuration']
Modifiability,"``. #### Adding a Branch with a Fixed Length Array. At first, we create a tree and create branches for a subset of variables; in the C structure` Gctrak_t`. Then we add several types of branches.; The first branch reads seven floating-point values beginning at the; address of `'gstep.vect'`. You do not need to specify `&gstep.vect`,; because in C and C++ the array variable holds the address of the first; element. ``` {.cpp}; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; ```. #### Adding a Branch with a Variable Length Array. The next two branches are dependent on each other. The first holds the; length of the variable length array and the second holds the variable; length array. The `lmec` branch reads `nmec` number of integers; beginning at the address `gstep.lmec`. ``` {.cpp}; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; ```. The variable `nmec` is a random number and is reset for each entry. ``` {.cpp}; gstep.nmec = (Int_t)(5*gRandom->Rndm());; ```. #### Filling the Tree. In this emulation of Geant3, we generate and transport particles in a; magnetic field and store the particle parameters at each tracking step; in a ROOT tree. ### Analysis. In this analysis, we do not read the entire entry we only read one; branch. First, we set the address for the branch to the file `dstep`,; and then we use the `TBranch::GetEntry` method. Then we fill a histogram; with the `dstep` branch entries, draw it and fit it with a Gaussian. In; addition, we draw the particle's path using the three values in the; vector. Here we use the **`TTree::Draw`** method. It automatically creates; a histogram and plots the 3 expressions (see Trees in Analysis). ![](pictures/030000FF.png). ``` {.cpp}; void tree2r() {. // read the Tree generated by tree2w and fill one histogram; // we are only interested by the destep branch. // note that we use ""new"" to create the TFile an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:48727,variab,variable,48727,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations. The ``-basic-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^. The ``-basic-aa`` pass is an aggressive local analysis that *knows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:24660,variab,variables,24660,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['variab'],['variables']
Modifiability,"``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed as before. .. code-block:: yaml. # Example of usage:; AlignTrailingComments:; Kind: Always; OverEmptyLines: 2. Nested configuration flags:. Alignment options. * ``TrailingCommentsAlignmentKinds Kind``; Specifies the way to align trailing comments. Possible values:. * ``TCAS_Leave`` (in configuration: ``Leave``); Leave trailing comments as they are. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Always`` (in configuration: ``Always``); Align trailing comments. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Never`` (in configuration: ``Never``); Don't align trailing comments but other formatter applies. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``unsigned OverEmptyLines`` How many empty lines to apply alignment.; When both ``MaxEmptyLinesToKeep`` and ``OverEmptyLines`` are set to 2,; it formats like below. .. code-block:: c++. int a; // all these. int ab; // comments are. int abcdef; // aligned. When ``MaxEmptyLinesToKeep`` is set to 2 and ``OverEmptyLines`` is set; to 1, it formats like below. .. code-block:: c++. int a; // these are. int ab; // aligned. int abcdef; // but this isn't. .. _AllowAllAr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:23363,config,configuration,23363,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"``DebugLoc`` object in the machine instruction. Fixed variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^. There are several ways of specifying variable locations. The simplest is; describing a variable that is permanently located on the stack. In the stack; or fixedStack attribute of the machine function, the variable, scope, and; any qualifying location modifier are provided:. .. code-block:: text. - { id: 0, name: offset.addr, offset: -24, size: 8, alignment: 8, stack-id: default,; 4 debug-info-variable: '!1', debug-info-expression: '!DIExpression()',; debug-info-location: '!2' }. Where:. - ``debug-info-variable`` identifies a DILocalVariable metadata node,. - ``debug-info-expression`` adds qualifiers to the variable location,. - ``debug-info-location`` identifies a DILocation metadata node. These metadata attributes correspond to the operands of a ``llvm.dbg.declare``; IR intrinsic, see the :ref:`source level debugging<format_common_intrinsics>`; documentation. Varying variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Variables that are not always on the stack or change location are specified; with the ``DBG_VALUE`` meta machine instruction. It is synonymous with the; ``llvm.dbg.value`` IR intrinsic, and is written:. .. code-block:: text. DBG_VALUE $rax, $noreg, !123, !DIExpression(), debug-location !456. The operands to which respectively:. 1. Identifies a machine location such as a register, immediate, or frame index,. 2. Is either $noreg, or immediate value zero if an extra level of indirection is to be added to the first operand,. 3. Identifies a ``DILocalVariable`` metadata node,. 4. Specifies an expression qualifying the variable location, either inline or as a metadata node reference,. While the source location identifies the ``DILocation`` for the scope of the; variable. The second operand (``IsIndirect``) is deprecated and to be deleted.; All additional qualifiers for the variable location should be made through the; expression metadata. .. _instruction-referenc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:25422,variab,variable,25422,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability,"``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) return;; else if (b); return;; else; return;. if (c) return;; else {; return;; }. * ``SIS_AllIfsAndElse`` (in configuration: ``AllIfsAndElse``); Always put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AllowShortLambdasOnASingleLine>`; Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a; single line. Possible values:. * ``SLS_None`` (in configuration: ``None``); Never merge lambd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:30279,config,configuration,30279,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) return;; else if (b); return;; else; return;. if (c) return;; else {; return;; }. * ``SIS_AllIfsAndElse`` (in configuration: ``AllIfsAndElse``); Always put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AllowShortLambdasOnASingleLine>`; Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a; single line. Possible values:. * ``SLS_None`` (in configuration: ``None``); Never merge lambdas into a single line. * ``SLS_Empty`` (in configuration: ``Empty``); Only merge empty lambdas. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) {; return a;; };. * ``SLS_Inline`` (in configuration: ``Inline``); Merge lambda into a single line if the lambda is argument of a function. .. code-block:: c++. auto lambda = [](int x, int y) {; return x < y;; };; sort(a.begin(), a.end(), [](int x, int y) { return x < y; });. * ``SLS_All`` (in configuration: ``All``); Merge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :ver",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:31272,config,configuration,31272,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"```. on your Linux box. The prompt should appear shortly:. ``` {.cpp}; root [0]; ```. and let's dive in with the steps shown here:. ``` {.cpp}; root [0] 1+1; (int) 2; root [1] 2*(4+2)/12.; (double) 1.000000; root [2] sqrt(3.); (double) 1.732051; root [3] 1 > 2; (bool) false; root [4] TMath::Pi(); (double) 3.141593; root [5] TMath::Erf(.2); (double) 0.222703; ```. Not bad. You can see that ROOT offers you the possibility not only to; type in `C++` statements, but also advanced mathematical functions,; which live in the `TMath` namespace. Now let's do something more elaborated. A numerical example with the; well known geometrical series:. ``` {.cpp}; root [6] double x=.5; (double) 0.500000; root [7] int N=30; (int) 30; root [8] double geom_series=0; (double) 0.000000; root [9] for (int i=0;i<N;++i)geom_series+=TMath::Power(x,i); root [10] cout << TMath::Abs(geom_series - (1-TMath::Power(x,N-1))/(1-x)) <<endl;; 1.86265e-09; ```. Here we made a step forward. We even declared variables and used a *for*; control structure. Note that there are some subtle differences between; Cling and the standard `C++` language. You do not need the "";"" at the end; of line in interactive mode -- try the difference e.g. using the command; at line `root [6]`. ## Learn C++ at the ROOT prompt ##; Behind the ROOT prompt there is an interpreter based on a real compiler toolkit:; LLVM. It is therefore possible to exercise many features of `C++` and the; standard library. For example in the following snippet we define a lambda; function, a vector and we sort it in different ways:; ``` {.cpp}; root [0] using doubles = std::vector<double>;; root [1] auto pVec = [](const doubles& v){for (auto&& x:v) cout << x << endl;};; root [2] doubles v{0,3,5,4,1,2};; root [3] pVec(v);; 0; 3; 5; 4; 1; 2; root [4] std::sort(v.begin(),v.end());; root [5] pVec(v);; 0; 1; 2; 3; 4; 5; root [6] std::sort(v.begin(),v.end(),[](double a, double b){return a>b;});; root [7] pVec(v);; 5; 4; 3; 2; 1; 0; ```; Or, if you prefer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:1635,variab,variables,1635,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['variab'],['variables']
Modifiability,"``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. W",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:3722,refactor,refactoring,3722,interpreter/llvm-project/clang/docs/ClangTools.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst,1,['refactor'],['refactoring']
Modifiability,"``name`` should; be incremented. It should be a value between 0 and ``num-counters``. Semantics:; """""""""""""""""""". This intrinsic represents an increment of a profiling counter. It will; cause the ``-instrprof`` pass to generate the appropriate data; structures and the code to increment the appropriate value, in a; format that can be written out by a compiler runtime and consumed via; the ``llvm-profdata`` tool. '``llvm.instrprof.increment.step``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.increment.step(ptr <name>, i64 <hash>,; i32 <num-counters>,; i32 <index>, i64 <step>). Overview:; """""""""""""""""". The '``llvm.instrprof.increment.step``' intrinsic is an extension to; the '``llvm.instrprof.increment``' intrinsic with an additional fifth; argument to specify the step of the increment. Arguments:; """"""""""""""""""""; The first four arguments are the same as '``llvm.instrprof.increment``'; intrinsic. The last argument specifies the value of the increment of the counter variable. Semantics:; """"""""""""""""""""; See description of '``llvm.instrprof.increment``' intrinsic. '``llvm.instrprof.timestamp``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.timestamp(i8* <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.timestamp``' intrinsic is used to implement temporal; profiling. Arguments:; """"""""""""""""""""; The arguments are the same as '``llvm.instrprof.increment``'. The ``index`` is; expected to always be zero. Semantics:; """"""""""""""""""""; Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores a; timestamp representing when this function was executed for the first time. '``llvm.instrprof.cover``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.cover(ptr <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.cover`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:528869,variab,variable,528869,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"`array``, to ""as-good-as-builtin""; ``numpy.ndarray``.; A vector is more like the latter two in that it can contain only one type,; but more like the former two in that it can contain objects.; In practice, it can interplay well with all these containers, but e.g.; efficiency and performance can differ significantly. A vector can be instantiated from any sequence, including generators, and; vectors of objects can be recursively constructed.; If the template type is to be inferred from the argument to the constructor,; the first element needs to be accessible, which precludes generators. .. code-block:: python. >>> from cppyy.gbl.std import vector, pair; >>> v = vector[int](range(10)) # from generator; >>> len(v); 10; >>> v = vector([x for x in range(10)]) # type inferred; >>> type(v); <class cppyy.gbl.std.vector<int> at 0x12d226f00>; >>> len(v); 10; >>> vp = vector[pair[int, int]](((1, 2), (3, 4))); >>> len(vp); 2; >>> vp[1][0]; 3; >>>. To extend a vector in-place with another sequence object, use ``+=``, just as; for Python's ``list``:. .. code-block:: python. >>> v += range(10, 20); >>> len(v); 20; >>>. Indexing and slicing of a vector follows the normal Python slicing rules;; printing a vector prints all its elements:. .. code-block:: python. >>> v[1]; 1; >>> v[-1]; 19; >>> v[-4:]; <cppyy.gbl.std.vector<int> object at 0x7f9051057650>; >>> print(v[-4:]); { 6, 7, 8, 9 }; >>>. The usual iteration operations work on vector, but the C++ rules still apply,; so a vector that is being iterated over can *not* be modified in the loop; body.; (On the plus side, this makes it much faster to iterate over a vector than,; say, a numpy ndarray.). .. code-block:: python. >>> for i in v[2:5]:; ... print(i); ...; 2; 3; 4; >>> 2 in v; True; >>> sum(v); 190; >>>. When a function takes a non-l-value (const-ref, move, or by-value) vector as; a parameter, another sequence can be used and cppyy will automatically; generate a temporary.; Typically, this will be faster than coding up such a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst:3296,extend,extend,3296,bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,1,['extend'],['extend']
Modifiability,"`def`` and ``defm`` are defined; as usual, and they are also collected in a global list of the given name; (:token:`TokIdentifier`). The specified type must be ``list<``\ *class*\ ``>``, where *class* is some; record class. The ``defset`` statement establishes a scope for its; statements. It is an error to define a record in the scope of the; ``defset`` that is not of type *class*. The ``defset`` statement can be nested. The inner ``defset`` adds the; records to its own set, and all those records are also added to the outer; set. Anonymous records created inside initialization expressions using the; ``ClassID<...>`` syntax are not collected in the set. ``defvar`` --- define a variable; --------------------------------. A ``defvar`` statement defines a global variable. Its value can be used; throughout the statements that follow the definition. .. productionlist::; Defvar: ""defvar"" `TokIdentifier` ""="" `Value` "";"". The identifier on the left of the ``=`` is defined to be a global variable; whose value is given by the value expression on the right of the ``=``. The; type of the variable is automatically inferred. Once a variable has been defined, it cannot be set to another value. Variables defined in a top-level ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1);. Variables can also be defined with ``defvar`` in a record body. See; `Defvar in a Record Body`_ for more details. ``foreach`` --- iterate over a sequence of statements; -----------------------------------------------------. The ``foreach`` statement iterates over a series of statements, varying a; variable over a sequence of values. .. productionlist::; Foreach: ""foreach"" `ForeachIterator` ""in"" ""{"" `Statement`* ""}""; :| ""foreach"" `ForeachIterator` ""in"" `Statement`; ForeachIterator: `TokIdentifier` ""="" (""{"" `RangeList` ""}"" | `RangePiece` | `Value`). The body of t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:45032,variab,variable,45032,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability,"`diagAppertainsToDecl``, which checks if the attribute has been used on the; right kind of declaration and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4559,plugin,plugin,4559,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,1,['plugin'],['plugin']
Modifiability,"`distinct`` keyword. For example:. .. code-block:: text. !0 = distinct !{!""test\00"", i32 10}. ``distinct`` nodes are useful when nodes shouldn't be merged based on their; content. They can also occur when transformations cause uniquing collisions; when metadata operands change. A :ref:`named metadata <namedmetadatastructure>` is a collection of; metadata nodes, which can be looked up in the module symbol table. For; example:. .. code-block:: llvm. !foo = !{!4, !3}. Metadata can be used as function arguments. Here the ``llvm.dbg.value``; intrinsic is using three metadata arguments:. .. code-block:: llvm. call void @llvm.dbg.value(metadata !24, metadata !25, metadata !26). Metadata can be attached to an instruction. Here metadata ``!21`` is attached; to the ``add`` instruction using the ``!dbg`` identifier:. .. code-block:: llvm. %indvar.next = add i64 %indvar, 1, !dbg !21. Instructions may not have multiple metadata attachments with the same; identifier. Metadata can also be attached to a function or a global variable. Here metadata; ``!22`` is attached to the ``f1`` and ``f2`` functions, and the globals ``g1``; and ``g2`` using the ``!dbg`` identifier:. .. code-block:: llvm. declare !dbg !22 void @f1(); define void @f2() !dbg !22 {; ret void; }. @g1 = global i32 0, !dbg !22; @g2 = external global i32, !dbg !22. Unlike instructions, global objects (functions and global variables) may have; multiple metadata attachments with the same identifier. A transformation is required to drop any metadata attachment that it; does not know or know it can't preserve. Currently there is an; exception for metadata attachment to globals for ``!func_sanitize``,; ``!type``, ``!absolute_symbol`` and ``!associated`` which can't be; unconditionally dropped unless the global is itself deleted. Metadata attached to a module using named metadata may not be dropped, with; the exception of debug metadata (named metadata with the name ``!llvm.dbg.*``). More information about specific metadata n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:244697,variab,variable,244697,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"`enhance_coeff` and transforms it back. Processed data are written into; the dest spectrum. Function parameters:. - **`source`**: pointer to the vector of the source spectrum, its length should be equal to `size`; - **`dest`**: pointer to the vector of the dest data, its length should be equal to `size`; - **`size`**: basic length of the source and dest spectra; - **`type`**: type of transform; - `TRANSFORM1_HAAR`; - `TRANSFORM1_WALSH`; - `TRANSFORM1_COS`; - `TRANSFORM1_SIN`; - `TRANSFORM1_FOURIER`; - `TRANSFORM1_HARTLEY`; - `TRANSFORM1_FOURIER_WALSH`; - `TRANSFORM1_FOURIER_HAAR`; - `TRANSFORM1_WALSH_HAAR`; - `TRANSFORM1_COS_WALSH`; - `TRANSFORM1_COS_HAAR`; - `TRANSFORM1_SIN_WALSH`; - `TRANSFORM1_SIN_HAAR`; - **`degree`**: applied only for mixed transforms; - **`xmin`**: low limit of filtered region; - **`xmax`**: high limit of filtered region; - **`enhance_coeff`**: value by which the filtered region is multiplied. An example of enhancement of the coefficients from region 380-800 by the; constant 2 in the Cosine transform domain is given in the Figure 6.6. The; determination of the region is a matter of analysis in the appropriate; transform domain. We assumed that low frequency components are placed in; the low coefficients. As it can be observed, the enhancement changes the; peak-to-background ratio. ![Enhancement of the coefficients from region 380-800 by the constant 2 in the Cosine transform domain](figures/image206.png). ## 2-DIMENSIONAL SPECTRA ##. Similarly to 1-dimensional data, we have implemented the; transforms also for 2-dimensional data. Besides the classic; orthogonal transforms like. - Haar; - Walsh; - Cos; - Sin; - Fourier; - Hartley; - Fourier-Haar; - Fourier-Walsh; - Walsh-Haar; - Cos-Walsh; - Cos-Haar; - Sin-Walsh; - Sin-Haar. ```{.cpp}; char *Transform2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int direction,; int degree);; ```. This function transforms the source spectrum. The calling program should; fill in the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:64835,enhance,enhancement,64835,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['enhance'],['enhancement']
Modifiability,"`list<``\ *class*\ ``>``, where *class* is some; record class. The ``defset`` statement establishes a scope for its; statements. It is an error to define a record in the scope of the; ``defset`` that is not of type *class*. The ``defset`` statement can be nested. The inner ``defset`` adds the; records to its own set, and all those records are also added to the outer; set. Anonymous records created inside initialization expressions using the; ``ClassID<...>`` syntax are not collected in the set. ``defvar`` --- define a variable; --------------------------------. A ``defvar`` statement defines a global variable. Its value can be used; throughout the statements that follow the definition. .. productionlist::; Defvar: ""defvar"" `TokIdentifier` ""="" `Value` "";"". The identifier on the left of the ``=`` is defined to be a global variable; whose value is given by the value expression on the right of the ``=``. The; type of the variable is automatically inferred. Once a variable has been defined, it cannot be set to another value. Variables defined in a top-level ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1);. Variables can also be defined with ``defvar`` in a record body. See; `Defvar in a Record Body`_ for more details. ``foreach`` --- iterate over a sequence of statements; -----------------------------------------------------. The ``foreach`` statement iterates over a series of statements, varying a; variable over a sequence of values. .. productionlist::; Foreach: ""foreach"" `ForeachIterator` ""in"" ""{"" `Statement`* ""}""; :| ""foreach"" `ForeachIterator` ""in"" `Statement`; ForeachIterator: `TokIdentifier` ""="" (""{"" `RangeList` ""}"" | `RangePiece` | `Value`). The body of the ``foreach`` is a series of statements in braces or a; single statement with no braces. The statements are re-evaluated once for; each value in the range list, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:45174,variab,variable,45174,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability,"`local.conf`. Since PoD is; > usually system-wide installed, its location is normally; > system-wide set in either the `local.conf` file by the system; > administrator. `$VafConf_RemotePodLocation`; : Full path to the PoD installation on the VAF master node. *Note: this variable should be set in the configuration files for; the local environment despite it refers to a software present on the; remote nodes.*. `$VafConf_PodRms` *(optional)*; : Name of the Resource Management System used for submitting PoD jobs.; Run `pod-submit -l` to see the possible values. If not set, defaults to `condor`. `$VafConf_PodQueue` *(optional)*; : Queue name where to submit PoD jobs. If no queue has been given, the default one configured on your RMS; will be used. ### Remote environment configuration. All the PoD commands sent to the VAF master will live in the environment; loaded via using the following scripts. Similarly to the local environment, configuration is split in different files; to allow for a system-wide configuration, which has precedence over; user's configuration in the home directory. If a script cannot be found,; it will be silently skipped. - `<output_of_payload>`. - `common.before`. - `remote.before`. - `remote.conf`. - `common.after`. - `remote.after`. For an explanation on how to pass extra data to the workers safely; through the payload, see below. ### Payload: sending local files to the remote nodes. In many cases it is necessary to send some local data to the remote; workers: it is very common, for instance, to distribute a local Grid; authentication proxy on the remote workers to let them authenticate to; access a data storage. The `payload` file must be an executable generating some output that; will be prepended to the remote environment preparation. Differently; than the other environment scripts, it is not executed: instead, it is; first run, then *the output it produces will be executed*. Let's see a practical example to better understand how it works. We n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:4595,config,configuration,4595,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,3,['config'],['configuration']
Modifiability,"`opt` *string-literal*. The *string-literal* specifies the name of the library or framework against which the program should be linked. For example, specifying ""clangBasic"" would instruct the linker to link with ``-lclangBasic`` for a Unix-style linker. A *link-declaration* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46513,config,config-macro-list,46513,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['config'],['config-macro-list']
Modifiability,"`settings.DragGraphs` flag (#224); 19. Correctly display extra data from TGraphQQ; 20. Implement ""3d"" draw options for TMultiGraph; 21. Support ""A"" hist option (do not draw axis) in lego/surf plots; 22. Support drawing of TGeo and TAxis3D objects inside TPad; 23. Implement proper drawing of TEllipse; 24. Add proper support of ""Symbols"" and ""Wingdings"" fonts; 25. Make ""col"" default draw option for TH2 in JSROOT gui. ## Changes in 6.3.4; 1. Fix bug in handling superimposing items via URL syntax; 2. Enable geometry clipping in node.js; 3. Upgrade node.js packages; 4. Let draw TGeo object inside TCanvas; 5. Let superimpose TPolyLine3D and TPolyMarker3D with TGeo drawing; 6. Fix plain #sum and #int parsing in TLatex; 7. Fix ticks position for axes with labels. ## Changes in 6.3.3; 1. Fix TEfficiency drawing; 2. Provide TPadPainter.divide method; 3. Fix browsing remote file via THttpServer; 4. Fix lego draw update while zooming. ## Changes in 6.3.2; 1. Fix bug in TH1 drawing when minimum or/and maximum was configured for histogram. ## Changes in 6.3.1; 1. Fix bug with col draw option in TH2/RH2. ## Changes in 6.3.0; 1. Fully rewrite TLatex parsing, use svg elements instead of plain text/tspan; 2. Make TLatex reliably working in node.js, does not depend from availability of canvas component; 3. Many optimizations to produce smaller (and faster) SVG output; 4. Provide x3dscNNN and y3dscNNN draw option for histogram to resize x/y axis in 3D plots; 5. Provide ""Find label"" command in TAxis context menu to zoom into bin region; 6. Allows to use JSROOT.define() in external scripts; 7. Provide JSROOT.Painter.setDefaultDrawOpt() to change class default draw option; 8. Provide example of custom entries in histogram context menu; 9. Provide alternative external location for zstd-codec, let use zstd even when not found locally; 10. Let skip HEAD requests when reading files, adding ""^"" symbol to file name (#223); 11. Show long histogram names in stats box when possible; 12. Fix logic h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:20890,config,configured,20890,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configured']
Modifiability,"`¶ <PenaltyBreakTemplateDeclaration>`; The penalty for breaking after template declaration. .. _PenaltyExcessCharacter:. **PenaltyExcessCharacter** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyExcessCharacter>`; The penalty for each character outside of the column limit. .. _PenaltyIndentedWhitespace:. **PenaltyIndentedWhitespace** (``Unsigned``) :versionbadge:`clang-format 12` :ref:`¶ <PenaltyIndentedWhitespace>`; Penalty for each character of whitespace indentation; (counted relative to leading non-whitespace column). .. _PenaltyReturnTypeOnItsOwnLine:. **PenaltyReturnTypeOnItsOwnLine** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <PenaltyReturnTypeOnItsOwnLine>`; Penalty for putting the return type of a function onto its own line. .. _PointerAlignment:. **PointerAlignment** (``PointerAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <PointerAlignment>`; Pointer and reference alignment style. Possible values:. * ``PAS_Left`` (in configuration: ``Left``); Align pointer to the left. .. code-block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:96142,config,configuration,96142,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"`¶ <PointerAlignment>`; Pointer and reference alignment style. Possible values:. * ``PAS_Left`` (in configuration: ``Left``); Align pointer to the left. .. code-block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qualifiers to be right-aligned. .. code-block:: c++. int const a;; int const *a;. * ``QAS_Custom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:96999,config,configuration,96999,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"a !DIExpression()), !dbg !2; !1 = !DILocalVariable(name: ""i"", ...) ; int i; !2 = !DILocation(...); ...; %buffer = alloca [256 x i8], align 8; ; The address of i is buffer+64.; call void @llvm.dbg.declare(metadata [256 x i8]* %buffer, metadata !3,; metadata !DIExpression(DW_OP_plus, 64)), !dbg !4; !3 = !DILocalVariable(name: ""i"", ...) ; int i; !4 = !DILocation(...). A frontend should generate exactly one call to ``llvm.dbg.declare`` at the point; of declaration of a source variable. Optimization passes that fully promote the; variable from memory to SSA values will replace this call with possibly multiple; calls to `llvm.dbg.value`. Passes that delete stores are effectively partial; promotion, and they will insert a mix of calls to ``llvm.dbg.value`` to track; the source variable value when it is available. After optimization, there may be; multiple calls to ``llvm.dbg.declare`` describing the program points where the; variables lives in memory. All calls for the same concrete source variable must; agree on the memory location. ``llvm.dbg.value``; ^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.value(metadata, metadata, metadata). This intrinsic provides information when a user source variable is set to a new; value. The first argument is the new value (wrapped as metadata). The second; argument is a `local variable <LangRef.html#dilocalvariable>`_ containing a; description of the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a source variable; directly, not its address. Note that the value operand of this intrinsic may; be indirect (i.e, a pointer to the source variable), provided that interpreting; the complex expression derives the direct value. ``llvm.dbg.assign``; ^^^^^^^^^^^^^^^^^^^; .. toctree::; :hidden:. AssignmentTracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:10107,variab,variable,10107,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has; a name and a type separated by a ""/"" and it is separated from the next; leaf by a ""`:`"". ``` {.cpp}; <Variable>/<type>:<Variable>/<type>; ```. The example on the next line has two leafs: a floating-point number; called temp and an integer named `ntrack`. ``` {.cpp}; ""temp/F:ntrack/I:""; ```. The type can be omitted and if no type is given, the same type as the; previous variable is assumed. This leaf list has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:20247,variab,variables,20247,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"a corresponding ""Linkdef.h"" file, selecting only ``MyClass``::. #ifdef __ROOTCLING__; #pragma link off all classes;; #pragma link off all functions;; #pragma link off all globals;; #pragma link off all typedef;. #pragma link C++ class MyClass;. #endif. For more pragmas, see the `rootcling manual`_.; E.g., a commonly useful pragma is one that selects all C++ entities that are; declared in a specific header file::. #pragma link C++ defined_in ""MyClass.h"";. Next, use ``rootcling`` to generate the dictionary (here:; ``MyClass_rflx.cxx``) and module files::. $ rootcling -f MyClass_rflx.cxx MyClass.h Linkdef.h. Alternatively, define a ""myclass_selection.xml"" file::. <lcgdict>; <class name=""MyClass"" />; </lcgdict>. serving the same purpose as the Linkdef.h file above (in fact, ``rootcling``; accepts a ""selection.xml"" file in lieu of a ""Linkdef.h"").; For more tags, see the `selection file`_ documentation.; Commonly used are ``namespace``, ``function``, ``enum``, or ``variable``; instead of the ``class`` tag, and ``pattern`` instead of ``name`` with; wildcarding in the value string. Next, use ``genreflex`` to generate the dictionary (here:; ``MyClass_rflx.cxx``) and module files::. $ genreflex MyClass.h --selection=myclass_selection.xml -o MyClass_rflx.cxx. From here, compile and link the generated dictionary file with the project; and/or system specific options and libraries into a shared library, using; ``cling-config`` for the relevant cppyy compiler/linker flags.; (For work on MS Windows, this `helper script`_ may be useful.); To continue the example, assuming Linux::. $ g++ `cling-config --cppflags` -fPIC -O2 -shared MyClass_rflx.cxx -o MyClassDict.so. Instead of loading the header text into ``cling``, you can now load the; dictionary:. .. code-block:: python. >>> import cppyy; >>> cppyy.load_reflection_info('MyClassDict'); >>> cppyy.gbl.MyClass(42); <cppyy.gbl.MyClass object at 0x7ffb9f230950>; >>> print(_.get_int()); 42; >>>. and use the selected C++ entities as if th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:6411,variab,variable,6411,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['variab'],['variable']
Modifiability,"a double; store double %x, double* %x1; %x2 = load double, double* %x1; %cmptmp = fcmp ult double %x2, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp one double %booltmp, 0.000000e+00; br i1 %ifcond, label %then, label %else. then: ; preds = %entry; br label %ifcont. else: ; preds = %entry; %x3 = load double, double* %x1; %subtmp = fsub double %x3, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %x4 = load double, double* %x1; %subtmp5 = fsub double %x4, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; br label %ifcont. ifcont: ; preds = %else, %then; %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]; ret double %iftmp; }. Here there is only one variable (x, the input argument) but you can; still see the extremely simple-minded code generation strategy we are; using. In the entry block, an alloca is created, and the initial input; value is stored into it. Each reference to the variable does a reload; from the stack. Also, note that we didn't modify the if/then/else; expression, so it still inserts a PHI node. While we could make an; alloca for it, it is actually easier to create a PHI node for it, so we; still just make the PHI. Here is the code after the mem2reg pass runs:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %cmptmp = fcmp ult double %x, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp one double %booltmp, 0.000000e+00; br i1 %ifcond, label %then, label %else. then:; br label %ifcont. else:; %subtmp = fsub double %x, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %subtmp5 = fsub double %x, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; br label %ifcont. ifcont: ; preds = %else, %then; %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]; ret double %iftmp; }. This is a trivial case for mem2reg, since there are no redefinitions of; the vari",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:18108,variab,variable,18108,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"a flow algorithm computes a failure state, we also can't; perform the refactoring. ```c++; Customer* kGlobalCustomer;. void GetCustomer(Customer* c) {; // Overwritten: {}; c->account_id = ...; // Overwritten: {c->account_id}; if (...) {; print(c->name); // Unsafe read; } else {; kGlobalCustomer = c; // Pointer escape; }; // Unsafe read, Pointer escape; }; ```. ## Example: finding dead stores. Let's say we want to find redundant stores, because they indicate potential; bugs. ```c++; x = GetX();; x = GetY();; ```. The first store to `x` is never read, probably there is a bug. The implementation of dead store analysis is very similar to output parameter; analysis: we need to track stores and loads, and find stores that were never; read. [Liveness analysis](https://en.wikipedia.org/wiki/Live_variable_analysis) is a; generalization of this idea, which is often used to answer many related; questions, for example:. * finding dead stores,; * finding uninitialized variables,; * finding a good point to deallocate memory,; * finding out if it would be safe to move an object. ## Example: definitive initialization. Definitive initialization proves that variables are known to be initialized when; read. If we find a variable which is read when not initialized then we generate; a warning. ```c++; void Init() {; int x; // x is uninitialized; if (cond()) {; x = 10; // x is initialized; } else {; x = 20; // x is initialized; }; print(x); // x is initialized; }; ```. ```c++; void Uninit() {; int x; // x is uninitialized; if (cond()) {; x = 10; // x is initialized; }; print(x); // x is maybe uninitialized, x is being read, report a bug.; }; ```. For this purpose we can use lattice in a form of a mapping from variable; declarations to initialization states; each initialization state is represented; by the following lattice:. ![Lattice for definitive initialization analysis](DataFlowAnalysisIntroImages/DefinitiveInitializationLattice.svg). A lattice element could also capture the source lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:20232,variab,variables,20232,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['variab'],['variables']
Modifiability,"a package; # @author Pere Mato, CERN; ############################################################################. set (EXTRA_DICT_OPTS); if (runtime_cxxmodules AND WIN32); set (EXTRA_DICT_OPTS NO_CXXMODULE); endif(). ROOT_STANDARD_LIBRARY_PACKAGE(TMVAGui; HEADERS; TMVA/BDT.h; TMVA/BDTControlPlots.h; TMVA/BDT_Reg.h; TMVA/BoostControlPlots.h; TMVA/CorrGui.h; TMVA/CorrGuiMultiClass.h; TMVA/MovieMaker.h; TMVA/PlotFoams.h; TMVA/TMVAGui.h; TMVA/TMVAMultiClassGui.h; TMVA/TMVARegGui.h; TMVA/annconvergencetest.h; TMVA/compareanapp.h; TMVA/correlations.h; TMVA/correlationsMultiClass.h; TMVA/correlationscatters.h; TMVA/correlationscattersMultiClass.h; TMVA/deviations.h; TMVA/efficiencies.h; TMVA/efficienciesMulticlass.h; TMVA/likelihoodrefs.h; TMVA/mvaeffs.h; TMVA/mvas.h; TMVA/mvasMulticlass.h; TMVA/mvaweights.h; TMVA/network.h; TMVA/paracoor.h; TMVA/probas.h; TMVA/regression_averagedevs.h; TMVA/rulevis.h; TMVA/rulevisCorr.h; TMVA/rulevisHists.h; TMVA/tmvaglob.h; TMVA/training_history.h; TMVA/variables.h; TMVA/variablesMultiClass.h; SOURCES; src/BDTControlPlots.cxx; src/BoostControlPlots.cxx; src/CorrGui.cxx; src/CorrGuiMultiClass.cxx; src/MovieMaker.cxx; src/PlotFoams.cxx; src/TMVAGui.cxx; src/TMVAMultiClassGui.cxx; src/TMVARegGui.cxx; src/annconvergencetest.cxx; src/compareanapp.cxx; src/correlations.cxx; src/correlationsMultiClass.cxx; src/correlationscatters.cxx; src/correlationscattersMultiClass.cxx; src/deviations.cxx; src/efficiencies.cxx; src/efficienciesMulticlass.cxx; src/likelihoodrefs.cxx; src/mvas.cxx; src/mvasMulticlass.cxx; src/mvaweights.cxx; src/network.cxx; src/paracoor.cxx; src/regression_averagedevs.cxx; src/rulevis.cxx; src/rulevisCorr.cxx; src/rulevisHists.cxx; src/tmvaglob.cxx; src/training_history.cxx; src/variables.cxx; src/variablesMultiClass.cxx; src/BDT.cxx; src/BDT_Reg.cxx; src/probas.cxx; src/mvaeffs.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; RIO; Hist; Tree; TreeViewer; MLP; Minuit; XMLIO; TMVA; Gui; HistPainter; Core; ${EXTRA_D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/CMakeLists.txt:1315,variab,variables,1315,tmva/tmvagui/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/CMakeLists.txt,1,['variab'],['variables']
Modifiability,"a problem. `Minuit`, when it; prints out error values, also gives some indication of how reliable it; thinks they are. For example, those marked `CURRENT GUESS ERROR` are; only working values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:61886,parameteriz,parameterized,61886,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['parameteriz'],['parameterized']
Modifiability,"a reference to the execution session and the; layer below (as all layers do) plus an *IR optimization function* that it will; apply to each Module that is added via addModule:. .. code-block:: c++. class KaleidoscopeJIT {; private:; ExecutionSession ES;; RTDyldObjectLinkingLayer ObjectLayer;; IRCompileLayer CompileLayer;; IRTransformLayer TransformLayer;. DataLayout DL;; MangleAndInterner Mangle;; ThreadSafeContext Ctx;. public:. KaleidoscopeJIT(JITTargetMachineBuilder JTMB, DataLayout DL); : ObjectLayer(ES,; []() { return std::make_unique<SectionMemoryManager>(); }),; CompileLayer(ES, ObjectLayer, ConcurrentIRCompiler(std::move(JTMB))),; TransformLayer(ES, CompileLayer, optimizeModule),; DL(std::move(DL)), Mangle(ES, this->DL),; Ctx(std::make_unique<LLVMContext>()) {; ES.getMainJITDylib().addGenerator(; cantFail(DynamicLibrarySearchGenerator::GetForCurrentProcess(DL.getGlobalPrefix())));; }. Our extended KaleidoscopeJIT class starts out the same as it did in Chapter 1,; but after the CompileLayer we introduce a new member, TransformLayer, which sits; on top of our CompileLayer. We initialize our OptimizeLayer with a reference to; the ExecutionSession and output layer (standard practice for layers), along with; a *transform function*. For our transform function we supply our classes; optimizeModule static method. .. code-block:: c++. // ...; return cantFail(OptimizeLayer.addModule(std::move(M),; std::move(Resolver)));; // ... Next we need to update our addModule method to replace the call to; ``CompileLayer::add`` with a call to ``OptimizeLayer::add`` instead. .. code-block:: c++. static Expected<ThreadSafeModule>; optimizeModule(ThreadSafeModule M, const MaterializationResponsibility &R) {; // Create a function pass manager.; auto FPM = std::make_unique<legacy::FunctionPassManager>(M.get());. // Add some optimizations.; FPM->add(createInstructionCombiningPass());; FPM->add(createReassociatePass());; FPM->add(createGVNPass());; FPM->add(createCFGSimplificationPass()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:3661,extend,extended,3661,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['extend'],['extended']
Modifiability,a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; The function definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Always break after the return type of function definitions. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int f();; int; f() {; return 1;; }. * ``RTBS_TopLevelDefinitions`` (in configuration: ``TopLevelDefinitions``); Always break after the return type of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; },MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:33130,config,configuration,33130,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Configure each individual space before parentheses in; ``SpaceBeforeParensOptions``. .. _SpaceBeforeParensOptions:. **SpaceBeforeParensOptions** (``SpaceBeforeParensCustom``) :versionbadge:`clang-format 14` :ref:`¶ <SpaceBeforeParensOptions>`; Control of individual space before parentheses. If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify; how each individual space before parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. Nested configuration flags:. Precise control over the spacing before parentheses. .. code-block:: c++. # Should be declared this w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:117686,config,configuration,117686,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"a substitution before any substitution that might; refer to it. In general, substitution expansion behaves as follows:. - Upon arriving at each ``RUN:`` line, lit expands all substitutions in that; ``RUN:`` line using their current values from the substitution list. No; substitution expansion is performed immediately at ``DEFINE:`` and; ``REDEFINE:`` directives except ``%(line)``, ``%(line+<number>)``, and; ``%(line-<number>)``.; - When expanding substitutions in a ``RUN:`` line, lit makes only one pass; through the substitution list by default. In this case, a substitution must; have been inserted earlier in the substitution list than any substitution; appearing in its value in order for the latter to expand. (For greater; flexibility, you can enable multiple passes through the substitution list by; setting `recursiveExpansionLimit`_ in a lit configuration file.); - While lit configuration files can insert anywhere in the substitution list,; the insertion behavior of the ``DEFINE:`` and ``REDEFINE:`` directives is; specified below and is designed specifically for the use case presented in the; example above.; - Defining a substitution in terms of itself, whether directly or via other; substitutions, should be avoided. It usually produces an infinitely recursive; definition that cannot be fully expanded. It does *not* define the; substitution in terms of its previous value, even when using ``REDEFINE:``. The relationship between the ``DEFINE:`` and ``REDEFINE:`` directive is; analogous to the relationship between a variable declaration and variable; assignment in many programming languages:. - ``DEFINE: %{name} = value``. This directive assigns the specified value to a new substitution whose; pattern is ``%{name}``, or it reports an error if there is already a; substitution whose pattern contains ``%{name}`` because that could produce; confusing expansions (e.g., a lit configuration file might define a; substitution with the pattern ``%{name}\[0\]``). The new substit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:31800,config,configuration,31800,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configuration']
Modifiability,"a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a source does. # Source function; # size_t fread(void *ptr, size_t size, size_t nmemb, FILE * stream); #; # Result example:; # FILE* f = fopen(""file.txt"");; # char buf[1024];; # size_t read = fread(buf, sizeof(buf[0]), sizeof(buf)/sizeof(buf[0]), f);; # // both read and buf are tainted; - Name: fread; DstArgs: [0, -1]. # Propagation functions; # The presence of SrcArgs key indicates conditional taint propagation,; # which is conceptually what a propagator does. # Propagation function; # char *dirname(char *path); #; # Result example:; # char* path = read_path();; # char* dir = dirname(path);; # // di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:2242,variab,variables,2242,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['variab'],['variables']
Modifiability,"a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10868,config,configure,10868,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,2,['config'],"['configuration', 'configure']"
Modifiability,"a user-defined behaviour (e.g. failure to compile on clang) and a; nonzero value when otherwise. Leaving the user the freedom to determine what is; and isn’t interesting to the tool, and thus, streamlining the process of; reducing a test-case. If the test accepts any arguments (excluding the input ll/bc file), they are; given via the following flag:; `--test_args=<test_arguments>`; If unspecified, the test is run as given. It’s worth noting that the input file; would be passed as a parameter to the test, similar how `-compile-custom`; currently operates. ### Implementation; The tool would behave similar to CReduce’s functionality in that it would have a; list of passes that try to minimize the given test-case. We should be able to; modularize the tool’s behavior, as well as making it easier to maintain and; expand. The first version of this redesign would try to:. * Discard functions, instructions and metadata that don’t influence the; interesting-ness test; * Remove unused parameters from functions; * Eliminate unvisited conditional paths; * Rename variables to more regular ones (such as “a”, “b”, “c”, etc.). Once these passes are implemented, more meaningful reductions (such as type; reduction) would be added to the tool, to even further reduce IR. ## Background on historical bugpoint issues. ### Root Cause Analysis; Presently, bugpoint takes a long time to find the source problem in a given IR; file, mainly due to the fact that it tries to debug the input by running; various strategies to classify the bug, which in turn run multiple optimizer; and compilation passes over the input, taking up a lot of time. Furthermore,; when the IR crashes, it tries to reduce it by performing some sub-optimal; passes (e.g. a lot of unreachable blocks), and sometimes even fails to minimize; at all. ### ""Quirky"" Interface; Bugpoint’s current interface overwhelms and confuses the user, the help screen; alone ends up confusing rather providing guidance. And, not only are there; numero",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugpointRedesign.md:2780,variab,variables,2780,interpreter/llvm-project/llvm/docs/BugpointRedesign.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugpointRedesign.md,1,['variab'],['variables']
Modifiability,"a); declare i64 @llvm.read_volatile_register.i64(metadata); declare void @llvm.write_register.i32(metadata, i32 @value); declare void @llvm.write_register.i64(metadata, i64 @value); !0 = !{!""sp\00""}. Overview:; """""""""""""""""". The '``llvm.read_register``', '``llvm.read_volatile_register``', and; '``llvm.write_register``' intrinsics provide access to the named register.; The register must be valid on the architecture being compiled to. The type; needs to be compatible with the register being read. Semantics:; """""""""""""""""""". The '``llvm.read_register``' and '``llvm.read_volatile_register``' intrinsics; return the current value of the register, where possible. The; '``llvm.write_register``' intrinsic sets the current value of the register,; where possible. A call to '``llvm.read_volatile_register``' is assumed to have side-effects; and possibly return a different value each time (e.g. for a timer register). This is useful to implement named register global variables that need; to always be mapped to a specific register, as is common practice on; bare-metal programs including OS kernels. The compiler doesn't check for register availability or use of the used; register in surrounding code, including inline assembly. Because of that,; allocatable registers are not supported. Warning: So far it only works with the stack pointer on selected; architectures (ARM, AArch64, PowerPC and x86_64). Significant amount of; work is needed to support other registers and even more so, allocatable; registers. .. _int_stacksave:. '``llvm.stacksave``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stacksave.p0(); declare ptr addrspace(5) @llvm.stacksave.p5(). Overview:; """""""""""""""""". The '``llvm.stacksave``' intrinsic is used to remember the current state; of the function stack, for use with; :ref:`llvm.stackrestore <int_stackrestore>`. This is useful for; implementing language features like scoped automatic variable sized; arrays in C99. Semantics:; """""""""""""""""""". Thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:518904,variab,variables,518904,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"a,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will not match loops whose; variables are initialized to ``'\0'``, ``0.0``, ``NULL``, or any form of; zero besides the integer 0. The last step is giving the matcher a name and binding the ``ForStmt``; as we will want to do something with it:. .. code-block:: c++. StatementMatcher LoopMatcher =; forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))).bind(""forLoop"");. Once you have defined your matchers, you will need to add a little more; scaffolding in order to run them. Matchers are paired with a; ``MatchCallback`` and regist",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7932,variab,variable,7932,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['variab'],['variable']
Modifiability,"a-dependency ordering: atomics and memory model; N2664; Clang 3.2 (4). Propagating exceptions; N2179; Clang 2.9. Allow atomics use in signal handlers; N2547; Clang 3.1. Thread-local storage; N2659; Clang 3.3 (5). Dynamic initialization and destruction with concurrency; N2660; Clang 2.9. C99 Features in C++11. __func__ predefined identifier; N2340; Clang 2.9. C99 preprocessor; N1653; Clang 2.9. long long; N1811; Clang 2.9. Extended integral types; N1988; N/A (6). (1): The [[carries_dependency]] attribute; has no effect.; (2): No compiler changes are required for an implementation; such as Clang that does not provide garbage collection.; (3): All compare-exchange operations are emitted as; strong compare-exchanges.; (4): memory_order_consume is lowered to; memory_order_acquire.; (5): thread_local support; requires a C++ runtime library providing __cxa_thread_atexit, such; as libc++abi 3.6 or later,; or libsupc++ 4.8 or later.; (6): No compiler changes are required for an implementation; such as Clang that does not provide any extended integer types.; __int128 is not treated as an extended integer type,; because changing intmax_t would be an ABI-incompatible; change. C++98 implementation status; Clang implements all of the ISO C++ 1998 standard; (including the defects addressed in the ISO C++ 2003 standard); except for export (which was removed in C++11). Defect reports; Clang generally aims to implement resolutions to Defect Reports (bug fixes; against prior standards) retroactively, in all prior standard versions where; the fix is meaningful. Significant Defect Report changes to language features; after the publication of the relevant standard are marked (DR) in the above; table.; Clang also has a test suite for conformance to resolutions for issues on the; C++ core issues list,; most of which are considered Defect Reports.; Implementation status for C++ core issues based on; that test suite is tracked on a separate page.; Technical specifications and standing docume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:18759,extend,extended,18759,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,1,['extend'],['extended']
Modifiability,"a.org/wiki/MIT_License); - Free from copy-left licenses, like GPL, because you should innovate without; restrictions.; - Forked from [Mongoose](https://code.google.com/p/mongoose/) in 2013, before; it changed the licence from MIT to commercial + GPL. A lot of enhancements; have been added since that time, see; [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md).; - Works on Windows, Mac, Linux, UNIX, iPhone, Android, Buildroot, and many; other platforms.; - Scripting and database support (CGI, SQLite database, Lua Server Pages,; Server side Lua scripts, Server side JavaScript).; This provides a ready to go, powerful web development platform in a one; single-click executable with **no dependencies**.0; - Support for CGI, SSI, HTTP digest (MD5) authorization, WebSocket,; WebDAV.; - HTTPS (SSL/TLS) support using [OpenSSL](https://www.openssl.org/).; - Optional support for authentication using client side X.509 certificates.; - Resumed download, URL rewrite, file blacklist, IP-based ACL.; - May run as Windows service.; - Download speed limit based on client subnet or URI pattern.; - Simple and clean embedding API.; - The source is in single file to make things easy.; - Embedding examples included.; - HTTP client capable of sending arbitrary HTTP/HTTPS requests.; - Websocket client functionality available (WS/WSS). ### Optionally included software. [![Lua](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/lua-logo.jpg ""Lua Logo"")](http://lua.org). [![Sqlite3](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/sqlite3-logo.jpg ""Sqlite3 Logo"")](http://sqlite.org). [![LuaFileSystem](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/luafilesystem-logo.jpg ""LuaFileSystem Logo"")](http://keplerproject.github.io/luafilesystem/). [![LuaSQLite3](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/luasqlite-logo.jpg ""LuaSQLite3 Logo"")](http://lua.sqlite.org/index.cgi/index). [",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:6347,rewrite,rewrite,6347,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['rewrite'],['rewrite']
Modifiability,"a; compilation. This document will provide a basic walkthrough of how to write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by declaring a ``ParsedAttrInfo`` and registering; it using ``ParsedAttrInfoRegister::Add<>``:. .. code-block:: c++. c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:1085,plugin,plugin,1085,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,1,['plugin'],['plugin']
Modifiability,"aInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);. // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. // Store the value into the alloca.; Builder->CreateStore(StartVal, Alloca);; ... // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.; Value *CurVar = Builder->CreateLoad(Alloca->getAllocatedType(), Alloca,; VarName.c_str());; Value *NextVar = Builder->CreateFAdd(CurVar, StepVal, ""nextvar"");; Builder->CreateStore(NextVar, Alloca);; ... This code is virtually identical to the code `before we allowed mutable; variables <LangImpl05.html#code-generation-for-the-for-loop>`_. The big difference is that we; no longer have to construct a PHI node, and we use load/store to access; the variable as needed. To support mutable argument variables, we need to also make allocas for; them. The code for this is also pretty simple:. .. code-block:: c++. Function *FunctionAST::codegen() {; ...; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. if (Value *RetVal = Body->codegen()) {; ... For each argument, we make an alloca, store the input value to the; function into the alloca, and register the alloca as the memory location; for the argument. This method gets invoked by ``FunctionAST::codegen()``; right after it sets up the entry block for the function. The final missing piece is adding the mem2reg pass, which allows us to; get good codegen once ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:15531,variab,variables,15531,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed as before. .. code-block:: yaml. # Example of usage:; AlignTrailingComments:; Kind: Always; OverEmptyLines: 2. Nested configuration flags:. Alignment options. * ``TrailingCommentsAlignmentKind",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:22234,config,configuration,22234,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"aaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);; }. .. _BinPackParameters:. **BinPackParameters** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BinPackParameters>`; If ``false``, a function declaration's or function definition's; parameters will either all be on the same line or will have one line each. .. code-block:: c++. true:; void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. false:; void f(int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. .. _BitFieldColonSpacing:. **BitFieldColonSpacing** (``BitFieldColonSpacingStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BitFieldColonSpacing>`; The BitFieldColonSpacingStyle to use for bitfields. Possible values:. * ``BFCS_Both`` (in configuration: ``Both``); Add one space on each side of the ``:``. .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:37823,config,configuration,37823,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);; }. false:; void f() {; f(aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);; }. .. _BinPackParameters:. **BinPackParameters** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BinPackParameters>`; If ``false``, a function declaration's or function definition's; parameters will either all be on the same line or will have one line each. .. code-block:: c++. true:; void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. false:; void f(int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. .. _BitFieldColonSpacing:. **BitFieldColonSpacing** (``BitFieldColonSpacingStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BitFieldColonSpacing>`; The BitFieldColonSpacingStyle to use for bitfields. Possible values:. * ``BFCS_Both`` (in configuration: ``Both``); Add one space on each side of the ``:``. .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: fals",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:37697,config,configuration,37697,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"able will; cause dyld to load the specified variant at runtime. .. option:: --dump-debug-map. Dump the *executable*'s debug-map (the list of the object files containing the; debug information) in YAML format and exit. No DWARF link will take place. .. option:: -D <path>. Specify a directory that contain dSYM files to search for.; This is used for mergeable libraries, so dsymutil knows where to look; for dSYM files with debug information about symbols present in those; libraries. .. option:: --fat64. Use a 64-bit header when emitting universal binaries. .. option:: --flat, -f. Produce a flat dSYM file. A ``.dwarf`` extension will be appended to the; executable name unless the output file is specified using the ``-o`` option. .. option:: --gen-reproducer. Generate a reproducer consisting of the input object files. Alias for; --reproducer=GenerateOnExit. .. option:: --help, -h. Print this help output. .. option:: --keep-function-for-static. Make a static variable keep the enclosing function even if it would have been; omitted otherwise. .. option:: --minimize, -z. When used when creating a dSYM file, this option will suppress the emission of; the .debug_inlines, .debug_pubnames, and .debug_pubtypes sections since; dsymutil currently has better equivalents: .apple_names and .apple_types. When; used in conjunction with ``--update`` option, this option will cause redundant; accelerator tables to be removed. .. option:: --no-odr. Do not use ODR (One Definition Rule) for uniquing C++ types. .. option:: --no-output. Do the link in memory, but do not emit the result file. .. option:: --no-swiftmodule-timestamp. Don't check the timestamp for swiftmodule files. .. option:: --num-threads <threads>, -j <threads>. Specifies the maximum number (``n``) of simultaneous threads to use when; linking multiple architectures. .. option:: --object-prefix-map <prefix=remapped>. Remap object file paths (but no source paths) before processing. Use; this for Clang objects where the module cach",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst:2459,variab,variable,2459,interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst,1,['variab'],['variable']
Modifiability,"able(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64); !20 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !21 = !DIExpression(DW_OP_LLVM_implicit_pointer,; DW_OP_LLVM_implicit_pointer)). DWARF specifies three kinds of simple location descriptions: Register, memory,; and implicit location descriptions. Note that a location description is; defined over certain ranges of a program, i.e the location of a variable may; change over the course of the program. Register and memory location; descriptions describe the *concrete location* of a source variable (in the; sense that a debugger might modify its value), whereas *implicit locations*; describe merely the actual *value* of a source variable which might not exist; in registers or in memory (see ``DW_OP_stack_value``). A ``llvm.dbg.declare`` intrinsic describes an indirect value (the address) of a; source variable. The first operand of the intrinsic must be an address of some; kind. A DIExpression attached to the intrinsic refines this address to produce a; concrete location for the source variable. A ``llvm.dbg.value`` intrinsic describes the direct value of a source variable.; The first operand of the intrinsic may be a direct or indirect value. A; DIExpression attached to the intrinsic refines the first operand to produce a; direct value. For example, if the first operand is an indirect value, it may be; necessary to insert ``DW_OP_deref`` into the DIExpression in order to produce a; valid debug intrinsic. .. note::. A DIExpression is interpreted in the same way regardless of which kind of; debug intrinsic it's attached to. .. code-block:: text. !0 = !DIExpression(DW_OP_deref); !1 = !DIExpression(DW_OP_plus_uconst, 3); !1 = !DIExpression(DW_OP_constu, 3, DW_OP_plus); !2 = !DIExpression(DW_OP_bit_piece, 3, 7); !3 = !DIExpression(DW_OP_deref, DW_OP_cons",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:267944,variab,variable,267944,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"able; location fidelity are:. 1. Instruction Selection; 2. Register allocation; 3. Block layout. each of which are discussed below. In addition, instruction scheduling can; significantly change the ordering of the program, and occurs in a number of; different passes. Some variable locations are not transformed during CodeGen. Stack locations; specified by ``llvm.dbg.declare`` are valid and unchanging for the entire; duration of the function, and are recorded in a simple MachineFunction table.; Location changes in the prologue and epilogue of a function are also ignored:; frame setup and destruction may take several instructions, require a; disproportionate amount of debugging information in the output binary to; describe, and should be stepped over by debuggers anyway. Variable locations in Instruction Selection and MIR; ---------------------------------------------------. Instruction selection creates a MIR function from an IR function, and just as; it transforms ``intermediate`` instructions into machine instructions, so must; ``intermediate`` variable locations become machine variable locations.; Within IR, variable locations are always identified by a Value, but in MIR; there can be different types of variable locations. In addition, some IR; locations become unavailable, for example if the operation of multiple IR; instructions are combined into one machine instruction (such as; multiply-and-accumulate) then intermediate Values are lost. To track variable; locations through instruction selection, they are first separated into; locations that do not depend on code generation (constants, stack locations,; allocated virtual registers) and those that do. For those that do, debug; metadata is attached to SDNodes in SelectionDAGs. After instruction selection; has occurred and a MIR function is created, if the SDNode associated with debug; metadata is allocated a virtual register, that virtual register is used as the; variable location. If the SDNode is folded into a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:25768,variab,variable,25768,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['variab'],['variable']
Modifiability,"ables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Objective-C; instance methods. - ``objc_property``: Can be used to apply attributes to ``@property``; declarations. - ``block``: Can be used to apply attributes to block declarations. This does; not include variables/fields of block pointer type. The use of ``unless`` in match rules is currently restricted to a strict set of; sub-rules that are used by the supported attributes. That means that even though; ``variable(unless(is_parameter))`` is a valid match rule,; ``variable(unless(is_thread_local))`` is not. Supported Attributes; --------------------. Not all attributes can be used with the ``#pragma clang attribute`` directive.; Notably, statement attributes like ``[[fallthrough]]`` or type attributes; like ``address_space`` aren't supported by this directive. You can determine; whether or not an attribute is supported by the pragma by referring to the; :doc:`individual documentation for that attribute <AttributeReference>`. The attributes are applied to all matching declarations individually, even when; the attribute is semantically incorrect. The attributes that aren't applied to; any declaration are not verified semantically. Specifying section names for global objects (#pragma clang section",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:185360,variab,variables,185360,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variables']
Modifiability,"ables that are rarely used, along with a brief; explanation and LLVM-related notes. For full documentation, consult the CMake; manual, or execute ``cmake --help-variable VARIABLE_NAME``. **CMAKE_CXX_STANDARD**:STRING; Sets the C++ standard to conform to when building LLVM. Possible values are; 17 and 20. LLVM Requires C++ 17 or higher. This defaults to 17. **CMAKE_INSTALL_BINDIR**:PATH; The path to install executables, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""bin"". **CMAKE_INSTALL_INCLUDEDIR**:PATH; The path to install header files, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""include"". **CMAKE_INSTALL_DOCDIR**:PATH; The path to install documentation, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""share/doc"". **CMAKE_INSTALL_MANDIR**:PATH; The path to install manpage files, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""share/man"". .. _LLVM-related variables:. LLVM-related variables; -----------------------. These variables provide fine control over the build of LLVM and; enabled sub-projects. Nearly all of these variable names begin with; ``LLVM_``. **BUILD_SHARED_LIBS**:BOOL; Flag indicating if each LLVM component (e.g. Support) is built as a shared; library (ON) or as a static library (OFF). Its default value is OFF. On; Windows, shared libraries may be used when building with MinGW, including; mingw-w64, but not when building with the Microsoft toolchain. .. note:: BUILD_SHARED_LIBS is only recommended for use by LLVM developers.; If you want to build LLVM as a shared library, you should use the; ``LLVM_BUILD_LLVM_DYLIB`` option. **LLVM_ABI_BREAKING_CHECKS**:STRING; Used to decide if LLVM should be built with ABI breaking checks or; not. Allowed values are `WITH_ASSERTS` (default), `FORCE_ON` and; `FORCE_OFF`. `WITH_ASSERTS` turns on ABI breaking checks in an; assertion enabled build. `FORCE_ON` (`FORCE_OFF`) turns them on; (off) irrespective of whether normal (`NDEBUG`-based) assertions are; enabled or not. A version of LLVM b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:11359,variab,variables,11359,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"ables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.exe`). A template for a leak suppression file can be found in `$ROOTSYS/etc/lsan-root.supp`. ## Create your own sanitised executable; ROOT exports a library target called `ROOT::ROOTStaticSanitizerConfig` that can be used to create sanitised executables with ROOT's default; address sanitizer config. Linking against this target will add the above setup functions and also add the address sanitizer flags that; ROOT was built with. It should be sufficient to; - Link all executables against this target; - And have `-fsanitize=address` in the `CXXFLAGS`. ## Use sanitised ROOT libraries from a non-sanitised executable (e.g. `python`); When ROOT libraries are built with sanitizers, the address sanitizer runtime needs to be loaded at startup. However, when calling into ROOT; functions from python, that won't happen, since python is not sanitised. Therefore, the address sanitizer runtime has to be preloaded with; `LD_PRELOAD=<pathToRuntime>:libROOTSanitizerConfig.<so|dylib> pythonX ROOTScript.py`. Preloading the shared sanitizer config as above is optional, but recommended, because it adds leak sanitizer suppressions. On Mac, preloading is theoretically possible, but code signing and many other barriers might make it difficult.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:3036,config,config,3036,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,1,['config'],['config']
Modifiability,"about CodeView and PDBs is ongoing. * RTTI: :good:`Complete`. Generation of RTTI data structures has been; finished, along with support for the ``/GR`` flag. * C++ Exceptions: :good:`Mostly complete`. Support for; C++ exceptions (``try`` / ``catch`` / ``throw``) have been implemented for; x86 and x64. Our implementation has been well tested but we still get the; odd bug report now and again.; C++ exception specifications are ignored, but this is `consistent with Visual; C++`_. .. _consistent with Visual C++:; https://msdn.microsoft.com/en-us/library/wfa0edys.aspx. * Asynchronous Exceptions (SEH): :partial:`Partial`.; Structured exceptions (``__try`` / ``__except`` / ``__finally``) mostly; work on x86 and x64.; LLVM does not model asynchronous exceptions, so it is currently impossible to; catch an asynchronous exception generated in the same frame as the catching; ``__try``. * Thread-safe initialization of local statics: :good:`Complete`. MSVC 2015; added support for thread-safe initialization of such variables by taking an; ABI break.; We are ABI compatible with both the MSVC 2013 and 2015 ABI for static local; variables. * Lambdas: :good:`Mostly complete`. Clang is compatible with Microsoft's; implementation of lambdas except for providing overloads for conversion to; function pointer for different calling conventions. However, Microsoft's; extension is non-conforming. Template instantiation and name lookup; ======================================. MSVC allows many invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:4464,variab,variables,4464,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,1,['variab'],['variables']
Modifiability,"above. The scope information attached with each instruction provides a straightforward; way to find instructions covered by a scope. Object lifetime in optimized code; =================================. In the example above, every variable assignment uniquely corresponds to a; memory store to the variable's position on the stack. However in heavily; optimized code LLVM promotes most variables into SSA values, which can; eventually be placed in physical registers or memory locations. To track SSA; values through compilation, when objects are promoted to SSA values an; ``llvm.dbg.value`` intrinsic is created for each assignment, recording the; variable's new location. Compared with the ``llvm.dbg.declare`` intrinsic:. * A dbg.value terminates the effect of any preceding dbg.values for (any; overlapping fragments of) the specified variable.; * The dbg.value's position in the IR defines where in the instruction stream; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the program. For any; execution of the optimized program, the set of variable values presented to the; developer by the debugger should not show a state that would never have existed; in the execution of the unoptimized program, given the same input. Doing so; risks misleading the developer by reporting a state that does not exist,; damaging their understanding of the optimized program and undermining their; trust in the debugger. Sometimes perfectly preserving variable locations is not possible, often when a; redundant calculation is optimized out. In such cases, a ``llvm.dbg.value``; with operand ``poison`` should be used, to terminate earlier variable locations; and let the debugger present ``optimized out`` to the developer.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:18664,variab,variable,18664,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"accepts executable lines.; Example::. >>> cppyy.cppexec(r""""""std::string hello = ""Hello, World!"";""""""); True; >>> cppyy.cppexec(""std::cout << hello << std::endl;""); Hello, World!; True; >>> . * ``include``: load declarations into the interpreter.; This function accepts C++ declarations from a file, typically a header.; Files are located through include paths given to the Cling.; Example::. >>> cppyy.include(""vector"") # equivalent to ""#include <vector>""; True; >>> . * ``c_include``: load declarations into the interpreter.; This function accepts C++ declarations from a file, typically a header.; Name mangling is an important difference between C and C++ code.; The use of ``c_include`` instead of ``include`` prevents mangling. * ``load_library``: load compiled C++ into the interpreter.; This function takes the name of a shared library and loads it into current; process, exposing all external symbols to Cling.; Libraries are located through load paths given to Cling, either through the; ""-L"" compiler flag or the dynamic search path environment variable (system; dependent).; Any method that brings symbols into the process (including normal linking,; e.g. when embedding Python in a C++ application) is suitable to expose; symbols.; An alternative for ``load_library`` is for example ``ctypes.CDLL``, but; that function does not respect dynamic load paths on all platforms. If a compilation error occurs during JITing of C++ code in any of the above; helpers, a Python ``SyntaxError`` exception is raised.; If a compilation warning occurs, a Python warning is issued. `Configuring Cling`; -------------------. It is often convenient to add additional search paths for Cling to find; headers and libraries when loading a module (Python does not have standard; locations to place headers and libraries, but their locations can usually; be inferred from the location of the module, i.e. it's ``__file__``; attribute).; cppyy provides the following two helpers:. * ``add_include_path``: add add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/toplevel.rst:2890,variab,variable,2890,bindings/pyroot/cppyy/cppyy/doc/source/toplevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/toplevel.rst,1,['variab'],['variable']
Modifiability,"accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Specify any additional linker options after; ``CMAKE_EXE_LINKER_FLAGS:STRING=``. Note the configure may fail if; linker plugin options are instead specified directly in the previous step. The ``BOOTSTRAP_LLVM_EN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:8045,variab,variables,8045,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,2,"['config', 'variab']","['configuring', 'variables']"
Modifiability,"ace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and union declarations. Example matches X, Z, U, and S; class X;; template<class T> class Z {};; struct S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:15702,variab,variable,15702,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"ace. Given; class vector {};; namespace foo {; class vector {};; namespace {; class vector {}; // #1; }; }; namespace {; class vector {}; // #2; namespace foo {; class vector{}; // #3; }; }; cxxRecordDecl(hasName(""vector""), isInAnonymousNamespace()) will match; #1, #2 and #3. Matcher<Decl>isInStdNamespace; Matches declarations in the namespace `std`, but not in nested namespaces. Given; class vector {};; namespace foo {; class vector {};; namespace std {; class vector {};; }; }; namespace std {; inline namespace __1 {; class vector {}; // #1; namespace experimental {; class vector {};; }; }; }; cxxRecordDecl(hasName(""vector""), isInStdNamespace()) will match only #1. Matcher<Decl>isInstantiated; Matches declarations that are template instantiations or are inside; template instantiations. Given; template<typename T> void A(T t) { T i; }; A(0);; A(0U);; functionDecl(isInstantiated()); matches 'A(int) {...};' and 'A(unsigned) {...}'. Matcher<Decl>isPrivate; Matches private C++ declarations and C++ base specifers that specify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<Decl>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<Decl>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<DesignatedInitExpr>designatorCountIsunsigned N; Matc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:84604,inherit,inheritance,84604,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['inherit'],['inheritance']
Modifiability,"acesInParensOptions`` to ``true`` except for ``InCStyleCasts`` and; ``InEmptyParentheses``. .. _SpacesInSquareBrackets:. **SpacesInSquareBrackets** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsign",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129341,config,configuration,129341,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ach of these names with the; appropriate pathname on your local system. All these paths are absolute:. ``SRC_ROOT``. This is the top level directory of the LLVM source tree. ``OBJ_ROOT``. This is the top level directory of the LLVM object tree (i.e. the tree where; object files and compiled programs will be placed. It can be the same as; SRC_ROOT). Unpacking the LLVM Archives; ---------------------------. If you have the LLVM distribution, you will need to unpack it before you can; begin to compile it. LLVM is distributed as a number of different; subprojects. Each one has its own download which is a TAR archive that is; compressed with the gzip program. The files are as follows, with *x.y* marking the version number:. ``llvm-x.y.tar.gz``. Source release for the LLVM libraries and tools. ``cfe-x.y.tar.gz``. Source release for the Clang frontend. .. _checkout:. Checkout LLVM from Git; ----------------------. You can also checkout the source code for LLVM from Git. .. note::. Passing ``--config core.autocrlf=false`` should not be required in; the future after we adjust the .gitattribute settings correctly, but; is required for Windows users at the time of this writing. Simply run:. .. code-block:: console. % git clone https://github.com/llvm/llvm-project.git. or on Windows,. .. code-block:: console. % git clone --config core.autocrlf=false https://github.com/llvm/llvm-project.git. This will create an '``llvm-project``' directory in the current directory and; fully populate it with all of the source code, test directories, and local; copies of documentation files for LLVM and all the related subprojects. Note; that unlike the tarballs, which contain each subproject in a separate file, the; git repository contains all of the projects together. If you want to get a specific release (as opposed to the most recent revision),; you can check out a tag after cloning the repository. E.g., `git checkout; llvmorg-6.0.1` inside the ``llvm-project`` directory created by the above; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:21888,config,config,21888,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['config']
Modifiability,"ache to the recent changes; In the XrdProofd plug-in. Improve synchronization between parent and child during; fork; Optimize loops over directory entries; Improve error and notification messages. Improved handling of Ctrl-C; this follows from a fix in; TMonitor and an improved handling of non-finished query state in the; workers (results are not send to master if the query was aborted) . Fixes. TFileMerger. Fix a problem preventing correct transmission of all; non-mergeable objects (fixes bug #52886); Remove the argument isdir from the function; MergeRecursive; Do not remove the first file in the list when returning; from MergeRecursive (fixes bug #54591); Fix a major leak when merging files with collections; written using kSingleKey option.  The merger was reading each; key in memory and deleted the object at the end, but the container is; not owner by default, so all objects inside leaked. PROOF-Lite. Fix a couple of memory leaks showing up when running; repeated queries; Fix a problem in TProofServ::CopyFromCache affecting; the case where the sandbox dir has a '.' and the macro name has no '.',; e.g. compiled selectors in PROOF-Lite. TProofOutputFile. Fix a problem with the determination of the fDir member; affecting mostly PROOF-Lite; Fix a serious issue whose net effect was to delete the; outputfile just after having open it. XrdProofd plugin. Make sure that the limit on the number of old; sessions is applied whenever a new session is started and not only when; the daemon is started.; Fix the behaviour of the xpd.allowedusers directive: if; at least one of these directives is present, users in the password file; are not allowed by default but must be explicitly appear in one; xpd.allowedusers directive  ; Fix a source for memory leak in; XrdProofdProtocol::SendMsg; Optimize the usage of strings in a few places. DataSet manager. Correctly classify as TTree all TTree derived classes; (e.g. TNtuple's); Fix a problem in saving the end-point URL for local; files; I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:7145,sandbox,sandbox,7145,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,1,['sandbox'],['sandbox']
Modifiability,"achine instruction or; otherwise transformed into a non-register, the variable location becomes; unavailable. Locations that are unavailable are treated as if they have been optimized out:; in IR the location would be assigned ``undef`` by a debug intrinsic, and in MIR; the equivalent location is used. After MIR locations are assigned to each variable, machine pseudo-instructions; corresponding to each ``llvm.dbg.value`` intrinsic are inserted. There are two; forms of this type of instruction. The first form, ``DBG_VALUE``, appears thus:. .. code-block:: text. DBG_VALUE %1, $noreg, !123, !DIExpression(). And has the following operands:; * The first operand can record the variable location as a register,; a frame index, an immediate, or the base address register if the original; debug intrinsic referred to memory. ``$noreg`` indicates the variable; location is undefined, equivalent to an ``undef`` dbg.value operand.; * The type of the second operand indicates whether the variable location is; directly referred to by the DBG_VALUE, or whether it is indirect. The; ``$noreg`` register signifies the former, an immediate operand (0) the; latter.; * Operand 3 is the Variable field of the original debug intrinsic.; * Operand 4 is the Expression field of the original debug intrinsic. The second form, ``DBG_VALUE_LIST``, appears thus:. .. code-block:: text. DBG_VALUE_LIST !123, !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_plus), %1, %2. And has the following operands:; * The first operand is the Variable field of the original debug intrinsic.; * The second operand is the Expression field of the original debug intrinsic.; * Any number of operands, from the 3rd onwards, record a sequence of variable; location operands, which may take any of the same values as the first; operand of the ``DBG_VALUE`` instruction above. These variable location; operands are inserted into the final DWARF Expression in positions indicated; by the DW_OP_LLVM_arg operator in the `DIExpres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:27692,variab,variable,27692,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"ack-end uses the following address space mapping:. ============= ======================; Address Space Memory Space; ============= ======================; 0 Generic; 1 Global; 2 Internal Use; 3 Shared; 4 Constant; 5 Local; ============= ======================. Every global variable and pointer type is assigned to one of these address; spaces, with 0 being the default address space. Intrinsics are provided which; can be used to convert pointers between the generic and non-generic address; spaces. As an example, the following IR will define an array ``@g`` that resides in; global device memory. .. code-block:: llvm. @g = internal addrspace(1) global [4 x i32] [ i32 0, i32 1, i32 2, i32 3 ]. LLVM IR functions can read and write to this array, and host-side code can; copy data to it by name with the CUDA Driver API. Note that since address space 0 is the generic space, it is illegal to have; global variables in address space 0. Address space 0 is the default address; space in LLVM, so the ``addrspace(N)`` annotation is *required* for global; variables. Triples; -------. The NVPTX target uses the module triple to select between 32/64-bit code; generation and the driver-compiler interface to use. The triple architecture; can be one of ``nvptx`` (32-bit PTX) or ``nvptx64`` (64-bit PTX). The; operating system should be one of ``cuda`` or ``nvcl``, which determines the; interface used by the generated code to communicate with the driver. Most; users will want to use ``cuda`` as the operating system, which makes the; generated PTX compatible with the CUDA Driver API. Example: 32-bit PTX for CUDA Driver API: ``nvptx-nvidia-cuda``. Example: 64-bit PTX for CUDA Driver API: ``nvptx64-nvidia-cuda``. .. _nvptx_intrinsics:. NVPTX Intrinsics; ================. Address Space Conversion; ------------------------. '``llvm.nvvm.ptr.*.to.gen``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". These are overloaded intrinsics. You can use these on any pointer types. .. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:3093,variab,variables,3093,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['variab'],['variables']
Modifiability,"ack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7004,variab,variables,7004,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['variab'],['variables']
Modifiability,"acket is; not NULL and this value; is not 0 then the value; specifies the kernarg; memory size in bytes. It; is recommended to provide; a value as it may be used; by CP to optimize making; the kernarg memory; visible to the kernel; code. 127:96 4 bytes Reserved, must be 0.; 191:128 8 bytes KERNEL_CODE_ENTRY_BYTE_OFFSET Byte offset (possibly; negative) from base; address of kernel; descriptor to kernel's; entry point instruction; which must be 256 byte; aligned.; 351:272 20 Reserved, must be 0.; bytes; 383:352 4 bytes COMPUTE_PGM_RSRC3 GFX6-GFX9; Reserved, must be 0.; GFX90A, GFX940; Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC3``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc3-gfx90a-table`.; GFX10-GFX11; Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC3``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc3-gfx10-gfx11-table`.; GFX12; Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC3``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc3-gfx12-table`.; 415:384 4 bytes COMPUTE_PGM_RSRC1 Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC1``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc1-gfx6-gfx12-table`.; 447:416 4 bytes COMPUTE_PGM_RSRC2 Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC2``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc2-gfx6-gfx12-table`.; 458:448 7 bits *See separate bits below.* Enable the setup of the; SGPR user data registers; (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). The total number of SGPR; user data registers; requested must not exceed; 16 and match value in; ``compute_pgm_rsrc2.user_sgpr.user_sgpr_count``.; Any requests beyond 16; will be ignored.; >448 1 bit ENABLE_SGPR_PRIVATE_SEGMENT If the *Target Properties*; _BUFFER column of; :ref:`amdgpu-processor-table`; specifies *A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:160694,config,configuration,160694,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['config'],['configuration']
Modifiability,"act algebra). ```c++; void ExampleOfTopWithALoop() {; int x = 0; // x is {0}; while (condition()) {; x += 1; // x is ⊤; }; print(x); // x is ⊤; }; ```. The statement ""at this program point, `x`'s possible values are `⊤`"" is; understood as ""at this program point `x` can have any value because we have too; much information, or the information is conflicting"". Note that we can get more than 3 possible values even without a loop:. ```c++; void ExampleOfTopWithoutLoops(int n) {; int x = 0; // x is {0}; switch(n) {; case 0: x = 1; break; // x is {1}; case 1: x = 9; break; // x is {9}; case 2: x = 7; break; // x is {7}; default: x = 3; break; // x is {3}; }; // x is ⊤; }; ```. ### Uninitialized variables and ""bottom"" values. When `x` is declared but not initialized, it has no possible values. We; represent this fact symbolically as `⊥` (pronounced ""bottom""). ```c++; void ExampleOfBottom() {; int x; // x is ⊥; x = 42; // x is {42}; print(x);; }; ```. Note that using values read from uninitialized variables is undefined behaviour; in C++. Generally, compilers and static analysis tools can assume undefined; behavior does not happen. We must model uninitialized variables only when we are; implementing a checker that specifically is trying to find uninitialized reads.; In this example we show how to model uninitialized variables only to demonstrate; the concept of ""bottom"", and how it applies to possible value analysis. We; describe an analysis that finds uninitialized reads in a section below. ### A practical lattice that tracks sets of concrete values. Taking into account all corner cases covered above, we can put together a; lattice that we can use in practice to track possible values of integer; variables. This lattice represents sets of integers with 1, 2, or 3 elements, as; well as top and bottom. Here is a Hasse diagram for it:. ![Hasse diagram for a lattice of integer sets](DataFlowAnalysisIntroImages/IntegerSetsFiniteLattice.svg). ### Formalization. Let's consider a sli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:6057,variab,variables,6057,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['variab'],['variables']
Modifiability,"ad of a variant of POSIX; Extended Regular Expression (where ``*`` is translated to ``.*``) by default.; Search for ``|`` to find patterns that may have different meanings now, and; replace ``a|b`` with ``{a,b}``. Changes to the Profile Runtime; ------------------------------. * Public header ``profile/instr_prof_interface.h`` is added to declare four; API functions to fine tune profile collection. Other Changes; -------------. * The ``Flags`` field of ``llvm::opt::Option`` has been split into ``Flags``; and ``Visibility`` to simplify option sharing between various drivers (such; as ``clang``, ``clang-cl``, or ``flang``) that rely on Clang's Options.td.; Overloads of ``llvm::opt::OptTable`` that use ``FlagsToInclude`` have been; deprecated. There is a script and instructions on how to resolve conflicts -; see https://reviews.llvm.org/D157150 and https://reviews.llvm.org/D157151 for; details. * On Linux, FreeBSD, and NetBSD, setting the environment variable; ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` causes tools to print stacktraces using; :doc:`Symbolizer Markup <SymbolizerMarkupFormat>`.; This works even if the tools have no embedded symbol information (i.e. are; fully stripped); :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` can; symbolize the markup afterwards using ``debuginfod``. External Open Source Projects Using LLVM 15; ===========================================. * A project... Additional Information; ======================. A wide variety of additional information is available on the `LLVM web page; <https://llvm.org/>`_, in particular in the `documentation; <https://llvm.org/docs/>`_ section. The web page also contains versions of the; API documentation which is up-to-date with the Git version of the source; code. You can access versions of these documents specific to this release by; going into the ``llvm/docs/`` directory in the LLVM tree. If you have any questions or comments about LLVM, please feel free to contact; us via the `Discourse forums <https:/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:18758,variab,variable,18758,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['variab'],['variable']
Modifiability,"adFile` can be used to automatic define the; structure of the **`TTree`** and read the data from a formatted ascii; file. ``` {.cpp}; Long64_t TTree::ReadFile(const char *filename,; const char *branchDescriptor); ```. Creates or simply read branches from the file named whose name is passed; in `'filename'`. ``` {.cpp}; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; ```. If `branchDescriptor` is set to an empty string (the default), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each process",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:67440,variab,variable,67440,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"add_custom_target(install-${name}; DEPENDS ${name}; COMMAND ""${CMAKE_COMMAND}""; -DCMAKE_INSTALL_COMPONENT=${name}; -P ""${CMAKE_BINARY_DIR}/cmake_install.cmake""); endif(); endif(); set_property(GLOBAL APPEND PROPERTY CLING_EXPORTS ${name}); else(); # Add empty ""phony"" target; add_custom_target(${name}); endif(). set_target_properties(${name} PROPERTIES FOLDER ""Cling libraries""); set_cling_windows_version_resource_properties(${name}); endmacro(add_cling_library). macro(add_cling_executable name); add_llvm_executable( ${name} ${ARGN} ); set_target_properties(${name} PROPERTIES FOLDER ""Cling executables""); set_cling_windows_version_resource_properties(${name}); endmacro(add_cling_executable). set(CMAKE_INCLUDE_CURRENT_DIR ON). include_directories(BEFORE; ${CMAKE_CURRENT_BINARY_DIR}/include; ${CMAKE_CURRENT_SOURCE_DIR}/include; ). if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY); install(DIRECTORY include/cling include/cling-c; DESTINATION include; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""config.h"" EXCLUDE; PATTERN "".svn"" EXCLUDE; ). install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/include/cling; DESTINATION include; FILES_MATCHING; PATTERN ""CMakeFiles"" EXCLUDE; PATTERN ""*.inc""; PATTERN ""*.h""; PATTERN ""*.modulemap""; ); endif(). add_definitions( -D_GNU_SOURCE -DCLING_VERSION=${CLING_VERSION}). option(CLING_INCLUDE_TESTS; ""Generate build targets for the Cling unit tests.""; ${LLVM_INCLUDE_TESTS}). if (NOT WIN32); set(cling_path_delim "":""); else(); set(cling_path_delim "";""); endif(). if( CLING_INCLUDE_TESTS ); set(cling_include_deflt ${CMAKE_INSTALL_PREFIX}/include; ${CMAKE_CURRENT_SOURCE_DIR}/include; ${CLANG_INCLUDE_DIRS}; ${LLVM_INCLUDE_DIRS}; ). # CLANG_INCLUDE_DIRS and LLVM_INCLUDE_DIRS can be a semicolon separated lists.; string(REPLACE "";"" ""${cling_path_delim}"" cling_include_deflt ""${cling_include_deflt}""); endif(). if(NOT CLING_INCLUDE_PATHS); set(CLING_INCLUDE_PATHS ""${cling_include_deflt}""); else(); set(CLING_INCLUDE_PATHS ""${CLING_INCLUDE_PATHS}${cling_path_delim",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt:15478,config,config,15478,interpreter/cling/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt,1,['config'],['config']
Modifiability,"addition, it marks function arguments (of; pointer type) ""``nocapture``"" if a call to the function does not create any; copies of the pointer value that outlive the call. This more or less means; that the pointer is only dereferenced, and not returned from the function or; stored in a global. This pass is implemented as a bottom-up traversal of the; call-graph. ``globaldce``: Dead Global Elimination; --------------------------------------. This transform is designed to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global variables that never have their address; taken. If obviously true, it marks read/write globals as constant, deletes; variables only stored to, etc. ``gvn``: Global Value Numbering; -------------------------------. This pass performs global value numbering to eliminate fully and partially; redundant instructions. It also performs redundant load elimination. .. _passes-indvars:. ``indvars``: Canonicalize Induction Variables; ---------------------------------------------. This transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:17274,variab,variables,17274,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variables']
Modifiability,"address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; Whe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98912,variab,variables,98912,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"ader::LoadEntry()`, `RNTupleView` call operator). By default, the page source uses an `RClusterPool` to asynchronously read-ahead data.; When a page of a certain cluster is required, the cluster pool reads pages of _active_ columns.; For instance, if only certain fields are used (e.g., through an imposed model), only the pages of columns connected to those fields are read.; Columns can be dynamically added (e.g. during event iteration, a new field view is created in a reader).; The cluster pool reads ahead a limited number of clusters given by the _cluster bunch size_ option (default = 1).; The read-ahead uses vector reads.; For the file backend, it additionally coalesces close read requests and uses uring reads when available. The page source can be restricted to a certain entry range.; This allows for optimizing the page lists that are being read.; Additionally, it allows for optimizing the cluster pool to not read-ahead beyond the limits. #### Late model extension; Reading an RNTuple with an extended model is transparent -- i.e., no additional interface calls are required.; Internally, columns that were created as part of late model extension will have synthesized zero-initialized column ranges for the clusters that were already written before the model was extended.; In addition, pages made up of 0x00 bytes are synthesized for deferred columns in the clusters that were already (partially) filled before the model was extended. Storage Backends; ----------------. Support for storage backends is implemented through derived classes of `RPageSink` and `RPageSource`.; The `RPage{Sink,Source}File` class provides a storage backend for RNTuple data in ROOT files, local or remote.; The `RPage{Sink,Source}Daos` class provides a storage backend for RNTuple data in the DAOS object store. Every new storage backend needs to define; 1) The RNTuple embedding: how are RNTuple data blobs stored, e.g. in keys of ROOT files, or in objects of object stores; 2) The RNTuple anchor: the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:22996,extend,extended,22996,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['extend'],['extended']
Modifiability,"after deallocation will thus trigger the crash handler, and we; can provide useful information about the source of the error. Please note that the use-after-free detection for a sampled allocation is; transient. To keep memory overhead fixed while still detecting bugs, deallocated; slots are randomly reused to guard future allocations. Usage; =====. GWP-ASan already ships by default in the; `Scudo Hardened Allocator <https://llvm.org/docs/ScudoHardenedAllocator.html>`_,; so building with ``-fsanitize=scudo`` is the quickest and easiest way to try out; GWP-ASan. Options; -------. GWP-ASan's configuration is managed by the supporting allocator. We provide a; generic configuration management library that is used by Scudo. It allows; several aspects of GWP-ASan to be configured through the following methods:. - When the GWP-ASan library is compiled, by setting; ``-DGWP_ASAN_DEFAULT_OPTIONS`` to the options string you want set by default.; If you're building GWP-ASan as part of a compiler-rt/LLVM build, add it during; cmake configure time (e.g. ``cmake ... -DGWP_ASAN_DEFAULT_OPTIONS=""...""``). If; you're building GWP-ASan outside of compiler-rt, simply ensure that you; specify ``-DGWP_ASAN_DEFAULT_OPTIONS=""...""`` when building; ``optional/options_parser.cpp``). - By defining a ``__gwp_asan_default_options`` function in one's program that; returns the options string to be parsed. Said function must have the following; prototype: ``extern ""C"" const char* __gwp_asan_default_options(void)``, with a; default visibility. This will override the compile time define;. - Depending on allocator support (Scudo has support for this mechanism): Through; an environment variable, containing the options string to be parsed. In Scudo,; this is through `SCUDO_OPTIONS=GWP_ASAN_${OPTION_NAME}=${VALUE}` (e.g.; `SCUDO_OPTIONS=GWP_ASAN_SampleRate=100`). Options defined this way will; override any definition made through ``__gwp_asan_default_options``. The options string follows a syntax similar ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:5464,config,configure,5464,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['config'],['configure']
Modifiability,"age memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be held in; collections. It is possible to nest one type of collection inside; another to any level to produce structures of arbitrary complexity. Collections do not own the objects they hold for the very good reason; that the same object could be a member of more than one collection.; Object ownership is important when it comes to deleting objects; if; nobody owns the object it could end up as wasted memory (i.e. a memory; leak) when no longer needed. If a collection is deleted, its objects are; not. The user can force a collection to delete its objects, but that is; the user's choice. ### Determining the Class of Contained Objects. Most containers may hold heterogeneous collections of objects and then; it is left to the user to cor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:1744,inherit,inherit,1744,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['inherit'],['inherit']
Modifiability,"ager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where the target headers and libraries; are. People add system-specific clues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have mult",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8066,config,configure,8066,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['config'],['configure']
Modifiability,"ager, Loop Rotate; D: GCC PCH Integration (llvm-gcc), llvm-gcc improvements; D: Optimizer improvements, Loop Index Split. N: Ana Pazos; E: apazos@codeaurora.org; D: Fixes and improvements to the AArch64 backend. N: Wesley Peck; E: peckw@wesleypeck.com; W: http://wesleypeck.com/; D: MicroBlaze backend. N: Francois Pichet; E: pichet2000@gmail.com; D: MSVC support. N: Simon Pilgrim; E: llvm-dev@redking.me.uk; D: X86 backend, Selection DAG, Scheduler Models and Cost Tables. N: Adrian Prantl; E: aprantl@apple.com; D: Debug Information. N: Vladimir Prus; W: http://vladimir_prus.blogspot.com; E: ghost@cs.msu.su; D: Made inst_iterator behave like a proper iterator, LowerConstantExprs pass. N: QIU Chaofan; E: qiucofan@cn.ibm.com; D: PowerPC Backend Developer. N: Kalle Raiskila; E: kalle.rasikila@nokia.com; D: Some bugfixes to CellSPU. N: Xerxes Ranby; E: xerxes@zafena.se; D: Cmake dependency chain and various bug fixes. N: Alex Rosenberg; E: alexr@leftfield.org; I: arosenberg; D: ARM calling conventions rewrite, hard float support. N: Chad Rosier; E: mcrosier@codeaurora.org; I: mcrosier; D: AArch64 fast instruction selection pass; D: Fixes and improvements to the ARM fast-isel pass; D: Fixes and improvements to the AArch64 backend. N: Nadav Rotem; E: nadav.rotem@me.com; D: X86 code generation improvements, Loop Vectorizer, SLP Vectorizer. N: Roman Samoilov; E: roman@codedgers.com; D: MSIL backend. N: Duncan Sands; E: baldrick@free.fr; I: baldrick; D: Ada support in llvm-gcc; D: Dragonegg plugin; D: Exception handling improvements; D: Type legalizer rewrite. N: Ruchira Sasanka; E: sasanka@uiuc.edu; D: Graph coloring register allocator for the Sparc64 backend. N: Alina Sbirlea; E: alina.sbirlea@gmail.com; D: MemorySSA, BatchAA, misc loop and new pass manager work. N: Arnold Schwaighofer; E: arnold.schwaighofer@gmail.com; D: Tail call optimization for the x86 backend. N: Shantonu Sen; E: ssen@apple.com; D: Miscellaneous bug fixes. N: Anand Shukla; E: ashukla@cs.uiuc.edu; D: The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:10905,rewrite,rewrite,10905,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,1,['rewrite'],['rewrite']
Modifiability,"ager.; After the `installation <https://chocolatey.org/install>`_ of Chocolatey,; run these commands in an admin shell to install the required tools:. .. code-block:: bat. choco install -y git cmake python3; pip3 install psutil. There is also a Windows; `Dockerfile <https://github.com/llvm/llvm-zorg/blob/main/buildbot/google/docker/windows-base-vscode2019/Dockerfile>`_; with the entire build tool chain. This can be used to test the build with a; tool chain different from your host installation or to create build servers. Next steps; ==========; 1. Read the documentation.; 2. Seriously, read the documentation.; 3. Remember that you were warned twice about reading the documentation. Test LLVM on the command line:; ------------------------------; The LLVM tests can be run by changing directory to the llvm source; directory and running:. .. code-block:: bat. c:\llvm> python ..\build\Release\bin\llvm-lit.py llvm\test. This example assumes that Python is in your PATH variable, which would be; after **Add Python to the PATH** was selected during Python installation.; If you had opened a command window prior to Python installation, you would; have to close and reopen it to get the updated PATH. A specific test or test directory can be run with:. .. code-block:: bat. c:\llvm> python ..\build\Release\bin\llvm-lit.py llvm\test\Transforms\Util. Build the LLVM Suite:; ---------------------; * The projects may still be built individually, but to build them all do; not just select all of them in batch build (as some are meant as; configuration projects), but rather select and build just the; ``ALL_BUILD`` project to build everything, or the ``INSTALL`` project,; which first builds the ``ALL_BUILD`` project, then installs the LLVM; headers, libs, and other useful things to the directory set by the; ``CMAKE_INSTALL_PREFIX`` setting when you first configured CMake.; * The Fibonacci project is a sample program that uses the JIT. Modify the; project's debugging properties to provide a n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:9167,variab,variable,9167,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['variab'],['variable']
Modifiability,"agic to override this. No source means no classes and no defs. Let's add a class. ## Classes. ```tablegen; class C {}; ```. ------------- Classes -----------------; class C {; }; ------------- Defs -----------------. Followed by a def (definition). ```tablegen; %noreset. def X: C;; ```. ------------- Classes -----------------; class C {; }; ------------- Defs -----------------; def X {	// C; }. `def` creates an instance of a class. Typically, the main loop of a TableGen backend will look for all defs that are instances of a certain class. For example if I am generating register information I would look for all defs that are instances of `RegisterInfo` in the example below. ```tablegen; class RegisterInfo {}; def X0: RegisterInfo {}; def X1: RegisterInfo {}; ```. ------------- Classes -----------------; class RegisterInfo {; }; ------------- Defs -----------------; def X0 {	// RegisterInfo; }; def X1 {	// RegisterInfo; }. ## Inheritance. Like many other languages with classes, a class in TableGen can inherit properties of another class. ```tablegen; class C {}; class D : C {}; ```. ------------- Classes -----------------; class C {; }; class D {	// C; }; ------------- Defs -----------------. Inheritance is done by putting the class you want to inherit from after `:`, before the opening `{`. You'll know that `D` inherits from `C` by the `// C` comment on the `class D {` line in the output. Not very interesting though, what are we actually inheriting? The members of the parent class. ```tablegen; class C {; int a;; }; class D : C {}; ```. ------------- Classes -----------------; class C {; int a = ?;; }; class D {	// C; int a = ?;; }; ------------- Defs -----------------. Note that `D` now has the `a` member which was defined in the class `C`. You can inherit from multiple classes. In that case the order that that happens in matches the order you write the class names after the `:`. ```tablegen; class C {; int a = 1;; }; class D {; int a = 2;; }; class E : C, D {}; ```.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:2973,inherit,inherit,2973,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['inherit'],['inherit']
Modifiability,"agio; E: andrea.dibiagio@sony.com; E: andrea.dibiagio@gmail.com; D: MCA, llvm-mca. N: Hal Finkel; E: hfinkel@anl.gov; D: The loop reroller and alias analysis. N: Nemanja Ivanovic; E: nemanja.i.ibm@gmail.com; D: PowerPC Backend. N: Dan Gohman; E: llvm@sunfishcode.online; D: WebAssembly Backend (lib/Target/WebAssembly/*). N: Renato Golin; E: rengolin@systemcall.eu; D: ARM Linux support. N: Venkatraman Govindaraju; E: venkatra@cs.wisc.edu; D: Sparc Backend (lib/Target/Sparc/*). N: Tobias Grosser; E: tobias@grosser.es; D: Polly. N: James Grosbach; E: grosbach@apple.com; D: MC layer. N: Justin Holewinski; E: jholewinski@nvidia.com; D: NVPTX Target (lib/Target/NVPTX/*). N: Lang Hames; E: lhames@gmail.com; D: MCJIT, RuntimeDyld and JIT event listeners, Orcish Warchief. N: Min-Yih Hsu; E: min@myhsu.dev; D: M68k Target (lib/Target/M68k/*). N: Cyndy Ishida; E: cyndyishida@gmail.com; D: TextAPI (lib/TextAPI/*) and related TAPI tools. N: Teresa Johnson; E: tejohnson@google.com; D: Gold plugin (tools/gold/*) and IR Linker. N: Galina Kistanova; E: gkistanova@gmail.com; D: LLVM Buildbot. N: Anton Korobeynikov; E: anton@korobeynikov.info; D: Exception handling, Windows codegen, ARM EABI, MSP430 Target (lib/Target/MSP430/*). N: Benjamin Kramer; E: benny.kra@gmail.com; D: DWARF Parser. N: Sundeep Kushwaha; E: sundeepk@quicinc.com; D: Hexagon Backend. N: Florian Hahn; E: flo@fhahn.com; D: Loop Vectorizer. N: Alexey Bataev; E: a.bataev@outlook.com; D: SLP Vectorizer. N: Sergei Larin; E: slarin@codeaurora.org; D: VLIW Instruction Scheduling, Packetization. N: Chris Lattner; E: sabre@nondot.org; W: http://nondot.org/~sabre/; D: Everything not covered by someone else. N: Weining Lu; E: luweining@loongson.cn; D: LoongArch backend (lib/Target/LoongArch/*). N: David Majnemer; E: david.majnemer@gmail.com; D: IR Constant Folder, InstCombine. N: Ben Shi; E: 2283975856@qq.com, powerman1st@163.com; D: AVR Backend. N: Kazushi Marukawa; E: marukawa@nec.com; D: VE Backend. N: Tim Northover; E: t.p.no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CODE_OWNERS.TXT:2913,plugin,plugin,2913,interpreter/llvm-project/llvm/CODE_OWNERS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CODE_OWNERS.TXT,1,['plugin'],['plugin']
Modifiability,"ailable. ### Performing the Fit. Here we have now all the required input ingredients for the fit, the data and the function to fit.; Depending on these we have now several different way to perform the fit, using the corresponding methods of the; `ROOT::Fit::Fitter` class and depending on the type of input data. #### Available fit methods. * **Least-square fit**: `Fitter::LeastSquare(const BinData & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional; *extended* boolean flag as *false*. This method is implemented by the class `ROOT::Fit:::PoissonLikelihoodFCN`.; * **Un-Binned likelihood fit**: `Fitter::LikelihoodFit(const UnBindata &)`. The user needs to pass an `UnBinData` object. By default the fit is not extended (i.e. the normalization is not fitted to the; data). As above the user can select an extended likelihood fit by passing the optional; *extended* boolean flag as *true*. This method is implemented using the class `LogLikelihoodFCN`; * **Linear Fit**: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the *Matrix* library), if the model function is linear in the; parameters. #### Customised Fit methods. Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize.; In this case, the user does not really need to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:46296,extend,extended,46296,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['extend'],['extended']
Modifiability,"ailed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. For questions regarding; libc++, the best place to ask is the #libcxx channel on; LLVM's Discord server. Creating Patch Files. To contribute changes to Clang see; LLVM's Getting Started page. LLVM IR Generation. The LLVM IR generation part of clang handles conversion of the; AST nodes output by the Sema module to the LLVM Intermediate; Representation (IR). Historically, this was referred to as; ""codegen"", and the Clang code for this lives; in lib/CodeGen.; The output is most",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:8283,config,configurations,8283,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['config'],['configurations']
Modifiability,"ainType == 9); subType = 6;; else if (mainType == 11); subType = 9;; return subType;; }. int test2(int mainType, int subType) {; if (mainType == 7); subType = 4;; if (mainType == 9); subType = 6;; if (mainType == 11); subType = 9;; return subType;; }. //===---------------------------------------------------------------------===//. The following test case (from PR6576):. define i32 @mul(i32 %a, i32 %b) nounwind readnone {; entry:; %cond1 = icmp eq i32 %b, 0 ; <i1> [#uses=1]; br i1 %cond1, label %exit, label %bb.nph; bb.nph: ; preds = %entry; %tmp = mul i32 %b, %a ; <i32> [#uses=1]; ret i32 %tmp; exit: ; preds = %entry; ret i32 0; }. could be reduced to:. define i32 @mul(i32 %a, i32 %b) nounwind readnone {; entry:; %tmp = mul i32 %b, %a; ret i32 %tmp; }. //===---------------------------------------------------------------------===//. We should use DSE + llvm.lifetime.end to delete dead vtable pointer updates.; See GCC PR34949. Another interesting case is that something related could be used for variables; that go const after their ctor has finished. In these cases, globalopt (which; can statically run the constructor) could mark the global const (so it gets put; in the readonly section). A testcase would be:. #include <complex>; using namespace std;; const complex<char> should_be_in_rodata (42,-42);; complex<char> should_be_in_data (42,-42);; complex<char> should_be_in_bss;. Where we currently evaluate the ctors but the globals don't become const because; the optimizer doesn't know they ""become const"" after the ctor is done. See; GCC PR4131 for more examples. //===---------------------------------------------------------------------===//. In this code:. long foo(long x) {; return x > 1 ? x : 1;; }. LLVM emits a comparison with 1 instead of 0. 0 would be equivalent; and cheaper on most targets. LLVM prefers comparisons with zero over non-zero in general, but in this; case it choses instead to keep the max operation obvious. //===-----------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:50886,variab,variables,50886,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['variab'],['variables']
Modifiability,"ake it possible to run extra user defined actions during a; compilation. This document will provide a basic walkthrough of how to write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by declaring a ``ParsedAttrInfo`` and registering; it using `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:1053,plugin,plugin,1053,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,1,['plugin'],['plugin']
Modifiability,"ake with the following; invocation:. .. code-block:: console. % cmake -G ""Unix Makefiles"" -DCMAKE_BUILD_TYPE=<type> SRC_ROOT. Between runs, CMake preserves the values set for all options. CMake has the; following build types defined:. Debug. These builds are the default. The build system will compile the tools and; libraries unoptimized, with debugging information, and asserts enabled. Release. For these builds, the build system will compile the tools and libraries; with optimizations enabled and not generate debug info. CMakes default; optimization level is -O3. This can be configured by setting the; ``CMAKE_CXX_FLAGS_RELEASE`` variable on the CMake command line. RelWithDebInfo. These builds are useful when debugging. They generate optimized binaries with; debug information. CMakes default optimization level is -O2. This can be; configured by setting the ``CMAKE_CXX_FLAGS_RELWITHDEBINFO`` variable on the; CMake command line. Once you have LLVM configured, you can build it by entering the *OBJ_ROOT*; directory and issuing the following command:. .. code-block:: console. % make. If the build fails, please `check here`_ to see if you are using a version of; GCC that is known not to compile LLVM. If you have multiple processors in your machine, you may wish to use some of the; parallel build options provided by GNU Make. For example, you could use the; command:. .. code-block:: console. % make -j2. There are several special targets which are useful when working with the LLVM; source code:. ``make clean``. Removes all files generated by the build. This includes object files,; generated C/C++ files, libraries, and executables. ``make install``. Installs LLVM header files, libraries, tools, and documentation in a hierarchy; under ``$PREFIX``, specified with ``CMAKE_INSTALL_PREFIX``, which; defaults to ``/usr/local``. ``make docs-llvm-html``. If configured with ``-DLLVM_ENABLE_SPHINX=On``, this will generate a directory; at ``OBJ_ROOT/docs/html`` which contains the HTML fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:29593,config,configured,29593,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configured']
Modifiability,"al asymmetric, and may be expensive to calculate,; especially if there are a lot of free parameters and the problem is very; non-linear. $\mbox{MINOS}$ can only operate after a good minimum has already; been found, and the error matrix has been calculated, so the; $\mbox{MINOS}$ error analysis will normally follow a; $\mbox{MIGRAD}$ minimization. The $\mbox{MINOS}$ error for a; given parameter is defined as the change in the value of that parameter; which causes ${\displaystyle F'}$ to increase by the amount; FCNBase::up(), where ${\displaystyle F'}$ is the minimum of; $\mbox{FCN}$ with respect to all *other* free parameters, and; FCNBase::up() is the return value of the error definition specified by; the user (default = 1.). The algorithm for finding the positive and negative $\mbox{MINOS}$; errors for parameter $\mbox{n}$ consists of varying parameter; $\mbox{n}$, each time minimizing $\mbox{FCN}$ with respect to; all the other $\mbox{npar - 1}$ variable parameters, to find; numerically the two values of parameter $\mbox{n}$ for which the; minimum of $\mbox{FCN}$ takes on the values; $\displaystyle F_{\mathrm{min}} + \mbox{up}$, where; $\displaystyle F_{\mathrm{min}}$ is the minimum of $\mbox{FCN}$ with; respect to all $\mbox{npar}$ parameters. In order to make the; procedure as fast as possible, $\mbox{MINOS}$ uses the error matrix; to predict the values of all parameters at the various sub-minima which; it will have to find in the course of the calculation, and in the limit; that the problem is nearly linear, the predictions of $\mbox{MINOS}$; will be nearly exact, requiring very few iterations. On the other hand,; when the problem is very non-linear (i.e., $\mbox{FCN}$ is far from; a quadratic function of its parameters), is precisely the situation when; $\mbox{MINOS}$ is needed in order to indicate the correct parameter; errors. ### $\mbox{CONTOURS}$ plotting ###. M offers a procedure for finding $\mbox{FCN}$ $\mbox{CONTOURS}$; (provided via the class MnContour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:18744,variab,variable,18744,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"al function describing the relation between the independent variables **`X`** and the single dependent variable `Y`.; We can have an arbitrary number `k` of independent variables. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:36275,extend,extends,36275,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['extend'],['extends']
Modifiability,"al is not intended to explain what; LLVM is, how it works, and what LLVM code looks like. It assumes that you know; the basics of LLVM and are interested in writing transformations or otherwise; analyzing or manipulating the code. This document should get you oriented so that you can find your way in the; continuously growing source code that makes up the LLVM infrastructure. Note; that this manual is not intended to serve as a replacement for reading the; source code, so if you think there should be a method in one of these classes to; do something, but it's not listed, check the source. Links to the `doxygen; <https://llvm.org/doxygen/>`__ sources are provided to make this as easy as; possible. The first section of this document describes general information that is useful; to know when working in the LLVM infrastructure, and the second describes the; Core LLVM classes. In the future this manual will be extended with information; describing how to use extension libraries, such as dominator information, CFG; traversal routines, and useful utilities like the ``InstVisitor`` (`doxygen; <https://llvm.org/doxygen/InstVisitor_8h_source.html>`__) template. .. _general:. General Information; ===================. This section contains general information that is useful if you are working in; the LLVM source-base, but that isn't specific to any particular API. .. _stl:. The C++ Standard Template Library; ---------------------------------. LLVM makes heavy use of the C++ Standard Template Library (STL), perhaps much; more than you are used to, or have seen before. Because of this, you might want; to do a little background reading in the techniques used and capabilities of the; library. There are many good pages that discuss the STL, and several books on; the subject that you can get, so it will not be discussed in this document. Here are some useful links:. #. `cppreference.com; <https://en.cppreference.com/w/>`_ - an excellent; reference for the STL and other parts of the s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:1243,extend,extended,1243,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['extend'],['extended']
Modifiability,"al representation that is at most one level deep. For example, consider the following:. .. code-block:: c++. for (int i = 1; i < n; i++) {; b[i] = c[i] + b[i-1];; }. This code contains a statement that has a loop carried dependence on; itself creating a cycle in the DDG. The figure below illustrates; how the cycle of dependency is carried through multiple def-use relations; and a memory access dependency. .. image:: cycle.png. The DDG corresponding to this example would have a pi-block that contains; all the nodes participating in the cycle, as shown below:. .. image:: cycle_pi.png. Program Dependence Graph; ========================. The Program Dependence Graph (or PDG) has a similar structure as the; DDG, but it is capable of representing both data dependencies and; control-flow dependencies between program elements such as; instructions, groups of instructions, basic blocks or groups of; basic blocks. High-Level Design; =================. The DDG and the PDG are both directed graphs and they extend the; ``DirectedGraph`` class. Each implementation extends its corresponding; node and edge types resulting in the inheritance relationship depicted; in the UML diagram below:. .. image:: uml_nodes_and_edges.png. Graph Construction; ------------------. The graph build algorithm considers dependencies between elements of; a given set of instructions or basic blocks. Any dependencies coming; into or going out of instructions that do not belong to that range; are ignored. The steps in the build algorithm for the DDG are very; similar to the steps in the build algorithm for the PDG. As such,; one of the design goals is to reuse the build algorithm code to; allow creation of both DDG and PDG representations while allowing; the two implementations to define their own distinct and independent; node and edge types. This is achieved by using the well-known builder; design pattern to isolate the construction of the dependence graph; from its concrete representation. The following ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:2498,extend,extend,2498,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['extend'],['extend']
Modifiability,"al to a; * checksum - A list of checksums of the source class that can be an input for this; rule. The list has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target - A semicolon-separated list of target class data member names that this rule; is capable of calculating.; * embed - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include - A list of header files that should be included in order to provide the func-; tionality used in the code snippet; the list is comma delimited.; * code - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj - variable representing the target in-memory object, it’s type is that of the; target object; * oldObj - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer - in raw conversion rules, an object of TBuﬀer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. 3. The C++ API. The schema evolution C++ API consists of two classes: ROOT::TSchemaRuleSet and ROOT::TSchemaRule.; Objects of the TSchemaRule class represent the rules and their fields hav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt:4959,variab,variables,4959,io/doc/DataModelEvolution.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt,1,['variab'],['variables']
Modifiability,"al to a; * checksum; - A list of checksums of the source class that can be an input for this; rule. The list has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass; - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target; - A comma-separated list of target class data member names that this rule; is capable of calculating.; * embed; - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include; - A list of header files that should be included in order to provide the; functionality used in the code snippet; the list is comma delimited.; * code; - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj; - variable representing the target in-memory object, its type is that of the; target object; * oldObj; - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer; - in raw conversion rules, an object of TBuffer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx; - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. #### The C++ API. The schema evolution C++ API consists of two classes: `ROOT::TSchemaRuleSet` and; `ROOT::TSchemaRule`. Objects of the TSchemaRule class represent the rules and their ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:81546,variab,variables,81546,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variables']
Modifiability,"al-world; software). ## Data flow analysis. ### The purpose of data flow analysis. Data flow analysis is a static analysis technique that proves facts about a; program or its fragment. It can make conclusions about all paths through the; program, while taking control flow into account and scaling to large programs.; The basic idea is propagating facts about the program through the edges of the; control flow graph (CFG) until a fixpoint is reached. ### Sample problem and an ad-hoc solution. We would like to explain data flow analysis while discussing an example. Let's; imagine that we want to track possible values of an integer variable in our; program. Here is how a human could annotate the code:. ```c++; void Example(int n) {; int x = 0;; // x is {0}; if (n > 0) {; x = 5;; // x is {5}; } else {; x = 42;; // x is {42}; }; // x is {5; 42}; print(x);; }; ```. We use sets of integers to represent possible values of `x`. Local variables; have unambiguous values between statements, so we annotate program points; between statements with sets of possible values. Here is how we arrived at these annotations. Assigning a constant to `x` allows; us to make a conclusion that `x` can only have one value. When control flow from; the ""then"" and ""else"" branches joins, `x` can have either value. Abstract algebra provides a nice formalism that models this kind of structure,; namely, a lattice. A join-semilattice is a partially ordered set, in which every; two elements have a least upper bound (called a *join*). ```; join(a, b) ⩾ a and join(a, b) ⩾ b and join(x, x) = x; ```. For this problem we will use the lattice of subsets of integers, with set; inclusion relation as ordering and set union as a join. Lattices are often represented visually as Hasse diagrams. Here is a Hasse; diagram for our lattice that tracks subsets of integers:. ![Hasse diagram for a lattice of integer sets](DataFlowAnalysisIntroImages/IntegerSetsInfiniteLattice.svg). Computing the join in the lattice corresponds",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:2549,variab,variables,2549,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['variab'],['variables']
Modifiability,"al; code often follows a pattern:. .. code-block:: c++. float my_function(float a) {; if (__nvvm_reflect(""FASTMATH"")); return my_function_fast(a);; else; return my_function_precise(a);; }. The default value for all unspecified reflection parameters is zero. The ``NVVMReflect`` pass should be executed early in the optimization; pipeline, immediately after the link stage. The ``internalize`` pass is also; recommended to remove unused math functions from the resulting PTX. For an; input IR module ``module.bc``, the following compilation flow is recommended:. 1. Save list of external functions in ``module.bc``; 2. Link ``module.bc`` with ``libdevice.compute_XX.YY.bc``; 3. Internalize all functions not in list from (1); 4. Eliminate all unused internal functions; 5. Run ``NVVMReflect`` pass; 6. Run standard optimization pipeline. .. note::. ``linkonce`` and ``linkonce_odr`` linkage types are not suitable for the; libdevice functions. It is possible to link two IR modules that have been; linked against libdevice using different reflection variables. Since the ``NVVMReflect`` pass replaces conditionals with constants, it will; often leave behind dead code of the form:. .. code-block:: llvm. entry:; ..; br i1 true, label %foo, label %bar; foo:; ..; bar:; ; Dead code; .. Therefore, it is recommended that ``NVVMReflect`` is executed early in the; optimization pipeline before dead-code elimination. The NVPTX TargetMachine knows how to schedule ``NVVMReflect`` at the beginning; of your pass manager; just use the following code when setting up your pass; manager and the PassBuilder will use ``registerPassBuilderCallbacks`` to let; NVPTXTargetMachine::registerPassBuilderCallbacks add the pass to the; pass manager:. .. code-block:: c++. std::unique_ptr<TargetMachine> TM = ...;; PassBuilder PB(TM);; ModulePassManager MPM;; PB.parsePassPipeline(MPM, ...);. Reflection Parameters; ---------------------. The libdevice library currently uses the following reflection parameters to; contro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:9528,variab,variables,9528,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['variab'],['variables']
Modifiability,"al;; if (Init) {; InitVal = Init->codegen();; if (!InitVal); return nullptr;; } else { // If not specified, use 0.0.; InitVal = ConstantFP::get(*TheContext, APFloat(0.0));; }. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);; Builder->CreateStore(InitVal, Alloca);. // Remember the old variable binding so that we can restore the binding when; // we unrecurse.; OldBindings.push_back(NamedValues[VarName]);. // Remember this binding.; NamedValues[VarName] = Alloca;; }. There are more comments here than code. The basic idea is that we emit; the initializer, create the alloca, then update the symbol table to; point to it. Once all the variables are installed in the symbol table,; we evaluate the body of the var/in expression:. .. code-block:: c++. // Codegen the body, now that all vars are in scope.; Value *BodyVal = Body->codegen();; if (!BodyVal); return nullptr;. Finally, before returning, we restore the previous variable bindings:. .. code-block:: c++. // Pop all our variables from scope.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i); NamedValues[VarNames[i].first] = OldBindings[i];. // Return the body computation.; return BodyVal;; }. The end result of all of this is that we get properly scoped variable; definitions, and we even (trivially) allow mutation of them :). With this, we completed what we set out to do. Our nice iterative fib; example from the intro compiles and runs just fine. The mem2reg pass; optimizes all of our stack variables into SSA registers, inserting PHI; nodes where needed, and our front-end remains simple: no ""iterated; dominance frontier"" computation anywhere in sight. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; mutable variables and var/in support. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:28380,variab,variables,28380,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"alar command line arguments. In addition to simple scalar arguments,; the CommandLine library also provides primitives to support CommandLine option; `aliases`_, and `lists`_ of options. .. _aliases:. Argument Aliases; ----------------. So far, the example works well, except for the fact that we need to check the; quiet condition like this now:. .. code-block:: c++. ...; if (!Quiet && !Quiet2) printInformationalMessage(...);; ... ... which is a real pain! Instead of defining two values for the same; condition, we can use the ""`cl::alias`_"" class to make the ""``-q``"" option an; **alias** for the ""``-quiet``"" option, instead of providing a value itself:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Overwrite output files""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::alias QuietA(""q"", cl::desc(""Alias for -quiet""), cl::aliasopt(Quiet));. The third line (which is the only one we modified from above) defines a ""``-q``""; alias that updates the ""``Quiet``"" variable (as specified by the `cl::aliasopt`_; modifier) whenever it is specified. Because aliases do not hold state, the only; thing the program has to query is the ``Quiet`` variable now. Another nice; feature of aliases is that they automatically hide themselves from the ``-help``; output (although, again, they are still visible in the ``-help-hidden output``). Now the application code can simply use:. .. code-block:: c++. ...; if (!Quiet) printInformationalMessage(...);; ... ... which is much nicer! The ""`cl::alias`_"" can be used to specify an; alternative name for any variable type, and has many uses. .. _unnamed alternatives using the generic parser:. Selecting an alternative from a set of possibilities; ----------------------------------------------------. So far we have seen how the CommandLine library handles builtin types like; ``std::string``, ``bool`` and ``int``, but how does it handle things it doesn't; know about, like enums or '``int*``'s?. The answer ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:12577,variab,variable,12577,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"alculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N-dimensional intervals based on the contour of a likelihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS contour about the maximum likelihood estimator. . HybridCalculator: hypothesis test calculator using a Bayesian-frequentist hybrid method (often called in HEP as CLs method). This class extends the functionality of the TLimit class by taking advantage of the RooFit package. The result of the calculator is returned as an HybridResult pointer. HybridResult implements the HypoTestResult interface. The class HybridPlot allows for a graphical representation of a HybridResult.; ; HybridCalculator implements the interface class HypoTestCalculator. A constructor exists taking as input the pdf's (expressed as RooAbsPdf instances) for the signal+background (alternate) and background only (null) hypothesis and the data set (as RooAbsData instance). One can provide optionally also the nuisance parameters and its pdf which will be marginalized by the calculator. The HypoTestCalculator interface provides also the possibility of setting the model via a Rooworkspace class and names of the pdf. This possibility is not yet supported for the HybridCalculator class. ; ; . Additional classes or functions provided by RooStats are: ; ; NumberCountingUtils: a collection of number counting statistical utilities; 	NumberCountingPd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:11128,extend,extends,11128,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['extend'],['extends']
Modifiability,"algorithm. This means that, for; example, a binary operator will stackify with its user before its operands.; However, if moving the binary operator to its user moves it to a place where; its operands can't be moved to, it would be better to leave it in place, or; perhaps move it up, so that it can stackify its operands. A binary operator; has two operands and one result, so in such cases there could be a net win by; preferring the operands. //===---------------------------------------------------------------------===//. Instruction ordering has a significant influence on register stackification and; coloring. Consider experimenting with the MachineScheduler (enable via; enableMachineScheduler) and determine if it can be configured to schedule; instructions advantageously for this purpose. //===---------------------------------------------------------------------===//. WebAssemblyRegStackify currently assumes that the stack must be empty after; an instruction with no return values, however wasm doesn't actually require; this. WebAssemblyRegStackify could be extended, or possibly rewritten, to take; full advantage of what WebAssembly permits. //===---------------------------------------------------------------------===//. Add support for mergeable sections in the Wasm writer, such as for strings and; floating-point constants. //===---------------------------------------------------------------------===//. The function @dynamic_alloca_redzone in test/CodeGen/WebAssembly/userstack.ll; ends up with a local.tee in its prolog which has an unused result, requiring; an extra drop:. global.get $push8=, 0; local.tee $push9=, 1, $pop8; drop $pop9; [...]. The prologue code initially thinks it needs an FP register, but later it; turns out to be unneeded, so one could either approach this by being more; clever about not inserting code for an FP in the first place, or optimizing; away the copy later. //===---------------------------------------------------------------------===//; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt:6421,extend,extended,6421,interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,1,['extend'],['extended']
Modifiability,"alias. The operand; fields are. * *strtab offset*, *strtab size*: Specifies the name of the alias.; See `STRTAB_BLOCK Contents`_. * *alias type*: The type index of the alias. * *aliasee val#*: The value index of the aliased value. * *linkage*: An encoding of the `linkage type`_ for this alias. * *visibility*: If present, an encoding of the `visibility`_ of the alias. * *dllstorageclass*: If present, an encoding of the; :ref:`dllstorageclass<bcdllstorageclass>` of the alias. * *threadlocal*: If present, an encoding of the; :ref:`thread local property<bcthreadlocal>` of the alias. * *unnamed_addr*: If present, an encoding of the; :ref:`unnamed_addr<bcunnamedaddr>` attribute of this alias. * *preemptionspecifier*: If present, an encoding of the :ref:`runtime preemption specifier<bcpreemptionspecifier>` of this alias. .. _MODULE_CODE_GCNAME:. MODULE_CODE_GCNAME Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[GCNAME, ...string...]``. The ``GCNAME`` record (code 11) contains a variable number of values; representing the bytes of a single garbage collector name string. There should; be one ``GCNAME`` record for each garbage collector name referenced in function; ``gc`` attributes within the module. These records can be referenced by 1-based; index in the *gc* fields of ``FUNCTION`` records. .. _PARAMATTR_BLOCK:. PARAMATTR_BLOCK Contents; ------------------------. The ``PARAMATTR_BLOCK`` block (id 9) contains a table of entries describing the; attributes of function parameters. These entries are referenced by 1-based index; in the *paramattr* field of module block `FUNCTION`_ records, or within the; *attr* field of function block ``INST_INVOKE`` and ``INST_CALL`` records. Entries within ``PARAMATTR_BLOCK`` are constructed to ensure that each is unique; (i.e., no two indices represent equivalent attribute lists). .. _PARAMATTR_CODE_ENTRY:. PARAMATTR_CODE_ENTRY Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[ENTRY, attrgrp0, attrgrp1, ...]``. The ``ENTRY`` record (code 2) contains a variable n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:33167,variab,variable,33167,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"alifier; Unknown. 750; CD2; Implementation constraints on reference-only closure objects; Unknown. 751; CD2; Deriving from closure classes; Unknown. 752; CD2; Name lookup in nested lambda-expressions; Unknown. 753; CD2; Array names in lambda capture sets; Unknown. 754; CD2; Lambda expressions in default arguments of block-scope function declarations; Unknown. 755; CD3; Generalized lambda-captures; Unknown. 756; CD2; Dropping cv-qualification on members of closure objects; Unknown. 757; CD2; Types without linkage in declarations; Unknown. 758; C++11; Missing cases of declarations that are not definitions; Unknown. 759; CD2; Destruction of closure objects; Unknown. 760; CD2; this inside a nested class of a non-static member function; Unknown. 761; CD2; Inferred return type of closure object call operator; Unknown. 762; CD2; Name lookup in the compound-statement of a lambda expression; Unknown. 763; CD2; Is a closure object's operator() inline?; Unknown. 764; CD2; Capturing unused variables in a lambda expression; Unknown. 765; CD2; Local types in inline functions with external linkage; Unknown. 766; CD2; Where may lambda expressions appear?; Unknown. 767; CD2; void and other unnamed lambda-parameters; Unknown. 768; CD2; Ellipsis in a lambda parameter list; Unknown. 769; CD2; Initialization of closure objects; Unknown. 770; CD2; Ambiguity in late-specified return type; Unknown. 771; CD2; Move-construction of reference members of closure objects; Unknown. 772; CD2; capture-default in lambdas in local default arguments; Unknown. 773; C++11; Parentheses in address non-type template arguments; Unknown. 774; CD2; Can a closure class be a POD?; Unknown. 775; CD2; Capturing references to functions; Unknown. 776; CD2; Delegating constructors, destructors, and std::exit; Unknown. 777; CD2; Default arguments and parameter packs; Clang 3.7. 778; C++11; Template parameter packs in non-type template parameters; Unknown. 779; CD2; Rvalue reference members of closure objects?; Unknow",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:52305,variab,variables,52305,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"align 4; call void @llvm.dbg.declare(metadata i32* %i.addr, metadata !1,; metadata !DIExpression()), !dbg !2; !1 = !DILocalVariable(name: ""i"", ...) ; int i; !2 = !DILocation(...); ...; %buffer = alloca [256 x i8], align 8; ; The address of i is buffer+64.; call void @llvm.dbg.declare(metadata [256 x i8]* %buffer, metadata !3,; metadata !DIExpression(DW_OP_plus, 64)), !dbg !4; !3 = !DILocalVariable(name: ""i"", ...) ; int i; !4 = !DILocation(...). A frontend should generate exactly one call to ``llvm.dbg.declare`` at the point; of declaration of a source variable. Optimization passes that fully promote the; variable from memory to SSA values will replace this call with possibly multiple; calls to `llvm.dbg.value`. Passes that delete stores are effectively partial; promotion, and they will insert a mix of calls to ``llvm.dbg.value`` to track; the source variable value when it is available. After optimization, there may be; multiple calls to ``llvm.dbg.declare`` describing the program points where the; variables lives in memory. All calls for the same concrete source variable must; agree on the memory location. ``llvm.dbg.value``; ^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.value(metadata, metadata, metadata). This intrinsic provides information when a user source variable is set to a new; value. The first argument is the new value (wrapped as metadata). The second; argument is a `local variable <LangRef.html#dilocalvariable>`_ containing a; description of the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a source variable; directly, not its address. Note that the value operand of this intrinsic may; be indirect (i.e, a pointer to the source variable), provided that interpreting; the complex expression derives the direct value. ``llvm.dbg.assign``; ^^^^^^^^^^^^^^^^^^^; .. toctree::; :hidden:. AssignmentTracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:10041,variab,variables,10041,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"alizationResponsibility argument; can be used to query JIT state for the module being transformed, such as the set; of definitions in the module that JIT'd code is actively trying to call/access.; For now we will ignore this argument and use a standard optimization; pipeline. To do this we set up a FunctionPassManager, add some passes to it, run; it over every function in the module, and then return the mutated module. The; specific optimizations are the same ones used in `Chapter 4 <LangImpl04.html>`_; of the ""Implementing a language with LLVM"" tutorial series. Readers may visit; that chapter for a more in-depth discussion of these, and of IR optimization in; general. And that's it in terms of changes to KaleidoscopeJIT: When a module is added via; addModule the OptimizeLayer will call our optimizeModule function before passing; the transformed module on to the CompileLayer below. Of course, we could have; called optimizeModule directly in our addModule function and not gone to the; bother of using the IRTransformLayer, but doing so gives us another opportunity; to see how layers compose. It also provides a neat entry point to the *layer*; concept itself, because IRTransformLayer is one of the simplest layers that; can be implemented. .. code-block:: c++. // From IRTransformLayer.h:; class IRTransformLayer : public IRLayer {; public:; using TransformFunction = std::function<Expected<ThreadSafeModule>(; ThreadSafeModule, const MaterializationResponsibility &R)>;. IRTransformLayer(ExecutionSession &ES, IRLayer &BaseLayer,; TransformFunction Transform = identityTransform);. void setTransform(TransformFunction Transform) {; this->Transform = std::move(Transform);; }. static ThreadSafeModule; identityTransform(ThreadSafeModule TSM,; const MaterializationResponsibility &R) {; return TSM;; }. void emit(MaterializationResponsibility R, ThreadSafeModule TSM) override;. private:; IRLayer &BaseLayer;; TransformFunction Transform;; };. // From IRTransformLayer.cpp:. IRTransfor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:6289,layers,layers,6289,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['layers'],['layers']
Modifiability,"all cell contents are scaled to `ncolors`.; The current color palette does not have a class or global object of its; own. It is defined in the current style as an array of color numbers.; The current palette can be changed with:. ``` {.cpp}; TStyle::SetPalette(Int_t ncolors,Int_t*color_indexes).; ```. By default, or if `ncolors <= 0`, a default palette (see above) of 50; colors is defined. The colors defined in this palette are good for; coloring pads, labels, and other graphic objects. If `ncolors > 0` and; `colors = 0`, the default palette is used with a maximum of `ncolors`.; If `ncolors == 1 && colors == 0`, then a pretty palette with a spectrum; `Violet->Red` is created. It is recommended to use this pretty palette; when drawing lego(s), surfaces or contours. For example, to set the; current palette to the ""`pretty`"" one, do:. ``` {.cpp}; root[] gStyle->SetPalette(1); ```. A more complete example is shown below. It illustrates the definition of; a custom palette. You can adapt it to suit your needs. In case you use; it for contour coloring, with the current color/contour algorithm,; always define two more colors than the number of contours. ``` {.cpp}; void palette() {; // Example of creating new colors (purples); const Int_t colNum = 10; // and defining of a new palette; Int_t palette[colNum];; for (Int_t i=0; i<colNum; i++) {; // get the color and if it does not exist create it; if (! gROOT->GetColor(230+i) ){; TColor *color =; new TColor(230+i,1-(i/((colNum)*1.0)),0.3,0.5,"""");; } else {; TColor *color = gROOT->GetColor(230+i);; color->SetRGB(1-(i/((colNum)*1.0)),0.3,0.5);; }; palette[i] = 230+i;; }; gStyle->SetPalette(colNum,palette);; TF2 *f2 = new TF2(""f2"",""exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; ```. Since ROOT 6.26, you can also define a palette based on an ASCII text; file, using `TColor::CreateColorTableFromFile(""filename.txt"")` or; `gStyle->SetPalette(""f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:82739,adapt,adapt,82739,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['adapt'],['adapt']
Modifiability,"allEvent's getRuntimeDefinition() method,; which returns a RuntimeDefinition object. When asked to provide a definition,; the CallEvents for dynamic calls will use the DynamicTypeInfo in their; ProgramState to attempt to devirtualize the call. In the case of no dynamic; dispatch, or perfectly constrained devirtualization, the resulting; RuntimeDefinition contains a Decl corresponding to the definition of the called; function, and RuntimeDefinition::mayHaveOtherDefinitions will return FALSE. In the case of dynamic dispatch where our information is not perfect, CallEvent; can make a guess, but RuntimeDefinition::mayHaveOtherDefinitions will return; TRUE. The RuntimeDefinition object will then also include a MemRegion; corresponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:11809,config,config,11809,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['config'],['config']
Modifiability,"allback should be assigned.; Callback is invoked when data received from the client or when connection is established.; Normally lambda function is used:. ```{.cpp}. win->SetDataCallBack([](unsigned connid, const std::string &msg) {. printf(""Msg:%s from connection:%u\n"", msg.c_str(), connid);. });. ```. Here **connid** is unique identifier, which assign to each connection when it is established.; There are several predefined messages kinds: **""CONN_READY""** when new connection established and; **""CONN_CLOSED""** when connection is closed by client.; The connection identifier should be used when sending message to the client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full path to the program which should be invoked.; With the method `win->GetUrl()` one obtains URL string, which can be typed in the browser address string directly. Same window can be displayed several times in different browsers or different browser tabs - one only; must allow appropriate number of connections calling `win->SetConnLimit(3)`. For the local displays **Chromium Embeded Framework (CEF)** is used. It provides functionality; of Chrome web browser in ROOT application without need to create and start real http server.; If CEF was configured correctly, it is enough to call `win->Show(""cef"")` to display window in CEF. ## Client code. There is no limitations which framework should be used on the client side.; The minimal HTML/JavaScript code, which establish connection with the server, looks like:. ``` {.html}; <!DOCTYP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:1871,config,configured,1871,documentation/users-guide/WebDisplay.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md,1,['config'],['configured']
Modifiability,"allers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:64463,variab,variables,64463,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variables']
Modifiability,"allow const; use of C++ objects, pointers, or references held in automatic storage. As usual, within the block, references to captured variables become; const-qualified, as if they were references to members of a const; object. Note that this does not change the type of a variable of; reference type. For example, given a class Foo:. .. code-block:: c. Foo foo;; Foo &fooRef = foo;; Foo *fooPtr = &foo;. A Block that referenced these variables would import the variables as; const variations:. .. code-block:: c. const Foo block_foo = foo;; Foo &block_fooRef = fooRef;; Foo *const block_fooPtr = fooPtr;. Captured variables are copied into the Block at the instant of; evaluating the Block literal expression. They are also copied when; calling ``Block_copy()`` on a Block allocated on the stack. In both; cases, they are copied as if the variable were const-qualified, and; it's an error if there's no such constructor. Captured variables in Blocks on the stack are destroyed when control; leaves the compound statement that contains the Block literal; expression. Captured variables in Blocks on the heap are destroyed; when the reference count of the Block drops to zero. Variables declared as residing in ``__block`` storage may be initially; allocated in the heap or may first appear on the stack and be copied; to the heap as a result of a ``Block_copy()`` operation. When copied; from the stack, ``__block`` variables are copied using their normal; qualification (i.e. without adding const). In C++11, ``__block``; variables are copied as x-values if that is possible, then as l-values; if not; if both fail, it's an error. The destructor for any initial; stack-based version is called at the variable's normal end of scope. References to ``this``, as well as references to non-static members of; any enclosing class, are evaluated by capturing ``this`` just like a; normal variable of C pointer type. Member variables that are Blocks may not be overloaded by the types of; their arguments.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:12145,variab,variables,12145,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,6,['variab'],"['variable', 'variables']"
Modifiability,"alone tool on your current buffer, optionally; selecting regions to reformat. The integration has the form of a `python`-file; which can be found under `clang/tools/clang-format/clang-format.py`. This can be integrated by adding the following to your `.vimrc`:. .. code-block:: vim. if has('python'); map <C-K> :pyf <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; elseif has('python3'); map <C-K> :py3f <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; endif. The first line enables :program:`clang-format` for NORMAL and VISUAL mode, the; second line adds support for INSERT mode. Change ""C-K"" to another binding if; you need :program:`clang-format` on a different key (C-K stands for Ctrl+k). With this integration you can press the bound key and clang-format will; format the current line in NORMAL and INSERT mode or the selected region in; VISUAL mode. The line or region is extended to the next bigger syntactic; entity. It operates on the current, potentially unsaved buffer and does not create; or save any files. To revert a formatting, just undo. An alternative option is to format changes when saving a file and thus to; have a zero-effort integration into the coding workflow. To do this, add this to; your `.vimrc`:. .. code-block:: vim. function! Formatonsave(); let l:formatdiff = 1; pyf <path-to-this-file>/clang-format.py; endfunction; autocmd BufWritePre *.h,*.cc,*.cpp call Formatonsave(). Emacs Integration; =================. Similar to the integration for :program:`vim`, there is an integration for; :program:`emacs`. It can be found at `clang/tools/clang-format/clang-format.el`; and used by adding this to your `.emacs`:. .. code-block:: common-lisp. (load ""<path-to-clang>/tools/clang-format/clang-format.el""); (global-set-key [C-M-tab] 'clang-format-region). This binds the function `clang-format-region` to C-M-tab, which then formats the; current line or selected",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:7433,extend,extended,7433,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['extend'],['extended']
Modifiability,"alse − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NTrees No 800 − Number of trees in the forest. MaxDepth No 3 − Max depth of the decision tree allowed. MinNodeSize No 5% − Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%). nCuts No 20 − Number of grid points in variable range used in finding optimal cut in node splitting. BoostType No AdaBoost AdaBoost, RealAdaBoost, Bagging, AdaBoostR2, Grad Boosting type for the trees in the forest . AdaBoostR2Loss No Quadratic Linear, Quadratic, Exponential Type of Loss function in AdaBoostR2. UseBaggedGrad No False − Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost). Shrinkage No 1 − Learning rate for GradBoost algorithm. AdaBoostBeta No 0.5 − Learning rate for AdaBoost algorithm. UseRandomisedTrees No False − Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests). UseNvars No 2 − Size of the subset of variables used with RandomisedTree option. UsePoissonNvars No True − Interpret UseNvars not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option. BaggedSampleFraction No 0.6 − Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedGrad, Bagging,). UseYesNoLeaf No True − Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost. NegWeightTreatment No InverseBoostNegWeights InverseBoostNegWeights, IgnoreNegWeightsInTraining, PairNegWeightsGlobal, Pray How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining; Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!). NodePurityLimit No 0.5 − In boostin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:12739,variab,variable,12739,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['variab'],"['variable', 'variables']"
Modifiability,"also (based on numeric_limits) templated functions on T (where T can be double, float or int) for computing; the limits for a given type:; ; T TMath::Limits< T >::Max() returning the maximum number which can be represented for the type T ( T TMath::Limits< double >::Max()=1.79769e+308); T TMath::Limits< T >::Min() returning the minimum number which can be represented for the type T ( T TMath::Limits< double >::Max()=2.22507e-308); T TMath::Limits< T >::Epsilon() returning the epsilon (see Wikipedia for its definition) for the type T ( T; TMath::Limits< double >::Epsilon()=2.22045e-16). TRandom1 and TRandom3. Add an implementation of UInt_t GetSeed() to return the first element of the seed table. Before always a fixed; value was returned, independently of the random generator state; . ROOT::Fit::Fitter and related classes. Add new version of the Fitter class with various improvements:; ; add the possibility to just evaluate the objective function (FCN) one time (Fitter::EvalFCN) and fill the; result (class ROOT::Fit::FitResult using the obtained value of FCN plus the parameter values and errors from; the Fit configuration class (ROOT::Fit::FitConfig).; This required adding a nw constructor of FitResult from FitConfig.; This originated from the Savannah request. ; Add also new methods Fitter::SetFCN.; Update the configuration (parameter values and errors) after a fit with the FitResult values; So next fit will use improved parameter values and errors. This update can be switched on/off; by using FitConfig::SetUpdateAfterFit(on/off). By default is on.; Add new method FitConfig::SetFromFitResult.; Add possibility to run Hesse (Fitter:::CalculateHessErrors) without having done the minimization. Add support for weighted likelihood fits. Add a new method Fitter::ApplyWeightCorrection(fcn2); which corrects covariance matrix for the weights using the likelihood function built using the weight square; Add the support for weights for the binned Poisson likelihood fits (in the; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html:1390,config,configuration,1390,math/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html,1,['config'],['configuration']
Modifiability,"also change for each sub-pad. ## Changes in 5.0.2; 1. Fix - read branch entries as arrays; 2. Fix - command submission to THttpServer; 3. Fix - let refill statbox also for empty histogram; 4. Fix - problem with online TTree::Draw and ROOT6. ## Changes in 5.0.1; 1. Support older ROOT files, created before 2010; 2. Support TBranchObject - appears in old files; 3. Correctly set TBasket buffer position for the entry; 4. Fix - problem with empty STL containers; 5. Fix - empty baskets at the end of branch store; 6. Fix - problem with zooming in THStack. ## Changes in 5.0.0; 1. Reading TTree data; - all kinds of branches, including split STL containers; - branches with several elementary leaves; - branches from different ROOT files; - JSROOT.TSelector class to access TTree data; - simple access to branch data with ""dump"" draw option; 2. TTree::Draw support; - simple 1D/2D/3D histograms; - simple cut conditions; - configurable histogram like ""px:py>>hist(50,-5,5,50,-5,5)""; - strings support; - iterate over arrays indexes, let use another branch as index values; - support ""Entry$"" and ""Entries$"" variables in expressions; - bits histogram like ""event.fTracks.fBits>>bits(16)""; - special handling of TBits; - arbitrary math function from JavaScript Math class, some TMath:: function from ROOT; - if branch is object, one could use methods ""TMath::Abs(lep1_p4.X()+lep1_p4.Y())""; - interactive player to configure and execute draw expression; 3. Full support of Float16_t and Double32_t types in I/O; 4. Drawing of RooPlot objects, I/O support for RooFit classes; 5. Many improvements in object inspector; - support of large lists; only first part is shown; - support of large arrays; values group in decades; - allow to call draw function for sub-elements in inspector; 6. Canvas or selected sub-pad can be enlarged when double-clicked outside frame (#116); Complete drawing will be expanded to the visible space.; Not available for flex, tabs and collapsible layouts.; 7. Support reading of lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:47002,config,configurable,47002,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,2,"['config', 'variab']","['configurable', 'variables']"
Modifiability,"alue allows for chained; assignments like ""X = (Y = Z)"". Now that we have an assignment operator, we can mutate loop variables; and arguments. For example, we can now run code like this:. ::. # Function to print a double.; extern printd(x);. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. def test(x); printd(x) :; x = 4 :; printd(x);. test(123);. When run, this example prints ""123"" and then ""4"", showing that we did; actually mutate the value! Okay, we have now officially implemented our; goal: getting this to work requires SSA construction in the general; case. However, to be really useful, we want the ability to define our; own local variables, let's add this next!. User-defined Local Variables; ============================. Adding var/in is just like any other extension we made to; Kaleidoscope: we extend the lexer, the parser, the AST and the code; generator. The first step for adding our new 'var/in' construct is to; extend the lexer. As before, this is pretty trivial, the code looks like; this:. .. code-block:: c++. enum Token {; ...; // var definition; tok_var = -13; ...; }; ...; static int gettok() {; ...; if (IdentifierStr == ""in""); return tok_in;; if (IdentifierStr == ""binary""); return tok_binary;; if (IdentifierStr == ""unary""); return tok_unary;; if (IdentifierStr == ""var""); return tok_var;; return tok_identifier;; ... The next step is to define the AST node that we will construct. For; var/in, it looks like this:. .. code-block:: c++. /// VarExprAST - Expression class for var/in; class VarExprAST : public ExprAST {; std::vector<std::pair<std::string, std::unique_ptr<ExprAST>>> VarNames;; std::unique_ptr<ExprAST> Body;. public:; VarExprAST(std::vector<std::pair<std::string, std::unique_ptr<ExprAST>>> VarNames,; std::unique_ptr<ExprAST> Body); : VarNames(std::move(VarNames)), Body(std::move(Body)) {}. Value *codegen() override;; };. var/in allows a list of names to be def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:23114,extend,extend,23114,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['extend'],['extend']
Modifiability,"alue passed as the ``%metadata`` parameter to the; ``@llvm.gcroot`` intrinsic. Also, for the function as a whole:. * ``getFrameSize()``: The overall size of the function's initial stack frame,; not accounting for any dynamic allocation. * ``roots_size()``: The count of roots in the function. To access the stack map, use ``GCFunctionMetadata::roots_begin()`` and; -``end()`` from the :ref:`GCMetadataPrinter <assembly>`:. .. code-block:: c++. for (iterator I = begin(), E = end(); I != E; ++I) {; GCFunctionInfo *FI = *I;; unsigned FrameSize = FI->getFrameSize();; size_t RootCount = FI->roots_size();. for (GCFunctionInfo::roots_iterator RI = FI->roots_begin(),; RE = FI->roots_end();; RI != RE; ++RI) {; int RootNum = RI->Num;; int RootStackOffset = RI->StackOffset;; Constant *RootMetadata = RI->Metadata;; }; }. If the ``llvm.gcroot`` intrinsic is eliminated before code generation by a; custom lowering pass, LLVM will compute an empty stack map. This may be useful; for collector plugins which implement reference counting or a shadow stack. .. _init-roots:. Initializing roots to null; ---------------------------. It is recommended that frontends initialize roots explicitly to avoid; potentially confusing the optimizer. This prevents the GC from visiting; uninitialized pointers, which will almost certainly cause it to crash. As a fallback, LLVM will automatically initialize each root to ``null``; upon entry to the function. Support for this mode in code generation is; largely a legacy detail to keep old collector implementations working. Custom lowering of intrinsics; ------------------------------. For GCs which use barriers or unusual treatment of stack roots, the; implementor is responsibly for providing a custom pass to lower the; intrinsics with the desired semantics. If you have opted in to custom; lowering of a particular intrinsic your pass **must** eliminate all; instances of the corresponding intrinsic in functions which opt in to; your GC. The best example of such",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:33473,plugin,plugins,33473,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugins']
Modifiability,"alue will be skipped. In order to use the -opt-bisect-limit option with a driver that provides a; wrapper around the LLVM core library, an additional prefix option may be; required, as defined by the driver. For example, to use this option with; clang, the ""-mllvm"" prefix must be used. A typical clang invocation would look; like this:. ::. clang -O2 -mllvm -opt-bisect-limit=256 my_file.c. The -opt-bisect-limit option may also be applied to link-time optimizations by; using a prefix to indicate that this is a plug-in option for the linker. The; following syntax will set a bisect limit for LTO transformations:. ::. # When using lld, or ld64 (macOS); clang -flto -Wl,-mllvm,-opt-bisect-limit=256 my_file.o my_other_file.o; # When using Gold; clang -flto -Wl,-plugin-opt,-opt-bisect-limit=256 my_file.o my_other_file.o. LTO passes are run by a library instance invoked by the linker. Therefore any; passes run in the primary driver compilation phase are not affected by options; passed via '-Wl,-plugin-opt' and LTO passes are not affected by options; passed to the driver-invoked LLVM invocation via '-mllvm'. Passing ``-opt-bisect-print-ir-path=path/foo.ll`` will dump the IR to; ``path/foo.ll`` when -opt-bisect-limit starts skipping passes. Bisection Index Values; ======================. The granularity of the optimizations associated with a single index value is; variable. Depending on how the optimization pass has been instrumented the; value may be associated with as much as all transformations that would have; been performed by an optimization pass on an IR unit for which it is invoked; (for instance, during a single call of runOnFunction for a FunctionPass) or as; little as a single transformation. The index values may also be nested so that; if an invocation of the pass is not skipped individual transformations within; that invocation may still be skipped. The order of the values assigned is guaranteed to remain stable and consistent; from one run to the next up to and inc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst:3214,plugin,plugin-opt,3214,interpreter/llvm-project/llvm/docs/OptBisect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst,1,['plugin'],['plugin-opt']
Modifiability,"alyzer <arg>. Pass arg to the static analyzer. .. option:: -Xassembler <arg>. Pass arg to the assembler. .. option:: -Xlinker <arg>. Pass arg to the linker. .. option:: -Xpreprocessor <arg>. Pass arg to the preprocessor. .. option:: -o <file>. Write output to file. .. option:: -print-file-name=<file>. Print the full library path of file. .. option:: -print-libgcc-file-name. Print the library path for the currently used compiler runtime library; (""libgcc.a"" or ""libclang_rt.builtins.*.a""). .. option:: -print-prog-name=<name>. Print the full program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:17670,variab,variables,17670,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['variab'],['variables']
Modifiability,"am.cpp; RWMutex.cpp; Signals.cpp; Threading.cpp; Valgrind.cpp; Watchdog.cpp. ADDITIONAL_HEADER_DIRS; Unix; Windows; ${LLVM_MAIN_INCLUDE_DIR}/llvm/ADT; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Support; ${Backtrace_INCLUDE_DIRS}. LINK_LIBS; ${system_libs} ${imported_libs} ${delayload_flags}. LINK_COMPONENTS; Demangle; ). set(llvm_system_libs ${system_libs}). # This block is only needed for llvm-config. When we deprecate llvm-config and; # move to using CMake export, this block can be removed.; if(LLVM_ENABLE_ZLIB); # CMAKE_BUILD_TYPE is only meaningful to single-configuration generators.; if(CMAKE_BUILD_TYPE); string(TOUPPER ${CMAKE_BUILD_TYPE} build_type); get_property(zlib_library TARGET ZLIB::ZLIB PROPERTY LOCATION_${build_type}); endif(); if(NOT zlib_library); get_property(zlib_library TARGET ZLIB::ZLIB PROPERTY LOCATION); endif(); get_library_name(${zlib_library} zlib_library); set(llvm_system_libs ${llvm_system_libs} ""${zlib_library}""); endif(). if(LLVM_ENABLE_ZSTD); # CMAKE_BUILD_TYPE is only meaningful to single-configuration generators.; if(CMAKE_BUILD_TYPE); string(TOUPPER ${CMAKE_BUILD_TYPE} build_type); get_property(zstd_library TARGET ${zstd_target} PROPERTY LOCATION_${build_type}); endif(); if(NOT zstd_library); get_property(zstd_library TARGET ${zstd_target} PROPERTY LOCATION); endif(); get_library_name(${zstd_library} zstd_library); set(llvm_system_libs ${llvm_system_libs} ""${zstd_library}""); endif(). if(LLVM_ENABLE_TERMINFO); if(NOT terminfo_library); get_property(terminfo_library TARGET Terminfo::terminfo PROPERTY LOCATION); endif(); get_library_name(${terminfo_library} terminfo_library); set(llvm_system_libs ${llvm_system_libs} ""${terminfo_library}""); endif(). set_property(TARGET LLVMSupport PROPERTY LLVM_SYSTEM_LIBS ""${llvm_system_libs}""). if(LLVM_INTEGRATED_CRT_ALLOC); if(LLVM_INTEGRATED_CRT_ALLOC MATCHES ""snmalloc$""); set_property(TARGET LLVMSupport PROPERTY CXX_STANDARD 17); add_compile_definitions(_SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING); i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt:9056,config,configuration,9056,interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"ame);; Variable->addIncoming(StartVal, PreheaderBB);. Now that the ""preheader"" for the loop is set up, we switch to emitting; code for the loop body. To begin with, we move the insertion point and; create the PHI node for the loop induction variable. Since we already; know the incoming value for the starting value, we add it to the Phi; node. Note that the Phi will eventually get a second value for the; backedge, but we can't set it up yet (because it doesn't exist!). .. code-block:: c++. // Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.; Value *OldVal = NamedValues[VarName];; NamedValues[VarName] = Variable;. // Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.; if (!Body->codegen()); return nullptr;. Now the code starts to get more interesting. Our 'for' loop introduces a; new variable to the symbol table. This means that our symbol table can; now contain either function arguments or loop variables. To handle this,; before we codegen the body of the loop, we add the loop variable as the; current value for its name. Note that it is possible that there is a; variable of the same name in the outer scope. It would be easy to make; this an error (emit an error and return null if there is already an; entry for VarName) but we choose to allow shadowing of variables. In; order to handle this correctly, we remember the Value that we are; potentially shadowing in ``OldVal`` (which will be null if there is no; shadowed variable). Once the loop variable is set into the symbol table, the code; recursively codegen's the body. This allows the body to use the loop; variable: any references to it will naturally find it in the symbol; table. .. code-block:: c++. // Emit the step value.; Value *StepVal = nullptr;; if (Step) {; StepVal = Step->codegen();; if (!StepVal); retur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:22918,variab,variable,22918,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability,"ame* argument name with unset (uninitialized) value; ====================== =============================================. The *value* can be any TableGen value. The *name*, if present, must be a; :token:`TokVarName`, which starts with a dollar sign (``$``). The purpose of; a name is to tag an operator or argument in a DAG with a particular meaning,; or to associate an argument in one DAG with a like-named argument in another; DAG. The following bang operators are useful for working with DAGs:; ``!con``, ``!dag``, ``!empty``, ``!foreach``, ``!getdagarg``, ``!getdagname``,; ``!getdagop``, ``!setdagarg``, ``!setdagname``, ``!setdagop``, ``!size``. Defvar in a record body; -----------------------. In addition to defining global variables, the ``defvar`` statement can; be used inside the :token:`Body` of a class or record definition to define; local variables. Template arguments of ``class`` or ``multiclass`` can be; used in the value expression. The scope of the variable extends from the; ``defvar`` statement to the end of the body. It cannot be set to a different; value within its scope. The ``defvar`` statement can also be used in the statement; list of a ``foreach``, which establishes a scope. A variable named ``V`` in an inner scope shadows (hides) any variables ``V``; in outer scopes. In particular, there are several cases:. * ``V`` in a record body shadows a global ``V``. * ``V`` in a record body shadows template argument ``V``. * ``V`` in template arguments shadows a global ``V``. * ``V`` in a ``foreach`` statement list shadows any ``V`` in surrounding record or; global scopes. Variables defined in a ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1). How records are built; ---------------------. The following steps are taken by TableGen when a record is built. Classes are simply; abstract records and so go through ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:52366,variab,variable,52366,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,2,"['extend', 'variab']","['extends', 'variable']"
Modifiability,"ameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3163,flexible,flexible,3163,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['flexible'],['flexible']
Modifiability,"ammer to remove this retain/release pair otherwise (as there is for; other parameters by, say, making the variable ``objc_externally_retained`` or; qualifying it with ``__unsafe_unretained``), we chose to make this optimizing; assumption and shift some amount of risk to the user. .. _arc.misc.enumeration:. Fast enumeration iteration variables; ------------------------------------. If a variable is declared in the condition of an Objective-C fast enumeration; loop, and the variable has no explicit ownership qualifier, then it is; implicitly :ref:`externally-retained <arc.misc.externally_retained>` so that; objects encountered during the enumeration are not actually retained and; released. .. admonition:: Rationale. This is an optimization made possible because fast enumeration loops promise; to keep the objects retained during enumeration, and the collection itself; cannot be synchronously modified. It can be overridden by explicitly; qualifying the variable with ``__strong``, which will make the variable; mutable again and cause the loop to retain the objects it encounters. .. _arc.misc.blocks:. Blocks; ------. The implicit ``const`` capture variables created when evaluating a block; literal expression have the same ownership semantics as the local variables; they capture. The capture is performed by reading from the captured variable; and initializing the capture variable with that value; the capture variable is; destroyed when the block literal is, i.e. at the end of the enclosing scope. The :ref:`inference <arc.ownership.inference>` rules apply equally to; ``__block`` variables, which is a shift in semantics from non-ARC, where; ``__block`` variables did not implicitly retain during capture. ``__block`` variables of retainable object owner type are moved off the stack; by initializing the heap copy with the result of moving from the stack copy. With the exception of retains done as part of initializing a ``__strong``; parameter variable or reading a ``__weak`` var",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:96027,variab,variable,96027,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['variab'],['variable']
Modifiability,"ample buggy code path to the user. ## Example: refactoring raw pointers to `unique_ptr`. Modern idiomatic C++ uses smart pointers to express memory ownership, however in; pre-C++11 code one can often find raw pointers that own heap memory blocks. Imagine that we would like to refactor raw pointers that own memory to; `unique_ptr`. There are multiple ways to design a data flow analysis for this; problem; let's look at one way to do it. For example, we would like to refactor the following code that uses raw; pointers:. ```c++; void UniqueOwnership1() {; int *pi = new int;; if (...) {; Borrow(pi);; delete pi;; } else {; TakeOwnership(pi);; }; }; ```. into code that uses `unique_ptr`:. ```c++; void UniqueOwnership1() {; auto pi = std::make_unique<int>();; if (...) {; Borrow(pi.get());; } else {; TakeOwnership(pi.release());; }; }; ```. This problem can be solved with a lattice in form of map from value declarations; to pointer states:. ![Lattice that identifies candidates for unique_ptr refactoring](DataFlowAnalysisIntroImages/UniquePtrLattice.svg). We can perform the refactoring if at the exit of a function `pi` is; `Compatible`. ```c++; void UniqueOwnership1() {; int *pi; // pi is Compatible; pi = new int; // pi is Defined; if (...) {; Borrow(pi); // pi is Defined; delete pi; // pi is Compatible; } else {; TakeOwnership(pi); // pi is Compatible; }; // pi is Compatible; }; ```. Let's look at an example where the raw pointer owns two different memory blocks:. ```c++; void UniqueOwnership2() {; int *pi = new int; // pi is Defined; Borrow(pi);; delete pi; // pi is Compatible; if (smth) {; pi = new int; // pi is Defined; Borrow(pi);; delete pi; // pi is Compatible; }; // pi is Compatible; }; ```. It can be refactored to use `unique_ptr` like this:. ```c++; void UniqueOwnership2() {; auto pi = make_unique<int>();; Borrow(pi);; if (smth) {; pi = make_unique<int>();; Borrow(pi);; }; }; ```. In the following example, the raw pointer is used to access the heap object; after the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:22386,refactor,refactoring,22386,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactoring']
Modifiability,"ample, arbitrarily limit; the size of sets to 3 elements. If at a certain program point `x` has more than; 3 possible values, we stop tracking specific values at that program point.; Instead, we denote possible values of `x` with the symbol `⊤` (pronounced ""top""; according to a convention in abstract algebra). ```c++; void ExampleOfTopWithALoop() {; int x = 0; // x is {0}; while (condition()) {; x += 1; // x is ⊤; }; print(x); // x is ⊤; }; ```. The statement ""at this program point, `x`'s possible values are `⊤`"" is; understood as ""at this program point `x` can have any value because we have too; much information, or the information is conflicting"". Note that we can get more than 3 possible values even without a loop:. ```c++; void ExampleOfTopWithoutLoops(int n) {; int x = 0; // x is {0}; switch(n) {; case 0: x = 1; break; // x is {1}; case 1: x = 9; break; // x is {9}; case 2: x = 7; break; // x is {7}; default: x = 3; break; // x is {3}; }; // x is ⊤; }; ```. ### Uninitialized variables and ""bottom"" values. When `x` is declared but not initialized, it has no possible values. We; represent this fact symbolically as `⊥` (pronounced ""bottom""). ```c++; void ExampleOfBottom() {; int x; // x is ⊥; x = 42; // x is {42}; print(x);; }; ```. Note that using values read from uninitialized variables is undefined behaviour; in C++. Generally, compilers and static analysis tools can assume undefined; behavior does not happen. We must model uninitialized variables only when we are; implementing a checker that specifically is trying to find uninitialized reads.; In this example we show how to model uninitialized variables only to demonstrate; the concept of ""bottom"", and how it applies to possible value analysis. We; describe an analysis that finds uninitialized reads in a section below. ### A practical lattice that tracks sets of concrete values. Taking into account all corner cases covered above, we can put together a; lattice that we can use in practice to track possible value",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:5750,variab,variables,5750,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['variab'],['variables']
Modifiability,"ample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4564,variab,variable,4564,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['variab'],['variable']
Modifiability,"an be added or customized by overriding InstrInfo's hook; ``createMIROperandComment()``. Debug-Info constructs; ---------------------. Most of the debugging information in a MIR file is to be found in the metadata; of the embedded module. Within a machine function, that metadata is referred to; by various constructs to describe source locations and variable locations. Source locations; ^^^^^^^^^^^^^^^^. Every MIR instruction may optionally have a trailing reference to a; ``DILocation`` metadata node, after all operands and symbols, but before; memory operands:. .. code-block:: text. $rbp = MOV64rr $rdi, debug-location !12. The source location attachment is synonymous with the ``!dbg`` metadata; attachment in LLVM-IR. The absence of a source location attachment will be; represented by an empty ``DebugLoc`` object in the machine instruction. Fixed variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^. There are several ways of specifying variable locations. The simplest is; describing a variable that is permanently located on the stack. In the stack; or fixedStack attribute of the machine function, the variable, scope, and; any qualifying location modifier are provided:. .. code-block:: text. - { id: 0, name: offset.addr, offset: -24, size: 8, alignment: 8, stack-id: default,; 4 debug-info-variable: '!1', debug-info-expression: '!DIExpression()',; debug-info-location: '!2' }. Where:. - ``debug-info-variable`` identifies a DILocalVariable metadata node,. - ``debug-info-expression`` adds qualifiers to the variable location,. - ``debug-info-location`` identifies a DILocation metadata node. These metadata attributes correspond to the operands of a ``llvm.dbg.declare``; IR intrinsic, see the :ref:`source level debugging<format_common_intrinsics>`; documentation. Varying variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Variables that are not always on the stack or change location are specified; with the ``DBG_VALUE`` meta machine instruction. It is synonymous with the; ``llvm.dbg.valu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:24628,variab,variable,24628,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability,"an check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro3.C; ```. A new element was added on line 4, the size of the canvas: it is; sometimes optically better to show plots in specific canvas sizes. [f42]: figures/polar_graph.png ""f42""; <a name=""f42""></a>. ![The graph of a fan obtained with ROOT.\label{f42}][f42]. ## 2D Graphs ##. Under specific circumstances, it might be useful to plot some quantities; versus two variables, therefore creating a bi-dimensional graph. Of; course ROOT can help you in this task, with the `TGraph2DErrors` class.; The following macro produces a bi-dimensional graph representing a; hypothetical measurement, fits a bi-dimensional function to it and draws; it together with its x and y projections. Some points of the code will; be explained in detail. This time, the graph is populated with data; points using random numbers, introducing a new and very important; ingredient, the ROOT `TRandom3` random number generator using the; Mersenne Twister algorithm [@MersenneTwister]. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro4.C; ```. Let's go through the code, step by step to understand what is going on:. - Line *3*: This sets the palette colour code to a much nicer one than; the default. Comment this line to give it a try.; [This article](https://root.cern/blog/rainbow-color-map/); gives more details about colour map choice. - Line *7*: The instance ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:2368,variab,variables,2368,documentation/primer/graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md,1,['variab'],['variables']
Modifiability,"an promote structs, ""unions"", and arrays in many; cases. All of these properties are easy to satisfy for most imperative; languages, and we'll illustrate it below with Kaleidoscope. The final; question you may be asking is: should I bother with this nonsense for my; front-end? Wouldn't it be better if I just did SSA construction; directly, avoiding use of the mem2reg optimization pass? In short, we; strongly recommend that you use this technique for building SSA form,; unless there is an extremely good reason not to. Using this technique; is:. - Proven and well tested: clang uses this technique; for local mutable variables. As such, the most common clients of LLVM; are using this to handle a bulk of their variables. You can be sure; that bugs are found fast and fixed early.; - Extremely Fast: mem2reg has a number of special cases that make it; fast in common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; =================================. Now that we know the sort of problem we want to tackle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for indu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:9597,variab,variables,9597,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,2,['variab'],['variables']
Modifiability,"an_label dfsan_read_label(const void *addr, size_t size);. /// Returns whether the given label contains the label elem.; int dfsan_has_label(dfsan_label label, dfsan_label elem);. /// Computes the union of \c l1 and \c l2, resulting in a union label.; dfsan_label dfsan_union(dfsan_label l1, dfsan_label l2);. /// Flushes the DFSan shadow, i.e. forgets about all labels currently associated; /// with the application memory. Use this call to start over the taint tracking; /// within the same process.; ///; /// Note: If another thread is working with tainted data during the flush, that; /// taint could still be written to shadow after the flush.; void dfsan_flush(void);. The following functions are provided to check origin tracking status and results. .. code-block:: c. /// Retrieves the immediate origin associated with the given data. The returned; /// origin may point to another origin.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; /// value.; dfsan_origin dfsan_get_origin(long data);. /// Retrieves the very first origin associated with the data at the given; /// address.; dfsan_origin dfsan_get_init_origin(const void *addr);. /// Prints the origin trace of the label at the address `addr` to stderr. It also; /// prints description at the beginning of the trace. If origin tracking is not; /// on, or the address is not labeled, it prints nothing.; void dfsan_print_origin_trace(const void *addr, const char *description);. /// Prints the origin trace of the label at the address `addr` to a pre-allocated; /// output buffer. If origin tracking is not on, or the address is`; /// not labeled, it prints nothing.; ///; /// `addr` is the tainted memory address whose origin we are printing.; /// `description` is a description printed at the beginning of the trace.; /// `out_buf` is t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:3140,extend,extended,3140,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,1,['extend'],['extended']
Modifiability,"anager &MPM,; PassBuilder::OptimizationLevel Level) {; MPM.addPass(FooPass());; };. will add ``FooPass`` near the very beginning of the pipeline for pass; managers created by that ``PassBuilder``. See the documentation for; ``PassBuilder`` for the various places that passes can be added. If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it; will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the; backend to inject passes into the pipeline. Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly; sanitizer) passes to various parts of the pipeline.; ``AMDGPUTargetMachine::registerPassBuilderCallbacks()`` is an example of a; backend adding passes to various parts of the pipeline. Pass plugins can also add passes into default pipelines. Different tools have; different ways of loading dynamic pass plugins. For example, ``opt; -load-pass-plugin=path/to/plugin.so`` loads a pass plugin into ``opt``. For; information on writing a pass plugin, see :doc:`WritingAnLLVMNewPMPass`. Using Analyses; ==============. LLVM provides many analyses that passes can use, such as a dominator tree.; Calculating these can be expensive, so the new pass manager has; infrastructure to cache analyses and reuse them when possible. When a pass runs on some IR, it also receives an analysis manager which it can; query for analyses. Querying for an analysis will cause the manager to check if; it has already computed the result for the requested IR. If it already has and; the result is still valid, it will return that. Otherwise it will construct a; new result by calling the analysis's ``run()`` method, cache it, and return it.; You can also ask the analysis manager to only return an analysis if it's; already cached. The analysis manager only provides analysis results for the same IR type as; what the pass runs on. For example, a function pass receives an analysis; manager that only provides function-level analyses. This works for many; passes wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:6724,plugin,plugin,6724,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['plugin'],['plugin']
Modifiability,"analyzer includes new checks for:; ; Improper instance cleanup up in Objective-C -dealloc methods under manual retain/release.; Inadvertent comparisons of NSNumber, CFNumberRef, and other number object pointers against scalar values.; Unsafe usage of dispatch_once_t predicates stored in Objective-C instance variables and other heap-allocated memory.; Issues resulting from self-assignment in C++.; Incorrect usage of MPI APIs in C and C++. This check can be enabled by passing the following command to scan-build: ;   -enable-checker optin.mpi.MPI-Checker. The scan-build tool now supports a --force-analyze-debug-code flag that forces projects to analyze in debug mode. This flag leaves in assertions and so typically results in fewer false positives.; Additional miscellaneous improvements.; Now requires macOS 10.8 or later. checker-278; built: February 5, 2016; download: checker-278.tar.bz2; highlights:. Greatly improves analysis of C++ lambdas, including interprocedural analysis of lambda applications and reduced 'dead store'; false positives for variables captured by reference.; The analyzer now checks for misuse of 'vfork()'. This check is enabled by default.; The analyzer can now detect excessively-padded structs. This check can be enabled by passing the following; command to scan-build:;   -enable-checker optin.performance.Padding ; The checks to detect misuse of _Nonnull are now enabled by default.; The checks to detect misuse of Objective-C generics are now enabled by default.; Many miscellaneous improvements. checker-277; built: October 28, 2015; download: checker-277.tar.bz2; highlights:. Includes about 20 months of change to Clang itself.; New checker for C++ leaks is turned on by default.; Added various small checks and bug fixes.; Added experimental checkers for Objective-C:. New localizability checks:; ; Checker warning about uses of non-localized NSStrings passed to UI methods expecting localized strings.; Checker warning when the comment argument is missing ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:1223,variab,variables,1223,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['variab'],['variables']
Modifiability,"and all; intermediate stores the uninitialized value went through. Origin; tracking has proved to be very useful for debugging MemorySanitizer; reports. It slows down program execution by a factor of 1.5x-2x on top; of the usual MemorySanitizer slowdown and increases memory overhead. Clang option ``-fsanitize-memory-track-origins=1`` enables a slightly; faster mode when MemorySanitizer collects only allocation points but; not intermediate stores. Use-after-destruction detection; ===============================. MemorySanitizer includes use-after-destruction detection. After invocation of; the destructor, the object will be considered no longer readable, and using; underlying memory will lead to error reports in runtime. Refer to the standard; for `lifetime <https://eel.is/c++draft/basic.life#1>`_ definition. This feature can be disabled with either:. #. Pass addition Clang option ``-fno-sanitize-memory-use-after-dtor`` during; compilation.; #. Set environment variable `MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes any libraries that the program depends on, even libc.; Failing to achieve this may result in false reports.; For the same reason you may need to replace all inline assembly code that writes to memory; with a pure C/C++ code. Full MemorySanitizer instrumentation is very difficult to achieve. To; make it easier, MemorySanitizer runtime library includes 70+; interceptors for the most common libc functions. They make it possible; to run MemorySanitizer-instrumented programs linked with; uninstrumented libc. For example, the authors were able to bootstrap; MemorySanitizer-instrumented Clang compiler by linking it with; self-built instrumented libc++ (as a replacement for libstdc++). Supported Platforms; ===================. MemorySanitizer is supported on the following OS:. * Linux; * NetBSD; * FreeBSD. Limitations; =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:5883,variab,variable,5883,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst,1,['variab'],['variable']
Modifiability,"and backend passes,; ultimately producing a mapping between source-level information and; instruction ranges. This; is relatively straightforwards for line number information, as mapping; instructions to line numbers is a simple association. For variable locations; however the story is more complex. As each ``llvm.dbg.value`` intrinsic; represents a source-level assignment of a value to a source variable, the; variable location intrinsics effectively embed a small imperative program; within the LLVM IR. By the end of CodeGen, this becomes a mapping from each; variable to their machine locations over ranges of instructions.; From IR to object emission, the major transformations which affect variable; location fidelity are:. 1. Instruction Selection; 2. Register allocation; 3. Block layout. each of which are discussed below. In addition, instruction scheduling can; significantly change the ordering of the program, and occurs in a number of; different passes. Some variable locations are not transformed during CodeGen. Stack locations; specified by ``llvm.dbg.declare`` are valid and unchanging for the entire; duration of the function, and are recorded in a simple MachineFunction table.; Location changes in the prologue and epilogue of a function are also ignored:; frame setup and destruction may take several instructions, require a; disproportionate amount of debugging information in the output binary to; describe, and should be stepped over by debuggers anyway. Variable locations in Instruction Selection and MIR; ---------------------------------------------------. Instruction selection creates a MIR function from an IR function, and just as; it transforms ``intermediate`` instructions into machine instructions, so must; ``intermediate`` variable locations become machine variable locations.; Within IR, variable locations are always identified by a Value, but in MIR; there can be different types of variable locations. In addition, some IR; locations become unavailable, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:24979,variab,variable,24979,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"and calculator classes.; Offsetting is a feature of calculation in a fitting context; it enhances numerical precision by subtracting the initial likelihood value from the value that the minimizer sees, thus setting it to zero for the minimizer.; Since this does not impact the derivative terms, it does not affect the fitting result, except for added numerical precision. ## Calculators; `RooFit::TestStatistics` provides two abstract base classes for likelihood calculation: `LikelihoodWrapper` and `LikelihoodGradientWrapper`.; These are used by the `RooAbsMinimizerFcn` implementation `MinuitFcnGrad` which expects them to, respectively, provide likelihood and likelihood gradient values for use by `Minuit2` in fitting the pdf to the dataset. The `Wrapper`s can be implemented for different kinds of algorithms, or with different kinds of optimization ""back-ends"" in mind.; One implementation of each is ready for use in `RooFit` currently:. 1. `LikelihoodSerial` is more or less simply a rewrite of the existing serial calculation of a `RooNLLVar`.; 2. `LikelihoodGradientJob` calculates the partial derivatives or the gradient in parallel on multiple CPUs/cores, based on `RooFit::MultiProcess`, which is a fork-based multi-processing task execution framework with dynamic load balancing. Other possible implementations could use the GPU or external tools like TensorFlow. The coupling of all these classes to `RooMinimizer` is made via the `MinuitFcnGrad` class, which owns the `Wrappers` that calculate the likelihood components. Note: a second `LikelihoodWrapper` class called `LikelihoodJob` is also available.; This class emulates the existing `NumCPU(>1)` functionality of the `RooAbsTestStatistic` tree, which is implemented based on `RooRealMPFE`.; This class is not yet thoroughly tested and should not be considered production ready. ### Usage example: `MultiProcess` enabled parallel gradient calculator. The main selling point of using `RooFit::TestStatistics` from a performance poi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:7132,rewrite,rewrite,7132,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['rewrite'],['rewrite']
Modifiability,"and file on canvas; 8. Support `gStyle.fHistTopMargin` (also as `&histmargin=value` URL parameter); 9. Let save frame, title and stats properties to `gStyle` via correspondent context menus; 10. Support majority of special symbols in TMathText; 11. Fix several issues with TPaveText. ## Changes in 7.0.2; 1. Fix - TH2 arrow drawing; 2. Fix - interactive change of fonts attributes; 3. Fix - proper draw results of TTree::Draw; 4. Fix - draw new histogram on same canvas. ## Changes in 7.0.1; 1. Fix problem with irregular axis labels; 2. Correctly scale and tilt large number of axes labels. ## Changes in 7.0.0; 1. Use ES6 modules for code organization; 2. Rewrite code with ES6 classes; one have to use class syntax to derive from it; 3. Upgrade d3.js to 7.3.0, three.js to r138; 4. Fully remove jQuery and jQueryUI, replace by plain HTML/JavaScript; 5. Remove ""collapsible"" and ""tabs"" layouts which were implemented with jQuery - use ""flex"" instead; 6. Improve flexible layout, provide context menu with cascading, tiling, selecting frames; 7. Use `BigInt` in I/O with 64bit integer which can not be stored as plain `Number`; 8. Starting from Chrome 96, allow embedding WebGL into SVG - solving problem with lego plots in canvas; 9. Implement all variants of CANDLE and VIOLIN draw options (#194); 10. Implement ""circular"" and ""chord"" draw options for TH2; 11. Implement ""cjust"" draw option when drawing color palette; 12. Implement ""colhz"" draw option to plot horizontal color palette; 13. Implement ""pads"" draw option for THStack; 14. In TF1/TF2 always try to use formula, only when fail - apply saved buffer; 15. Add many standard functions to math like ""crystalball_pdf"", ""gaussian_pdf"", ""tdistribution_pdf""; 16. Improve drawing of TEfficiency, support 2D case; 17. Support new TGraphMultiErrors class; 18. Let disable TGraph dragging via `settings.DragGraphs` flag (#224); 19. Correctly display extra data from TGraphQQ; 20. Implement ""3d"" draw options for TMultiGraph; 21. Support ""A"" hist op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:18992,flexible,flexible,18992,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['flexible'],['flexible']
Modifiability,"and ideas for the SystemZ backend.; //===---------------------------------------------------------------------===//. The initial backend is deliberately restricted to z10. We should add support; for later architectures at some point. --. If an inline asm ties an i32 ""r"" result to an i64 input, the input; will be treated as an i32, leaving the upper bits uninitialised.; For example:. define void @f4(i32 *%dst) {; %val = call i32 asm ""blah $0"", ""=r,0"" (i64 103); store i32 %val, i32 *%dst; ret void; }. from CodeGen/SystemZ/asm-09.ll will use LHI rather than LGHI.; to load 103. This seems to be a general target-independent problem. --. The tuning of the choice between LOAD ADDRESS (LA) and addition in; SystemZISelDAGToDAG.cpp is suspect. It should be tweaked based on; performance measurements. --. There is no scheduling support. --. We don't use the BRANCH ON INDEX instructions. --. We only use MVC, XC and CLC for constant-length block operations.; We could extend them to variable-length operations too,; using EXECUTE RELATIVE LONG. MVCIN, MVCLE and CLCLE may be worthwhile too. --. We don't use CUSE or the TRANSLATE family of instructions for string; operations. The TRANSLATE ones are probably more difficult to exploit. --. We don't take full advantage of builtins like fabsl because the calling; conventions require f128s to be returned by invisible reference. --. ADD LOGICAL WITH SIGNED IMMEDIATE could be useful when we need to; produce a carry. SUBTRACT LOGICAL IMMEDIATE could be useful when we; need to produce a borrow. (Note that there are no memory forms of; ADD LOGICAL WITH CARRY and SUBTRACT LOGICAL WITH BORROW, so the high; part of 128-bit memory operations would probably need to be done; via a register.). --. We don't use ICM, STCM, or CLM. --. We don't use ADD (LOGICAL) HIGH, SUBTRACT (LOGICAL) HIGH,; or COMPARE (LOGICAL) HIGH yet. --. DAGCombiner doesn't yet fold truncations of extended loads. Functions like:. unsigned long f (unsigned long x, unsigned short *y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt:1071,extend,extend,1071,interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt,2,"['extend', 'variab']","['extend', 'variable-length']"
Modifiability,"and is added with 123.; Due to framework limitations ``N`` must be 1, in other words,; ``DW_OP_entry_value`` always refers to the value/address operand of the; instruction. Because ``DW_OP_LLVM_entry_value`` is defined in terms of registers, it is; usually used in MIR, but it is also allowed in LLVM IR when targeting a; :ref:`swiftasync <swiftasync>` argument. The operation is introduced by:. - ``LiveDebugValues`` pass, which applies it to function parameters that; are unmodified throughout the function. Support is limited to simple; register location descriptions, or as indirect locations (e.g.,; parameters passed-by-value to a callee via a pointer to a temporary copy; made in the caller).; - ``AsmPrinter`` pass when a call site parameter value; (``DW_AT_call_site_parameter_value``) is represented as entry value of; the parameter.; - ``CoroSplit`` pass, which may move variables from allocas into a; coroutine frame. If the coroutine frame is a; :ref:`swiftasync <swiftasync>` argument, the variable is described with; an ``DW_OP_LLVM_entry_value`` operation. - ``DW_OP_LLVM_arg, N`` is used in debug intrinsics that refer to more than one; value, such as one that calculates the sum of two registers. This is always; used in combination with an ordered list of values, such that; ``DW_OP_LLVM_arg, N`` refers to the ``N``\ :sup:`th` element in that list. For; example, ``!DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus,; DW_OP_stack_value)`` used with the list ``(%reg1, %reg2)`` would evaluate to; ``%reg1 - reg2``. This list of values should be provided by the containing; intrinsic/instruction.; - ``DW_OP_breg`` (or ``DW_OP_bregx``) represents a content on the provided; signed offset of the specified register. The opcode is only generated by the; ``AsmPrinter`` pass to describe call site parameter value which requires an; expression over two registers.; - ``DW_OP_push_object_address`` pushes the address of the object which can then; serve as a descriptor in sub",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:264604,variab,variable,264604,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"and it emphasizes peaks (depending on the averaging; window). The example of the part of original noisy spectrum and Markov; spectrum for `window=3` is given in Figure 3.5 Then the peaks can be found in; Markov spectrum using standard above-presented algorithm. ![Part of original noisy spectrum and Markov spectrum for window=3](figures/image066.png). The form of the generalized peak searching function is as follows:. ```{.cpp}; Int_t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver_window);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into the structure pointed by the; `one_dim_peak` structure pointer. Function parameters:. - **`spectrum`**: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks; - **`threshold`**: threshold value for peaks selection; - **`markov`**: logical variable. If it is set to `true`, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; - **`aver_window`**: averaging window used in the calculation of Markov spectrum, applies only if the `markov` variable was set to `true`. The methods of peak searching are sensitive to the `sigma`. Usually the; `sigma` value is known beforehand. It also changes only slightly with the; energy. We have investigated as well the robustness of the proposed; algorithms to the spectrum with the peaks with `sigma` changing from 1 to; 10 (see Figure 3.6). ![Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10](figures/image068.png). We applied peak searching algorithm based on Markov approach. We changed; `sigma` in the interval from 1 to 10. The spectra for averaging windows 3,; 5, 10 are shown in Figure 3.7. ![Spectra for averaging ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:19992,variab,variable,19992,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['variab'],['variable']
Modifiability,"and line. This particular function will start the VI editor if the; environment variable `EDITOR` is not set. ``` {.cpp}; root[0] edit(""c1.C""); ```. For more details, see `$ROOTSYS/tutorials/rootalias.C`. ### History File. You can use the up and down arrow at the command line, to access the; previous and next command. The commands are recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system.rootrc`; file, by setting the `Rint.History `option. You can also turn off the; command logging in the `system.rootrc` file with the option:; `Rint.History: -`. The number of history lines to be kept can be set also in `.rootrc`; by:. ```; Rint.HistSize: 500; Rint.HistSave: 400; ```. The first value defines the maximum of lines kept; once it is reached; all, the last `HistSave` lines will be removed. One can set `HistSize`; to 0 to disable history line management. There is also implemented an; environment variable called `ROOT_HIST`. By setting; `ROOT_HIST=300:200` the above values can be overriden - the first; value corresponds to `HistSize`, the (optional) second one to; `HistSave`. You can set `ROOT_HIST=0` to disable the history. ### Tracking Memory Leaks. You can track memory usage and detect leaks by monitoring the number; of objects that are created and deleted (see **`TObjectTable`**). To; use this facility, edit the file `$ROOTSYS/etc/system.rootrc` or; `.rootrc` if you have this file and add the two following lines:. ```; Root.ObjectStat: 1; ```. In your code or on the command line you can type the line:. ``` {.cpp}; gObjectTable->Print();; ```. This line will print the list of all active classes and the number of; instances for each class. By comparing consecutive print outs, you can; see objects that you forgot to delete. Note that this method cannot; show leaks coming from the allocation of non-objects or classes; unknown to ROOT. ## Converting from PAW to ROOT. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:39203,variab,variable,39203,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['variab'],['variable']
Modifiability,"and run ``git bisect good`` or ``git bisect bad``. If you can't repro at the current commit (maybe the build is broken), run; ``git bisect skip`` and git will pick a nearby alternate commit. (To abort a bisect, run ``git bisect reset``, and if git complains about not; being able to reset, do the usual ``git checkout -f main; git reset --hard; origin/main`` dance and try again). ``git bisect run``; ==================. A single bisect step often requires first building clang, and then compiling; a large code base with just-built clang. This can take a long time, so it's; good if it can happen completely automatically. ``git bisect run`` can do; this for you if you write a run script that reproduces the problem; automatically. Writing the script can take 10-20 minutes, but it's almost; always worth it -- you can do something else while the bisect runs (such; as writing this document). Here's an example run script. It assumes that you're in ``llvm-project`` and; that you have a sibling ``llvm-build-project`` build directory where you; configured CMake to use Ninja. You have a file ``repro.c`` in the current; directory that makes clang crash at trunk, but it worked fine at revision; ``f00ba``. .. code-block:: bash. # Build clang. If the build fails, `exit 125` causes this; # revision to be skipped; ninja -C ../llvm-build-project clang || exit 125. ../llvm-build-project/bin/clang repro.c. To make sure your run script works, it's a good idea to run ``./run.sh`` by; hand and tweak the script until it works, then run ``git bisect good`` or; ``git bisect bad`` manually once based on the result of the script; (check ``echo $?`` after your script ran), and only then run ``git bisect run; ./run.sh``. Don't forget to mark your run script as executable -- ``git bisect; run`` doesn't check for that, it just assumes the run script failed each time. Once your run script works, run ``git bisect run ./run.sh`` and a few hours; later you'll know which commit caused the regression. (This ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitBisecting.rst:1992,config,configured,1992,interpreter/llvm-project/llvm/docs/GitBisecting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitBisecting.rst,1,['config'],['configured']
Modifiability,"and then; perform another analysis that removes unnecessary `reset()` calls. ```c++; void AddedMemoryOverhead() {; HugeObject *ho = new HugeObject();; use(ho);; delete ho; // Release the large amount of memory quickly.; LongRunningFunction();; }; ```. This analysis will refuse to refactor code that mixes borrowed pointer values; and unique ownership. In the following code, `GetPtr()` returns a borrowed; pointer, which is assigned to `pi`. Then, `pi` is used to hold a uniquely-owned; pointer. We don't distinguish between these two assignments, and we want each; assignment to be paired with a corresponding sink; otherwise, we transition the; pointer to a `Conflicting` state, like in this example. ```c++; void ConflictingOwnership() {; int *pi; // pi is Compatible; pi = GetPtr(); // pi is Defined; Borrow(pi); // pi is Defined. pi = new int; // pi is Conflicting; Borrow(pi);; delete pi;; // pi is Conflicting; }; ```. We could still handle this case by finding a maximal range in the code where; `pi` could be in the Compatible state, and only refactoring that part. ```c++; void ConflictingOwnership() {; int *pi;; pi = GetPtr();; Borrow(pi);. std::unique_ptr<int> pi_unique = std::make_unique<int>();; Borrow(pi_unique.get());; }; ```. ## Example: finding redundant branch conditions. In the code below `b1` should not be checked in both the outer and inner ""if""; statements. It is likely there is a bug in this code. ```c++; int F(bool b1, bool b2) {; if (b1) {; f();; if (b1 && b2) { // Check `b1` again -- unnecessary!; g();; }; }; }; ```. A checker that finds this pattern syntactically is already implemented in; ClangTidy using AST matchers (`bugprone-redundant-branch-condition`). To implement it using the data flow analysis framework, we can produce a warning; if any part of the branch condition is implied by the flow condition. ```c++; int F(bool b1, bool b2) {; // Flow condition: true.; if (b1) {; // Flow condition: b1.; f();; if (b1 && b2) { // `b1` is implied by the flow c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:25611,refactor,refactoring,25611,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactoring']
Modifiability,"and variables:. Options and variables; =====================. Variables customize how the build will be generated. Options are boolean; variables, with possible values ON/OFF. Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; -------------------------------. Here are some of the CMake variables that are used often, along with a; brief explanation. For full documentation, consult the CMake manual,; or execute ``cmake --help-variable VARIABLE_NAME``. See `Frequently; Used LLVM-related Variables`_ below for information about commonly; used variables that control features of LLVM and enabled subprojects. .. _cmake_build_type:. **CMAKE_BUILD_TYPE**:STRING; This configures the optimization level for ``make`` or ``ninja`` builds. Possible values:. =========================== ============= ========== ========== ==========================; Build Type Optimizations Debug Info Assertions Best suited for; =========================== ============= ========== ========== ==========================; **Release** For Speed No No Users of LLVM and Clang; **Debug** None Yes Yes Developers of LLVM; **RelWithDebInfo** For Speed Yes No Users that also need Debug; **MinSizeRel** For Size No No When disk space matters; ===========",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:6549,variab,variables,6549,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"and vice versa.; It can also reduce or remove temporaries, especially for template; expressions.; Thus, there can be significant speedups for mixed code, beyond the Numba; compilation of Python code itself.; The current implementation integrates compiled C++ through function pointers,; object pointers, and pointer offsets, into the intermediate representation; (IR) as generated by Numba.; A future version may integrate Cling-generated IR directly into Numba IR (or; vice versa), e.g. if the C++ code is exposed from (precompiled) headers.; This would allow inlining of C++ code into Numba traces, for further; expected speedups. Why Numba?; ----------. The advertised premise of Numba is that it ""makes Python code fast.""; However, there is a much more compelling reason: Numba allows developers to; stay in their chosen ecosystem, be it Python or C++, in mixed environments,; without paying for their choice in lost performance.; For example, a Python developer using Numba does not need to rewrite a kernel; into C++ just to run performantly in a C++ framework.; Similarly, a C++ developer can use Numba to compile and create function; pointers to Python code for easy, performant, access.; This becomes even more compelling if the deployment target is a GPU, which; would otherwise certainly require a rewrite of the Python code.; Add that Numba, as a JIT-compiler, is fully run-time just like ``cppyy``,; and the use case for integration is clear.; (Numba does not currently provide support for C++.). Usage; -------. ``cppyy`` does not use Numba extension hooks to minimize accidental; dependencies.; Instead, it requires that the extensions are loaded explicitly by any code; that uses it::. import cppyy.numba_ext. After that, Numba is able to trace ``cppyy`` bound code when applying the; usual ``numba.njit`` decorator. Numba type declarations are done lazily, with the ``numba_ext`` module only; initially registering hooks on proxy base classes, to keep overheads in; Numba's type-reso",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:1720,rewrite,rewrite,1720,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['rewrite'],['rewrite']
Modifiability,"and; FP intrinsics rather than rely on overloading. For example, if different; codegen is required for ``llvm.target.foo(<4 x i32>)`` and; ``llvm.target.foo(<4 x float>)`` then these should be split into; different intrinsics. To learn how to add an intrinsic function, please see the `Extending; LLVM Guide <ExtendingLLVM.html>`_. .. _int_varargs:. Variable Argument Handling Intrinsics; -------------------------------------. Variable argument support is defined in LLVM with the; :ref:`va_arg <i_va_arg>` instruction and these three intrinsic; functions. These functions are related to the similarly named macros; defined in the ``<stdarg.h>`` header file. All of these functions operate on arguments that use a target-specific; value type ""``va_list``"". The LLVM assembly language reference manual; does not define what this type is, so all transformations should be; prepared to handle these functions regardless of the type used. This example shows how the :ref:`va_arg <i_va_arg>` instruction and the; variable argument handling intrinsic functions are used. .. code-block:: llvm. ; This struct is different for every platform. For most platforms,; ; it is merely a ptr.; %struct.va_list = type { ptr }. ; For Unix x86_64 platforms, va_list is the following struct:; ; %struct.va_list = type { i32, i32, ptr, ptr }. define i32 @test(i32 %X, ...) {; ; Initialize variable argument processing; %ap = alloca %struct.va_list; call void @llvm.va_start(ptr %ap). ; Read a single integer argument; %tmp = va_arg ptr %ap, i32. ; Demonstrate usage of llvm.va_copy and llvm.va_end; %aq = alloca ptr; call void @llvm.va_copy(ptr %aq, ptr %ap); call void @llvm.va_end(ptr %aq). ; Stop processing of arguments.; call void @llvm.va_end(ptr %ap); ret i32 %tmp; }. declare void @llvm.va_start(ptr); declare void @llvm.va_copy(ptr, ptr); declare void @llvm.va_end(ptr). .. _int_va_start:. '``llvm.va_start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_start(ptr <argl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:492220,variab,variable,492220,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"and; `LLDB development <https://lldb.llvm.org/resources/build.html>`_. 11. Install psutil and obtain LLVM source code:. .. code-block:: bat. pip install psutil; git clone https://github.com/llvm/llvm-project.git llvm. Instead of ``git clone`` you may download a compressed source distribution; from the `releases page <https://github.com/llvm/llvm-project/releases>`_.; Select the last link: ``Source code (zip)`` and unpack the downloaded file using; Windows Explorer built-in zip support or any other unzip tool. 12. Finally, configure LLVM using CMake:. .. code-block:: bat. cmake -S llvm\llvm -B build -DLLVM_ENABLE_PROJECTS=clang -DLLVM_TARGETS_TO_BUILD=X86 -Thost=x64; exit. ``LLVM_ENABLE_PROJECTS`` specifies any additional LLVM projects you want to; build while ``LLVM_TARGETS_TO_BUILD`` selects the compiler targets. If; ``LLVM_TARGETS_TO_BUILD`` is omitted by default all targets are built; slowing compilation and using more disk space.; See the :doc:`LLVM CMake guide <CMake>` for detailed information about; how to configure the LLVM build. The ``cmake`` command line tool is bundled with Visual Studio but its GUI is; not. You may install `CMake <http://www.cmake.org/>`_ to use its GUI to change; CMake variables or modify the above command line. * Once CMake is installed then the simplest way is to just start the; CMake GUI, select the directory where you have LLVM extracted to, and; the default options should all be fine. One option you may really; want to change, regardless of anything else, might be the; ``CMAKE_INSTALL_PREFIX`` setting to select a directory to INSTALL to; once compiling is complete, although installation is not mandatory for; using LLVM. Another important option is ``LLVM_TARGETS_TO_BUILD``,; which controls the LLVM target architectures that are included on the; build.; * CMake generates project files for all build types. To select a specific; build type, use the Configuration manager from the VS IDE or the; ``/property:Configuration`` command line ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:5435,config,configure,5435,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['config'],['configure']
Modifiability,"andler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by declaring a ``ParsedAttrInfo`` and registering; it using ``ParsedAttrInfoRegister::Add<>``:. .. code-block:: c++. class ExampleAttrInfo : public ParsedAttrInfo {; public:; ExampleAttrInfo() {; Spellings.push_back({ParsedAttr::AS_GNU,""example""});; }; AttrHandling handleDeclAttribute(Sema &S, Decl *D,; const ParsedAttr &Attr) const override {; // Handle the attribute; return AttributeApplied;; }; };. static ParsedAttrInfoRegistry::Add<ExampleAttrInfo> Z(""example_attr"",""example attribute description"");. The members of ``ParsedAttrInfo`` that a plugin attribute must define are:. * ``Spellings``, which must be populated with every `Spelling; </doxygen/structclang_1_1ParsedAttrInfo_1_1Spelling.html>`_ of the; attribute, each of which consists of an attribute syntax and how the; attribute name is spelled for that syntax. If the syntax allows a scope then; the spelling must be ""scope::attr"" if a scope is present or ""::attr"" if not.; * ``handleDeclAttribute``, which is the function that applies the attribute to; a declaration. It is responsible for checking that the attribute's arguments; are valid, and typically applies the attribute by adding an ``Attr`` to the; ``Decl``. It returns either ``AttributeApplied``, to indicate that the; attribute was successfully applied, or ``AttributeNotApplied`` if it wasn't. The members of ``ParsedAttrInfo`` that may need to be defined, depending on the; attribute, are:. * ``NumArgs`` and ``OptArgs``, which set the number of required and optional; arguments to the attribute.; * ``diagApperta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:2549,plugin,plugin,2549,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,1,['plugin'],['plugin']
Modifiability,"ands of classes, where this advantage is very; important. `Distributing headers`; ----------------------. cppyy requires C/C++ headers to be available at run-time, which was never a; problem in the developer-centric world from which it originated: software; always had supported C++ APIs already, made available through header files,; and Python simply piggy-backed onto those.; JIT-ing code in those headers, which potentially picked up system headers; that were configured differently, was thus also never a problem.; Or rather, the same problem exists for C++, and configuration for C++ to; resolve potential issues translates transparently to Python. There are only two alternatives: precompile headers into LLVM bitcode and; distribute those or provide a restricted set of headers.; Precompiled headers (and modules) were never designed to be portable and; relocatable, however, thus that may not be the panacea it seems.; A restricted set of headers is some work, but cppyy can operate on abstract; interface classes just fine (including Python-side cross-inheritance). `Large deployment`; ------------------. The single biggest headache in maintaining an installation of Python; extension modules is that Python patch releases can break them.; The two typical solutions are to either restrict the choice of Python; interpreter and version that are supported (common in HPC) or to provide; binaries (wheels) for a large range of different interpreters and versions; (as e.g. done for conda). In the case of cppyy, only CPython/CPyCppyy and PyPy/_cppyy (an internal; module) depend on the Python interpreter (see:; :ref:`Package Structure <package-structure>`).; The user-facing ``cppyy`` module is pure Python and the backend (Cling) is; Python-independent.; Most importantly, since all bindings are generated at run-time, there are no; extension modules to regenerate and/or recompile. Thus, the end-user only needs to rebuild/reinstall CPyCppyy for each relevant; version of Python (and nothin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:10601,inherit,inheritance,10601,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['inherit'],['inheritance']
Modifiability,"andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operands of ``op`` to be the same register,; and don't care exactly which register it is. If ``--enable-var-scope`` is in effect, variables with names that; start with ``$`` are considered to be global. All others variables are; local. All local variables get undefined at the beginning of each; CHECK-LABEL block. Global variables are not affected by CHECK-LABEL.; This makes it easier to ensure that individual tests are not affected; by variables set in preceding tests. FileCheck Numeric Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. :program:`FileCheck` also supports numeric substitution blocks that allow; defining numeric variables and checking for numeric values that satisfy a; numeric expression constraint based on those variables via a numeric; substitution. This allows ``CHECK:`` directives to verify a numeric relation; between two numbers, such as the need for consecutive registers to be used. The syntax to capture a numeric value is; ``[[#%<fmtspec>,<NUMVAR>:]]`` where:. * ``%<fmtspec>,`` is an optional format specifier to indicate what number; format to match and the minimum number of digits to expect. * ``<NUMVAR>:`` is an optional definition of variable ``<NUMVAR>`` from the; captured value. The syntax of ``<fmtspec>`` is: ``#.<precision><conversion specifier>`` where:. * ``#`` is an optional flag available for hex values (see; ``<conversion specifier>`` below) which requir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:27823,variab,variables,27823,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variables']
Modifiability,"ang++""; - ""-c""; - ""/path/to/your/project/foo.cpp""; - ""-o""; - ""/path/to/your/project/foo.o"". ""/path/to/your/project/main.cpp"":; - ""clang++""; - ""-c""; - ""/path/to/your/project/main.cpp""; - ""-o""; - ""/path/to/your/project/main.o"". We'd like to analyze `main.cpp` and discover the division by zero bug.; As we are using On-demand mode, we only need to create a CTU index file which holds the `USR` name and location of; external definitions in the source files in format `<USR-Length>:<USR> <File-Path>`:. .. code-block:: bash. $ clang-extdef-mapping -p . foo.cpp; 9:c:@F@foo# /path/to/your/project/foo.cpp; $ clang-extdef-mapping -p . foo.cpp > externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-config -Xclang ctu-invocation-list=invocations.yaml \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.cpp main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp main.cpp reports/; $ tree reports; reports; ├── compile_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:9510,config,config,9510,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,1,['config'],['config']
Modifiability,ang-tools-extra/clang-tidy/performance/NoAutomaticMoveCheck.cpp; clang-tools-extra/clang-tidy/performance/NoAutomaticMoveCheck.h; clang-tools-extra/clang-tidy/performance/NoexceptMoveConstructorCheck.cpp; clang-tools-extra/clang-tidy/performance/NoexceptMoveConstructorCheck.h; clang-tools-extra/clang-tidy/performance/NoIntToPtrCheck.cpp; clang-tools-extra/clang-tidy/performance/NoIntToPtrCheck.h; clang-tools-extra/clang-tidy/performance/PerformanceTidyModule.cpp; clang-tools-extra/clang-tidy/performance/TriviallyDestructibleCheck.cpp; clang-tools-extra/clang-tidy/performance/TriviallyDestructibleCheck.h; clang-tools-extra/clang-tidy/performance/TypePromotionInMathFnCheck.cpp; clang-tools-extra/clang-tidy/performance/TypePromotionInMathFnCheck.h; clang-tools-extra/clang-tidy/performance/UnnecessaryCopyInitialization.cpp; clang-tools-extra/clang-tidy/performance/UnnecessaryValueParamCheck.cpp; clang-tools-extra/clang-tidy/performance/UnnecessaryValueParamCheck.h; clang-tools-extra/clang-tidy/plugin/ClangTidyPlugin.cpp; clang-tools-extra/clang-tidy/portability/PortabilityTidyModule.cpp; clang-tools-extra/clang-tidy/portability/RestrictSystemIncludesCheck.cpp; clang-tools-extra/clang-tidy/portability/SIMDIntrinsicsCheck.cpp; clang-tools-extra/clang-tidy/readability/AvoidConstParamsInDecls.h; clang-tools-extra/clang-tidy/readability/BracesAroundStatementsCheck.cpp; clang-tools-extra/clang-tidy/readability/BracesAroundStatementsCheck.h; clang-tools-extra/clang-tidy/readability/ConstReturnTypeCheck.cpp; clang-tools-extra/clang-tidy/readability/ContainerContainsCheck.cpp; clang-tools-extra/clang-tidy/readability/ContainerContainsCheck.h; clang-tools-extra/clang-tidy/readability/ContainerDataPointerCheck.cpp; clang-tools-extra/clang-tidy/readability/ContainerDataPointerCheck.h; clang-tools-extra/clang-tidy/readability/ContainerSizeEmptyCheck.h; clang-tools-extra/clang-tidy/readability/ConvertMemberFunctionsToStatic.cpp; clang-tools-extra/clang-tidy/readability/ConvertMemberFu,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:66385,plugin,plugin,66385,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugin']
Modifiability,ang-tools-extra/clangd/index/dex/Trigram.cpp; clang-tools-extra/clangd/index/dex/Trigram.h; clang-tools-extra/clangd/index/dex/dexp/Dexp.cpp; clang-tools-extra/clangd/index/remote/Client.cpp; clang-tools-extra/clangd/index/remote/Client.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/support/Function.h; clang-tools-extra/clangd/support/Logger.cpp; clang-tools-extra/clangd/support/Markup.cpp; clang-tools-extra/clangd/support/Markup.h; clang-tools-extra/clangd/support/MemoryTree.cpp; clang-tools-extra/cla,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80386,refactor,refactor,80386,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,ang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/support/Function.h; clang-tools-extra/clangd/support/Logger.cpp; clang-tools-extra/clangd/support/Markup.cpp; clang-tools-extra/clangd/support/Markup.h; clang-tools-extra/clangd/support/MemoryTree.cpp; clang-tools-extra/clangd/support/MemoryTree.h; clang-tools-extra/clangd/support/Path.cpp; clang-tools-extra/clangd/support/Path.h; clang-tools-extra/clangd/support/Shutdown.cpp; clang-tools-extra/clangd/support/Shutdown.h; clang-tools-extra/clangd/support/ThreadCrashReporter.cpp; clang-tools-extra/clangd/support/ThreadCrashReporter.h; clang-tools-extra/clangd/support/Threading.cpp; clang-tools-extra/clangd/support/Threading.h; clang-tools-extra/clang,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80818,refactor,refactor,80818,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"ang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/includ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5306,plugin,plugins,5306,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,3,['plugin'],"['plugin', 'plugins']"
Modifiability,"ang; if (MSVC_VERSION GREATER_EQUAL 1924 AND MSVC_VERSION LESS 1929); string(REPLACE ""-O2"" ""-O1 -Oi"" CMAKE_CXX_FLAGS_RELEASE ""${CMAKE_CXX_FLAGS_RELEASE}""); string(REPLACE ""-O2"" ""-O1 -Oi"" CMAKE_CXX_FLAGS_RELWITHDEBINFO ""${CMAKE_CXX_FLAGS_RELWITHDEBINFO}""); endif(); # replace dashes in the -EH* and -GR* flags with slashes (/EH* /GR*); string(REPLACE "" -EH"" "" /EH"" CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS}""); string(REPLACE "" -GR"" "" /GR"" CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS}""); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} /ignore:4049,4206,4217,4221""); set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHARED_LINKER_FLAGS} /ignore:4049,4206,4217,4221""); set(CMAKE_MODULE_LINKER_FLAGS ""${CMAKE_MODULE_LINKER_FLAGS} /ignore:4049,4206,4217,4221""); endif(). set(LLVM_TARGETS_TO_BUILD ${ROOT_CLING_TARGET} CACHE STRING ""Semicolon-separated list of targets to build, or \""all\"".""). if(clingtest); message(""-- cling test suite enabled: llvm / clang symbols in libCling will be visible!""); set(CLING_INCLUDE_TESTS ON CACHE BOOL """" FORCE); # The path to cling passed through environment variable only relevant when building; # against external llvm. In that case, cling's testsuite cannot deduce the binary; # of cling relatively to the llvm tools folder.; if (NOT builtin_llvm); set(CLINGTEST_EXECUTABLE CLING=${CMAKE_CURRENT_BINARY_DIR}/llvm-project/llvm/${CMAKE_CFG_INTDIR}/bin/cling); endif(); ROOT_ADD_TEST(clingtest-check-cling COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target check-cling; ENVIRONMENT ${CLINGTEST_EXECUTABLE}); else(); #---Build LLVM/Clang with symbol visibility=hidden--------------------------------------------------; set(CMAKE_CXX_VISIBILITY_PRESET hidden); set(CMAKE_C_VISIBILITY_PRESET hidden); endif(); if (NOT MSVC AND NOT APPLE); # Requires the linker to resolve the symbol internally and prevents; # conflicts when linked with another software using also LLVM like in; # the problem reported for Julia in; # https://github.com/JuliaHEP/ROOT.jl/issues/17#issuecomment-8827",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:6570,variab,variable,6570,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['variab'],['variable']
Modifiability,"angInterpreter`` library. To automatically print the value of an expression, simply write the expression; in the global scope **without a semicolon**. .. graphviz::; :name: automaticprintf; :caption: Automatic PrintF; :alt: Shows how Automatic PrintF can be used; :align: center. digraph ""AutomaticPrintF"" {; size=""6,4"";; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. manual [label="" Manual PrintF "", shape=""box""];; int1 [label="" int ( &) 42 "", shape=""box""]; auto [label="" Automatic PrintF "", shape=""box""];; int2 [label="" int ( &) 42 "", shape=""box""]. auto -> int2 [label=""int x = 42; \n x""];; manual -> int1 [label=""int x = 42; \n printf(&quot;(int &) %d \\n&quot;, x);""];; }. Significance of this feature; ----------------------------. Inspired by a similar implementation in `Cling <https://github.com/root-project/cling>`_,; this feature added to upstream Clang repo has essentially extended the syntax of; C++, so that it can be more helpful for people that are writing code for data; science applications. This is useful, for example, when you want to experiment with a set of values; against a set of functions, and you'd like to know the results right away.; This is similar to how Python works (hence its popularity in data science; research), but the superior performance of C++, along with this flexibility; makes it a more attractive option. Implementation Details; ======================. Parsing mechanism:; ------------------. The Interpreter in Clang-Repl (``Interpreter.cpp``) includes the function; ``ParseAndExecute()`` that can accept a 'Value' parameter to capture the result.; But if the value parameter is made optional and it is omitted (i.e., that the; user does not want to utilize it elsewhere), then the last value can be; validated and pushed into the ``dump()`` function. .. graphviz::; :name: parsing; :caption: Parsing Mechanism; :alt: Shows the Parsing Mechanism for Pretty",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:15216,extend,extended,15216,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['extend'],['extended']
Modifiability,"anging *all* of ``foo`` (or its base region) will; *definitely* change ``foo[i]``. This logic could be improved by using the current constraints on ``i``, at the; cost of speed. The latter case could also be improved by matching region kinds,; i.e. changing ``foo[0].a`` is unlikely to affect ``foo[i].b``, no matter what; ``i`` is. For more detail, read through ``RegionStoreManager::removeSubRegionBindings`` in; RegionStore.cpp. ObjCIvarRegions; ---------------. Objective-C instance variables require a bit of special handling. Like struct; fields, they are not base regions, and when their parent object region is; invalidated, all the instance variables must be invalidated as well. However,; they have no concrete compile-time offsets (in the modern, ""non-fragile""; runtime), and so cannot easily be represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Consequently, although the base region of an ObjCIvarRegion is the entire; object, RegionStore offsets are computed from the start of the instance; variable. Thus it is not valid to assume that all bindings with non-symbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the entire; contents of a region may have changed---say, because it has been passed to a; function the analyzer can model, like memcpy, or because its address has; escaped, usually as an argument to an opaque function call. In these cases we; need to throw away not just all bindings within the region itself, but within; its entire cluster, since neighboring regions may be accessed via pointer; arithmetic. Region invalidation typically does even more than this, however. Because it; usually represents the co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:3131,variab,variable,3131,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,2,['variab'],['variable']
Modifiability,"antage of this trick, we need; to talk about how LLVM represents stack variables. In LLVM, all memory accesses are explicit with load/store instructions,; and it is carefully designed not to have (or need) an ""address-of""; operator. Notice how the type of the @G/@H global variables is actually; ""i32\*"" even though the variable is defined as ""i32"". What this means is; that @G defines *space* for an i32 in the global data area, but its; *name* actually refers to the address for that space. Stack variables; work the same way, except that instead of being declared with global; variable definitions, they are declared with the `LLVM alloca; instruction <../../LangRef.html#alloca-instruction>`_:. .. code-block:: llvm. define i32 @example() {; entry:; %X = alloca i32 ; type of %X is i32*.; ...; %tmp = load i32, i32* %X ; load the stack value %X from the stack.; %tmp2 = add i32 %tmp, 1 ; increment it; store i32 %tmp2, i32* %X ; store it back; ... This code shows an example of how you can declare and manipulate a stack; variable in the LLVM IR. Stack memory allocated with the alloca; instruction is fully general: you can pass the address of the stack slot; to functions, you can store it in other variables, etc. In our example; above, we could rewrite the example to use the alloca technique to avoid; using a PHI node:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; %X = alloca i32 ; type of %X is i32*.; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; store i32 %X.0, i32* %X ; Update X; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; store i32 %X.1, i32* %X ; Update X; br label %cond_next. cond_next:; %X.2 = load i32, i32* %X ; Read X; ret i32 %X.2; }. With this, we have discovered a way to handle arbitrary mutable; variables without the need to create Phi nodes at all:. #. Each mutable variable becomes a stack alloc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:5271,variab,variable,5271,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"anteed to be aligned to at least that boundary. The; alignment may not be greater than ``1 << 32``. The alignment is only optional when parsing textual IR; for in-memory IR,; it is always present. If not specified, the target can choose to align the; allocation on any convenient boundary compatible with the type. '``type``' may be any sized type. Structs containing scalable vectors cannot be used in allocas unless all; fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>,; <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>,; <vscale x 2 x i64>}`` doesn't). Semantics:; """""""""""""""""""". Memory is allocated; a pointer is returned. The allocated memory is; uninitialized, and loading from uninitialized memory produces an undefined; value. The operation itself is undefined if there is insufficient stack; space for the allocation.'``alloca``'d memory is automatically released; when the function returns. The '``alloca``' instruction is commonly used; to represent automatic variables that must have an address available. When; the function returns (either with the ``ret`` or ``resume`` instructions),; the memory is reclaimed. Allocating zero bytes is legal, but the returned; pointer may not be unique. The order in which memory is allocated (ie.,; which way the stack grows) is not specified. Note that '``alloca``' outside of the alloca address space from the; :ref:`datalayout string<langref_datalayout>` is meaningful only if the; target has assigned it a semantics. If the returned pointer is used by :ref:`llvm.lifetime.start <int_lifestart>`,; the returned object is initially dead.; See :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` for the precise semantics of; lifetime-manipulating intrinsics. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; %ptr = alloca i32, i32 4 ; yields ptr; %ptr = alloca i32, i32 4, align 1024 ; yields ptr; %ptr = alloca i32, align 1024 ; yields ptr. .. _i_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:410828,variab,variables,410828,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"anvas to the ROOT file you can use either; **`TObject::Write()` or `TDirectory`**`::WriteTObject()`. The example:. ``` {.cpp}; root[] c1->Write(); ```. This is equivalent to:. ``` {.cpp}; root[] f->WriteTObject(c1); ```. For objects that do not inherit from **`TObject`** use:. ``` {.cpp}; root[] f->WriteObject(ptr,""nameofobject""); ```. ***`Another example:`***. ``` {.cpp}; root[] TFile *f = new TFile(""hsimple.root"",""UPDATE""); root[] hpx->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] c1->Write(); root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TH1F hpx This is the px distribution : 0; KEY: TH1F hpx;2 This is the px distribution; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;2 Profile of pz versus px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; KEY: TCanvas c1;1 c1; ```. ### Saving Collections to Disk. All collection classes inherit from **`TCollection`** and hence inherit; the **`TCollection::Write()` method. When you call; `TCollection`**`::Write()` each object in the container is written; individually into its own key in the file. To write all objects into one; key you can specify the name of the key and use the; option` TObject::kSingleKey`. For example:. ``` {.cpp}; root[] TList * list = new TList;; root[] TNamed * n1, * n2;; root[] n1 = new TNamed(""name1"",""title1"");; root[] n2 = new TNamed(""name2"",""title2"");; root[] list->Add(n1);; root[] list->Add(n2);; root[] gFile->WriteObject(list,""list"",TObject::kSingleKey);; ```. ### A TFile Object Going Out of Scope. There is another important point to remember about `TFile::Close` and; **`TFile::Write`**. When a variable is declared on the stack in a function; such as in the code below, it will be deleted when it goes out of; scope. ``` {.cpp}; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; ```. As soon as the function `foo `has finished executing, the variable `f`; is deleted. When a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:34311,inherit,inherit,34311,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,2,['inherit'],['inherit']
Modifiability,"any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=ON` now switches the default value of all optional packages to `ON`; - The options `astiff`, `cling`, `pch`, `thread`, and `explicitlink` have been; removed and are now ignored. They either had no effect (their value was not; being used in the build system), or could not be disabled (like `cling` and; `explicitlink`).; - ROOT library targets now export which C++ standard they were built with via; the target compile features `cxx_std_11`, `cxx_std_14`, and `cxx_std_17`.; - The file `RootNewMacros.cmake` has been renamed to `RootMacros.cmake`.; Including the old file by name is deprecated and will generate a warning.; Including `RootMacros.cmake` is not necessary, as now it is already included; when calling `find_package(ROOT)`. If you still need to inherit ROOT's compile; options, however, you may use `include(${ROOT_USE_FILE})` as before.; - ROOT's internal CMake modules (e.g. CheckCompiler.cmake, SetUpLinux.cmake, etc); are no longer installed with `make install`. Only the necessary files by; dependent projects are installed by default now, and they are installed; directly into the cmake/ directory, not cmake/modules/ as before.; - The macro `ROOT_GENERATE_DICTIONARY()` can now attach the generated source; file directly to a library target by using the option `MODULE <library>`, where; `<library>` is an existing library target. This allows the dictionary to inherit; target properties such as compile options and include directories from the library; target, even when they are added after the call to `ROOT_GENERATE_DICTIONARY()`.; - The macros `REFLEX_GENERATE_DICTIONARY()` and `ROOT_GENERATE_DICTIONARY()` can; now have custom extra dependencies added with the options `DEPENDS` and; `EXTRA_DEPENDENCIES`, respectively. The following builtins have been updated:. - FFTW3 3.3.8; - GSL 2.5; - Intel TBB 2019 U8; - PCRE 8.43; - OpenSSL 1.0.2s; - Vdt 0.4.3; - VecCore 0.6.0; - XRootD 4.10.0; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:9495,inherit,inherit,9495,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['inherit'],['inherit']
Modifiability,"any problem. This is called **overriding**; a method. Draw in **`TArrow`** overrides Draw in **`TLine`**. There is; no possible ambiguity since, when one calls the `Draw()` method; this; applies to an object whose type is known. Suppose we have an object; `l` of type **`TLine`** and an object `a` of type **`TArrow`**. When; you want to draw the line, you do:. ``` {.cpp}; l.Draw();; ```. `Draw()` from **`TLine`** is called. If you do:. ``` {.cpp}; a.Draw();; ```. `Draw()` from **`TArrow`** is called and the arrow `a` is drawn. ### Data Encapsulation. We have seen previously the keyword ""`public`"". This keyword means; that every name declared public is seen by the outside world. This is; opposed to ""`private`"" that means only the class where the name was; declared private could see this name. For example, suppose we declare; in **`TArrow`** the variable `ArrowHeadSize` private. ``` {.cpp}; private:; int ArrowHeadSize;; ```. Then, only the methods (i.e. member functions) of **`TArrow`** will be; able to access this variable. Nobody else will see it. Even the; classes that we could derive from **`TArrow`** will not see it. On the; other hand, if we declare the method `Draw()` as public, everybody will; be able to see it and use it. You see that the character public or; private does not depend of the type of argument. It can be a data; member, a member function, or even a class. For example, in the case; of **`TArrow`**, the base class **`TLine`** is declared as public:. ``` {.cpp}; class TArrow : public TLine { ...; ```. This means that all methods of **`TArrow`** will be able to access all; methods of **`TLine`**, but this will be also true for anybody in the; outside world. Of course, this is true if **`TLine`** accepts the; outside world to see its methods/data members. If something is; declared private in **`TLine`**, nobody will see it, not even; **`TArrow`** members, even if **`TLine`** is declared as a public; base class. What if **`TLine`** is declared ""`private`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:4356,variab,variable,4356,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['variab'],['variable']
Modifiability,"apEnd* options may be repeated as needed. Syntax:; ``.cv_def_range`` *RangeStart RangeEnd* [ *GapStart GapEnd* ] ``,`` *bytes*. ``.cv_stringtable`` Directive; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``.cv_filechecksums`` Directive; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``.cv_filechecksumoffset`` Directive; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Syntax:; ``.cv_filechecksumoffset`` *FileNumber*. ``.cv_fpo_data`` Directive; ^^^^^^^^^^^^^^^^^^^^^^^^^^; Syntax:; ``.cv_fpo_data`` *procsym*. Target Specific Behaviour; =========================. X86; ---. Relocations; ^^^^^^^^^^^. **@ABS8** can be applied to symbols which appear as immediate operands to; instructions that have an 8-bit immediate form for that operand. It causes; the assembler to use the 8-bit form and an 8-bit relocation (e.g. ``R_386_8``; or ``R_X86_64_8``) for the symbol. For example:. .. code-block:: gas. cmpq $foo@ABS8, %rdi. This causes the assembler to select the form of the 64-bit ``cmpq`` instruction; that takes an 8-bit immediate operand that is sign extended to 64 bits, as; opposed to ``cmpq $foo, %rdi`` which takes a 32-bit immediate operand. This; is also not the same as ``cmpb $foo, %dil``, which is an 8-bit comparison. **@GOTPCREL_NORELAX** can be used in place of ``@GOTPCREL`` to guarantee that; the assembler emits an ``R_X86_64_GOTPCREL`` relocation instead of a relaxable; ``R_X86_64[_REX]_GOTPCRELX`` relocation. Windows on ARM; --------------. Stack Probe Emission; ^^^^^^^^^^^^^^^^^^^^. The reference implementation (Microsoft Visual Studio 2012) emits stack probes; in the following fashion:. .. code-block:: gas. movw r4, #constant; bl __chkstk; sub.w sp, sp, r4. However, this has the limitation of 32 MiB (±16MiB). In order to accommodate; larger binaries, LLVM supports the use of ``-mcmodel=large`` to allow a 4GiB; range via a slight deviation. It will generate an indirect jump as follows:. .. code-block:: gas. movw r4, #constant; movw r12, :lower16:__chkstk; movt r12, :upper16:__chkstk; blx r12; sub.w sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst:21391,extend,extended,21391,interpreter/llvm-project/llvm/docs/Extensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst,1,['extend'],['extended']
Modifiability,"ape; surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to; provide navigation functionality. In addition to those, shapes have also; to implement additional specific abstract methods:. - Computation of the minimal box bounding the shape, given that this; box have to be aligned with the local coordinates;; - Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will; call `primitives`. It also provides a special class allowing the; creation of shapes as a result of Boolean operations between primitives.; These are called `composite shapes` and the composition operation can be; recursive (combined composites). This allows the creation of a quite; large number of different shape topologies and combinations. You can; have a look and run the tutorial:; <http://root.cern.ch/root/html/examples/geodemo.C.html>. ![Primitive Shapes - the general inheritance scheme](pictures/030001B5.png). Shapes are named objects and all primitives have constructors like:. ``` {.cpp}; TGeoXXX(const char *name,<type> param1,<type> param2, ...);; TGeoXXX(<type> param1,<type> param2, ...);; ```. Naming shape primitive is mandatory only for the primitives used in; Boolean composites (see ""Composite Shapes""). For the sake of simplicity,; we will describe only the constructors in the second form. ### Units. The length units used in the geometry are **arbitrary**. However, there; are certain functionalities that work with the assumption that the used; lengths are expressed in centimeters. This is the case for shape; capacity or volume weight computation. The same is valid when using the; ROOT geometry as navigator for an external transport MC package (e.g.; GEANT) via the VMC interface. Other units in use: All angles used for defining rotation matrices or; some shape parameters are expressed in **degrees**. Material density is; expressed in [**g/cm3**]",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:24834,inherit,inheritance,24834,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['inherit'],['inheritance']
Modifiability,"apedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:21548,config,configuration,21548,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"aphivz package.; This package can be downloaded from; http://www.graphviz.org/. At installation time, to find graphviz, the ROOT's configure file looks in; standard locations. It is possible to define a specific location using the; configure flags:. --with-gviz-incdir=""the directory where gvc.h is""; --with-gviz-libdir=""the directory where the libgvc library is"". To install graphviz (if needed) it is recommended to use the following configure flags:. --enable-static=yes --enable-shared=no --with-pic --prefix=""graphviz installed here"". On 64 bits machines, the ROOT sources are compiled with the option -m64. In; that case graphviz should be also compiled in 64 bits mode. It might be the; default option, but on some machine it is not. In that case the environment; variable CC should be defined as:. CC=""gcc -m64"". before doing configure. On Windows machines it recommended to not install graphviz but to download the; pre-installed version from http://www.graphviz.org/. The ROOT configure command; remains the same.; Graphics Primitives; New class TGraphTime; TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax.; each time step has a new list of objects. This list can be identical to; the list of objects in the previous steps, but with different attributes.; see example of use in $ROOTSYS/tutorials/graphs/gtime.C. TLatex. In the following macro the #int and #sum symbols had; wrong limits placement if the character just before started with ""#"".; ; {; TCanvas *c1 = new TCanvas(""c1"",""c1"",500,500);; TLatex l;; l.SetTextSize(0.1);. l.DrawLatex(0.1,0.6,""#nu#int^{1-x}_{2#pi}"");; l.DrawLatex(0.1,0.2,""a#int^{1-x}_{2#pi}"");. l.DrawLatex(0.5,0.6,""#nu#sum^{1-x}_{2#pi}"");; l.DrawLatex(0.5,0.2,""a#sum^{1-x}_{2#pi}"");; }; . This problem is there since the 1st version of TLatex. It is fixed by:; ; Giving ""^"" and ""_"" a lower precedence than special and greek characters.; Making a special case for #int and #sum and giving them even; lower precedence t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html:4338,config,configure,4338,graf2d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html,1,['config'],['configure']
Modifiability,"apping the; wide pointers to struct types with equivalent layout won’t be sufficient. To; represent the wide pointers in Clang AST, we add an extra field in the; PointerType class to indicate the internal bounds of the pointer. This ensures; pointers of different representations are mapped to different canonical types; while they are still treated as pointers. In LLVM IR, wide pointers will be emitted as structs of equivalent; representations. Clang CodeGen will handle them as Aggregate in; ``TypeEvaluationKind (TEK)``. ``AggExprEmitter`` was extended to handle pointer; operations returning wide pointers. Alternatively, a new ``TEK`` and an; expression emitter dedicated to wide pointers could be introduced. Default bounds annotations; ==========================. The model may implicitly add ``__bidi_indexable`` or ``__single`` depending on; the context of the declaration that has the pointer type. ``__bidi_indexable``; implicitly adds to local variables, while ``__single`` implicitly adds to; pointer types specifying struct fields, function parameters, or global; variables. This means the parser may first create the pointer type without any; default pointer attribute and then recreate the type once the parser has the; declaration context and determined the default attribute accordingly. This also requires the parser to reset the type of the declaration with the; newly created type with the right default attribute. Promotion expression; ====================. A new expression will be introduced to represent the conversion from a pointer; with an external bounds annotation, such as ``__counted_by``, to; ``__bidi_indexable``. This type of conversion cannot be handled by normal; CastExprs because it requires an extra subexpression(s) to provide the bounds; information necessary to create a wide pointer. Bounds check expression; =======================. Bounds checks are part of semantics defined in the ``-fbounds-safety`` language; model. Hence, exposing the bounds check",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:3681,variab,variables,3681,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,2,['variab'],['variables']
Modifiability,"approaches to; Just In Time (JIT) compilation.; `Kaleidoscope Tutorial for complete beginner; <https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html>`_. - BuildingAJIT: Examples of the `BuildingAJIT tutorial; <https://llvm.org/docs/tutorial/BuildingAJIT1.html>`_ that shows how LLVM’s; ORC JIT APIs interact with other parts of LLVM. It also, teaches how to; recombine them to build a custom JIT that is suited to your use-case. ``llvm/include``; ----------------. Public header files exported from the LLVM library. The three main subdirectories:. ``llvm/include/llvm``. All LLVM-specific header files, and subdirectories for different portions of; LLVM: ``Analysis``, ``CodeGen``, ``Target``, ``Transforms``, etc... ``llvm/include/llvm/Support``. Generic support libraries provided with LLVM but not necessarily specific to; LLVM. For example, some C++ STL utilities and a Command Line option processing; library store header files here. ``llvm/include/llvm/Config``. Header files configured by ``cmake``. They wrap ""standard"" UNIX and; C header files. Source code can include these header files which; automatically take care of the conditional #includes that ``cmake``; generates. ``llvm/lib``; ------------. Most source files are here. By putting code in libraries, LLVM makes it easy to; share code among the `tools`_. ``llvm/lib/IR/``. Core LLVM source files that implement core classes like Instruction and; BasicBlock. ``llvm/lib/AsmParser/``. Source code for the LLVM assembly language parser library. ``llvm/lib/Bitcode/``. Code for reading and writing bitcode. ``llvm/lib/Analysis/``. A variety of program analyses, such as Call Graphs, Induction Variables,; Natural Loop Identification, etc. ``llvm/lib/Transforms/``. IR-to-IR program transformations, such as Aggressive Dead Code Elimination,; Sparse Conditional Constant Propagation, Inlining, Loop Invariant Code Motion,; Dead Global Elimination, and many others. ``llvm/lib/Target/``. Files describing target architecture",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:35865,config,configured,35865,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configured']
Modifiability,"ar"" `TokIdentifier` ""="" `Value` "";""; :| `Assert`. A field definition in the body specifies a field to be included in the class; or record. If no initial value is specified, then the field's value is; uninitialized. The type must be specified; TableGen will not infer it from; the value. The keyword ``code`` may be used to emphasize that the field; has a string value that is code. The ``let`` form is used to reset a field to a new value. This can be done; for fields defined directly in the body or fields inherited from parent; classes. A :token:`RangeList` can be specified to reset certain bits in a; ``bit<n>`` field. The ``defvar`` form defines a variable whose value can be used in other; value expressions within the body. The variable is not a field: it does not; become a field of the class or record being defined. Variables are provided; to hold temporary values while processing the body. See `Defvar in a Record; Body`_ for more details. When class ``C2`` inherits from class ``C1``, it acquires all the field; definitions of ``C1``. As those definitions are merged into class ``C2``, any; template arguments passed to ``C1`` by ``C2`` are substituted into the; definitions. In other words, the abstract record fields defined by ``C1`` are; expanded with the template arguments before being merged into ``C2``. .. _def:. ``def`` --- define a concrete record; ------------------------------------. A ``def`` statement defines a new concrete record. .. productionlist::; Def: ""def"" [`NameValue`] `RecordBody`; NameValue: `Value` (parsed in a special mode). The name value is optional. If specified, it is parsed in a special mode; where undefined (unrecognized) identifiers are interpreted as literal; strings. In particular, global identifiers are considered unrecognized.; These include global variables defined by ``defvar`` and ``defset``. A; record name can be the null string. If no name value is given, the record is *anonymous*. The final name of an; anonymous record is unspecif",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:27046,inherit,inherits,27046,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherits']
Modifiability,"arDecl(isAtPosition(0))`` matches ``int a``. ``parmVarDecl(isAtPosition(1))`` matches ``int b``. Matcher<QualType>asStringstd::string Name; Matches if the matched type is represented by the given string. Given; class Y { public: void x(); };; void z() { Y* y; y->x(); }; cxxMemberCallExpr(on(hasType(asString(""class Y *"")))); matches y->x(). Matcher<QualType>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<QualType>hasLocalQualifiers; Matches QualType nodes that have local CV-qualifiers attached to; the node, not hidden within a typedef. Given; typedef const int const_int;; const_int i;; int *const j;; int *volatile k;; int m;; varDecl(hasType(hasLocalQualifiers())) matches only j and k.; i is const-qualified but the qualifier is not local. Matcher<QualType>isAnyCharacter; Matches QualType nodes that are of character type. Given; void a(char);; void b(wchar_t);; void c(double);; functionDecl(hasAnyParameter(hasType(isAnyCharacter()))); matches ""a(char)"", ""b(wchar_t)"", but not ""c(double)"". Matcher<QualType>isAnyPointer; Matches QualType nodes that are of any pointer type; this includes; the Objective-C object pointer type, which is different despite being; syntactically similar. Given; int *i = nullptr;. @interface Foo; @end; Foo *f;. int j;; varDecl(hasType(isAnyPointer())",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:111582,variab,variable,111582,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"arName"")))))),; hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(ignoringParenImpCasts(declRefExpr(; to(varDecl(hasType(isInteger())).bind(""condVarName""))))),; hasRHS(expr(hasType(isInteger())))))).bind(""forLoop"");. And change ``LoopPrinter::run`` to. .. code-block:: c++. void LoopPrinter::run(const MatchFinder::MatchResult &Result) {; ASTContext *Context = Result.Context;; const ForStmt *FS = Result.Nodes.getNodeAs<ForStmt>(""forLoop"");; // We do not want to convert header files!; if (!FS || !Context->getSourceManager().isWrittenInMainFile(FS->getForLoc())); return;; const VarDecl *IncVar = Result.Nodes.getNodeAs<VarDecl>(""incVarName"");; const VarDecl *CondVar = Result.Nodes.getNodeAs<VarDecl>(""condVarName"");; const VarDecl *InitVar = Result.Nodes.getNodeAs<VarDecl>(""initVarName"");. if (!areSameVariable(IncVar, CondVar) || !areSameVariable(IncVar, InitVar)); return;; llvm::outs() << ""Potential array-based loop discovered.\n"";; }. Clang associates a ``VarDecl`` with each variable to represent the variable's; declaration. Since the ""canonical"" form of each declaration is unique by; address, all we need to do is make sure neither ``ValueDecl`` (base class of; ``VarDecl``) is ``NULL`` and compare the canonical Decls. .. code-block:: c++. static bool areSameVariable(const ValueDecl *First, const ValueDecl *Second) {; return First && Second &&; First->getCanonicalDecl() == Second->getCanonicalDecl();; }. If execution reaches the end of ``LoopPrinter::run()``, we know that the; loop shell looks like. .. code-block:: c++. for (int i= 0; i < expr(); ++i) { ... }. For now, we will just print a message explaining that we found a loop.; The next section will deal with recursively traversing the AST to; discover all changes needed. As a side note, it's not as trivial to test if two expressions are the same,; though Clang has already done the hard work for us by providing a way to; canonicalize expressions:. .. code-block:: c++. static bool areSameExpr(ASTContext *Cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:17936,variab,variable,17936,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,2,['variab'],['variable']
Modifiability,"arate components of LLVM, a separate abstract; base class and registry is provided for printing assembly code, the; ``GCMetadaPrinter`` and ``GCMetadataPrinterRegistry``. The AsmWriter will look; for such a subclass if the ``GCStrategy`` sets ``UsesMetadata``:. .. code-block:: c++. MyGC::MyGC() {; UsesMetadata = true;; }. This separation allows JIT-only clients to be smaller. Note that LLVM does not currently have analogous APIs to support code generation; in the JIT, nor using the object writers. .. code-block:: c++. // lib/MyGC/MyGCPrinter.cpp - Example LLVM GC printer. #include ""llvm/CodeGen/GCMetadataPrinter.h""; #include ""llvm/Support/Compiler.h"". using namespace llvm;. namespace {; class LLVM_LIBRARY_VISIBILITY MyGCPrinter : public GCMetadataPrinter {; public:; virtual void beginAssembly(AsmPrinter &AP);. virtual void finishAssembly(AsmPrinter &AP);; };. GCMetadataPrinterRegistry::Add<MyGCPrinter>; X(""mygc"", ""My bespoke garbage collector."");; }. The collector should use ``AsmPrinter`` to print portable assembly code. The; collector itself contains the stack map for the entire module, and may access; the ``GCFunctionInfo`` using its own ``begin()`` and ``end()`` methods. Here's; a realistic example:. .. code-block:: c++. #include ""llvm/CodeGen/AsmPrinter.h""; #include ""llvm/IR/Function.h""; #include ""llvm/IR/DataLayout.h""; #include ""llvm/Target/TargetAsmInfo.h""; #include ""llvm/Target/TargetMachine.h"". void MyGCPrinter::beginAssembly(AsmPrinter &AP) {; // Nothing to do.; }. void MyGCPrinter::finishAssembly(AsmPrinter &AP) {; MCStreamer &OS = AP.OutStreamer;; unsigned IntPtrSize = AP.getPointerSize();. // Put this in the data section.; OS.switchSection(AP.getObjFileLowering().getDataSection());. // For each function...; for (iterator FI = begin(), FE = end(); FI != FE; ++FI) {; GCFunctionInfo &MD = **FI;. // A compact GC layout. Emit this data structure:; //; // struct {; // int32_t PointCount;; // void *SafePointAddress[PointCount];; // int32_t StackFrameSize; // in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:36499,portab,portable,36499,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['portab'],['portable']
Modifiability,arations naming members of class templates in non-templates; Not resolved. 1946; CD4; exception-specifications vs pointer dereference; Unknown. 1947; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion sequences; Unknown. 1951; CD4; Cv-qualification and literal types; Unknown. 1952; CD4; Constant expressions and library undefined behavior; Unknown. 1953; open; Data races and common initial sequence; Not resolved. 1954; tentatively ready; typeid null dereference check in subexpressions; Unknown. 1955; CD4; #elif with invalid controlling expression; Unknown. 1956; CD4; Reuse of storage of automatic variables; Unknown. 1957; NAD; decltype(auto) with direct-list-initialization; Unknown. 1958; CD4; decltype(auto) with parenthesized initializer; Unknown. 1959; CD4; Inadvertently inherited copy constructor; Clang 3.9. 1960; NAD; Visibility of entity named in class-scope using-declaration; No. 1961; C++17; Potentially-concurrent actions within a signal handler; Unknown. 1962; open; Type of __func__; Not resolved. 1963; CD4; Implementation-defined identifier characters; Unknown. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant spe,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:133053,inherit,inherited,133053,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inherit'],['inherited']
Modifiability,"arded. Setting the; minimum or maximum value for the Y scale before filling has the same; effect as calling the special **`TProfile`** constructor above where; `ylow` and `yup` are specified. ### Build Options. The last parameter is the build option. If a bin has N data points all; with the same value Y, which is the case when dealing with integers,; the spread in Y for that bin is zero, and the uncertainty assigned is; also zero, and the bin is ignored in making subsequent fits. If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it is only; in the case where the Y variable is some sort of counting statistics,; following a Poisson distribution. This is the default case. However, Y; can be any variable from an original `NTUPLE`, and does not; necessarily follow a Poisson distribution. The computation of errors; is based on Y = values of data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y values with the uncertainty; of $\pm 0.5$, assuming the probability that Y takes any value between Y-0.5; and Y+0.5 is uniform (the same argument for Y uniformly distributed; betwe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:64304,variab,variable,64304,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variable']
Modifiability,"are normally drawn on side opposite to tick marks. However,; `chopt = '='`: on Equal side. The function `TAxis::CenterLabels()` sets; the bit `kCenterLabels` and it is visible from **`TAxis`** context menu.; It centers the bin labels and it makes sense only when the number of; bins is equal to the number of tick marks. The class responsible for; drawing the axis **`TGaxis`** inherits this property. #### Orientation. Labels are normally drawn parallel to the axis. However, if; `xmin = xmax`, then they are drawn orthogonal, and if `ymin=ymax` they; are drawn parallel. #### Labels for Exponents. By default, an exponent of the form 10\^N is used when the label values; are either all very small or very large. One can disable the exponent by; calling:. ``` {.cpp}; TAxis::SetNoExponent(kTRUE); ```. Note that this option is implicitly selected if the number of digits to; draw a label is less than the `fgMaxDigits` global member. If the; property `SetNoExponent` was set in **`TAxis`** (via; `TAxis::SetNoExponent)`, the **`TGaxis`** will inherit this property.; **`TGaxis`** is the class responsible for drawing the axis. The method; `SetNoExponent` is also available from the axis context menu. ![Y-axis with and without exponent labels](pictures/030000C7.png). #### Number of Digits in Labels. `TGaxis::fgMaxDigits` is the maximum number of digits permitted for the; axis labels above which the notation with 10\^N is used. It must be; greater than 0. By default `fgMaxDigits` is 5 and to change it use the; `TGaxis::SetMaxDigits` method. For example to set `fgMaxDigits` to; accept 6 digits and accept numbers like 900000 on an axis call:. ``` {.cpp}; TGaxis::SetMaxDigits(6); ```. #### Tick Mark Positions. Labels are centered on tick marks. However, if `xmin = xmax`, then they; are right adjusted. - `chopt = 'R'`: labels are right adjusted on tick mark (default is; centered). - `chopt = 'L'`: labels are left adjusted on tick mark. - `chopt = 'C'`: labels are centered on tick mark. - `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:56057,inherit,inherit,56057,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inherit']
Modifiability,"are now in XML format; ; New MVA methods ""PDE-Foam"" and ""LD"", both featuring; classification and regression; ; ; Comments. On XML format:; ; The old text format is obsolete though still readable in the; application. Backward compatibility is NOT guaranteed. Please; contact the authors if you require the reading of old text weight; files in TMVA 4.; ; ; Standard macros:; ; The structure of the standard macros has changed: macros are; still in the ""$ROOTSYS/tmva/test"" directory, but distinguished for; classification and regression examples:; ; TMVAClassification.C, TMVAClassificationApplication.C TMVARegression.C, TMVARegressionApplication.C; ; Classification and regression analysis (training) is analysed as; usual via standard macros that can be called from dedicated; GUIs.; ; ; Regression:. Not yet available for all MVA methods. It exists for:; PDE-RS, PDE-Foam, K-NN, LD, FDA, MLP, BDT for single targets; (1D), and MLP for multiple targets (nD).; ; Not all transformation of input variables are available; (only ""Norm"" so far). Regression requires specific evaluation tools:. ; During the training we provide a ranking of input; variables, using various criteria: correlations, transposed; correlation, correlation ratio, and ""mutual information"" between; input variables and regression target. (Correlation ratio and; mutual information implmentations provided by Moritz Backes,; Geneva U); ; After the training, the trained MVA methods are ranked wrt.; the deviations between regression target and estimate.; ; Macros plot various deviation and correlation quantities.; A new GUI (macros/TMVARegGui.C) collects these macros.; . Improvements of / new features for MVA methods . Linear Discriminant:; Re-implementation of ""Fisher"" method as general linear discriminant (""LD""),; which is also regression capable (so far: single-target only). PDEFoam:; PDE-Foam is a variation of the PDE-RS method using a self-adapting binning; method to divide the multi-dimensional variable space into ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html:1507,variab,variables,1507,tmva/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html,1,['variab'],['variables']
Modifiability,"are part of a group; of classes that share a common header and implementation file. More complicated; structuring of source code into files is not supported. ; ; Also new accessors have been added for discrete-valued functions catfunc(); and stored category functions are now also printed under their own heading in Print(); Parameterized ranges. It is now possible to use RooAbsReal derived functions as range definition for variables; to construct ranges that vary as function of another variable. For example. RooRealVar x(""x"",""x"",-10,10) ; // variable with fixed range [-10,10] ; RooRealVar y(""y"",""y"",0,20) ; // variable with fixed range [-10,10] ; ; RooFormulaVar x_lo(""x_lo"",""y-20"",y) ; ; RooFormulaVar x_hi(""x_hi"",""sin(y)*5"",y) ; ; x.setRange(x_lo,x_hi) ; // Change x to have variable range depending on y; ; It is also possible to define parameterized named ranges in the same way. x.setRange(""signalRegion"",x_lo,x_hi) ;. There are no fundamental limits to the complexity of the parameterized ranges; that can be defined as long as the problem is uniquely defined. For example, given three observables ; x, y and z, one can define a parameterized named range 'R' of x in terms of y and of y in terms of z; and ask to calculate the three dimensional integral of any function or p.d.f in terms of (x,y,z); over that range 'R' and it will be calculated correctly, taking recursive range dependencies into; account. A definition of a range 'R' on the other hand where the bounds of x depend on y and; the bounds of y depend on x is not allowed, and an error message will be printed to complain about; the ambiguity of the problem definition. Integrals over non-rectangular regions are created the; same way as integrals over rectangular regions using the RooAbsReal::createIntegral() function, the; chosen mode of operation depends on the shape of the requestion integration range. Note that in general integration over non (hyper)rectangular regions will be more computationally; intensive as onl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:3824,parameteriz,parameterized,3824,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['parameteriz'],['parameterized']
Modifiability,"are provided within the code, the first one; containing three-dimensional representations (Figure [5.4](#f54)) and the second one; projections and profiles (Figure [5.5](#f55)) of the bi-dimensional histogram. [f54]: figures/th2f.png ""f54""; <a name=""f54""></a>. ![Different ways of representing bi-dimensional; histograms.\label{f54}][f54]. [f55]: figures/proj_and_prof.png ""f55""; <a name=""f55""></a>. ![The projections and profiles of bi-dimensional; histograms.\label{f55}][f55]. When a projection is performed along the x (y) direction, for every bin; along the x (y) axis, all bin contents along the y (x) axis are summed; up (upper the plots of Figure [5.5](#f55)). When a profile is performed along the x (y); direction, for every bin along the x (y) axis, the average of all the; bin contents along the y (x) is calculated together with their RMS and; displayed as a symbol with error bar (lower two plots of Figure [5.5](#f55)). Correlations between the variables are quantified by the methods; `Double_t GetCovariance()` and `Double_t GetCorrelationFactor()`. \newpage. ## Multiple histograms ##. The class `THStack` allows to manipulate a set of histograms as a single entity.; It is a collection of `TH1` (or derived) objects. When drawn, the X and Y axis; ranges are automatically computed such as all the histograms will be visible.; Several drawing option are available for both 1D and 2D histograms. The next; macros shows how it looks for 2D histograms:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/hstack.C; ```. - Line *4*: creates the stack. - Lines *4-18*: create two histograms to be added in the stack. - Lines *20-21*: add the histograms in the stack. - Line *23*: draws the stack as a lego plot. The colour distinguish the two histograms [5.6](#f56). [f56]: figures/hstack.png ""f56""; <a name=""f56""></a>. ![Two 2D histograms stack on top of each other.\label{f56}][f56]. [^4]: To optimise the memory usage you might go for one byte (TH1C), short (TH1S), integer (TH1I), lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:4442,variab,variables,4442,documentation/primer/histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md,1,['variab'],['variables']
Modifiability,"are(metadata [256 x i8]* %buffer, metadata !3,; metadata !DIExpression(DW_OP_plus, 64)), !dbg !4; !3 = !DILocalVariable(name: ""i"", ...) ; int i; !4 = !DILocation(...). A frontend should generate exactly one call to ``llvm.dbg.declare`` at the point; of declaration of a source variable. Optimization passes that fully promote the; variable from memory to SSA values will replace this call with possibly multiple; calls to `llvm.dbg.value`. Passes that delete stores are effectively partial; promotion, and they will insert a mix of calls to ``llvm.dbg.value`` to track; the source variable value when it is available. After optimization, there may be; multiple calls to ``llvm.dbg.declare`` describing the program points where the; variables lives in memory. All calls for the same concrete source variable must; agree on the memory location. ``llvm.dbg.value``; ^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.value(metadata, metadata, metadata). This intrinsic provides information when a user source variable is set to a new; value. The first argument is the new value (wrapped as metadata). The second; argument is a `local variable <LangRef.html#dilocalvariable>`_ containing a; description of the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a source variable; directly, not its address. Note that the value operand of this intrinsic may; be indirect (i.e, a pointer to the source variable), provided that interpreting; the complex expression derives the direct value. ``llvm.dbg.assign``; ^^^^^^^^^^^^^^^^^^^; .. toctree::; :hidden:. AssignmentTracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression). This intrinsic marks the position in IR where a source assignment occurred. It; encodes the value of the variable. It references the store, if any,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:10321,variab,variable,10321,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"are). - transfer a custom user **payload** on each PROOF worker (for instance,; user's client-generated Grid credentials to make PROOF workers; capable of accessing a remote authenticated storage). Configuration files are searched for in two different locations:. - a system-wide directory: `<client_install_dir>/etc`. - user's home directory: `~/.vaf`. > A system-wide configuration file always has precedence over user's; > configuration. It is thus possible for the sysadmin to enforce a; > policy where some scripts cannot ever be overridden. Thanks to this separation, users can maintain an uncluttered directory; with very simple configuration files that contain only what really needs; or is allowed to be customized: for instance, user might specify a single line; containing the needed ROOT version, while all the technicalities to set; up the environment are taken care of inside system-installed scripts,; leaving the user's configuration directory clean and uncluttered. ### Local environment configuration. All the local environment files are loaded at the time of the; client's startup following a certain order. - `common.before`. - `local.before`. - `local.conf`. - `$VafConf_LocalPodLocation/PoD_env.sh`. - `common.after`. - `local.after`. The `common.*` files are sourced both for the local and the remote; environment. This might be convenient to avoid repeating the same; configuration in different places. Each file is looked for first in the system-wide directory and then in; the user's directory. If a configuration file does not exist, it is; silently skipped. The `$VafConf_LocalPodLocation/PoD_env.sh` environment script, provided; with each PROOF on Demand installation, *must exist*: without this file,; the VAF client won't start. ### List of VAF-specific variables. There are some special variables that need to be set in one of the above; configuration files. `$VafConf_LocalPodLocation`; : Full path to the PoD installation on the client. > The `$VafConf_LocalPodLocat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:2526,config,configuration,2526,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['config'],['configuration']
Modifiability,"arently; required by the Objective-C exceptions implementation. .. _arc.misc.externally_retained:. Externally-Retained Variables; -----------------------------. In some situations, variables with strong ownership are considered; externally-retained by the implementation. This means that the variable is; retained elsewhere, and therefore the implementation can elide retaining and; releasing its value. Such a variable is implicitly ``const`` for safety. In; contrast with ``__unsafe_unretained``, an externally-retained variable still; behaves as a strong variable outside of initialization and destruction. For; instance, when an externally-retained variable is captured in a block the value; of the variable is retained and released on block capture and destruction. It; also affects C++ features such as lambda capture, ``decltype``, and template; argument deduction. Implicitly, the implementation assumes that the :ref:`self parameter in a; non-init method <arc.misc.self>` and the :ref:`variable in a for-in loop; <arc.misc.enumeration>` are externally-retained. Externally-retained semantics can also be opted into with the; ``objc_externally_retained`` attribute. This attribute can apply to strong local; variables, functions, methods, or blocks:. .. code-block:: objc. @class WobbleAmount;. @interface Widget : NSObject; -(void)wobble:(WobbleAmount *)amount;; @end. @implementation Widget. -(void)wobble:(WobbleAmount *)amount; __attribute__((objc_externally_retained)) {; // 'amount' and 'alias' aren't retained on entry, nor released on exit.; __attribute__((objc_externally_retained)) WobbleAmount *alias = amount;; }; @end. Annotating a function with this attribute makes every parameter with strong; retainable object pointer type externally-retained, unless the variable was; explicitly qualified with ``__strong``. For instance, ``first_param`` is; externally-retained (and therefore ``const``) below, but not ``second_param``:. .. code-block:: objc. __attribute__((objc_externally_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:92846,variab,variable,92846,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"arf-evaluation-stack:. 2.1 Allow Location Description on the DWARF Expression Stack; ------------------------------------------------------------. DWARF Version 5 does not allow location descriptions to be entries on the DWARF; expression stack. They can only be the final result of the evaluation of a DWARF; expression. However, by allowing a location description to be a first-class; entry on the DWARF expression stack it becomes possible to compose expressions; containing both values and location descriptions naturally. It allows objects to; be located in any kind of memory address space, in registers, be implicit; values, be undefined, or a composite of any of these. By extending DWARF carefully, all existing DWARF expressions can retain their; current semantic meaning. DWARF has implicit conversions that convert from a; value that represents an address in the default address space to a memory; location description. This can be extended to allow a default address space; memory location description to be implicitly converted back to its address; value. This allows all DWARF Version 5 expressions to retain their same meaning,; while enabling the ability to explicitly create memory location descriptions in; non-default address spaces and generalizing the power of composite location; descriptions to any kind of location description. For those familiar with the definition of location descriptions in DWARF Version; 5, the definitions in these extensions are presented differently, but does in; fact define the same concept with the same fundamental semantics. However, it; does so in a way that allows the concept to extend to support address spaces,; bit addressing, the ability for composite location descriptions to be composed; of any kind of location description, and the ability to support objects located; at multiple places. Collectively these changes expand the set of architectures; that can be supported and improves support for optimized code. Several approaches were ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:5895,extend,extended,5895,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extended']
Modifiability,"arger; pointer that carries bounds information alongside the pointer value. Utilizing; wide pointers can potentially reduce the adoption burden, as it contains bounds; information internally and eliminates the need for explicit bounds annotations.; However, wide pointers differ from standard C pointers in their data layout,; which may result in incompatibilities with the application binary interface; (ABI). Breaking the ABI complicates interoperability with external code that has; not adopted the same programming model. ``-fbounds-safety`` harmonizes the wide pointer and the bounds annotation; approaches to reduce the adoption burden while maintaining the ABI. In this; model, local variables of pointer type are implicitly treated as wide pointers,; allowing them to carry bounds information without requiring explicit bounds; annotations. Please note that this approach doesn't apply to function parameters; which are considered ABI-visible. As local variables are typically hidden from; the ABI, this approach has a marginal impact on it. In addition,; ``-fbounds-safety`` employs compile-time restrictions to prevent implicit wide; pointers from silently breaking the ABI (see `ABI implications of default bounds; annotations`_). Pointers associated with any other variables, including function; parameters, are treated as single object pointers (i.e., ``__single``), ensuring; that they always have the tightest bounds by default and offering a strong; bounds safety guarantee. By implementing default bounds annotations based on ABI visibility, a; considerable portion of C code can operate without modifications within this; programming model, reducing the adoption burden. The rest of the section will discuss individual bounds annotations and the; programming model in more detail. Bounds annotations; ------------------. Annotation for pointers to a single object; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The C language allows pointer arithmetic on arbitrary pointers and this h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:6185,variab,variables,6185,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variables']
Modifiability,"arget machine's default alignment. Write barrier: ``llvm.gcwrite``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.gcwrite(i8* %value, i8* %object, i8** %derived). For write barriers, LLVM provides the ``llvm.gcwrite`` intrinsic function. It; has exactly the same semantics as a non-volatile ``store`` to the derived; pointer (the third argument). The exact code generated is specified by the; Function's selected :ref:`GC strategy <plugin>`. Many important algorithms require write barriers, including generational and; concurrent collectors. Additionally, write barriers could be used to implement; reference counting. Read barrier: ``llvm.gcread``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. i8* @llvm.gcread(i8* %object, i8** %derived). For read barriers, LLVM provides the ``llvm.gcread`` intrinsic function. It has; exactly the same semantics as a non-volatile ``load`` from the derived pointer; (the second argument). The exact code generated is specified by the Function's; selected :ref:`GC strategy <plugin>`. Read barriers are needed by fewer algorithms than write barriers, and may have a; greater performance impact since pointer reads are more frequent than writes. .. _plugin:. .. _builtin-gc-strategies:. Built In GC Strategies; ======================. LLVM includes built in support for several varieties of garbage collectors. The Shadow Stack GC; ----------------------. To use this collector strategy, mark your functions with:. .. code-block:: c++. F.setGC(""shadow-stack"");. Unlike many GC algorithms which rely on a cooperative code generator to compile; stack maps, this algorithm carefully maintains a linked list of stack roots; [:ref:`Henderson2002 <henderson02>`]. This so-called ""shadow stack"" mirrors the; machine stack. Maintaining this data structure is slower than using a stack map; compiled into the executable as constant data, but has a significant portability; advantage because it requires no special support from the target code gene",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:15637,plugin,plugin,15637,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"argument that is the name of; an attribute implemented as a Microsoft-style ``__declspec`` attribute. It; evaluates to 1 if the attribute is supported by the current compilation target,; or 0 if not. It can be used like this:. .. code-block:: c++. #ifndef __has_declspec_attribute // Optional of course.; #define __has_declspec_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_declspec_attribute(dllexport); #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__dllexport__`` can be used instead of ``dllexport``. ``__is_identifier``; -------------------. This function-like macro takes a single identifier argument that might be either; a reserved word or a regular identifier. It evaluates to 1 if the argument is just; a regular identifier and not a reserved word, in the sense that it can then be; used as the name of a user-defined function or variable. Otherwise it evaluates; to 0. It can be used like this:. .. code-block:: c++. ...; #ifdef __is_identifier // Compatibility with non-clang compilers.; #if __is_identifier(__wchar_t); typedef wchar_t __wchar_t;; #endif; #endif. __wchar_t WideCharacter;; ... Include File Checking Macros; ============================. Not all developments systems have the same include files. The; :ref:`langext-__has_include` and :ref:`langext-__has_include_next` macros allow; you to check for the existence of an include file before doing a possibly; failing ``#include`` directive. Include file checking macros must be used; as expressions in ``#if`` or ``#elif`` preprocessing directives. .. _langext-__has_include:. ``__has_include``; -----------------. This function-like macro takes a single file name string argument that is the; name of an include file. It evaluates to 1 if the file can be found using the; include pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:9474,variab,variable,9474,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variable']
Modifiability,"arguments specified after **--gcc-tool-args** to the invocation of; **gcc**. **--opt-args** *opt args*. Pass all arguments specified after **--opt-args** to the invocation of **opt**. **--disable-{dce,simplifycfg}**. Do not run the specified passes to clean up and reduce the size of the test; program. By default, **bugpoint** uses these passes internally when attempting to; reduce test programs. If you're trying to find a bug in one of these passes,; **bugpoint** may crash. **--enable-valgrind**. Use valgrind to find faults in the optimization phase. This will allow; bugpoint to find otherwise asymptomatic problems caused by memory; mis-management. **-find-bugs**. Continually randomize the specified passes and run them on the test program; until a bug is found or the user kills **bugpoint**. **-help**. Print a summary of command line options. **--input** *filename*. Open *filename* and redirect the standard input of the test program, whenever; it runs, to come from that file. **--load** *plugin*. Load the dynamic object *plugin* into **bugpoint** itself. This object should; register new optimization passes. Once loaded, the object will add new command; line options to enable various optimizations. To see the new complete list of; optimizations, use the **-help** and **--load** options together; for example:. .. code-block:: bash. bugpoint --load myNewPass.so -help. **--mlimit** *megabytes*. Specifies an upper limit on memory usage of the optimization and codegen. Set; to zero to disable the limit. **--output** *filename*. Whenever the test program produces output on its standard output stream, it; should match the contents of *filename* (the ""reference output""). If you; do not use this option, **bugpoint** will attempt to generate a reference output; by compiling the program with the ""safe"" backend and running it. **--run-{int,jit,llc,custom}**. Whenever the test program is compiled, **bugpoint** should generate code for it; using the specified code generator. These ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst:3304,plugin,plugin,3304,interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,1,['plugin'],['plugin']
Modifiability,"ariable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and evaluate; opcodes from the DIExpression until the final variable description is produced. The current supported opcode vocabulary is limited:. - ``DW_OP_deref`` dereferences the top of the expression stack.; - ``DW_OP_plus`` pops the last two entries from the expression stack, adds; them together and appends the result to the expression stack.; - ``DW_OP_minus`` pops the last two entries from the expression stack, subtracts; the last entry from the second last entry and appends the result to the; expression stack.; - ``DW_OP_plus_uconst, 93`` adds ``93`` to the working expression.; - ``DW_OP_LLVM_fragment, 16, 8`` specifies the offset and size (``16`` and ``8``; here, respectively) of the variable fragment from the working expression. Note; that contrary to DW_OP_bit_piece, the offset is describing the location; within the described source variable.; - ``DW_OP_LLVM_convert, 16, DW_ATE_signed`` specifies a bit size and encoding; (``16`` and ``DW_ATE_signed`` here, respectively) to which the top of the; expression stack is to be converted. Maps into a ``DW_OP_convert`` operation; that references a base type constructed from the supplied values.; - ``DW_OP_LLVM_tag_offset, tag_offset`` specifies that a memory tag should be; optionally applied to the pointer. The memory tag is derived from the; given tag offset in an implementation-defined manner.; - ``DW_OP_swap`` swaps top two stack entries.; - ``DW_OP_xderef`` provides extended dereference mechanism. The entry at the top; of the stack is treated as an address. The second stack entry is treated as an; address space identifier.; - ``DW_OP_stack_value`` marks a constant value.; - ``DW_OP_LLVM_entry_value, N`` refers to the value a register had upon; function entry. When targeting DWARF, a ``DBG_VALUE(reg, ...,; DIExpression(DW",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:262202,variab,variable,262202,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ariable;. // Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.; if (!Body->codegen()); return nullptr;. Now the code starts to get more interesting. Our 'for' loop introduces a; new variable to the symbol table. This means that our symbol table can; now contain either function arguments or loop variables. To handle this,; before we codegen the body of the loop, we add the loop variable as the; current value for its name. Note that it is possible that there is a; variable of the same name in the outer scope. It would be easy to make; this an error (emit an error and return null if there is already an; entry for VarName) but we choose to allow shadowing of variables. In; order to handle this correctly, we remember the Value that we are; potentially shadowing in ``OldVal`` (which will be null if there is no; shadowed variable). Once the loop variable is set into the symbol table, the code; recursively codegen's the body. This allows the body to use the loop; variable: any references to it will naturally find it in the symbol; table. .. code-block:: c++. // Emit the step value.; Value *StepVal = nullptr;; if (Step) {; StepVal = Step->codegen();; if (!StepVal); return nullptr;; } else {; // If not specified, use 1.0.; StepVal = ConstantFP::get(*TheContext, APFloat(1.0));; }. Value *NextVar = Builder->CreateFAdd(Variable, StepVal, ""nextvar"");. Now that the body is emitted, we compute the next value of the iteration; variable by adding the step value, or 1.0 if it isn't present.; '``NextVar``' will be the value of the loop variable on the next; iteration of the loop. .. code-block:: c++. // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Convert condition to a bool by comparing non-equal to 0.0.; EndCond = Builder->CreateFCmpONE(; EndCond, ConstantFP::get(*TheContext, APFloat(0.0)), ""loopcond"");. Finally, we ev",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:23587,variab,variable,23587,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability,ariables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across protected inheritance; Not resolved. 473; NAD; Block-scope declarations of allocator functions; Unknown. 474; CD1; Block-scope extern declarations in namespace members; Clang 3.4. 475; C++11; When is std::uncaught_exception() true? (take 2); Unknown. 476; CD5; Determining the buffer size for placement new; Unknown. 477; CD1; Can virtual appear in a friend declaration?; Clang 3.5. 478; NAD; May a function parameter be an array of an abstract class type?; Yes. 479; CD1; Copy elision in exception handling; Clang 2.8. 480; CD1; Is a base of a virtual base also virtual?; Yes. 481; CD2; Scope of template parameters; Clang 2.8. 482; CD3; Qualified declarators in redeclarations; Clang 3.5. 483; CD3; Normative requirements on integral ranges; Yes. 484; CD1; Can a base-specifier name a cv-qualified class type?; Yes. 485; CD1; What is a “name”?; Yes. 486; CD1; Invalid return types and template argument deduction; Yes. 487; NAD; Operator overloading in constant expressions; Yes. 488; CD1; Local types,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:32286,inherit,inheritance,32286,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inherit'],['inheritance']
Modifiability,"ariables is actually; ""i32\*"" even though the variable is defined as ""i32"". What this means is; that @G defines *space* for an i32 in the global data area, but its; *name* actually refers to the address for that space. Stack variables; work the same way, except that instead of being declared with global; variable definitions, they are declared with the `LLVM alloca; instruction <../../LangRef.html#alloca-instruction>`_:. .. code-block:: llvm. define i32 @example() {; entry:; %X = alloca i32 ; type of %X is i32*.; ...; %tmp = load i32, i32* %X ; load the stack value %X from the stack.; %tmp2 = add i32 %tmp, 1 ; increment it; store i32 %tmp2, i32* %X ; store it back; ... This code shows an example of how you can declare and manipulate a stack; variable in the LLVM IR. Stack memory allocated with the alloca; instruction is fully general: you can pass the address of the stack slot; to functions, you can store it in other variables, etc. In our example; above, we could rewrite the example to use the alloca technique to avoid; using a PHI node:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; %X = alloca i32 ; type of %X is i32*.; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; store i32 %X.0, i32* %X ; Update X; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; store i32 %X.1, i32* %X ; Update X; br label %cond_next. cond_next:; %X.2 = load i32, i32* %X ; Read X; ret i32 %X.2; }. With this, we have discovered a way to handle arbitrary mutable; variables without the need to create Phi nodes at all:. #. Each mutable variable becomes a stack allocation.; #. Each read of the variable becomes a load from the stack.; #. Each update of the variable becomes a store to the stack.; #. Taking the address of a variable just uses the stack address; directly. While this solution has solved our immediate problem, it introduced;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:5498,rewrite,rewrite,5498,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['rewrite'],['rewrite']
Modifiability,"ariables that are cached or specified on the command line can have types; associated with them. The variable's type is used by CMake's UI tool to display; the right input field. A variable's type generally doesn't impact evaluation,; however CMake does have special handling for some variables such as PATH.; You can read more about the special handling in `CMake's set documentation; <https://cmake.org/cmake/help/v3.5/command/set.html#set-cache-entry>`_. Scope; -----. CMake inherently has a directory-based scoping. Setting a variable in a; CMakeLists file, will set the variable for that file, and all subdirectories.; Variables set in a CMake module that is included in a CMakeLists file will be; set in the scope they are included from, and all subdirectories. When a variable that is already set is set again in a subdirectory it overrides; the value in that scope and any deeper subdirectories. The CMake set command provides two scope-related options. PARENT_SCOPE sets a; variable into the parent scope, and not the current scope. The CACHE option sets; the variable in the CMakeCache, which results in it being set in all scopes. The; CACHE option will not set a variable that already exists in the CACHE unless the; FORCE option is specified. In addition to directory-based scope, CMake functions also have their own scope.; This means variables set inside functions do not bleed into the parent scope.; This is not true of macros, and it is for this reason LLVM prefers functions; over macros whenever reasonable. .. note::; Unlike C-based languages, CMake's loop and control flow blocks do not have; their own scopes. Control Flow; ============. CMake features the same basic control flow constructs you would expect in any; scripting language, but there are a few quirks because, as with everything in; CMake, control flow constructs are commands. If, ElseIf, Else; ----------------. .. note::; For the full documentation on the CMake if command go; `here <https://cmake.org/cmake/help",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:6695,variab,variable,6695,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variable']
Modifiability,"ariables. - By default `fGraphicsMode` is true. When calling the `Minuit`; functions such as `mncont`, `mnscan`, or any `Minuit` command; invoking `mnplot`, `TMinuit::mnplot()` produces a **`TGraph`**; object pointed by `fPlot`. One can retrieve this object with; **`TMinuit`**`::GetPlot().` For example:. ``` {.cpp}; h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");; ```. - To set `Minuit` in no graphics mode, call. ``` {.cpp}; gMinuit->SetGraphicsMode(kFALSE);; ```. ### Basic Concepts of Minuit. The `Minuit` package acts on a multi parameter FORTRAN function to; which one must give the generic name `FCN`. In the ROOT; implementation, the function `FCN` is defined via the `Minuit`; `SetFCN` member function when an histogram fitting is invoked. The; value of `FCN` will in general depend on one or more variable; parameters. ### The Transformation of Limited Parameters. For variable parameters with limits, `Minuit` uses the following; transformation:. `Pint = arcsin(2((Pext-a)/(b-a))-1) `. `Pext = a+((b-a)/(2))(sinPint+1)`. so that the internal value `Pint` can take on any value, while the; external value Pext can take on values only between the lower limit a; and the ext upper limit b. Since the transformation is necessarily; non-linear, it would transform a nice linear problem into a nasty; non-linear one, which is the reason why limits should be avoided if; not necessary. In addition, the transformation does require some; computer time, so it slows down the computation a little bit, and more; importantly, it introduces additional numerical inaccuracy into the; problem in addition to what is introduced in the numerical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer to one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:55436,variab,variable,55436,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['variab'],['variable']
Modifiability,"ariables. Check the address; sanitizer documentation or the link below for details. In clang, which allows to blacklist functions, the build will continue. See [core/sanitizer](https://github.com/root-project/root/tree/master/core/sanitizer) for information. ### Optimization of ROOT header files. Many (but intentionally not all) unused includes were removed from ROOT header files. For instance, `#include ""TObjString.h""` and; `#include ""ThreadLocalStorage.h""` were removed from `TClass.h`. Or `#include ""TDatime.h""` was removed from; `TDirectory.h` header file . Or `#include ""TDatime.h""` was removed from `TFile.h`.; This change may cause errors during compilation of ROOT-based code. To fix it, provide missing the includes; where they are really required.; This improves compile times and reduces code inter-dependency; see https://github.com/include-what-you-use/include-what-you-use/blob/master/docs/WhyIWYU.md for a good overview of the motivation. Even more includes will be ""hidden"" when ROOT configured with `-Ddev=ON` build option.; In that case ROOT uses `#ifdef R__LESS_INCLUDES` to replace unused includes by class forward declarations.; Such `dev` builds can be used to verify that ROOT-based code really includes all necessary ROOT headers. ## RDataFrame. - Starting from this version, when `RSnapshotOptions.fMode` is `""UPDATE""` (i.e. the output file is opened in ""UPDATE""; mode), Snapshot will refuse to write out a TTree if one with the same name is already present in the output file.; Users can set the new flag `RSnapshotOption::fOverwriteIfExists` to `true` to force the deletion of the TTree that is; already present and the writing of a new TTree with the same name. See; [ROOT-10573](https://sft.its.cern.ch/jira/browse/ROOT-10573) for more details.; - RDataFrame changed its error handling strategy in case of unreadable input files. Instead of simply logging an error; and skipping the file, it now throws an exception if any of the input files is unreadable (this could ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:8926,config,configured,8926,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['config'],['configured']
Modifiability,"aries are added on the top-level; # CMakeLists.txt. add_subdirectory(IR); add_subdirectory(FuzzMutate); add_subdirectory(FileCheck); add_subdirectory(InterfaceStub); add_subdirectory(IRPrinter); add_subdirectory(IRReader); add_subdirectory(CodeGen); add_subdirectory(BinaryFormat); add_subdirectory(Bitcode); add_subdirectory(Bitstream); add_subdirectory(DWARFLinker); add_subdirectory(Extensions); add_subdirectory(Frontend); add_subdirectory(Transforms); add_subdirectory(Linker); add_subdirectory(Analysis); add_subdirectory(LTO); add_subdirectory(MC); add_subdirectory(MCA); add_subdirectory(ObjCopy); add_subdirectory(Object); add_subdirectory(ObjectYAML); add_subdirectory(Option); add_subdirectory(Remarks); add_subdirectory(Debuginfod); add_subdirectory(DebugInfo); add_subdirectory(DWP); add_subdirectory(ExecutionEngine); add_subdirectory(Target); add_subdirectory(AsmParser); add_subdirectory(LineEditor); add_subdirectory(ProfileData); add_subdirectory(Passes); add_subdirectory(TargetParser); add_subdirectory(TextAPI); add_subdirectory(ToolDrivers); add_subdirectory(XRay); if (LLVM_INCLUDE_TESTS); add_subdirectory(Testing); endif(); add_subdirectory(WindowsDriver); add_subdirectory(WindowsManifest). set(LLVMCONFIGLIBRARYDEPENDENCIESINC ""${LLVM_BINARY_DIR}/tools/llvm-config/LibraryDependencies.inc""). # Special components which don't have any source attached but aggregate other; # components; add_llvm_component_group(all-targets LINK_COMPONENTS ${LLVM_TARGETS_TO_BUILD}); add_llvm_component_group(Engine). # The native target may not be enabled when cross compiling; if(TARGET ${LLVM_NATIVE_ARCH}); add_llvm_component_group(Native LINK_COMPONENTS ${LLVM_NATIVE_ARCH}); add_llvm_component_group(NativeCodeGen LINK_COMPONENTS ${LLVM_NATIVE_ARCH}CodeGen); else(); add_llvm_component_group(Native); add_llvm_component_group(NativeCodeGen); endif(). # Component post-processing; LLVMBuildResolveComponentsLink(); LLVMBuildGenerateCFragment(OUTPUT ${LLVMCONFIGLIBRARYDEPENDENCIESINC}); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CMakeLists.txt:1349,config,config,1349,interpreter/llvm-project/llvm/lib/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CMakeLists.txt,1,['config'],['config']
Modifiability,"aries are found. However, it is strongly recommended, to use an optimized Blas implementation such as `libopenblas`, that is; available in cvmfs.; - Add several performance optimizations for both CPU and GPU versions of `MethodDL`. . ### Other New TMVA Features. - Add a new option to the `DataLoader` to switch off computation of correlation matrix. The new option is called *CalcCorrelations* and it should be used when a large number of input variables are; provided, otherwise TMVA will spend a long time in setting up the data set before training. ; ; - Build configuration:; - Add new cmake flags, `tmva-cpu` and `tmva-gpu`, which can be used to swicth on/off the CPU and GPU (based on CUDA) implementations of the TMVA Deep Learning module. `tmva-cpu` is enabled by; default if a Blas or CBlas library is found in the system. `tmva-gpu` is enabled when the cmake flag `cuda` is enabled and a compatible Cuda library is found. ; enabled if the corre; - Add possibility to independently configure building of optional pymva part of tmva with flag `-Dpymva=ON|OFF`. - New Cross Validation features:; - Add stratified splitting for cross validation.; - New plotting option in cross validation, average ROC curve. - Bugfixes:; - Fix bug in BDT training with imt=on; - Improved handling of large event numbers in cross validation using deterministic splitting. - Documentation:; - Update TMVA Users' guide. ## 2D Graphics Libraries. - Highlight mode is implemented for `TH1` and for `TGraph` classes. When; highlight mode is on, mouse movement over the bin will be represented; graphically. Histograms bins or graph points will be highlighted. Moreover,; any highlight emits signal `TCanvas::Highlighted()` which allows the user to; react and call their own function. For a better understanding see also; the tutorials `$ROOTSYS/tutorials/hist/hlHisto*.C` and; `$ROOTSYS/tutorials/graphs/hlGraph*.C` .; - Implement fonts embedding for PDF output. The ""EmbedFonts"" option allows to; embed the fonts us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:15875,config,configure,15875,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['config'],['configure']
Modifiability,"aries`` to install all LLVM libraries); a target can appear in a; different distribution than its umbrella, in which case the target will be; exported by the distribution it appears in (and not the distribution its; umbrella appears in). Set *LLVM_STRICT_DISTRIBUTIONS* to ``On`` if you want to; enforce a target appearing in only one distribution and umbrella distributions; being consistent with target distributions. We strongly encourage looking at ``clang/cmake/caches/MultiDistributionExample.cmake``; as an example of configuring multiple distributions. Special Notes for Library-only Distributions; --------------------------------------------. One of the most powerful features of LLVM is its library-first design mentality; and the way you can compose a wide variety of tools using different portions of; LLVM. Even in this situation using *BUILD_SHARED_LIBS* is not supported. If you; want to distribute LLVM as a shared library for use in a tool, the recommended; method is using *LLVM_BUILD_LLVM_DYLIB*, and you can use *LLVM_DYLIB_COMPONENTS*; to configure which LLVM components are part of libLLVM.; Note: *LLVM_BUILD_LLVM_DYLIB* is not available on Windows. Options for Optimizing LLVM; ===========================. There are four main build optimizations that our CMake build system supports.; When performing a bootstrap build it is not beneficial to do anything other than; setting *CMAKE_BUILD_TYPE* to ``Release`` for the stage-1 compiler. This is; because the more intensive optimizations are expensive to perform and the; stage-1 compiler is thrown away. All of the further options described should be; set on the stage-2 compiler either using a CMake cache file, or by prefixing the; option with *BOOTSTRAP_*. The first and simplest to use is the compiler optimization level by setting the; *CMAKE_BUILD_TYPE* option. The main values of interest are ``Release`` or; ``RelWithDebInfo``. By default the ``Release`` option uses the ``-O3``; optimization level, and ``RelWithDebIn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:7363,config,configure,7363,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['config'],['configure']
Modifiability,"arlo (MC) fractions to data histogram; (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993); 219-228). It takes into account both data and Monte Carlo statistical; uncertainties through a likelihood fit using Poisson statistics.; However, the template (MC) predictions are also varied within; statistics, leading to additional contributions to the overall; likelihood. This leads to many more fit parameters (one per bin per; template), but the minimization with respect to these additional; parameters is done analytically rather than introducing them as formal; fit parameters. Some special care needs to be taken in the case of bins; with zero content. **`TMultiDimFit`** implements multi-dimensional function; parametrization for multi-dimensional data by fitting them to; multi-dimensional data using polynomial or Chebyshev or Legendre; polynomial. **`TSpectrum`** contains advanced spectra processing functions for; 1- and 2-dimensional background estimation, smoothing, deconvolution,; peak search and fitting, and orthogonal transformations. **`RooFit`** is a complete toolkit for fitting and data analysis; modeling (see the RooFit User Guide at; ftp://root.cern.ch/root/doc/RooFit\_Users\_Manual\_2.07-29.pdf). **`TSplot`** to disentangle signal from background via an extended; maximum likelihood fit and with a tool to access the quality and; validity of the fit producing distributions for the control variables.; (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369,; 2005). ### Multi-variate Analysis Classes. **`TMultiLayerPerceptron`** is a Neural Network class (see for more; details the chapter ""Neural Networks""). **`TPrincipal`** provides the Principal Component Analysis. **`TRobustEstimator`** is a robust method for minimum covariance; determinant estimator (MCD). **`TMVA`** is a package for multivariate data analysis (see; <https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf> the User's Guide).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:119340,extend,extended,119340,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,"['extend', 'variab']","['extended', 'variables']"
Modifiability,"armType>...; Matches template type parameter types. Example matches T, but not int.; (matcher = templateTypeParmType()); template <typename T> void f(int i);. Matcher<Type>typeMatcher<Type>...; Matches Types in the clang AST. Matcher<Type>typedefTypeMatcher<TypedefType>...; Matches typedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53306,variab,variableArrayType,53306,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variableArrayType']
Modifiability,"array, which must always be present, shall; contain the `x`, `y`, `z`, and t values for the call. The second array,; which is optional and its size depends on the number given to the; **`TF1`** constructor, contains the values that parameterize the; function. For more details, see the **`TF1`** documentation and the; examples below. #### Plotting Python Function. This is an example of a parameter less Python function that is plotted; on a default canvas:. ``` {.cpp}; from ROOT import TF1, TCanvas. def identity( x ):; return x[0]. # create an identity function; f = TF1('pyf1', identity, -1., 1.). # plot the function; c = TCanvas(); f.Draw(); ```. Because no number of parameters is given to the **`TF1`** constructor,; '`0`' (the default) is assumed. This way, the '`identity'` function need; not handle a second argument, which would normally be used to pass the; function parameters. Note that the argument '`x`' is an array of size 4.; The following is an example of a parameterized Python callable instance; that is plotted on a default canvas:. ``` {.cpp}; from ROOT import TF1, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # create a linear function with offset 5, and pitch 2; f = TF1('pyf2',Linear(),-1.,1.,2); f.SetParameters(5.,2.). # plot the function; c = TCanvas(); f.Draw(); ```. Note that this time the constructor is told that there are two; parameters, and note in particular how these parameters are set. It is,; of course, also possible (and preferable if you only use the function; for plotting) to keep the parameters as data members of the callable; instance and use and set them directly from Python. #### Fitting Histograms. Fitting a histogram with a Python function is no more difficult than; plotting: instantiate a **`TF1`** with the Python callable and supply; that **`TF1`** as a parameter to the `Fit()` member function of the; histogram. After the fit, you can retrieve the fit parameters from the; **`TF1`** instance. For",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:26678,parameteriz,parameterized,26678,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['parameteriz'],['parameterized']
Modifiability,"art of register allocation (`phi-node-elimination`), then; `DBG_PHI` instructions are inserted after regalloc finishes. This requires some; maintenance of which register a variable is located in during regalloc, but at; single positions (block entry points) rather than ranges of instructions. An example, before regalloc:. ```text; bb.2:; %2 = PHI %1, %bb.0, %2, %bb.1, debug-instr-number 1; ```. After:. ```text; bb.2:; DBG_PHI $rax, 1; ```. # `LiveDebugValues`. After optimisations and code layout complete, information about variable; values must be translated into variable locations, i.e. registers and stack; slots. This is performed in the [`LiveDebugValues` pass][LiveDebugValues], where; the debug instructions and machine code are separated out into two independent; functions:; * One that assigns values to variable names,; * One that assigns values to machine registers and stack slots. LLVM's existing SSA tools are used to place `PHI`s for each function, between; variable values and the values contained in machine locations, with value; propagation eliminating any unnecessary `PHI`s. The two can then be joined up; to map variables to values, then values to locations, for each instruction in; the function. Key to this process is being able to identify the movement of values between; registers and stack locations, so that the location of values can be preserved; for the full time that they are resident in the machine. # Required target support and transition guide. Instruction referencing will work on any target, but likely with poor coverage.; Supporting instruction referencing well requires:; * Target hooks to be implemented to allow `LiveDebugValues` to follow values; through the machine,; * Target-specific optimisations to be instrumented, to preserve instruction; numbers. ## Target hooks. `TargetInstrInfo::isCopyInstrImpl` must be implemented to recognise any; instructions that are copy-like -- `LiveDebugValues` uses this to identify when; values move between re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:4777,variab,variable,4777,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['variab'],['variable']
Modifiability,"ary has no notion of typedef names vs variable; names: both are returned as identifiers, and the parser is left to decide; whether a specific identifier is a typedef or a variable (tracking this; requires scope information among other things). The parser can do this; translation by replacing tokens returned by the preprocessor with ""Annotation; Tokens"". .. _AnnotationToken:. Annotation Tokens; -----------------. Annotation tokens are tokens that are synthesized by the parser and injected; into the preprocessor's token stream (replacing existing tokens) to record; semantic information found by the parser. For example, if ""``foo``"" is found; to be a typedef, the ""``foo``"" ``tok::identifier`` token is replaced with an; ``tok::annot_typename``. This is useful for a couple of reasons: 1) this makes; it easy to handle qualified type names (e.g., ""``foo::bar::baz<42>::t``"") in; C++ as a single ""token"" in the parser. 2) if the parser backtracks, the; reparse does not need to redo semantic analysis to determine whether a token; sequence is a variable, type, template, etc. Annotation tokens are created by the parser and reinjected into the parser's; token stream (when backtracking is enabled). Because they can only exist in; tokens that the preprocessor-proper is done with, it doesn't need to keep; around flags like ""start of line"" that the preprocessor uses to do its job.; Additionally, an annotation token may ""cover"" a sequence of preprocessor tokens; (e.g., ""``a::b::c``"" is five preprocessor tokens). As such, the valid fields; of an annotation token are different than the fields for a normal token (but; they are multiplexed into the normal ``Token`` fields):. * **SourceLocation ""Location""** --- The ``SourceLocation`` for the annotation; token indicates the first token replaced by the annotation token. In the; example above, it would be the location of the ""``a``"" identifier.; * **SourceLocation ""AnnotationEndLoc""** --- This holds the location of the last; token replaced wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:49452,variab,variable,49452,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['variab'],['variable']
Modifiability,"ary.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global variables, functions and aliases may have an optional runtime preemption; specifier. If a preemption specifier isn't given explicitly, then a; symbol is assumed to be ``dso_preemptable``. ``dso_preemptable``; Indicates that the function or variable may be replaced by a symbol from; outside the linkage unit at runtime. ``dso_local``; The compiler may assume that a function or variable marked as ``dso_local``; will resolve to a symbol within the same linkage unit. Direct access will; be generated even if the definition is not within this compilation unit. .. _namedtypes:. Structure Types; ---------------. LLVM IR allows you to specify both ""identified"" and ""literal"" :ref:`structure; types <t_struct>`. Literal types are uniqued structurally, but identified types; are never uniqued. An :ref:`opaque structural type <t_opaque>` can also be used; to forward declare a type that is not yet available. An example of an identified structure specification is:. .. code-block:: llvm. %mytype = type { %mytype*, i32 }. Prior to the LLVM 3.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:26915,variab,variables,26915,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"as a number of special cases that make it; fast in common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; =================================. Now that we know the sort of problem we want to tackle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for induction variables, and; redefining those only goes so far :). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. # Recursive fib, we could do this before.; def fib(x); if (x < 3) then; 1; else; fib(x-1)+fib(x-2);. # Iterative fib.; def fibi(x); var a = 1, b = 1, c in; (for i = 3, i < x in; c = a + b :; a = b :; b = c) :; b;. # Call it.; fibi(10);. In order to mutate variables, we have to change our existing variables; to use the ""alloca trick"". Once we have that, we'll add our new; operator, then extend Kaleidoscope to support new variable definit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:10467,variab,variables,10467,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"as de facto disactivating the cache; the; other was causing a std::bad_alloc exception to be thrown on workers; when opening a remote file after a local one.    ; Fix several problems in TChain::Draw including. drawing into an existing histogram, i.e.; chain->Draw(""var>>myhist"");. treatment of histogram merging in case of small; statistics, i.e. when; the autobinning is not or only partially active;. usage of existing canvases when different histogram; names are specified;. Fix a problem causing a duplication of the final feedback; object. Fix problem with determining the subdir name in; TFileMerger::MergeRecursive on Windows; Make sure that the default sandbox is under $HOME/.proof; Fix a problem with dataset validation in multi-level; master setups; Fix a problem with ordinal numbers in multi-master setups; Fix a problem with defining the internal paths for; executables when configuring with '--prefix'; Fix backward-incompatibility issue giving the error; message  ""unknown action code: 5112""; Fix a few problems with file retrieval from the cache; Fix a problem with iteration of a std::list occasionally; causing seg-violations in TXSocket; Fix a few problems preventing correct usage of entry; lists in PROOF; Fix a problem with the permissions of the credentials; files created under <sandbox>/.creds; Fix a potential problem while determining the log paths; in log retrieval. Do not use vnsprintf in the XrdProofd plug-in, potential; source of deadlocks.; Fix a problem overwriting the local environment settings; for the xrootd sec modules; In XrdProofdProofServMgr::Destroy, fix segv in message; creation when all sessions are destroyed at once; Fix a problem determining the relative time order of old; sessions for log retrieval; In TProof::HandleInputMessage, fix possible double delete; after kPROOF_STOPPROCESS; Fix a couple of issues on reconnection to a running; session (some dialog buttons not in the correct state; logs not; correctly redirected); Fix a problem creati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:9609,config,configuring,9609,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,2,"['config', 'sandbox']","['configuring', 'sandbox']"
Modifiability,"as long as the non-ARC side is careful about; transferring ownership. - It avoids unnecessary indirection for sufficiently small types that; the C ABI would prefer to pass in registers. - Given that struct arguments must be produced at +1 to satisfy C's; semantics of initializing the local parameter variable, transferring; ownership of that copy to the callee is generally better for ARC; optimization, since otherwise there will be releases in the caller; that are much harder to pair with transfers in the callee. Breaking compatibility with existing Objective-C++ structures was; considered an acceptable cost, as most Objective-C++ code does not have; binary-compatibility requirements. Any existing code which cannot accept; this compatibility break, which is necessarily Objective-C++, should; force the use of the standard C++ ABI by declaring an empty (but; non-defaulted) destructor. .. _arc.ownership.inference:. Ownership inference; -------------------. .. _arc.ownership.inference.variables:. Objects; ^^^^^^^. If an object is declared with retainable object owner type, but without an; explicit ownership qualifier, its type is implicitly adjusted to have; ``__strong`` qualification. As a special case, if the object's base type is ``Class`` (possibly; protocol-qualified), the type is adjusted to have ``__unsafe_unretained``; qualification instead. .. _arc.ownership.inference.indirect_parameters:. Indirect parameters; ^^^^^^^^^^^^^^^^^^^. If a function or method parameter has type ``T*``, where ``T`` is an; ownership-unqualified retainable object pointer type, then:. * if ``T`` is ``const``-qualified or ``Class``, then it is implicitly; qualified with ``__unsafe_unretained``;; * otherwise, it is implicitly qualified with ``__autoreleasing``. .. admonition:: Rationale. ``__autoreleasing`` exists mostly for this case, the Cocoa convention for; out-parameters. Since a pointer to ``const`` is obviously not an; out-parameter, we instead use a type more useful for passing arra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:64780,variab,variables,64780,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"as operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform dependent implementation is in the; **`TMutexImp`** and **`TConditionImp`** classes. ### TThread for Pedestrians. To run a thread in ROOT, follow these steps:. 1. Initialization. Add these lines to your `rootlogon.C`:. ``` {.cpp}; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; ```. This loads the library with the **`TThread`** class and the `pthread`; specific implementation file for `Posix` threads. 2. Coding. Define a function (e.g. `void* UserFun(void* UserArgs))` that should run; as a thread. The code for the examples is at the web site of the authors; (Jörn Adamczewski, Marc Hemberger). After downloading the code from this; site, you can ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3993,variab,variable,3993,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['variab'],['variable']
Modifiability,"as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've been somewhat vague in our; explanation of what the rewrite rules are actually rewriting. We've referred to; ""code"", but code can be represented both as raw source text and as an abstract; syntax tree. So, which one is it?. Ideally, we'd be rewriting the input AST to a new AST, but clang's AST is not; terribly amenable to this kind of transformation. So, we compromise: we express; our patterns and the names that they bind in terms of the AST, but our changes; in terms of source code text. We've designed Transformer's language to bridge; the gap between the two representations, in an attempt to minimize the user's; need to reason about source code locations and other, low-level syntactic; details. Range Selectors; ^^^^^^^^^^^^^^^. Transformer provides a small API for describing source ranges: the; ``RangeSelector`` combinators. These ranges are most commonly used to specify the; source code affected by an edit and to extract source code in constructing new; text. Roughly, there are two kinds of range combin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:9481,rewrite,rewrite,9481,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,"asOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<UnresolvedMemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<VarDecl>hasAutomaticStorageDuration; Matches a variable declaration that has automatic storage duration. Example matches x, but not y, z, or a.; (matcher = varDecl(hasAutomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:124419,variab,variable,124419,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"ase that you want to match double; braces explicitly from the input, you can use something ugly like; ``{{[}][}]}}`` as your pattern. Or if you are using the repetition count; syntax, for example ``[[:xdigit:]]{8}`` to match exactly 8 hex digits, you; would need to add parentheses like this ``{{([[:xdigit:]]{8})}}`` to avoid; confusion with FileCheck's closing double-brace. FileCheck String Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. It is often useful to match a pattern and then verify that it occurs again; later in the file. For codegen tests, this can be useful to allow any; register, but verify that that register is used consistently later. To do; this, :program:`FileCheck` supports string substitution blocks that allow; string variables to be defined and substituted into patterns. Here is a simple; example:. .. code-block:: llvm. ; CHECK: test5:; ; CHECK: notw	[[REGISTER:%[a-z]+]]; ; CHECK: andw	{{.*}}[[REGISTER]]. The first check line matches a regex ``%[a-z]+`` and captures it into the; string variable ``REGISTER``. The second line verifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operands of ``op`` to be the same register,; and don't care exactly which register it is. If ``--enable-var-scope`` is in effect, variables with names that; start with ``$`` are considered to be global. All others variables are; local. All local variables get undefined",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:26682,variab,variable,26682,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability,"ases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Objective-C; instance methods. - ``objc_property``: Can be used to apply attributes to ``@property``; declarations. - ``block``: Can be used to apply attributes to block declarations. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:184285,variab,variable,184285,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"ason not to. Using this technique; is:. - Proven and well tested: clang uses this technique; for local mutable variables. As such, the most common clients of LLVM; are using this to handle a bulk of their variables. You can be sure; that bugs are found fast and fixed early.; - Extremely Fast: mem2reg has a number of special cases that make it; fast in common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; =================================. Now that we know the sort of problem we want to tackle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for induction variables, and; redefining those only goes so far :). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. # Recursive fib, we could do this before.; def fib(x); if (x < 3) then; 1; else; fib(x-1)+fib(x-2);. # Iterative fib.; def fibi(x); var ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:10147,extend,extend,10147,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,2,"['extend', 'variab']","['extend', 'variables']"
Modifiability,"ass and depending on the type of input data. #### Available fit methods. * **Least-square fit**: `Fitter::LeastSquare(const BinData & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional; *extended* boolean flag as *false*. This method is implemented by the class `ROOT::Fit:::PoissonLikelihoodFCN`.; * **Un-Binned likelihood fit**: `Fitter::LikelihoodFit(const UnBindata &)`. The user needs to pass an `UnBinData` object. By default the fit is not extended (i.e. the normalization is not fitted to the; data). As above the user can select an extended likelihood fit by passing the optional; *extended* boolean flag as *true*. This method is implemented using the class `LogLikelihoodFCN`; * **Linear Fit**: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the *Matrix* library), if the model function is linear in the; parameters. #### Customised Fit methods. Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize.; In this case, the user does not really need to build as input a `ROOT::Fit` data set and model function as we described before. He can implements its own version of the method function using on its own; data set objects and functions. In this case `ROOT::Fit::Fitter::SetFCN` is used to set the method function and `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:46556,extend,extended,46556,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['extend'],['extended']
Modifiability,"ass of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Formula No (0) − The discrimination formula. ParRanges No () − Parameter ranges. FitMethod No MINUIT MC, GA, SA, MINUIT Optimisation Method. Converger No None None, MINUIT FitMethod uses Converger to improve result. Configuration options for MVA method :. Configuration options reference for MVA method: LD. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Configuration options for MVA method :. Configuration options reference for MVA method: SVM. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before trainin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:6607,variab,variable,6607,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variable']
Modifiability,"ass with the `ClassDef` macro; has the ability to obtain a **`TClass`** with the `IsA` method. ``` {.cpp}; TClass *cl = obj->IsA();; ```. It returns a **`TClass`**. In addition, an object can directly get the; class name and the base classes by:. ``` {.cpp}; const char* name = obj->ClassName();; ```. If the class is a descendent of **`TObject`**, you can check if an; object inherits from a specific class, you can use the `InheritsFrom`; method. This method returns `kTrue` if the object inherits from the; specified class name or **`TClass`**. ``` {.cpp}; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ```. ROOT and `Cling` rely on reflection and the class dictionary to identify; the type of a variable at run time. With **`TObject`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ROOT collection, it must be a descendent of; **`TObject`**. This is convenient if you want to store objects of; different classes in the same collection and execute the method of the; same name on all members of the collection. For example, the list of; graphics primitives are in a ROOT collection called **`TList`**. When; the canvas is drawn, the `Paint` method is executed on the entire; collection. Each member may be a different class, and if the `Paint`; method is not implemented, **`TObject::Paint`** will be executed. ### Input/Output. The `TObject::Write` method is the interface to the ROOT I/O system. It; streams the object into a buffer using the `Streamer` method. It; supports cycle numbers and automatic schema evolution. See; ""Input/Output"". ### Paint/Draw. These graphics methods ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:1875,inherit,inheritance,1875,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['inherit'],['inheritance']
Modifiability,"ass.; =CompileUnit: A compile unit.; =EntryPoint: A subroutine entry point.; =Enumeration: An enumeration.; =Function: A function.; =FunctionType: A function pointer.; =InlinedFunction: An inlined function.; =Label: A label.; =LexicalBlock: A lexical block.; =Namespace: A namespace.; =Root: The element representing the main scope.; =Structure: A structure.; =Subprogram: A subprogram.; =Template: A template definition.; =TemplateAlias: A template alias.; =TemplatePack: A template pack.; =TryBlock: An exception try block.; =Union: A union. SYMBOLS; ^^^^^^^; The following options allow printing of symbols that match the given <kind>. .. option:: --select-symbols=<kind[,kind,...]>. With **kind** being one of the options in the following list. .. code-block:: text. =CallSiteParameter: A call site parameter.; =Constant: A constant symbol.; =Inheritance: A base class.; =Member: A member class.; =Parameter: A parameter to function.; =Unspecified: Unspecified parameters to function.; =Variable: A variable. TYPES; ^^^^^; The following options allow printing of types that match the given <kind>. .. option:: --select-types=<kind[,kind,...]>. With **kind** being one of the options in the following list. .. code-block:: text. =Base: Base type (integer, boolean, etc).; =Const: Constant specifier.; =Enumerator: Enumerator.; =Import: Import declaration.; =ImportDeclaration: Import declaration.; =ImportModule: Import module.; =Pointer: Pointer type.; =PointerMember: Pointer to member function.; =Reference: Reference type.; =Restrict: Restrict specifier.; =RvalueReference: R-value reference.; =Subrange: Array subrange.; =TemplateParam: Template parameter.; =TemplateTemplateParam: Template template parameter.; =TemplateTypeParam: Template type parameter.; =TemplateValueParam: Template value parameter.; =Typedef: Type definition.; =Unspecified: Unspecified type.; =Volatile: Volatile specifier. .. _compare_:. COMPARE; ~~~~~~~; When dealing with debug information, there are situations whe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:18411,variab,variable,18411,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['variab'],['variable']
Modifiability,"assManager.cpp:1564:0: (anonymous namespace)::MPPassManager::runOnModule(llvm::Module&); 139607 2 [ 0.147345, 0.315994, 0.315994, 0.315994, 0.315994] 0.463340 LegacyPassManager.cpp:1530:0: llvm::FPPassManager::runOnModule(llvm::Module&); 139605 21 [ 0.000002, 0.000002, 0.102593, 0.213336, 0.213336] 0.463331 LegacyPassManager.cpp:1491:0: llvm::FPPassManager::runOnFunction(llvm::Function&); 139563 26096 [ 0.000002, 0.000002, 0.000037, 0.000063, 0.000215] 0.225708 LegacyPassManager.cpp:1083:0: llvm::PMDataManager::findAnalysisPass(void const*, bool); 108055 188 [ 0.000002, 0.000120, 0.001375, 0.004523, 0.062624] 0.159279 MachineFunctionPass.cpp:38:0: llvm::MachineFunctionPass::runOnFunction(llvm::Function&); 62635 22 [ 0.000041, 0.000046, 0.000050, 0.126744, 0.126744] 0.127715 X86TargetMachine.cpp:242:0: llvm::X86TargetMachine::getSubtargetImpl(llvm::Function const&) const. Instrumentation Attributes; ``````````````````````````. The other way is to use configuration files for selecting which functions; should always be instrumented by the compiler. This gives us a way of ensuring; that certain functions are either always or never instrumented by not having to; add the attribute to the source. To use this feature, you can define one file for the functions to always; instrument, and another for functions to never instrument. The format of these; files are exactly the same as the SanitizerLists files that control similar; things for the sanitizer implementations. For example:. ::. # xray-attr-list.txt; # always instrument functions that match the following filters:; [always]; fun:main. # never instrument functions that match the following filters:; [never]; fun:__cxx_*. Given the file above we can re-build by providing it to the; ``-fxray-attr-list=`` flag to clang. You can have multiple files, each defining; different sets of attribute sets, to be combined into a single list by clang. The XRay stack tool; -------------------. Given a trace, and optionally an instrumentat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst:10015,config,configuration,10015,interpreter/llvm-project/llvm/docs/XRayExample.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst,1,['config'],['configuration']
Modifiability,"asses -----------------; class RegisterInfo {; }; ------------- Defs -----------------; def X0 {	// RegisterInfo; }; def X1 {	// RegisterInfo; }. ## Inheritance. Like many other languages with classes, a class in TableGen can inherit properties of another class. ```tablegen; class C {}; class D : C {}; ```. ------------- Classes -----------------; class C {; }; class D {	// C; }; ------------- Defs -----------------. Inheritance is done by putting the class you want to inherit from after `:`, before the opening `{`. You'll know that `D` inherits from `C` by the `// C` comment on the `class D {` line in the output. Not very interesting though, what are we actually inheriting? The members of the parent class. ```tablegen; class C {; int a;; }; class D : C {}; ```. ------------- Classes -----------------; class C {; int a = ?;; }; class D {	// C; int a = ?;; }; ------------- Defs -----------------. Note that `D` now has the `a` member which was defined in the class `C`. You can inherit from multiple classes. In that case the order that that happens in matches the order you write the class names after the `:`. ```tablegen; class C {; int a = 1;; }; class D {; int a = 2;; }; class E : C, D {}; ```. ------------- Classes -----------------; class C {; int a = 1;; }; class D {; int a = 2;; }; class E {	// C D; int a = 2;; }; ------------- Defs -----------------. Class `E` first inherits from class `C`. This gives `E` a member `a` with value `1`. Then it inherits from class `D` which also has a member `a` but with a value of `2`. Meaning the final value of `E`'s `a` is `2`. When a member has the same name this is handled on a ""last one in wins"" basis. Assuming the types match. ```tablegen; class C {; string a = """";; }; class D {; int a = 2;; }; class E : C, D {}; ```. <stdin>:7:14: error: New definition of 'a' of type 'int' is incompatible with previous definition of type 'string'; class E : C, D {}; ^. When they don't match, we get an error. Luckily for us, we're about to le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:3737,inherit,inherit,3737,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['inherit'],['inherit']
Modifiability,"asses inheriting from `RooAbsArg` when reading; older RooFit models from a file. These warnings are harmless and can be avoided by incrementing also the class version of the inheriting class. ### Compile-time protection against creating empty `RooCmdArg`s from strings. The implicit [RooCmdArg](https://root.cern/doc/v626/classRooCmdArg.html) constructor from `const char*` was removed to avoid the accidental construction of meaningless RooCmdArgs that only have a name but no payload.; This causes new compiler errors in your code if you pass a string instead of a RooCmdArg to various RooFit functions, such as [RooAbsPdf::fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5).; If this happens, please consult the documentation of [fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5) to check which of the [free functions in the `RooFit` namespace](https://root.cern/doc/v626/group__CmdArgs.html) you need to use to achieve the desired configuration. **Example** of an error that is now caught at compile time: confusing the [RooAbsPdf::fitTo()]() function signature with the one of [TH1::Fit()](https://root.cern/doc/v626/classTH1.html#a63eb028df86bc86c8e20c989eb23fb2a) and passing the fit range name as a string literal:. ```C++; pdf.fitTo(*data, ""r""); // ERROR!; // Will not compile anymore, as `""r""` is not a recognized command and will be ignored!; // Instead, to restrict to a range called ""r"", use:; pdf.fitTo(*data, RooFit::Range(""r""));; ```. ## TMVA. ### SOFIE : Code generation for fast inference of Deep Learning models. ROOT/TMVA SOFIE (“System for Optimized Fast Inference code Emit”) is a new package introduced in this release that generates C++ functions easily invokable for the fast inference of trained neural network models. It takes ONNX model files as inputs and produces C++ header files that can be included and utilized in a “plug-and-go” style.; This is a new development and it is currently st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:31914,config,configuration,31914,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['config'],['configuration']
Modifiability,"asses you will encounter in this tutorial; have such graphical interfaces. We will not comment further on this,; just be aware of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with the options in the; `.rootrc` file. Examples of the tunable parameters are the ones related; to the operating and window system, to the fonts to be used, to the; location of start-up files. At start-up, ROOT looks for a `.rootrc` file; in the following order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:17533,adapt,adaptive,17533,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['adapt'],['adaptive']
Modifiability,"assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; root [13] TF1 f2(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; root [14] f2.SetParameter(0,1);; root [15] f2.SetParameter(1,1);; root [16] f2.Draw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to have it; at you disposal whenever you need it. To extend a little bit on the above example, consider a more complex; function you would like to define. You can also do this using standard; `C` or `C++` code. Consider the example below, which calculates and displays the; interference pattern produced by light falling on a multiple slit.; Please do not type in the example below at the ROOT command line, there; is a much simpler way: Make sure you have the file `slits.C` on disk,; and type `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the lines in the file will be; executed one after the other. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:4966,extend,extend,4966,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['extend'],['extend']
Modifiability,"at is using it (the User_ class; is a base class for all nodes in the LLVM graph that can refer to ``Value``\ s).; This use list is how LLVM represents def-use information in the program, and is; accessible through the ``use_*`` methods, shown below. Because LLVM is a typed representation, every LLVM ``Value`` is typed, and this; Type_ is available through the ``getType()`` method. In addition, all LLVM; values can be named. The ""name"" of the ``Value`` is a symbolic string printed; in the LLVM code:. .. code-block:: llvm. %foo = add i32 1, 2. .. _nameWarning:. The name of this instruction is ""foo"". **NOTE** that the name of any value may; be missing (an empty string), so names should **ONLY** be used for debugging; (making the source code easier to read, debugging printouts), they should not be; used to keep track of values or map between them. For this purpose, use a; ``std::map`` of pointers to the ``Value`` itself instead. One important aspect of LLVM is that there is no distinction between an SSA; variable and the operation that produces it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument, for example) is represented as a direct pointer to the instance of the; class that represents this value. Although this may take some getting used to,; it simplifies the representation and makes it easier to manipulate. .. _m_Value:. Important Public Members of the ``Value`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``Value::use_iterator`` - Typedef for iterator over the use-list; | ``Value::const_use_iterator`` - Typedef for const_iterator over the; use-list; | ``unsigned use_size()`` - Returns the number of users of the value.; | ``bool use_empty()`` - Returns true if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:142742,variab,variable,142742,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"at of its parent. Variables used within the scope of the compound; statement are bound to the Block in the normal manner with the; exception of those in automatic (stack) storage. Thus one may access; functions and global variables as one would expect, as well as static; local variables. [testme]. Local automatic (stack) variables referenced within the compound; statement of a Block are imported and captured by the Block as const; copies. The capture (binding) is performed at the time of the Block; literal expression evaluation. The compiler is not required to capture a variable if it can prove; that no references to the variable will actually be evaluated.; Programmers can force a variable to be captured by referencing it in a; statement at the beginning of the Block, like so:. .. code-block:: c. (void) foo;. This matters when capturing the variable has side-effects, as it can; in Objective-C or C++. The lifetime of variables declared in a Block is that of a function;; each activation frame contains a new copy of variables declared within; the local scope of the Block. Such variable declarations should be; allowed anywhere [testme] rather than only when C99 parsing is; requested, including for statements. [testme]. Block literal expressions may occur within Block literal expressions; (nest) and all variables captured by any nested blocks are implicitly; also captured in the scopes of their enclosing Blocks. A Block literal expression may be used as the initialization value for; Block variables at global or local static scope. The Invoke Operator; ===================. Blocks are :block-term:`invoked` using function call syntax with a; list of expression parameters of types corresponding to the; declaration and returning a result type also according to the; declaration. Given:. .. code-block:: c. int (^x)(char);; void (^z)(void);; int (^(*y))(char) = &x;. the following are all legal Block invocations:. .. code-block:: c. x('a');; (*y)('a');; (true ? x : *y)('a'). The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:5158,variab,variables,5158,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,2,['variab'],['variables']
Modifiability,"at some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enabled by default; in all non-GC Objective-C modes. .. _objc-fixed-enum:. Enumerations with a fixed underlying type; -----------------------------------------. Clang provides support for C++11 enumerations with a fixed underlying type; within Objective-C. For example, one can write an enumeration type as:. .. code-block:: c++. typedef enum : unsigned char { Red, Green, Blue } Color;. This specifies that the underlying type, which is used to store the enumeration; value, is ``unsigned char``. Use `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:73322,variab,variable,73322,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variable']
Modifiability,"at some of the generalizations may also benefit other DWARF; issues that have been raised. The remainder of this section enumerates the extensions and provides motivation; for each in terms of heterogeneous debugging. .. _amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack:. 2.1 Allow Location Description on the DWARF Expression Stack; ------------------------------------------------------------. DWARF Version 5 does not allow location descriptions to be entries on the DWARF; expression stack. They can only be the final result of the evaluation of a DWARF; expression. However, by allowing a location description to be a first-class; entry on the DWARF expression stack it becomes possible to compose expressions; containing both values and location descriptions naturally. It allows objects to; be located in any kind of memory address space, in registers, be implicit; values, be undefined, or a composite of any of these. By extending DWARF carefully, all existing DWARF expressions can retain their; current semantic meaning. DWARF has implicit conversions that convert from a; value that represents an address in the default address space to a memory; location description. This can be extended to allow a default address space; memory location description to be implicitly converted back to its address; value. This allows all DWARF Version 5 expressions to retain their same meaning,; while enabling the ability to explicitly create memory location descriptions in; non-default address spaces and generalizing the power of composite location; descriptions to any kind of location description. For those familiar with the definition of location descriptions in DWARF Version; 5, the definitions in these extensions are presented differently, but does in; fact define the same concept with the same fundamental semantics. However, it; does so in a way that allows the concept to extend to support address spaces,; bit addressing, the ability for composite location descrip",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:5632,extend,extending,5632,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extending']
Modifiability,"at those in; the ``alloc``, ``copy``, ``mutableCopy``, and ``new`` families provide access; to :ref:`retained objects <arc.object.operands.retained-return-values>`. This; can be overridden by annotating the property with ``ns_returns_not_retained``; attribute. .. _arc.family.semantics.init:. Semantics of ``init``; ^^^^^^^^^^^^^^^^^^^^^. Methods in the ``init`` family implicitly :ref:`consume; <arc.objects.operands.consumed>` their ``self`` parameter and :ref:`return a; retained object <arc.object.operands.retained-return-values>`. Neither of; these properties can be altered through attributes. A call to an ``init`` method with a receiver that is either ``self`` (possibly; parenthesized or casted) or ``super`` is called a :arc-term:`delegate init; call`. It is an error for a delegate init call to be made except from an; ``init`` method, and excluding blocks within such methods. As an exception to the :ref:`usual rule <arc.misc.self>`, the variable ``self``; is mutable in an ``init`` method and has the usual semantics for a ``__strong``; variable. However, it is undefined behavior and the program is ill-formed, no; diagnostic required, if an ``init`` method attempts to use the previous value; of ``self`` after the completion of a delegate init call. It is conventional,; but not required, for an ``init`` method to return ``self``. It is undefined behavior for a program to cause two or more calls to ``init``; methods on the same object, except that each ``init`` method invocation may; perform at most one delegate init call. .. _arc.family.semantics.result_type:. Related result types; ^^^^^^^^^^^^^^^^^^^^. Certain methods are candidates to have :arc-term:`related result types`:. * class methods in the ``alloc`` and ``new`` method families; * instance methods in the ``init`` family; * the instance method ``self``; * outside of ARC, the instance methods ``retain`` and ``autorelease``. If the formal result type of such a method is ``id`` or protocol-qualified; ``id``, or a t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:73447,variab,variable,73447,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['variab'],['variable']
Modifiability,"at we ignore the value computed by the body, but don't; // allow an error.; if (!Body->codegen()); return nullptr;. Now the code starts to get more interesting. Our 'for' loop introduces a; new variable to the symbol table. This means that our symbol table can; now contain either function arguments or loop variables. To handle this,; before we codegen the body of the loop, we add the loop variable as the; current value for its name. Note that it is possible that there is a; variable of the same name in the outer scope. It would be easy to make; this an error (emit an error and return null if there is already an; entry for VarName) but we choose to allow shadowing of variables. In; order to handle this correctly, we remember the Value that we are; potentially shadowing in ``OldVal`` (which will be null if there is no; shadowed variable). Once the loop variable is set into the symbol table, the code; recursively codegen's the body. This allows the body to use the loop; variable: any references to it will naturally find it in the symbol; table. .. code-block:: c++. // Emit the step value.; Value *StepVal = nullptr;; if (Step) {; StepVal = Step->codegen();; if (!StepVal); return nullptr;; } else {; // If not specified, use 1.0.; StepVal = ConstantFP::get(*TheContext, APFloat(1.0));; }. Value *NextVar = Builder->CreateFAdd(Variable, StepVal, ""nextvar"");. Now that the body is emitted, we compute the next value of the iteration; variable by adding the step value, or 1.0 if it isn't present.; '``NextVar``' will be the value of the loop variable on the next; iteration of the loop. .. code-block:: c++. // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Convert condition to a bool by comparing non-equal to 0.0.; EndCond = Builder->CreateFCmpONE(; EndCond, ConstantFP::get(*TheContext, APFloat(0.0)), ""loopcond"");. Finally, we evaluate the exit value of the loop, to determine whether; the loop should exit. This mirrors the conditio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:23706,variab,variable,23706,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability,"at, and 0.51ULP for half. Float; instruction does not natively support denormal; inputs. :ref:`llvm.stacksave.p5 <int_stacksave>` Implemented, must use the alloca address space.; :ref:`llvm.stackrestore.p5 <int_stackrestore>` Implemented, must use the alloca address space. :ref:`llvm.get.fpmode.i32 <int_get_fpmode>` The natural floating-point mode type is i32. This; implemented by extracting relevant bits out of the MODE; register with s_getreg_b32. The first 10 bits are the; core floating-point mode. Bits 12:18 are the exception; mask. On gfx9+, bit 23 is FP16_OVFL. Bitfields not; relevant to floating-point instructions are 0s. :ref:`llvm.get.rounding<int_get_rounding>` AMDGPU supports two separately controllable rounding; modes depending on the floating-point type. One; controls float, and the other controls both double and; half operations. If both modes are the same, returns; one of the standard return values. If the modes are; different, returns one of :ref:`12 extended values; <amdgpu-rounding-mode-enumeration-values-table>`; describing the two modes. To nearest, ties away from zero is not a supported; mode. The raw rounding mode values in the MODE; register do not exactly match the FLT_ROUNDS values,; so a conversion is performed. llvm.amdgcn.wave.reduce.umin Performs an arithmetic unsigned min reduction on the unsigned values; provided by each lane in the wavefront.; Intrinsic takes a hint for reduction strategy using second operand; 0: Target default preference,; 1: `Iterative strategy`, and; 2: `DPP`.; If target does not support the DPP operations (e.g. gfx6/7),; reduction will be performed using default iterative strategy.; Intrinsic is currently only implemented for i32. llvm.amdgcn.wave.reduce.umax Performs an arithmetic unsigned max reduction on the unsigned values; provided by each lane in the wavefront.; Intrinsic takes a hint for reduction strategy using second operand; 0: Target default preference,; 1: `Iterative strategy`, and; 2: `DPP`.; If targe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:37951,extend,extended,37951,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['extend'],['extended']
Modifiability,"at,; in the event an application does not supply such function or; table, the facility still operates, and performs whatever part of; its purpose remains meaningful. (For example, a function in a library to compute square roots has; a purpose that is entirely well-defined independent of the; application. Therefore, Subsection 2d requires that any; application-supplied function or table used by this function must; be optional: if the application does not supply it, the square; root function must still compute square roots.). These requirements apply to the modified work as a whole. If; identifiable sections of that work are not derived from the Library,; and can be reasonably considered independent and separate works in; themselves, then this License, and its terms, do not apply to those; sections when you distribute them as separate works. But when you; distribute the same sections as part of a whole which is a work based; on the Library, the distribution of the whole must be on the terms of; this License, whose permissions for other licensees extend to the; entire whole, and thus to each and every part regardless of who wrote; it. Thus, it is not the intent of this section to claim rights or contest; your rights to work written entirely by you; rather, the intent is to; exercise the right to control the distribution of derivative or; collective works based on the Library. In addition, mere aggregation of another work not based on the Library; with the Library (or with a work based on the Library) on a volume of; a storage or distribution medium does not bring the other work under; the scope of this License. 3. You may opt to apply the terms of the ordinary GNU General Public; License instead of this License to a given copy of the Library. To do; this, you must alter all the notices that refer to this License, so; that they refer to the ordinary GNU General Public License, version 2,; instead of to this License. (If a newer version than version 2 of the; ordinary GN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:10254,extend,extend,10254,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,2,['extend'],['extend']
Modifiability,"at; restriction can normally be enforced. However it may in some cases be necessary; for a function to perform a forbidden cast to conform with an external API; (e.g. the ``allocate`` member function of a standard library allocator). Such; functions may be :ref:`ignored <cfi-ignorelist>`. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Non-Virtual Member Function Call Checking; =========================================. This scheme checks that non-virtual calls take place using an object of; the correct dynamic type; that is, the dynamic type of the called object; must be a derived class of the static type of the object used to make the; call. The checks are currently only introduced where the object is of a; polymorphic class type. This CFI scheme can be enabled on its own using; ``-fsanitize=cfi-nvcall``. For this scheme to work, all translation units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. .. _cfi-strictness:. Strictness; ----------. If a class has a single non-virtual base and does not introduce or override; virtual member functions or fields other than an implicitly defined virtual; destructor, it will have the same layout and virtual function semantics as; its base. By default, casts to such classes are checked as if they were made; to the least derived such class. Casting an instance of a base class to such a derived class is technically; undefined behavior, but it is a relatively common hack for intro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:7427,polymorphi,polymorphic,7427,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['polymorphi'],['polymorphic']
Modifiability,"ata !20); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !20 = !DIExpression(DW_OP_LLVM_implicit_pointer)). IR for ""**ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !21); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64); !20 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !21 = !DIExpression(DW_OP_LLVM_implicit_pointer,; DW_OP_LLVM_implicit_pointer)). DWARF specifies three kinds of simple location descriptions: Register, memory,; and implicit location descriptions. Note that a location description is; defined over certain ranges of a program, i.e the location of a variable may; change over the course of the program. Register and memory location; descriptions describe the *concrete location* of a source variable (in the; sense that a debugger might modify its value), whereas *implicit locations*; describe merely the actual *value* of a source variable which might not exist; in registers or in memory (see ``DW_OP_stack_value``). A ``llvm.dbg.declare`` intrinsic describes an indirect value (the address) of a; source variable. The first operand of the intrinsic must be an address of some; kind. A DIExpression attached to the intrinsic refines this address to produce a; concrete location for the source variable. A ``llvm.dbg.value`` intrinsic describes the direct value of a source variable.; The first operand of the intrinsic may be a direct or indirect value. A; DIExpression attached to the intrinsic refines the first operand to produce a; direct value. For example, if the first operand is an indirect value, it may be; necessary to insert ``DW_OP_deref`` into the D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:267486,variab,variable,267486,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"atches Y but not X; (matcher = cxxRecordDecl(isExpansionInSystemHeader()); #include <SystemHeader.h>; class X {};; SystemHeader.h:; class Y {};. Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>. Matcher<Type>booleanType; Matches type bool. Given; struct S { bool func(); };; functionDecl(returns(booleanType())); matches ""bool func();"". Matcher<Type>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<Type>equalsNodeconst Type* Other; Matches if a node equals another node. Type has pointer identity in the AST. Matcher<Type>realFloatingPointType; Matches any real floating-point type (float, double, long double). Given; int i;; float f;; realFloatingPointType(); matches ""float f"" but not ""int i"". Matcher<Type>voidType; Matches type void. Given; struct S { void func(); };; functionDecl(returns(voidType())); matches ""void func();"". Matcher<UnaryExprOrTypeTraitExpr>ofKindUnaryExprOrTypeTrait Kind; Matches unary expressions of a certain kind. Given; int x;; int s = sizeof(x) + alignof(x); unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf)); matches sizeof(x). If the matcher is use from clang-query, UnaryExprOrTypeTrait parameter; should be passed as a quoted string. e.g., ofKind(""UETT_SizeOf""). Matcher<UnaryOperator>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:121981,variab,variable,121981,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"atches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxFoldExpr(hasOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<BinaryOperator>isAssignmentOperator; Matches all kinds of assignment operators. Example 1: matches a += b (matcher = binaryOperator(isAssignmentOperator())); if (a == b); a += b;. Example 2: matches s1 = s2; (matcher = cxxOperatorCallExpr(isAssignmentOperator())); struct S { S& operator=(const S&); };; void x() { S s1, s2; s1 = s2; }. Matcher<BinaryOperator>isComparisonOperator; Matches comparison operators. Example 1: matches a == b (matcher = binaryOperator(isComparisonOperator())); if (a == b); a += b;. Example 2: matches s1 < s2; (matcher = cxxOperatorCallExpr(isComparisonOperator())); struct S { bool operator<(const S& other); };; void x(S s1, S s2) { bool b1 = s1 < s2; }. Matcher<CXXBaseSpecifier>isPrivate; Matches private C++ declarations and C++ base specifers that specify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isVir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:56674,inherit,inheritance,56674,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['inherit'],['inheritance']
Modifiability,"ate memory. OS X Alpha Checkers. Name, DescriptionExample. alpha.osx.cocoa.DirectIvarAssignment; (ObjC); Check that Objective C properties follow the following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMet",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8055,variab,variables,8055,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['variab'],['variables']
Modifiability,"ate the :doc:`coding standards<CodingStandards>` to allow the new; features we've explicitly approved in the RFC. * Start using the new features in LLVM's codebase. Here's a `sample RFC; <https://discourse.llvm.org/t/rfc-migrating-past-c-11/50943>`_ and the; `corresponding change <https://reviews.llvm.org/D57264>`_. .. _ci-usage:. Working with the CI system; --------------------------. The main continuous integration (CI) tool for the LLVM project is the; `LLVM Buildbot <https://lab.llvm.org/buildbot/>`_. It uses different *builders*; to cover a wide variety of sub-projects and configurations. The builds are; executed on different *workers*. Builders and workers are configured and; provided by community members. The Buildbot tracks the commits on the main branch and the release branches.; This means that patches are built and tested after they are merged to the these; branches (aka post-merge testing). This also means it's okay to break the build; occasionally, as it's unreasonable to expect contributors to build and test; their patch with every possible configuration. *If your commit broke the build:*. * Fix the build as soon as possible as this might block other contributors or; downstream users.; * If you need more time to analyze and fix the bug, please revert your change to; unblock others. *If someone else broke the build and this blocks your work*. * Comment on the code review in `GitHub <https://github.com/llvm/llvm-project/pulls>`_; (if available) or email the author, explain the problem and how this impacts; you. Add a link to the broken build and the error message so folks can; understand the problem.; * Revert the commit if this blocks your work, see revert_policy_ . *If a build/worker is permanently broken*. * 1st step: contact the owner of the worker. You can find the name and contact; information for the *Admin* of worker on the page of the build in the; *Worker* tab:. .. image:: buildbot_worker_contact.png. * 2nd step: If the owner does not respond o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:36559,config,configuration,36559,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['config'],['configuration']
Modifiability,"ate we're; looking for is the contents of the heap. And when we try to model such; typestates (complex in this specific manner, i.e. heap-like) in any checker, we; have a choice between re-doing this modeling in every such checker (which is; something analyzer is indeed good at, but at a price of making checkers heavy); or instead relying on the Store to do exactly what it's designed to do. > I think the key criterion here is: ""is the region accessible from outside; > the library"". That is, does the library expose the region as a pointer that; > can be read to or written from in the client program? If so, then it makes; > sense for this to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > for them just to get invalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:15959,variab,variables,15959,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['variab'],['variables']
Modifiability,ate.h; openmp/libomptarget/DeviceRTL/include/Synchronization.h; openmp/libomptarget/DeviceRTL/include/Types.h; openmp/libomptarget/DeviceRTL/include/Utils.h; openmp/libomptarget/DeviceRTL/src/Configuration.cpp; openmp/libomptarget/DeviceRTL/src/Kernel.cpp; openmp/libomptarget/DeviceRTL/src/Misc.cpp; openmp/libomptarget/DeviceRTL/src/Parallelism.cpp; openmp/libomptarget/DeviceRTL/src/Reduction.cpp; openmp/libomptarget/DeviceRTL/src/State.cpp; openmp/libomptarget/DeviceRTL/src/Synchronization.cpp; openmp/libomptarget/DeviceRTL/src/Tasking.cpp; openmp/libomptarget/DeviceRTL/src/Utils.cpp; openmp/libomptarget/include/Debug.h; openmp/libomptarget/include/device.h; openmp/libomptarget/include/DeviceEnvironment.h; openmp/libomptarget/include/interop.h; openmp/libomptarget/include/omptarget.h; openmp/libomptarget/include/omptargetplugin.h; openmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/l,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:406902,plugin,plugins,406902,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"ated list of expressions. For example:. .. code-block:: llvm. ; CHECK: load r[[#REG:]], [r0]; ; CHECK: load r[[#REG+1]], [r1]; ; CHECK: Loading from 0x[[#%x,ADDR:]]; ; CHECK-SAME: to 0x[[#ADDR + 7]]. The above example would match the text:. .. code-block:: gas. load r5, [r0]; load r6, [r1]; Loading from 0xa0463440 to 0xa0463447. but would not match the text:. .. code-block:: gas. load r5, [r0]; load r7, [r1]; Loading from 0xa0463440 to 0xa0463443. Due to ``7`` being unequal to ``5 + 1`` and ``a0463443`` being unequal to; ``a0463440 + 7``. A numeric variable can also be defined to the result of a numeric expression,; in which case the numeric expression constraint is checked and if verified the; variable is assigned to the value. The unified syntax for both checking a; numeric expression and capturing its value into a numeric variable is thus; ``[[#%<fmtspec>,<NUMVAR>: <constraint> <expr>]]`` with each element as; described previously. One can use this syntax to make a testcase more; self-describing by using variables instead of values:. .. code-block:: gas. ; CHECK: mov r[[#REG_OFFSET:]], 0x[[#%X,FIELD_OFFSET:12]]; ; CHECK-NEXT: load r[[#]], [r[[#REG_BASE:]], r[[#REG_OFFSET]]]. which would match:. .. code-block:: gas. mov r4, 0xC; load r6, [r5, r4]. The ``--enable-var-scope`` option has the same effect on numeric variables as; on string variables. Important note: In its current implementation, an expression cannot use a; numeric variable defined earlier in the same CHECK directive. FileCheck Pseudo Numeric Variables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Sometimes there's a need to verify output that contains line numbers of the; match file, e.g. when testing compiler diagnostics. This introduces a certain; fragility of the match file structure, as ""``CHECK:``"" lines contain absolute; line numbers in the same file, which have to be updated whenever line numbers; change due to text addition or deletion. To support this case, FileCheck expressions understand the ``@LINE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:33077,variab,variables,33077,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variables']
Modifiability,"ated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when creating a rule. Refactoring Options; -------------------. Refactoring options are values that affect a refactoring operation and are; specified either using command-line options or another client-specific; mechanism. Options should be created using a class that derive",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:8965,refactor,refactoring,8965,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactoring']
Modifiability,"ates is to find techniques; to reduce the output’s cluttering. The Parallel Coordinates plots in; ROOT have been implemented as a new plotting option “PARA” in the; `TTree::Draw()method`. To demonstrate how the Parallel Coordinates; works in ROOT we will use the tree produced by the following; “pseudo C++” code:. ``` {.cpp}; void parallel_example() {; TNtuple *nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; for (Int_t i=0; i<3000; i++) {; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x, s1y, s1z, s2x, s2y, s2z, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, s3y, rnd );; nt->Fill( s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; ```. The data set generated has:. - 9 variables: x, y, z, u, v, w, a, b, c.; - 3000*8 = 24000 events.; - 3 sets of random points distributed on spheres: s1, s2, s3; - Random values (noise): rnd; - The variables a,b,c are almost completely random. The variables a; and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere” s3. The command used to produce the Parallel Coordinates plot is:. ``` {.cpp}; nt->Draw(""x:a:y:b:z:u:c:v:w"","""",""PARA"");; ```. ![Cluttered output produced when all the tree events are plotted.](pictures/para3.png). If the 24000 events are plotted as solid lines and no special techniques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:97648,variab,variables,97648,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"ather than the actual; ``EXEC`` mask in order to support whole or quad wavefront mode. .. _amdgpu-dwarf-amdgpu-dw-at-llvm-active-lane:. ``DW_AT_LLVM_active_lane``; ~~~~~~~~~~~~~~~~~~~~~~~~~~. The ``DW_AT_LLVM_active_lane`` attribute on a subprogram debugger information; entry is used to specify the lanes that are conceptually active for a SIMT; thread. The execution mask may be modified to implement whole or quad wavefront mode; operations. For example, all lanes may need to temporarily be made active to; execute a whole wavefront operation. Such regions would save the ``EXEC`` mask,; update it to enable the necessary lanes, perform the operations, and then; restore the ``EXEC`` mask from the saved value. While executing the whole; wavefront region, the conceptual execution mask is the saved value, not the; ``EXEC`` value. This is handled by defining an artificial variable for the active lane mask. The; active lane mask artificial variable would be the actual ``EXEC`` mask for; normal regions, and the saved execution mask for regions where the mask is; temporarily updated. The location list expression created for this artificial; variable is used to define the value of the ``DW_AT_LLVM_active_lane``; attribute. ``DW_AT_LLVM_augmentation``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. For AMDGPU, the ``DW_AT_LLVM_augmentation`` attribute of a compilation unit; debugger information entry has the following value for the augmentation string:. ::. [amdgpu:v0.0]. The ""vX.Y"" specifies the major X and minor Y version number of the AMDGPU; extensions used in the DWARF of the compilation unit. The version number; conforms to [SEMVER]_. Call Frame Information; ----------------------. DWARF Call Frame Information (CFI) describes how a consumer can virtually; *unwind* call frames in a running process or core dump. See DWARF Version 5; section 6.4 and :ref:`amdgpu-dwarf-call-frame-information`. For AMDGPU, the Common Information Entry (CIE) fields have the following values:. 1. ``augmentation`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:110050,variab,variable,110050,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variable']
Modifiability,"ating parameters; a grid (histogram) of integral values is stored, which are interpolated to return integral; values for each value of the parameters. A new tutorial macro rf903_numintcache.C has been added to $ROOTSYS/tutorials/roofit; to illustrate the use of this feature. Representation of function and p.d.f. derivatives; A new class has been added that can represent the derivative of any p.d.f or function w.r.t. any; parameter or observable. To construct e.g. a first order derivative of a Gaussian p.d.f, do. RooAbsReal* dgdx = gauss.derivative(x,1) ;. A more complete example is available in the new tutorial macro rf111_derivatives.C. Improved handling of chi-squared fits; Chi-squared fits can now be performed through the same style of interface as likelihood fits,; through the newly added method RooAbsReal::chi2FitTo(const RooDataHist&,...). Functions that can be fitted with chi-squared minimization are any RooAbsReal based function; as well as RooAbsPdf based p.d.f.s. In case of non-extended p.d.f.s the probability density; calculated by the p.d.f. is multiplied with the number of events in the histogram to adjust; the scale of the function. In case of extended p.d.f.s, the adjustment is made with the expected; number of events, rather than the observed number of events. Tutorial macro rf602_chi2fit.C has been updated to use this new interface. Chi-squared fits to X-Y datasets now possible; In addition to the ability to perform chi-squared fits to histograms it is now also possible; to perform chi-squared fits to unbinned datasets containing a series of X and Y values; with associated errors on Y and optionally on X. These 'X-Y' chi-squared fits are interfaced through newly added method; RooAbsReal::chi2FitTo(const RooDataSet&,...). By default the event weight is; interpreted as the 'Y' value, but an YVar() argument can designate any other; dataset column as Y value. If X errors are defined, one can choose to integrate the fitted; function over the range of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:7784,extend,extended,7784,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['extend'],['extended']
Modifiability,"ation and Removal. - The deprecated types `ROOT::Experimental::TBufferMerger` and `ROOT::Experimental::TBufferMergerFile` are removed.; Please use their non-experimental counterparts `ROOT::TBufferMerger` and `ROOT::TBufferMergerFile` instead.; - `ROOT::RVec::shrink_to_fit()` has now been removed after deprecation; it is not needed.; - `ROOT::RVec::emplace()` has now been removed after deprecation; please use `ROOT::RVec::insert()` instead.; - The deprecated function `ROOT::Detail::RDF::RActionImpl<Helper>::GetDataBlockCallback()` is removed; please use `GetSampleCallback()` instead.; - The deprecated RooFit containers `RooHashTable`, `RooNameSet`, `RooSetPair`, and `RooList` are removed. Please use STL container classes instead, like `std::unordered_map`, `std::set`, and `std::vector`.; - The `RooFit::FitOptions(const char*)` command to steer [RooAbsPdf::fitTo()](https://root.cern.ch/doc/v628/classRooAbsPdf.html) with an option string was removed. This way of configuring the fit was deprecated since at least since ROOT 5.02.; Subsequently, the `RooMinimizer::fit(const char*)` function and the [RooMCStudy](https://root.cern.ch/doc/v628/classRooMCStudy.html) constructor that takes an option string were removed as well.; - The overload of `RooAbsData::createHistogram` that takes integer parameters for the bin numbers is now deprecated and will be removed in ROOT 6.30.; This was done to avoid confusion with inconsistent behavior when compared to other `createHistogram` overloads.; Please use the verson of `createHistogram` that takes RooFit command arguments.; - The `RooAbsData::valid()` method to cache valid entries in the variable range; was removed. It was not implemented in RooDataSet, so it never worked as; intended. Related to it was the `RooDataHist::cacheValidEntries()` function, which is removed as well.; The preferred way to reduce RooFit datasets to subranges is [RooAbsData::reduce()](https://root.cern.ch/doc/v628/classRooAbsData.html#acfa7b31e5cd751eec1bc4e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:2623,config,configuring,2623,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['config'],['configuring']
Modifiability,"ation for the module is in the; ``cmake-modules`` manpage, and is also available at the; `cmake-modules online documentation; <https://cmake.org/cmake/help/v3.4/module/CMakeParseArguments.html>`_. .. note::; As of CMake 3.5 the cmake_parse_arguments command has become a native command; and the CMakeParseArguments module is empty and only left around for; compatibility. Functions Vs Macros; -------------------. Functions and Macros look very similar in how they are used, but there is one; fundamental difference between the two. Functions have their own scope, and; macros don't. This means variables set in macros will bleed out into the calling; scope. That makes macros suitable for defining very small bits of functionality; only. The other difference between CMake functions and macros is how arguments are; passed. Arguments to macros are not set as variables, instead dereferences to; the parameters are resolved across the macro before executing it. This can; result in some unexpected behavior if using unreferenced variables. For example:. .. code-block:: cmake. macro(print_list my_list); foreach(var IN LISTS my_list); message(""${var}""); endforeach(); endmacro(). set(my_list a b c d); set(my_list_of_numbers 1 2 3 4); print_list(my_list_of_numbers); # prints:; # a; # b; # c; # d. Generally speaking this issue is uncommon because it requires using; non-dereferenced variables with names that overlap in the parent scope, but it; is important to be aware of because it can lead to subtle bugs. LLVM Project Wrappers; =====================. LLVM projects provide lots of wrappers around critical CMake built-in commands.; We use these wrappers to provide consistent behaviors across LLVM components; and to reduce code duplication. We generally (but not always) follow the convention that commands prefaced with; ``llvm_`` are intended to be used only as building blocks for other commands.; Wrapper commands that are intended for direct use are generally named following; with the pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:12603,variab,variables,12603,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variables']
Modifiability,"ation status. Clang has support for some of the features of the ISO C++ 2023 standard.; You can use Clang in C++23 mode with the -std=c++23 option. List of features and minimum Clang version with support. Language Feature; C++23 Proposal; Available in Clang?. Literal suffix uz, z for size_t, ssize_t; P0330R8; Clang 13. Make () in lambdas optional in all cases; P1102R2; Clang 13. Simpler implicit move; P2266R1; Clang 13. if consteval; P1938R3; Clang 14. Allow duplicate attributes; P2156R1; Clang 13. Narrowing contextual conversions to bool; P1401R5; Clang 14. Trimming whitespaces before line splicing; P2223R2; Yes. Make declaration order layout mandated; P1874R4; Yes. C++ identifier syntax using UAX 31; P1949R7; Clang 14. Mixed string literal concatenation; P2201R1; Yes. Deducing this; P0847R7; Clang 18. P2797R0; No. Change scope of lambda trailing-return-type; P2036R3; Clang 17. P2579R0. Multidimensional subscript operator; P2128R6; Clang 15. Non-literal variables (and labels and gotos) in constexpr functions; P2242R3; Clang 15. Character encoding of diagnostic text; P2246R1; Yes. Character sets and encodings; P2314R4; Yes. Consistent character literal encoding; P2316R2; Yes. Add support for preprocessing directives elifdef and elifndef; P2334R1; Clang 13. Extend init-statement to allow alias-declaration; P2360R0; Clang 14. auto(x): decay-copy in the language; P0849R8; Clang 15. Attributes on Lambda-Expressions; P2173R1; Clang 13. constexpr for <cmath> and <cstdlib>; P0533R9; No. Type trait to determine if a reference binds to a temporary; P2255R2. Partial; Clang provides __reference_constructs_from_temporary type; trait builtin, with which std::reference_constructs_from_temporary; is implemented. __reference_converts_from_temporary needs to be; provided, following the normal cross-vendor convention to implement; traits requiring compiler support directly.; . The Equality Operator You Are Looking For; P2468R2; Clang 16. De-deprecating volatile compound operations; P",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:2903,variab,variables,2903,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,1,['variab'],['variables']
Modifiability,"ation, Fitter::CalculateHessErrors() and for calculating the Minos errors Fitter::CalculateMinosErrors; FitConfig: add in the configuration the possibility to select a sub-set of the parameters for calculating the Minos errors by using the method FitConfig::SetMinosErrors( listOfParameters ). If no list is passed, by default the Minos error will be computed on all parameters.; UnBinData class: add new constructor for creating a unbin data set passing a range to select the data and copy in the internal array; FitResult: the class now stores a map of the Minos error using as key the parameter index. If the Minos error has not been calculated for the parameter, FitResult::LowerError(i) and FitResult::UpperError(i) returns the parabolic error; ; Add a new class, MinimTransformFunction to perform a transformation of the function object to deal with limited and fixed variables.; This class uses the same transformation which are also used inside Minuit, a sin transformation for double bounded variables and a sqrt transformation for single bound variable defined in the class MinimizerVariableTransformation.; These classes can be used by minimizer which do not support internally the bounds (like the GSL minimizers).; . Add two new method in ROOT::Math::Minimizer class:; ; int Minimizer::CovMatrixStatus() : returning the status of the covariance matrix. Implemented by Minuit and Minuit2 and follows original Minuit code meaning: code = 0 (not calculated), 1 (approximated), 2 (matrix was made pos def) , 3 (accurate); ; bool Hesse(): to perform a full calculation of the Hessian matrix; . TMath. Fix a numerical problem in TMath::ErfcInverse for small input values. Now the normal quantile function is used for implementing it.; . MathMore. Fix 2 bugs in the quartic equation solver (see issue #49031).; ; A protection has been added against numerical errors which could cause NaN due to wrong inputs to an acos function. This problem appears also in the GSL cubic solver. A new GSL patc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:1871,variab,variables,1871,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,2,['variab'],"['variable', 'variables']"
Modifiability,"ation, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1). How records are built; ---------------------. The following steps are taken by TableGen when a record is built. Classes are simply; abstract records and so go through the same steps. 1. Build the record name (:token:`NameValue`) and create an empty record. 2. Parse the parent classes in the :token:`ParentClassList` from left to; right, visiting each parent class's ancestor classes from top to bottom. a. Add the fields from the parent class to the record.; b. Substitute the template arguments into those fields.; c. Add the parent class to the record's list of inherited classes. 3. Apply any top-level ``let`` bindings to the record. Recall that top-level; bindings only apply to inherited fields. 4. Parse the body of the record. * Add any fields to the record.; * Modify the values of fields according to local ``let`` statements.; * Define any ``defvar`` variables. 5. Make a pass over all the fields to resolve any inter-field references. 6. Add the record to the final record list. Because references between fields are resolved (step 5) after ``let`` bindings are; applied (step 3), the ``let`` statement has unusual power. For example:. .. code-block:: text. class C <int x> {; int Y = x;; int Yplus1 = !add(Y, 1);; int xplus1 = !add(x, 1);; }. let Y = 10 in {; def rec1 : C<5> {; }; }. def rec2 : C<5> {; let Y = 10;; }. In both cases, one where a top-level ``let`` is used to bind ``Y`` and one; where a local ``let`` does the same thing, the results are:. .. code-block:: text. def rec1 { // C; int Y = 10;; int Yplus1 = 11;; int xplus1 = 6;; }; def rec2 { // C; int Y = 10;; int Yplus1 = 11;; int xplus1 = 6;; }. ``Yplus1`` is 11 because the ``let Y`` is performed before the ``!add(Y,; 1)`` is resolved. Use this power wisely. Using Classes as Subroutines; ============================. As described in `Simple values`_, a class can be in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:54089,variab,variables,54089,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variables']
Modifiability,"ation. The user will be able to see the; line and location of the caret, so you don't need to tell them that the; problem is with the 4th argument to the function: just point to it.; * Do not capitalize the diagnostic string, and do not end it with a period.; * If you need to quote something in the diagnostic string, use single quotes. Diagnostics should never take random English strings as arguments: you; shouldn't use ""``you have a problem with %0``"" and pass in things like ""``your; argument``"" or ""``your return value``"" as arguments. Doing this prevents; :ref:`translating <internals-diag-translation>` the Clang diagnostics to other; languages (because they'll get random English words in their otherwise; localized diagnostic). The exceptions to this are C/C++ language keywords; (e.g., ``auto``, ``const``, ``mutable``, etc) and C/C++ operators (``/=``).; Note that things like ""pointer"" and ""reference"" are not keywords. On the other; hand, you *can* include anything that comes from the user's source code,; including variable names, types, labels, etc. The ""``select``"" format can be; used to achieve this sort of thing in a localizable way, see below. Formatting a Diagnostic Argument; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Arguments to diagnostics are fully typed internally, and come from a couple; different classes: integers, types, names, and random strings. Depending on; the class of the argument, it can be optionally formatted in different ways.; This gives the ``DiagnosticConsumer`` information about what the argument means; without requiring it to use a specific presentation (consider this MVC for; Clang :). It is really easy to add format specifiers to the Clang diagnostics system, but; they should be discussed before they are added. If you are creating a lot of; repetitive diagnostics and/or have an idea for a useful formatter, please bring; it up on the cfe-dev mailing list. Here are the different diagnostic argument formats currently supported by; Clang:. **""s"" f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:9371,variab,variable,9371,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['variab'],['variable']
Modifiability,"ation: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and make a; decision on options they don't really care about. The goal of the clang-format project is more on the side of supporting a; limited set of styles really well as opposed to supporting every single style; used by a codebase somewhere in the wild. Of course, we do want to support all; major projects and thus have established the following bar for adding style; options.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:133506,config,configuration,133506,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,['config'],"['configuration', 'configured']"
Modifiability,"ation: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; {7, 5, ""!!"" }; };. * ``AIAS_Right`` (in configuration: ``Right``); Align array column and right justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; { 7, 5, ""!!""}; };. * ``AIAS_None`` (in configuration: ``None``); Don't align array initializer columns. .. _AlignConsecutiveAssignments:. **AlignConsecutiveAssignments** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignConsecutiveAssignments>`; Style of aligning consecutive assignments. ``Consecutive`` will result in formattings like:. .. code-block:: c++. int a = 1;; int somelongname = 2;; double c = 3;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. For example, to align across empty lines and not across comments, either; of these work. .. code-block:: c++. AlignConsecutiveMacros: AcrossEmptyLines. AlignConsecutiveMacros:; Enabled: true; AcrossEmptyLines: t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:8861,config,configuration,8861,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,ation; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unknown. 1914; extension; Duplicate standard attributes; Extension. 1915; open; Potentially-invoked destructors in non-throwing constructors; Not resolved. 1916; CD4; “Same cv-unqualified type”; Unknown. 1917; NAD; decltype-qualified enumeration names; Unknown. 1918; open; friend templates with dependent scopes; Not resolved. 1919; open; Overload resolution for ! with explicit conversion operator; Not resolved. 1920; CD4; Qualification mismatch in pseudo-destructor-name; Unknown. 1921; NAD; constexpr constructors and point of initialization of const variables; Unknown. 1922; CD4; Injected class template names and default arguments; Unknown. 1923; NAD; Lvalues of type void; Unknown. 1924; review; Definition of “literal” and kinds of literals; Not resolved. 1925; CD4; Bit-field prvalues; Unknown. 1926; CD4; Potential results of subscript operator; Unknown. 1927; dup; Lifetime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NAD; Implementation limit for initializer-list elements; Unknown. 1934; NAD; Relaxing exception-specification compatibility requirements; Unknown. 1935; CD5; Reuse of placement arguments in deallocation; Unknown. 1936; CD6; Dependent qual,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:130503,variab,variables,130503,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"ation; of references at a safepoint and is used by precise collectors to identify; references within a stack frame on the machine stack. Note that collectors; which conservatively scan the stack don't require such a structure. #. A stack crawler to discover functions on the call stack, and enumerate the; references listed in the stack map for each call site. #. A mechanism for identifying references in global locations (e.g. global; variables). #. If you collector requires them, an LLVM IR implementation of your collectors; load and store barriers. Note that since many collectors don't require; barriers at all, LLVM defaults to lowering such barriers to normal loads; and stores unless you arrange otherwise. Implementing a collector plugin; -------------------------------. User code specifies which GC code generation to use with the ``gc`` function; attribute or, equivalently, with the ``setGC`` method of ``Function``. To implement a GC plugin, it is necessary to subclass ``llvm::GCStrategy``,; which can be accomplished in a few lines of boilerplate code. LLVM's; infrastructure provides access to several important algorithms. For an; uncontroversial collector, all that remains may be to compile LLVM's computed; stack map to assembly code (using the binary representation expected by the; runtime library). This can be accomplished in about 100 lines of code. This is not the appropriate place to implement a garbage collected heap or a; garbage collector itself. That code should exist in the language's runtime; library. The compiler plugin is responsible for generating code which conforms; to the binary interface defined by library, most essentially the :ref:`stack map; <stack-map>`. To subclass ``llvm::GCStrategy`` and register it with the compiler:. .. code-block:: c++. // lib/MyGC/MyGC.cpp - Example LLVM GC plugin. #include ""llvm/CodeGen/GCStrategy.h""; #include ""llvm/CodeGen/GCMetadata.h""; #include ""llvm/Support/Compiler.h"". using namespace llvm;. namespace {; class LL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:23591,plugin,plugin,23591,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"ations. Checks if the cstring pointer from which the ``std::string`` object is; constructed is ``NULL`` or not.; If the checker cannot reason about the nullness of the pointer it will assume; that it was non-null to satisfy the precondition of the constructor. This checker is capable of checking the `SEI CERT C++ coding rule STR51-CPP.; Do not attempt to create a std::string from a null pointer; <https://wiki.sei.cmu.edu/confluence/x/E3s-BQ>`__. .. code-block:: cpp. #include <string>. void f(const char *p) {; if (!p) {; std::string msg(p); // warn: The parameter must not be null; }; }. .. _deadcode-checkers:. deadcode; ^^^^^^^^. Dead Code Checkers. .. _deadcode-DeadStores:. deadcode.DeadStores (C); """"""""""""""""""""""""""""""""""""""""""""""; Check for values stored to variables that are never read afterwards. .. code-block:: c. void test() {; int x;; x = 1; // warn; }. The ``WarnForDeadNestedAssignments`` option enables the checker to emit; warnings for nested dead assignments. You can disable with the; ``-analyzer-config deadcode.DeadStores:WarnForDeadNestedAssignments=false``.; *Defaults to true*. Would warn for this e.g.:; if ((y = make_int())) {; }. .. _nullability-checkers:. nullability; ^^^^^^^^^^^. Objective C checkers that warn for null pointer passing and dereferencing errors. .. _nullability-NullPassedToNonnull:. nullability.NullPassedToNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a null pointer is passed to a pointer which has a _Nonnull type. .. code-block:: objc. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. .. _nullability-NullReturnedFromNonnull:. nullability.NullReturnedFromNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a null pointer is returned from a function that has _Nonnull return type. .. code-block:: objc. - (nonnull id)firstChild {; id result = nil;; if ([_children count] > 0); result = _children[0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:10554,config,config,10554,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['config']
Modifiability,"ative && mean<0) {; RooNaNPacker np;; np.setPayload(-mean);; return np._payload;; }; return TMath::Poisson(k,mean);; }; ```; `TMath::Poisson()` is a simple mathematical function. For this example, the; relevant part is `return TMath::Poisson(k,mean);`. This needs to be extracted; into the `MathFuncs.h` file and the fully qualified name of the function; referencing that file should be used here instead. ## After Code Generation Support. Following is a code snippet from `RooPoisson` *after* it has AD support. ### Step 1. Refactor the `RooPoisson::evaluate()` Function. ``` {.cpp}; /// Implementation in terms of the TMath::Poisson() function. double RooPoisson::evaluate() const; {; double k = _noRounding ? x : floor(x);; if(_protectNegative && mean<0) {; RooNaNPacker np;; np.setPayload(-mean);; return np._payload;; }; return RooFit::Detail::MathFuncs::poisson(k, mean);; }; ```. Note that the `evaluate()` function was refactored in such a way that the; mathematical parts were moved to an inline function in a separate header file; named `MathFuncs`, so that Clad could see and differentiate that function.; The rest of the contents of the function remain unchanged. > All contents of the `evaluate()` function don't always need to be pulled; out, only the required parts (mathematical logic) should be moved to; `MathFuncs`. **What is MathFuncs?**. Moving away from the class-based hierarchy design, `MathFuncs.h` a simply; a flat file of function implementations. This file is required since Clad will not be able to see anything that is not; inlined and explicitly available to it during compilation (since it has to be; in the same translation). So other than of generating these functions on the; fly, your only other option is to place these functions in a separate header; file and make them inline. Theoretically, multiple header files can also be used and then mashed; together. > Directory path: [roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h](https://github.com/root-project/root",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:10851,refactor,refactored,10851,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['refactor'],['refactored']
Modifiability,"ative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83785,config,configuration,83785,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"atting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacement sequence is a string of the form ``{N[[,align]:style]}``. ``N`` refers to the 0-based index of the argument from the list of replacement; values. Note that this means it is possible to reference the same parameter; multiple times, possibly with different style and/or alignment options, in any order. ``align`` is an optional string specifying the width of the field to format; the value into, and the alignment of the value within the field. It is specified as; an optional **alignment style** followed by a positive integral **field width**. The; alignment style can be one of the characters ``-`` (left align), ``=`` (center align),; or ``+`` (right align). The default is right aligned. ``style`` is an optional string consisting of a type specific that controls the; formatting of the value. For example, to format a floating point value as a percentage,; you can use the style option ``P``. C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:12377,variab,variable,12377,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; suppression of certain optimisations, like GlobalMerge, as well as ensuring; extra directives are emitted in the assembly and extra bits of metadata are; placed in the object file so that the linker can ensure the accesses are; protected by MTE. This attribute is added by clang when; `-fsanitize=memtag-globals` is provided, as long as the global is not marked; with `__attribute__((no_sanitize(""memtag"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file. The AArch64 Globals Tagging pass may remove; this attribute when it's not possible to tag the global (e.g. it's a TLS; variable).; ``sanitize_address_dyninit``; This attribute indicates that the global variable, when instrumented with; AddressSanitizer, should be checked for ODR violations. This attribute is; applied to global variables that are dynamically initialized according to; C++ rules. .. _opbundles:. Operand Bundles; ---------------. Operand bundles are tagged sets of SSA values that can be associated; with certain LLVM instructions (currently only ``call`` s and; ``invoke`` s). In a way they are like metadata, but dropping them is; incorrect and will change program semantics. Syntax::. operand bundle set ::= '[' operand bundle (, operand bundle )* ']'; operand bundle ::= tag '(' [ bundle operand ] (, bundle operand )* ')'; bundle operand ::= SSA value; tag ::= string constant. Operand bundles are **not** part of a function's signature, and a; given function may be called from multiple places with different kinds; of operand bundles. This reflects the fact that the operand bundles; are conceptually a part of the ``call`` (or ``invoke``), not the; callee being dispatched to. Operand bundles are a generic mechanism intended to support; runtime-introspection-like functionality for managed languages. While; the exact ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:116799,variab,variables,116799,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"attribute push([[nodiscard]], apply_to = any(record, namespace)). #pragma clang attribute pop. Multiple match rules can be specified using the ``any`` match rule, as shown; in the example above. The ``any`` rule applies attributes to all declarations; that are matched by at least one of the rules in the ``any``. It doesn't nest; and can't be used inside the other match rules. Redundant match rules or rules; that conflict with one another should not be used inside of ``any``. Failing to; specify a rule within the ``any`` rule results in an error. Clang supports the following match rules:. - ``function``: Can be used to apply attributes to functions. This includes C++; member functions, static functions, operators, and constructors/destructors. - ``function(is_member)``: Can be used to apply attributes to C++ member; functions. This includes members like static functions, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global var",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:183126,variab,variables,183126,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variables']
Modifiability,"attribute__((NSObject))`` should; have ``byref_keep`` and ``byref_dispose`` helper functions that use; ``_Block_object_assign`` and ``_Block_object_dispose``. ``__block`` escapes; ^^^^^^^^^^^^^^^^^^^. Because ``Blocks`` referencing ``__block`` variables may have ``Block_copy()``; performed upon them the underlying storage for the variables may move to the; heap. In Objective-C Garbage Collection Only compilation environments the heap; used is the garbage collected one and no further action is required. Otherwise; the compiler must issue a call to potentially release any heap storage for; ``__block`` variables at all escapes or terminations of their scope. The call; should be:. .. code-block:: c. _Block_object_dispose(&_block_byref_foo, BLOCK_FIELD_IS_BYREF);. Nesting; ^^^^^^^. ``Blocks`` may contain ``Block`` literal expressions. Any variables used within; inner blocks are imported into all enclosing ``Block`` scopes even if the; variables are not used. This includes ``const`` imports as well as ``__block``; variables. Objective C Extensions to ``Blocks``; ====================================. Importing Objects; -----------------. Objects should be treated as ``__attribute__((NSObject))`` variables; all; ``copy_helper``, ``dispose_helper``, ``byref_keep``, and ``byref_dispose``; helper functions should use ``_Block_object_assign`` and; ``_Block_object_dispose``. There should be no code generated that uses; ``*-retain`` or ``*-release`` methods. ``Blocks`` as Objects; ---------------------. The compiler will treat ``Blocks`` as objects when synthesizing property setters; and getters, will characterize them as objects when generating garbage; collection strong and weak layout information in the same manner as objects, and; will issue strong and weak write-barrier assignments in the same manner as; objects. ``__weak __block`` Support; --------------------------. Objective-C (and Objective-C++) support the ``__weak`` attribute on ``__block``; variables. Under normal circ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:18563,variab,variables,18563,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"ault key-binding is Alt-Shift-F. Git integration; ===============. The script `clang/tools/clang-format/git-clang-format` can be used to; format just the lines touched in git commits:. .. code-block:: console. % git clang-format -h; usage: git clang-format [OPTIONS] [<commit>] [<commit>|--staged] [--] [<file>...]. If zero or one commits are given, run clang-format on all lines that differ; between the working directory and <commit>, which defaults to HEAD. Changes are; only applied to the working directory, or in the stage/index. Examples:; To format staged changes, i.e everything that's been `git add`ed:; git clang-format. To also format everything touched in the most recent commit:; git clang-format HEAD~1. If you're on a branch off main, to format everything touched on your branch:; git clang-format main. If two commits are given (requires --diff), run clang-format on all lines in the; second <commit> that differ from the first <commit>. The following git-config settings set the default of the corresponding option:; clangFormat.binary; clangFormat.commit; clangFormat.extensions; clangFormat.style. positional arguments:; <commit> revision from which to compute the diff; <file>... if specified, only consider differences in these files. optional arguments:; -h, --help show this help message and exit; --binary BINARY path to clang-format; --commit COMMIT default commit to use if none is specified; --diff print a diff instead of applying the changes; --diffstat print a diffstat instead of applying the changes; --extensions EXTENSIONS; comma-separated list of file extensions to format, excluding the period and case-insensitive; -f, --force allow changes to unstaged files; -p, --patch select hunks interactively; -q, --quiet print less information; --staged, --cached format lines in the stage instead of the working dir; --style STYLE passed to clang-format; -v, --verbose print extra information. Script for patch reformatting; =============================. The python scri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:11111,config,config,11111,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['config'],['config']
Modifiability,"ault settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a sour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1638,config,configuration,1638,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,2,['config'],"['configuration', 'configuration-example']"
Modifiability,"aunched; July 1st, 2011; Welcome to the new website of the project. Read more; Useful Links. CERN. Download & Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps; If you want to download and build cling within ROOT please follow the tutorial here; Build; Unix systems; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite. Get it at: http://www.python.org/download; . Checkout LLVM:; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src. Checkout Clang:; cd llvm/src/tools/; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to clang):; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system:; cat tools/cling/patches/*.diff | patch -p0. Configure in your build folder (preferably out of the source code). For example:; cd ../../obj; ../src/configure --prefix=Where\to\be\installed\. Now compile and install:; make && make install. The executables could be found in your installation folder.; ; Using Visual Studio; Prerequisites; Subversion client - http://subversion.tigris.org/getting.html; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Checkout LLVM; svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm/src/. Checkout Clang; cd llvm\src\tools\; svn co http://llvm.org/svn/llvm-project/cfe/trunk clang. Checkout Cling (next to Clang); ; svn co http://root.cern.ch/svn/root/branches/dev/cling cling. Allow Cling to hook into LLVM's build system: apply the two patches located in the cling\patches folder.; . Open up cmake and enter the path to the 'src' folder in the 'Where is the source code' field and the path to the 'build' folder in the 'Where to build the binaries' field (mkdir llvm\obj -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html:1342,config,configure,1342,interpreter/cling/www/old/download.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/download.html,1,['config'],['configure']
Modifiability,"ause it's a volatile load, though, it's not. Design tradeoffs; ----------------. Precision; ^^^^^^^^^. ``MemorySSA`` in LLVM deliberately trades off precision for speed.; Let us think about memory variables as if they were disjoint partitions of the; memory (that is, if you have one variable, as above, it represents the entire; memory, and if you have multiple variables, each one represents some; disjoint portion of the memory). First, because alias analysis results conflict with each other, and; each result may be what an analysis wants (IE; TBAA may say no-alias, and something else may say must-alias), it is; not possible to partition the memory the way every optimization wants.; Second, some alias analysis results are not transitive (IE A noalias B,; and B noalias C, does not mean A noalias C), so it is not possible to; come up with a precise partitioning in all cases without variables to; represent every pair of possible aliases. Thus, partitioning; precisely may require introducing at least N^2 new virtual variables,; phi nodes, etc. Each of these variables may be clobbered at multiple def sites. To give an example, if you were to split up struct fields into; individual variables, all aliasing operations that may-def multiple struct; fields, will may-def more than one of them. This is pretty common (calls,; copies, field stores, etc). Experience with SSA forms for memory in other compilers has shown that; it is simply not possible to do this precisely, and in fact, doing it; precisely is not worth it, because now all the optimizations have to; walk tons and tons of virtual variables and phi nodes. So we partition. At the point at which you partition, again,; experience has shown us there is no point in partitioning to more than; one variable. It simply generates more IR, and optimizations still; have to query something to disambiguate further anyway. As a result, LLVM partitions to one variable. Precision in practice; ^^^^^^^^^^^^^^^^^^^^^. In practice, there ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:17548,variab,variables,17548,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['variab'],['variables']
Modifiability,"aussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). VolumeRangeMode No Adaptive Unscaled, MinMax, RMS, Adaptive, kNN Method to determine volume size. KernelEstimator No Box Box, Sphere, Teepee, Gauss, Sinc3, Sinc5, Sinc7, Sinc9, Sinc11, Lanczos2, Lanczos3, Lanczos5, Lanczos8, Trim Kernel estimation function. DeltaFrac No 3 − nEventsMin/Max for minmax and rms volume range. NEventsMin No 100 − nEventsMin for adaptive volume range. NEventsMax No 200 − nEventsMax for adaptive volume range. MaxVIterations No 150 − MaxVIterations for adaptive volume range. InitialScale No 0.99 − InitialScale for adaptive volume range. GaussSigma No 0.1 − Width (wrt volume size) of Gaussian kernel estimator. NormTree No False − Normalize binary search tree. Configuration options for MVA method :. Configuration options reference for MVA method: FDA. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:4912,adapt,adaptive,4912,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['adapt'],['adaptive']
Modifiability,"author Pere Mato, CERN; ############################################################################. set (EXTRA_DICT_OPTS); if (runtime_cxxmodules AND WIN32); set (EXTRA_DICT_OPTS NO_CXXMODULE); endif(). ROOT_STANDARD_LIBRARY_PACKAGE(TMVAGui; HEADERS; TMVA/BDT.h; TMVA/BDTControlPlots.h; TMVA/BDT_Reg.h; TMVA/BoostControlPlots.h; TMVA/CorrGui.h; TMVA/CorrGuiMultiClass.h; TMVA/MovieMaker.h; TMVA/PlotFoams.h; TMVA/TMVAGui.h; TMVA/TMVAMultiClassGui.h; TMVA/TMVARegGui.h; TMVA/annconvergencetest.h; TMVA/compareanapp.h; TMVA/correlations.h; TMVA/correlationsMultiClass.h; TMVA/correlationscatters.h; TMVA/correlationscattersMultiClass.h; TMVA/deviations.h; TMVA/efficiencies.h; TMVA/efficienciesMulticlass.h; TMVA/likelihoodrefs.h; TMVA/mvaeffs.h; TMVA/mvas.h; TMVA/mvasMulticlass.h; TMVA/mvaweights.h; TMVA/network.h; TMVA/paracoor.h; TMVA/probas.h; TMVA/regression_averagedevs.h; TMVA/rulevis.h; TMVA/rulevisCorr.h; TMVA/rulevisHists.h; TMVA/tmvaglob.h; TMVA/training_history.h; TMVA/variables.h; TMVA/variablesMultiClass.h; SOURCES; src/BDTControlPlots.cxx; src/BoostControlPlots.cxx; src/CorrGui.cxx; src/CorrGuiMultiClass.cxx; src/MovieMaker.cxx; src/PlotFoams.cxx; src/TMVAGui.cxx; src/TMVAMultiClassGui.cxx; src/TMVARegGui.cxx; src/annconvergencetest.cxx; src/compareanapp.cxx; src/correlations.cxx; src/correlationsMultiClass.cxx; src/correlationscatters.cxx; src/correlationscattersMultiClass.cxx; src/deviations.cxx; src/efficiencies.cxx; src/efficienciesMulticlass.cxx; src/likelihoodrefs.cxx; src/mvas.cxx; src/mvasMulticlass.cxx; src/mvaweights.cxx; src/network.cxx; src/paracoor.cxx; src/regression_averagedevs.cxx; src/rulevis.cxx; src/rulevisCorr.cxx; src/rulevisHists.cxx; src/tmvaglob.cxx; src/training_history.cxx; src/variables.cxx; src/variablesMultiClass.cxx; src/BDT.cxx; src/BDT_Reg.cxx; src/probas.cxx; src/mvaeffs.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; RIO; Hist; Tree; TreeViewer; MLP; Minuit; XMLIO; TMVA; Gui; HistPainter; Core; ${EXTRA_DICT_OPTS}; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/CMakeLists.txt:1333,variab,variablesMultiClass,1333,tmva/tmvagui/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/CMakeLists.txt,3,['variab'],"['variables', 'variablesMultiClass']"
Modifiability,"automatic storage referenced within the Block expression; (or form strong references if running under garbage collection).; Object variables of ``__block`` storage type are assumed to hold; normal pointers with no provision for retain and release messages. Foundation defines (and supplies) ``-copy`` and ``-release`` methods for; Blocks. In the Objective-C and Objective-C++ languages, we allow the; ``__weak`` specifier for ``__block`` variables of object type. If; garbage collection is not enabled, this qualifier causes these; variables to be kept without retain messages being sent. This; knowingly leads to dangling pointers if the Block (or a copy) outlives; the lifetime of this object. In garbage collected environments, the ``__weak`` variable is set to; nil when the object it references is collected, as long as the; ``__block`` variable resides in the heap (either by default or via; ``Block_copy()``). The initial Apple implementation does in fact; start ``__block`` variables on the stack and migrate them to the heap; only as a result of a ``Block_copy()`` operation. It is a runtime error to attempt to assign a reference to a; stack-based Block into any storage marked ``__weak``, including; ``__weak`` ``__block`` variables. C++ Extensions; ==============. Block literal expressions within functions are extended to allow const; use of C++ objects, pointers, or references held in automatic storage. As usual, within the block, references to captured variables become; const-qualified, as if they were references to members of a const; object. Note that this does not change the type of a variable of; reference type. For example, given a class Foo:. .. code-block:: c. Foo foo;; Foo &fooRef = foo;; Foo *fooPtr = &foo;. A Block that referenced these variables would import the variables as; const variations:. .. code-block:: c. const Foo block_foo = foo;; Foo &block_fooRef = fooRef;; Foo *const block_fooPtr = fooPtr;. Captured variables are copied into the Block at the instan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:10715,variab,variables,10715,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variables']
Modifiability,"avaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <Macros>`; A li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84585,config,configuration,84585,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.ast foo.cpp foo.cpp.ast main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp foo.cpp.ast main.cpp reports/; $ tree reports; reports; ├── compile_cmd.json; ├── compiler_info.json; ├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist; ├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist; ├── metadata.json; └── unique_compile_commands.json. 0 directories, 6 files; $. The `plist` files contain the results of the analysis, which may be viewed with the regular analysis tools.; E.g. one may use `CodeChecker parse` to view the results in command line:. .. code-block:: bash. $ CodeChecker parse reports; [HIGH] /home/egbomrt/ctu_mini_raw_project/main.cpp:5:12: Division by zero [core.DivideZero]; return 3 / foo();; ^. Found 1 defect(s) in main.cpp. ----==== Summary ====----; -----------------------; Filename | Report count; -----------------------; main.cpp | 1; -----------------------; ----------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:4400,variab,variable,4400,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,1,['variab'],['variable']
Modifiability,"available for; execution"" by adding them to the CompileLayer, which will it turn store the; Module in the main JITDylib. This process will create new symbol table entries; in the JITDylib for each definition in the module, and will defer compilation of; the module until any of its definitions is looked up. Note that this is not lazy; compilation: just referencing a definition, even if it is never used, will be; enough to trigger compilation. In later chapters we will teach our JIT to defer; compilation of functions until they're actually called. To add our Module we; must first wrap it in a ThreadSafeModule instance, which manages the lifetime of; the Module's LLVMContext (our Ctx member) in a thread-friendly way. In our; example, all modules will share the Ctx member, which will exist for the; duration of the JIT. Once we switch to concurrent compilation in later chapters; we will use a new context per module. Our last method is ``lookup``, which allows us to look up addresses for; function and variable definitions added to the JIT based on their symbol names.; As noted above, lookup will implicitly trigger compilation for any symbol; that has not already been compiled. Our lookup method calls through to; `ExecutionSession::lookup`, passing in a list of dylibs to search (in our case; just the main dylib), and the symbol name to search for, with a twist: We have; to *mangle* the name of the symbol we're searching for first. The ORC JIT; components use mangled symbols internally the same way a static compiler and; linker would, rather than using plain IR symbol names. This allows JIT'd code; to interoperate easily with precompiled code in the application or shared; libraries. The kind of mangling will depend on the DataLayout, which in turn; depends on the target platform. To allow us to remain portable and search based; on the un-mangled name, we just re-produce this mangling ourselves using our; ``Mangle`` member function object. This brings us to the end of Chapter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:11475,variab,variable,11475,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['variab'],['variable']
Modifiability,"available generators on your system, execute. .. code-block:: console. $ cmake --help. This will list the generator names at the end of the help text. Generators' names are case-sensitive, and may contain spaces. For this reason,; you should enter them exactly as they are listed in the ``cmake --help``; output, in quotes. For example, to generate project files specifically for; Visual Studio 12, you can execute:. .. code-block:: console. $ cmake -G ""Visual Studio 12"" path/to/llvm/source/root. For a given development platform there can be more than one adequate; generator. If you use Visual Studio, ""NMake Makefiles"" is a generator you can use; for building with NMake. By default, CMake chooses the most specific generator; supported by your development environment. If you want an alternative generator,; you must tell this to CMake with the ``-G`` option. .. todo::. Explain variables and cache. Move explanation here from #options section. .. _Options and variables:. Options and variables; =====================. Variables customize how the build will be generated. Options are boolean; variables, with possible values ON/OFF. Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; -------------------------------. Here",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:5587,variab,variables,5587,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"aving the high bits; unspecified. .. code-block:: none. %1:_(s32) = G_ANYEXT %0:_(s16). G_SEXT; ^^^^^^. Sign extend the underlying scalar type of an operation, copying the sign bit; into the newly-created space. .. code-block:: none. %1:_(s32) = G_SEXT %0:_(s16). G_SEXT_INREG; ^^^^^^^^^^^^. Sign extend the value from an arbitrary bit position, copying the sign bit; into all bits above it. This is equivalent to a shl + ashr pair with an; appropriate shift amount. $sz is an immediate (MachineOperand::isImm(); returns true) to allow targets to have some bitwidths legal and others; lowered. This opcode is particularly useful if the target has sign-extension; instructions that are cheaper than the constituent shifts as the optimizer is; able to make decisions on whether it's better to hang on to the G_SEXT_INREG; or to lower it and optimize the individual shifts. .. code-block:: none. %1:_(s32) = G_SEXT_INREG %0:_(s32), 16. G_ZEXT; ^^^^^^. Zero extend the underlying scalar type of an operation, putting zero bits; into the newly-created space. .. code-block:: none. %1:_(s32) = G_ZEXT %0:_(s16). G_TRUNC; ^^^^^^^. Truncate the underlying scalar type of an operation. This is equivalent to; G_EXTRACT for scalar types, but acts elementwise on vectors. .. code-block:: none. %1:_(s16) = G_TRUNC %0:_(s32). Type Conversions; ----------------. G_INTTOPTR; ^^^^^^^^^^. Convert an integer to a pointer. .. code-block:: none. %1:_(p0) = G_INTTOPTR %0:_(s32). G_PTRTOINT; ^^^^^^^^^^. Convert a pointer to an integer. .. code-block:: none. %1:_(s32) = G_PTRTOINT %0:_(p0). G_BITCAST; ^^^^^^^^^. Reinterpret a value as a new type. This is usually done without; changing any bits but this is not always the case due a subtlety in the; definition of the :ref:`LLVM-IR Bitcast Instruction <i_bitcast>`. It; is allowed to bitcast between pointers with the same size, but; different address spaces. .. code-block:: none. %1:_(s64) = G_BITCAST %0:_(<2 x s32>). G_ADDRSPACE_CAST; ^^^^^^^^^^^^^^^^. Convert a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst:2205,extend,extend,2205,interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,1,['extend'],['extend']
Modifiability,"avor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8259,rewrite,rewrite,8259,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,ax/Pseudo/LRTableBuild.cpp; clang/lib/Tooling/Syntax/Pseudo/Preprocess.cpp; clang/lib/Tooling/Syntax/Pseudo/Token.cpp; clang/lib/Tooling/Transformer/Parsing.cpp; clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp; clang/lib/Tooling/Transformer/Stencil.cpp; clang/lib/Tooling/Transformer/Transformer.cpp; clang/tools/amdgpu-arch/AMDGPUArch.cpp; clang/tools/apinotes-test/APINotesTest.cpp; clang/tools/clang-format/ClangFormat.cpp; clang/tools/clang-fuzzer/ClangFuzzer.cpp; clang/tools/clang-fuzzer/DummyClangFuzzer.cpp; clang/tools/clang-fuzzer/ExampleClangLLVMProtoFuzzer.cpp; clang/tools/clang-fuzzer/ExampleClangLoopProtoFuzzer.cpp; clang/tools/clang-fuzzer/handle-llvm/handle_llvm.h; clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp; clang/tools/clang-linker-wrapper/OffloadWrapper.cpp; clang/tools/clang-pseudo/ClangPseudo.cpp; clang/tools/clang-refactor/ClangRefactor.cpp; clang/tools/clang-refactor/TestSupport.cpp; clang/tools/clang-refactor/TestSupport.h; clang/tools/clang-refactor/ToolRefactoringResultConsumer.h; clang/tools/clang-rename/ClangRename.cpp; clang/tools/clang-repl/ClangRepl.cpp; clang/tools/clang-scan-deps/ClangScanDeps.cpp; clang/tools/clang-shlib/clang-shlib.cpp; clang/tools/driver/cc1gen_reproducer_main.cpp; clang/tools/libclang/CIndex.cpp; clang/tools/libclang/CIndexUSRs.cpp; clang/tools/libclang/CursorVisitor.h; clang/tools/libclang/CXCursor.cpp; clang/tools/libclang/CXCursor.h; clang/tools/scan-build-py/tests/functional/src/include/clean-one.h; clang/unittests/Analysis/CFGBuildResult.h; clang/unittests/Analysis/MacroExpansionContextTest.cpp; clang/unittests/Analysis/FlowSensitive/DataflowAnalysisContextTest.cpp; clang/unittests/Analysis/FlowSensitive/DataflowEnvironmentTest.cpp; clang/unittests/Analysis/FlowSensitive/MapLatticeTest.cpp; clang/unittests/Analysis/FlowSensitive/MatchSwitchTest.cpp; clang/unittests/Analysis/FlowSensitive/MultiVarConstantPropagationTest.cpp; clang/unittests/Analysis/FlowSensitive/SingleVarConstantPropagationTest.cp,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:28115,refactor,refactor,28115,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"ay be much longer than the list above. To see a full list of; libraries use: ``llvm-config --libs all``. Using ``LINK_COMPONENTS`` as; described below, obviates the need to set ``LLVMLIBS``. ``LINK_COMPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add options that tell the compiler; the location of additional directories to search for header files. It is highly suggested that you append to ``CFLAGS`` and ``CPPFLAGS`` as; opposed to overwriting them. The LLVM ``Makefiles`` may already have; useful options in them that you may not want to overwrite. Placement of Object Code; ========================. The final location of built libraries and executables will depend upon whether; you do a ``Debug``, ``Release``, or ``Profile`` build. Libraries. All libraries (static and dynamic) will be stored in; ``PROJ_OBJ_ROOT/<type>/lib``, where *type* is ``Debug``, ``Release``, or; ``Profile`` for a debug, optimized, or profiled build, respectively. Executables. All executables will be stored in ``PROJ_OBJ_ROOT/<type>/bin``, where *type*; is ``Debug``, ``Release``, or ``Profile`` for a debug, optimized, or; profiled build, respectively. Further Help; ============. If you have an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:8043,variab,variable,8043,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,1,['variab'],['variable']
Modifiability,"ay disappear; in the future when all C++ compilers used with the ROOT system fully; support templates. In the mean time, knowing the; role TObject plays in collections can be helpful. In general you don't need to worry about TObject. Many ROOT; classes have TObject as an ancestor. In fact, collections themselves; are descendants of TObject. This makes it possible for collections to; contain other collections (subcollections) in a tree structure. Such trees; are used in the ROOT system to implement components of the graphics system; (graphics pads containing pads), geometries (detectors in detectors), etc. The basic protocol TObject defines for collection elements is shown below:. IsEqual(); Compare(); IsSortable(); Hash(). How to use and override these member functions is shown in the; example program. Types of Collections. The ROOT system implements the following type of collections:; arrays, lists, sorted lists, B-trees, hashtables and maps.; The figure below shows the inheritance hierarchy for the primary; collection classes. Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they; were added. The following sequence collections are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. Both a TObjArray as well as a TOrdCollection can be sorted; using their Sort() member function (assuming the stored items are; sortable). Sorted Collections. Sorted collections are ordered by an internal (automatic) sorting mechanism.; The following sorted collections are available:. TSortedList; TBtree. Unordered Collections. Unordered collections don't maintain the order in which the elements were added.; I.e. when you iterate over an unordered collection, you are not likely to; retrieve elements in the same order they were added to the collection.; The following unordered collections are available:. THashTable; TMap. Using Collections. Rene Brun,; Fons Rade",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/Understanding_Collections.html:1902,inherit,inheritance,1902,core/cont/doc/Understanding_Collections.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/doc/Understanding_Collections.html,1,['inherit'],['inheritance']
Modifiability,"ay optionally have a trailing reference to a; ``DILocation`` metadata node, after all operands and symbols, but before; memory operands:. .. code-block:: text. $rbp = MOV64rr $rdi, debug-location !12. The source location attachment is synonymous with the ``!dbg`` metadata; attachment in LLVM-IR. The absence of a source location attachment will be; represented by an empty ``DebugLoc`` object in the machine instruction. Fixed variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^. There are several ways of specifying variable locations. The simplest is; describing a variable that is permanently located on the stack. In the stack; or fixedStack attribute of the machine function, the variable, scope, and; any qualifying location modifier are provided:. .. code-block:: text. - { id: 0, name: offset.addr, offset: -24, size: 8, alignment: 8, stack-id: default,; 4 debug-info-variable: '!1', debug-info-expression: '!DIExpression()',; debug-info-location: '!2' }. Where:. - ``debug-info-variable`` identifies a DILocalVariable metadata node,. - ``debug-info-expression`` adds qualifiers to the variable location,. - ``debug-info-location`` identifies a DILocation metadata node. These metadata attributes correspond to the operands of a ``llvm.dbg.declare``; IR intrinsic, see the :ref:`source level debugging<format_common_intrinsics>`; documentation. Varying variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Variables that are not always on the stack or change location are specified; with the ``DBG_VALUE`` meta machine instruction. It is synonymous with the; ``llvm.dbg.value`` IR intrinsic, and is written:. .. code-block:: text. DBG_VALUE $rax, $noreg, !123, !DIExpression(), debug-location !456. The operands to which respectively:. 1. Identifies a machine location such as a register, immediate, or frame index,. 2. Is either $noreg, or immediate value zero if an extra level of indirection is to be added to the first operand,. 3. Identifies a ``DILocalVariable`` metadata node,. 4. Specifies an exp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:25048,variab,variable,25048,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability,"ay the memory footprint on workers and master as a; function of the entry processed (workers) or of the merging step; (master). A new button has been added to the PROOF dialog box to; retrieve and display the memory usage. On the workers about 100; measurements are recorded by default; this number can be changed with 'proof->SetParameter(""PROOF_MemLogFreq"", memlogfreq)';Add; the possibility to set upper limits on the virtual memory used by; processes; the session gets firts a warning when it reaches 80% of; the limit, and then processing is stopped whenit exceeds 95% of the; limit, sending back the results. Also, the memory footprint is notified; when the session is terminated. The limit in MBs is set by the; environment variable ""ROOTPROOFASSOFT"". An hard limit can be set via the; env ""ROOTPROOFASHARD"" (also in MBs): the process is automatically; killed by the system if it reaches this limit. Envs variables for the; PROOF processes can be set using the directive 'xpd.putenv' in the; xrootd config file.Input dataIntroduce the; concept of 'input data': these are objects that are distributed in; optimal way to the workers, which are available via the input list, but; which are not saved in the TQueryResult object. These are meant for big; objects whic can create a big overload when distributed via the; standard input list (which should mostly be used for job control; parameters).  To add an input-data object just use; TProof::AddInputData(TObject *); if the input-data objects are in a; file you can use TProof::SetInputDataFile(const char *file); the final; set of input-data objects is assembled from the objects added via; AddInputData and those found in the file defined bySetInputDataFile.  . Improvements:. More; complete set of tests in test/stressProof . To run with PROOF-Lite pass; the argument 'lite' as master URL, e.g. './stressProof lite'.Possibility; to control on the client via rc variable the location of the sandbox,; package directory, cache and dataset direc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:3179,config,config,3179,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['config'],['config']
Modifiability,"ay[argc]; // BOOM; }. # Compile and link; % clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer example_UseAfterFree.cc. or:. .. code-block:: console. # Compile; % clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer -c example_UseAfterFree.cc; # Link; % clang++ -g -fsanitize=address example_UseAfterFree.o. If a bug is detected, the program will print an error message to stderr and; exit with a non-zero exit code. AddressSanitizer exits on the first detected error.; This is by design:. * This approach allows AddressSanitizer to produce faster and smaller generated code; (both by ~5%).; * Fixing bugs becomes unavoidable. AddressSanitizer does not produce; false alarms. Once a memory corruption occurs, the program is in an inconsistent; state, which could lead to confusing results and potentially misleading; subsequent reports. If your process is sandboxed and you are running on OS X 10.10 or earlier, you; will need to set ``DYLD_INSERT_LIBRARIES`` environment variable and point it to; the ASan library that is packaged with the compiler used to build the; executable. (You can find the library by searching for dynamic libraries with; ``asan`` in their name.) If the environment variable is not set, the process will; try to re-exec. Also keep in mind that when moving the executable to another machine,; the ASan library will also need to be copied over. Symbolizing the Reports; =========================. To make AddressSanitizer symbolize its output; you need to set the ``ASAN_SYMBOLIZER_PATH`` environment variable to point to; the ``llvm-symbolizer`` binary (or make sure ``llvm-symbolizer`` is in your; ``$PATH``):. .. code-block:: console. % ASAN_SYMBOLIZER_PATH=/usr/local/bin/llvm-symbolizer ./a.out; ==9442== ERROR: AddressSanitizer heap-use-after-free on address 0x7f7ddab8c084 at pc 0x403c8c bp 0x7fff87fb82d0 sp 0x7fff87fb82c8; READ of size 4 at 0x7f7ddab8c084 thread T0; #0 0x403c8c in main example_UseAfterFree.cc:4; #1 0x7f7ddabcac4d in __libc_start_main ??:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:2994,variab,variable,2994,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['variab'],['variable']
Modifiability,"ayer concept by using a new layer,; IRTransformLayer, to add IR optimization support to KaleidoscopeJIT. Optimizing Modules using the IRTransformLayer; =============================================. In `Chapter 4 <LangImpl04.html>`_ of the ""Implementing a language with LLVM""; tutorial series the llvm *FunctionPassManager* is introduced as a means for; optimizing LLVM IR. Interested readers may read that chapter for details, but; in short: to optimize a Module we create an llvm::FunctionPassManager; instance, configure it with a set of optimizations, then run the PassManager on; a Module to mutate it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In this Chapter we will make optimization a phase of our JIT; instead. For now this will provide us a motivation to learn more about ORC; layers, but in the long term making optimization part of our JIT will yield an; important benefit: When we begin lazily compiling code (i.e. deferring; compilation of each function until the first time it's run) having; optimization managed by our JIT will allow us to optimize lazily too, rather; than having to do all our optimization up-front. To add optimization support to our JIT we will take the KaleidoscopeJIT from; Chapter 1 and compose an ORC *IRTransformLayer* on top. We will look at how the; IRTransformLayer works in more detail below, but the interface is simple: the; constructor for this layer takes a reference to the execution session and the; layer below (as all layers do) plus an *IR optimization function* that it will; apply to each Module that is added via addModule:. .. code-block:: c++. class KaleidoscopeJIT {; private:; ExecutionSession ES;; RTDyldObjectLinkingLayer ObjectLayer;; IRCompileLayer CompileLayer;; IRTransformLayer TransformLayer;. DataLayout DL;; MangleAndInterner Mangle;; ThreadSafeContex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:2133,layers,layers,2133,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['layers'],['layers']
Modifiability,"ays that are ``new[]``'d in ARC translation units cannot be; ``delete[]``'d in non-ARC translation units and vice-versa. .. _arc.ownership.restrictions.pass_by_writeback:. Passing to an out parameter by writeback; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If the argument passed to a parameter of type ``T __autoreleasing *`` has type; ``U oq *``, where ``oq`` is an ownership qualifier, then the argument is a; candidate for :arc-term:`pass-by-writeback`` if:. * ``oq`` is ``__strong`` or ``__weak``, and; * it would be legal to initialize a ``T __strong *`` with a ``U __strong *``. For purposes of overload resolution, an implicit conversion sequence requiring; a pass-by-writeback is always worse than an implicit conversion sequence not; requiring a pass-by-writeback. The pass-by-writeback is ill-formed if the argument expression does not have a; legal form:. * ``&var``, where ``var`` is a scalar variable of automatic storage duration; with retainable object pointer type; * a conditional expression where the second and third operands are both legal; forms; * a cast whose operand is a legal form; * a null pointer constant. .. admonition:: Rationale. The restriction in the form of the argument serves two purposes. First, it; makes it impossible to pass the address of an array to the argument, which; serves to protect against an otherwise serious risk of mis-inferring an; ""array"" argument as an out-parameter. Second, it makes it much less likely; that the user will see confusing aliasing problems due to the implementation,; below, where their store to the writeback temporary is not immediately seen; in the original argument variable. A pass-by-writeback is evaluated as follows:. #. The argument is evaluated to yield a pointer ``p`` of type ``U oq *``.; #. If ``p`` is a null pointer, then a null pointer is passed as the argument,; and no further work is required for the pass-by-writeback.; #. Otherwise, a temporary of type ``T __autoreleasing`` is created and; initialized to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:49165,variab,variable,49165,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"az(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; continue;; }. * ``SBS_Empty`` (in configuration: ``Empty``); Only merge empty blocks. .. code-block:: c++. while (true) {}; while (true) {; continue;; }. * ``SBS_Always`` (in configuration: ``Always``); Always merge short blocks into a single line. .. code-block:: c++. while (true) {}; while (true) { continue; }. .. _AllowShortCaseLabelsOnASingleLine:. **AllowShortCaseLabelsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.6` :ref:`¶ <AllowShortCaseLabelsOnASingleLine>`; If ``true``, short case labels will be contracted to a single line. .. code-block:: c++. true: false:; switch (a) { vs. switch (a) {; case 1: x = 1; break; case 1:; case 2: return; x = 1;; } break;; case 2:; return;; }. .. _AllowShortCompoundRequirementOnASingleLine:. **AllowShortCompoundRequirementOnASingleLine** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <AllowShortCompoundRequirementOnASingleLine>`; Allow short compound requirement on a single line. .. code-block:: c++. true:; template <typename T>; concept c = requires(T x) {; { x + 1 } -> std::same_as<int>;; };. false:; template <typename T>; concept c = requires(T x) {; {; x + 1; } -> std::same_as<int>;; };. .. _AllowShortEnumsOnASingleLin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:27336,config,configuration,27336,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"b = 2;. * ``bool AlignFunctionPointers`` Only for ``AlignConsecutiveDeclarations``. Whether function pointers are; aligned. .. code-block:: c++. true:; unsigned i;; int &r;; int *p;; int (*f)();. false:; unsigned i;; int &r;; int *p;; int (*f)();. * ``bool PadOperators`` Only for ``AlignConsecutiveAssignments``. Whether short assignment; operators are left-padded to the same length as long ones in order to; put all assignment operators to the right of the left hand side. .. code-block:: c++. true:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. false:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. .. _AlignConsecutiveDeclarations:. **AlignConsecutiveDeclarations** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignConsecutiveDeclarations>`; Style of aligning consecutive declarations. ``Consecutive`` will align the declaration names of consecutive lines.; This will result in formattings like:. .. code-block:: c++. int aaaa = 12;; float b = 23;; std::string ccc;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. For example, to align across empty lines and not across comments, either; of these work. .. code-block:: c++. AlignConsecutiveMacros: AcrossEmptyLines. AlignConsecutiveMacros:; Enabled: true; AcrossEmptyLines: true; AcrossComments: false. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. #define SHORT_NAME 42; #define LONGER_NAME 0x007f; #define EVEN_LONGER_NAME (2); #define foo(x) (x * x); #define bar(y, z) (y + z). int a = 1;; int somelongname = 2;; double c = 3;. int aaaa : 1;; int b : 12;; int ccc : 8;. int aaaa = 12;; float b = 23;; std::string ccc;. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;. false:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:14246,config,configuration,14246,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,b407830e0db0f843b1c1028119c9cd1; # via -r requirements.txt; idna==3.6 \; --hash=sha256:9ecdbbd083b06798ae1e86adcbfe8ab1479cf864e4ee30fe4e46a003d12491ca \; --hash=sha256:c05567e9c24a6b9faaa835c4821bad0590fbb9d5779e7caa6e1cc4978e7eb24f; # via requests; imagesize==1.4.1 \; --hash=sha256:0d8d18d08f840c19d0ee7ca1fd82490fdc3729b7ac93f49870406ddde8ef8d8b \; --hash=sha256:69150444affb9cb0d5cc5a92b3676f0b2fb7cd9ae39e947a5e11a36b4497cd4a; # via sphinx; jinja2==3.1.2 \; --hash=sha256:31351a702a408a9e7595a8fc6150fc3f43bb6bf7e319770cbc0db9df9437e852 \; --hash=sha256:6088930bfe239f0e6710546ab9c19c9ef35e29792895fed6e6e31a023a182a61; # via; # myst-parser; # sphinx; markdown==3.5.1 \; --hash=sha256:5874b47d4ee3f0b14d764324d2c94c03ea66bee56f2d929da9f2508d65e722dc \; --hash=sha256:b65d7beb248dc22f2e8a31fb706d93798093c308dc1aba295aedeb9d41a813bd; # via sphinx-markdown-tables; markdown-it-py==3.0.0 \; --hash=sha256:355216845c60bd96232cd8d8c40e8f9765cc86f46880e43a8fd22dc1a1a8cab1 \; --hash=sha256:e3f60a94fa066dc52ec76661e37c851cb232d92f9886b15cb560aaada2df8feb; # via; # mdit-py-plugins; # myst-parser; markupsafe==2.1.3 \; --hash=sha256:05fb21170423db021895e1ea1e1f3ab3adb85d1c2333cbc2310f2a26bc77272e \; --hash=sha256:0a4e4a1aff6c7ac4cd55792abf96c915634c2b97e3cc1c7129578aa68ebd754e \; --hash=sha256:10bbfe99883db80bdbaff2dcf681dfc6533a614f700da1287707e8a5d78a8431 \; --hash=sha256:134da1eca9ec0ae528110ccc9e48041e0828d79f24121a1a146161103c76e686 \; --hash=sha256:14ff806850827afd6b07a5f32bd917fb7f45b046ba40c57abdb636674a8b559c \; --hash=sha256:1577735524cdad32f9f694208aa75e422adba74f1baee7551620e43a3141f559 \; --hash=sha256:1b40069d487e7edb2676d3fbdb2b0829ffa2cd63a2ec26c4938b2d34391b4ecc \; --hash=sha256:1b8dd8c3fd14349433c79fa8abeb573a55fc0fdd769133baac1f5e07abf54aeb \; --hash=sha256:1f67c7038d560d92149c060157d623c542173016c4babc0c1913cca0564b9939 \; --hash=sha256:282c2cb35b5b673bbcadb33a585408104df04f14b2d9b01d4c345a3b92861c2c \; --hash=sha256:2c1b19b3aaacc6e57b7e25710ff571c24d6c3613a45e905b,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:10079,plugin,plugins,10079,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['plugin'],['plugins']
Modifiability,"bage collection intrinsics; <gc_intrinsics>` that offer support for a broad class of collector models. For; instance, the intrinsics permit:. * semi-space collectors. * mark-sweep collectors. * generational collectors. * incremental collectors. * concurrent collectors. * cooperative collectors. * reference counting. We hope that the support built into the LLVM IR is sufficient to support a; broad class of garbage collected languages including Scheme, ML, Java, C#,; Perl, Python, Lua, Ruby, other scripting languages, and more. Note that LLVM **does not itself provide a garbage collector** --- this should; be part of your language's runtime library. LLVM provides a framework for; describing the garbage collectors requirements to the compiler. In particular,; LLVM provides support for generating stack maps at call sites, polling for a; safepoint, and emitting load and store barriers. You can also extend LLVM -; possibly through a loadable :ref:`code generation plugins <plugin>` - to; generate code and data structures which conforms to the *binary interface*; specified by the *runtime library*. This is similar to the relationship between; LLVM and DWARF debugging info, for example. The difference primarily lies in; the lack of an established standard in the domain of garbage collection --- thus; the need for a flexible extension mechanism. The aspects of the binary interface with which LLVM's GC support is; concerned are:. * Creation of GC safepoints within code where collection is allowed to execute; safely. * Computation of the stack map. For each safe point in the code, object; references within the stack frame must be identified so that the collector may; traverse and perhaps update them. * Write barriers when storing object references to the heap. These are commonly; used to optimize incremental scans in generational collectors. * Emission of read barriers when loading object references. These are useful; for interoperating with concurrent collectors. There are add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:5994,extend,extend,5994,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,3,"['extend', 'plugin']","['extend', 'plugin', 'plugins']"
Modifiability,"balvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31291,variab,variables,31291,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"bbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed as before. .. code-block:: yaml. # Example of usage:; AlignTrailingComments:; Kind: Always; OverEmptyLines: 2. Nested configuration flags:. Alignment options. * ``TrailingCommentsAlignmentKinds Kind``; Specifies the way to align trailing comments. Possible values:. * ``TCAS_Leave`` (in configuration: ``Leave``); Leave trailing comments as they are. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Always`` (in configuration: ``Always``); Align trailing comments. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Never`` (in configuration: ``Never``); Don't align trailing comments but other formatter applies. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``unsigned OverEmptyLines`` How many empty lines to apply alignment.; When both ``MaxEmptyLinesToKeep`` and ``OverEmptyLines`` are set to 2,; it formats like below. .. code-block:: c++. int a; // all these. int ab; // comments are. int abcdef; // aligned. When ``MaxEmptyLinesToKeep`` is set to 2 and ``OverEmptyLines`` is set; to 1, it formats like below. .. code-block:: c++. int a; // these are. int ab; // aligned. int abcdef; // but this isn't. .. _AllowAllArgumentsOnNextLine:. **AllowAllArgumentsOnNextLine** (``Boolean``) :versionbadge:`clang-format 9` :ref:`¶ <AllowAllArgumentsOnNextLine>`; If a function call or braced initializer list ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:23552,config,configuration,23552,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. Note that this works only for statically linked libraries. LLVM is split; into a large number of static libraries, and the list of libraries you; require may be much longer than the list above. To see a full list of; libraries use: ``llvm-config --libs all``. Using ``LINK_COMPONENTS`` as; described below, obviates the need to set ``LLVMLIBS``. ``LINK_COMPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add options that tell the compiler; the location of additional directories to search for header files. It is highly suggested that you append to ``CFLAGS`` and ``CPPFLAGS`` as; opposed to overwriting them. The LLVM ``Makefiles`` may already have; useful options in them that you may not want to overwrite. Placement of Object Code; ========================. The final location of built libraries and executables will depend upon wheth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:7612,variab,variable,7612,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,1,['variab'],['variable']
Modifiability,"be able to open the address `http://localhost:8080` in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics. There is a [server snapshot](https://root.cern/js/latest/httpserver.C/?layout=simple&item=Canvases/c1) of running macro [tutorials/http/httpserver.C](https://github.com/root-project/root/blob/master/tutorials/http/httpserver.C) from ROOT tutorials. One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:. ```cpp; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; ```. Following URL parameters are supported:. | Name | Description |; | :-------------------- | :---------------- |; | thrds=N | number of threads used by the civetweb (default is 10) |; | top=name | configure top name, visible in the web browser |; | auth_file=filename | authentication file name, created with htdigets utility |; | auth_domain=domain | authentication domain |; | loopback | bind specified port to loopback 127.0.0.1 address |; | debug | enable debug mode, server returns html page with request info |; | websocket_timeout=tm | set web sockets timeout in seconds (default 300) |; | websocket_disable | disable web sockets handling (default enabled) |; | cors=domain | define value for CORS header ""Access-Control-Allow-Origin"" in server response |; | log=filename | configure civetweb log file |; | max_age=value | configures ""Cache-Control: max_age=value"" http header for all file-related requests, default 3600 |; | nocache | try to fully disable cache control for file requests |; | winsymlinks=no | do not resolve symbolic links on file system (Windows only), default true |; | dirlisting=no | enable/disable directory listing for browsing filesystem (default no) |. If necessary, one could bind http server to spec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:1713,config,configure,1713,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configure']
Modifiability,"be computed when; calling `GetEntryWithIndex()`. To build an index with only `majorname`,; specify `minorname=""0""` (default). Note that once the index is built, it can be saved with the **`TTree`**; object with:. ``` {.cpp}; tree.Write(); //if the file has been open in ""update"" mode; ```. The most convenient place to create the index is at the end of the; filling process just before saving the tree header. If a previous index; was computed, it is redefined by this new call. Note that this function can also be applied to a **`TChain`**. The; return value is the number of entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18314,variab,variables,18314,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"be evaluated; during translation is in the initializers of variables of static storage; duration, which are all notionally initialized before the program begins; executing (and thus before a non-default floating point environment can be; entered). But C++ has many more contexts where floating point constant; evaluation occurs. Specifically: for static/thread-local variables,; first try evaluating the initializer in a constant context, including in the; constant floating point environment (just like in C), and then, if that fails,; fall back to emitting runtime code to perform the initialization (which might; in general be in a different floating point environment). Consider this example when compiled with ``-frounding-math``. .. code-block:: console. constexpr float func_01(float x, float y) {; return x + y;; }; float V1 = func_01(1.0F, 0x0.000001p0F);. The C++ rule is that initializers for static storage duration variables are; first evaluated during translation (therefore, in the default rounding mode),; and only evaluated at runtime (and therefore in the runtime rounding mode) if; the compile-time evaluation fails. This is in line with the C rules;; C11 F.8.5 says: *All computation for automatic initialization is done (as if); at execution time; thus, it is affected by any operative modes and raises; floating-point exceptions as required by IEC 60559 (provided the state for the; FENV_ACCESS pragma is ‘‘on’’). All computation for initialization of objects; that have static or thread storage duration is done (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:73767,variab,variables,73767,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"be of :ref:`integer <t_integer>` types, or vectors of; the same number of integers. The bit size of the ``value`` must be; smaller than the bit size of the destination type, ``ty2``. Semantics:; """""""""""""""""""". The ``zext`` fills the high order bits of the ``value`` with zero bits; until it reaches the size of the destination type, ``ty2``. When zero extending from i1, the result will always be either 0 or 1. If the ``nneg`` flag is set, and the ``zext`` argument is negative, the result; is a poison value. Example:; """""""""""""""". .. code-block:: llvm. %X = zext i32 257 to i64 ; yields i64:257; %Y = zext i1 true to i32 ; yields i32:1; %Z = zext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>. %a = zext nneg i8 127 to i16 ; yields i16 127; %b = zext nneg i8 -1 to i16 ; yields i16 poison. .. _i_sext:. '``sext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = sext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``sext``' sign extends ``value`` to the type ``ty2``. Arguments:; """""""""""""""""""". The '``sext``' instruction takes a value to cast, and a type to cast it; to. Both types must be of :ref:`integer <t_integer>` types, or vectors of; the same number of integers. The bit size of the ``value`` must be; smaller than the bit size of the destination type, ``ty2``. Semantics:; """""""""""""""""""". The '``sext``' instruction performs a sign extension by copying the sign; bit (highest order bit) of the ``value`` until it reaches the bit size; of the type ``ty2``. When sign extending from i1, the extension always results in -1 or 0. Example:; """""""""""""""". .. code-block:: llvm. %X = sext i8 -1 to i16 ; yields i16 :65535; %Y = sext i1 true to i32 ; yields i32:-1; %Z = sext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>. '``fptrunc .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fptrunc <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``fptrunc``' instruction truncates ``v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:444677,extend,extends,444677,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extends']
Modifiability,"be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will not match loops whose; variables are initialized to ``'\0'``, ``0.0``, ``NULL``, or any form of; zero besides the integer 0. The last step is giving the matcher a name and binding the ``ForStmt``; as we will want to do something with it:. .. code-block:: c++. StatementMatcher LoopMatcher =; forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))).bind(""forLoop"");. Once you have defined your matchers, you will need to add a little more; scaffolding in order to run them. Matchers are paired with a; ``MatchCallback`` and registered with a ``MatchFinder`` object, then run; from a ``ClangTool``. More code!. Add the following to ``LoopConvert.cpp``:. .. code-block:: c++. #include ""clang/ASTMatchers/ASTMatchers.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h"". using namespace clang;; using namespace clan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:8204,variab,variable,8204,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['variab'],['variable']
Modifiability,"because the first dereference turns ``list_name`` into the name of the sub-list; (a, b, or c in the example), then the second dereference is to get the value of; the list. This pattern is used throughout CMake, the most common example is the compiler; flags options, which CMake refers to using the following variable expansions:; CMAKE_${LANGUAGE}_FLAGS and CMAKE_${LANGUAGE}_FLAGS_${CMAKE_BUILD_TYPE}. Other Types; -----------. Variables that are cached or specified on the command line can have types; associated with them. The variable's type is used by CMake's UI tool to display; the right input field. A variable's type generally doesn't impact evaluation,; however CMake does have special handling for some variables such as PATH.; You can read more about the special handling in `CMake's set documentation; <https://cmake.org/cmake/help/v3.5/command/set.html#set-cache-entry>`_. Scope; -----. CMake inherently has a directory-based scoping. Setting a variable in a; CMakeLists file, will set the variable for that file, and all subdirectories.; Variables set in a CMake module that is included in a CMakeLists file will be; set in the scope they are included from, and all subdirectories. When a variable that is already set is set again in a subdirectory it overrides; the value in that scope and any deeper subdirectories. The CMake set command provides two scope-related options. PARENT_SCOPE sets a; variable into the parent scope, and not the current scope. The CACHE option sets; the variable in the CMakeCache, which results in it being set in all scopes. The; CACHE option will not set a variable that already exists in the CACHE unless the; FORCE option is specified. In addition to directory-based scope, CMake functions also have their own scope.; This means variables set inside functions do not bleed into the parent scope.; This is not true of macros, and it is for this reason LLVM prefers functions; over macros whenever reasonable. .. note::; Unlike C-based languages, CMake'",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:6242,variab,variable,6242,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,2,['variab'],['variable']
Modifiability,"before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Method No Fisher Fisher, Mahalanobis Discrimination method. Configuration options for MVA method :. Configuration options reference for MVA method: PDERS. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). VolumeRangeMode No Adaptive Unscaled, MinMax, RMS, Adaptive, kNN Method to determine volume size. KernelEstimator No Box Box, Sphere, Teepee, Gauss, Sinc3, Sinc5, Sinc7, Sinc9, Sinc11, Lanczos2, Lanczos3, Lanczos5, Lanczos8, Trim Kernel estimation function. DeltaFrac No 3 − nEventsMin/Max for minmax and rms volume range. NEventsMin No 100 − nEventsMin for adaptive volume range. NEventsMax No 200 − nEventsMax for adap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:3776,variab,variable,3776,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variable']
Modifiability,"behaves as though the command-line option; ``-ffp-eval-method=source`` is enabled. Rounds intermediate results to; source-defined precision. When ``pragma clang fp eval_method(double)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=double`` is enabled. Rounds intermediate results to; ``double`` precision. When ``pragma clang fp eval_method(extended)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=extended`` is enabled. Rounds intermediate results to; target-dependent ``long double`` precision. In Win32 programming, for instance,; the long double data type maps to the double, 64-bit precision data type. The full syntax this pragma supports is; ``#pragma clang fp eval_method(source|double|extended)``. .. code-block:: c++. for(...) {; // The compiler will use long double as the floating-point evaluation; // method.; #pragma clang fp eval_method(extended); a = b[i] * c[i] + e;; }. Note: ``math.h`` defines the typedefs ``float_t`` and ``double_t`` based on the active; evaluation method at the point where the header is included, not where the; typedefs are used. Because of this, it is unwise to combine these typedefs with; ``#pragma clang fp eval_method``. To catch obvious bugs, Clang will emit an; error for any references to these typedefs within the scope of this pragma;; however, this is not a fool-proof protection, and programmers must take care. The ``#pragma float_control`` pragma allows precise floating-point; semantics and floating-point exception behavior to be specified; for a section of the source code. This pragma can only appear at file or; namespace scope, within a language linkage specification or at the start of a; compound statement (excluding comments). When used within a compound statement,; the pragma is active within the scope of the compound statement. This pragma; is modeled after a Microsoft pragma with the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:174345,extend,extended,174345,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['extend'],['extended']
Modifiability,"behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary object fields.; (`#66221 <https://github.com/llvm/llvm-project/issues/66221>`_). - A few crashes have been found and fixed using randomized testing related; to the use of ``_BitInt()`` in tidy checks and in clang analysis.; (`#67212 <https://github.com/llvm/llvm-project/pull/67212>`_,; `#66782 <https://github.com/llvm/llvm-project/pull/66782>`_,; `#65889 <https://github.com/llvm/llvm-project/pull/65889>`_,; `#65888 <https://github.com/llvm/llvm-proj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:70449,config,configuration,70449,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['config'],['configuration']
Modifiability,"ber names that this rule; is capable of calculating.; * embed - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include - A list of header files that should be included in order to provide the func-; tionality used in the code snippet; the list is comma delimited.; * code - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj - variable representing the target in-memory object, it’s type is that of the; target object; * oldObj - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer - in raw conversion rules, an object of TBuﬀer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. 3. The C++ API. The schema evolution C++ API consists of two classes: ROOT::TSchemaRuleSet and ROOT::TSchemaRule.; Objects of the TSchemaRule class represent the rules and their fields have exactly the same; meaning as the ones of rules specified in the dictionaries. TSchemaRuleSet objects; manage the sets of rules and ensure their consistency. There can be no conflicting; rules in the rule sets. The rule sets are owned by the TClass objects corresponding to the; target classes defined in the rules and can be accessed using TClass::{Get|Adopt}SchemaRules; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt:5081,variab,variable,5081,io/doc/DataModelEvolution.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt,2,['variab'],"['variable', 'variables']"
Modifiability,"bes the ABI; contract with the runtime and the compiler, and, as necessary, will be referred; to as ABI.2010.3.16. Since the Apple ABI references symbols from other elements of the system, any; attempt to use this ABI on systems prior to SnowLeopard is undefined. High Level; ==========. The ABI of ``Blocks`` consist of their layout and the runtime functions required; by the compiler. A ``Block`` of type ``R (^)(P...)`` consists of a structure of; the following form:. .. code-block:: c. struct Block_literal_1 {; void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock; int flags;; int reserved;; R (*invoke)(struct Block_literal_1 *, P...);; struct Block_descriptor_1 {; unsigned long int reserved; // NULL; unsigned long int size; // sizeof(struct Block_literal_1); // optional helper functions; void (*copy_helper)(void *dst, void *src); // IFF (1<<25); void (*dispose_helper)(void *src); // IFF (1<<25); // required ABI.2010.3.16; const char *signature; // IFF (1<<30); } *descriptor;; // imported variables; };. The following flags bits are in use thusly for a possible ABI.2010.3.16:. .. code-block:: c. enum {; // Set to true on blocks that have captures (and thus are not true; // global blocks) but are known not to escape for various other; // reasons. For backward compatibility with old runtimes, whenever; // BLOCK_IS_NOESCAPE is set, BLOCK_IS_GLOBAL is set too. Copying a; // non-escaping block returns the original block and releasing such a; // block is a no-op, which is exactly how global blocks are handled.; BLOCK_IS_NOESCAPE = (1 << 23),. BLOCK_HAS_COPY_DISPOSE = (1 << 25),; BLOCK_HAS_CTOR = (1 << 26), // helpers have C++ code; BLOCK_IS_GLOBAL = (1 << 28),; BLOCK_HAS_STRET = (1 << 29), // IFF BLOCK_HAS_SIGNATURE; BLOCK_HAS_SIGNATURE = (1 << 30),; };. In 10.6.ABI the (1<<29) was usually set and was always ignored by the runtime -; it had been a transitional marker that did not get deleted after the; transition. This bit is now paired with (1<<30)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:2047,variab,variables,2047,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: objc. ObjCBlockIndentWidth: 4. [operation setCompletionBlock:^{; [self onOperationDone];; }];. .. _ObjCBreakBeforeNestedBlockParam:. **ObjCBreakBeforeNestedBlockParam** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <ObjCBreakBeforeNestedBlockParam>`; Break parameters list into lines when there is nested block; parameters in a function call. .. code-block:: c++. false:; - (void)_aMethod; {; [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber; *u, NSNumber *v) {; u = c;; }]; }; true:; - (void)_aMethod; {; [self.test1 t:self; w:self; callback:^(typeof(self) sel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:89070,config,configuration,89070,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"binary and unary operators, it uses JIT; compilation for immediate evaluation, and it supports a few control flow; constructs with SSA construction. Part of the idea of this tutorial was to show you how easy and fun it; can be to define, build, and play with languages. Building a compiler; need not be a scary or mystical process! Now that you've seen some of; the basics, I strongly encourage you to take the code and hack on it.; For example, try adding:. - **global variables** - While global variables have questionable value; in modern software engineering, they are often useful when putting; together quick little hacks like the Kaleidoscope compiler itself.; Fortunately, our current setup makes it very easy to add global; variables: just have value lookup check to see if an unresolved; variable is in the global variable symbol table before rejecting it.; To create a new global variable, make an instance of the LLVM; ``GlobalVariable`` class.; - **typed variables** - Kaleidoscope currently only supports variables; of type double. This gives the language a very nice elegance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:1856,variab,variables,1856,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,2,['variab'],['variables']
Modifiability,bitcode file. **Number Of Symbol Tables**. The total number of symbol tables in all functions in the bitcode file. **Number Of Dependent Libs**. The total number of dependent libraries found in the bitcode file. **Total Instruction Size**. The total size of the instructions in all functions in the bitcode file. **Average Instruction Size**. The average number of bytes per instruction across all functions in the bitcode; file. This value is computed by dividing Total Instruction Size by Number Of; Instructions. **Maximum Type Slot Number**. The maximum value used for a type's slot number. Larger slot number values take; more bytes to encode. **Maximum Value Slot Number**. The maximum value used for a value's slot number. Larger slot number values take; more bytes to encode. **Bytes Per Value**. The average size of a Value definition (of any type). This is computed by; dividing File Size by the total number of values of any type. **Bytes Per Global**. The average size of a global definition (constants and global variables). **Bytes Per Function**. The average number of bytes per function definition. This is computed by; dividing Function Bytes by Number Of Functions. **# of VBR 32-bit Integers**. The total number of 32-bit integers encoded using the Variable Bit Rate; encoding scheme. **# of VBR 64-bit Integers**. The total number of 64-bit integers encoded using the Variable Bit Rate encoding; scheme. **# of VBR Compressed Bytes**. The total number of bytes consumed by the 32-bit and 64-bit integers that use; the Variable Bit Rate encoding scheme. **# of VBR Expanded Bytes**. The total number of bytes that would have been consumed by the 32-bit and 64-bit; integers had they not been compressed with the Variable Bit Rage encoding; scheme. **Bytes Saved With VBR**. The total number of bytes saved by using the Variable Bit Rate encoding scheme.; The percentage is relative to # of VBR Expanded Bytes. DETAILED OUTPUT DEFINITIONS; ---------------------------. The following,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-bcanalyzer.rst:5374,variab,variables,5374,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-bcanalyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-bcanalyzer.rst,1,['variab'],['variables']
Modifiability,"bject);; virtual Int_t ReadSequence(const TStreamerInfoActions::TActionSequence &sequence,; void *start_collection, void *end_collection);; virtual Int_t ReadSequence(const TStreamerInfoActions::TActionSequence &sequence,; void *start_collection, void *end_collection);. The 1st version is optimized to read a single object. The 2nd version is optimized to read the content of TClonesArrays and vectors of pointers to objects. The 3rd version is used to streamed any collections. TBufferXML and TBufferSQL overload the loops to introduce extra code to help the buffer keep track of which streamer element is being streamed (this functionality is not used by TBufferFile.). A TStreamerInfoActions::TActionSequence is an ordered sequence of configured actions. A configured action has both an action which is a free standing function and a configuration object deriving; from TStreamerInfoActions::TConfiguration. The configuration contains information that is specific to the action; but varies from use to use, including the offset from the beginning of the object that needs to be updated.; Other examples of configuration include the number of bits requested for storing a Double32_t or its factor and minimum. When the sequence is intended for a collection, the sequence has a configuration object deriving; from TStreamerInfoActions::TLoopConfiguration which contains for example the size of the element of; a vector or the pointers to the iterators functions (see below). Each TStreamerInfo has 2 reading sequences, one for object-wise reading (GetReadObjectWiseActions); and one for member-wise reading (GetReadMemberWiseActions) which is used when streaming a TClonesArray; of a vector of pointer to the type of objects described by the TClass. Each collection proxy has at least one reading sequences, one for the reading each version of the; contained class layout. Each case of the TStreamerInfo::ReadBuffer switch statement is replaced by 4 new action functions,; one for the object wise re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:4374,config,configuration,4374,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,1,['config'],['configuration']
Modifiability,"bjective-C and Objective-C++ languages, we allow the; ``__weak`` specifier for ``__block`` variables of object type. If; garbage collection is not enabled, this qualifier causes these; variables to be kept without retain messages being sent. This; knowingly leads to dangling pointers if the Block (or a copy) outlives; the lifetime of this object. In garbage collected environments, the ``__weak`` variable is set to; nil when the object it references is collected, as long as the; ``__block`` variable resides in the heap (either by default or via; ``Block_copy()``). The initial Apple implementation does in fact; start ``__block`` variables on the stack and migrate them to the heap; only as a result of a ``Block_copy()`` operation. It is a runtime error to attempt to assign a reference to a; stack-based Block into any storage marked ``__weak``, including; ``__weak`` ``__block`` variables. C++ Extensions; ==============. Block literal expressions within functions are extended to allow const; use of C++ objects, pointers, or references held in automatic storage. As usual, within the block, references to captured variables become; const-qualified, as if they were references to members of a const; object. Note that this does not change the type of a variable of; reference type. For example, given a class Foo:. .. code-block:: c. Foo foo;; Foo &fooRef = foo;; Foo *fooPtr = &foo;. A Block that referenced these variables would import the variables as; const variations:. .. code-block:: c. const Foo block_foo = foo;; Foo &block_fooRef = fooRef;; Foo *const block_fooPtr = fooPtr;. Captured variables are copied into the Block at the instant of; evaluating the Block literal expression. They are also copied when; calling ``Block_copy()`` on a Block allocated on the stack. In both; cases, they are copied as if the variable were const-qualified, and; it's an error if there's no such constructor. Captured variables in Blocks on the stack are destroyed when control; leaves the compound ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:11057,extend,extended,11057,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['extend'],['extended']
Modifiability,"bjects. The second is to provide a simple end-user language to; populate a RooWorkspace with function and p.d.f. objects. For the latter purpose the object creation language is executed through the factory() method; of a workspace object. RooWorkspace w(""w"") ;; RooAbsArg* arg = w.factory(""expression_goes_here"") ;. Basic Syntax; The rules at its simplest level are as follows. Expressions with square brackets create variables (discrete and continuous). ""m[-10,10]"" - Creates a RooRealVar named 'm' with range [-10,10]; ""m[5,-10,10]"" - Idem, but with initial value 5; ""m[5]"" - Creates a constant RooRealVar with name 'm' and value 5. ""tagCat[Lep,Kao,NT1,NT2]"" -- Creates a RooCategory with name tagCat and labeled states Lep,Kao,NT1,NT2; ""b0flav[B0=1,B0bar=-1]"" -- Creates a RooCategory with name b0flav and states B0 and B0bar with explicit index assignments. Expressions with parentheses create RooAbsArg function objects of any type. ""RooGaussian::g(x,m,s)"" -- Create a RooGaussian named g with variables x,m,s; This expression maps 1-1 to a createArg() call. ""Gaussian::g(x,m,s)"" -- Idem. The 'Roo' prefix on any class may be omitted. ""Gaussian(x,m,s)"" -- Create a RooGaussian with an automatically assigned name with variables x,m,s. Expressions with curly brackets creates RooArgSets or RooArgLists ""{x,y,z}"". Compound expressions; The real power of this language is that all these expressions may be nested to result in a compact; and readable expression that creates an entire p.d.f. and its components. ""Gaussian::g(x[-10,10],m[-10,10],3)"". Creates a RooGaussian named 'g', its observables 'x' with range [-10,10],; its parameter 'm' with range [-10,10]' and a constant width of 3. ""SUM::model( f[0.5,0,1] * Gaussian( x[-10,10], m[0], 3] ),; Chebychev( x, {a0[0.1],a1[0.2],a2[-0.3]}))"". Create a RooAddPdf model of a RooGaussian and a RooChebychev (which; are implicitly named model_0 and model_1), its observable x and its; parameters m,a0,a1,a2,Nsig and Nbkg; Note that each object may be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:19420,variab,variables,19420,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['variab'],['variables']
Modifiability,"ble code. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. LLVM Checkers. Name, DescriptionExample. alpha.llvm.Conventions; (C); Check code for LLVM codebase conventions:. A StringRef should not be bound to a temporary std::string; whose lifetime is shorter than the StringRef's.; Clang AST nodes should not have fields that can allocate memory. OS X Alpha Checkers. Name, DescriptionExample. alpha.osx.cocoa.DirectIvarAssignment; (ObjC); Check that Objective C properties follow the following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be inval",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:7564,variab,variables,7564,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['variab'],['variables']
Modifiability,"ble location in every basic block; requires the consideration of control flow. Consider the following IR, which; presents several difficulties:. .. code-block:: text. define dso_local i32 @foo(i1 %cond, i32 %input) !dbg !12 {; entry:; br i1 %cond, label %truebr, label %falsebr. bb1:; %value = phi i32 [ %value1, %truebr ], [ %value2, %falsebr ]; br label %exit, !dbg !26. truebr:; call void @llvm.dbg.value(metadata i32 %input, metadata !30, metadata !DIExpression()), !dbg !24; call void @llvm.dbg.value(metadata i32 1, metadata !23, metadata !DIExpression()), !dbg !24; %value1 = add i32 %input, 1; br label %bb1. falsebr:; call void @llvm.dbg.value(metadata i32 %input, metadata !30, metadata !DIExpression()), !dbg !24; call void @llvm.dbg.value(metadata i32 2, metadata !23, metadata !DIExpression()), !dbg !24; %value2 = add i32 %input, 2; br label %bb1. exit:; ret i32 %value, !dbg !30; }. Here the difficulties are:. * The control flow is roughly the opposite of basic block order; * The value of the ``!23`` variable merges into ``%bb1``, but there is no PHI; node. As mentioned above, the ``llvm.dbg.value`` intrinsics essentially form an; imperative program embedded in the IR, with each intrinsic defining a variable; location. This *could* be converted to an SSA form by mem2reg, in the same way; that it uses use-def chains to identify control flow merges and insert phi; nodes for IR Values. However, because debug variable locations are defined for; every machine instruction, in effect every IR instruction uses every variable; location, which would lead to a large number of debugging intrinsics being; generated. Examining the example above, variable ``!30`` is assigned ``%input`` on both; conditional paths through the function, while ``!23`` is assigned differing; constant values on either path. Where control flow merges in ``%bb1`` we would; want ``!30`` to keep its location (``%input``), but ``!23`` to become undefined; as we cannot determine at runtime what value it sho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:38159,variab,variable,38159,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"ble object owner type are moved off the stack; by initializing the heap copy with the result of moving from the stack copy. With the exception of retains done as part of initializing a ``__strong``; parameter variable or reading a ``__weak`` variable, whenever these semantics; call for retaining a value of block-pointer type, it has the effect of a; ``Block_copy``. The optimizer may remove such copies when it sees that the; result is used only as an argument to a call. When a block pointer type is converted to a non-block pointer type (such as; ``id``), ``Block_copy`` is called. This is necessary because a block allocated; on the stack won't get copied to the heap when the non-block pointer escapes.; A block pointer is implicitly converted to ``id`` when it is passed to a; function as a variadic argument. .. _arc.misc.exceptions:. Exceptions; ----------. By default in Objective C, ARC is not exception-safe for normal releases:. * It does not end the lifetime of ``__strong`` variables when their scopes are; abnormally terminated by an exception.; * It does not perform releases which would occur at the end of a; full-expression if that full-expression throws an exception. A program may be compiled with the option ``-fobjc-arc-exceptions`` in order to; enable these, or with the option ``-fno-objc-arc-exceptions`` to explicitly; disable them, with the last such argument ""winning"". .. admonition:: Rationale. The standard Cocoa convention is that exceptions signal programmer error and; are not intended to be recovered from. Making code exceptions-safe by; default would impose severe runtime and code size penalties on code that; typically does not actually care about exceptions safety. Therefore,; ARC-generated code leaks by default on exceptions, which is just fine if the; process is going to be immediately terminated anyway. Programs which do care; about recovering from exceptions should enable the option. In Objective-C++, ``-fobjc-arc-exceptions`` is enabled by default.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:97809,variab,variables,97809,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"ble to select an histogram on a canvas by clicking on the vertical; lines of the bins boundaries.; This problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-6649).; * When using time format in axis, `TGaxis::PaintAxis()` may in some cases call; `strftime()` with invalid parameter causing a crash.; This problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-7689).; * Having ""X11.UseXft: yes"" activated in .rootrc file and running; [this](https://sft.its.cern.ch/jira/browse/ROOT-7985) little program,; resulted in a crash.; * Ease the setting of the appearance of joining lines for PostScript and PDF; output. `TPostScript::SetLineJoin`; allowed to set the line joining style for PostScript files. But the setting this; parameter implied to create a `TPostScript` object. Now a `TStyle` setting has been; implemented and it is enough to do:; ``` {.cpp}; gStyle->SetLineJoinPS(2);; ```; Also this setting is now active for PDF output.; This enhancement was triggered by [this forum question](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=21077).; * Make sure the palette axis title is correct after a histogram cloning. This; problem was mentioned [here](https://sft.its.cern.ch/jira/browse/ROOT-8007).; * `TASImage` When the first or last point of a wide line is exactly on the; window limit the line is drawn vertically or horizontally.; This problem was mentioned [here](https://sft.its.cern.ch/jira/browse/ROOT-8021); * Make sure that `TLatex` text strings containing ""\\"" (ie: rendered using `TMathText`); produce an output in PDF et SVG files.; * In TLatex, with the Cocoa backend on Mac the Angstroem characters did not render correctly.; This problem was mentioned [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=21321); * New version of libpng (1.2.55) as requested [here](https://sft.its.cern.ch/jira/browse/ROOT-8045).; * Enhancement of the CANDLE drawing option (implemented by Georg Troska georg.troska@tu-dortmund.de).; This option has been comple",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:15960,enhance,enhancement,15960,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['enhance'],['enhancement']
Modifiability,"ble values to 3 elements. ### Symbolic pointers. This approach proves to be particularly useful for modeling pointer values,; since we don't care about specific addresses but just want to give a unique; identifier to a memory location. ```c++; void ExampleOfSymbolicPointers(bool b) {; int x = 0; // x is {0}; int* ptr = &x; // x is {0} ptr is {&x}; if (b) {; *ptr = 42; // x is {42} ptr is {&x}; }; print(x); // x is {0; 42} ptr is {&x}; }; ```. ## Example: finding output parameters. Let's explore how data flow analysis can help with a problem that is hard to; solve with other tools in Clang. ### Problem description. Output parameters are function parameters of pointer or reference type whose; pointee is completely overwritten by the function, and not read before it is; overwritten. They are common in pre-C++11 code due to the absence of move; semantics. In modern C++ output parameters are non-idiomatic, and return values; are used instead. Imagine that we would like to refactor output parameters to return values to; modernize old code. The first step is to identify refactoring candidates through; static analysis. For example, in the following code snippet the pointer `c` is an output; parameter:. ```c++; struct Customer {; int account_id;; std::string name;; }. void GetCustomer(Customer *c) {; c->account_id = ...;; if (...) {; c->name = ...;; } else {; c->name = ...;; }; }; ```. We would like to refactor this code into:. ```c++; Customer GetCustomer() {; Customer c;; c.account_id = ...;; if (...) {; c.name = ...;; } else {; c.name = ...;; }; return c;; }; ```. However, in the function below the parameter `c` is not an output parameter; because its field `name` is not overwritten on every path through the function. ```c++; void GetCustomer(Customer *c) {; c->account_id = ...;; if (...) {; c->name = ...;; }; }; ```. The code also cannot read the value of the parameter before overwriting it:. ```c++; void GetCustomer(Customer *c) {; use(c->account_id);; c->name = ...;; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:14856,refactor,refactor,14856,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactor']
Modifiability,"ble`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial value for a ``GlobalVariable``. It is not legal to call; this method if there is no initializer. .. _BasicBlock:. The ``BasicBlock`` class; ------------------------. ``#include ""llvm/IR/BasicBlock.h""``. header source: `BasicBlock.h; <https://llvm.org/doxygen/BasicBlock_8h_source.html>`_. doxygen info: `BasicBlock Class; <https://llvm.org/doxygen/classllvm_1_1BasicBlock.html>`_. Superclass: Value_. This class represents a single entry single exit section of the code, commonly; known as a basic block by the compiler community. The ``BasicBlock`` class; maintains a list of Instruction_\ s, which form the body of the block. Matching; the language definition, the last el",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:160279,variab,variable,160279,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,['variab'],['variable']
Modifiability,"bled by blank.""); mark_as_advanced(LLVM_TARGET_TRIPLE_ENV). if(CMAKE_SYSTEM_NAME MATCHES ""BSD|Linux|OS390""); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default ON); else(); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default OFF); endif(); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR ${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default} CACHE BOOL; ""Enable per-target runtimes directory""). set(LLVM_PROFDATA_FILE """" CACHE FILEPATH; ""Profiling data file to use when compiling in order to improve runtime performance.""). if(LLVM_INCLUDE_TESTS); # Lit test suite requires at least python 3.6; set(LLVM_MINIMUM_PYTHON_VERSION 3.6); else(); # FIXME: it is unknown if this is the actual minimum bound; set(LLVM_MINIMUM_PYTHON_VERSION 3.0); endif(). # Find python before including config-ix, since it needs to be able to search; # for python modules.; find_package(Python3 ${LLVM_MINIMUM_PYTHON_VERSION} REQUIRED; COMPONENTS Interpreter). # All options referred to from HandleLLVMOptions have to be specified; # BEFORE this include, otherwise options will not be correctly set on; # first cmake run; include(config-ix). # By default, we target the host, but this can be overridden at CMake; # invocation time. Except on 64-bit AIX, where the system toolchain; # expect 32-bit objects by default.; if(""${LLVM_HOST_TRIPLE}"" MATCHES ""^powerpc64-ibm-aix""); string(REGEX REPLACE ""^powerpc64"" ""powerpc"" LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT ""${LLVM_HOST_TRIPLE}""); else(); # Only set default triple when native target is enabled.; if (LLVM_NATIVE_TARGET); set(LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT ""${LLVM_HOST_TRIPLE}""); endif(); endif(). set(LLVM_DEFAULT_TARGET_TRIPLE ""${LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT}"" CACHE STRING; ""Default target for which LLVM will generate code."" ); message(STATUS ""LLVM default target triple: ${LLVM_DEFAULT_TARGET_TRIPLE}""). set(LLVM_TARGET_TRIPLE ""${LLVM_DEFAULT_TARGET_TRIPLE}""). if(WIN32 OR CYGWIN); if(BUILD_SHARED_LIBS OR LLVM_BUILD_LLVM_DYLIB); set(LLVM_ENABLE_PLUGINS_default ON); else(); set(LLVM_ENAB",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:37908,config,config-ix,37908,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config-ix']
Modifiability,"block:: c++. int* a;. * ``PAS_Right`` (in configuration: ``Right``); Align pointer to the right. .. code-block:: c++. int *a;. * ``PAS_Middle`` (in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qualifiers to be right-aligned. .. code-block:: c++. int const a;; int const *a;. * ``QAS_Custom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and; aligned in the order supplied. Items to the right of 'type' will be; placed to the rig",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:97176,config,configuration,97176,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that becaus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2963,variab,variable,2963,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,1,['variab'],['variable']
Modifiability,"block_byref_obj),; .byref_keep=_block_byref_obj_keep, .byref_dispose=_block_byref_obj_dispose,; .captured_obj = <initialization expression> )};. truct __block_literal_5 _block_literal = {; &_NSConcreteStackBlock,; (1<<25)|(1<<29), <uninitialized>,; __block_invoke_5,; &__block_descriptor_5,; &obj, // a reference to the on-stack structure containing ""captured_obj""; };. functioncall(_block_literal->invoke(&_block_literal));. C++ Support; ===========. Within a block stack based C++ objects are copied into ``const`` copies using; the copy constructor. It is an error if a stack based C++ object is used within; a block if it does not have a copy constructor. In addition both copy and; destroy helper routines must be synthesized for the block to support the; ``Block_copy()`` operation, and the flags work marked with the (1<<26) bit in; addition to the (1<<25) bit. The copy helper should call the constructor using; appropriate offsets of the variable within the supplied stack based block source; and heap based destination for all ``const`` constructed copies, and similarly; should call the destructor in the destroy routine. As an example, suppose a C++ class ``FOO`` existed with a copy constructor.; Within a code block a stack version of a ``FOO`` object is declared and used; within a ``Block`` literal expression:. .. code-block:: c++. {; FOO foo;; void (^block)(void) = ^{ printf(""%d\n"", foo.value()); };; }. The compiler would synthesize:. .. code-block:: c++. struct __block_literal_10 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_10 *);; struct __block_descriptor_10 *descriptor;; const FOO foo;; };. void __block_invoke_10(struct __block_literal_10 *_block) {; printf(""%d\n"", _block->foo.value());; }. void __block_copy_10(struct __block_literal_10 *dst, struct __block_literal_10 *src) {; FOO_ctor(&dst->foo, &src->foo);; }. void __block_dispose_10(struct __block_literal_10 *src) {; FOO_dtor(&src->foo);; }. static struct __block_descriptor_10 {",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:23982,variab,variable,23982,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variable']
Modifiability,"block_decl ::= type_expression. where type expression is extended to allow ``^`` as a Block reference; (pointer) where ``*`` is allowed as a function reference (pointer). The following Block literal:. .. code-block:: c. ^ void (void) { printf(""hello world\n""); }. produces a reference to a Block with no arguments with no return value. The return type is optional and is inferred from the return; statements. If the return statements return a value, they all must; return a value of the same type. If there is no value returned the; inferred type of the Block is void; otherwise it is the type of the; return statement value. If the return type is omitted and the argument list is ``( void )``,; the ``( void )`` argument list may also be omitted. So:. .. code-block:: c. ^ ( void ) { printf(""hello world\n""); }. and:. .. code-block:: c. ^ { printf(""hello world\n""); }. are exactly equivalent constructs for the same expression. The type_expression extends C expression parsing to accommodate Block; reference declarations as it accommodates function pointer; declarations. Given:. .. code-block:: c. typedef int (*pointerToFunctionThatReturnsIntWithCharArg)(char);; pointerToFunctionThatReturnsIntWithCharArg functionPointer;; ^ pointerToFunctionThatReturnsIntWithCharArg (float x) { return functionPointer; }. and:. .. code-block:: c. ^ int ((*)(float x))(char) { return functionPointer; }. are equivalent expressions, as is:. .. code-block:: c. ^(float x) { return functionPointer; }. [returnfunctionptr.c]. The compound statement body establishes a new lexical scope within; that of its parent. Variables used within the scope of the compound; statement are bound to the Block in the normal manner with the; exception of those in automatic (stack) storage. Thus one may access; functions and global variables as one would expect, as well as static; local variables. [testme]. Local automatic (stack) variables referenced within the compound; statement of a Block are imported and captured by the B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:3595,extend,extends,3595,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['extend'],['extends']
Modifiability,"bot-worker description::. Windows 7 x64; Core i7 (2.66GHz), 16GB of RAM. g++.exe (TDM-1 mingw32) 4.4.0; GNU Binutils 2.19.1; cmake version 2.8.4; Microsoft(R) 32-bit C/C++ Optimizing Compiler Version 16.00.40219.01 for 80x86. See `here <http://docs.buildbot.net/current/manual/installation/worker.html>`_; for which files to edit. #. Send a patch which adds your build worker and your builder to; `zorg <https://github.com/llvm/llvm-zorg>`_. Use the typical LLVM; `workflow <https://llvm.org/docs/Contributing.html#how-to-submit-a-patch>`_. * workers are added to ``buildbot/osuosl/master/config/workers.py``; * builders are added to ``buildbot/osuosl/master/config/builders.py``. Please make sure your builder name and its builddir are unique through the; file. All new builders should default to using the ""'collapseRequests': False""; configuration. This causes the builder to build each commit individually; and not merge build requests. To maximize quality of feedback to developers,; we *strongly prefer* builders to be configured not to collapse requests.; This flag should be removed only after all reasonable efforts have been; exhausted to improve build times such that the builder can keep up with; commit flow. It is possible to allow email addresses to unconditionally receive; notifications on build failure; for this you'll need to add an; ``InformativeMailNotifier`` to ``buildbot/osuosl/master/config/status.py``.; This is particularly useful for the staging buildmaster which is silent; otherwise. #. Send the buildbot-worker access name and the access password directly to; `Galina Kistanova <mailto:gkistanova@gmail.com>`_, and wait until she; lets you know that your changes are applied and buildmaster is; reconfigured. #. Make sure you can start the buildbot-worker and successfully connect; to the silent buildmaster. Then set up your buildbot-worker to start; automatically at the start up time. See the buildbot documentation; for help. You may want to restart your computer t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:5770,config,configured,5770,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['configured']
Modifiability,"branches . PruneStrength No 0 − Pruning strength. PruningValFraction No 0.5 − Fraction of events to use for optimizing automatic pruning. nEventsMin No 0 − deprecated: Use MinNodeSize (in % of training events) instead. GradBaggingFraction No 0.6 − deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. . UseNTrainEvents No 0 − deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees. NNodesMax No 0 − deprecated: Use MaxDepth instead to limit the tree size. Configuration options for MVA method :. Configuration options reference for MVA method: Boost. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Boost_Num No 100 − Number of times the classifier is boosted. Boost_MonitorMethod No True − Write monitoring histograms for each boosted classifier. Boost_DetailedMonitoring No False − Produce histograms for detailed boost-wise monitoring. Boost_Type No AdaBoost AdaBoost, Bagging, HighEdgeGauss, HighEdgeCoPara Boosting type for the classifiers. Boost_BaggedSampleFraction No 0.6 − Relative size of bagged event sample ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:15969,variab,variable,15969,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variable']
Modifiability,"brary name string, one of the libraries; mentioned in a ``deplibs`` declaration. There should be one ``DEPLIB`` record; for each library name referenced. MODULE_CODE_GLOBALVAR Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[GLOBALVAR, strtab offset, strtab size, pointer type, isconst, initid, linkage, alignment, section, visibility, threadlocal, unnamed_addr, externally_initialized, dllstorageclass, comdat, attributes, preemptionspecifier]``. The ``GLOBALVAR`` record (code 7) marks the declaration or definition of a; global variable. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the global variable.; See `STRTAB_BLOCK Contents`_. * *pointer type*: The type index of the pointer type used to point to this; global variable. * *isconst*: Non-zero if the variable is treated as constant within the module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: An encoding of the linkage type for this variable:. * ``external``: code 0; * ``weak``: code 1; * ``appending``: code 2; * ``internal``: code 3; * ``linkonce``: code 4; * ``dllimport``: code 5; * ``dllexport``: code 6; * ``extern_weak``: code 7; * ``common``: code 8; * ``private``: code 9; * ``weak_odr``: code 10; * ``linkonce_odr``: code 11; * ``available_externally``: code 12; * deprecated : code 13; * deprecated : code 14. * alignment*: The logarithm base 2 of the variable's requested alignment, plus 1. * *section*: If non-zero, the 1-based section index in the table of; `MODULE_CODE_SECTIONNAME`_ entries. .. _visibility:. * *visibility*: If present, an encoding of the visibility of this variable:. * ``default``: code 0; * ``hidden``: code 1; * ``protected``: code 2. .. _bcthreadlocal:. * *threadlocal*: If present, an encoding of the thread local storage mode of the; variable:. * ``not thread local``: code 0; * ``thread local; default TLS model``: code 1; * ``localdynamic``: code 2; * ``initialexec``:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:27798,variab,variable,27798,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"bricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version histo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:12809,enhance,enhancement,12809,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['enhance'],['enhancement']
Modifiability,"bs: (1) Running every IR Module that is emitted via this; layer through the transform function object, and (2) implementing the ORC; ``IRLayer`` interface (which itself conforms to the general ORC Layer concept,; more on that below). Most of the class is straightforward: a typedef for the; transform function, a constructor to initialize the members, a setter for the; transform function value, and a default no-op transform. The most important; method is ``emit`` as this is half of our IRLayer interface. The emit method; applies our transform to each module that it is called on and, if the transform; succeeds, passes the transformed module to the base layer. If the transform; fails, our emit function calls; ``MaterializationResponsibility::failMaterialization`` (this JIT clients who; may be waiting on other threads know that the code they were waiting for has; failed to compile) and logs the error with the execution session before bailing; out. The other half of the IRLayer interface we inherit unmodified from the IRLayer; class:. .. code-block:: c++. Error IRLayer::add(JITDylib &JD, ThreadSafeModule TSM, VModuleKey K) {; return JD.define(std::make_unique<BasicIRLayerMaterializationUnit>(; *this, std::move(K), std::move(TSM)));; }. This code, from ``llvm/lib/ExecutionEngine/Orc/Layer.cpp``, adds a; ThreadSafeModule to a given JITDylib by wrapping it up in a; ``MaterializationUnit`` (in this case a ``BasicIRLayerMaterializationUnit``).; Most layers that derived from IRLayer can rely on this default implementation; of the ``add`` method. These two operations, ``add`` and ``emit``, together constitute the layer; concept: A layer is a way to wrap a part of a compiler pipeline (in this case; the ""opt"" phase of an LLVM compiler) whose API is opaque to ORC with an; interface that ORC can call as needed. The add method takes an; module in some input program representation (in this case an LLVM IR module); and stores it in the target ``JITDylib``, arranging for it to be passed",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:8957,inherit,inherit,8957,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['inherit'],['inherit']
Modifiability,"bstitution list,; the insertion behavior of the ``DEFINE:`` and ``REDEFINE:`` directives is; specified below and is designed specifically for the use case presented in the; example above.; - Defining a substitution in terms of itself, whether directly or via other; substitutions, should be avoided. It usually produces an infinitely recursive; definition that cannot be fully expanded. It does *not* define the; substitution in terms of its previous value, even when using ``REDEFINE:``. The relationship between the ``DEFINE:`` and ``REDEFINE:`` directive is; analogous to the relationship between a variable declaration and variable; assignment in many programming languages:. - ``DEFINE: %{name} = value``. This directive assigns the specified value to a new substitution whose; pattern is ``%{name}``, or it reports an error if there is already a; substitution whose pattern contains ``%{name}`` because that could produce; confusing expansions (e.g., a lit configuration file might define a; substitution with the pattern ``%{name}\[0\]``). The new substitution is; inserted at the start of the substitution list so that it will expand first.; Thus, its value can contain any substitution previously defined, whether in; the same test file or in a lit configuration file, and both will expand. - ``REDEFINE: %{name} = value``. This directive assigns the specified value to an existing substitution whose; pattern is ``%{name}``, or it reports an error if there are no substitutions; with that pattern or if there are multiple substitutions whose patterns; contain ``%{name}``. The substitution's current position in the substitution; list does not change so that expansion order relative to other existing; substitutions is preserved. The following properties apply to both the ``DEFINE:`` and ``REDEFINE:``; directives:. - **Substitution name**: In the directive, whitespace immediately before or; after ``%{name}`` is optional and discarded. ``%{name}`` must start with; ``%{``, it must end wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:32812,config,configuration,32812,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configuration']
Modifiability,"bugs; by turning OOB accesses into deterministic traps. The ``-fbounds-safety`` extension offers bounds annotations that programmers can; use to attach bounds to pointers. For example, programmers can add the; ``__counted_by(N)`` annotation to parameter ``ptr``, indicating that the pointer; has ``N`` valid elements:. .. code-block:: c. void foo(int *__counted_by(N) ptr, size_t N);. Using this bounds information, the compiler inserts bounds checks on every; pointer dereference, ensuring that the program does not access memory outside; the specified bounds. The compiler requires programmers to provide enough bounds; information so that the accesses can be checked at either run time or compile; time — and it rejects code if it cannot. The most important contribution of ``-fbounds-safety`` is how it reduces the; programmer's annotation burden by reconciling bounds annotations at ABI; boundaries with the use of implicit wide pointers (a.k.a. ""fat"" pointers) that; carry bounds information on local variables without the need for annotations. We; designed this model so that it preserves ABI compatibility with C while; minimizing adoption effort. The ``-fbounds-safety`` extension has been adopted on millions of lines of; production C code and proven to work in a consumer operating system setting. The; extension was designed to enable incremental adoption — a key requirement in; real-world settings where modifying an entire project and its dependencies all; at once is often not possible. It also addresses multiple of other practical; challenges that have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extensio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:1433,variab,variables,1433,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variables']
Modifiability,"build check-llvm; # runs our new test alongside all other llvm lit tests. FAQs; ====. Required passes; ---------------. A pass that defines a static ``isRequired()`` method that returns true is a required pass. For example:. .. code-block:: c++. class HelloWorldPass : public PassInfoMixin<HelloWorldPass> {; public:; PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);. static bool isRequired() { return true; }; };. A required pass is a pass that may not be skipped. An example of a required; pass is ``AlwaysInlinerPass``, which must always be run to preserve; ``alwaysinline`` semantics. Pass managers are required since they may contain; other required passes. An example of how a pass can be skipped is the ``optnone`` function; attribute, which specifies that optimizations should not be run on the; function. Required passes will still be run on ``optnone`` functions. For more implementation details, see; ``PassInstrumentation::runBeforePass()``. Registering passes as plugins; -----------------------------. LLVM provides a mechanism to register pass plugins within various tools like; ``clang`` or ``opt``. A pass plugin can add passes to default optimization; pipelines or to be manually run via tools like ``opt``. For more information,; see :doc:`NewPassManager`. Create a CMake project at the root of the repo alongside; other projects. This project must contain the following minimal; ``CMakeLists.txt``:. .. code-block:: cmake. add_llvm_pass_plugin(MyPassName source.cpp). See the definition of ``add_llvm_pass_plugin`` for more CMake details. The pass must provide at least one of two entry points for the new pass manager,; one for static registration and one for dynamically loaded plugins:. - ``llvm::PassPluginLibraryInfo get##Name##PluginInfo();``; - ``extern ""C"" ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo() LLVM_ATTRIBUTE_WEAK;``. Pass plugins are compiled and linked dynamically by default. Setting; ``LLVM_${NAME}_LINK_INTO_TOOLS`` to ``ON`` turns th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:7325,plugin,plugins,7325,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,1,['plugin'],['plugins']
Modifiability,"build. If the ``install``; target is run then this also enables all built documentation targets to be; installed. Defaults to OFF. To enable a particular documentation target, see; see LLVM_ENABLE_SPHINX and LLVM_ENABLE_DOXYGEN. **LLVM_BUILD_EXAMPLES**:BOOL; Build LLVM examples. Defaults to OFF. Targets for building each example are; generated in any case. See documentation for *LLVM_BUILD_TOOLS* above for more; details. **LLVM_BUILD_INSTRUMENTED_COVERAGE**:BOOL; If enabled, `source-based code coverage; <https://clang.llvm.org/docs/SourceBasedCodeCoverage.html>`_ instrumentation; is enabled while building llvm. If CMake can locate the code coverage; scripts and the llvm-cov and llvm-profdata tools that pair to your compiler,; the build will also generate the `generate-coverage-report` target to generate; the code coverage report for LLVM, and the `clear-profile-data` utility target; to delete captured profile data. See documentation for; *LLVM_CODE_COVERAGE_TARGETS* and *LLVM_COVERAGE_SOURCE_DIRS* for more; information on configuring code coverage reports. **LLVM_CODE_COVERAGE_TARGETS**:STRING; If set to a semicolon separated list of targets, those targets will be used; to drive the code coverage reports. If unset, the target list will be; constructed using the LLVM build's CMake export list. **LLVM_COVERAGE_SOURCE_DIRS**:STRING; If set to a semicolon separated list of directories, the coverage reports; will limit code coverage summaries to just the listed directories. If unset,; coverage reports will include all sources identified by the tooling. **LLVM_INDIVIDUAL_TEST_COVERAGE**:BOOL; Enable individual test case coverage. When set to ON, code coverage data for; each test case will be generated and stored in a separate directory under the; config.test_exec_root path. This feature allows code coverage analysis of each; individual test case. Defaults to OFF. **LLVM_BUILD_LLVM_DYLIB**:BOOL; If enabled, the target for building the libLLVM shared library is added.; This",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:15290,config,configuring,15290,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['config'],['configuring']
Modifiability,"but are also fully supported. `std::string`; """""""""""""""""""""""""". The C++ core type ``std::string`` is considered the equivalent of Python's; ``str``, even as purely implementation-wise, it is more akin to ``bytes``:; as a practical matter, a C++ programmer would use ``std::string`` where a; Python developer would use ``str`` (and vice versa), not ``bytes``. A Python ``str`` is unicode, however, whereas an ``std::string`` is character; based, thus conversions require encoding or decoding.; To allow for different encodings, ``cppyy`` defers implicit conversions; between the two types until forced, at which point it will default to seeing; ``std::string`` as ASCII based and ``str`` to use the UTF-8 codec.; To support this, the bound ``std::string`` has been pythonized to allow it to; be a drop-in for a range of uses as appropriate within the local context. In particular, it is sometimes necessary (e.g. for function arguments that; take a non-const reference or a pointer to non-const ``std::string``; variables), to use an actual ``std::string`` instance to allow in-place; modifications.; The pythonizations then allow their use where ``str`` is expected.; For example:. .. code-block:: python. >>> cppyy.cppexec(""std::string gs;""); True; >>> cppyy.gbl.gs = ""hello""; >>> type(cppyy.gbl.gs) # C++ std::string type; <class cppyy.gbl.std.string at 0x7fbb02a89880>; >>> d = {""hello"": 42} # dict filled with str; >>> d[cppyy.gbl.gs] # drop-in use of std::string -> str; 42; >>>. To handle codecs other than UTF-8, the ``std::string`` pythonization adds a; ``decode`` method, with the same signature as the equivalent method of; ``bytes``.; If it is known that a specific C++ function always returns an ``std::string``; representing unicode with a codec other than UTF-8, it can in turn be; explicitly pythonized to do the conversion with that codec. `std::string_view`; """""""""""""""""""""""""""""""""""". It is possible to construct a (char-based) ``std::string_view`` from a Python; ``str``, but it requires the u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/strings.rst:1510,variab,variables,1510,bindings/pyroot/cppyy/cppyy/doc/source/strings.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/strings.rst,1,['variab'],['variables']
Modifiability,"by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a source does. # Source function; # size_t fread(void *ptr, size_t size, size_t nmemb, FILE * stream); #; # Result example:; # FILE* f = fopen(""file.txt"");; # char buf[1024];; # size_t read = fread(buf, sizeof(buf[0]), sizeof(buf)/sizeof(buf[0]), f);; # // both read and buf are tainted; - Name: fread; DstArgs: [0, -1]. # Propagation functions; # The presence of Src",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1971,config,configuration,1971,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['config'],['configuration']
Modifiability,"by default when the build; is broken. This buildmaster is reconfigured every two hours with any new; commits from the llvm-zorg repository. In order to remain connected to the main buildmaster (and thus notify; developers of failures), a builbot must:. * Be building a supported configuration. Builders for experimental backends; should generally be attached to staging buildmaster.; * Be able to keep up with new commits to the main branch, or at a minimum; recover to tip of tree within a couple of days of falling behind. Additionally, we encourage all bot owners to point their bots towards the; staging master during maintenance windows, instability troubleshooting, and; such. Roles & Expectations; ====================. Each buildbot has an owner who is the responsible party for addressing problems; which arise with said buildbot. We generally expect the bot owner to be; reasonably responsive. For some bots, the ownership responsibility is split between a ""resource owner""; who provides the underlying machine resource, and a ""configuration owner"" who; maintains the build configuration. Generally, operational responsibility lies; with the ""config owner"". We do expect ""resource owners"" - who are generally; the contact listed in a workers attributes - to proxy requests to the relevant; ""config owner"" in a timely manner. Most issues with a buildbot should be addressed directly with a bot owner; via email. Please CC `Galina Kistanova <mailto:gkistanova@gmail.com>`_. Steps To Add Builder To LLVM Buildbot; =====================================; Volunteers can provide their build machines to work as build workers to; public LLVM Buildbot. Here are the steps you can follow to do so:. #. Check the existing build configurations to make sure the one you are; interested in is not covered yet or gets built on your computer much; faster than on the existing one. We prefer faster builds so developers; will get feedback sooner after changes get committed. #. The computer you will be regi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:1779,config,configuration,1779,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,2,['config'],['configuration']
Modifiability,"by this function will have names; corresponding to the collection or object names. It is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33770,extend,extend,33770,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['extend'],['extend']
Modifiability,"bytes relevant to a store. This is mostly relevant to; unaligned stores: it is not allowed in general to convert an unaligned store; into two aligned stores of the same width as the unaligned store. Backends are; also expected to generate an i8 store as an i8 store, and not an instruction; which writes to surrounding bytes. (If you are writing a backend for an; architecture which cannot satisfy these restrictions and cares about; concurrency, please send an email to llvm-dev.). Unordered; ---------. Unordered is the lowest level of atomicity. It essentially guarantees that races; produce somewhat sane results instead of having undefined behavior. It also; guarantees the operation to be lock-free, so it does not depend on the data; being part of a special atomic structure or depend on a separate per-process; global lock. Note that code generation will fail for unsupported atomic; operations; if you need such an operation, use explicit locking. Relevant standard; This is intended to match the Java memory model for shared variables. Notes for frontends; This cannot be used for synchronization, but is useful for Java and other; ""safe"" languages which need to guarantee that the generated code never; exhibits undefined behavior. Note that this guarantee is cheap on common; platforms for loads of a native width, but can be expensive or unavailable for; wider loads, like a 64-bit store on ARM. (A frontend for Java or other ""safe""; languages would normally split a 64-bit store on ARM into two 32-bit unordered; stores.). Notes for optimizers; In terms of the optimizer, this prohibits any transformation that transforms a; single load into multiple loads, transforms a store into multiple stores,; narrows a store, or stores a value which would not be stored otherwise. Some; examples of unsafe optimizations are narrowing an assignment into a bitfield,; rematerializing a load, and turning loads and stores into a memcpy; call. Reordering unordered operations is safe, though, and opt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:8477,variab,variables,8477,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['variab'],['variables']
Modifiability,"c :; C(); try {; f();; }; catch (...) {; i=2; // warn; }; };. void f() { throw 1; }. class Base {; public:; int i;; };. class C: public Base {; public :; ~C() try {; f();; }; catch (...) {; i=2; // warn; }; };. undefbehavior.ReturnAtCatchEnd; (C++); Undefined behavior: a function returns when control reaches the end of a; handler. This results in undefined behavior in a value-returning function.; Source: C++11 15.3p10. void f() { throw 1; }. int test() try {; f();; return 1;; }; catch(int) {; } // warn. undefbehavior.AutoptrsOwnSameObj; (C++03); Undefined behavior: if more than one auto_ptr owns the same object; at the same time the behavior of the program is undefined.; Source: C++03 20.4.5p3; C++11 auto_ptr is deprecated; (D.10). #include <memory>. void test() {; int *data = new int;; std::auto_ptr<int> p(data);; std::auto_ptr<int> q(data); // warn; }. undefbehavior.BasicStringOutOfBound; (C++03); Undefined behavior: out-of-bound basic_string access/modification.; Note: possibly an enhancement to ; alpha.security.ArrayBoundV2.; Source: C++03 21.3.4p1; C++11 behavior is defined; (21.4.5p2). #include <string>. void test() {; std::basic_string<char> s;; char c = s[10]; // warn; }. #include <string>. void test() {; std::basic_string<char> s;; s[10] = 0; // warn; }. undefbehavior.EosDereference; (C++); Undefined behavior: the result of operator*() on an end of a; stream is undefined.; Source: C++03 24.5.3p2; C++11 24.6.3p2. #include <vector>. int test() {; std::vector<int> v;; return *v.end(); // warn; }. undefbehavior.QsortNonPODNonTrivial; (C++); C++03: Undefined behavior: the objects in the array passed to qsort are of; non-POD type.; C++11: Undefined behavior: the objects in the array passed to qsort are of; non-trivial type.; Source: C++03 25.4p4; C++11 25.5p4. // C++03; #include <cstdlib>. struct non_POD {; non_POD();; };. non_POD values[] = { non_POD(), non_POD() };. int compare(const void *a, const void *b);. void test() {; qsort(values, 2, sizeof(non_POD), comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:13676,enhance,enhancement,13676,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['enhance'],['enhancement']
Modifiability,"c or obj directory.]. #. You can now run the test suite from your build tree as follows:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT/projects/test-suite; % make. Note that the second and third steps only need to be done once. After; you have the suite checked out and configured, you don't need to do it; again (unless the test code or configure script changes). Configuring External Tests; ==========================. In order to run the External tests in the ``test-suite`` module, you; must specify *--with-externals*. This must be done during the; *re-configuration* step (see above), and the ``llvm`` re-configuration; must recognize the previously-built ``llvm-gcc``. If any of these is; missing or neglected, the External tests won't work. * *--with-externals*. * *--with-externals=<directory>*. This tells LLVM where to find any external tests. They are expected to; be in specifically named subdirectories of <``directory``>. If; ``directory`` is left unspecified, ``configure`` uses the default value; ``/home/vadve/shared/benchmarks/speccpu2000/benchspec``. Subdirectory; names known to LLVM include:. * spec95. * speccpu2000. * speccpu2006. * povray31. Others are added from time to time, and can be determined from; ``configure``. Running Different Tests; =======================. In addition to the regular ""whole program"" tests, the ``test-suite``; module also provides a mechanism for compiling the programs in different; ways. If the variable TEST is defined on the ``gmake`` command line, the; test system will include a Makefile named; ``TEST.<value of TEST variable>.Makefile``. This Makefile can modify; build rules to yield different results. For example, the LLVM nightly tester uses ``TEST.nightly.Makefile`` to; create the nightly test reports. To run the nightly tests, run; ``gmake TEST=nightly``. There are several TEST Makefiles available in the tree. Some of them are; designed for internal LLVM research and will not work outside of the; LLVM research group. They may st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:2482,config,configure,2482,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['config'],['configure']
Modifiability,"c to the implicit; kernel argument that holds the multigrid synchronization pointer. If this; attribute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-no-default-queue"" Similar to amdgpu-no-implicitarg-ptr, except specific to the implicit; kernel argument that holds the default queue pointer. If this; attribute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-no-completion-action"" Similar to amdgpu-no-implicitarg-ptr, except specific to the implicit; kernel argument that holds the completion action pointer. If this; attribute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-lds-size""=""min[,max]"" Min is the minimum number of bytes that will be allocated in the Local; Data Store at address zero. Variables are allocated within this frame; using absolute symbol metadata, primarily by the AMDGPULowerModuleLDS; pass. Optional max is the maximum number of bytes that will be allocated.; Note that min==max indicates that no further variables can be added to; the frame. This is an internal detail of how LDS variables are lowered,; language front ends should not set this attribute. ======================================= ==========================================================. Calling Conventions; -------------------. The AMDGPU backend supports the following calling conventions:. .. table:: AMDGPU Calling Conventions; :name: amdgpu-cc. =============================== ==========================================================; Calling Convention Description; =============================== ==========================================================; ``ccc`` The C calling convention. Used by default.; See :ref:`amdgpu-amdhsa-function-call-convention-non-kernel-functions`; for more details. ``fastcc`` The fast calling convention. Mostly the same as the ``ccc``. ``coldcc`` The cold calling convention. Mostly the same as the ``ccc``. ``amdgpu_cs`` Used for Mesa/AMDPAL compute shaders.; ..TODO::; Describe. ``amdg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:51709,variab,variables,51709,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variables']
Modifiability,"c tools. This can be changed well by setting; *LLVM_INSTALL_TOOLCHAIN_ONLY* to ``On``. The LLVM tools are intended for; development and testing of LLVM, and should only be included in distributions; that support LLVM development. When building with *LLVM_DISTRIBUTION_COMPONENTS* the build system also; generates a ``distribution`` target which builds all the components specified in; the list. This is a convenience build target to allow building just the; distributed pieces without needing to build all configured targets. .. _Multi-distribution configurations:. Multi-distribution configurations; ---------------------------------. The ``install-distribution`` target described above is for building a single; distribution. LLVM's build system also supports building multiple distributions,; which can be used to e.g. have one distribution containing just tools and; another for libraries (to enable development). These are configured by setting; the *LLVM_DISTRIBUTIONS* variable to hold a list of all distribution names; (which conventionally start with an uppercase letter, e.g. ""Development""), and; then setting the *LLVM_<distribution>_DISTRIBUTION_COMPONENTS* variable to the; list of targets for that distribution. For each distribution, the build system; generates an ``install-${distribution}-distribution`` target, where; ``${distribution}`` is the name of the distribution in lowercase, to install; that distribution. Each distribution creates its own set of CMake exports, and the target to; install the CMake exports for a particular distribution for a project is named; ``${project}-${distribution}-cmake-exports``, where ``${project}`` is the name; of the project in lowercase and ``${distribution}`` is the name of the; distribution in lowercase, unless the project is LLVM, in which case the target; is just named ``${distribution}-cmake-exports``. These targets need to be; explicitly included in the *LLVM_<distribution>_DISTRIBUTION_COMPONENTS*; variable in order to be includ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:4558,config,configured,4558,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,2,"['config', 'variab']","['configured', 'variable']"
Modifiability,"c triggers sending of a; packet containing various information about the performance related to; that file only.; Added support also for performance monitoring when writing. RGLITE: A ROOT GRID interface. RGLite plug-in - a ROOT plug-in module, which implements the ROOT Grid; interface and offers to ROOT users possibilities to perform a number of; operations using gLite middleware from within ROOT. Supported features:. Workload Management System operations:; ; job submission – normal, DAG and parametric; jobs (gLite; WMProxy API), ; smart look-up algorithm for WMP-Endpoints, ; job status querying (gLite LB API), ; job output retrieving (Globus GridFTP). . File Catalog operations (gLite/LCG LFC API):; ; smart session manager, ; set/query the current working catalog directory, ; list files, directories and their stats, ; add/remove files in a catalog namespace, ; add/remove directories, ; add/remove replicas from a given file. . An executive logging. ; Support of an external XML configuration file with; according XML; schema. . Usage examples:. Job operations. // loading RGLite plug-in. TGrid::Connect(""glite"");; // submitting Grid job. TGridJob *job = gGrid->Submit(""JDLs/simple.jdl"");; // getting status object. TGridJobStatus *status = job->GetJobStatus();; // getting status of the job. TGridJobStatus::EGridJobStatus st( status->GetStatus() );; // when the st is; TGridJobStatus::kDONE you can; retrieve job's output. job->GetOutputSandbox(""/tmp"");. File Catalog operations. // loading RGLite plug-in. TGrid::Connect(""glite"");; // changing the current directory to; ""/grid/dech"". gGrid->Cd(""/grid/dech"");; // using Mkdir to create a new; directory. Bool_t b = gGrid->Mkdir(""root_test2"");; // listing the current directory. TGridResult* result = gGrid->Ls();; // full file information. result->Print(""all"");; // removing the directory . b = gGrid->Rmdir(""root_test2"");. Documentation: ; http://www-linux.gsi.de/%7Emanafov/D-Grid/docz/RGLite/html/. and; http://www-linux.gsi.de/~mana",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html:3852,config,configuration,3852,net/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html,1,['config'],['configuration']
Modifiability,"c-assemble-fuzzer`` for details. .. |generic fuzzer| replace:: :ref:`generic fuzzer <fuzzing-llvm-generic>`; .. |protobuf fuzzer|; replace:: :ref:`libprotobuf-mutator based fuzzer <fuzzing-llvm-protobuf>`; .. |LLVM IR fuzzer|; replace:: :ref:`structured LLVM IR fuzzer <fuzzing-llvm-ir>`. lldb-target-fuzzer; ---------------------. A |generic fuzzer| that interprets inputs as object files and uses them to; create a target in lldb. Mutators and Input Generators; =============================. The inputs for a fuzz target are generated via random mutations of a; :ref:`corpus <libfuzzer-corpus>`. There are a few options for the kinds of; mutations that a fuzzer in LLVM might want. .. _fuzzing-llvm-generic:. Generic Random Fuzzing; ----------------------. The most basic form of input mutation is to use the built in mutators of; LibFuzzer. These simply treat the input corpus as a bag of bits and make random; mutations. This type of fuzzer is good for stressing the surface layers of a; program, and is good at testing things like lexers, parsers, or binary; protocols. Some of the in-tree fuzzers that use this type of mutator are `clang-fuzzer`_,; `clang-format-fuzzer`_, `llvm-as-fuzzer`_, `llvm-dwarfdump-fuzzer`_,; `llvm-mc-assemble-fuzzer`_, and `llvm-mc-disassemble-fuzzer`_. .. _fuzzing-llvm-protobuf:. Structured Fuzzing using ``libprotobuf-mutator``; ------------------------------------------------. We can use libprotobuf-mutator_ in order to perform structured fuzzing and; stress deeper layers of programs. This works by defining a protobuf class that; translates arbitrary data into structurally interesting input. Specifically, we; use this to work with a subset of the C++ language and perform mutations that; produce valid C++ programs in order to exercise parts of clang that are more; interesting than parser error handling. To build this kind of fuzzer you need `protobuf`_ and its dependencies; installed, and you need to specify some extra flags when configuring the buil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:6021,layers,layers,6021,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['layers'],['layers']
Modifiability,"c2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; ```. If `branchDescriptor` is set to an empty string (the default), it is; assumed that the **`Tree`** descriptor is given in the first line of the; file with a syntax like: `A/D:Table[2]/F:Ntracks/I:astring/C`. Otherwise branchDescriptor must be specified with the above syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open the file and lists its contents. ``` {.cpp}; root[] TFile f (""cernstaff.root""); roo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:67788,variab,variable,67788,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"c> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<Expr>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<Expr>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type; mat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:193249,variab,variable,193249,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"c>hasNamedTypeLocMatcher<TypeLoc> InnerMatcher; Matches elaborated `TypeLoc`s that have a named `TypeLoc` matching; `InnerMatcher`. Given; template <typename T>; class C {};; class C<int> c;. class D {};; class D d;; elaboratedTypeLoc(hasNamedTypeLoc(templateSpecializationTypeLoc()));; matches the `TypeLoc` of the variable declaration of `c`, but not `d`. Matcher<ElaboratedType>hasQualifierMatcher<NestedNameSpecifier> InnerMatcher; Matches ElaboratedTypes whose qualifier, a NestedNameSpecifier,; matches InnerMatcher if the qualifier exists. Given; namespace N {; namespace M {; class D {};; }; }; N::M::D d;. elaboratedType(hasQualifier(hasPrefix(specifiesNamespace(hasName(""N"")))); matches the type of the variable declaration of d. Matcher<ElaboratedType>namesTypeMatcher<QualType> InnerMatcher; Matches ElaboratedTypes whose named type matches InnerMatcher. Given; namespace N {; namespace M {; class D {};; }; }; N::M::D d;. elaboratedType(namesType(recordType(; hasDeclaration(namedDecl(hasName(""D"")))))) matches the type of the variable; declaration of d. Matcher<EnumType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:190529,variab,variable,190529,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"cal scope ``!18``. The lexical scope itself resides; inside of subprogram ``!4`` described above. The scope information attached with each instruction provides a straightforward; way to find instructions covered by a scope. Object lifetime in optimized code; =================================. In the example above, every variable assignment uniquely corresponds to a; memory store to the variable's position on the stack. However in heavily; optimized code LLVM promotes most variables into SSA values, which can; eventually be placed in physical registers or memory locations. To track SSA; values through compilation, when objects are promoted to SSA values an; ``llvm.dbg.value`` intrinsic is created for each assignment, recording the; variable's new location. Compared with the ``llvm.dbg.declare`` intrinsic:. * A dbg.value terminates the effect of any preceding dbg.values for (any; overlapping fragments of) the specified variable.; * The dbg.value's position in the IR defines where in the instruction stream; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the program. For any; execution of the optimized program, the set of variable values presented to the; developer by the debugger should not show a state that would never have existed; in the execution of the unoptimized program, given the same input. Doing so; risks misleading the developer by reporting a state that does not exist,; damaging their understanding of the optimized program and undermining their; trust in the debugger. Sometimes perfectly preserving variable locations is not possible, often when a; redundant calculation is optimized out. In such cases, a ``llvm.dbg.value``; with operand ``poison`` should be used, to terminate e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:18593,variab,variable,18593,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"calPodLocation`; : Full path to the PoD installation on the client. > The `$VafConf_LocalPodLocation` variable must be set before the; > `PoD_env.sh` script gets sourced, so set it either in; > `common.before`, `local.before` or `local.conf`. Since PoD is; > usually system-wide installed, its location is normally; > system-wide set in either the `local.conf` file by the system; > administrator. `$VafConf_RemotePodLocation`; : Full path to the PoD installation on the VAF master node. *Note: this variable should be set in the configuration files for; the local environment despite it refers to a software present on the; remote nodes.*. `$VafConf_PodRms` *(optional)*; : Name of the Resource Management System used for submitting PoD jobs.; Run `pod-submit -l` to see the possible values. If not set, defaults to `condor`. `$VafConf_PodQueue` *(optional)*; : Queue name where to submit PoD jobs. If no queue has been given, the default one configured on your RMS; will be used. ### Remote environment configuration. All the PoD commands sent to the VAF master will live in the environment; loaded via using the following scripts. Similarly to the local environment, configuration is split in different files; to allow for a system-wide configuration, which has precedence over; user's configuration in the home directory. If a script cannot be found,; it will be silently skipped. - `<output_of_payload>`. - `common.before`. - `remote.before`. - `remote.conf`. - `common.after`. - `remote.after`. For an explanation on how to pass extra data to the workers safely; through the payload, see below. ### Payload: sending local files to the remote nodes. In many cases it is necessary to send some local data to the remote; workers: it is very common, for instance, to distribute a local Grid; authentication proxy on the remote workers to let them authenticate to; access a data storage. The `payload` file must be an executable generating some output that; will be prepended to the remote environme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:4430,config,configuration,4430,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['config'],['configuration']
Modifiability,"call i32 @foo() ; yields i32; %Y = tail call fastcc i32 @foo() ; yields i32; call void %foo(i8 signext 97). %struct.A = type { i32, i8 }; %r = call %struct.A @foo() ; yields { i32, i8 }; %gr = extractvalue %struct.A %r, 0 ; yields i32; %gr1 = extractvalue %struct.A %r, 1 ; yields i8; %Z = call void @foo() noreturn ; indicates that %foo never returns normally; %ZZ = call zeroext i32 @bar() ; Return value is %zero extended. llvm treats calls to some functions with names and arguments that match; the standard C99 library as being the C99 library functions, and may; perform optimizations or generate code for them under that assumption.; This is something we'd like to change in the future to provide better; support for freestanding environments and non-C-based languages. .. _i_va_arg:. '``va_arg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = va_arg <va_list*> <arglist>, <argty>. Overview:; """""""""""""""""". The '``va_arg``' instruction is used to access arguments passed through; the ""variable argument"" area of a function call. It is used to implement; the ``va_arg`` macro in C. Arguments:; """""""""""""""""""". This instruction takes a ``va_list*`` value and the type of the; argument. It returns a value of the specified argument type and; increments the ``va_list`` to point to the next argument. The actual; type of ``va_list`` is target specific. Semantics:; """""""""""""""""""". The '``va_arg``' instruction loads an argument of the specified type; from the specified ``va_list`` and causes the ``va_list`` to point to; the next argument. For more information, see the variable argument; handling :ref:`Intrinsic Functions <int_varargs>`. It is legal for this instruction to be called in a function which does; not take a variable number of arguments, for example, the ``vfprintf``; function. ``va_arg`` is an LLVM instruction instead of an :ref:`intrinsic; function <intrinsics>` because it takes a type as an argument. Example:; """""""""""""""". See the :ref:`variable argument proc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:479267,variab,variable,479267,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"call void @llvm.dbg.value(metadata i32 2, metadata !23, metadata !DIExpression()), !dbg !24; %value2 = add i32 %input, 2; br label %bb1. exit:; ret i32 %value, !dbg !30; }. Here the difficulties are:. * The control flow is roughly the opposite of basic block order; * The value of the ``!23`` variable merges into ``%bb1``, but there is no PHI; node. As mentioned above, the ``llvm.dbg.value`` intrinsics essentially form an; imperative program embedded in the IR, with each intrinsic defining a variable; location. This *could* be converted to an SSA form by mem2reg, in the same way; that it uses use-def chains to identify control flow merges and insert phi; nodes for IR Values. However, because debug variable locations are defined for; every machine instruction, in effect every IR instruction uses every variable; location, which would lead to a large number of debugging intrinsics being; generated. Examining the example above, variable ``!30`` is assigned ``%input`` on both; conditional paths through the function, while ``!23`` is assigned differing; constant values on either path. Where control flow merges in ``%bb1`` we would; want ``!30`` to keep its location (``%input``), but ``!23`` to become undefined; as we cannot determine at runtime what value it should have in %bb1 without; inserting a PHI node. mem2reg does not insert the PHI node to avoid changing; codegen when debugging is enabled, and does not insert the other dbg.values; to avoid adding very large numbers of intrinsics. Instead, LiveDebugValues determines variable locations when control; flow merges. A dataflow analysis is used to propagate locations between blocks:; when control flow merges, if a variable has the same location in all; predecessors then that location is propagated into the successor. If the; predecessor locations disagree, the location becomes undefined. Once LiveDebugValues has run, every block should have all valid variable; locations described by DBG_VALUE instructions within the block.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:38803,variab,variable,38803,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"calling convention ``fastcc``, ``cc 10`` (GHC; calling convention), ``cc 11`` (HiPE calling convention), ``tailcc``, or; ``swifttailcc``. * The call is a tail call - in tail position (ret immediately follows call and; ret uses value of call or is void). * Option ``-tailcallopt`` is enabled or the calling convention is ``tailcc``. * Platform-specific constraints are met. x86/x86-64 constraints:. * No variable argument lists are used. * On x86-64 when generating GOT/PIC code only module-local calls (visibility =; hidden or protected) are supported. PowerPC constraints:. * No variable argument lists are used. * No byval parameters are used. * On ppc32/64 GOT/PIC only module-local calls (visibility = hidden or protected); are supported. WebAssembly constraints:. * No variable argument lists are used. * The 'tail-call' target attribute is enabled. * The caller and callee's return types must match. The caller cannot; be void unless the callee is, too. AArch64 constraints:. * No variable argument lists are used. Example:. Call as ``llc -tailcallopt test.ll``. .. code-block:: llvm. declare fastcc i32 @tailcallee(i32 inreg %a1, i32 inreg %a2, i32 %a3, i32 %a4). define fastcc i32 @tailcaller(i32 %in1, i32 %in2) {; %l1 = add i32 %in1, %in2; %tmp = tail call fastcc i32 @tailcallee(i32 inreg %in1, i32 inreg %in2, i32 %in1, i32 %l1); ret i32 %tmp; }. Implications of ``-tailcallopt``:. To support tail call optimization in situations where the callee has more; arguments than the caller a 'callee pops arguments' convention is used. This; currently causes each ``fastcc`` call that is not tail call optimized (because; one or more of above constraints are not met) to be followed by a readjustment; of the stack. So performance might be worse in such cases. Sibling call optimization; -------------------------. Sibling call optimization is a restricted form of tail call optimization.; Unlike tail call optimization described in the previous section, it can be; performed automatically on any",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:87453,variab,variable,87453,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['variab'],['variable']
Modifiability,"calling:. .. code-block:: c++. auto ReexportFlags = JITSymbolFlags::Exported | JITSymbolFlags::Callable;; JD2.define(; lazyReexports(CallThroughMgr, StubsMgr, JD,; SymbolAliasMap({; { Mangle(""foo""), { Mangle(""foo_body""), ReexportedFlags } },; { Mangle(""bar""), { Mangle(""bar_body""), ReexportedFlags } }; }));. A full example of how to use lazyReexports with the LLJIT class can be found at; ``llvm/examples/OrcV2Examples/LLJITWithLazyReexports``. Supporting Custom Compilers; ===========================. TBD. .. _transitioning_orcv1_to_orcv2:. Transitioning from ORCv1 to ORCv2; =================================. Since LLVM 7.0, new ORC development work has focused on adding support for; concurrent JIT compilation. The new APIs (including new layer interfaces and; implementations, and new utilities) that support concurrency are collectively; referred to as ORCv2, and the original, non-concurrent layers and utilities; are now referred to as ORCv1. The majority of the ORCv1 layers and utilities were renamed with a 'Legacy'; prefix in LLVM 8.0, and have deprecation warnings attached in LLVM 9.0. In LLVM; 12.0 ORCv1 will be removed entirely. Transitioning from ORCv1 to ORCv2 should be easy for most clients. Most of the; ORCv1 layers and utilities have ORCv2 counterparts [2]_ that can be directly; substituted. However there are some design differences between ORCv1 and ORCv2; to be aware of:. 1. ORCv2 fully adopts the JIT-as-linker model that began with MCJIT. Modules; (and other program representations, e.g. Object Files) are no longer added; directly to JIT classes or layers. Instead, they are added to ``JITDylib``; instances *by* layers. The ``JITDylib`` determines *where* the definitions; reside, the layers determine *how* the definitions will be compiled.; Linkage relationships between ``JITDylibs`` determine how inter-module; references are resolved, and symbol resolvers are no longer used. See the; section `Design Overview`_ for more details. Unless multiple JITDylibs are",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:19530,layers,layers,19530,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['layers'],['layers']
Modifiability,"carded: Discarded elements by the linker.; =discriminator: Discriminators for inlined function instances.; =inserted: Generated inlined abstract references.; =linkage: Object file linkage name.; =offset: Debug information offset.; =qualifier: Line qualifiers (Newstatement, BasicBlock, etc).; =zero: Zero line numbers. The following attribute described specific information for the **PE/COFF**; file format. It includes MS runtime types. .. code-block:: text. =system: Display PDB's MS system elements. The above attributes are grouped into *standard* and *extended*; categories that can be enabled. The *standard* group, contains those attributes that add sufficient; information to describe a logical element and that can cover the; normal situations while dealing with debug information. .. code-block:: text. =base; =coverage; =directories; =discriminator; =filename; =files; =format; =level; =producer; =publics; =range; =reference; =zero. The *extended* group, contains those attributes that require a more; extended knowledge about debug information. They are intended when a; lower level of detail is required. .. code-block:: text. =argument; =discarded; =encoded; =gaps; =generated; =global; =inserted; =linkage; =local; =location; =offset; =operation; =pathname; =qualified; =qualifier; =register; =subrange; =system; =typename. .. _print_:. PRINT; ~~~~~; The following options describe the elements to print. The layout used; is determined by the :option:`--report`. In the tree layout, all the; elements have their enclosing lexical scopes printed, even when not; explicitly specified. .. option:: --print=<value[,value,...]>. With **value** being one of the options in the following lists. .. code-block:: text. =all: Include all the below attributes. The following options print the requested elements; in the case of any; given select conditions (:option:`--select`), only those elements that; match them, will be printed. The **elements** value is a convenient; way to specify instruc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:8664,extend,extended,8664,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,2,['extend'],['extended']
Modifiability,"case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The minmization is implemented in `TF1` using the BrentMInimizer1D and available with the class member functions; * `TF1::GetMinimum`/`TF1::GetMaximum` to find the function minimum/maximum value; * `TF1::GetMinimumX`/`TF1::GetMaximumX` to find the x value corresponding at the function minimum. The interval to search for the minimum (the default is the `TF1` range), tolerance and maximum iterations can be provided as optional parameters of the; `TF1::GetMinimum/Maximum` functions. ### Multi-Dimensional Minimization. All the algorithms for multi-dimensional minimization are implementing the `ROOT::Math::Minimizer`; interface and they can be used in the same way and one can switch between minimizer at run-time.; The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT; plug-in manager.; More information on multi-dimensional minimization is provided in the Fitting Histogram chapter. ## ROOT Finder Algorithms. The function must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object.; Some of the algorithm requires the derivatives of the function.; In that case a `ROOT::Math::IGradientFunctionOneDim` object must be provided. ## Generic Vectors for 2, 3 and 4 Dimensions (GenVector). `GenVector` is a package intended to represent vectors and their; operations and transformations, such as rotations and Lorentz; transformations, in 3 and 4 dimensions. The 3D space is used to describe; the geometry vectors and points, while the 4D space-time is used for; physics vectors representing relativistic particles. These 3D and 4D; vectors are different from vectors of the linear algebra package, which; describe generic N-dimensional vectors. Similar functionality is; currently pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:66817,plug-in,plug-in,66817,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['plug-in'],['plug-in']
Modifiability,"case of time axis) and used to; replace the old bit `TH1::kCanRebin` (see below).; Note that this bit is automatically set when the axis has labels associated to each bin. In this case the axis becomes alphanumeric and; there is no more relation to the observed quantities. Note that when an axis is alphanumeric the mean and the rms of the histograms are not anymore; coputed and they are set to zero. ### TH1. - The bit `TH1::kCanRebin` used to extend the histogram axes is now deprecated. The bit exists still in ROOT 6.0 but it has no effect.; One should use now the new function `TH1::SetCanExtend(..)` passing the axis (using the appropriate enumeration), which needs to be extended.; In addition to extend each axis individually, the function can be used also to enable/disable extension for all axes.; For example `TH1::SetCanExtend(TH1::kXaxis)` will make extendable only the X axis; `TH1::SetCanExtend(TH1::kAllAxes)` will; make extendable all the axes (this is the same functionality of the previous function `SetBit(TH1::kCanRebin)` and; `TH1::SetCanExtend(TH1::kNoAxis)` will remove the extendable functionality to all the axes (equivalent to the old `ResetBit(TH1::kCanRebin)`).; The functionality of `TestBit(TH1::kCanRebin)` is now replaced by `TH1::CanExtendAllAxis()`. - An histogram filled with weights different than one has now automatically the sum of the weight squared stored inside, without the need to call anymore; `TH1::Sumw2()`. As a consequences an histogram filled with weights will always draw the errors by default. If one desire to continue having the histogram drawn; without the errors, one should use the `hist` option: `h.Draw(""hist"")`.; If, for memory reason, one does not want to remove the internal array storing the bin errors (the bin sum of weight square), one can use the function `TH1::Sumw2(false)`. - The copy constructor is not anymore public for TH1. Before (in 5.34) this code was allowed by the compiler, although giving undefined behavior: now not",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:7535,extend,extendable,7535,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,3,['extend'],['extendable']
Modifiability,"case-sensitive, and may contain spaces. For this reason,; you should enter them exactly as they are listed in the ``cmake --help``; output, in quotes. For example, to generate project files specifically for; Visual Studio 12, you can execute:. .. code-block:: console. $ cmake -G ""Visual Studio 12"" path/to/llvm/source/root. For a given development platform there can be more than one adequate; generator. If you use Visual Studio, ""NMake Makefiles"" is a generator you can use; for building with NMake. By default, CMake chooses the most specific generator; supported by your development environment. If you want an alternative generator,; you must tell this to CMake with the ``-G`` option. .. todo::. Explain variables and cache. Move explanation here from #options section. .. _Options and variables:. Options and variables; =====================. Variables customize how the build will be generated. Options are boolean; variables, with possible values ON/OFF. Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; -------------------------------. Here are some of the CMake variables that are used often, along with a; brief explanation. For full documentation, consult the CMake manual,; or execute ``cmake --help-variable V",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:5747,variab,variables,5747,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"cate_state = (condition != 0) ? all_zeros_mask : predicate_state;; // ... lots of code ...; //; // Harden the pointer so it can't be loaded; pointer1 &= predicate_state;; leak(*pointer1);; break;. case 1:; predicate_state = (condition != 1) ? all_zeros_mask : predicate_state;; // ... more code ...; //; // Alternative: Harden the loaded value; int value2 = *pointer2 & predicate_state;; leak(value2);; break;. // ...; }; }; ```. The core idea remains the same: validate the control flow using data-flow and; use that validation to check that loads cannot leak information along; misspeculated paths. Typically this involves passing the desired target of such; control flow across the edge and checking that it is correct afterwards. Note; that while it is tempting to think that this mitigates variant #2 attacks, it; does not. Those attacks go to arbitrary gadgets that don't include the checks. ### Variant #1.1 and #1.2 attacks: ""Bounds Check Bypass Store"". Beyond the core variant #1 attack, there are techniques to extend this attack.; The primary technique is known as ""Bounds Check Bypass Store"" and is discussed; in this research paper: https://people.csail.mit.edu/vlk/spectre11.pdf. We will analyze these two variants independently. First, variant #1.1 works by; speculatively storing over the return address after a bounds check bypass. This; speculative store then ends up being used by the CPU during speculative; execution of the return, potentially directing speculative execution to; arbitrary gadgets in the binary. Let's look at an example.; ```; unsigned char local_buffer[4];; unsigned char *untrusted_data_from_caller = ...;; unsigned long untrusted_size_from_caller = ...;; if (untrusted_size_from_caller < sizeof(local_buffer)) {; // Speculative execution enters here with a too-large size.; memcpy(local_buffer, untrusted_data_from_caller,; untrusted_size_from_caller);; // The stack has now been smashed, writing an attacker-controlled; // address over the return address.; m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:11069,extend,extend,11069,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['extend'],['extend']
Modifiability,"cc"", ""dd""}, {""ee"", ""ff""}};'); True; >>> type(cppyy.gbl.str_array[0][1]); <class cppyy.gbl.std.string at 0x7fd650ccb650>; >>> cppyy.gbl.str_array[0][1]; 'bb'; >>> cppyy.gbl.str_array[4][0]; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: tuple index out of range; >>>. `Pointers`; """""""""""""""""""". When the C++ code takes a pointer or reference type to a specific builtin; type (such as an ``unsigned int`` for example), then types need to match; exactly.; ``cppyy`` supports the types provided by the standard modules ``ctypes`` and; ``array`` for those cases.; Example of using a reference to builtin:. .. code-block:: python. >>> from ctypes import c_uint; >>> u = c_uint(0); >>> c.uint_ref_assign(u, 42); >>> u.value; 42; >>>. For objects, an object, a pointer to an object, and a smart pointer to an; object are represented the same way, with the necessary (de)referencing; applied automatically.; Pointer variables are also bound by reference, so that updates on either the; C++ or Python side are reflected on the other side as well. `Enums`; """""""""""""". Named, anonymous, and class enums are supported.; The Python-underlying type of an enum is implementation dependent and may even; be different for different enums on the same compiler.; Typically, however, the types are ``int`` or ``unsigned int``, which; translates to Python's ``int`` or ``long`` on Python2 or class ``int`` on; Python3.; Separate from the underlying, all enums have their own Python type to allow; them to be used in template instantiations:. .. code-block:: python. >>> from cppyy.gbl import kBanana # classic enum, globally available; >>> print(kBanana); 29; >>> cppyy.gbl.EFruit; <class '__main__.EFruit'>; >>> print(cppyy.gbl.EFruit.kApple); 78; >>> cppyy.gbl.E1 # C++11 class enum, scoped; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; AttributeError: <namespace cppyy.gbl at 0x7ff2766a4af0> has no attribute 'E1'.; >>> cppyy.gbl.NamedClassEnum.E1; 42; >>>. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst:5300,variab,variables,5300,bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,1,['variab'],['variables']
Modifiability,"ccordingly, like so:. .. code-block:: C. c = ...;; if (c) {; for (...) {; if (true); X1 = ...; else; X2 = ...; X3 = phi(X1, X2);; }; } else {; for (...) {; if (false); X1' = ...; else; X2' = ...; X3' = phi(X1', X2');; }; }; X4 = phi(X3, X3'). Now, all uses of X4 will get the updated value (in general,; if a loop is in LCSSA form, in any loop transformation,; we only need to update the loop closing PHI nodes for the changes; to take effect). If we did not have Loop Closed SSA form, it means that X3 could; possibly be used outside the loop. So, we would have to introduce the; X4 (which is the new X3) and replace all uses of X3 with that.; However, we should note that because LLVM keeps a def-use chain; [#def-use-chain]_ for each Value, we wouldn't need; to perform data-flow analysis to find and replace all the uses; (there is even a utility function, replaceAllUsesWith(),; that performs this transformation by iterating the def-use chain). Another important advantage is that the behavior of all uses; of an induction variable is the same. Without this, you need to; distinguish the case when the variable is used outside of; the loop it is defined in, for example:. .. code-block:: C. for (i = 0; i < 100; i++) {; for (j = 0; j < 100; j++) {; k = i + j;; use(k); // use 1; }; use(k); // use 2; }. Looking from the outer loop with the normal SSA form, the first use of k; is not well-behaved, while the second one is an induction variable with; base 100 and step 1. Although, in practice, and in the LLVM context,; such cases can be handled effectively by SCEV. Scalar Evolution; (:ref:`scalar-evolution <passes-scalar-evolution>`) or SCEV, is a; (analysis) pass that analyzes and categorizes the evolution of scalar; expressions in loops. In general, it's easier to use SCEV in loops that are in LCSSA form.; The evolution of a scalar (loop-variant) expression that; SCEV can analyze is, by definition, relative to a loop.; An expression is represented in LLVM by an; `llvm::Instruction <",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:14622,variab,variable,14622,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['variab'],['variable']
Modifiability,"ce a date for the renaming of the starter project (LLD). #. Update the `policy page <../CodingStandards.html>`_. This will explain the; old and new rules and which projects each applies to. #. Refactor the starter project in two commits:. 1. Add or change the project's .clang-tidy to reflect the agreed rules.; (This is in a separate commit to enable the merging process described in; `Minimising cost of downstream merges`_).; Also update the project list on the policy page.; 2. Apply ``clang-tidy`` to the project's files, with only the; ``readability-identifier-naming`` rules enabled. ``clang-tidy`` will also; reformat the affected lines according to the rules in ``.clang-format``.; It is anticipated that this will be a good dog-fooding opportunity for; clang-tidy, and bugs should be fixed in the process, likely including:. * `readability-identifier-naming incorrectly fixes lambda capture; <https://bugs.llvm.org/show_bug.cgi?id=41119>`_.; * `readability-identifier-naming incorrectly fixes variables which; become keywords <https://bugs.llvm.org/show_bug.cgi?id=41120>`_.; * `readability-identifier-naming misses fixing member variables in; destructor <https://bugs.llvm.org/show_bug.cgi?id=41122>`_. #. Gather feedback and refine the process as appropriate. #. Apply the process to the following projects, with a suitable delay between; each (at least 4 weeks after the first change, at least 2 weeks subsequently); to allow gathering further feedback.; This list should exclude projects that must adhere to an externally defined; standard e.g. libcxx.; The list is roughly in chronological order of renaming.; Some items may not make sense to rename individually - it is expected that; this list will change following experimentation:. * TableGen; * llvm/tools; * clang-tools-extra; * clang; * ARM backend; * AArch64 backend; * AMDGPU backend; * ARC backend; * AVR backend; * BPF backend; * Hexagon backend; * Lanai backend; * MIPS backend; * NVPTX backend; * PowerPC backend; * RISC-V",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:11918,variab,variables,11918,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variables']
Modifiability,"ce interface allows developers to pipe any kind of columnar data format into TDataFrame. Two example data sources have been provided: the TRootDS and the TTrivialDS. The former allows to read via the novel data source mechanism ROOT data, while the latter is a simple generator, created for testing and didactic purposes. It is therefore now possible to interface *any* kind of dataset/data format to ROOT as long as an adaptor which implements the pure virtual methods of the TDataSource interface can be written in C++.; - TDF can now read CSV files through a specialized TDataSource. Just create the TDF with `MakeCsvDataFrame(""f.csv"")`. Just create the TDF with MakeCsvDataFrame(""f.csv""). The data types of the CSV columns are automatically inferred. You can also specify if you want to use a different delimiter or if your file does not have headers.; - Users can now configure Snapshot to use different file open modes (""RECREATE"" or ""UPDATE""), compression level, compression algorithm, TTree split-level and autoflush settings; - Users can now access multi-threading slot and entry number as pre-defined columns ""tdfslot_"" and ""tdfentry_"". Especially useful for pyROOT users.; - Users can now specify filters and definitions as strings containing multiple C++ expressions, e.g. ""static int a = 0; return ++a"". Especially useful for pyROOT users.; - Histograms can be initialised by *models*, which allow to create histograms with the same parameters of their constructors, for example; ```c++; auto myHisto = myTdf.Histo1D({""histName"", ""histTitle"", 64, 0, 128}, ""myColumn"");; ```; or; ```c++; auto myHistoCustomBinning = myTdf.Histo1D({""histName"", ""histTitle"", 64, binEdges}, ""myColumn"");; ```; Models can be created as stand alone objects:; ```c++; TDF::TH1DModel myModel {""histName"", ""histTitle"", 64, binEdges};; auto myHistoCustomBinning = myTdf.Histo1D(myModel, ""myColumn"");; ```; - pyROOT users can now easily specify parameters for the TDF histograms and profiles thanks to the newly intr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:13298,config,configure,13298,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['config'],['configure']
Modifiability,"ce the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:30730,variab,variable,30730,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ce to TMultiLayerPerceptron) now also uses event weights; and writes standalone C++ class. k-NN:; A new global knn search function has been added to NodekNN that searches for; k-nearest neighbor using event weights instead of raw event counts. ModulekNN; has been modified to allow searches using ""weight"" or ""count"" option, where; ""count"" is default. Added UseWeight option to MethodKNN to allow using of; ""weight"" or ""count"". ; (Work by Rustem Ospanov, CERN). . Likelihood (and general PDF treatment):; Adaptive smoothing the PDF class, allowing it to smooth between MinSmoothNum ; (for regions with more signal) and MaxSmoothNum (for regions with less signal). . Configuration of the PDF parameters from the option string moved to PDF class,; allowing the user to define all the PDF functionalities in every classifier; the PDF is used (i.e., also for the MVA PDFs). The reading of these variables; was removed from MethodBase and MethodLikelihood. This also allows improved ; (full) PDF configuration of MVA output via the ""CreateMvaPdf"" option.; (Work by Or Cohen, CERN & Weizmann); ; New generalisation methods:. ; MethodCompositeBase: combines more than one; classifier within one. MethodBoost: boosts/bags any classifier; type. A special booking procedure for it was added to; Factory class. MethodDT: a classifier composed of a single; decision tree, boosted using MethodBoost. Results are; compatible with BDT, but BDT remains the default for boosted; decision trees, because it has pruning (among other; additional features). . Other improvements . Improved handling of small Likelihood values such that; Likelihood performance increases in analyses with many variables; (~>10). Thanks to Ralph Schaefer (Bonn U.) for reporting this. Nicer plotting: custom variable titles and units can be; assigned in ""AddVariable"" call. Introduced the inverse transformation InverseTransform for; the variable transformations into the framework. While this is; not necessary for classification, it is ne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html:4474,config,configuration,4474,tmva/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html,1,['config'],['configuration']
Modifiability,"ce you've contributed a handful of patches to LLVM, start to think; about getting commit access yourself. It's probably a good idea if:. - you've landed 3-5 patches of larger scope than ""fix a typo"". - you'd be willing to review changes that are closely related to yours. - you'd like to keep contributing to LLVM. Getting commit access; ---------------------. LLVM uses Git for committing changes. The details are in the `developer; policy; document <https://llvm.org/docs/DeveloperPolicy.html#obtaining-commit-access>`__. With great power; ----------------. Actually, this would be a great time to read the rest of the `developer; policy <https://llvm.org/docs/DeveloperPolicy.html>`__, too. At minimum,; you need to be subscribed to the relevant commits list before landing; changes (e.g. llvm-commits@lists.llvm.org), as discussion often happens; there if a new patch causes problems. Post-commit errors; ------------------. Once your change is submitted it will be picked up by automated build; bots that will build and test your patch in a variety of configurations. You can see all configurations and their current state in a waterfall; view at http://lab.llvm.org/buildbot/#/waterfall. The waterfall view is good; to get a general overview over the tested configurations and to see; which configuration have been broken for a while. The console view at http://lab.llvm.org/buildbot/#/console helps to get a; better understanding of the build results of a specific patch. If you; want to follow along how your change is affecting the build bots, **this; should be the first place to look at** - the colored bubbles correspond; to projects in the waterfall. If you see a broken build, do not despair - some build bots are; continuously broken; if your change broke the build, you will see a red; bubble in the console view, while an already broken build will show an; orange bubble. Of course, even when the build was already broken, a new; change might introduce a hidden new failure. | When y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:13736,config,configurations,13736,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['config'],['configurations']
Modifiability,ce.h; openmp/libomptarget/include/DeviceEnvironment.h; openmp/libomptarget/include/interop.h; openmp/libomptarget/include/omptarget.h; openmp/libomptarget/include/omptargetplugin.h; openmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/deviceinfo/llvm-omp-device-info.cpp; openmp/runtime/doc/doxyge,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407560,plugin,plugins,407560,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,ceRTL/src/Kernel.cpp; openmp/libomptarget/DeviceRTL/src/Misc.cpp; openmp/libomptarget/DeviceRTL/src/Parallelism.cpp; openmp/libomptarget/DeviceRTL/src/Reduction.cpp; openmp/libomptarget/DeviceRTL/src/State.cpp; openmp/libomptarget/DeviceRTL/src/Synchronization.cpp; openmp/libomptarget/DeviceRTL/src/Tasking.cpp; openmp/libomptarget/DeviceRTL/src/Utils.cpp; openmp/libomptarget/include/Debug.h; openmp/libomptarget/include/device.h; openmp/libomptarget/include/DeviceEnvironment.h; openmp/libomptarget/include/interop.h; openmp/libomptarget/include/omptarget.h; openmp/libomptarget/include/omptargetplugin.h; openmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/p,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407139,plugin,plugins,407139,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"ced (e.g., in global; variable or function ``section`` attributes) within the module. These records; can be referenced by the 1-based index in the *section* fields of ``GLOBALVAR``; or ``FUNCTION`` records. MODULE_CODE_DEPLIB Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DEPLIB, ...string...]``. The ``DEPLIB`` record (code 6) contains a variable number of values representing; the bytes of a single dependent library name string, one of the libraries; mentioned in a ``deplibs`` declaration. There should be one ``DEPLIB`` record; for each library name referenced. MODULE_CODE_GLOBALVAR Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[GLOBALVAR, strtab offset, strtab size, pointer type, isconst, initid, linkage, alignment, section, visibility, threadlocal, unnamed_addr, externally_initialized, dllstorageclass, comdat, attributes, preemptionspecifier]``. The ``GLOBALVAR`` record (code 7) marks the declaration or definition of a; global variable. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the global variable.; See `STRTAB_BLOCK Contents`_. * *pointer type*: The type index of the pointer type used to point to this; global variable. * *isconst*: Non-zero if the variable is treated as constant within the module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: An encoding of the linkage type for this variable:. * ``external``: code 0; * ``weak``: code 1; * ``appending``: code 2; * ``internal``: code 3; * ``linkonce``: code 4; * ``dllimport``: code 5; * ``dllexport``: code 6; * ``extern_weak``: code 7; * ``common``: code 8; * ``private``: code 9; * ``weak_odr``: code 10; * ``linkonce_odr``: code 11; * ``available_externally``: code 12; * deprecated : code 13; * deprecated : code 14. * alignment*: The logarithm base 2 of the variable's requested alignment, plus 1. * *section*: If non-zero, the 1-based section index in the table of; `MODULE_CODE_SECTIONNAME`_ entrie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:27400,variab,variable,27400,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"ced. // but more spaces are possible. Minimum = 0; Maximum = 0; //Forces to start every comment directly after the slashes. Note that in line comment sections the relative indent of the subsequent; lines is kept, that means the following:. .. code-block:: c++. before: after:; Minimum: 1; //if (b) { // if (b) {; // return true; // return true;; //} // }. Maximum: 0; /// List: ///List:; /// - Foo /// - Foo; /// - Bar /// - Bar. This option has only effect if ``ReflowComments`` is set to ``true``. Nested configuration flags:. Control of spaces within a single line comment. * ``unsigned Minimum`` The minimum number of spaces at the start of the comment. * ``unsigned Maximum`` The maximum number of spaces at the start of the comment. .. _SpacesInParens:. **SpacesInParens** (``SpacesInParensStyle``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParens>`; Defines in which cases spaces will be inserted after ``(`` and before; ``)``. Possible values:. * ``SIPO_Never`` (in configuration: ``Never``); Never put a space in parentheses. .. code-block:: c++. void f() {; if(true) {; f();; }; }. * ``SIPO_Custom`` (in configuration: ``Custom``); Configure each individual space in parentheses in; `SpacesInParensOptions`. .. _SpacesInParensOptions:. **SpacesInParensOptions** (``SpacesInParensCustom``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParensOptions>`; Control of individual spaces in parentheses. If ``SpacesInParens`` is set to ``Custom``, use this to specify; how each individual space in parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; InEmptyParentheses: true. Nested configuration flags:. Precise control over the spacing in parentheses. .. code-block:: c++. # Should be declared this way:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; Other: true. * ``bool InConditionalStatements`` Put a space in par",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:126248,config,configuration,126248,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"cept(false);; functionDecl(isNoThrow()) and functionProtoType(isNoThrow()); match the declarations of g, and h, but not f, i or j. Matcher<FunctionProtoType>parameterCountIsunsigned N; Matches FunctionDecls and FunctionProtoTypes that have a; specific parameter count. Given; void f(int i) {}; void g(int i, int j) {}; void h(int i, int j);; void j(int i);; void k(int x, int y, int z, ...);; functionDecl(parameterCountIs(2)); matches g and h; functionProtoType(parameterCountIs(2)); matches g and h; functionProtoType(parameterCountIs(3)); matches k. Matcher<IfStmt>isConsteval; Matches consteval function declarations and if consteval/if ! consteval; statements. Given:; consteval int a();; void b() { if consteval {} }; void c() { if ! consteval {} }; void d() { if ! consteval {} else {} }; functionDecl(isConsteval()); matches the declaration of ""int a()"".; ifStmt(isConsteval()); matches the if statement in ""void b()"", ""void c()"", ""void d()"". Matcher<IfStmt>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<IntegerLiteral>equalsbool Value. Matcher<IntegerLiteral>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the positive numeric literal. Instead, you must use a unaryOperator(); matcher to match the minus sign:. unaryOpe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:97733,variab,variable,97733,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"cepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRequirement()); );. The ``createRefactoringActionRule`` function takes in a list of refactoring; action rule requirement values. These values describe the initiation; requirements that have to be satisfied by the refactoring engine before the; provided action rule can be constructed and invoked. The next section; describes how these requirements are evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type must define an; ``evaluate`` member function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:6446,refactor,refactoring,6446,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactoring']
Modifiability,"cern.ch/t/25889; - Ignore not-supported options in TMultiGraph https://root-forum.cern.ch/t/25888; - Correctly use fGridColor from TStyle; - Prevent error when TPaveText includes TLine or TBox in list of lines; - Bin errors calculations in TProfile; - Correctly handle new TF1 parameter coding convention (jsroot#132); - Check if pad name can be used as element id (jsroot#133); - Adjust title position for vertical axis with fTitleOffset==0. ## Tutorials. - xml/xmlreadfile.C shows how to read and parse any xml file, supported by TXMLEngine class.; - fit/fitNormSum.C shows building of vectorized function and fitting with TF1.; - multicore/mt303_AsyncSimple.C explains uses of `Async()` and `TFuture`.; - multicore/mt304_fillHistos.C shows the new auto-binning mechanism.; - graphs/timeSeriesFromCSV_TDF.C illustrates a time axis on a TGraph with text-data read by `TDataFrame`.; - dataframe/tdf013_InspectAnalysis.C shows how to display incremental snapshots of `TDataFrame` analysis results in a `TBrowser`; - dataframe/tdf014_CSVDataSource.C shows reading text-data (comma separated) using a `TDataFrame`; - dataframe/tdf012_DefinesAndFiltersAsStrings.C shows how to use jitted defines and filters by calculating pi; from checking how many randomly generated points in the unit square fall inside a unit circle; - most `TDataFrame` tutorials are now provided both in C++ and python. ## Command line tools; - `rootls` has been extended.; - option `-l` displays the year; - option `-t` displays all details of 'THnSparse'; - `rootcp` bug fixes ([ROOT-8528](https://sft.its.cern.ch/jira/browse/ROOT-8528)); - Now copies only the latest version of each object instead of copying all; versions in wrong order. ## Class Reference Guide; - The list of libraries needed by each class is displayed as a diagram. ## Build, Configuration and Testing Infrastructure. This is the last release with the configure/make-based build system. It will; be removed; please migrate to the CMake-based build system.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:31566,extend,extended,31566,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,2,"['config', 'extend']","['configure', 'extended']"
Modifiability,"certificate authentication. - your experiment's software (if available on CernVM-FS). Obtain the CernVM image and contextualization; ---------------------------------------------. ### Download the CernVM bare image. The Virtual Analysis Facility currently works with *CernVM Batch 2.7.1; 64-bit*. This means that you need to have this CernVM image available; either on your local hard disk (in case of a desktop deployment) or in; your cloud's image repository. > For convenience we provide the direct link for the working versions:; >; > - [CernVM 2.7.1 batch 64-bit for; > **KVM**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.hdd.gz); >; > - [CernVM 2.7.1 batch 64-bit for; > **Xen**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.ext3.gz); >; > Images are gzipped. In most cases you'll need to gunzip them before; > registering to your image repository. ### Create VM configuration profiles. CernVM images are base images supporting boot-time customization via; configuration profiles called ""contexts"". Context creation can be; performed through the [CernVM Online](https://cernvm-online.cern.ch/); website. The site is immediately accessible if you have a CERN account. Go to your [CernVM Online; Dashboard](https://cernvm-online.cern.ch/dashboard), click on the; **Create new context...** dropdown and select **Virtual Analysis Facility; node**. There's only a few parameters to configure. Context name; : A name for your context (such as *VAF Master for ATLAS*). Any name; will work. Role; : Use this to configure either a *master* or a *slave*. VAF master (only available when configuring a slave); : IP address or FQDN of the Virtual Analysis Facility master. Auth method; : Choose between *ALICE LDAP* (useful only for ALICE users) or *Pool; accounts* (good for authenticating all the other Grid users). Num. pool accounts (only available when using pool accounts auth); : Number of pool accounts to create. Proxy for CVMFS; : An URL specif",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:1725,config,configuration,1725,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['config'],['configuration']
Modifiability,"ces from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains all objects held in; variables of automatic storage referenced within the Block expression; (or form strong references if running under garbage collection).; Object variables of ``__block`` storage type are assumed to hold; normal pointers with no provision for retain and release messages. Foundation defines (and supplies) ``-copy`` and ``-release`` methods for; Blocks. In the Objective-C and Objective-C++ languages, we allow the; ``__weak`` specifier for ``__block`` variables of object type. If; garbage collection is not enabled, this qualifier causes these; variables to be kept without retain messages being sent. This; knowingly leads to dangling pointers if the Block (or a copy) outlives; the lifetime of this object. In garbage collected environments, the ``__weak`` variable is set to; nil when the object it references is collected, as long as the; ``__block`` variable resides in the heap (either by default or via; ``Block_copy()``). The initial Apple implementation does in fact; start ``__block`` variables on the stack and migrate them to the heap; only as a result of a ``Block_copy()`` operation. It is a runtime error to attempt to assign a reference to a; stack-based Block into any storage marked ``__weak``, including; ``__weak`` ``__block`` variables. C++ Extensions; ==============. Block literal expressions within functions are extended to allow const; use of C++ objects, pointers, or references held in automatic storage. As usual, within the block, references to captured variables become; const-qualified, as if they were references to members of a const; object. Note that this does not change the type of a variable of; reference type. For example, given a class Foo:. .. code-block:: c. Foo foo;; Foo &fooRef = foo;; Foo *fooPtr = &foo;. A Block that referenced these variables would import the variable",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:10479,variab,variable,10479,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,2,['variab'],['variable']
Modifiability,"ces) to its outputs (sinks).; This has applications from a privacy/security perspective in that; one can audit how a sensitive data item is used within a program and; ensure it isn't exiting the program anywhere it shouldn't be. Interface; ---------. A number of functions are provided which will attach taint labels to; memory regions and extract the set of labels associated with a; specific memory region. These functions are declared in the header; file ``sanitizer/dfsan_interface.h``. .. code-block:: c. /// Sets the label for each address in [addr,addr+size) to \c label.; void dfsan_set_label(dfsan_label label, void *addr, size_t size);. /// Sets the label for each address in [addr,addr+size) to the union of the; /// current label for that address and \c label.; void dfsan_add_label(dfsan_label label, void *addr, size_t size);. /// Retrieves the label associated with the given data.; ///; /// The type of 'data' is arbitrary. The function accepts a value of any type,; /// which can be truncated or extended (implicitly or explicitly) as necessary.; /// The truncation/extension operations will preserve the label of the original; /// value.; dfsan_label dfsan_get_label(long data);. /// Retrieves the label associated with the data at the given address.; dfsan_label dfsan_read_label(const void *addr, size_t size);. /// Returns whether the given label contains the label elem.; int dfsan_has_label(dfsan_label label, dfsan_label elem);. /// Computes the union of \c l1 and \c l2, resulting in a union label.; dfsan_label dfsan_union(dfsan_label l1, dfsan_label l2);. /// Flushes the DFSan shadow, i.e. forgets about all labels currently associated; /// with the application memory. Use this call to start over the taint tracking; /// within the same process.; ///; /// Note: If another thread is working with tainted data during the flush, that; /// taint could still be written to shadow after the flush.; void dfsan_flush(void);. The following functions are provided to check origin ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:1867,extend,extended,1867,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,1,['extend'],['extended']
Modifiability,"cess(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variab",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68509,config,config,68509,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['config']
Modifiability,"cessed by a ""backend"" into domain specific code. The compiler for TableGen is the binary `llvm-tblgen`. This contains the logic to convert TableGen source into records that can then be passed to a TableGen backend. TableGen allows you to define Classes and Defs (which are instances of classes) but it doesn't encode what to do with that structure. That's what the backend does. The backend converts this structure into something useful, for example C++ code. These backends are included in the `llvm-tblgen` binary and you can choose which one to run using a command line option. If you don't choose a backend you get a dump of the structure, and that is what this notebook will be showing. This tutorial will focus on the language itself only. The only thing you need to know now is that in addition to `llvm-tblgen` you will see other `*-tblgen` like `clang-tblgen`. The difference between them is the backends they include. The default output from `llvm-tblgen` looks like this:. ```tablegen; %config cellreset on. // Empty source file; ```. ------------- Classes -----------------; ------------- Defs -----------------. **Note:** `%config` is not a TableGen command but a ""magic"" command to the Jupyter kernel for this notebook. By default new cells include the content of previously run cells, but for this notebook we mostly want each to be isolated. On occasion we will use the `%noreset` magic to override this. No source means no classes and no defs. Let's add a class. ## Classes. ```tablegen; class C {}; ```. ------------- Classes -----------------; class C {; }; ------------- Defs -----------------. Followed by a def (definition). ```tablegen; %noreset. def X: C;; ```. ------------- Classes -----------------; class C {; }; ------------- Defs -----------------; def X {	// C; }. `def` creates an instance of a class. Typically, the main loop of a TableGen backend will look for all defs that are instances of a certain class. For example if I am generating register information I woul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:1558,config,config,1558,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['config'],['config']
Modifiability,"cfg>` pass will clean up blocks; which are split out but end up being unnecessary, so usage of this pass should; not pessimize generated code. This pass obviously modifies the CFG, but updates loop information and; dominator information. ``loop-unroll``: Unroll loops; -----------------------------. This pass implements a simple loop unroller. It works best when loops have; been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it to; determine the trip counts of loops easily. ``loop-unroll-and-jam``: Unroll and Jam loops; ---------------------------------------------. This pass implements a simple unroll and jam classical loop optimisation pass.; It transforms loop from:. .. code-block:: c++. for i.. i+= 1 for i.. i+= 4; for j.. for j..; code(i, j) code(i, j); code(i+1, j); code(i+2, j); code(i+3, j); remainder loop. Which can be seen as unrolling the outer loop and ""jamming"" (fusing) the inner; loops into one. When variables or loads can be shared in the new inner loop, this; can lead to significant performance improvements. It uses; :ref:`Dependence Analysis <passes-da>` for proving the transformations are safe. ``lower-global-dtors``: Lower global destructors; ------------------------------------------------. This pass lowers global module destructors (``llvm.global_dtors``) by creating; wrapper functions that are registered as global constructors in; ``llvm.global_ctors`` and which contain a call to ``__cxa_atexit`` to register; their destructor functions. ``loweratomic``: Lower atomic intrinsics to non-atomic form; -----------------------------------------------------------. This pass lowers atomic intrinsics to non-atomic form for use in a known; non-preemptible environment. The pass does not verify that the environment is non-preemptible (in general; this would require knowledge of the entire call graph of the program including; any libraries which may not be available in bitcode form); it simply lowers; every atomic intrinsic. ``lowerinvoke`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:28597,variab,variables,28597,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variables']
Modifiability,"ch ROOT to use; C++ Modules by default. However, since it is essentially the same technology,; optimizations of C++ Modules also affect the PCH. We have a few tricks up in; the sleeves to but they come with given trade-offs. #### Preloading of C++ Modules. The main focus for the technology preview was not in performance until recently.; We have invested some resources in optimizations and we would like to show you; (probably outdated) performance results:. * Memory footprint -- mostly due to importing all C++ Modules at startup; we see overhead which depends on the number of preloaded modules. For; ROOT it is between 40-60 MB depending on the concrete configuration.; When the workload increases we notice that the overall memory performance; decreases in number of cases.; * Execution times -- likewise we have an execution overhead. For ; workflows which take ms the slowdown can be 2x. Increasing of the work; to seconds shows 50-60% slowdowns. The performance is dependent on many factors such as configuration of ROOT and; workflow. You can read more at our Intel IPCC-ROOT Showcase presentation; here (pp 25-33)[[8]]. #### Loading C++ Modules on Demand. In long term, we should optimize the preloading of modules to be a no-op and; avoid recursive behavior based on identifier lookup callbacks. Unfortunately,; at the moment the loading of C++ modules on demand shows significantly better; performance results. You can visit our continuous performance monitoring tool where we compare; the performance of ROOT against ROOT with a PCH [[9]].; *Note: if you get error 400, clean your cache or open a private browser session.*. ## How to use; C++ Modules in ROOT are default since v6.20 (Unix) and v6.22 (OSX). Enjoy. To disable C++ Modules in ROOT use `-Druntime_cxxmodules=Off`. ## Citing ROOT's C++ Modules; ```latex; % Peer-Reviewed Publication; %; % 22nd International Conference on Computing in High Energy and Nuclear Physics (CHEP); % 8-14 October, 2016, San Francisco, USA; %; @in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:18724,config,configuration,18724,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['config'],['configuration']
Modifiability,"ch as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always defin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:30954,variab,variable,30954,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ch begin with a capital letter. This convention means that the; most readable variable name also requires the least thought::. Triple triple;. There is some agreement that the current rule is broken [LattnerAgree]_; [ArsenaultAgree]_ [RobinsonAgree]_ and that acronyms are an obstacle to reading; new code [MalyutinDistinguish]_ [CarruthAcronym]_ [PicusAcronym]_. There are; some opposing views [ParzyszekAcronym2]_ [RicciAcronyms]_. This work-in-progress proposal is to change the coding standard for variable; names to require that they start with a lower case letter. .. [*] In `some cases; <https://github.com/llvm/llvm-project/blob/8b72080d4d7b13072f371712eed333f987b7a18e/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp#L2727>`_; the type name *is* reused as a variable name, but this shadows the type name; and confuses many debuggers [DenisovCamelBack]_. Variable Names Coding Standard Options; ======================================. There are two main options for variable names that begin with a lower case; letter: ``camelBack`` and ``lower_case``. (These are also known by other names; but here we use the terminology from clang-tidy). ``camelBack`` is consistent with [WebKit]_, [Qt]_ and [Swift]_ while; ``lower_case`` is consistent with [LLDB]_, [Google]_, [Rust]_ and [Python]_. ``camelBack`` is already used for function names, which may be considered an; advantage [LattnerFunction]_ or a disadvantage [CarruthFunction]_. Approval for ``camelBack`` was expressed by [DenisovCamelBack]_; [LattnerFunction]_ [IvanovicDistinguish]_.; Opposition to ``camelBack`` was expressed by [CarruthCamelBack]_; [TurnerCamelBack]_.; Approval for ``lower_case`` was expressed by [CarruthLower]_; [CarruthCamelBack]_ [TurnerLLDB]_.; Opposition to ``lower_case`` was expressed by [LattnerLower]_. Differentiating variable kinds; ------------------------------. An additional requested change is to distinguish between different kinds of; variables [RobinsonDistinguish]_ [RobinsonDistinguish2]_ [Jone",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:2846,variab,variable,2846,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability,"ch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:127782,variab,variable,127782,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"ch can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key type is expensive to; construct, but cheap to compare against. The DenseMapInfo is responsible for; defining the appropriate comparison and hashing methods for each alternate key; type used. DenseMap.h also contains a SmallDenseMap variant, that similar to; :ref:`SmallVector <dss_smallvector>` performs no heap allocation until the; number of elements in the template parameter N are exceeded. .. _dss_valuemap:. llvm/IR/ValueMap.h; ^^^^^^^^^^^^^^^^^^^. ValueMap is a wrapper around a :ref:`DenseMap <dss_densemap>` mapping; ``Value*``\ s (or subclasses) to another type. When a Value is deleted or; RAUW'ed, ValueMap will update itself so the new version of the key is mapped to; the same value, just as if the key were a WeakVH. You can configure exactly how; this happens, and what else happens on these two events, by passing a ``Config``; parameter to the ValueMap template. .. _dss_intervalmap:. llvm/ADT/IntervalMap.h; ^^^^^^^^^^^^^^^^^^^^^^. IntervalMap is a compact map for small keys and values. It maps key intervals; instead of single keys, and it will automatically coalesce adjacent intervals.; When the map only contains a few intervals, they are stored in the map object; itself to avoid allocations. The IntervalMap iterators are quite big, so they should not be passed around as; STL iterators. The heavyweight iterators allow a smaller data structure. .. _dss_intervaltree:. llvm/ADT/IntervalTree.h; ^^^^^^^^^^^^^^^^^^^^^^^. ``llvm::IntervalTree`` is a light tree data structure to hold intervals. It; allows finding all intervals that overlap with any given point. At this time,; it does not support any deletion or rebalancing operations. The IntervalTree is designed to be set up once, and then queried without any; further additions. .. _dss_map:. <map>; ^^^^^. std::map has similar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:92430,config,configure,92430,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['config'],['configure']
Modifiability,"ch for CMake; - Make Spectrum optional via the `-Dspectrum={OFF,ON}` switch for CMake; - ROOT now fails to configure when any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=ON` now switches the default value of all optional packages to `ON`; - The options `astiff`, `cling`, `pch`, `thread`, and `explicitlink` have been; removed and are now ignored. They either had no effect (their value was not; being used in the build system), or could not be disabled (like `cling` and; `explicitlink`).; - ROOT library targets now export which C++ standard they were built with via; the target compile features `cxx_std_11`, `cxx_std_14`, and `cxx_std_17`.; - The file `RootNewMacros.cmake` has been renamed to `RootMacros.cmake`.; Including the old file by name is deprecated and will generate a warning.; Including `RootMacros.cmake` is not necessary, as now it is already included; when calling `find_package(ROOT)`. If you still need to inherit ROOT's compile; options, however, you may use `include(${ROOT_USE_FILE})` as before.; - ROOT's internal CMake modules (e.g. CheckCompiler.cmake, SetUpLinux.cmake, etc); are no longer installed with `make install`. Only the necessary files by; dependent projects are installed by default now, and they are installed; directly into the cmake/ directory, not cmake/modules/ as before.; - The macro `ROOT_GENERATE_DICTIONARY()` can now attach the generated source; file directly to a library target by using the option `MODULE <library>`, where; `<library>` is an existing library target. This allows the dictionary to inherit; target properties such as compile options and include directories from the library; target, even when they are added after the call to `ROOT_GENERATE_DICTIONARY()`.; - The macros `REFLEX_GENERATE_DICTIONARY()` and `ROOT_GENERATE_DICTIONARY()` can; now have custom extra dependencies added with the options `DEPENDS` and; `EXTRA_DEPENDENCIES`, respectively. The following builtins have been updated:. - F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:8872,inherit,inherit,8872,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['inherit'],['inherit']
Modifiability,"ch record contains a globally; unique ID defining a given ROOT job that wrote a referenced object (see \ref tprocessid).; Each referenced object contains a ""pidf"" field referencing the corresponding TProcessID; record and an ""fUniqueID"" field uniquely identifying the referenced object among those; written by that process (see \ref tobject). Similarly, every persistent reference to that; object (a TRef Object, see \ref tref) also contains ""pidf"" and ""fUniqueID"" fields with the; same value, thereby uniquely determining the referenced object (which need not even be in the; same file). In the case of an array of references (a TRefArray object, see \ref trefarray),; there is one ""pidf"" value for the entire array, and a separate ""fUniqueID"" value for each; reference. For further information, see the above URL. ## Some useful container classes. ### TObjArray and TClonesArray. The TObjArray class can be used to support an array of objects. The objects need not be of the; same type, but each object must be of a class type that inherits from TObject. We have already; seen a specific example of the use of TObjArray, in the StreamerInfo record, where it is used; to hold an array of TStreamerElement objects, each of which is of a class inheriting from; TStreamerElement, which in turn inherits from TObject. The TClonesArray class is a specialization of the TObjArray class for holding an array; of objects that are all of the same type. The format of a TClonesArray object; is given in \ref tclonesarray. There are two great advantages in the use of TClonesArray over TObjArray when the objects; all will be of the same class:. 1. Memory for the objects will be allocated only once for the entire array, rather; than the per-object allocation for TObjArray. This can be done because all the; objects are the same size.; 2. In the case of TObjArray, the stored objects are written sequentially. However,; in a TClonesArray, by default, each object is split one level deep into its base; class(e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:12023,inherit,inherits,12023,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['inherit'],['inherits']
Modifiability,"ch(runtime_name ${runtime_names}); if(NOT TARGET ${runtime_name}); add_custom_target(${runtime_name}); endif(); add_dependencies(${runtime_name} ${runtime_name}-${name}); if(NOT TARGET install-${runtime_name}); add_custom_target(install-${runtime_name}); endif(); add_dependencies(install-${runtime_name} install-${runtime_name}-${name}); if(NOT TARGET install-${runtime_name}-stripped); add_custom_target(install-${runtime_name}-stripped); endif(); add_dependencies(install-${runtime_name}-stripped install-${runtime_name}-${name}-stripped); endforeach(); foreach(component ${LLVM_RUNTIME_DISTRIBUTION_COMPONENTS}); add_dependencies(${component} ${component}-${name}); add_dependencies(install-${component} install-${component}-${name}); add_dependencies(install-${component}-stripped install-${component}-${name}-stripped); endforeach(); endfunction(). if(runtimes); # Create a runtimes target that uses this file as its top-level CMake file.; # The runtimes target is a configuration of all the runtime libraries; # together in a single CMake invocation.; set(extra_deps """"); if(""openmp"" IN_LIST LLVM_ENABLE_RUNTIMES); foreach(dep opt llvm-link llvm-extract clang clang-offload-packager); if(TARGET ${dep} AND OPENMP_ENABLE_LIBOMPTARGET); list(APPEND extra_deps ${dep}); endif(); endforeach(); endif(); if(""libc"" IN_LIST LLVM_ENABLE_PROJECTS AND; (LLVM_LIBC_FULL_BUILD OR LIBC_GPU_BUILD OR LIBC_GPU_ARCHITECTURES)); if(LIBC_HDRGEN_EXE); set(hdrgen_exe ${LIBC_HDRGEN_EXE}); else(); if(TARGET ${LIBC_TABLEGEN_EXE}); set(hdrgen_exe $<TARGET_FILE:${LIBC_TABLEGEN_EXE}>); else(); set(hdrgen_exe ${LIBC_TABLEGEN_EXE}); endif(); set(hdrgen_deps ${LIBC_TABLEGEN_TARGET}); endif(); if(NOT hdrgen_exe); message(FATAL_ERROR ""libc-hdrgen executable missing""); endif(); set(libc_cmake_args ""-DLIBC_HDRGEN_EXE=${hdrgen_exe}""; ""-DLLVM_LIBC_FULL_BUILD=ON""); list(APPEND extra_deps ${hdrgen_deps}); if(LIBC_GPU_BUILD OR LIBC_GPU_ARCHITECTURES); foreach(dep clang-offload-packager nvptx-arch amdgpu-arch); if(TARGET ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:15303,config,configuration,15303,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"chain and runtime libraries to be more easily ported to new; platforms since (theoretically) only ``lib/Support`` needs to be ported. This; library also unclutters the rest of LLVM from #ifdef use and special cases for; specific operating systems. Such uses are replaced with simple calls to the; interfaces provided in ``include/llvm/Support``. Note that the Support Library is not intended to be a complete operating system; wrapper (such as the Adaptive Communications Environment (ACE) or Apache; Portable Runtime (APR)), but only provides the functionality necessary to; support LLVM. The Support Library was originally referred to as the System Library, written; by Reid Spencer who formulated the design based on similar work originating; from the eXtensible Programming System (XPS). Several people helped with the; effort; especially, Jeff Cohen and Henrik Bach on the Win32 port. Keeping LLVM Portable; =====================. In order to keep LLVM portable, LLVM developers should adhere to a set of; portability rules associated with the Support Library. Adherence to these rules; should help the Support Library achieve its goal of shielding LLVM from the; variations in operating system interfaces and doing so efficiently. The; following sections define the rules needed to fulfill this objective. Don't Include System Headers; ----------------------------. Except in ``lib/Support``, no LLVM source code should directly ``#include`` a; system header. Care has been taken to remove all such ``#includes`` from LLVM; while ``lib/Support`` was being developed. Specifically this means that header; files like ""``unistd.h``"", ""``windows.h``"", ""``stdio.h``"", and ""``string.h``""; are forbidden to be included by LLVM source code outside the implementation of; ``lib/Support``. To obtain system-dependent functionality, existing interfaces to the system; found in ``include/llvm/Support`` should be used. If an appropriate interface is; not available, it should be added to ``include/llvm/Sup",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:1611,portab,portable,1611,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,2,['portab'],"['portability', 'portable']"
Modifiability,"changed accordingly (see [#13219](https://github.com/root-project/root/pull/13219) and [#13264](https://github.com/root-project/root/pull/13264)).; If you were not using `RField::(Read|Append)` directly, this change should not impact you. - The new `RNTupleImporter` class provides automatic conversion of TTree to RNTuple.; Note that not all of the C++ types supported in TTree are currently supported in RNTuple. - Many bug fixes and performance improvements. Please, report any issues regarding the abovementioned features should you encounter them.; RNTuple is still experimental and is scheduled to become production grade by end of 2024.; Thus, we appreciate feedback and suggestions for improvement. ## Histogram Libraries. ## Math Libraries. ### Minuit2 is now the default minimizer. Many ROOT-based frameworks and users employ Minuit2 as the minimizer of choice for a long time already.; Therefore, Minuit2 is now the default minimizer used by ROOT.; This affects also **RooFit**, which inherits the default minimizer from ROOT Math. The default can be changed back to the old Minuit implementation as follows:; ```c++; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit"");; ```. Alternatively, you can add this line to your `~/.rootrc` file:; ```; Root.Fitter: Minuit; ```. ### Behavior change of `TMath::AreEqualAbs()`. The `TMath::AreEqualAbs()` compares two numbers for equality within a certain absolute range.; So far, it would tell you that `inf != inf` if you define `inf` as `std::numeric_limits<double>::infinity()`, which is inconsistent with the regular `==` operator. This is unexpected, because one would expect that if two numbers are considered exactly equal, they would also be considered equal within any range.; Therefore, the behavior of `TMath::AreEqualAbs()` was changed to return always `true` if the `==` comparison would return `true`. ## RooFit Libraries. ### Changes in RooFormulaVar and RooGenericPdf. The TFormula-based RooFit classes `RooFormulaVar` and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:10256,inherit,inherits,10256,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['inherit'],['inherits']
Modifiability,"character encodings; Yes. 279; C99; Wide character code values for members of the basic character set; Yes. 280; NAD; struct tm, member tm_isdst, and mktime() in <time.h>; N/A. 281; C99; CLOCKS_PER_SEC should not be a constant expression; N/A. 282; C99; Flexible array members & struct padding; Yes. 283; C99; Accessing a non-current union member (""type punning""); Unknown. 284; NAD; Does <math.h> define INT_MIN and INT_MAX?; N/A. 285; C99; Conversion of an imaginary type to _Bool. Partial; Clang detects use of the _Imaginary keyword but does not otherwise; support the type yet.; . 286; C99; Correctly rounded and rounding direction/mode; N/A. 287; Dup; Floating-point status flags and sequence points; Duplicate of 87. 288; NAD; Deficiency on multibyte conversions; N/A. 289; C99; Function prototype with [restrict]; Yes. 290; C99; FLT_EVAL_METHOD and extra precision and/or range; Unknown. 291; C99; Corrections to requirements on inexact floating-point exceptions; Unknown. 292; C99; Use of the word variable; Yes. 293; C99; Typo in Standard - double complex instead of complex in an example; Yes. 294; NAD; Technical question on C99 restrict keyword; Unknown. 295; C99; Incomplete types for function parameters; Yes. 296; C99; Is exp(INFINITY) overflow? A range error? A divide-by-zero exception? INFINITY without any errors?; N/A. 297; C99; May FE_* floating-point exception flags have bits in common?; N/A. 298; C99; Validity of constant in unsigned long long range. Partial; Clang defines the behavior in this situation by automatically using; long long or unsigned long long as the; underlying type of the constant; however, Clang fails to diagnose the; extension in C89 mode with such constants.; . 299; C99; Is cabs() a type-generic macro?; N/A. 300; NAD; Translation-time expresssion evaluation; Yes. 301; NAD; Meaning of FE_* macros in <fenv.h>; Yes. 302; C99; 6.10.2p5: Adding underscore to portable include file name character set; Yes. 303; C99; 6.10p2: Breaking up the very long se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:17505,variab,variable,17505,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,1,['variab'],['variable']
Modifiability,"che scripts to make these features more approachable. CMake cache files are utilized using CMake's -C flag:. .. code-block:: console. $ cmake -C <path to cache file> <path to sources>. CMake cache scripts are processed in an isolated scope, only cached variables; remain set when the main configuration runs. CMake cached variables do not reset; variables that are already set unless the FORCE option is specified. A few notes about CMake Caches:. - Order of command line arguments is important. - -D arguments specified before -C are set before the cache is processed and; can be read inside the cache file; - -D arguments specified after -C are set after the cache is processed and; are unset inside the cache file. - All -D arguments will override cache file settings; - CMAKE_TOOLCHAIN_FILE is evaluated after both the cache file and the command; line arguments; - It is recommended that all -D options should be specified *before* -C. For more information about some of the advanced build configurations supported; via Cache files see :doc:`AdvancedBuilds`. Executing the Tests; ===================. Testing is performed when the *check-all* target is built. For instance, if you are; using Makefiles, execute this command in the root of your build directory:. .. code-block:: console. $ make check-all. On Visual Studio, you may run tests by building the project ""check-all"".; For more information about testing, see the :doc:`TestingGuide`. Cross compiling; ===============. See `this wiki page <https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/CrossCompiling>`_ for; generic instructions on how to cross-compile with CMake. It goes into detailed; explanations and may seem daunting, but it is not. On the wiki page there are; several examples including toolchain files. Go directly to the; ``Information how to set up various cross compiling toolchains`` section; for a quick solution. Also see the `LLVM-related variables`_ section for variables used when; cross-compiling. Embeddin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:39790,config,configurations,39790,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['config'],['configurations']
Modifiability,"che; this plot; is present only if some I/O is done, i.e. not for pure CPU tasks.; The number of active workers; The number of total and effecive sessions running; concurrently on the cluster (started by the same daemon); this plot is; present only is the number is at least onec different from 1. If enabled, send monitoring information from the master; at each GetNextPacket (at each call of TPerfStat::PacketEvent) to allow; extrnal real-time progress monitoring.; Save the status of a 'proofserv' session into a new file; in the 'activesessions' area. The full path of the new file is;          ; <admin_path>/.xproofd.<port>/activesessions/<user>.<group>.<pid>.status. The status indicates whether the session is idle, running or queued.; The status is updated every 'checkfq' secs (see xpd.proofservmgr;; default 30 s). The status is dumped by the reader thread of TXProofServ; and therefore its r/w access is protected. Enable the use of the tree cache also for local files,; adapting the default settings for the cache to the recent changes; In the XrdProofd plug-in. Improve synchronization between parent and child during; fork; Optimize loops over directory entries; Improve error and notification messages. Improved handling of Ctrl-C; this follows from a fix in; TMonitor and an improved handling of non-finished query state in the; workers (results are not send to master if the query was aborted) . Fixes. TFileMerger. Fix a problem preventing correct transmission of all; non-mergeable objects (fixes bug #52886); Remove the argument isdir from the function; MergeRecursive; Do not remove the first file in the list when returning; from MergeRecursive (fixes bug #54591); Fix a major leak when merging files with collections; written using kSingleKey option.  The merger was reading each; key in memory and deleted the object at the end, but the container is; not owner by default, so all objects inside leaked. PROOF-Lite. Fix a couple of memory leaks showing up when running; repeate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:6043,adapt,adapting,6043,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,2,"['adapt', 'plug-in']","['adapting', 'plug-in']"
Modifiability,"check-llvm``. This will setup an LLVM build with debugging info, then compile LLVM and; run LLVM tests. * For more detailed information on CMake options, see `CMake <CMake.html>`__. * If you get build or test failures, see `below`_. Consult the `Getting Started with LLVM`_ section for detailed information on; configuring and compiling LLVM. Go to `Directory Layout`_ to learn about the; layout of the source code tree. Stand-alone Builds; ------------------. Stand-alone builds allow you to build a sub-project against a pre-built; version of the clang or llvm libraries that is already present on your; system. You can use the source code from a standard checkout of the llvm-project; (as described above) to do stand-alone builds, but you may also build; from a :ref:`sparse checkout<workflow-multicheckout-nocommit>` or from the; tarballs available on the `releases <https://github.com/llvm/llvm-project/releases/>`_; page. For stand-alone builds, you must have an llvm install that is configured; properly to be consumable by stand-alone builds of the other projects.; This could be a distro provided LLVM install, or you can build it yourself,; like this:. .. code-block:: console. cmake -G Ninja -S path/to/llvm-project/llvm -B $builddir \; -DLLVM_INSTALL_UTILS=ON \; -DCMAKE_INSTALL_PREFIX=/path/to/llvm/install/prefix \; < other options >. ninja -C $builddir install. Once llvm is installed, to configure a project for a stand-alone build, invoke CMake like this:. .. code-block:: console. cmake -G Ninja -S path/to/llvm-project/$subproj \; -B $buildir_subproj \; -DLLVM_EXTERNAL_LIT=/path/to/lit \; -DLLVM_ROOT=/path/to/llvm/install/prefix. Notice that:. * The stand-alone build needs to happen in a folder that is not the; original folder where LLVMN was built; (`$builddir!=$builddir_subproj`).; * ``LLVM_ROOT`` should point to the prefix of your llvm installation,; so for example, if llvm is installed into ``/usr/bin`` and; ``/usr/lib64``, then you should pass ``-DLLVM_ROOT=/usr/``.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:5696,config,configured,5696,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configured']
Modifiability,"checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15658,portab,portable,15658,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['portab'],['portable']
Modifiability,"cializationType() matches the type of the explicit; instantiation in A and the type of the variable declaration in B. Matcher<Type>templateTypeParmTypeMatcher<TemplateTypeParmType>...; Matches template type parameter types. Example matches T, but not int.; (matcher = templateTypeParmType()); template <typename T> void f(int i);. Matcher<Type>typeMatcher<Type>...; Matches Types in the clang AST. Matcher<Type>typedefTypeMatcher<TypedefType>...; Matches typedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as Ty",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53106,variab,variableArrayTypeMatcher,53106,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variableArrayTypeMatcher']
Modifiability,"cidentally forget; to drain an autorelease pool when using the manual API, and this can; significantly inflate the process's high-water-mark. The introduction of a; new scope is unfortunate but basically required for sane interaction with the; rest of the language. Not draining the pool during an unwind is apparently; required by the Objective-C exceptions implementation. .. _arc.misc.externally_retained:. Externally-Retained Variables; -----------------------------. In some situations, variables with strong ownership are considered; externally-retained by the implementation. This means that the variable is; retained elsewhere, and therefore the implementation can elide retaining and; releasing its value. Such a variable is implicitly ``const`` for safety. In; contrast with ``__unsafe_unretained``, an externally-retained variable still; behaves as a strong variable outside of initialization and destruction. For; instance, when an externally-retained variable is captured in a block the value; of the variable is retained and released on block capture and destruction. It; also affects C++ features such as lambda capture, ``decltype``, and template; argument deduction. Implicitly, the implementation assumes that the :ref:`self parameter in a; non-init method <arc.misc.self>` and the :ref:`variable in a for-in loop; <arc.misc.enumeration>` are externally-retained. Externally-retained semantics can also be opted into with the; ``objc_externally_retained`` attribute. This attribute can apply to strong local; variables, functions, methods, or blocks:. .. code-block:: objc. @class WobbleAmount;. @interface Widget : NSObject; -(void)wobble:(WobbleAmount *)amount;; @end. @implementation Widget. -(void)wobble:(WobbleAmount *)amount; __attribute__((objc_externally_retained)) {; // 'amount' and 'alias' aren't retained on entry, nor released on exit.; __attribute__((objc_externally_retained)) WobbleAmount *alias = amount;; }; @end. Annotating a function with this attribute makes ev",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:92504,variab,variable,92504,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['variab'],['variable']
Modifiability,"ciding exactly what you need to say to help the user,; picking a suitable wording, and providing the information needed to format it; correctly. The good news is that the call site that issues a diagnostic should; be completely independent of how the diagnostic is formatted and in what; language it is rendered. Fix-It Hints; ^^^^^^^^^^^^. In some cases, the front end emits diagnostics when it is clear that some small; change to the source code would fix the problem. For example, a missing; semicolon at the end of a statement or a use of deprecated syntax that is; easily rewritten into a more modern form. Clang tries very hard to emit the; diagnostic and recover gracefully in these and other cases. However, for these cases where the fix is obvious, the diagnostic can be; annotated with a hint (referred to as a ""fix-it hint"") that describes how to; change the code referenced by the diagnostic to fix the problem. For example,; it might add the missing semicolon at the end of the statement or rewrite the; use of a deprecated construct into something more palatable. Here is one such; example from the C++ front end, where we warn about the right-shift operator; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is suggesting that parentheses be added, and showing; exactly where those parentheses would be inserted into the source code. The; fix-it hints themselves describe what changes to make to the source code in an; abstract manner, which the text diagnostic printer renders as a line of; ""insertions"" below the caret line. :ref:`Other diagnostic clients; <DiagnosticConsumer>` might choose to render the code differently (e.g., as; markup inline) or even give the user the ability to automatically fix the; problem. Fix-it hints on errors and warnings need to obey these rules:. * Since they are automatical",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:18524,rewrite,rewrite,18524,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['rewrite'],['rewrite']
Modifiability,"cient for a wide range of applications, but you might have; already asked yourself ""how can this code be compiled ?"". There are two; answers. ### Compile a Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory and you will be able to execute it simply by calling from; inside the interpreter:. ``` {.cpp}; root [2] macro1(); ```. ### Compile a Macro with the Compiler. A plethora of excellent compilers are available, both free and; commercial. We will refer to the `GCC` compiler in the following. In; this case, you have to include the appropriate headers in the code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keybo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:10164,config,config,10164,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['config'],['config']
