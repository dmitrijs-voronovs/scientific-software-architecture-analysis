quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"ty to set single side parameter limits or the FUMILI algorithm, which is an optimized method for least square and log likelihood minimizations. The package has been originally developed by M. Winkler and F. James. More information on the new C++ version can be found on the <a href=""http://www.cern.ch/minuit"">MINUIT Web Site</a> and in particular the online doc can be found here <a href=""http://www.cern.ch/mathlibs/sw/html/Minuit2.html"">here</a>.<p>; Minuit2, originally developed in the SEAL project, is now distributed within ROOT. The API has been then changed in this new version to follow the ROOT coding convention (function names starting with capital letters) and the classes have been moved inside the namespace <em>ROOT::Minuit2</em>. In addition, the ROOT distribution contains classes like TFitterMinuit and TFitterFumili needed to integrate Minuit2 in the ROOT framework. <p>; In the latest version (from 5.17.08) a new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements the interface; ROOT::Math::Minimizer from <a href=""http://www.cern.ch/mathlibs/sw/html/MathCore.html"">MathCore</a>.; . It can be instantiates also using the ROOT plug-in manager. It is a convenient entry point for using Minuit2. <h3>References</h3>; <p>; <ol>; <li>; F. James, <em>Fortran MINUIT Reference Manual</em> (<a href=""https://cern-tex.web.cern.ch/cern-tex/minuit/minmain.html"">html</a>); </li>; <li>; F. James and M. Winkler, <em>C++ MINUIT User's Guide</em> (<a href=""http://seal.cern.ch/documents/minuit/mnusersguide.pdf"">pdf</a>); </li>; <li>; F. James, <em>Minuit Tutorial on Function Minimization</em> (<a href=""http://seal.cern.ch/documents/minuit/mntutorial.pdf"">pdf</a>); </li>; <li>; F. James, <em>The Interpretation of Errors in Minuit</em> (<a href=""http://seal.cern.ch/documents/minuit/mnerror.pdf"">pdf</a>); </li>; </ol>; <p>; <hr>; <h3>See also:</h3>; <ul>; <li>Recommended <a href=""http://www.cern.ch/mathlibs/sw/html/Minuit2.html"">Online doc for all Minuit2 clas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/index.txt:1408,interface,interface,1408,math/minuit2/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/index.txt,1,['interface'],['interface']
Integrability,"ty. The ``#include`` mechanism works just fine. No Exposed Functions; --------------------. Any functions defined by system libraries (i.e. not defined by ``lib/Support``); must not be exposed through the ``lib/Support`` interface, even if the header; file for that function is not exposed. This prevents inadvertent use of system; specific functionality. For example, the ``stat`` system call is notorious for having variations in the; data it provides. ``lib/Support`` must not declare ``stat`` nor allow it to be; declared. Instead it should provide its own interface to discovering; information about files and directories. Those interfaces may be implemented in; terms of ``stat`` but that is strictly an implementation detail. The interface; provided by the Support Library must be implemented on all platforms (even; those without ``stat``). No Exposed Data; ---------------. Any data defined by system libraries (i.e. not defined by ``lib/Support``) must; not be exposed through the ``lib/Support`` interface, even if the header file; for that function is not exposed. As with functions, this prevents inadvertent; use of data that might not exist on all platforms. Minimize Soft Errors; --------------------. Operating system interfaces will generally provide error results for every; little thing that could go wrong. In almost all cases, you can divide these; error results into two groups: normal/good/soft and abnormal/bad/hard. That is,; some of the errors are simply information like ""file not found"", ""insufficient; privileges"", etc. while other errors are much harder like ""out of space"", ""bad; disk sector"", or ""system call interrupted"". We'll call the first group ""*soft*""; errors and the second group ""*hard*"" errors. ``lib/Support`` must always attempt to minimize soft errors. This is a design; requirement because the minimization of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:7042,interface,interface,7042,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"type is of the form `T[N]`. Note that only single-dimension arrays are currently supported. - Improvements to the ROOT file embedding (PR [#10558](https://github.com/root-project/root/pull/10558)). In particular, a `RNTupleReader` or `RDataFrame` object can be created from a `TFile` instance as follows; ```; auto f = TFile::Open(""data.root"");; auto ntpl = f->Get<ROOT::Experimental::RNTuple>(""Events"");. auto reader = ROOT::Experimental::RNTupleReader::Open(ntpl);; // or for RDataFrame; auto rdf = ROOT::Experimental::MakeNTupleDataFrame(ntpl);; ```. - If buffered write is enabled, vector writes are used where possible. In particular, this yields important improvements in storage backends leveraging parallel writes, e.g. in object storages. - Large read/write throughput improvements in the experimental Intel DAOS backend. - `RNTupleWriter::Fill()` now returns the number of uncompressed bytes written, which is align with TTree behavior. - Support for user-defined classes that behave as a collection via the `TVirtualCollectionProxy` interface.; Fields created via `RFieldBase::Create()` automatically detect the presence of a collection proxy at run-time. However, if `RField<T>` (`T` being a class) is used instead, the trait `IsCollectionProxy<T>` must be set for the given type (see PR [#11525](https://github.com/root-project/root/pull/11525) for details).; Note that associative collections are not yet supported. - Some internal support for per field post-read callbacks. This functionality will be presented in upcoming releases through custom I/O rules. Please, report any issues regarding the abovementioned features should you encounter them.; RNTuple is still experimental and is scheduled to become production grade in 2024. Thus, we appreciate feedback and suggestions for improvement. ## RDataFrame. ### New features. - Add [`GraphAsymmErrors`](https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html#acea30792eef607489d498bf6547a00a6) action that fills a TGraphAsym",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:9910,interface,interface,9910,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interface']
Integrability,"u have other objects not; drawn with the graphics editor (histograms for example). ### The Editor Frame. The ROOT graphics editor loads the corresponding object editor; `objEditor` according to the selected object `obj` in the canvas; respecting the class inheritance. An object in the canvas is selected; after the left mouse click on it. For example, if the selected object; is **`TAxis`**, the **`TAxisEditor`** will shows up in the editor; frame giving the possibility for changing different axis attributes.; The graphics editor can be:. Embedded - connected only with the canvas in the application window; that appears on the left of the canvas window after been activated via; View menu / Editor. It appears on the left side if the canvas window; allowing users to edit the attributes of the selected object via; provided user interface. The name of the selected object is displayed; on the top of the editor frame in red color. If the user interface; needs more space then the height of the canvas window, a vertical; scroll bar appears for easer navigation. ![](pictures/03000027.png). Global - has own application window and can be connected to any; created canvas in a ROOT session. It can be activated via the context; menu entries for setting line, fill, text and marker attributes for; backward compatibility, but there will be a unique entry in the near; future. ![](pictures/03000028.png). The user interface for the following classes is available since ROOT; v.4.04: **`TAttLine`**, **`TAttFill`**, **`TAttMarker`**,; **`TAttText`**, **`TArrow`**, **`TAxis`**, **`TCurlyArc`**,; **`TCurlyLine`**, **`TFrame`**, **`TH1`**, **`TH2`**, **`TGraph`**,; **`TPad`**, **`TCanvas`**, **`TPaveStats`**. For more details, see; ""The Graphics Editor"", ""The User Interface for Histograms"", ""The User; Interface for Graphs"". ### Classes, Methods and Constructors. Object oriented programming introduces objects, which have data; members and methods. The next line creates an object named `f1` of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:17570,interface,interface,17570,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['interface'],['interface']
Integrability,u/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/deviceinfo/llvm-omp-device-info.cpp; openmp/runtime/doc/doxygen/libomp_interface.h; openmp/runtime/src/extractExternal.cpp; openmp/runtime/src/kmp.h; openmp/runtime/src/kmp_affinity.h; openmp/runtime/src/kmp_alloc.cpp; openmp/runtime/src/kmp_atomic.cpp; openmp/runtime/src/kmp_atomic.h; openmp/runtime/src/kmp_barrier.h; openmp/runtime/src/kmp_cancel.cpp; openmp/runtime/src/kmp_debug.cpp; openmp/runtime/src/kmp_debug.h; openmp/runtime/src/kmp_debugger.cpp; openmp/runtime/src/kmp_debugger.h; openmp/runtime/src/kmp_dispatch.cpp; openmp/runtime/src/kmp_dispatch.h; openmp/runtime/src/kmp_dispatch_hier.h; openmp/runtime/src/kmp_environment.cpp; openmp/runtime/src/kmp_environment.h; openmp/runtime/src/kmp_error.cpp; openmp/runtime/src/kmp_error.h; openmp/runtime/src/kmp_ftn_cdecl.cpp; openmp/runtime/src,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:408320,interface,interface,408320,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['interface'],['interface']
Integrability,"ual optimizations for local values. .. admonition:: Rationale. This formalizes direct transfers of ownership from a caller to a callee. The; most common scenario here is passing the ``self`` parameter to ``init``, but; it is useful to generalize. Typically, local optimization will remove any; extra retains and releases: on the caller side the retain will be merged with; a +1 source, and on the callee side the release will be rolled into the; initialization of the parameter. The implicit ``self`` parameter of a method may be marked as consumed by adding; ``__attribute__((ns_consumes_self))`` to the method declaration. Methods in; the ``init`` :ref:`family <arc.method-families>` are treated as if they were; implicitly marked with this attribute. It is undefined behavior if an Objective-C message send to a method with; ``ns_consumed`` parameters (other than self) is made with a null receiver. It; is undefined behavior if the method to which an Objective-C message send; statically resolves to has a different set of ``ns_consumed`` parameters than; the method it dynamically resolves to. It is undefined behavior if a block or; function call is made through a static type with a different set of; ``ns_consumed`` parameters than the implementation of the called block or; function. .. admonition:: Rationale. Consumed parameters with null receiver are a guaranteed leak. Mismatches; with consumed parameters will cause over-retains or over-releases, depending; on the direction. The rule about function calls is really just an; application of the existing C/C++ rule about calling functions through an; incompatible function type, but it's useful to state it explicitly. .. _arc.object.operands.retained-return-values:. Retained return values; ^^^^^^^^^^^^^^^^^^^^^^. A function or method which returns a retainable object pointer type may be; marked as returning a retained value, signifying that the caller expects to take; ownership of a +1 retain count. This is done by adding the; ``n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:18299,message,message,18299,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"ually 'this'), `in`; (string to add to the squashed code).; - Output: Adds the input string to the squashed code body. - **RooFit::Detail::CodeSquashContext::addToGlobalScope()**: Helps declare and; initialize the results variable, so that it can be available globally; (throughout the function body). - Input: `str` (the string to add to the global scope).; - Output: Adds the given string to the string block that will be emitted at; the top of the squashed function. - **RooFit::Detail::CodeSquashContext::assembleCode()**: combines the generated; code statements into the final code body of the squashed function. - Input: `returnExpr` (he string representation of what the squashed function; should return, usually the head node).; - Output: The final body of the function. - **RooFit::Detail::CodeSquashContext::beginLoop()**: The code squashing task; will automatically build a For loop around the indented statements that follow; this function. - Input: `in` (a pointer to the calling class, used to determine the loop; dependent variables).; - Output: A scope for iterating over vector observables. - **RooFit::Detail::CodeSquashContext::buildArg()**: helps convert RooFit; objects into arrays or other C++ representations for efficient computation. - Input: `in` (the list to convert to array).; - Output: Name of the array that stores the input list in the squashed code. - **RooFit::Detail::CodeSquashContext::buildCall()**: Creates a string; representation of the function to be called and its arguments. - Input: A function with name `funcname`, passing some arguments.; - Output: A string representation of the function to be called. - **RooFit::Detail::makeValidVarName()**: It helps fetch and save a valid name; from the name of the respective RooFit class. - Input: `in` (the input string).; - Output: A new string that is a valid variable name. - **RooFuncWrapper::buildCode()**: Generates the optimized code for evaluating; the function and its derivatives. - Input: `head` (starti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:36599,depend,dependent,36599,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['depend'],['dependent']
Integrability,"uch solution - copy only the top index.htm file from JSROOT package and specify the full path to `modules/gui.mjs` script like:. ```javascript; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; ```. In the main `<div>` element one can specify many custom parameters like one do it in URL string:. ```html; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; ```. ## Reading local ROOT files. JSROOT can read files from local file system using HTML5 FileReader functionality.; Main limitation here - user should interactively select files for reading.; There is button __""...""__ on the main JSROOT page, which starts file selection dialog.; If valid ROOT file is selected, JSROOT will be able to normally read content of such file. ## JSROOT with THttpServer. THttpServer provides http access to objects from running ROOT application.; JSROOT is used to implement the user interface in the web browsers. The layout of the main page coming from THttpServer is very similar to normal JSROOT page.; One could browse existing items and display them. A snapshot of running; server can be seen on the [demo page](https://root.cern/js/latest/httpserver.C/). One could also specify similar URL parameters to configure the displayed items and drawing options. It is also possible to display one single item from the THttpServer server like:. <https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz>. ## Data monitoring with JSROOT. ### Monitoring with http server. The best possibility to organize the monitoring of data from a running application; is to use THttpServer. In such case the client can always access the latest; changes and request only the items currently displayed in the browser.; To enable monitoring, one should activate the appropriate checkbox or; provide __monitoring__ parameter in the URL string like:. <https://root.cern/js/lat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:29885,interface,interface,29885,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['interface'],['interface']
Integrability,"uction``\ s it contains:. .. code-block:: c++. Function &Func = ...; for (BasicBlock &BB : Func); // Print out the name of the basic block if it has one, and then the; // number of instructions that it contains; errs() << ""Basic block (name="" << BB.getName() << "") has ""; << BB.size() << "" instructions.\n"";. .. _iterate_basicblock:. Iterating over the ``Instruction`` in a ``BasicBlock``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Just like when dealing with ``BasicBlock``\ s in ``Function``\ s, it's easy to; iterate over the individual instructions that make up ``BasicBlock``\ s. Here's; a code snippet that prints out each instruction in a ``BasicBlock``:. .. code-block:: c++. BasicBlock& BB = ...; for (Instruction &I : BB); // The next statement works since operator<<(ostream&,...); // is overloaded for Instruction&; errs() << I << ""\n"";. However, this isn't really the best way to print out the contents of a; ``BasicBlock``! Since the ostream operators are overloaded for virtually; anything you'll care about, you could have just invoked the print routine on the; basic block itself: ``errs() << BB << ""\n"";``. .. _iterate_insiter:. Iterating over the ``Instruction`` in a ``Function``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If you're finding that you commonly iterate over a ``Function``'s; ``BasicBlock``\ s and then that ``BasicBlock``'s ``Instruction``\ s,; ``InstIterator`` should be used instead. You'll need to include; ``llvm/IR/InstIterator.h`` (`doxygen; <https://llvm.org/doxygen/InstIterator_8h.html>`__) and then instantiate; ``InstIterator``\ s explicitly in your code. Here's a small example that shows; how to dump all instructions in a function to the standard error stream:. .. code-block:: c++. #include ""llvm/IR/InstIterator.h"". // F is a pointer to a Function instance; for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I); errs() << *I << ""\n"";. Easy, isn't it? You can also use ``InstIterator``\ s to fill a work list w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:106639,rout,routine,106639,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['rout'],['routine']
Integrability,"uctor call expression has at least; the specified number of arguments (including absent default arguments). Example matches f(0, 0) and g(0, 0, 0); (matcher = callExpr(argumentCountAtLeast(2))); void f(int x, int y);; void g(int x, int y, int z);; f(0, 0);; g(0, 0, 0);. Matcher<ObjCMessageExpr>argumentCountIsunsigned N; Checks that a call expression or a constructor call expression has; a specific number of arguments (including absent default arguments). Example matches f(0, 0) (matcher = callExpr(argumentCountIs(2))); void f(int x, int y);; f(0, 0);. Matcher<ObjCMessageExpr>hasAnySelectorStringRef, ..., StringRef; Matches when at least one of the supplied string equals to the; Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""methodA:"", ""methodB:""));; matches both of the expressions below:; [myObj methodA:argA];; [myObj methodB:argB];. Matcher<ObjCMessageExpr>hasKeywordSelector; Matches when the selector is a keyword selector. objCMessageExpr(hasKeywordSelector()) matches the generated setFrame; message expression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:106199,message,message,106199,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['message'],['message']
Integrability,uctor calls; Not resolved. 2474; CD6; Cv-qualification and deletion; Unknown. 2475; C++23; Object declarations of type cv void; Unknown. 2476; tentatively ready; placeholder-type-specifiers and function declarators; Unknown. 2477; CD6; Defaulted vs deleted copy constructors/assignment operators; Unknown. 2478; C++23; Properties of explicit specializations of implicitly-instantiated class templates; Unknown. 2479; CD6; Missing specifications for consteval and constinit; Unknown. 2480; drafting; Lookup for enumerators in modules; Not resolved. 2481; CD6; Cv-qualification of temporary to which a reference is bound; Unknown. 2482; CD6; bit_cast and indeterminate values; Unknown. 2483; C++23; Language linkage of static member functions; Unknown. 2484; CD6; char8_t and char16_t in integral promotions; Unknown. 2485; DRWP; Bit-fields in integral promotions; Unknown. 2486; CD6; Call to noexcept function via noexcept(false) pointer/lvalue; Unknown. 2487; drafting; Type dependence of function-style cast to incomplete array type; Not resolved. 2488; open; Overloading virtual functions and functions with trailing requires-clauses; Not resolved. 2489; C++23; Storage provided by array of char; Unknown. 2490; CD6; Restrictions on destruction in constant expressions; Unknown. 2491; CD6; Export of typedef after its first declaration; Unknown. 2492; drafting; Comparing user-defined conversion sequences in list-initialization; Not resolved. 2493; dup; auto as a conversion-type-id; Unknown. 2494; CD6; Multiple definitions of non-odr-used entities; Unknown. 2495; open; Glvalue result of a function call; Not resolved. 2496; CD6; ref-qualifiers and virtual overriding; Unknown. 2497; drafting; Points of instantiation for constexpr function templates; Not resolved. 2498; open; Partial specialization failure and the immediate context; Not resolved. 2499; CD6; Inconsistency in definition of pointer-interconvertibility; Unknown. 2500; extension; noexcept(false) functions and noexcept expression,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:170448,depend,dependence,170448,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependence']
Integrability,"uctors for all elements of the array are called.; We should model (potentially some of) such evaluations,; and the same applies for destructors called from; operator delete[].; See tests cases in handle_constructors_with_new_array.cpp.; . Constructing an array requires invoking multiple (potentially unknown); amount of constructors with the same construct-expression.; Apart from the technical difficulties of juggling program points around; correctly to avoid accidentally merging paths together, we'll have to; be a judge on when to exit the loop and how to widen it.; Given that the constructor is going to be a default constructor,; a nice 95% solution might be to execute exactly one constructor and; then default-bind the resulting LazyCompoundVal to the whole array;; it'll work whenever the default constructor doesn't touch global state; but only initializes the object to various default values.; But if, say, we're making an array of strings,; depending on the implementation you might have to allocate a new buffer; for each string, and in this case default-binding won't cut it.; We might want to come up with an auxiliary analysis in order to perform; widening of these simple loops more precisely.; . Handle constructors that can be elided due to Named Return Value Optimization (NRVO); Local variables which are returned by values on all return statements; may be stored directly at the address for the return value,; eliding the copy or move constructor call.; Such variables can be identified using the AST call VarDecl::isNRVOVariable.; . Handle constructors of lambda captures; Variables which are captured by value into a lambda require a call to; a copy constructor.; This call is not currently modeled.; . Handle constructors for default arguments; Default arguments in C++ are recomputed at every call,; and are therefore local, and not static, variables.; See tests cases in handle_constructors_for_default_arguments.cpp.; . Default arguments are annoying because the initi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:3649,depend,depending,3649,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['depend'],['depending']
Integrability,"ude/llvm/Support`` and implemented in; ``lib/Support`` for all supported platforms. Don't Expose System Headers; ---------------------------. The Support Library must shield LLVM from **all** system headers. To obtain; system level functionality, LLVM source must; ``#include ""llvm/Support/Thing.h""`` and nothing else. This means that; ``Thing.h`` cannot expose any system header files. This protects LLVM from; accidentally using system specific functionality and only allows it via; the ``lib/Support`` interface. Use Standard C Headers; ----------------------. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; template library may be exposed through the ``lib/Support`` interface. These; headers and the things they declare are considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``execve``, and ``wait``. The; correct thing for ``lib/Support`` to provide is a function, say; ``ExecuteProgramAndWait``, that implements the functionality completely. what; we d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:3703,interface,interface,3703,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"uding the input ll/bc file), they are; given via the following flag:; `--test_args=<test_arguments>`; If unspecified, the test is run as given. It’s worth noting that the input file; would be passed as a parameter to the test, similar how `-compile-custom`; currently operates. ### Implementation; The tool would behave similar to CReduce’s functionality in that it would have a; list of passes that try to minimize the given test-case. We should be able to; modularize the tool’s behavior, as well as making it easier to maintain and; expand. The first version of this redesign would try to:. * Discard functions, instructions and metadata that don’t influence the; interesting-ness test; * Remove unused parameters from functions; * Eliminate unvisited conditional paths; * Rename variables to more regular ones (such as “a”, “b”, “c”, etc.). Once these passes are implemented, more meaningful reductions (such as type; reduction) would be added to the tool, to even further reduce IR. ## Background on historical bugpoint issues. ### Root Cause Analysis; Presently, bugpoint takes a long time to find the source problem in a given IR; file, mainly due to the fact that it tries to debug the input by running; various strategies to classify the bug, which in turn run multiple optimizer; and compilation passes over the input, taking up a lot of time. Furthermore,; when the IR crashes, it tries to reduce it by performing some sub-optimal; passes (e.g. a lot of unreachable blocks), and sometimes even fails to minimize; at all. ### ""Quirky"" Interface; Bugpoint’s current interface overwhelms and confuses the user, the help screen; alone ends up confusing rather providing guidance. And, not only are there; numerous features and options, but some of them also work in unexpected ways; and most of the time the user ends up using a custom script. Pruning and; simplifying the interface will be worth considering in order to make the tool; more useful in the general case and easier to maintain.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugpointRedesign.md:3572,interface,interface,3572,interpreter/llvm-project/llvm/docs/BugpointRedesign.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugpointRedesign.md,2,['interface'],['interface']
Integrability,"ue/weight; 	 with optionally an error on the value or the coordinate and the `ROOT::Fit::UnBinData` for un-binned data sets,; 	 which consists only of a vector of coordinate values. The coordinate values can be; 	 one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; * Function classes defining the type of fit (the objective function used for fitting):; 	- `ROOT::Fit::Chi2FCN` for chi2 (least-square fits),; 	- `ROOT::Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:27961,interface,interfaces,27961,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,2,['interface'],"['interface', 'interfaces']"
Integrability,"ueReference = 0x01, // ""old"" reference; PointerToDataMember = 0x02, // pointer to data member; PointerToMemberFunction = 0x03, // pointer to member function; RValueReference = 0x04 // r-value reference; };; enum class PointerModifiers : uint8_t {; None = 0x00, // ""normal"" pointer; Flat32 = 0x01, // ""flat"" pointer; Volatile = 0x02, // pointer is marked volatile; Const = 0x04, // pointer is marked const; Unaligned = 0x08, // pointer is marked unaligned; Restrict = 0x10, // pointer is marked restrict; };; enum class PointerFlags : uint8_t {; WinRTSmartPointer = 0x01, // pointer is a WinRT smart pointer; LValueRefThisPointer = 0x02, // pointer is a 'this' pointer of a member function with ref qualifier (e.g. void X::foo() &); RValueRefThisPointer = 0x04 // pointer is a 'this' pointer of a member function with ref qualifier (e.g. void X::foo() &&); };. The ``Size`` field of the Attributes bitmask is a 1-byte value indicating the; pointer size. For example, a `void*` would have a size of either 4 or 8 depending; on the target architecture. On the other hand, if ``Mode`` indicates that this is; a pointer to member function or pointer to data member, then the size can be any; implementation defined number. The ``Member Ptr Info`` field of the ``LF_POINTER`` record is only present if the; attributes indicate that this is a pointer to member. Note that ""plain"" pointers to primitive types are not represented by ``LF_POINTER``; records, they are indicated by special reserved :ref:`TypeIndex values <type_indices>`. LF_MODIFIER (0x1001); ^^^^^^^^^^^^^^^^^^^^. LF_PROCEDURE (0x1008); ^^^^^^^^^^^^^^^^^^^^^. LF_MFUNCTION (0x1009); ^^^^^^^^^^^^^^^^^^^^^. LF_LABEL (0x000e); ^^^^^^^^^^^^^^^^^. LF_ARGLIST (0x1201); ^^^^^^^^^^^^^^^^^^^. LF_FIELDLIST (0x1203); ^^^^^^^^^^^^^^^^^^^^^. LF_ARRAY (0x1503); ^^^^^^^^^^^^^^^^^. LF_CLASS (0x1504); ^^^^^^^^^^^^^^^^^. LF_STRUCTURE (0x1505); ^^^^^^^^^^^^^^^^^^^^^. LF_INTERFACE (0x1519); ^^^^^^^^^^^^^^^^^^^^^. LF_UNION (0x1506); ^^^^^^^^^^^^^^^^^. LF_EN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewTypes.rst:4560,depend,depending,4560,interpreter/llvm-project/llvm/docs/PDB/CodeViewTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewTypes.rst,1,['depend'],['depending']
Integrability,"ues and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""*Materials*"" shutter item; category. Generally, for creating objects, the interface is always in; the **`TGeoManagerEditor`** in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""*Shapes*"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""*Medium*"" category. You will notice that some categories as ""*Volume*""; and ""*Medium*"" are inactive at the beginning because at that time there; is no material yet (for making a medium) and no shape (for making a; volume). These categories are dynamically activated once all the; required components are defined. 5. Create a volume from the ""*Volumes*"" category. You will notice that; contrary to the other editors, the volume editor is opened in a tab, not; transient - this is because it is more complex. 6. Go back to ""*General*"" category and select the newly created volume; as the top one (you can do it also from the volume category). This is; just for starting. To create some hierarchy, one has to create several; other volumes and the matrices to position them. Once this is done, use; the volume editor interface to:; - add/remove daughters, change shape, edit position of daughters; - change visualization settings; - divide the volume (only if there are no daughters yet). 7. Close the geometry from the ""*General*"" category.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:175685,interface,interface,175685,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"uild LLVM (e.g. `cmake` or `gn`). **--cflags**. Print the C compiler flags needed to use LLVM headers. **--cmakedir**. Print the installation directory for LLVM CMake modules. **--components**. Print all valid component names. **--cppflags**. Print the C preprocessor flags needed to use LLVM headers. **--cxxflags**. Print the C++ compiler flags needed to use LLVM headers. **--has-rtti**. Print whether or not LLVM was built with rtti (YES or NO). **--help**. Print a summary of **llvm-config** arguments. **--host-target**. Print the target triple used to configure LLVM. **--ignore-libllvm**. Ignore libLLVM and link component libraries instead. **--includedir**. Print the installation directory for LLVM headers. **--ldflags**. Print the flags needed to link against LLVM libraries. **--libdir**. Print the installation directory for LLVM libraries. **--libfiles**. Similar to **--libs**, but print the full path to each library file. This is; useful when creating makefile dependencies, to ensure that a tool is relinked if; any library it uses changes. **--libnames**. Similar to **--libs**, but prints the bare filenames of the libraries; without **-l** or pathnames. Useful for linking against a not-yet-installed; copy of LLVM. **--libs**. Print all the libraries needed to link against the specified LLVM; *components*, including any dependencies. **--link-shared**. Link the components as shared libraries. **--link-static**. Link the component libraries statically. **--obj-root**. Print the object root used to build LLVM. **--prefix**. Print the installation prefix for LLVM. **--shared-mode**. Print how the provided components can be collectively linked (`shared` or `static`). **--system-libs**. Print all the system libraries needed to link against the specified LLVM; *components*, including any dependencies. **--targets-built**. Print the component names for all targets supported by this copy of LLVM. **--version**. Print the version number of LLVM. COMPONENTS; ----------. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst:1906,depend,dependencies,1906,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,1,['depend'],['dependencies']
Integrability,"uild; % cd gcc-${gcc_version}-build; % $PWD/../gcc-${gcc_version}/configure --prefix=$HOME/toolchains --enable-languages=c,c++; % make -j$(nproc); % make install. For more details, check out the excellent `GCC wiki entry`_, where I got most; of this information from. .. _GCC wiki entry:; https://gcc.gnu.org/wiki/InstallingGCC. Once you have a GCC toolchain, configure your build of LLVM to use the new; toolchain for your host compiler and C++ standard library. Because the new; version of libstdc++ is not on the system library search path, you need to pass; extra linker flags so that it can be found at link time (``-L``) and at runtime; (``-rpath``). If you are using CMake, this invocation should produce working; binaries:. .. code-block:: console. % mkdir build; % cd build; % CC=$HOME/toolchains/bin/gcc CXX=$HOME/toolchains/bin/g++ \; cmake .. -DCMAKE_CXX_LINK_FLAGS=""-Wl,-rpath,$HOME/toolchains/lib64 -L$HOME/toolchains/lib64"". If you fail to set rpath, most LLVM binaries will fail on startup with a message; from the loader similar to ``libstdc++.so.6: version `GLIBCXX_3.4.20' not; found``. This means you need to tweak the -rpath linker flag. This method will add an absolute path to the rpath of all executables. That's; fine for local development. If you want to distribute the binaries you build; so that they can run on older systems, copy ``libstdc++.so.6`` into the; ``lib/`` directory. All of LLVM's shipping binaries have an rpath pointing at; ``$ORIGIN/../lib``, so they will find ``libstdc++.so.6`` there. Non-distributed; binaries don't have an rpath set and won't find ``libstdc++.so.6``. Pass; ``-DLLVM_LOCAL_RPATH=""$HOME/toolchains/lib64""`` to cmake to add an absolute; path to ``libstdc++.so.6`` as above. Since these binaries are not distributed,; having an absolute local path is fine for them. When you build Clang, you will need to give *it* access to modern C++; standard library in order to use it as your new host in part of a bootstrap.; There are two easy ways",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:18615,message,message,18615,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['message'],['message']
Integrability,"uint NPar()`.; Example of creating a parametric function:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricFunction: public ROOT::Math::IParametricFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricFunctionMultiDim* Clone() const; {; return new MyParametricFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }; };; ```. * **`ROOT::Math::IParametricGradFunctionMultiDim`**:; Provides an interface for parametric gradient multi-dimensional functions. In addition to function evaluation it provides the gradient with respect to the parameters,; via the method `ParameterGradient()`. This interface is only used in case of some dedicated fitting algorithms, when is required or more efficient to provide derivatives with respect to the; parameters. Here is an example:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:41017,interface,interface,41017,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"uisite: the executable directive must not be standalone directive.; If it is, it will never match. Given. #pragma omp parallel; ;; #pragma omp parallel; {}. ``ompExecutableDirective(hasStructuredBlock(nullStmt()))`` will match ``;``. Matcher<ObjCInterfaceDecl>isDerivedFromMatcher<NamedDecl> Base; Matches C++ classes that are directly or indirectly derived from a class; matching Base, or Objective-C classes that directly or indirectly; subclass a class matching Base. Note that a class is not considered to be derived from itself. Example matches Y, Z, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. In the following example, Bar matches isDerivedFrom(hasName(""NSObject"")); @interface NSObject @end; @interface Bar : NSObject @end. Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>. Matcher<ObjCInterfaceDecl>isDirectlyDerivedFromMatcher<NamedDecl> Base; Matches C++ or Objective-C classes that are directly derived from a class; matching Base. Note that a class is not considered to be derived from itself. Example matches Y, C (Base == hasName(""X"")); class X;; class Y : public X {}; // directly derived; class Z : public Y {}; // indirectly derived; typedef X A;; typedef A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<ObjCInterfaceDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's cal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:219225,interface,interface,219225,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['interface'],['interface']
Integrability,"uivalency). We do not import, however, the whole; redeclaration chain as we do in case of functions. Up till now, we haven't; found any essential property of forward declarations which is similar to the; case of the virtual flag in a member function prototype. In the future, this; may change, though. Traversal during the Import; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. The node specific import mechanisms are implemented in; ``ASTNodeImporter::VisitNode()`` functions, e.g. ``VisitFunctionDecl()``.; When we import a declaration then first we import everything which is needed to; call the constructor of that declaration node. Everything which can be set; later is set after the node is created. For example, in case of a; ``FunctionDecl`` we first import the declaration context in which the function; is declared, then we create the ``FunctionDecl`` and only then we import the; body of the function. This means there are implicit dependencies between AST; nodes. These dependencies determine the order in which we visit nodes in the; ""from"" context. As with the regular graph traversal algorithms like DFS, we; keep track which nodes we have already visited in; ``ASTImporter::ImportedDecls``. Whenever we create a node then we immediately; add that to the ``ImportedDecls``. We must not start the import of any other; declarations before we keep track of the newly created one. This is essential,; otherwise, we would not be able to handle circular dependencies. To enforce; this, we wrap all constructor calls of all AST nodes in; ``GetImportedOrCreateDecl()``. This wrapper ensures that all newly created; declarations are immediately marked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDecl()`` there is still a; probability of having an infinite import recursion",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:98487,depend,dependencies,98487,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependencies']
Integrability,"ulateErrors No False − Calculates inverse Hessian matrix at the end of the training to be able to calculate the uncertainties of an MVA value. WeightRange No 1 − Take the events for the estimator calculations from small deviations from the desired value to large deviations only over the weight range. Configuration options for MVA method :. Configuration options reference for MVA method: Cuts. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). FitMethod No GA GA, SA, MC, MCEvents, MINUIT, EventScan Minimisation Method (GA, SA, and MC are the primary methods to be used; the others have been introduced for testing purposes and are depreciated). EffMethod No EffSel EffSel, EffPDF Selection Method. CutRangeMin Yes -1 − Minimum of allowed cut range (set per variable). CutRangeMax Yes -1 − Maximum of allowed cut range (set per variable). VarProp Yes NotEnforced NotEnforced, FMax, FMin, FSmart Categorisation of cuts. Configuration options for MVA method :. Configuration options reference for MVA method: PDEFoam. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLev",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:24906,message,message,24906,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['message'],['message']
Integrability,"uld be implemented by one or more ``.cpp`` files. Each; of these ``.cpp`` files should include the header that defines their interface; first. This ensures that all of the dependences of the header have been; properly added to the header itself, and are not implicit. System headers; should be included after user headers for a translation unit. Library Layering; ^^^^^^^^^^^^^^^^. A directory of header files (for example ``include/llvm/Foo``) defines a; library (``Foo``). One library (both; its headers and implementation) should only use things from the libraries; listed in its dependencies. Some of this constraint can be enforced by classic Unix linkers (Mac & Windows; linkers, as well as lld, do not enforce this constraint). A Unix linker; searches left to right through the libraries specified on its command line and; never revisits a library. In this way, no circular dependencies between; libraries can exist. This doesn't fully enforce all inter-library dependencies, and importantly; doesn't enforce header file circular dependencies created by inline functions.; A good way to answer the ""is this layered correctly"" would be to consider; whether a Unix linker would succeed at linking the program if all inline; functions were defined out-of-line. (& for all valid orderings of dependencies; - since linking resolution is linear, it's possible that some implicit; dependencies can sneak through: A depends on B and C, so valid orderings are; ""C B A"" or ""B C A"", in both cases the explicit dependencies come before their; use. But in the first case, B could still link successfully if it implicitly; depended on C, or the opposite in the second case). .. _minimal list of #includes:. ``#include`` as Little as Possible; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``#include`` hurts compile time performance. Don't do it unless you have to,; especially in header files. But wait! Sometimes you need to have the definition of a class to use it, or to; inherit from it. In these cases go ahead a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:31060,depend,dependencies,31060,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,2,['depend'],['dependencies']
Integrability,"ule will still conflict with a struct of the same name declared in a different module, just as they would if declared in two different headers. This aspect is important for backward compatibility, because (for example) the mangled names of entities in software libraries must not change when introducing modules. * **Binary distribution of modules**: Headers (particularly C++ headers) expose the full complexity of the language. Maintaining a stable binary module format across architectures, compiler versions, and compiler vendors is technically infeasible. Using Modules; =============; To enable modules, pass the command-line flag ``-fmodules``. This will make any modules-enabled software libraries available as modules as well as introducing any modules-specific syntax. Additional `command-line parameters`_ are described in a separate section later. Standard C++ Modules; --------------------; .. note::; Modules are adopted into C++20 Standard. And its semantic and command line interface are very different from the Clang C++ modules. See `StandardCPlusPlusModules <StandardCPlusPlusModules.html>`_ for details. Objective-C Import declaration; ------------------------------; Objective-C provides syntax for importing a module via an *@import declaration*, which imports the named module:. .. parsed-literal::. @import std;. The ``@import`` declaration above imports the entire contents of the ``std`` module (which would contain, e.g., the entire C or C++ standard library) and make its API available within the current translation unit. To import only part of a module, one may use dot syntax to specific a particular submodule, e.g.,. .. parsed-literal::. @import std.io;. Redundant import declarations are ignored, and one is free to import modules at any point within the translation unit, so long as the import declaration is at global scope. At present, there is no C or C++ syntax for import declarations. Clang; will track the modules proposal in the C++ committee. See the sectio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:8067,interface,interface,8067,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['interface'],['interface']
Integrability,"uled for May 29, 2012. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU/ATLAS, RooStats,; Sven Kreiss, NYU/ATLAS, RooStats,; Gena Kukartsev, CERN and FNAL/CMS, ; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Christian Gumpert, CERN and University Dresden/ATLAS, Math,; Wim Lavrijsen, LBNL, PyRoot,; Sergei Linev, GSI,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Eddy Offermann, Renaissance, ; Giovanni Petrucciani, UCSD/CMS, RooStats, ; Fons Rademakers, CERN/SFT,; Paul Russo, FNAL, ; Joerg Stelzer, DESY/Atlas, TMVA, ; Alja Tadel, UCSD/CMS, Eve, ; Matevz Tadel, UCSD/CMS, Eve, ; Eckhard von Toerne, University Bonn, ATLAS, TMVA, ; Wouter Verkerke, NIKHEF/Atlas, RooFit, ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v532/index.html:1266,protocol,protocols,1266,doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v532/index.html,3,"['interface', 'protocol']","['interfaces', 'protocols']"
Integrability,"ull; ); string(REGEX MATCH ""Xcode ([0-9][0-9]?([.][0-9])+)"" version_match ${xcodebuild_version}); if(version_match); message(STATUS ""Identified Xcode Version: ${CMAKE_MATCH_1}""); set(XCODE_VERSION ${CMAKE_MATCH_1}); else(); # If detecting Xcode version failed, set a crazy high version so we default; # to the newest.; set(XCODE_VERSION 99); message(WARNING ""Failed to detect the version of an installed copy of Xcode, falling back to highest supported version. Set XCODE_VERSION to override.""); endif(); endif(). # Xcode 8 requires CompatibilityVersion 2; set(COMPAT_VERSION 2); if(XCODE_VERSION VERSION_LESS 8.0.0); # Xcode 7.3 (the first version supporting external toolchains) requires; # CompatibilityVersion 1; set(COMPAT_VERSION 1); endif(). execute_process(; COMMAND xcrun -find otool; OUTPUT_VARIABLE clang_path; OUTPUT_STRIP_TRAILING_WHITESPACE; ERROR_FILE /dev/null; ); string(REGEX MATCH ""(.*/Toolchains)/.*"" toolchains_match ${clang_path}); if(NOT toolchains_match); message(FATAL_ERROR ""Could not identify toolchain dir""); endif(); set(toolchains_dir ${CMAKE_MATCH_1}). set(LLVMToolchainDir ""${CMAKE_INSTALL_PREFIX}/Toolchains/LLVM${PACKAGE_VERSION}.xctoolchain/""). add_custom_command(OUTPUT ${LLVMToolchainDir}; COMMAND ${CMAKE_COMMAND} -E make_directory ${LLVMToolchainDir}). add_custom_command(OUTPUT ${LLVMToolchainDir}/Info.plist; DEPENDS ${LLVMToolchainDir}; COMMAND ${CMAKE_COMMAND} -E remove ${LLVMToolchainDir}/Info.plist; COMMAND /usr/libexec/PlistBuddy -c ""Add:CFBundleIdentifier string org.llvm.${PACKAGE_VERSION}"" ""${LLVMToolchainDir}/Info.plist""; COMMAND /usr/libexec/PlistBuddy -c ""Add:CompatibilityVersion integer ${COMPAT_VERSION}"" ""${LLVMToolchainDir}/Info.plist""; ). add_custom_target(build-xcode-toolchain; COMMAND ""${CMAKE_COMMAND}"" --build ${CMAKE_BINARY_DIR} --target all); add_llvm_install_targets(install-xcode-toolchain; DEPENDS ${LLVMToolchainDir}/Info.plist build-xcode-toolchain; PREFIX ${LLVMToolchainDir}/usr/). if(LLVM_DISTRIBUTION_COMPONENTS); if(LLVM_EN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt:3073,message,message,3073,interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,1,['message'],['message']
Integrability,"ull; cd ../../projects/libcxx; git pull. To create a new branch::. git checkout -b MyBranch; cd tools/clang; git checkout -b MyBranch; cd ../../projects/libcxx; git checkout -b MyBranch. To switch branches::. git checkout AnotherBranch; cd tools/clang; git checkout AnotherBranch; cd ../../projects/libcxx; git checkout AnotherBranch. .. _workflow-mono-branching:. Monorepo Variant; ^^^^^^^^^^^^^^^^. Regular Git commands are sufficient, because everything is in a single; repository:. To update the repository to tip of trunk::. git pull. To create a new branch::. git checkout -b MyBranch. To switch branches::. git checkout AnotherBranch. Bisecting; ---------. Assuming a developer is looking for a bug in clang (or lld, or lldb, ...). Currently; ^^^^^^^^^. SVN does not have builtin bisection support, but the single revision across; sub-projects makes it possible to script around. Using the existing Git read-only view of the repositories, it is possible to use; the native Git bisection script over the llvm repository, and use some scripting; to synchronize the clang repository to match the llvm revision. .. _workflow-mono-bisecting:. Monorepo Variant; ^^^^^^^^^^^^^^^^. Bisecting on the monorepo is straightforward, and very similar to the above,; except that the bisection script does not need to include the; `git submodule update` step. The same example, finding which commit introduces a regression where clang-3.9; crashes but not clang-3.8 passes, will look like::. git bisect start releases/3.9.x releases/3.8.x; git bisect run ./bisect_script.sh. With the `bisect_script.sh` script being::. #!/bin/sh; cd $BUILD_DIR. ninja clang || exit 125 # an exit code of 125 asks ""git bisect""; # to ""skip"" the current commit. ./bin/clang some_crash_test.cpp. Also, since the monorepo handles commits update across multiple projects, you're; less like to encounter a build failure where a commit change an API in LLVM and; another later one ""fixes"" the build in clang. Moving Local Branches to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:19105,synchroniz,synchronize,19105,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['synchroniz'],['synchronize']
Integrability,"ult all such opcodes are filtered out.; This flag will instead show only such unstable opcodes. .. option:: --ignore-invalid-sched-class=false. If set, ignore instructions that do not have a sched class (class idx = 0). .. option:: --mtriple=<triple name>. Target triple. See `-version` for available targets. .. option:: --mcpu=<cpu name>. If set, measure the cpu characteristics using the counters for this CPU. This; is useful when creating new sched models (the host CPU is unknown to LLVM).; (`-mcpu=help` for details). .. option:: --analysis-override-benchmark-triple-and-cpu. By default, llvm-exegesis will analyze the benchmarks for the triple/CPU they; were measured for, but if you want to analyze them for some other combination; (specified via `-mtriple`/`-mcpu`), you can pass this flag. .. option:: --dump-object-to-disk=true. If set, llvm-exegesis will dump the generated code to a temporary file to; enable code inspection. Disabled by default. .. option:: --use-dummy-perf-counters. If set, llvm-exegesis will not read any real performance counters and; return a dummy value instead. This can be used to ensure a snippet doesn't; crash when hardware performance counters are unavailable and for; debugging :program:`llvm-exegesis` itself. .. option:: --execution-mode=[inprocess,subprocess]. This option specifies what execution mode to use. The `inprocess` execution; mode is the default. The `subprocess` execution mode allows for additional; features such as memory annotations but is currently restricted to X86-64; on Linux. .. option:: --benchmark-repeat-count=<repeat-count>. This option enables specifying the number of times to repeat the measurement; when performing latency measurements. By default, llvm-exegesis will repeat; a latency measurement enough times to balance run-time and noise reduction. EXIT STATUS; -----------. :program:`llvm-exegesis` returns 0 on success. Otherwise, an error message is; printed to standard error, and the tool returns a non 0 value.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:18481,message,message,18481,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['message'],['message']
Integrability,"ult is; returned but directly the base class HypoTestResult which; has been improved for this release.; The plot class, HybridPlot is not returned, but; the user can create an HypoTestPlot object from the; HypoTestResult.; The classes HybridResult and HybridPlot work only; with the HybridCalculatorOriginal and remain for maintaining; a backward compatibility. ; Given a ModelConfig, the tool will attempt to form the posterior pdf ; for the nuisance parameters based on the prior and the constraint terms ; in the pdf. However, this is not yet implemented. In order to keep; logical consistency with other tools, the distribution being used; to smear the nuisance parameters should NOT be considered the prior in ; the model config. Instead, one should use HybridCalculator's; ForcePriorNuisanceNull and ForcePriorNuisanceAlt. HybridCalculatorOriginal. Apply a fix for test statistic = 3 (profile likelihood); Apply a fix for using non-extended pdf. TestStatSampler and TestStatistics. Cleanup of the interfaces.; TestStatistics now have a method PValueIsRightTail to specify the sign conventions for the test statistic. This is used when making plots and calculating p-values.; make clear that TestStatistic::Evaluate should take data and values of the parameters that define the null.; Add method TestStatSampler::SetParametersForTestStat that ; allows for greater control of parameters used for generating toy data; and parameters used for evaluating the test statistic.; ProfileLikelihoodTestStatUsing the raw profile likelihood while reviewing the old algorithm used to provide robustness in situations with local minima.; New test statistic classes:; ; SimpleLikelihoodRatioTestStat : log L_1 / L_0; RatioOfProfiledLikelihoodsTestStat: log L(mu_1, hat(nu_1))/L(mu_0,hat(nu_0)); MaxLikelihoodEstimateTestStat: the MLE of a specified parameter. ToyMCSampler. New version of ToyMCSampler which can smear the nuisance; parameters according to their distributions for use with; HybridCalculator; Up",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:6470,interface,interfaces,6470,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,1,['interface'],['interfaces']
Integrability,"ulti-process by using MPI. A new class MPIProcess deals with starting and terminating the MPI process. Each process calculates independently the derivatives for a given set of parameters.; A Minuit2 library with MPI support can be built by defining before compilation the environment variables USE_PARALLEL_MINUIT2 and USE_MPI. Unuran; Add constructor of Tunuran distributions using function objects defined using the mathcore interfaces:. TUnuranContDist (const ROOT::Math::IGenFunction & pdf, const ROOT::Math::IGenFunction * dpdf, bool isLogPdf);; TUnuranMultiContDist (const ROOT::Math::IMultiGenFunction & pdf, bool isLogPdf );; TUnuranDiscrDist (const ROOT::Math::IGenFunction & func );. TRolke; New version of TRolke from J. Lundberg. The interface of the class has been changed. The old user interface was very hard to use, and the documentation in the source was also not on par with the correct usage. The old interface was a single get-function with 12 arguments, and the user was supposed to figure out which ~ 5 arguments were relevant for a specific model (1 out of 7 models).; ; The new user interface is is easy to use correctly and hard to use incorrectly (TM). It's a single set-method for each method:. SetPoissonBkgBinomialEff(Int_t x,Int_t y,Int_t z,Double_t tau,Int_t m);; SetPoissonBkgGaussianEff(Int_t x,Int_t y,Double_t em, Double_t tau,Double_t sde);; SetGaussianBkgGaussianEff(Int_t x,Double_t bm,Double_t em, Double_t sde,Double_t sdb);; SetPoissondBkgknownEff(Int_t x,Int_t y,Double_t tau,Double_t e);; SetGaussianBkgknownEff(Int_t x,Double_t bm,Double_t sdb,Double_t e);; SetKnownBkgBinomialEff(Int_t x, Int_t z,Int_t m,Double_t b);; SetknownBkgGaussianEff(Int_t x,Double_t em,Double_t sde,Double_t b);. New methods for getting sensitivity (average limits) and related quantities and for critical number related to rejection of the null-hypothesis (no signal).; Some small Bug fixes. Some variables were used uninitialized. (Eg, input arguments which were not supposed to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:8453,interface,interface,8453,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,1,['interface'],['interface']
Integrability,"ulti-variate Gaussian distribution. A complete example is provided in a new tutorial macro rf610_visualerror.C,; the output of which is shown below. It is also possible to visualize partial errors (from a subset of the parameters),; as shown above. Binned dataset generation. A new method RooAbsPdf::generateBinned() has been implemented; that samples binned datasets (RooDataHist) from any; p.d.f. RooDataHist* data = pdf.generateBinned(x,10000) ;. This binned generation interface samples the p.d.f. at each bin; center and applies a Poisson fluctuation to each sampled value.; The binning of the returned RooDataHist is controlled by the default; binning associated with the observables generated. To set the number; of bins in x to 200, do e.g. x.setBins(200) prior to the call; to generateBinned(). The binned dataset generation method does not (yet) support the concept of; prototype datasets. New minimizer interface to Minuit2, GSLMinimizer etc... A new minimizer interface, RooMinimizer has been added (contribution; from Alfio Lazarro). The new minimizer is similar in functionality to; the existing class RooMinuit, but supports the new ROOT abstract; minimizer interface and supports multiple minimizer packages and algorithms; through that interface. The present interface of RooMinimizer is identical to that of RooMinuit; with two extensions. The setMinimizer(const char*) method allows to choose between ""minuit"" and ""minuit2""); as implementation for migrad(),hesse(),minos() etc...; The minimizer(const char* package, const char* alg) provides a completely generic interface; to all minimizers, where package is the package (minuit,GSLminimizer) and alg is the algorithm (migrad) to be used. By default, RooMinuit is still used when RooAbsPdf::fitTo() is called, but can be overridden with; a Minimizer() named argument. // Minimization with MINUIT/MIGRAD through RooMinuit; pdf->fitTo(data) ;. // Minimization with MINUIT/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minui",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:3101,interface,interface,3101,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['interface'],['interface']
Integrability,"um class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerType(); matches ""A::* ptr"". Matcher<Type>objcObjectPointerTypeMatcher<ObjCObjectPointerType>...; Matches an Objective-C o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48889,inject,injectedClassNameType,48889,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['inject'],['injectedClassNameType']
Integrability,"umann, CERN/SFT,\; Danilo Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Oksana Shadura, UNL,\; Saurav Shekhar, GSOC 2017,\; Xavier Valls Pla, UJI, CERN/SFT,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/Atlas, RooFit,\; Stefan Wunsch, CERN/SFT, \; Zhe Zhang, UNL. ## Important Notice. The default compression algorithm used when writing ROOT files has been updated to use LZ4 in particular to improve read (decompression) performance. You can change this default for each file through (for example) the `TFile constructor` or `TFile::SetCompressionAlgorithm`. It should be noted that ROOT files written with LZ4 compression can not be read with older release of ROOT. Support for LZ4 was however back-ported to the patch branches of previous releases and the following tags (and later release in the same patch series) can read ROOT files written with LZ4 compression:. * v5.34/38; * v6.08/06 [not yet released]; * v6.10/08; * v6.12/02. ## Removed interfaces. ## Core Libraries; - Optimize away redundant deserialization of template specializations. This reduces the memory footprint for hsimple by around 30% while improving the runtime performance for various cases by around 15%.; - When ROOT is signaled with a SIGUSR2 (i.e. on Linux and MacOS X) it will now print a backtrace.; - Move RStringView.h to ROOT/RStringView.hxx and always include ROOT/RStringView.hxx instead of RStringView.h for backward compatibility; - In `TClingCallFunc`, support r-value reference parameters. This paves the way for the corresponding support in PyROOT (implemented now in the latest Cppyy).; - Included the new TSequentialExecutor in ROOT, sharing the interfaces of TExecutor.This should improve code economy when providing a fallback for TThreadExecutor/TProcessExecutor. ### Thread safety; - Resolved several race conditions, dead-locks, performance and order of initialization/destruction issues still lingering because of or despite the new read-write loc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:1708,interface,interfaces,1708,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['interface'],['interfaces']
Integrability,"umber`` from; scalar literal expressions; *Collection Literals* provide a short-hand; for creating arrays and dictionaries; *Object Subscripting* provides a; way to use subscripting with Objective-C objects. Users of Apple; compiler releases can use these features starting with the Apple LLVM; Compiler 4.0. Users of open-source LLVM.org compiler releases can use; these features starting with clang v3.1. These language additions simplify common Objective-C programming; patterns, make programs more concise, and improve the safety of; container creation. This document describes how the features are implemented in clang, and; how to use them in your own programs. NSNumber Literals; =================. The framework class ``NSNumber`` is used to wrap scalar values inside; objects: signed and unsigned integers (``char``, ``short``, ``int``,; ``long``, ``long long``), floating point numbers (``float``,; ``double``), and boolean values (``BOOL``, C++ ``bool``). Scalar values; wrapped in objects are also known as *boxed* values. In Objective-C, any character, numeric or boolean literal prefixed with; the ``'@'`` character will evaluate to a pointer to an ``NSNumber``; object initialized with that value. C's type suffixes may be used to; control the size of numeric literals. Examples; --------. The following program illustrates the rules for ``NSNumber`` literals:. .. code-block:: objc. void main(int argc, const char *argv[]) {; // character literals.; NSNumber *theLetterZ = @'Z'; // equivalent to [NSNumber numberWithChar:'Z']. // integral literals.; NSNumber *fortyTwo = @42; // equivalent to [NSNumber numberWithInt:42]; NSNumber *fortyTwoUnsigned = @42U; // equivalent to [NSNumber numberWithUnsignedInt:42U]; NSNumber *fortyTwoLong = @42L; // equivalent to [NSNumber numberWithLong:42L]; NSNumber *fortyTwoLongLong = @42LL; // equivalent to [NSNumber numberWithLongLong:42LL]. // floating point literals.; NSNumber *piFloat = @3.141592654F; // equivalent to [NSNumber numberWithFlo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:1196,wrap,wrapped,1196,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['wrap'],['wrapped']
Integrability,umeration used as enumerator value; Unknown. 1766; CD4; Values outside the range of the values of an enumeration; Unknown. 1767; C++14; Scoped enumeration in a switch statement; Unknown. 1768; NAD; Zero-element array of runtime bound; Unknown. 1769; C++14; Catching a base class of the exception object; Unknown. 1770; C++14; Type matching of non-type template parameters and arguments; Unknown. 1771; CD6; Restricted lookup in nested-name-specifier; Unknown. 1772; C++14; __func__ in a lambda body; Clang 14. 1773; C++14; Out-of-lifetime lvalue-to-rvalue conversion; Unknown. 1774; CD4; Discrepancy between subobject destruction and stack unwinding; Unknown. 1775; C++14; Undefined behavior of line splice in raw string literal; Unknown. 1776; CD4; Replacement of class objects containing reference members; Unknown. 1777; CD4; Empty pack expansion in dynamic-exception-specification; Unknown. 1778; C++14; exception-specification in explicitly-defaulted functions; Clang 9. 1779; CD4; Type dependency of __func__; Clang 14. 1780; CD4; Explicit instantiation/specialization of generic lambda operator(); Unknown. 1781; CD5; Converting from nullptr_t to bool in overload resolution; Unknown. 1782; CD4; Form of initialization for nullptr_t to bool conversion; Unknown. 1783; NAD; Why are virtual destructors non-trivial?; Unknown. 1784; C++17; Concurrent execution during static local initialization; Unknown. 1785; NAD; Conflicting diagnostic requirements for template definitions; Unknown. 1786; C++14; Effect of merging allocations on memory leakage; Unknown. 1787; C++14; Uninitialized unsigned char values; Unknown. 1788; CD4; Sized deallocation of array of non-class type; Unknown. 1789; open; Array reference vs array decay in overload resolution; Not resolved. 1790; open; Ellipsis following function parameter pack; Not resolved. 1791; CD4; Incorrect restrictions on cv-qualifier-seq and ref-qualifier; Unknown. 1792; NAD; Incorrect example of explicit specialization of member enumeration; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:120675,depend,dependency,120675,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependency']
Integrability,"un:. ::. gh pr create. When prompted select to create and use your own fork and follow; the instructions to add more information needed. .. note::. When you let the GitHub CLI create a fork of llvm-project to; your user, it will change the git ""remotes"" so that ""origin"" points; to your fork and ""upstream"" points to the main llvm-project repository. Updating Pull Requests; ----------------------; In order to update your pull request, the only thing you need to do is to push; your new commits to the branch in your fork. That will automatically update; the pull request. When updating a pull request, you should push additional ""fix up"" commits to; your branch instead of force pushing. This makes it easier for GitHub to; track the context of previous review comments. Consider using the; `built-in support for fixups <https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---fixupamendrewordltcommitgt>`_; in git. If you do this, you must squash and merge before landing the PR and; you must use the pull request title and description as the commit message.; You can do this manually with an interactive git rebase or with GitHub's; built-in tool. See the section about landing your fix below. When pushing to your branch, make sure you push to the correct fork. Check your; remotes with:. ::. git remote -v. And make sure you push to the remote that's pointing to your fork. Rebasing Pull Requests and Force Pushes; ---------------------------------------; In general, you should avoid rebasing a Pull Request and force pushing to the; branch that's the root of the Pull Request during the review. This action will; make the context of the old changes and comments harder to find and read. Sometimes, a rebase might be needed to update your branch with a fix for a test; or in some dependent code. After your PR is reviewed and accepted, you want to rebase your branch to ensure; you won't encounter merge conflicts when landing the PR. Landing your change; -------------------; When ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:3871,message,message,3871,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['message'],['message']
Integrability,"unction interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, implementing the pseudo-random number generators. A detailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides an advanced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probabili",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:2576,depend,depending,2576,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['depend'],['depending']
Integrability,"unction""; N/A. 106; CD1; Creating references to references during template deduction/instantiation; Superseded by 540. 107; NAD; Linkage of operator functions; Yes. 108; TC1; Are classes nested in templates dependent?; Clang 2.9. 109; NAD; Allowing ::template in using-declarations; Yes. 110; CD6; Can template functions and classes be declared in the same scope?; Unknown. 111; NAD; Copy constructors and cv-qualifiers; Duplicate of 535. 112; CD1; Array types and cv-qualifiers; Yes. 113; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions; Yes. 119; CD1; Object lifetime and aggregate initialization; N/A. 120; TC1; Nonexistent non-terminal qualified-name; N/A. 121; TC1; Dependent type names with non-dependent nested-name-specifiers; Yes. 122; CD1; template-ids as unqualified-ids; Yes. 123; TC1; Bad cross-reference; N/A. 124; CD1; Lifetime of temporaries in default initialization of class arrays; Duplicate of 201. 125; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:8755,depend,dependent,8755,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"unctionally equivalent to the one shown below.; Placing on Objective-C methods: With respect to Objective-C methods.,; this attribute is identical in its behavior and usage to 'ns_returns_retained'; except for the distinction of returning a Core Foundation object instead of a; Cocoa object. This distinction is important for the following reason:; as Core Foundation is a C API,; the analyzer cannot always tell that a pointer return value refers to a; Core Foundation object.; In contrast, it is; trivial for the analyzer to recognize if a pointer refers to a Cocoa object; (given the Objective-C type system). Placing on C functions: When placing the attribute; 'cf_returns_retained' on the declarations of C functions, the analyzer; interprets the function as:. Returning a Core Foundation Object; Treating the function as if it its name; contained the keywords ""create"" or ""copy"". This means the; returned object as a +1 retain count that must be released by the caller, either; by sending a release message (via toll-free bridging to an Objective-C; object pointer), or calling CFRelease or a similar function. Example. $ cat test.m; $ cat test.m; #import <Cocoa/Cocoa.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_RETAINED; #if __has_feature(attribute_cf_returns_retained); #define CF_RETURNS_RETAINED __attribute__((cf_returns_retained)); #else; #define CF_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSDate*) returnsCFRetained CF_RETURNS_RETAINED;; - (NSDate*) alsoReturnsRetained;; - (NSDate*) returnsNSRetained NS_RETURNS_RETAINED;; @end. CF_RETURNS_RETAINED; CFDateRef returnsRetainedCFDate() {; return CFDateCreate(0, CFAbsoluteTimeGetCurrent());; }. @implementation MyClass; - (NSDate*) returnsCFRetained {; return (NSDate*) returnsRetainedCFDate(); // No leak.; }. - (NSDate*) alsoReturnsRetained {; return (NSDate*) returnsRetainedCFDate(); // Always report a leak.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:7391,message,message,7391,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,2,"['bridg', 'message']","['bridging', 'message']"
Integrability,"und parameters and bound parameters. It could also affected Fumili2. Furthermore, a wrong sign for the correlation matrix could also have been obtained in some cases with bound parameters.; ; Use a tolerance of 0.01 instead of 0.05 in MnContours. The value of 0.01 is the same used in Minos. This is sufficient to get good quality contours.; Improve also the debug in MnContour. Add printing of points as info messages; Remove some un-necessary assert() when defining the minimization parameters.; Fix a bug in MnHesse to return the information if the matrix was made pos def. In addition change in MinimumError the condition that when the matrix was made pos def the status of the error is still considered valid and not invalid as before. This makes also the function minimum valid when a matrix was decleared pos def.; Improvements in the Minuit2Minimizer class:; . implement the new methods defined in the base class: Hess() using MnHess and CovMatrixStatus();; ; improve the switch-off of the info message according to the print level;; ; define the variables passed with zero step-size as constant (as is done in F77 Minuit); . Fix a problem in building the parallel version of Minuit2. The parallel version is built if the environment variables USE_PARALLEL_MINUIT2 and USE_OPENMP are set before compiling Minuit2 on a compiler which supports openMP (for example gcc version >= 4.2); ; Add, thanks to Alfio Lazzaro, support for running Minuit2 using multi-process by using MPI. A new class MPIProcess deals with starting and terminating the MPI process. Each process calculates independently the derivatives for a given set of parameters.; A Minuit2 library with MPI support can be built by defining before compilation the environment variables USE_PARALLEL_MINUIT2 and USE_MPI. Unuran; Add constructor of Tunuran distributions using function objects defined using the mathcore interfaces:. TUnuranContDist (const ROOT::Math::IGenFunction & pdf, const ROOT::Math::IGenFunction * dpdf, bool isLo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:7078,message,message,7078,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,1,['message'],['message']
Integrability,"und-to-keep-it-behind-option/; option(CLANG_FORCE_MATCHING_LIBCLANG_SOVERSION; ""Force the SOVERSION of libclang to be equal to CLANG_MAJOR"" ON). # Clang version information; set(CLANG_EXECUTABLE_VERSION; ""${CLANG_VERSION_MAJOR}"" CACHE STRING; ""Major version number that will be appended to the clang executable name""); set(LIBCLANG_LIBRARY_VERSION; ""${CLANG_VERSION_MAJOR}"" CACHE STRING; ""Major version number that will be appended to the libclang library""); mark_as_advanced(CLANG_EXECUTABLE_VERSION LIBCLANG_LIBRARY_VERSION). option(CLANG_INCLUDE_TESTS; ""Generate build targets for the Clang unit tests.""; ${LLVM_INCLUDE_TESTS}). option(CLANG_ENABLE_HLSL ""Include HLSL build products"" Off); # While HLSL support is experimental this should stay hidden.; mark_as_advanced(CLANG_ENABLE_HLSL). add_subdirectory(utils/TableGen). # Export CLANG_TABLEGEN_EXE for use by flang docs.; set(CLANG_TABLEGEN_EXE ""${CLANG_TABLEGEN_EXE}"" CACHE INTERNAL """"). add_subdirectory(include). # All targets below may depend on all tablegen'd files.; get_property(CLANG_TABLEGEN_TARGETS GLOBAL PROPERTY CLANG_TABLEGEN_TARGETS); add_custom_target(clang-tablegen-targets; DEPENDS; omp_gen; ClangDriverOptions; ${CLANG_TABLEGEN_TARGETS}); set_target_properties(clang-tablegen-targets PROPERTIES FOLDER ""Misc""); list(APPEND LLVM_COMMON_DEPENDS clang-tablegen-targets). # Force target to be built as soon as possible. Clang modules builds depend; # header-wise on it as they ship all headers from the umbrella folders. Building; # an entire module might include header, which depends on intrinsics_gen.; if(LLVM_ENABLE_MODULES); list(APPEND LLVM_COMMON_DEPENDS intrinsics_gen); endif(). add_subdirectory(lib); add_subdirectory(tools); add_subdirectory(runtime). option(CLANG_BUILD_EXAMPLES ""Build CLANG example programs by default."" OFF); add_subdirectory(examples). if(APPLE); # this line is needed as a cleanup to ensure that any CMakeCaches with the old; # default value get updated to the new default.; if(CLANG_ORDER_FILE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:17158,depend,depend,17158,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['depend'],['depend']
Integrability,"undamental ways. It was necessary to; do this to support expanding the attributes to encompass more than a handful of; attributes --- e.g. command line options. The old way of handling attributes; consisted of representing them as a bit mask of values. This bit mask was; stored in a ""list"" structure that was reference counted. The advantage of this; was that attributes could be manipulated with 'or's and 'and's. The; disadvantage of this was that there was limited room for expansion, and; virtually no support for attribute-value pairs other than alignment. In the new scheme, an ``Attribute`` object represents a single attribute that's; uniqued. You use the ``Attribute::get`` methods to create a new ``Attribute``; object. An attribute can be a single ""enum"" value (the enum being the; ``Attribute::AttrKind`` enum), a string representing a target-dependent; attribute, or an attribute-value pair. Some examples:. * Target-independent: ``noinline``, ``zext``; * Target-dependent: ``""no-sse""``, ``""thumb2""``; * Attribute-value pair: ``""cpu"" = ""cortex-a8""``, ``align = 4``. Note: for an attribute value pair, we expect a target-dependent attribute to; have a string for the value. ``Attribute``; =============; An ``Attribute`` object is designed to be passed around by value. Because attributes are no longer represented as a bit mask, you will need to; convert any code which does treat them as a bit mask to use the new query; methods on the Attribute class. ``AttributeList``; =================. The ``AttributeList`` stores a collection of Attribute objects for each kind of; object that may have an attribute associated with it: the function as a whole,; the return type, or the function's parameters. A function's attributes are at; index ``AttributeList::FunctionIndex``; the return type's attributes are at; index ``AttributeList::ReturnIndex``; and the function's parameters' attributes; are at indices 1, ..., n (where 'n' is the number of parameters). Most methods; on the ``Attribu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseAttributes.rst:1139,depend,dependent,1139,interpreter/llvm-project/llvm/docs/HowToUseAttributes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseAttributes.rst,1,['depend'],['dependent']
Integrability,"unlike the other ABI hint; attributes, the queue pointer may be required in situations where the; intrinsic call does not directly appear in the program. Some subtargets; require the queue pointer for to handle some addrspacecasts, as well; as the llvm.amdgcn.is.shared, llvm.amdgcn.is.private, llvm.trap, and; llvm.debug intrinsics. ""amdgpu-no-hostcall-ptr"" Similar to amdgpu-no-implicitarg-ptr, except specific to the implicit; kernel argument that holds the pointer to the hostcall buffer. If this; attribute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-no-heap-ptr"" Similar to amdgpu-no-implicitarg-ptr, except specific to the implicit; kernel argument that holds the pointer to an initialized memory buffer; that conforms to the requirements of the malloc/free device library V1; version implementation. If this attribute is absent, then the; amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-no-multigrid-sync-arg"" Similar to amdgpu-no-implicitarg-ptr, except specific to the implicit; kernel argument that holds the multigrid synchronization pointer. If this; attribute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-no-default-queue"" Similar to amdgpu-no-implicitarg-ptr, except specific to the implicit; kernel argument that holds the default queue pointer. If this; attribute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-no-completion-action"" Similar to amdgpu-no-implicitarg-ptr, except specific to the implicit; kernel argument that holds the completion action pointer. If this; attribute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-lds-size""=""min[,max]"" Min is the minimum number of bytes that will be allocated in the Local; Data Store at address zero. Variables are allocated within this frame; using absolute symbol metadata, primarily by the AMDGPULowerModuleLDS; pass. Optional max is the maximum number of bytes that will be allocated.; Note that min==max indicates that no fur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:50764,synchroniz,synchronization,50764,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"unsafe; dependencies into their own loop. This metadata can be used to selectively enable or disable distribution of the; loop. The first operand is the string ``llvm.loop.distribute.enable`` and the; second operand is a bit. If the bit operand value is 1 distribution is; enabled. A value of 0 disables distribution:. .. code-block:: llvm. !0 = !{!""llvm.loop.distribute.enable"", i1 0}; !1 = !{!""llvm.loop.distribute.enable"", i1 1}. This metadata should be used in conjunction with ``llvm.loop`` loop; identification metadata. '``llvm.loop.distribute.followup_coincident``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes extracted loops with no cyclic; dependencies will have (i.e. can be vectorized). See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_sequential``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata defines which attributes the isolated loops with unsafe; memory dependencies will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_fallback``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If loop versioning is necessary, this metadata defined the attributes; the non-distributed fallback version will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The attributes in this metadata is added to all followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.licm.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:308827,depend,dependencies,308827,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependencies']
Integrability,unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initialization example; Unknown. 1188; C++11; Type punning in constant expressions; Unknown. 1189; C++11; Address of distinct base class subobjects; Unknown. 1190; C++11; Operations on non-safely-derived pointers; Unknown. 1191; C++11; Deleted subobject destructors and implicitly-defined constructors; Unknown. 1192; C++11; Inadvertent change to ODR and templates; Unknown. 1193; C++11; Use of address-constant pointers in constant expressions; Unknown. 1194; C++11; Constexpr references; Unknown. 1195; C++11; References to non-literal types in constexpr functions; Unknown. 1196; C++11; Definition required for explicit instantiation after explicit specialization?; Unknown. 1197; C++11; Constexpr arrays; Unknown. 1198; C++11; Literal types and copy constructors; Unknown. 1199; C++11; Deleted constexpr functions; Unknown. 1200; CD6; Lookup rules for template parameters; N/A. 1201; C++11; Are deleted and defaulted functions def,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78911,depend,dependent,78911,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"upport dynamic loading of code from various sources. Already; mentioned above was the example of loading java bytecodes, but we want; to support dynamic loading of VM code as well. This makes the job of; the runtime compiler much more interesting: it can do interprocedural; optimizations that the static compiler can't do, because it doesn't; have all of the required information (for example, inlining from; shared libraries, etc...). 6. Define a set of generally useful annotations to add to the VM; representation. For example, a function can be analysed to see if it; has any sideeffects when run... also, the MOD/REF sets could be; calculated, etc... we would have to determine what is reasonable. This; would generally be used to make IP optimizations cheaper for the; runtime compiler... > o Explicit instructions to handle aliasing, e.g.s:; > -- an instruction to say ""I speculate that these two values are not; > aliased, but check at runtime"", like speculative execution in; > EPIC?; > -- or an instruction to check whether two values are aliased and; > execute different code depending on the answer, somewhat like; > predicated code in EPIC. These are also very good points... if this can be determined at compile; time. I think that an epic style of representation (not the instruction; packing, just the information presented) could be a very interesting model; to use... more later... > o (This one is a difficult but powerful idea.); > A ""thread-id"" field on every instruction that allows the static; > compiler to generate a set of parallel threads, and then have; > the runtime compiler and hardware do what they please with it.; > This has very powerful uses, but thread-id on every instruction; > is expensive in terms of instruction size and code size.; > We would need to compactly encode it somehow. Yes yes yes! :) I think it would be *VERY* useful to include this kind; of information (which EPIC architectures *implicitly* encode. The trend; that we are seeing supports thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:6655,depend,depending,6655,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['depend'],['depending']
Integrability,"ure illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunctionOneDim`:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; doubl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:35101,interface,interface,35101,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"ures that there is at most one split per region. At a high level, ""bifurcation mode"" allows for increased semantic coverage in; cases where the parent method contains code which is only executed when the; class is subclassed. The disadvantages of this mode are a (considerable?); performance hit and the possibility of false positives on the path where the; conservative mode is used. Objective-C Message Heuristics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ExprEngine relies on a set of heuristics to partition the set of Objective-C; method calls into those that require bifurcation and those that do not. Below; are the cases when the DynamicTypeInfo of the object is considered precise; (cannot be a subclass):. - If the object was created with +alloc or +new and initialized with an -init; method. - If the calls are property accesses using dot syntax. This is based on the; assumption that children rarely override properties, or do so in an; essentially compatible way. - If the class interface is declared inside the main source file. In this case; it is unlikely that it will be subclassed. - If the method is not declared outside of main source file, either by the; receiver's class or by any superclasses. C++ Caveats; ^^^^^^^^^^^. C++11 [class.cdtor]p4 describes how the vtable of an object is modified as it is; being constructed or destructed; that is, the type of the object depends on; which base constructors have been completed. This is tracked using; DynamicTypeInfo in the DynamicTypePropagation checker. There are several limitations in the current implementation:. * Temporaries are poorly modeled right now because we're not confident in the; placement of their destructors in the CFG. We currently won't inline their; constructors unless the destructor is trivial, and don't process their; destructors at all, not even to invalidate the region. * 'new' is poorly modeled due to some nasty CFG/design issues. This is tracked; in PR12014. 'delete' is not modeled at all. * Arrays of obje",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:15369,interface,interface,15369,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['interface'],['interface']
Integrability,"urn 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection`** to make an iterator. - **`TCollection`** asks **`TObjArray`** to make an iterator. - **`TObjArray`** returns a **`TObjArrayIter`**. Now define a pointer for `MyClass` objects and set it to each member of; the **`TObjArray`**:. ``` {.cpp}; MyClass *myobject;; while ((myobject = (MyClass *)myiter.Next())) {; // process myobject; }; ```. The heart of this is the `myiter.Next()` expression whic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:11227,wrap,wrapper,11227,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['wrap'],['wrapper']
Integrability,"urrent node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ~~~{.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; ~~~. - Current `global transformation`. This represents the transformation; from `MARS` to the local reference of the current node, being the; product of all local mother-daughter transformations in the branch.; The global transformation can be referenced or copied:. ~~~{.cpp}; const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);; ~~~. - One often needs to perform `master-to-local` and `local-to-master`; point and vector conversions to get from `MARS` to the local node; coordinates. This can be done by using the global transformation or; directly the **`TGeoManager`** corresponding interfaces:. ~~~{.cpp}; Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; ~~~. \anchor GP02f; ### Saving and Restoring the Current State. As we already described, saving and restoring modeller states can be; quite useful during tracking and is a feature extensively used by; external tracking engines. We will call this navigation history; management, which in most of the cases can be performed by handling the; state identifiers. For quite big geometries, state indexing is not; possible anymore and will be automatically disabled by the modeller.; Fortunately there is a backup solution working in any condition: the; modeller maintains a stack of states that is internally used by its own; navigati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:72345,interface,interfaces,72345,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interfaces']
Integrability,"urther increases the stability of ROOT.; Add support for 'Dump' and 'Browse' of 'emulated' object.; TBits equality operator nows return true if the 2 operands have different; length and all the bits in the longer TBits that are passed the length; of the shorter TBits are zero (i.e. the default value of each; bits is zero).; Properly handle scripts with line longer than 1024 characters.; Repair the handling of ACLiC options on the command line (for example a.C+g).; In TClass::BuildEmulatedRealData properly handle the case of TNamed member that are not base class.; On the command line:; ; Fix the tab-completion of filenames in the sub-directories.; Prevent the unadvertent replacement of an arrow with a dot when the left side is actually a pointer. More user friendly stacktrace in case of a crash, with hints where; the problem might be. On Linux and MacOS X these stacktraces are generated; by the script $ROOTSYS/etc/gdb-backtrace.sh. Using the Root.StackTraceMessage; resource one can customize the message printed by the script. The entire; script can be replaced using the Root.StacktraceScript resource.; Numerous minor bug fixes... New module editline ; The new module editline enhances the prompt, giving type and syntax feedback using e.g. colors.; Class names are highlighted blue when typed, indicating that it is known to ROOT.; Matching parenthesis pairs are highlighted green when typed, or when the cursor is moved to a bracket. This works for () {} and [] brackets.; Any mismatched brackets (those without a matching partner) will be highlighted red when typed or when the cursor is moved to the bracket.; Tab completion output is colored magenta to differentiate between tab completion output and user input.; All of the colors are configurable in the .rootrc file.; They can be specified as #rgb or #rrggbb or color names:; black, red, green, yellow, blue, magenta, cyan or white.; They can be followed by an optional bold (alias light) or underlined.; Rint.ReverseColor all",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v526/index.html:1332,message,message,1332,core/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v526/index.html,1,['message'],['message']
Integrability,"use it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we need for this is **`TMonitor`**. It lets; you add sockets and the `TMonitor::Select` method retu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:2129,message,message,2129,documentation/users-guide/Networking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md,1,['message'],['message']
Integrability,"use-after-scope``); * Double-free, invalid free; * Memory leaks (experimental). Typical slowdown introduced by AddressSanitizer is **2x**. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>` and enable; the ``compiler-rt`` runtime. An example CMake configuration that will allow; for the use/testing of AddressSanitizer:. .. code-block:: console. $ cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=""clang"" -DLLVM_ENABLE_RUNTIMES=""compiler-rt"" <path to source>/llvm. Usage; =====. Simply compile and link your program with ``-fsanitize=address`` flag. The; AddressSanitizer run-time library should be linked to the final executable, so; make sure to use ``clang`` (not ``ld``) for the final link step. When linking; shared libraries, the AddressSanitizer run-time is not linked, so; ``-Wl,-z,defs`` may cause link errors (don't use it with AddressSanitizer). To; get a reasonable performance add ``-O1`` or higher. To get nicer stack traces; in error messages add ``-fno-omit-frame-pointer``. To get perfect stack traces; you may need to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat example_UseAfterFree.cc; int main(int argc, char **argv) {; int *array = new int[100];; delete [] array;; return array[argc]; // BOOM; }. # Compile and link; % clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer example_UseAfterFree.cc. or:. .. code-block:: console. # Compile; % clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer -c example_UseAfterFree.cc; # Link; % clang++ -g -fsanitize=address example_UseAfterFree.o. If a bug is detected, the program will print an error message to stderr and; exit with a non-zero exit code. AddressSanitizer exits on the first detected error.; This is by design:. * This approach allows AddressSanitizer to produce faster and smaller generated code; (both by ~5%).; * Fixing bugs becomes unavoidable. AddressSanitizer does not produ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:1678,message,messages,1678,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['message'],['messages']
Integrability,"used exception handling info on SCC (<<null function>>); BISECT: running pass (12) Function Integration/Inlining on SCC (<<null function>>); BISECT: running pass (13) Deduce function attributes on SCC (<<null function>>); BISECT: running pass (14) Remove unused exception handling info on SCC (f); BISECT: running pass (15) Function Integration/Inlining on SCC (f); BISECT: running pass (16) Deduce function attributes on SCC (f); BISECT: NOT running pass (17) Remove unused exception handling info on SCC (g); BISECT: NOT running pass (18) Function Integration/Inlining on SCC (g); BISECT: NOT running pass (19) Deduce function attributes on SCC (g); BISECT: NOT running pass (20) SROA on function (g); BISECT: NOT running pass (21) Early CSE on function (g); BISECT: NOT running pass (22) Speculatively execute instructions if target has divergent branches on function (g); ... etc. ... Pass Skipping Implementation; ============================. The -opt-bisect-limit implementation depends on individual passes opting in to; the opt-bisect process. The OptBisect object that manages the process is; entirely passive and has no knowledge of how any pass is implemented. When a; pass is run if the pass may be skipped, it should call the OptBisect object to; see if it should be skipped. The OptBisect object is intended to be accessed through LLVMContext and each; Pass base class contains a helper function that abstracts the details in order; to make this check uniform across all passes. These helper functions are:. .. code-block:: c++. bool ModulePass::skipModule(Module &M);; bool CallGraphSCCPass::skipSCC(CallGraphSCC &SCC);; bool FunctionPass::skipFunction(const Function &F);; bool LoopPass::skipLoop(const Loop *L);. A MachineFunctionPass should use FunctionPass::skipFunction() as such:. .. code-block:: c++. bool MyMachineFunctionPass::runOnMachineFunction(Function &MF) {; if (skipFunction(*MF.getFunction()); return false;; // Otherwise, run the pass normally.; }. In addition to ch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst:6903,depend,depends,6903,interpreter/llvm-project/llvm/docs/OptBisect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst,1,['depend'],['depends']
Integrability,"used for namespaces. Possible values:. * ``NI_None`` (in configuration: ``None``); Don't indent in namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_Inner`` (in configuration: ``Inner``); Indent only in inner namespaces (nested in other namespaces). .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_All`` (in configuration: ``All``); Indent in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Aut",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88124,protocol,protocol,88124,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['protocol'],['protocol']
Integrability,"user specifies the number of intermediate function points; used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration.; We can use the example above, but replacing the creation of a `ROOT::Math::GaussIntegrator` object with `ROOT::Math::GaussLegendreIntegrator`. #### ROOT::Math::GSLIntegrator. This is a wrapper for the *QUADPACK* integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time.; The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide; This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the; GSL library, wich is provided in the *MathMore* library of ROOT. The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the `ROOT::Math::GSLIntegrator` class.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users document",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:55179,interface,interface,55179,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"using tied-outputs (i.e. outputs that are inputs and outputs, not just; outputs) with the `+r` constraint, there is a hidden input that's created; before the label, so numeric references to operands must account for that. .. code-block:: c++. int foo(int x) {; // %0 and %1 both refer to x; // %l2 refers to err; asm goto(""# %0 %1 %l2"" : ""+r""(x) : : : err);; return x;; err:; return -1;; }. This was changed to match GCC in clang-13; for better portability, symbolic; references can be used instead of numeric references. .. code-block:: c++. int foo(int x) {; asm goto(""# %[x] %l[err]"" : [x]""+r""(x) : : : err);; return x;; err:; return -1;; }. Objective-C Features; ====================. Related result types; --------------------. According to Cocoa conventions, Objective-C methods with certain names; (""``init``"", ""``alloc``"", etc.) always return objects that are an instance of; the receiving class's type. Such methods are said to have a ""related result; type"", meaning that a message send to one of these methods will have the same; static type as an instance of the receiver class. For example, given the; following classes:. .. code-block:: objc. @interface NSObject; + (id)alloc;; - (id)init;; @end. @interface NSArray : NSObject; @end. and this common initialization pattern. .. code-block:: objc. NSArray *array = [[NSArray alloc] init];. the type of the expression ``[NSArray alloc]`` is ``NSArray*`` because; ``alloc`` implicitly has a related result type. Similarly, the type of the; expression ``[[NSArray alloc] init]`` is ``NSArray*``, since ``init`` has a; related result type and its receiver is known to have the type ``NSArray *``.; If neither ``alloc`` nor ``init`` had a related result type, the expressions; would have had type ``id``, as declared in the method signature. A method with a related result type can be declared by using the type; ``instancetype`` as its result type. ``instancetype`` is a contextual keyword; that is only permitted in the result type of an Obje",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:68390,message,message,68390,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['message'],['message']
Integrability,"ut nodes for; implicit destructors, or if the destructors for the given object are not; represented in the CFG, the constructor will not be inlined. (As an exception,; constructors for objects with trivial constructors can still be inlined.); See ""C++ Caveats"" below. - In C++, ExprEngine does not inline custom implementations of operator 'new'; or operator 'delete', nor does it inline the constructors and destructors; associated with these. See ""C++ Caveats"" below. - Calls resulting in ""dynamic dispatch"" are specially handled. See more below. - The FunctionSummaries map stores additional information about declarations,; some of which is collected at runtime based on previous analyses.; We do not inline functions which were not profitable to inline in a different; context (for example, if the maximum block count was exceeded; see; ""Retry Without Inlining""). Dynamic Calls and Devirtualization; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ""Dynamic"" calls are those that are resolved at runtime, such as C++ virtual; method calls and Objective-C message sends. Due to the path-sensitive nature of; the analysis, the analyzer may be able to reason about the dynamic type of the; object whose method is being called and thus ""devirtualize"" the call. This path-sensitive devirtualization occurs when the analyzer can determine what; method would actually be called at runtime. This is possible when the type; information is constrained enough for a simulated C++/Objective-C object that; the analyzer can make such a decision. DynamicTypeInfo; ^^^^^^^^^^^^^^^. As the analyzer analyzes a path, it may accrue information to refine the; knowledge about the type of an object. This can then be used to make better; decisions about the target method of a call. Such type information is tracked as DynamicTypeInfo. This is path-sensitive; data that is stored in ProgramState, which defines a mapping from MemRegions to; an (optional) DynamicTypeInfo. If no DynamicTypeInfo has been explicitly set for a MemRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:9079,message,message,9079,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['message'],['message']
Integrability,"ut[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; ```. #### Adding a Branch with a Fixed Length Array. At first, we create a tree and create branches for a subset of variables; in the C structure` Gctrak_t`. Then we add several types of branches.; The first branch reads seven floating-point values beginning at the; address of `'gstep.vect'`. You do not need to specify `&gstep.vect`,; because in C and C++ the array variable holds the address of the first; element. ``` {.cpp}; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; ```. #### Adding a Branch with a Variable Length Array. The next two branches are dependent on each other. The first holds the; length of the variable length array and the second holds the variable; length array. The `lmec` branch reads `nmec` number of integers; beginning at the address `gstep.lmec`. ``` {.cpp}; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; ```. The variable `nmec` is a random number and is reset for each entry. ``` {.cpp}; gstep.nmec = (Int_t)(5*gRandom->Rndm());; ```. #### Filling the Tree. In this emulation of Geant3, we generate and transport particles in a; magnetic field and store the particle parameters at each tracking step; in a ROOT tree. ### Analysis. In this analysis, we do not read the entire entry we only read one; branch. First, we set the address for the branch to the file `dstep`,; and then we use the `TBranch::GetEntry` method. Then we fill a histogram; with the `dstep` branch entries, draw it and fit it with a Gaussian. In; addition, we draw the particle's path using the three values in t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:48398,depend,dependent,48398,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['depend'],['dependent']
Integrability,"ut`` option generates the BMI as a by-product of the compilation.; If ``-fmodule-output=`` is specified, the BMI will be emitted the specified location. Then if; ``-fmodule-output`` and ``-c`` are specified, the BMI will be emitted in the directory of the; output file with the name of the input file with the new extension ``.pcm``. Otherwise, the BMI; will be emitted in the working directory with the name of the input file with the new extension; ``.pcm``. The style to generate BMIs by ``--precompile`` is called two-phase compilation since it takes; 2 steps to compile a source file to an object file. The style to generate BMIs by ``-fmodule-output``; is called one-phase compilation respectively. The one-phase compilation model is simpler; for build systems to implement and the two-phase compilation has the potential to compile faster due; to higher parallelism. As an example, if there are two module units A and B, and B depends on A, the; one-phase compilation model would need to compile them serially, whereas the two-phase compilation; model may be able to compile them simultaneously if the compilation from A.pcm to A.o takes a long; time. File name requirement; ~~~~~~~~~~~~~~~~~~~~~. The file name of an ``importable module unit`` should end with ``.cppm``; (or ``.ccm``, ``.cxxm``, ``.c++m``). The file name of a ``module implementation unit``; should end with ``.cpp`` (or ``.cc``, ``.cxx``, ``.c++``). The file name of BMIs should end with ``.pcm``.; The file name of the BMI of a ``primary module interface unit`` should be ``module_name.pcm``.; The file name of BMIs of ``module partition unit`` should be ``module_name-partition_name.pcm``. If the file names use different extensions, Clang may fail to build the module.; For example, if the filename of an ``importable module unit`` ends with ``.cpp`` instead of ``.cppm``,; then we can't generate a BMI for the ``importable module unit`` by ``--precompile`` option; since ``--precompile`` option now would only run preproc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:8043,depend,depends,8043,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['depends']
Integrability,"ute>`_. * If you are unsure of what a label is intended to be used for, please see the; `documentation for our labels <https://github.com/llvm/llvm-project/labels>`_. .. _Actively working on fixing:. Actively working on fixing bugs; ===============================. Please remember to assign the bug to yourself if you're actively working on; fixing it and to unassign it when you're no longer actively working on it. You; unassign a bug by removing the person from the ``Assignees`` field. .. _Closing:. Resolving/Closing bugs; ======================. Resolving bugs is good! Make sure to properly record the reason for resolving.; Examples of reasons for resolving are:. * If the issue has been resolved by a particular commit, close the issue with; a brief comment mentioning which commit(s) fixed it. If you are authoring; the fix yourself, your git commit message may include the phrase; ``Fixes #<issue number>`` on a line by itself. GitHub recognizes such commit; messages and will automatically close the specified issue with a reference; to your commit. * If the reported behavior is not a bug, it is appropriate to close the issue; with a comment explaining why you believe it is not a bug, and adding the; ``invalid`` tag. * If the bug duplicates another issue, close it as a duplicate by adding the; ``duplicate`` label with a comment pointing to the issue it duplicates. * If there is a sound reason for not fixing the issue (difficulty, ABI, open; research questions, etc), add the ``wontfix`` label and a comment explaining; why no changes are expected. * If there is a specific and plausible reason to think that a given bug is; otherwise inapplicable or obsolete. One example is an open bug that doesn't; contain enough information to clearly understand the problem being reported; (e.g. not reproducible). It is fine to close such a bug, adding with the; ``worksforme`` label and leaving a comment to encourage the reporter to; reopen the bug with more information if it's still repr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst:4101,message,messages,4101,interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,1,['message'],['messages']
Integrability,"utex mu;; int a GUARDED_BY(mu);. public:; Mutex* getMu() RETURN_CAPABILITY(mu) { return &mu; }. // analysis knows that getMu() == mu; void clear() REQUIRES(getMu()) { a = 0; }; };. ACQUIRED_BEFORE(...), ACQUIRED_AFTER(...); -----------------------------------------. ``ACQUIRED_BEFORE`` and ``ACQUIRED_AFTER`` are attributes on member; declarations, specifically declarations of mutexes or other capabilities.; These declarations enforce a particular order in which the mutexes must be; acquired, in order to prevent deadlock. .. code-block:: c++. Mutex m1;; Mutex m2 ACQUIRED_AFTER(m1);. // Alternative declaration; // Mutex m2;; // Mutex m1 ACQUIRED_BEFORE(m2);. void foo() {; m2.Lock();; m1.Lock(); // Warning! m2 must be acquired after m1.; m1.Unlock();; m2.Unlock();; }. CAPABILITY(<string>); --------------------. *Previously*: ``LOCKABLE``. ``CAPABILITY`` is an attribute on classes, which specifies that objects of the; class can be used as a capability. The string argument specifies the kind of; capability in error messages, e.g. ``""mutex""``. See the ``Container`` example; given above, or the ``Mutex`` class in :ref:`mutexheader`. SCOPED_CAPABILITY; -----------------. *Previously*: ``SCOPED_LOCKABLE``. ``SCOPED_CAPABILITY`` is an attribute on classes that implement RAII-style; locking, in which a capability is acquired in the constructor, and released in; the destructor. Such classes require special handling because the constructor; and destructor refer to the capability via different names; see the; ``MutexLocker`` class in :ref:`mutexheader`, below. Scoped capabilities are treated as capabilities that are implicitly acquired; on construction and released on destruction. They are associated with; the set of (regular) capabilities named in thread safety attributes on the; constructor or function returning them by value (using C++17 guaranteed copy; elision). Acquire-type attributes on other member functions are treated as; applying to that set of associated capabilities,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:13018,message,messages,13018,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['message'],['messages']
Integrability,"utorials create new files. If you have write access to; the tutorials directory, the new files will be created in the tutorials; directory, otherwise they will be created in the user directory. You can start by executing the standard ROOT demos with a session like:. ```; root > .x demos.C; ```; or. ```; root > .x $ROOTSYS/tutorials/demos.C; ```. You can execute the standard ROOT graphics benchmark with. ```; root > .x benchmarks.C; ```. or. ```; root > .x $ROOTSYS/tutorials/benchmarks.C; ```. The `$ROOTSYS/tutorials` directory includes several sub-directories:. \defgroup tutorial_hist Histograms tutorials; \ingroup Tutorials; \brief Examples showing the ""histograms' classes"" usage. \defgroup tutorial_tree Tree tutorials; \ingroup Tutorials; \brief Example code which illustrates how to use ROOT trees and ntuples. \defgroup tutorial_dataframe Dataframe tutorials; \ingroup Tutorials; \brief These examples show various features of [RDataFrame](classROOT_1_1RDataFrame.html): ROOT's declarative analysis interface. \defgroup tutorial_v7 ROOT 7 tutorials; \ingroup Tutorials; \brief Various examples showing the ROOT 7 interface. \defgroup tutorial_FOAM FOAM tutorials; \ingroup Tutorials; \brief Examples showing how to use FOAM. \defgroup tutorial_cont Containers tutorials; \ingroup Tutorials; \brief Examples showing the ""containers' classes"" usage. \defgroup tutorial_eve Event display tutorials; \ingroup Tutorials; \brief Examples showing the ""Event display classes"" usage. \defgroup tutorial_eve7 Event display ROOT7 tutorials; \ingroup Tutorials; \brief Examples showing the ""Event display classes"" usage with ROOT7. \defgroup tutorial_geom Geometry tutorials; \ingroup Tutorials; \brief Various ROOT geometry package examples. \defgroup tutorial_fft Fast Fourier Transforms tutorials; \ingroup Tutorials; \brief Example showing the Fast Fourier Transforms interface in ROOT. \defgroup tutorial_fit Fit Tutorials; \ingroup Tutorials; \brief These tutorials illustrate the main fitting",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md:1330,interface,interface,1330,tutorials/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md,1,['interface'],['interface']
Integrability,"utorials; \ingroup Tutorials; \brief Examples showing the TImage class usage. \defgroup tutorial_io IO tutorials; \ingroup Tutorials; \brief These tutorials illustrate some of the capabilities of the ROOT IO subsystem. \defgroup tutorial_math Math tutorials; \ingroup Tutorials; \brief Examples showing the Math classes. \defgroup tutorial_matrix Matrix tutorials; \ingroup Tutorials; \brief Examples showing how to use TMatrix. \defgroup tutorial_mc Monte Carlo tutorials; \ingroup Tutorials; \brief Monte Carlo examples. \defgroup tutorial_multicore Multicore tutorials; \ingroup Tutorials; \brief These examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing. \defgroup tutorial_net Net tutorials; \ingroup Tutorials; \brief Examples showing the net classes. \defgroup tutorial_physics Physics tutorials; \ingroup Tutorials; \brief Physics examples. \defgroup tutorial_pyroot PyRoot tutorials; \ingroup Tutorials; \brief Selected examples illustrating how to use ROOT's Python interface: PyROOT. \defgroup tutorial_pythia Pythia tutorials; \ingroup Tutorials; \brief Examples showing the pythia usage. \defgroup tutorial_quadp Quadratic programming package.; \ingroup Tutorials; \brief Example showing the usage of the quadratic programming package quadp. \defgroup tutorial_r R tutorials; \ingroup Tutorials; \brief Examples showing the R interface. \defgroup tutorial_roostats RooStats Tutorials; \ingroup Tutorials; \brief These tutorials illustrate the main features of RooStats. \defgroup tutorial_spectrum Spectrum tutorials; \ingroup Tutorials; \brief Examples showing the TSpectrum and TSpectrumPainter usage. \defgroup tutorial_splot TSPlot tutorials; \ingroup Tutorials; \brief This tutorial illustrates the use of class TSPlot. \defgroup tutorial_sql SQL tutorials; \ingroup Tutorials; \brief Examples showing the SQL classes. \defgroup tutorial_tmva TMVA tutorials; \ingroup Tutorials; \brief Example code whic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md:4613,interface,interface,4613,tutorials/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md,1,['interface'],['interface']
Integrability,"utputFile. Fix a problem with the determination of the fDir member; affecting mostly PROOF-Lite; Fix a serious issue whose net effect was to delete the; outputfile just after having open it. XrdProofd plugin. Make sure that the limit on the number of old; sessions is applied whenever a new session is started and not only when; the daemon is started.; Fix the behaviour of the xpd.allowedusers directive: if; at least one of these directives is present, users in the password file; are not allowed by default but must be explicitly appear in one; xpd.allowedusers directive  ; Fix a source for memory leak in; XrdProofdProtocol::SendMsg; Optimize the usage of strings in a few places. DataSet manager. Correctly classify as TTree all TTree derived classes; (e.g. TNtuple's); Fix a problem in saving the end-point URL for local; files; Improve realtime notification during 'verify'. TProofDraw. Fix a problem with the axis ranges of the underlying; histogram in PolyMarker3D; Allow to use the default pad instead of forcing; creation of one pad per object; Add wrapper to handle the feedback default canvas. TEventIter. Fix a problem with changing the tree cache size: the; size was reset to the default value after the first file. TDataSetManagerFile. Solve a consistency problem in checking URLs for; duplication when adding them to the relevant TFileInfo; During dataset validation, do not fail on duplications; but notify and add them to the bad file list. TPacketizerAdaptive, TPacketizer. Improve data node / worker matching by always using the; host FQDN. TPacketizerUnit, TEventIter. Make sure that the entry; number passed to TSelector::Process is unique and in increasing order; for non-data driven processing (packetizer TPacketizerUnit). This; allows to give a meaning to this variable, for example to related it to; one dimension of an integration. Fixes in PROOF-Lite:. Make sure that with envs settings via TProof::AddEnvVar; are effective; this enables, for example, the automatic valg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:8306,wrap,wrapper,8306,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,1,['wrap'],['wrapper']
Integrability,"utside the index; type width will not be affected. The result value of the ``getelementptr`` may be outside the object pointed; to by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or to its end. Note that the; object does not have to be live anymore; being in-bounds of a deallocated; object is sufficient.; * If the type of an index is larger than the pointer index type, the; truncation to the pointer index type preserves the signed value.; * The multiplication of an index by the type size does not wrap the pointer; index type in a signed sense (``nsw``).; * The successive addition of each offset (without adding the base address) does; not wrap the pointer index type in a signed sense (``nsw``).; * The successive addition of the current address, interpreted as an unsigned; number, and each offset, interpreted as a signed number, does not wrap the; unsigned address space and remains *in bounds* of the allocated object.; As a corollary, if the added offset is non-negative, the addition does not; wrap in an unsigned sense (``nuw``).; * In cases where the base is a vector of pointers, the ``inbounds`` keyword; applies to each of the computations element-wise. Note that ``getelementptr`` with all-zero indices is always considered to be; ``inbounds``, even if the base pointer does not point to an allocated object.; As a corollary, the only pointer in bounds of the null pointer in the default; address space is the null pointer itself. These rules are based on the assumption that no al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:437717,wrap,wrap,437717,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['wrap'],['wrap']
Integrability,"utton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2b.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h); : TGMainFrame(p,w,h) {. // Creates widgets of the example; fEcanvas = new TRootEmbeddedCanvas (""Ecanvas"",this,200,200);; AddFrame(fEcanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY, 10,10,10,1));; TGHorizontalFrame *hframe=new TGHorizontalFrame(this, 200,40);; TGTextButton *draw = new TGTextButton(hframe,""&Draw"");; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; hframe->AddFrame(draw, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; TGTextButton *exit = new TGTextButton(hframe,""&Exit "",; ""gApplication->Terminate()"");; hframe->AddFrame(exit, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; AddFrame(hframe,new TGLayoutHints(kLHintsCenterX,2,2,2,2));. // Sets window name and shows the main frame; SetWindowName(""Simple Example"");; MapSubwindows();; Resize(GetDefaultSize());; MapWindow();; }; ```. ## Widgets Overview. The word widget is a contraction of windows and gadget. Almost all GUI; elements are widgets. A button is a widget, a menu item is a widget, a; scrollbar is a widget, and a complete dialog box is a widget too. Some; widgets may have sub widgets. For example, a dialog box can contain; buttons, text fields, a combo-box, etc. On the screen widgets look like rectangular areas with special; behaviors. In terms of the object-oriented programming we can define a; widget in ROOT as an object of a class deriving from **`TGObject`**. This section presents all currently supported widgets in ROOT and their; most useful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:19679,contract,contraction,19679,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['contract'],['contraction']
Integrability,"uture version may integrate Cling-generated IR directly into Numba IR (or; vice versa), e.g. if the C++ code is exposed from (precompiled) headers.; This would allow inlining of C++ code into Numba traces, for further; expected speedups. Why Numba?; ----------. The advertised premise of Numba is that it ""makes Python code fast.""; However, there is a much more compelling reason: Numba allows developers to; stay in their chosen ecosystem, be it Python or C++, in mixed environments,; without paying for their choice in lost performance.; For example, a Python developer using Numba does not need to rewrite a kernel; into C++ just to run performantly in a C++ framework.; Similarly, a C++ developer can use Numba to compile and create function; pointers to Python code for easy, performant, access.; This becomes even more compelling if the deployment target is a GPU, which; would otherwise certainly require a rewrite of the Python code.; Add that Numba, as a JIT-compiler, is fully run-time just like ``cppyy``,; and the use case for integration is clear.; (Numba does not currently provide support for C++.). Usage; -------. ``cppyy`` does not use Numba extension hooks to minimize accidental; dependencies.; Instead, it requires that the extensions are loaded explicitly by any code; that uses it::. import cppyy.numba_ext. After that, Numba is able to trace ``cppyy`` bound code when applying the; usual ``numba.njit`` decorator. Numba type declarations are done lazily, with the ``numba_ext`` module only; initially registering hooks on proxy base classes, to keep overheads in; Numba's type-resolution to a minimum.; On use in a JITed trace, each C++ type or function call is refined to the; actual, concrete types and type-specific overloads, with templates; instantiated as-needed.; Where possible, lowering is kept generic to reduce the number of callbacks; in Numba's compilation chain. Examples; --------. The following, non-exhaustive, set of examples gives an idea of the; current lev",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:2158,integrat,integration,2158,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['integrat'],['integration']
Integrability,"valuated once for; each value in the range list, range piece, or single value. On each; iteration, the :token:`TokIdentifier` variable is set to the value and can; be used in the statements. The statement list establishes an inner scope. Variables local to a; ``foreach`` go out of scope at the end of each loop iteration, so their; values do not carry over from one iteration to the next. Foreach loops may; be nested. .. Note that the productions involving RangeList and RangePiece have precedence; over the more generic value parsing based on the first token. .. code-block:: text. foreach i = [0, 1, 2, 3] in {; def R#i : Register<...>;; def F#i : Register<...>;; }. This loop defines records named ``R0``, ``R1``, ``R2``, and ``R3``, along; with ``F0``, ``F1``, ``F2``, and ``F3``. ``dump`` --- print messages to stderr; -------------------------------------. A ``dump`` statement prints the input string to standard error; output. It is intended for debugging purpose. * At top level, the message is printed immediately. * Within a record/class/multiclass, `dump` gets evaluated at each; instantiation point of the containing record. .. productionlist::; Dump: ""dump"" `string` "";"". For example, it can be used in combination with `!repr` to investigate; the values passed to a multiclass:. .. code-block:: text. multiclass MC<dag s> {; dump ""s = "" # !repr(s);; }. ``if`` --- select statements based on a test; --------------------------------------------. The ``if`` statement allows one of two statement groups to be selected based; on the value of an expression. .. productionlist::; If: ""if"" `Value` ""then"" `IfBody`; :| ""if"" `Value` ""then"" `IfBody` ""else"" `IfBody`; IfBody: ""{"" `Statement`* ""}"" | `Statement`. The value expression is evaluated. If it evaluates to true (in the same; sense used by the bang operators), then the statements following the; ``then`` reserved word are processed. Otherwise, if there is an ``else``; reserved word, the statements following the ``else`` are process",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:47147,message,message,47147,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['message'],['message']
Integrability,"value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx.coreFoundation.CFError; (C); Check usage of CFErrorRef* parameters. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. osx.coreFoundation.CFNumber; (C); Check for improper uses of CFNumberCreate. CFNumberRef test(unsigne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:19092,interface,interface,19092,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['interface'],['interface']
Integrability,"values; directly to the output stream, or by using the ``std::format()`` or; ``llvm::formatv()`` functions. .. code-block:: text. OS << ""#ifndef "" << NodeName << ""\n"";. OS << format(""0x%0*x, "", Digits, Value);. Instances of the following classes can be printed using the ``<<`` operator:; ``RecordKeeper``,; ``Record``,; ``RecTy``,; ``RecordVal``, and; ``Init``. The helper function ``emitSourceFileHeader()`` prints the header comment; that should be included at the top of every output file. A call to it is; included in the skeleton backend file ``TableGenBackendSkeleton.cpp``. Printing Error Messages; =======================. TableGen records are often derived from multiple classes and also often; defined through a sequence of multiclasses. Because of this, it can be; difficult for backends to report clear error messages with accurate source; file locations. To make error reporting easier, five error reporting; functions are provided, each with four overloads. * ``PrintWarning`` prints a message tagged as a warning. * ``PrintError`` prints a message tagged as an error. * ``PrintFatalError`` prints a message tagged as an error and then terminates. * ``PrintNote`` prints a note. It is often used after one of the previous; functions to provide more information. * ``PrintFatalNote`` prints a note and then terminates. Each of these five functions is overloaded four times. * ``PrintError(const Twine &Msg)``:; Prints the message with no source file location. * ``PrintError(ArrayRef<SMLoc> ErrorLoc, const Twine &Msg)``:; Prints the message followed by the specified source line,; along with a pointer to the item in error. The array of; source file locations is typically taken from a ``Record`` instance. * ``PrintError(const Record *Rec, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record (see `Record`_). * ``PrintError(const RecordVal *RecVal, const Twine &Msg)``:; Prints the message followed by the source line associated w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:23929,message,message,23929,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['message'],['message']
Integrability,"var will not be automatically released during; deallocation. .. _arc.ownership.semantics:. Semantics; ---------. There are five :arc-term:`managed operations` which may be performed on an; object of retainable object pointer type. Each qualifier specifies different; semantics for each of these operations. It is still undefined behavior to; access an object outside of its lifetime. A load or store with ""primitive semantics"" has the same semantics as the; respective operation would have on an ``void*`` lvalue with the same alignment; and non-ownership qualification. :arc-term:`Reading` occurs when performing a lvalue-to-rvalue conversion on an; object lvalue. * For ``__weak`` objects, the current pointee is retained and then released at; the end of the current full-expression. In particular, messaging a ``__weak``; object keeps the object retained until the end of the full expression. .. code-block:: objc. __weak MyObject *weakObj;. void foo() {; // weakObj is retained before the message send and released at the end of; // the full expression.; [weakObj m];; }. This must execute atomically with respect to assignments and to the final; release of the pointee.; * For all other objects, the lvalue is loaded with primitive semantics. :arc-term:`Assignment` occurs when evaluating an assignment operator. The; semantics vary based on the qualification:. * For ``__strong`` objects, the new pointee is first retained; second, the; lvalue is loaded with primitive semantics; third, the new pointee is stored; into the lvalue with primitive semantics; and finally, the old pointee is; released. This is not performed atomically; external synchronization must be; used to make this safe in the face of concurrent loads and stores.; * For ``__weak`` objects, the lvalue is updated to point to the new pointee,; unless the new pointee is an object currently undergoing deallocation, in; which case the lvalue is updated to a null pointer. This must execute; atomically with respect to other ass",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:38277,message,message,38277,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"vases. A pad (class; **`TPad`**) is a graphical container in the sense it contains other; graphical objects like histograms and arrows. It may contain other pads; (sub-pads) as well. A Pad is a linked list of primitives of any type; (graphs, histograms, shapes, tracks, etc.). It is a kind of display list. ![The pad display list](pictures/pad_01.png). Drawing an object is nothing more than adding its pointer to this list.; Look for example at the code of `TH1::Draw()`. It is merely ten lines of; code. The last statement is `AppendPad()`. This statement calls method; of **`TObject`** that just adds the pointer of the object, here a; histogram, to the list of objects attached to the current pad. Since; this is a **`TObject`**'s method, every object may be ""drawn"", which; means attached to a pad. When is the painting done then ? The answer is: when needed. Every object; that derives from **`TObject`** has a `Paint()` method. It may be empty,; but for graphical objects, this routine contains all the instructions to; paint effectively it in the active pad. Since a Pad has the list of; objects it owns, it will call successively the `Paint()` method of each; object, thus re-painting the whole pad on the screen. If the object is a; sub-pad, its `Paint()` method will call the `Paint()` method of the; objects attached, recursively calling `Paint()` for all the objects. ![Pad painting](pictures/pad_02.png). In some cases a pad need to be painted during a macro execution. To; force the pad painting `gPad->Update()` (see next section) should be performed. The list of primitives stored in the pad is also used to pick objects; and to interact with them. ### The Global Pad: gPad. When an object is drawn, it is always in the so-called active pad. For; every day use, it is comfortable to be able to access the active pad,; whatever it is. For that purpose, there is a global pointer, called; ***`gPad`***. It is always pointing to the active pad. If you want to; change the fill color of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:14427,rout,routine,14427,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['rout'],['routine']
Integrability,"ve &A, unsigned ChildIdx);; Archive::Child &operator*();; friend bool operator==(const ArchiveIterator &LHS,; const ArchiveIterator &RHS);. // operator++/operator-- replaced with fallible increment / decrement:; Error inc() {; if (!A.childValid(ChildIdx + 1)); return make_error<BadArchiveMember>(...);; ++ChildIdx;; return Error::success();; }. Error dec() { ... }; };. Instances of this kind of fallible iterator interface are then wrapped with the; fallible_iterator utility which provides ``operator++`` and ``operator--``,; returning any errors via a reference passed in to the wrapper at construction; time. The fallible_iterator wrapper takes care of (a) jumping to the end of the; range on error, and (b) marking the error as checked whenever an iterator is; compared to ``end`` and found to be inequal (in particular: this marks the; error as checked throughout the body of a range-based for loop), enabling early; exit from the loop without redundant error checking. Instances of the fallible iterator interface (e.g. FallibleChildIterator above); are wrapped using the ``make_fallible_itr`` and ``make_fallible_end``; functions. E.g.:. .. code-block:: c++. class Archive {; public:; using child_iterator = fallible_iterator<FallibleChildIterator>;. child_iterator child_begin(Error &Err) {; return make_fallible_itr(FallibleChildIterator(*this, 0), Err);; }. child_iterator child_end() {; return make_fallible_end(FallibleChildIterator(*this, size()));; }. iterator_range<child_iterator> children(Error &Err) {; return make_range(child_begin(Err), child_end());; }; };. Using the fallible_iterator utility allows for both natural construction of; fallible iterators (using failing ``inc`` and ``dec`` operations) and; relatively natural use of c++ iterator/loop idioms. .. _function_apis:. More information on Error and its related utilities can be found in the; Error.h header file. Passing functions and other callable objects; --------------------------------------------. Sometimes you ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:38922,interface,interface,38922,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interface']
Integrability,"ve a string with the example ""go"". Now let's send a histogram. *To send an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:1934,message,message,1934,documentation/users-guide/Networking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md,2,['message'],['message']
Integrability,"ve been removed from the interfaces.; The SetWorkspace(RooWorkspace & ) has also been removed, while a SetModel(const ModelConfig &); function is introduced. Users are supposed to pass all the model information using the; ModelConfig class rather than via the; RooWorkspace or specifying directly the pdf and parameter; objects in the constructors. ; Setter methods using pdf instances and parameter lists are maintained in the derived classes, like the ProfileLikelihoodCalculator or the HybridCalculator, but those passing a string for the name of the pdf have been removed. ; All the calculator classes do not keep anymore a pointer to the workspace, but they contain pointers to the pdf, the data and the parameters required to run the calculator. These pointers are managed outside by the users or by the RooWorkspace. They can be passed either directly to the classes, for example via the constructor, or by using the ModelConfig class. The ModelConfig class acts as an interface to the Workspace in order to load and store all the; needed information. . ProfileLikelihoodCalculator, LikelihoodInterval. The Minos algorithm of Minuit is used now to find the limit of the likelihood intervals instead of searching directly the roots of the RooProfileLL class. Minos is used via the ROOT::Math::Minimizer interface. By default TMinuit is used, one can also use Minuit2 by doing ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"").; The LikelihoodInterval class now provides now two new methods, FindLimits which finds both the upper and lower interval bounds, and GetContourPoints to find the 2D contour points defining the likelihood interval. GetContourPoints is now used by the LikelihoodIntervalPlot class to draw the 2D contour.; ; New tutorials have been added: rs501_ProfileLikelihoodCalculator_limit.C and rs502_ProfileLikelihoodCalculator_significance.C for getting the interval limits and significance using the ProfileLikelihoodCalculator. The tutorials can be run on a set of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:12644,interface,interface,12644,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['interface'],['interface']
Integrability,"ve reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65843,inject,injected,65843,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['inject'],['injected']
Integrability,"ve the definition of a class to use it, or to; inherit from it. In these cases go ahead and ``#include`` that header file. Be; aware however that there are many cases where you don't need to have the full; definition of a class. If you are using a pointer or reference to a class, you; don't need the header file. If you are simply returning a class instance from a; prototyped function or method, you don't need it. In fact, for most cases, you; simply don't need the definition of a class. And not ``#include``\ing speeds up; compilation. It is easy to try to go too overboard on this recommendation, however. You; **must** include all of the header files that you are using --- you can include; them either directly or indirectly through another header file. To make sure; that you don't accidentally forget to include a header file in your module; header, make sure to include your module header **first** in the implementation; file (as mentioned above). This way there won't be any hidden dependencies that; you'll find out about later. Keep ""Internal"" Headers Private; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Many modules have a complex implementation that causes them to use more than one; implementation (``.cpp``) file. It is often tempting to put the internal; communication interface (helper classes, extra functions, etc) in the public; module header file. Don't do this!. If you really need to do something like this, put a private header file in the; same directory as the source files, and include it locally. This ensures that; your private interface remains private and undisturbed by outsiders. .. note::. It's okay to put extra implementation methods in a public class itself. Just; make them private (or protected) and all is well. Use Namespace Qualifiers to Implement Previously Declared Functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When providing an out of line implementation of a function in a source file, do; not open namespace blocks in the sou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:32998,depend,dependencies,32998,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['depend'],['dependencies']
Integrability,"ve. Also, any loop should have at most one; directive applied to it (and a sequence of transformations built using; followup-attributes). Otherwise, which transformation will be applied; depends on implementation details such as the pass pipeline order. See :ref:`transformation-metadata` for details. '``llvm.loop.vectorize``' and '``llvm.loop.interleave``'; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Metadata prefixed with ``llvm.loop.vectorize`` or ``llvm.loop.interleave`` are; used to control per-loop vectorization and interleaving parameters such as; vectorization width and interleave count. These metadata should be used in; conjunction with ``llvm.loop`` loop identification metadata. The; ``llvm.loop.vectorize`` and ``llvm.loop.interleave`` metadata are only; optimization hints and the optimizer will only interleave and vectorize loops if; it believes it is safe to do so. The ``llvm.loop.parallel_accesses`` metadata; which contains information about loop-carried memory dependencies can be helpful; in determining the safety of these transformations. '``llvm.loop.interleave.count``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata suggests an interleave count to the loop interleaver.; The first operand is the string ``llvm.loop.interleave.count`` and the; second operand is an integer specifying the interleave count. For; example:. .. code-block:: llvm. !0 = !{!""llvm.loop.interleave.count"", i32 4}. Note that setting ``llvm.loop.interleave.count`` to 1 disables interleaving; multiple iterations of the loop. If ``llvm.loop.interleave.count`` is set to 0; then the interleave count will be determined automatically. '``llvm.loop.vectorize.enable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata selectively enables or disables vectorization for the loop. The; first operand is the string ``llvm.loop.vectorize.enable`` and the second operand; is a bit. If the bit operand value is 1 vectorization is enabled. A value of; 0 d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:296700,depend,dependencies,296700,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependencies']
Integrability,"ve; their own scopes. Control Flow; ============. CMake features the same basic control flow constructs you would expect in any; scripting language, but there are a few quirks because, as with everything in; CMake, control flow constructs are commands. If, ElseIf, Else; ----------------. .. note::; For the full documentation on the CMake if command go; `here <https://cmake.org/cmake/help/v3.4/command/if.html>`_. That resource is; far more complete. In general CMake if blocks work the way you'd expect:. .. code-block:: cmake. if(<condition>); message(""do stuff""); elseif(<condition>); message(""do other stuff""); else(); message(""do other other stuff""); endif(). The single most important thing to know about CMake's if blocks coming from a C; background is that they do not have their own scope. Variables set inside; conditional blocks persist after the ``endif()``. Loops; -----. The most common form of the CMake ``foreach`` block is:. .. code-block:: cmake. foreach(var ...); message(""do stuff""); endforeach(). The variable argument portion of the ``foreach`` block can contain dereferenced; lists, values to iterate, or a mix of both:. .. code-block:: cmake. foreach(var foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var ${my_list}); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var ${my_list} out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. There is also a more modern CMake foreach syntax. The code below is equivalent; to the code above:. .. code-block:: cmake. foreach(var IN ITEMS foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var IN LISTS my_list); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var IN LISTS my_list ITEMS out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. Similar to the conditional statements, these generally behave how you woul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:8308,message,message,8308,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['message'],['message']
Integrability,"vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polymorphic objects. It is a combination of a chained; hash table with intrusive links (uniqued objects are required to inherit from; FoldingSetNode) that uses :ref:`SmallVector <dss_smallvector>` as part of its ID; process. Consider a case where you want to implement a ""getOrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which point we would have to delete it; and return the node that already exists. To support this style of client, FoldingSet perform a query with a; FoldingSetNodeID (which wraps SmallVector) that can be used to describe the; element that we want to query for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take place. Construction of the ID usually does not require heap traffic. Because FoldingSet uses intrusive links, it can support polymorphic objects in; the set (for example, you can have SDNode instances mixed with LoadSDNodes).; Because the elements are individually allocated, pointers to the elements are; stable: inserting or removing elements does not invalidate any pointers to other; elements. .. _dss_set:. <set>; ^^^^^. ``std::set`` is a reasonable all-around set class, which is decent at many; things but great at nothing. std::set allocates memory for each element; inserted (thus it is very malloc intensive) and typically stores three pointers; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:82578,wrap,wraps,82578,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wraps']
Integrability,"ved word, the statements following the ``else`` are processed. If the; value is false and there is no ``else`` arm, no statements are processed. Because the braces around the ``then`` statements are optional, this grammar rule; has the usual ambiguity with ""dangling else"" clauses, and it is resolved in; the usual way: in a case like ``if v1 then if v2 then {...} else {...}``, the; ``else`` associates with the inner ``if`` rather than the outer one. The :token:`IfBody` of the then and else arms of the ``if`` establish an; inner scope. Any ``defvar`` variables defined in the bodies go out of scope; when the bodies are finished (see `Defvar in a Record Body`_ for more details). The ``if`` statement can also be used in a record :token:`Body`. ``assert`` --- check that a condition is true; ---------------------------------------------. The ``assert`` statement checks a boolean condition to be sure that it is true; and prints an error message if it is not. .. productionlist::; Assert: ""assert"" `condition` "","" `message` "";"". If the boolean condition is true, the statement does nothing. If the; condition is false, it prints a nonfatal error message. The **message**, which; can be an arbitrary string expression, is included in the error message as a; note. The exact behavior of the ``assert`` statement depends on its; placement. * At top level, the assertion is checked immediately. * In a record definition, the statement is saved and all assertions are; checked after the record is completely built. * In a class definition, the assertions are saved and inherited by all; the subclasses and records that inherit from the class. The assertions are; then checked when the records are completely built. * In a multiclass definition, the assertions are saved with the other; components of the multiclass and then checked each time the multiclass; is instantiated with ``defm``. Using assertions in TableGen files can simplify record checking in TableGen; backends. Here is an example of an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:49113,message,message,49113,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['message'],['message']
Integrability,ved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with empty anonymous union member; Unknown. 2081; CD5; Deduced return type in redeclaration or specialization of function template; Unknown. 2082; CD4; Referring to parameters in unevaluated operands of default arguments; Clang 11. 2083; CD5; Incorrect cases of odr-use; Partial. ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140696,depend,dependent,140696,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"ven the Objective-C type system). Placing on C functions: When placing the attribute; 'cf_returns_retained' on the declarations of C functions, the analyzer; interprets the function as:. Returning a Core Foundation Object; Treating the function as if it its name; contained the keywords ""create"" or ""copy"". This means the; returned object as a +1 retain count that must be released by the caller, either; by sending a release message (via toll-free bridging to an Objective-C; object pointer), or calling CFRelease or a similar function. Example. $ cat test.m; $ cat test.m; #import <Cocoa/Cocoa.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_RETAINED; #if __has_feature(attribute_cf_returns_retained); #define CF_RETURNS_RETAINED __attribute__((cf_returns_retained)); #else; #define CF_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSDate*) returnsCFRetained CF_RETURNS_RETAINED;; - (NSDate*) alsoReturnsRetained;; - (NSDate*) returnsNSRetained NS_RETURNS_RETAINED;; @end. CF_RETURNS_RETAINED; CFDateRef returnsRetainedCFDate() {; return CFDateCreate(0, CFAbsoluteTimeGetCurrent());; }. @implementation MyClass; - (NSDate*) returnsCFRetained {; return (NSDate*) returnsRetainedCFDate(); // No leak.; }. - (NSDate*) alsoReturnsRetained {; return (NSDate*) returnsRetainedCFDate(); // Always report a leak.; }. - (NSDate*) returnsNSRetained {; return (NSDate*) returnsRetainedCFDate(); // Report a leak when using GC.; }; @end. Running scan-build on this example produces the following output:. Attribute 'cf_returns_not_retained'; (Clang-specific); The 'cf_returns_not_retained' attribute is the complement of 'cf_returns_retained'. Where a function or; method may appear to obey the Core Foundation or Cocoa conventions and return; a retained Core Foundation object, this attribute can be used to indicate that; the object reference returned should not be considered as an; ""owning"" ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:7878,interface,interface,7878,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['interface'],['interface']
Integrability,"ver, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ```. When using Geant3, the common block is filled by Geant3 routines at each; step and only the `TTree::Fill` method needs to be called. In this; example we emulate the Geant3 step routine with the `helixStep`; function. We also emulate the filling of the particle values. The calls; to the `Branch` methods are the same as if Geant3 were used. ``` {.cpp}; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; // field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];. Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];. vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:44366,rout,routine,44366,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['rout'],['routine']
Integrability,"vergence constraints as; follows:. .. code-block:: llvm. define void @example_shader() convergent {; %entry = call token @llvm.experimental.convergence.entry(); ...; %color = call T @textureSample(U %texture, V %coordinates) [ ""convergencectrl""(token %entry) ]; br i1 %condition, label %then, label %end. then:; call void @use(T %color); br label %end. end:; ret void; }. The :ref:`llvm.experimental.convergence.entry <llvm.experimental.convergence.entry>`; intrinsic is itself ``convergent``, and we expect it to communicate at least; among all threads of the same ""quad"" -- a group of 2x2 pixels that are; evaluated together for the purpose of approximating screen-space derivatives.; This fact is not part of the generic LLVM IR semantics; it would have to be; defined somewhere else, for example as part of target-specific ABI definitions; and/or in reference to some relevant API specs. Since the ``@textureSample`` call then uses the token produced by the entry; intrinsic in its ``convergencectrl`` bundle, and has no additional control; dependencies, it must communicate among the same set of threads. This indicates; to generic program transforms that sinking the ``@textureSample`` call is; forbidden. (A program transform can still sink the call if it can prove somehow,; e.g. by leaning on target-specific callbacks that can analyze the program with; additional knowledge, that ``%condition`` is always uniform across the threads; referenced by the *convergence token* ``%entry``.). .. _convergence_example_reductions:. Reductions inside divergent control flow; ----------------------------------------. The following example shows that merging common code of branches can be; incorrect in the face of convergent operations:. .. code-block:: c++. void example_kernel() {; delta = ...; if (delta > 0) {; total_gains = subgroupAdd(delta);; ...; } else {; total_losses = subgroupAdd(delta);; ...; }; }. The ``subgroupAdd`` computing the ``total_gains`` will be executed by the; subset of thr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:5972,depend,dependencies,5972,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['depend'],['dependencies']
Integrability,"version 5.16 and version 5.18 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities. Binaries for all supported platforms are available at:. http://root.cern.ch/root/Version520.html; Versions for AFS have also been updated. See the list of supported; platforms:; http://root.cern.ch/Welcome.html. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Ilka Antcheva,; Jean-Fran�ois Bastien, ; Bertrand Bellenot,; Rene Brun,; Philippe Canal,; Olivier Couet,; Valeri Fine,; Leo Franco, ; Gerri Ganis,; Andrei Gheata,; Mihaela Gheata,; David Gonzalez Maline, ; Andreas Hoecker, ; Jan Iwaszkiewicz, ; Lukasz Janyst, ; Anna Kreshuk, ; Wim Lavrijsen,; Sergei Linev,; Anar Manafov, ; Diego Marcos-Segura, ; Lorenzo Moneta,; Axel Naumann,; Mathieu de Naurois, ; Eddy Offermann, ; Valeriy Onuchin,; Timur Pocheptsov,; Fons Rademakers,; Paul Russo, ; Alja Tadel, ; Matevz Tadel, ; Wouter Verkerke, ; Guido Volpi, ; Hady Zalek . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v520/index.html:1098,protocol,protocols,1098,doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v520/index.html,3,"['interface', 'protocol']","['interfaces', 'protocols']"
Integrability,"vert?. * Use your best judgment. If you're uncertain, please start an email on; the commit thread asking for assistance. We aren't trying to enumerate; every case, but rather give a set of guidelines.; * You should be sure that reverting the change improves the stability of tip; of tree. Sometimes reverting one change in a series can worsen things; instead of improving them. We expect reasonable judgment to ensure that; the proper patch or set of patches is being reverted.; * The commit message for the reverting commit should explain why patch; is being reverted.; * It is customary to respond to the original commit email mentioning the; revert. This serves as both a notice to the original author that their; patch was reverted, and helps others following llvm-commits track context.; * Ideally, you should have a publicly reproducible test case ready to share.; Where possible, we encourage sharing of test cases in commit threads, or; in PRs. We encourage the reverter to minimize the test case and to prune; dependencies where practical. This even applies when reverting your own; patch; documenting the reasons for others who might be following along; is critical.; * It is not considered reasonable to revert without at least the promise to; provide a means for the patch author to debug the root issue. If a situation; arises where a public reproducer can not be shared for some reason (e.g.; requires hardware patch author doesn't have access to, sharp regression in; compile time of internal workload, etc.), the reverter is expected to be; proactive about working with the patch author to debug and test candidate; patches.; * Reverts should be reasonably timely. A change submitted two hours ago; can be reverted without prior discussion. A change submitted two years ago; should not be. Where exactly the transition point is is hard to say, but; it's probably in the handful of days in tree territory. If you are unsure,; we encourage you to reply to the commit thread, give the au",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:21697,depend,dependencies,21697,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['depend'],['dependencies']
Integrability,"very simple: it expects to be called when the current; token is a ``tok_number`` token. It takes the current number value,; creates a ``NumberExprAST`` node, advances the lexer to the next token,; and finally returns. There are some interesting aspects to this. The most important one is; that this routine eats all of the tokens that correspond to the; production and returns the lexer buffer with the next token (which is; not part of the grammar production) ready to go. This is a fairly; standard way to go for recursive descent parsers. For a better example,; the parenthesis operator is defined like this:. .. code-block:: c++. /// parenexpr ::= '(' expression ')'; static std::unique_ptr<ExprAST> ParseParenExpr() {; getNextToken(); // eat (.; auto V = ParseExpression();; if (!V); return nullptr;. if (CurTok != ')'); return LogError(""expected ')'"");; getNextToken(); // eat ).; return V;; }. This function illustrates a number of interesting things about the; parser:. 1) It shows how we use the LogError routines. When called, this function; expects that the current token is a '(' token, but after parsing the; subexpression, it is possible that there is no ')' waiting. For example,; if the user types in ""(4 x"" instead of ""(4)"", the parser should emit an; error. Because errors can occur, the parser needs a way to indicate that; they happened: in our parser, we return null on an error. 2) Another interesting aspect of this function is that it uses recursion; by calling ``ParseExpression`` (we will soon see that; ``ParseExpression`` can call ``ParseParenExpr``). This is powerful; because it allows us to handle recursive grammars, and keeps each; production very simple. Note that parentheses do not cause construction; of AST nodes themselves. While we could do it this way, the most; important role of parentheses are to guide the parser and provide; grouping. Once the parser constructs the AST, parentheses are not; needed. The next simple production is for handling variable re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:8572,rout,routines,8572,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['rout'],['routines']
Integrability,"ves the; email format unchanged besides the commit URL. Straw Man Migration Plan; ========================. Step #1 : Before The Move; -------------------------. 1. Update docs to mention the move, so people are aware of what is going on.; 2. Set up a read-only version of the GitHub project, mirroring our current SVN; repository.; 3. Add the required bots to implement the commit emails, as well as the; umbrella repository update (if the multirepo is selected) or the read-only; Git views for the sub-projects (if the monorepo is selected). Step #2 : Git Move; ------------------. 4. Update the buildbots to pick up updates and commits from the GitHub; repository. Not all bots have to migrate at this point, but it'll help; provide infrastructure testing.; 5. Update Phabricator to pick up commits from the GitHub repository.; 6. LNT and llvmlab have to be updated: they rely on unique monotonically; increasing integer across branch [MatthewsRevNum]_.; 7. Instruct downstream integrators to pick up commits from the GitHub; repository.; 8. Review and prepare an update for the LLVM documentation. Until this point nothing has changed for developers, it will just; boil down to a lot of work for buildbot and other infrastructure; owners. The migration will pause here until all dependencies have cleared, and all; problems have been solved. Step #3: Write Access Move; --------------------------. 9. Collect developers' GitHub account information, and add them to the project.; 10. Switch the SVN repository to read-only and allow pushes to the GitHub repository.; 11. Update the documentation.; 12. Mirror Git to SVN. Step #4 : Post Move; -------------------. 13. Archive the SVN repository.; 14. Update links on the LLVM website pointing to viewvc/klaus/phab etc. to; point to GitHub instead. GitHub Repository Description; =============================. Monorepo; ----------------. The LLVM git repository hosted at https://github.com/llvm/llvm-project contains all; sub-projects in a single ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:7519,integrat,integrators,7519,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['integrat'],['integrators']
Integrability,"ves. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to mi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15080,interface,interface,15080,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['interface'],['interface']
Integrability,"via:. ~~~{.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ~~~. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by TGeoNavigator; are interfaced by TGeoManager and will act on the current; navigator. \anchor GP02b; ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ~~~{.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ~~~. Initializing this point can be done like:. ~~~{.cpp}; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; ~~~. \anchor GP02c; ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to know the current direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ~~~{.cpp}; Const Double_t *cdir = gGeoManager->GetCurren",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:64296,interface,interfaced,64296,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interfaced']
Integrability,"vious declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note + {{previous declaration is here}}. A range can also be specified by ``<n>-<m>``. For example:. .. code-block:: c++. void f(); // expected-note 0-1 {{previous declaration is here}}. In this example, the diagnostic may appear only once, if at all. .. _DiagnosticMatching:. Matching Modes; ~~~~~~~~~~~~~~. The default matching mode is simple string, which looks for the expected text; that appears between the first `{{` and `}}` pair of the comment. The string is; interpreted just as-is, with one exception: the sequence `\n` is converted to a; single newline character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-erro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:161229,message,message,161229,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['message'],['message']
Integrability,"virtual methods to do their work. All; of these methods should return ``true`` if they modified the program, or; ``false`` if they didn't. .. _writing-an-llvm-pass-doInitialization-mod:. The ``doInitialization(Module &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Module &M);. The ``doInitialization`` method is allowed to do most of the things that; ``FunctionPass``\ es are not allowed to do. They can add and remove functions,; get pointers to functions, etc. The ``doInitialization`` method is designed to; do simple initialization type of stuff that does not depend on the functions; being processed. The ``doInitialization`` method call is not scheduled to; overlap with any other pass executions (thus it should be very fast). A good example of how this method should be used is the `LowerAllocations; <https://llvm.org/doxygen/LowerAllocations_8cpp-source.html>`_ pass. This pass; converts ``malloc`` and ``free`` instructions into platform dependent; ``malloc()`` and ``free()`` function calls. It uses the ``doInitialization``; method to get a reference to the ``malloc`` and ``free`` functions that it; needs, adding prototypes to the module if necessary. .. _writing-an-llvm-pass-runOnFunction:. The ``runOnFunction`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnFunction(Function &F) = 0;. The ``runOnFunction`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a ``true`` value; should be returned if the function is modified. .. _writing-an-llvm-pass-doFinalization-mod:. The ``doFinalization(Module &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization(Module &M);. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnFunction; <writing-an-llvm-pass-runOnFunction>` for every function in the program b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:19173,depend,dependent,19173,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['depend'],['dependent']
Integrability,"visibility on all symbols -- behavior; for other linkages/visibilities was not well defined. #. It constrained and/or prohibited the use of features requiring runtime; support, e.g. static initializers or thread local storage. As a result of these restrictions not all language features supported by LLVM; worked under MCJIT, and objects to be loaded under the JIT had to be compiled to; target it (precluding the use of precompiled code from other sources under the; JIT). RuntimeDyld also provided very limited visibility into the linking process; itself: Clients could access conservative estimates of section size; (RuntimeDyld bundled stub size and padding estimates into the section size; value) and the final relocated bytes, but could not access RuntimeDyld's; internal object representations. Eliminating these restrictions and limitations was one of the primary motivations; for the development of JITLink. The llvm-jitlink tool; =====================. The ``llvm-jitlink`` tool is a command line wrapper for the JITLink library.; It loads some set of relocatable object files and then links them using; JITLink. Depending on the options used it will then execute them, or validate; the linked memory. The ``llvm-jitlink`` tool was originally designed to aid JITLink development by; providing a simple environment for testing. Basic usage; -----------. By default, ``llvm-jitlink`` will link the set of objects passed on the command; line, then search for a ""main"" function and execute it:. .. code-block:: sh. % cat hello-world.c; #include <stdio.h>. int main(int argc, char *argv[]) {; printf(""hello, world!\n"");; return 0;; }. % clang -c -o hello-world.o hello-world.c; % llvm-jitlink hello-world.o; Hello, World!. Multiple objects may be specified, and arguments may be provided to the JIT'd; main function using the -args option:. .. code-block:: sh. % cat print-args.c; #include <stdio.h>. void print_args(int argc, char *argv[]) {; for (int i = 0; i != argc; ++i); printf(""arg %i is \",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:37025,wrap,wrapper,37025,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['wrap'],['wrapper']
Integrability,"vm built in ${LLVM_BUILD_MODE} mode.""). if(NOT MSVC_IDE); set(LLVM_ENABLE_ASSERTIONS ${ENABLE_ASSERTIONS}; CACHE BOOL ""Enable assertions""); # Assertions should follow llvm-config's.; mark_as_advanced(LLVM_ENABLE_ASSERTIONS); endif(). set(LLVM_TOOLS_BINARY_DIR ${TOOLS_BINARY_DIR} CACHE PATH ""Path to llvm/bin""); set(LLVM_LIBRARY_DIR ${LIBRARY_DIR} CACHE PATH ""Path to llvm/lib""); set(LLVM_MAIN_INCLUDE_DIR ${INCLUDE_DIR} CACHE PATH ""Path to llvm/include""); set(LLVM_BINARY_DIR ${LLVM_OBJ_ROOT} CACHE PATH ""Path to LLVM build tree""). set(LLVM_DIR ""${LLVM_BINARY_DIR}""). # Normalize LLVM_CMAKE_PATH. --cmakedir might contain backslashes.; # CMake assumes slashes as PATH.; file(TO_CMAKE_PATH ${LLVM_CONFIG_CMAKE_PATH} LLVM_CMAKE_PATH). find_program(LLVM_TABLEGEN_EXE ""llvm-tblgen"" ${LLVM_TOOLS_BINARY_DIR}; NO_DEFAULT_PATH). set(LLVMCONFIG_FILE ""${LLVM_CMAKE_PATH}/LLVMConfig.cmake""); if(EXISTS ${LLVMCONFIG_FILE}); list(APPEND CMAKE_MODULE_PATH ""${LLVM_CMAKE_PATH}""); include(${LLVMCONFIG_FILE}); else(); message(FATAL_ERROR ""Not found: ${LLVMCONFIG_FILE}""); endif(); # We already FORCE-d the CACHE value to OFF, but LLVMConfig.cmake might have; # set the variable to ON again...; set(LLVM_ENABLE_WARNINGS OFF). # They are used as destination of target generators.; # We try to keep these locations consistent with the builtin_llvm. This is important; # for the LLVMRES target.; # FIXME: In longer term, we do not really need this and may want to adjust LLVMRES.; set(LLVM_RUNTIME_OUTPUT_INTDIR ${CMAKE_CURRENT_BINARY_DIR}/llvm-project/llvm/${CMAKE_CFG_INTDIR}/bin); set(LLVM_LIBRARY_OUTPUT_INTDIR ${CMAKE_CURRENT_BINARY_DIR}/llvm-project/llvm/${CMAKE_CFG_INTDIR}/lib). if(WIN32 OR CYGWIN); # DLL platform -- put DLLs into bin.; set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_RUNTIME_OUTPUT_INTDIR}); else(); set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_LIBRARY_OUTPUT_INTDIR}); endif(). option(LLVM_INSTALL_TOOLCHAIN_ONLY; ""Only include toolchain files in the 'install' target."" OFF). option(LLVM_FORCE_USE_OLD_HOST_TOOLC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:14710,message,message,14710,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['message'],['message']
Integrability,"vm-install-name-tool` [*options*] *input*. DESCRIPTION; -----------. :program:`llvm-install-name-tool` is a tool to manipulate dynamic shared library; install names and rpaths listed in a Mach-O binary. For most scenarios, it works as a drop-in replacement for Apple's; :program:`install_name_tool`. OPTIONS; --------; At least one of the following options are required, and some options can be; combined with other options. Options :option:`-add_rpath`, :option:`-delete_rpath`,; and :option:`-rpath` can be combined in an invocation only if they do not share; the same `<rpath>` value. .. option:: -add_rpath <rpath>. Add an rpath named ``<rpath>`` to the specified binary. Can be specified multiple; times to add multiple rpaths. Throws an error if ``<rpath>`` is already listed in; the binary. .. option:: -change <old_install_name> <new_install_name>. Change an install name ``<old_install_name>`` to ``<new_install_name>`` in the; specified binary. Can be specified multiple times to change multiple dependent shared; library install names. Option is ignored if ``<old_install_name>`` is not listed; in the specified binary. .. option:: -delete_rpath <rpath>. Delete an rpath named ``<rpath>`` from the specified binary. Can be specified multiple; times to delete multiple rpaths. Throws an error if ``<rpath>`` is not listed in; the binary. .. option:: -delete_all_rpaths. Deletes all rpaths from the binary. .. option:: --help, -h. Print a summary of command line options. .. option:: -id <name>. Change shared library's identification name under LC_ID_DYLIB to ``<name>`` in the; specified binary. If specified multiple times, only the last :option:`-id` option is; selected. Option is ignored if the specified Mach-O binary is not a dynamic shared library. .. option:: -rpath <old_rpath> <new_rpath>. Change an rpath named ``<old_rpath>`` to ``<new_rpath>`` in the specified binary. Can be specified; multiple times to change multiple rpaths. Throws an error if ``<old_rpath>`` is not liste",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-install-name-tool.rst:1231,depend,dependent,1231,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-install-name-tool.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-install-name-tool.rst,1,['depend'],['dependent']
Integrability,"void @llvm.memset.inline.p0.p0.i64(ptr <dest>, i8 <val>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memset.inline.*``' intrinsics fill a block of memory with a; particular byte value and guarantees that no external functions are called. Note that, unlike the standard libc function, the ``llvm.memset.inline.*``; intrinsics do not return a value, take an extra isvolatile argument and the; pointer can be in specified address spaces. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination to fill, the second; is the byte value with which to fill it, the third argument is a constant; integer argument specifying the number of bytes to fill, and the fourth; is a boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first argument. If the ``isvolatile`` parameter is ``true``, the ``llvm.memset.inline`` call is; a :ref:`volatile operation <volatile>`. The detailed access behavior is not; very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memset.inline.*``' intrinsics fill ""len"" bytes of memory starting; at the destination location. If the argument is known to be; aligned to some boundary, this can be specified as an attribute on; the argument. ``len`` must be a constant expression.; If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to; the arguments.; If ``<len>`` is not a well-defined value, the behavior is undefined.; If ``<len>`` is not zero, ``<dest>`` should be well-defined, otherwise the; behavior is undefined. The behavior of '``llvm.memset.inline.*``' is equivalent to the behavior of; '``llvm.memset.*``', but the generated code is guaranteed not to call any; external functions. .. _int_sqrt:. '``llvm.sqrt.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.sqrt`` on any; floating-point or vector of floating-point type. Not all targets support;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:555864,depend,depend,555864,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability,"w pass manager by default.""); if(NOT LLVM_ENABLE_NEW_PASS_MANAGER); message(FATAL_ERROR ""Enabling the legacy pass manager on the cmake level is""; "" no longer supported.""); endif(). include(HandleLLVMOptions). ######. # Configure all of the various header file fragments LLVM uses which depend on; # configuration variables.; set(LLVM_ENUM_TARGETS """"); set(LLVM_ENUM_ASM_PRINTERS """"); set(LLVM_ENUM_ASM_PARSERS """"); set(LLVM_ENUM_DISASSEMBLERS """"); set(LLVM_ENUM_TARGETMCAS """"); set(LLVM_ENUM_EXEGESIS """"); foreach(t ${LLVM_TARGETS_TO_BUILD}); set( td ${LLVM_MAIN_SRC_DIR}/lib/Target/${t} ). # Make sure that any experimental targets were passed via; # LLVM_EXPERIMENTAL_TARGETS_TO_BUILD, not LLVM_TARGETS_TO_BUILD.; # We allow experimental targets that are not in LLVM_ALL_EXPERIMENTAL_TARGETS,; # as long as they are passed via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.; if ( NOT ""${t}"" IN_LIST LLVM_ALL_TARGETS AND NOT ""${t}"" IN_LIST LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ); if( ""${t}"" IN_LIST LLVM_ALL_EXPERIMENTAL_TARGETS ); message(FATAL_ERROR ""The target `${t}' is experimental and must be passed ""; ""via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.""); else(); message(FATAL_ERROR ""The target `${t}' is not a core tier target. It may be ""; ""experimental, if so it must be passed via ""; ""LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.\n""; ""Core tier targets: ${LLVM_ALL_TARGETS}\n""; ""Known experimental targets: ${LLVM_ALL_EXPERIMENTAL_TARGETS}""); endif(); else(); set(LLVM_ENUM_TARGETS ""${LLVM_ENUM_TARGETS}LLVM_TARGET(${t})\n""); string(TOUPPER ${t} T_UPPER); set(LLVM_HAS_${T_UPPER}_TARGET 1); endif(). file(GLOB asmp_file ""${td}/*AsmPrinter.cpp""); if( asmp_file ); set(LLVM_ENUM_ASM_PRINTERS; ""${LLVM_ENUM_ASM_PRINTERS}LLVM_ASM_PRINTER(${t})\n""); endif(); if( EXISTS ${td}/AsmParser/CMakeLists.txt ); set(LLVM_ENUM_ASM_PARSERS; ""${LLVM_ENUM_ASM_PARSERS}LLVM_ASM_PARSER(${t})\n""); endif(); if( EXISTS ${td}/Disassembler/CMakeLists.txt ); set(LLVM_ENUM_DISASSEMBLERS; ""${LLVM_ENUM_DISASSEMBLERS}LLVM_DISASSEMBLER(${t})\n""); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:40101,message,message,40101,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,w; tutorial-hist-FirstContour; tutorial-geom-na49view; tutorial-tree-ntuple1; tutorial-tree-spider; tutorial-io-hadd; tutorial-io-loopdir; tutorial-io-copyFiles); set(geom-na49view-depends tutorial-geom-geometry); set(multicore-mt102_readNtuplesFillHistosAndFit-depends tutorial-multicore-mt101_fillNtuples); set(multicore-mp102_readNtuplesFillHistosAndFit-depends tutorial-multicore-mp101_fillNtuples); set(multicore-mp105_processEntryList-depends tutorial-multicore-mp104_processH1). #--many histfactory and roostats tutorials depending on having creating the file first with histfactory and example_combined_GaussExample_model.root; foreach(tname histfactory-hf001_example; roostats-ModelInspector; roostats-OneSidedFrequentistUpperLimitWithBands; roostats-OneSidedFrequentistUpperLimitWithBands; roostats-StandardBayesianMCMCDemo; roostats-StandardBayesianNumericalDemo; roostats-StandardFeldmanCousinsDemo; roostats-StandardFrequentistDiscovery; roostats-StandardHistFactoryPlotsWithCategories; roostats-StandardHypoTestDemo; roostats-StandardHypoTestInvDemo; roostats-StandardProfileInspectorDemo; roostats-StandardProfileLikelihoodDemo; roostats-StandardTestStatDistributionDemo; roostats-TwoSidedFrequentistUpperLimitWithBands); set(${tname}-depends tutorial-roostats-CreateExampleFile); set(${tname}-py-depends tutorial-roostats-CreateExampleFile); endforeach(). #--dependency for TMVA tutorials; set (tmva-TMVAClassificationApplication-depends tutorial-tmva-TMVAClassification); set (tmva-TMVAClassificationCategory-depends tutorial-tmva-TMVAClassification); set (tmva-TMVAClassificationCategoryApplication-depends tutorial-tmva-TMVAClassificationCategory); set (tmva-TMVAMulticlass-depends tutorial-tmva-TMVAMultipleBackgroundExample); set (tmva-TMVAMulticlassApplication-depends tutorial-tmva-TMVAMulticlass); set (tmva-TMVARegressionApplication-depends tutorial-tmva-TMVARegression); set (tmva-TMVACrossValidationRegression-depends tutorial-tmva-TMVARegressionApplication); set (tmva-TMVA,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:18976,depend,depends,18976,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,2,['depend'],['depends']
Integrability,"watch?v=K2KqEV866Ro>`_; - *V Vasilev*, CERN PH-SFT, 2013; - Vassil Vasilev (Princeton University) explains how Cling enables interactivity in C++, and illustrates the type introspection mechanism provided by the interpreter.; * - `Introducing Cling, a C++ Interpreter Based on Clang/LLVM <https://www.youtube.com/watch?v=f9Xfh8pv3Fs>`_; - *Axel Naumann* 2012 Googletechtalks; - Axel Naumann (CERN) discusses Cling’s most relevant features: abstract syntax tree (AST) production, wrapped functions, global initialization of a function, delay expression evaluation at runtime, and dynamic scopes.; * - `Creating Cling, an interactive interpreter interface <https://www.youtube.com/watch?v=BjmGOMJWeAo>`_; - *Axel Naumann* 2010 LLVM Developers’ meeting; - This presentation introduces Cling, an ahead-of-time compiler that extends C++ for ease of use as an interpreter.; . ; .. list-table:: Demos, tutorials, Cling’s ecosystem:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Cling integration | CLion <https://www.jetbrains.com/help/clion/cling-integration.html#install-cling>`_; - 2022.2 Version; - CLion uses Cling to integrate the `Quick Documentation <https://www.jetbrains.com/help/clion/2022.2/viewing-inline-documentation.html>`_ popup by allowing you to view the value of the expressions evaluated at compile time.; * - `Interactive C++ for Data Science <https://www.youtube.com/watch?v=23E0S3miWB0&t=2716s>`_; - *Vassil Vassilev* 2021 CppCon (The C++ Conference); - In this video, the author discusses how Cling enables interactive C++ for Data Science projects. ; * - `Cling -- Beyond Just Interpreting C++ <https://blog.llvm.org/posts/2021-03-25-cling-beyond-just-interpreting-cpp/>`_; - *Vassil Vassilev* 2021 The LLVM Project Blog; - This blog page discusses how Cling enables template Instantiation on demand, language interoperability on demand, interpreter/compiler as a service, plugins extension.; * - `TinySpec-Cling <https://github.com/nwoeanhinnogaehr/ti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:1966,integrat,integration,1966,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['integrat'],['integration']
Integrability,"werpc64"" ""powerpc"" LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT ""${LLVM_HOST_TRIPLE}""); else(); # Only set default triple when native target is enabled.; if (LLVM_NATIVE_TARGET); set(LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT ""${LLVM_HOST_TRIPLE}""); endif(); endif(). set(LLVM_DEFAULT_TARGET_TRIPLE ""${LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT}"" CACHE STRING; ""Default target for which LLVM will generate code."" ); message(STATUS ""LLVM default target triple: ${LLVM_DEFAULT_TARGET_TRIPLE}""). set(LLVM_TARGET_TRIPLE ""${LLVM_DEFAULT_TARGET_TRIPLE}""). if(WIN32 OR CYGWIN); if(BUILD_SHARED_LIBS OR LLVM_BUILD_LLVM_DYLIB); set(LLVM_ENABLE_PLUGINS_default ON); else(); set(LLVM_ENABLE_PLUGINS_default OFF); endif(); else(); set(LLVM_ENABLE_PLUGINS_default ${LLVM_ENABLE_PIC}); endif(); option(LLVM_ENABLE_PLUGINS ""Enable plugin support"" ${LLVM_ENABLE_PLUGINS_default}). set(LLVM_ENABLE_NEW_PASS_MANAGER TRUE CACHE BOOL; ""Enable the new pass manager by default.""); if(NOT LLVM_ENABLE_NEW_PASS_MANAGER); message(FATAL_ERROR ""Enabling the legacy pass manager on the cmake level is""; "" no longer supported.""); endif(). include(HandleLLVMOptions). ######. # Configure all of the various header file fragments LLVM uses which depend on; # configuration variables.; set(LLVM_ENUM_TARGETS """"); set(LLVM_ENUM_ASM_PRINTERS """"); set(LLVM_ENUM_ASM_PARSERS """"); set(LLVM_ENUM_DISASSEMBLERS """"); set(LLVM_ENUM_TARGETMCAS """"); set(LLVM_ENUM_EXEGESIS """"); foreach(t ${LLVM_TARGETS_TO_BUILD}); set( td ${LLVM_MAIN_SRC_DIR}/lib/Target/${t} ). # Make sure that any experimental targets were passed via; # LLVM_EXPERIMENTAL_TARGETS_TO_BUILD, not LLVM_TARGETS_TO_BUILD.; # We allow experimental targets that are not in LLVM_ALL_EXPERIMENTAL_TARGETS,; # as long as they are passed via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.; if ( NOT ""${t}"" IN_LIST LLVM_ALL_TARGETS AND NOT ""${t}"" IN_LIST LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ); if( ""${t}"" IN_LIST LLVM_ALL_EXPERIMENTAL_TARGETS ); message(FATAL_ERROR ""The target `${t}' is experimental and must be passed ""; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:39149,message,message,39149,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"where the function is evaluated in a relatively short time and/or; where the parameter errors must be calculated reliably. In addition all; constants set in MnStrategy can be changed individually by the user,; e.g. the number of iteration cycles in the numerical gradient. ## Parameter errors ##. M is usually used to find the ""best"" values of a set of parameters,; where ""best"" is defined as those values which minimize a given function,; $\mbox{FCN}$. The width of the function minimum, or more generally,; the shape of the function in some neighbourhood of the minimum, gives; information about the *uncertainty* in the best parameter values, often; called by physicists the *parameter errors*. An important feature of M; is that it offers several tools to analyze the parameter errors. ### $\mbox{FCN}$ normalization and the error definition ###. Whatever method is used to calculate the parameter errors, they will; depend on the overall (multiplicative) normalization of; $\mbox{FCN}$, in the sense that if the value of $\mbox{FCN}$ is; everywhere multiplied by a constant $\beta$, then the errors will be; decreased by a factor $\sqrt{\beta}$. Additive constants do not change; the parameter errors, but may imply a different goodness-of-fit; confidence level. Assuming that the user knows what the normalization of their; $\mbox{FCN}$ means, and also that they are interested in parameter; errors, the user can change the error definition which allows them to; define what they means by one ""error"", in terms of the change in the; $\mbox{FCN}$ value which should be caused by changing one parameter; by one ""error"". If the $\mbox{FCN}$ is the usual chisquare function; (defined below) and if the user wants the usual one-standard-deviation; errors, then the error definition (return value of the FCNBase::up(); method, see [howto:errordef]) should be $1.0$. If the $\mbox{FCN}$; is a negative-log-likelihood function, then the one-standard-deviation; value for FCNBase::up() to return is $0.5",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:13097,depend,depend,13097,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['depend'],['depend']
Integrability,"where they would not; otherwise exist is allowed; introducing stores to shared variables is not. See; `Optimization outside atomic`_. Notes for code generation; The one interesting restriction here is that it is not allowed to write to; bytes outside of the bytes relevant to a store. This is mostly relevant to; unaligned stores: it is not allowed in general to convert an unaligned store; into two aligned stores of the same width as the unaligned store. Backends are; also expected to generate an i8 store as an i8 store, and not an instruction; which writes to surrounding bytes. (If you are writing a backend for an; architecture which cannot satisfy these restrictions and cares about; concurrency, please send an email to llvm-dev.). Unordered; ---------. Unordered is the lowest level of atomicity. It essentially guarantees that races; produce somewhat sane results instead of having undefined behavior. It also; guarantees the operation to be lock-free, so it does not depend on the data; being part of a special atomic structure or depend on a separate per-process; global lock. Note that code generation will fail for unsupported atomic; operations; if you need such an operation, use explicit locking. Relevant standard; This is intended to match the Java memory model for shared variables. Notes for frontends; This cannot be used for synchronization, but is useful for Java and other; ""safe"" languages which need to guarantee that the generated code never; exhibits undefined behavior. Note that this guarantee is cheap on common; platforms for loads of a native width, but can be expensive or unavailable for; wider loads, like a 64-bit store on ARM. (A frontend for Java or other ""safe""; languages would normally split a 64-bit store on ARM into two 32-bit unordered; stores.). Notes for optimizers; In terms of the optimizer, this prohibits any transformation that transforms a; single load into multiple loads, transforms a store into multiple stores,; narrows a store, or stores a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:8163,depend,depend,8163,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,2,['depend'],['depend']
Integrability,"which is being miscompiled. The miscompilation debugger assumes that; the selected code generator is working properly. Advice for using bugpoint; =========================. ``bugpoint`` can be a remarkably useful tool, but it sometimes works in; non-obvious ways. Here are some hints and tips:. * In the code generator and miscompilation debuggers, ``bugpoint`` only works; with programs that have deterministic output. Thus, if the program outputs; ``argv[0]``, the date, time, or any other ""random"" data, ``bugpoint`` may; misinterpret differences in these data, when output, as the result of a; miscompilation. Programs should be temporarily modified to disable outputs; that are likely to vary from run to run. * In the `crash debugger`_, ``bugpoint`` does not distinguish different crashes; during reduction. Thus, if new crash or miscompilation happens, ``bugpoint``; will continue with the new crash instead. If you would like to stick to; particular crash, you should write check scripts to validate the error; message, see ``-compile-command`` in :doc:`CommandGuide/bugpoint`. * In the code generator and miscompilation debuggers, debugging will go faster; if you manually modify the program or its inputs to reduce the runtime, but; still exhibit the problem. * ``bugpoint`` is extremely useful when working on a new optimization: it helps; track down regressions quickly. To avoid having to relink ``bugpoint`` every; time you change your optimization however, have ``bugpoint`` dynamically load; your optimization with the ``-load`` option. * ``bugpoint`` can generate a lot of output and run for a long period of time.; It is often useful to capture the output of the program to file. For example,; in the C shell, you can run:. .. code-block:: console. $ bugpoint ... |& tee bugpoint.log. to get a copy of ``bugpoint``'s output in the file ``bugpoint.log``, as well; as on your terminal. * ``bugpoint`` cannot debug problems with the LLVM linker. If ``bugpoint``; crashes before you see",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:6470,message,message,6470,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['message'],['message']
Integrability,"will build just clang.; ninja check-clang This will run the clang tests. Clang Compiler Driver (Drop-in Substitute for GCC); The clang tool is the compiler driver and front-end, which is; designed to be a drop-in replacement for the gcc command. Here are; some examples of how to use the high-level driver:. $ cat t.c; #include <stdio.h>; int main(int argc, char **argv) { printf(""hello world\n""); }; $ clang t.c; $ ./a.out; hello world. The 'clang' driver is designed to work as closely to GCC as possible to; maximize portability. The only major difference between the two is that; Clang defaults to gnu99 mode while GCC defaults to gnu89 mode. If you see; weird link-time errors relating to inline functions, try passing -std=gnu89; to clang.; Examples of using Clang. $ cat ~/t.c; typedef float V __attribute__((vector_size(16)));; V foo(V a, V b) { return a+b*a; }. Preprocessing:. $ clang ~/t.c -E; # 1 ""/Users/sabre/t.c"" 1. typedef float V __attribute__((vector_size(16)));. V foo(V a, V b) { return a+b*a; }. Type checking:. $ clang -fsyntax-only ~/t.c. GCC options:. $ clang -fsyntax-only ~/t.c -pedantic; /Users/sabre/t.c:2:17: warning: extension used; typedef float V __attribute__((vector_size(16)));; ^; 1 diagnostic generated. Pretty printing from the AST:; Note, the -cc1 argument indicates the compiler front-end, and; not the driver, should be run. The compiler front-end has several additional; Clang specific features which are not exposed through the GCC compatible driver; interface. $ clang -cc1 ~/t.c -ast-print; typedef float V __attribute__(( vector_size(16) ));; V foo(V a, V b) {; return a + b * a;; }. Code generation with LLVM:. $ clang ~/t.c -S -emit-llvm -o -; define <4 x float> @foo(<4 x float> %a, <4 x float> %b) {; entry:; %mul = mul <4 x float> %b, %a; %add = add <4 x float> %mul, %a; ret <4 x float> %add; }; $ clang -fomit-frame-pointer -O3 -S -o - t.c # On x86_64; ...; _foo:; Leh_func_begin1:; 	mulps	%xmm0, %xmm1; 	addps	%xmm1, %xmm0; 	ret; Leh_func_end1:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:8165,interface,interface,8165,interpreter/llvm-project/clang/www/get_started.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html,1,['interface'],['interface']
Integrability,"wing descriptor for the trampoline function:. .. code-block:: text. !DISubprogram(name: ""sub1_.t0p"", linkageName: ""sub1_.t0p"", scope: !4, file: !4, type: !5, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !7, retainedNodes: !24, targetFuncName: ""sub1_""). The targetFuncName field is the name of the function that the trampoline; calls. This descriptor results in the following DWARF tag:. .. code-block:: text. DW_TAG_subprogram; ...; DW_AT_linkage_name	(""sub1_.t0p""); DW_AT_name	(""sub1_.t0p""); DW_AT_trampoline	(""sub1_""). Debugging information format; ============================. Debugging Information Extension for Objective C Properties; ----------------------------------------------------------. Introduction; ^^^^^^^^^^^^. Objective C provides a simpler way to declare and define accessor methods using; declared properties. The language provides features to declare a property and; to let compiler synthesize accessor methods. The debugger lets developer inspect Objective C interfaces and their instance; variables and class variables. However, the debugger does not know anything; about the properties defined in Objective C interfaces. The debugger consumes; information generated by compiler in DWARF format. The format does not support; encoding of Objective C properties. This proposal describes DWARF extensions to; encode Objective C properties, which the debugger can use to let developers; inspect Objective C properties. Proposal; ^^^^^^^^. Objective C properties exist separately from class members. A property can be; defined only by ""setter"" and ""getter"" selectors, and be calculated anew on each; access. Or a property can just be a direct access to some declared ivar.; Finally it can have an ivar ""automatically synthesized"" for it by the compiler,; in which case the property can be referred to in user code directly using the; standard C dereference syntax as well as through the property ""dot"" syntax, but; there is no entry in the ``@interface`` declaration co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:49506,interface,interfaces,49506,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['interface'],['interfaces']
Integrability,"with error on the; spread. ### 2D Profiles. The class for a 2D Profile is called **`TProfile2D`** . It is in many; cases an elegant replacement of a three-dimensional histogram. The; relationship of three measured quantities X, Y and Z can be visualized; by a three-dimensional histogram or scatter-plot; its representation; is not particularly satisfactory, except for sparse data. If Z is an; unknown (but single-valued) function of (X,Y), it can be displayed; with a **`TProfile2D`** with better precision than by a scatter-plot.; A **`TProfile2D`** displays the mean value of Z and its RMS for each; cell in X, Y. The following shows the cumulated contents (capital; letters) and the values displayed (small letters) of the elements for; cell `i,j`. When you fill a profile histogram with **`TProfile2D`**`.Fill(x,y,z)`:. - `E[i,j]` contains for each bin `i,j` the sum of the z values for; this bin. - `L[i,j]` contains the number of entries in the bin j. - `e[j]` or `s[j]` will be the resulting error depending on the; selected option. See ""Build Options"". ``` {.cpp}; E[i,j] = sum z; L[i,j] = sum l; h[i,j] = H[i,j ] / L[i,j]; s[i,j] = sqrt[E[i,j] / L[i,j]- h[i,j]**2]; e[i,j] = s[i,j] / sqrt[L[i,j]]; ```. In the special case where `s[i,j]` is zero, when there is only one; entry per cell, `e[i,j]` is computed from the average of the `s[i,j]`; for all cells. This approximation is used to keep the cell during a; fit operation. ![A TProfile2D histogram example](pictures/0800003F.png). ``` {.cpp}; {; // Creating a Canvas and a TProfile2D; TCanvas *c1 = new TCanvas(""c1"",; ""Profile histogram example"",; 200, 10,700,500);; hprof2d = new TProfile2D(""hprof2d"",; ""Profile of pz versus px and py"",; 40,-4,4,40,-4,4,0,20);. // Filling the TProfile2D with 25000 points; Float_t px, py, pz;; for (Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof2d->Fill(px,py,pz,1);; }; hprof2d->Draw();; }; ```. ## Iso Surfaces. Paint one Gouraud shaded 3d iso surface though a 3d hi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:68681,depend,depending,68681,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['depend'],['depending']
Integrability,"with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax {State1;State2} where State1; and State2 are the state names of the two spitting categories. Additional; functionality exists to work with multiple prototype p.d.f.s simultaneously. ; Improved infrastructure for caching p.d.f and functions. The infrastructure that exists for caching p.d.f.s, i.e. p.d.f that precalculate their value; for all observable values at one and cache those in a histogram that is returned as p.d.f shape; (with optional interpolation), has been expanded. This infrastructure comprises RooAbsCached; the base class for all caching p.d.fs, RooAbsSelfCachedPdf a base class for end-user; caching p.d.f implementations that simply cache the result of evaluate() and RooCachedPdf; that can wrap and cache any input p.d.f specified in its constructor. . By default a p.d.f is sampled and cached in all observables in any; given use context, with no need to specify what those are in advance.; The internal code has also been changed such that all cache; histograms now store pre-normalized p.d.f, which is more efficient; than 'raw' p.d.f histograms that are explicitly post-normalized; through integration. Multiple different use cases (e.g. definitions; of what are observables vs parameters) can be cached; simultaneously. Now it is also possible to specify that p.d.f.s; should be sampled and cached in one or more parameter dimensions; in addition to the automatically determined set of observables.; as well. Also a complete new line of classes with similar functionality has been added inheriting from RooAbsReal.; These are RooAbsCachedReal,RooAbsSelfCachedReal and RooCachedReal. A newly; added class RooHistFunc presents these shapes and is capable of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:13982,wrap,wrap,13982,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['wrap'],['wrap']
Integrability,"with; a Minimizer() named argument. // Minimization with MINUIT/MIGRAD through RooMinuit; pdf->fitTo(data) ;. // Minimization with MINUIT/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minuit"")) ;. // Minimization with MINUIT2/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minuit2"")) ;. // Minimization with GSLMultiMin/conjugatefr through RooMinimizer; pdf->fitTo(data,Minimizer(""GSLMultiMin"",""conjugatefr"")) ;. Note that installation of GSL and the ROOT MathMore package is needed to access the GSL Minimizers and that the GSL; Minimizer do not implement error analysis. New numeric integration algorithms available; RooFit can now interface all MathCore numeric integration; algorithms. In this release ROOT::Math::AdaptiveIntegratorMultiDim,; which implements the 'Genz & Malik' algorithm has been interfaced; in RooAdaptiveIntegratorND and is now the default numeric integrator; for numeric integrations in two or more dimensions. This new default integrator has much improved stability and speed; for relatively smooth p.d.f.s in two or three dimensions and can; generally be used well for p.d.f. normalization integrals without; causing MINUIT converge problems due to numeric precision issues. In future release some more numeric integrators will be migrated to; a MathCore implementation. Interface to TFoam adaptive MC sampler added; RooFit can now use the TFoam adaptive MC sampler for event generation of p.d.f.s that; do not have an internal generator. The TFoam generator adaptively subdivides the; observable space and is generally more efficient both warmup and generation than the original; RooAcceptReject algorithm. In its current interface in RooFit, TFoam cannot; handle problems yet with discrete observables or conditional observables. For those problems; the original RooAcceptReject generator is still used. The choice of MC sampling algorithm can be steered through class RooNumGenConfig, which; is similar in style and structure, to RooNumIntConfig which",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:4903,integrat,integrator,4903,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['integrat'],['integrator']
Integrability,"wningPtr`; return type, which is an alias for `std::unique_ptr` in memory-safe mode or an; alias for a raw pointer otherwise.; ```c++; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; ```. The biggest application of the memory-safe interfaces is to spot memory leaks; in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatible migration early** is strongly encouraged and; appreciated. ### Removal of some memory-unsafe interfaces. * The final `bool takeOwnership` parameter of the **RooAddition** and; **RooStats::HistFactory::PiecewiseInterpolation** constructors was removed.; This is to avoid situations where ownership is not clear to the compiler.; Now, ownership of the input RooAbsArgs is never passed in the constructor. If; you want the pass input ownership to the created object, please use; `addOwnedComponents`. If you want to be extra safe, make sure the inputs are; in an owning collection and then `std::move` the collection, so that the; ownership is always clear. Example:; ```c++; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; ```; should become:; ```c++; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:10458,interface,interfaces,10458,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['interface'],['interfaces']
Integrability,"write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactorin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:1361,integrat,integrate,1361,interpreter/llvm-project/clang/docs/Tooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst,1,['integrat'],['integrate']
Integrability,"ws:. ```c++; using RooFit::TestStatistics::RooAbsL;; using RooFit::TestStatistics::buildLikelihood;. RooAbsPdf* pdf = ...; // build a pdf; RooAbsData* data = ...; // get some data. std::shared_ptr<RooAbsL> likelihood = buildLikelihood(pdf, data, [OPTIONAL ARGUMENTS]);. RooMinimizer m(likelihood);; m.migrad();; ```. The `RooMinimizer` object behaves as usual, except that behind the scenes it will now calculate each partial derivative on a separate process, ideally running on a separate CPU core.; This can be used to speed up fits with many parameters (at least as many as there are cores to parallelize over), since every parameter corresponds to a partial derivative.; The resulting fit parameters will be identical to those obtained with the non-parallelized gradients minimizer in most cases (see the usage notes linked below for exceptions). In upcoming releases, further developments are planned:. - Benchmark/profile and optimize performance further; - Add a `RooAbsPdf::fitTo` interface around these new classes; - Achieve feature parity with existing `RooNLLVar` functionality, e.g. ranges are not yet supported. For more details, consult the usage notes in the [TestStatistics README.md](https://github.com/root-project/root/tree/master/roofit/roofitcore/src/TestStatistics/README.md).; For benchmarking results on the prototype version of the parallelized gradient calculator, see the corresponding [CHEP19 proceedings paper](https://doi.org/10.1051/epjconf/202024506027). ### New pythonizations. Various new pythonizations are introduced to streamline your RooFit code in Python. For a complete list of all pythonized classes and functions, please see the [RooFit pythonizations page in the reference guide](https://root.cern/doc/v626/group__RoofitPythonizations.html).; All RooFit Python tutorials have been updated to profit from all available pythonizations. Some notable highlights are listed in the following. #### Keyword argument pythonizations. All functions that take RooFit ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:18283,interface,interface,18283,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['interface'],['interface']
Integrability,"x as input using the; class MnUserCovariance. More information can be found in; [api:covariance]. ### MnUserParameterState ###. The MnUserParameterState contains the parameters (MnUserParameters) and; covariance (MnUserCovariance). The MnUserParameterState has to main; purposes:. - It can be used as input to minimization. - The result of the minimization is transformed into the user; representable format by M . For more explanations see [api:state]. ## Input to M ##. The following input combinations to M are possible:. - $\mbox{FCN}$ + parameters + uncertainties. - $\mbox{FCN}$ with gradient + parameters + uncertainties. - $\mbox{FCN}$ + parameters + covariance. - $\mbox{FCN}$ with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal; required interface (using std::vector containers) for the parameters and; uncertainties or a more functional one provided by M . If the user wants; to interact with the parameters before minimization (fixing,; adding/removing limits), the minimal required interface cannot be used. ### What the user must supply ###. The user must supply to M. - a valid implementation of the FCNBase base class. - parameters with their starting values. - expected uncertainties on the parameters. The input parameters can be simply defined via an; std::vector$<$double$>$, which means that all parameters are variables.; If the user wants fix a parameter or put limits on it before; minimization, they have to instantiate a MnUserParameters object and then; add parameters one by one, giving them a name, value, uncertainty. Once; all parameters are added to MnUserParameters, they can fix a parameter or; put limits on another one before handing them over to Minuit for; minimization. ### What the user can supply ###. Optionally the user can supply their own gradient calculator by; implementing the FCNGradientBase interface or supply a full covariance; matrix for input if one is available. The covariance matrix can ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:32307,interface,interface,32307,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"x variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17; Problems with sized delete; Unknown. 2249; CD5; identifiers and i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:152286,depend,dependent,152286,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"xample. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(attribute_cf_consumed); #define CF_CONSUMED __attribute__((cf_consumed)); #else; #define CF_CONSUMED; #endif; #endif. void consume_cf(id CF_CONSUMED x);; void consume_CFDate(CFDateRef CF_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_cf(x); // No leak!; }. void test2() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; consume_CFDate(date); // No leak, including under GC!. }. @interface Foo : NSObject; + (void) releaseArg:(CFDateRef) CF_CONSUMED x;; @end. void test_method() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; [Foo releaseArg:date]; // No leak!; }. Attribute 'ns_consumes_self'; (Clang-specific); The 'ns_consumes_self' attribute can be placed only on an Objective-C method; declaration. It indicates that the receiver of the message is; ""consumed"" (a single reference count decremented) after the message; is sent. This matches the semantics of all ""init"" methods.; One use of this attribute is declare your own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consumes_self)); #define NS_CONSUMES_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CONSUMES_SELF NS_RETURNS_RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:12546,message,message,12546,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,2,['message'],['message']
Integrability,"xecutables and libraries."" OFF); endif(). # Define the default arguments to use with 'lit', and an option for the user to; # override.; set(LIT_ARGS_DEFAULT ""-sv""); if (MSVC_IDE OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); if(LLVM_INDIVIDUAL_TEST_COVERAGE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --per-test-coverage""); endif(); set(LLVM_LIT_ARGS ""${LIT_ARGS_DEFAULT}"" CACHE STRING ""Default options for lit""). # On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.; if( WIN32 AND NOT CYGWIN ); set(LLVM_LIT_TOOLS_DIR """" CACHE PATH ""Path to GnuWin32 tools""); endif(); set(LLVM_NATIVE_TOOL_DIR """" CACHE PATH ""Path to a directory containing prebuilt matching native tools (such as llvm-tblgen)""). set(LLVM_INTEGRATED_CRT_ALLOC """" CACHE PATH ""Replace the Windows CRT allocator with any of {rpmalloc|mimalloc|snmalloc}. Only works with CMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded.""); if(LLVM_INTEGRATED_CRT_ALLOC); if(NOT WIN32); message(FATAL_ERROR ""LLVM_INTEGRATED_CRT_ALLOC is only supported on Windows.""); endif(); if(LLVM_USE_SANITIZER); message(FATAL_ERROR ""LLVM_INTEGRATED_CRT_ALLOC cannot be used along with LLVM_USE_SANITIZER!""); endif(); if(CMAKE_BUILD_TYPE AND uppercase_CMAKE_BUILD_TYPE STREQUAL ""DEBUG""); message(FATAL_ERROR ""The Debug target isn't supported along with LLVM_INTEGRATED_CRT_ALLOC!""); endif(); endif(). # Define options to control the inclusion and default build behavior for; # components which may not strictly be necessary (tools, examples, and tests).; #; # This is primarily to support building smaller or faster project files.; option(LLVM_INCLUDE_TOOLS ""Generate build targets for the LLVM tools."" ON); option(LLVM_BUILD_TOOLS; ""Build the LLVM tools. If OFF, just generate build targets."" ON). option(LLVM_INCLUDE_UTILS ""Generate build targets for the LLVM utils."" ON); option(LLVM_BUILD_UTILS; ""Build LLVM utility binaries. If OFF, just generate build targets."" ON). option(LLVM_INCLUDE_RUNTIMES ""Generate b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:30121,message,message,30121,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"ximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59467,contract,contract,59467,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"xt. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we didn't have any; cycle, then the normal way of passing an Error object through the call stack; could handle the situation. This is why we must track cycles during the import; process for each visited declaration. Lookup Problems; ^^^^^^^^^^^^^^^. When we import a declaration from the source context then we check whether we; already have a structurally equivalent node with the same name in the ""to""; context. If the ""from"" node is a definition and the found one is also a; definition, then we do not create a new node, instead, we mark the found node; as the imported node. If the found definition and the one we want to import; have the same name b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103745,depend,dependent,103745,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependent']
Integrability,"y # requires GUI; pyroot/fit1_py.py # not a tutorial; pyroot/gui_ex.py # requires GUI; pyroot/mrt.py # not really a tutorial; pyroot/na49geomfile.py # ????; pyroot/na49visible.py # ????; pyroot/parse_CSV_file_with_TTree_ReadStream.py # not a tutorial; pyroot/numberEntry.py # requires GUI; legacy/pyroot/*py # legacy ...; histfactory/makeQuickModel.py # not a tutorial; eve/lineset.py # requires GUI; sql/sqlcreatedb.py # same as the C++ case; sql/sqlfilldb.py # same as the C++ case; sql/sqlselect.py # same as the C++ case; launcher.py # Not a tutorial; .enableImplicitMTWrapper.py # Not a tutorial; ). if(NOT dataframe; OR DEFINED ENV{ROOTTEST_IGNORE_NUMBA_PY3}; OR (MSVC AND NOT win_broken_tests)); list(APPEND pyveto pyroot/pyroot004_NumbaDeclare.py); endif(). if(dataframe AND DEFINED ENV{ROOTTEST_IGNORE_PANDAS_PY3}); list(APPEND pyveto dataframe/df026_AsNumpyArrays.py); endif(). # Rules specific to distributed RDataFrame; # Disable distributed RDF tutorials if we didn't check dependencies in the environment first; if(NOT test_distrdf_pyspark); list(APPEND pyveto dataframe/distrdf001_spark_connection.py); endif(); if(NOT test_distrdf_dask); list(APPEND pyveto dataframe/distrdf002_dask_connection.py); list(APPEND pyveto dataframe/distrdf003_live_visualization.py); endif(); # Use main Python executable to run in PySpark driver and executors; if(test_distrdf_pyspark); list(APPEND TUTORIAL_ENV PYSPARK_PYTHON=${Python3_EXECUTABLE}); if(MACOSX_VERSION VERSION_GREATER_EQUAL 10.13); # MacOS has changed rules about forking processes after 10.13; # Running pyspark tests with XCode Python3 throws crashes with errors like:; # `objc[17271]: +[__NSCFConstantString initialize] may have been in progress in another thread when fork() was called.`; # This issue should have been fixed after Python 3.8 (see https://bugs.python.org/issue33725); # Indeed, any other Python 3.8+ executable does not show this crash. It is; # specifically the XCode Python executable that triggers this.; # For now",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:27684,depend,dependencies,27684,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['depend'],['dependencies']
Integrability,"y a lie, because IMT takes whatever it finds.; # However, even this poor indication of MT behaviour is a good hint for cmake to reduce congestion.; set_tests_properties(tutorial-${tname} PROPERTIES RESOURCE_LOCK multithreaded PROCESSORS ${NProcessors}); endif(); endforeach(). #---Loop over all MPI tutorials and define the corresponding test---------; foreach(t ${mpi_tutorials}); list(FIND returncode_1 ${t} index); if(index EQUAL -1); set(rc 0); else(); set(rc 255); endif(); string(REPLACE "".C"" """" tname ${t}); string(REPLACE ""/"" ""-"" tname ${tname}). # These tests on ARM64 need much more than 20 minutes - increase the timeout; if(ROOT_ARCHITECTURE MATCHES arm64 OR ROOT_ARCHITECTURE MATCHES ppc64); set(thisTestTimeout 3000) # 50m; else(); set(thisTestTimeout 1200) # 20m; endif(). ROOT_ADD_TEST(tutorial-${tname}; COMMAND ${MPIEXEC_EXECUTABLE} ${MPIEXEC_NUMPROC_FLAG} 4 ${ROOT_root_CMD} -b -l -q ${CMAKE_CURRENT_SOURCE_DIR}/${t}${${tname}-aclic}; PASSRC ${rc} FAILREGEX ""Error in <"" "": error:"" ""segmentation violation"" ""FROM HESSE STATUS=FAILED"" ""warning: Failed to call""; LABELS tutorial; DEPENDS tutorial-hsimple ${${tname}-depends}; ENVIRONMENT ${TUTORIAL_ENV}; TIMEOUT ${thisTestTimeout}); endforeach(). #---Python tutorials-----------------------------------------------------; if(ROOT_pyroot_FOUND). # Copy .rootlogon.py file into the build directory. It disables graphics for the Python tutorials; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/.rootlogon.py ${CMAKE_CURRENT_BINARY_DIR} COPYONLY); # Copy .enableImplicitMTWrapper.py file into the build directory. It can limit the size of the thread pool; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/.enableImplicitMTWrapper.py ${CMAKE_CURRENT_BINARY_DIR} COPYONLY). file(GLOB_RECURSE pytutorials RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} *.py). # Now python-specific vetos:; set(pyveto pyroot/demo.py # requires GUI; pyroot/fit1_py.py # not a tutorial; pyroot/gui_ex.py # requires GUI; pyroot/mrt.py # not really a tutorial; pyroot/na49geomfile.p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:25976,depend,depends,25976,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['depend'],['depends']
Integrability,"y another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need, *logarithmical-search* (read ""total-ordering"") could; be used as a milestone on our way to the *random-access* implementation. Every comparison is based either on the numbers or on the flags comparison. In; the *random-access* approach, we could use the same comparison algorithm.; During comparison, we exit once we find the difference, but here we might have; to scan the whole function body every time (note, it could be slower). Like i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:6279,depend,depends,6279,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['depend'],['depends']
Integrability,"y as to allow users (that is, people like; you) to easily add missing importers and exporters for existing; `RooFit` classes as well as custom implementations you might be using. ### Native and proxy-based importers and exporters. `RooFitHS3` allows to different types of importers and exporters:; *Native* implementations, and *proxy-based* ones. If for a certain; class several implementations are provided, the native; implementation(s) take precedence. ### Writing your own importers and exporters: Proxy-based. Proxy-based implementations can be added very easily and without; actually writing any `C++` code -- you only need to add a short item; to a list in a `JSON` file, namely the; [export keys](https://github.com/root-project/root/blob/master/etc/RooFitHS3_wsexportkeys.json); for an exporter, or the; [factory expressions](https://github.com/root-project/root/blob/master/etc/RooFitHS3_wsfactoryexpressions.json); for an importer. This works in the following way: Every `RooFit` class performs; dependency tracking via proxies, which have names. This can be; exploited to perform the mapping of proxy names to `json` keys upon; export. In the other direction, the `RooWorkspace` has a factory; interface that allows to call any constructor via a string; interface. Hence:; - If a `RooFit` class has no other members aside from proxies, it can; be exported using a set of `export keys`.; - If all relevant members to a `RooFit` class are passed as; constructor arguments, it can be imported using a `factory; expression`. For the importer, an entry in the; [factory expressions](https://github.com/root-project/root/blob/master/etc/RooFitHS3_wsfactoryexpressions.json); needs to be added as follows:. ``` {.json}; ""<json-key>"": {; ""class"": ""<C++ class name>"",; ""arguments"": [; ""<json-key of constructor argument #1>"",; ""<json-key of constructor argument #2>"",; ...; ]; }; ```. Similarly, for the exporter, an entry in the; [export keys](https://github.com/root-project/root/blob/master/etc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md:2981,depend,dependency,2981,roofit/doc/developers/roofit_hs3.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md,1,['depend'],['dependency']
Integrability,"y contains a base image and a number; of RUN commands that have to be executed to build the image. When building a new; image, docker will first download your base image, mount its filesystem as; read-only and then add a writable overlay on top of it to keep track of all; filesystem modifications, performed while building your image. When the build; process is finished, a diff between your image's final filesystem state and the; base image's filesystem is stored in the resulting image. Overview; ========; The ``llvm/utils/docker`` folder contains Dockerfiles and simple bash scripts to; serve as a basis for anyone who wants to create their own Docker image with; LLVM components, compiled from sources. The sources are checked out from the; upstream git repository when building the image. The resulting image contains only the requested LLVM components and a few extra; packages to make the image minimally useful for C++ development, e.g. libstdc++; and binutils. The interface to run the build is ``build_docker_image.sh`` script. It accepts a; list of LLVM repositories to checkout and arguments for CMake invocation. If you want to write your own docker image, start with an ``example/`` subfolder.; It provides an incomplete Dockerfile with (very few) FIXMEs explaining the steps; you need to take in order to make your Dockerfiles functional. Usage; =====; The ``llvm/utils/build_docker_image.sh`` script provides a rather high degree of; control on how to run the build. It allows you to specify the projects to; checkout from git and provide a list of CMake arguments to use during when; building LLVM inside docker container. Here's a very simple example of getting a docker image with clang binary,; compiled by the system compiler in the debian10 image:. .. code-block:: bash. ./llvm/utils/docker/build_docker_image.sh \; 	--source debian10 \; 	--docker-repository clang-debian10 --docker-tag ""staging"" \; 	-p clang -i install-clang -i install-clang-resource-headers \; 	-- \; 	-DC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst:2890,interface,interface,2890,interpreter/llvm-project/llvm/docs/Docker.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst,1,['interface'],['interface']
Integrability,"y is; ``RegisterMyPasses`` then define:. .. code-block:: c++. MachinePassRegistry<RegisterMyPasses::FunctionPassCtor> RegisterMyPasses::Registry;. And finally, declare the command line option for your passes. Example:. .. code-block:: c++. cl::opt<RegisterMyPasses::FunctionPassCtor, false,; RegisterPassParser<RegisterMyPasses> >; MyPassOpt(""mypass"",; cl::init(&createDefaultMyPass),; cl::desc(""my pass option help""));. Here the command option is ""``mypass``"", with ``createDefaultMyPass`` as the; default creator. Using GDB with dynamically loaded passes; ----------------------------------------. Unfortunately, using GDB with dynamically loaded passes is not as easy as it; should be. First of all, you can't set a breakpoint in a shared object that; has not been loaded yet, and second of all there are problems with inlined; functions in shared objects. Here are some suggestions to debugging your pass; with GDB. For sake of discussion, I'm going to assume that you are debugging a; transformation invoked by :program:`opt`, although nothing described here; depends on that. Setting a breakpoint in your pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. First thing you do is start gdb on the opt process:. .. code-block:: console. $ gdb opt; GNU gdb 5.0; Copyright 2000 Free Software Foundation, Inc.; GDB is free software, covered by the GNU General Public License, and you are; welcome to change it and/or distribute copies of it under certain conditions.; Type ""show copying"" to see the conditions.; There is absolutely no warranty for GDB. Type ""show warranty"" for details.; This GDB was configured as ""sparc-sun-solaris2.6""...; (gdb). Note that :program:`opt` has a lot of debugging information in it, so it takes; time to load. Be patient. Since we cannot set a breakpoint in our pass yet; (the shared object isn't loaded until runtime), we must execute the process,; and have it stop before it invokes our pass, but after it has loaded the shared; object. The most foolproof way of doing this ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:52536,depend,depends,52536,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['depend'],['depends']
Integrability,"y object (uncompressed); | OR'd with kByteCountMask (0x40000000); 4->.. ClassInfo = Information about TClonesArray class; | If this is the first occurrence of a TClonesArray object in the record; | 4->7 -1 = New class tag (constant kNewClassTag = 0xffffffff); | 8->17 Classname = Object Class Name ""TClonesArray"" (null terminated); | Otherwise; | 4->7 clIdx = Byte offset of new class tag in record, plus 2.; | OR'd with kClassMask (0x80000000); 0->3 ByteCount = Number of remaining bytes in TClonesArray object (uncompressed); | OR'd with kByteCountMask (0x40000000); 4->5 Version = Version of TClonesArray Class; 6->15 = TObject object (a base class of TClonesArray) (see \ref tobject).; | Would be two bytes longer (6->17) if object were referenced.; 16->.. fName = Number of bytes in name of TClonesArray object, followed by the; | name itself. (TCollection::fName). This name will be the; | class name of the cloned object, appended with an 's'; | (e.g. ""TXxxs""); 0->.. = Number of bytes in name and version of the cloned class, followed; | by the name and version themselves (e.g. ""TXxx;1""); 0->3 nObjects = Number of objects in clones array.; 4->7 fLowerBound= Lower bound of clones array.; 8->.. objects = Sequentially, objects in the clones array. However, the data; | ordering depends on whether or not kBypassStreamer (0x1000) is; | set in TObject::fBits. By default, it is set. If it is not set,; | the objects are streamed sequentially using the streamer of the; | cloned class (e.g. TXxx::Streamer()).; |; | If it is set, the cloned class is split into its base classes and; | persistent data members, and those streamers are used. So, if the; | base classes and persistent data members of class TXxx are TXxxbase,; | TXxxdata0, TXxxdata1, etc., all the TXxxbase data from the entire; | clones array is streamed first, followed by all the TXxxdata0 data,; | etc. This breakdown is not recursive, in that the member objects; | are not again split.; -End TClonesArray object; </pre></div>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/tclonesarray.md:1569,depend,depends,1569,io/doc/TFile/tclonesarray.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/tclonesarray.md,1,['depend'],['depends']
Integrability,"y operative modes and raises; floating-point exceptions as required by IEC 60559 (provided the state for the; FENV_ACCESS pragma is ‘‘on’’). All computation for initialization of objects; that have static or thread storage duration is done (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75123,message,message,75123,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['message'],['message']
Integrability,"y the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If this environment variable is present, it is treated as a delimited list of; paths to be added to the default system include path list. The delimiter is; the platform dependent delimiter, as used in the PATH environment variable. Empty components in the environment variable are ignored. .. envvar:: C_INCLUDE_PATH, OBJC_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJCPLUS_INCLUDE_PATH. These environment variables specify additional paths, as for :envvar:`CPATH`, which are; only used when processing the appropriate language. .. envvar:: MACOSX_DEPLOYMENT_TARGET. If :option:`-mmacosx-version-min` is unspecified, the default deployment; target is read from this environment variable. This option only affects; Darwin targets. BUGS; ----. To report bugs, please visit <https://github.com/llvm/llvm-project/issues/>. Most bug reports should; include preprocessed source files (use the :option:`-E` option) and the full; output of the compiler, along with information to reproduce. SEE ALSO; --------. :manpage:`as(1)`, :manpage:`ld(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:21101,depend,dependent,21101,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['depend'],['dependent']
Integrability,"y you add the top folder of your hierarchy to; `//root`. Then you add a folder to an existing folder with the; **`TFolder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3492,depend,dependent,3492,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,1,['depend'],['dependent']
Integrability,"y.p0.p0.i32(ptr <dest>, ptr <src>,; i32 <len>, i1 <isvolatile>); declare void @llvm.memcpy.p0.p0.i64(ptr <dest>, ptr <src>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memcpy.*``' intrinsics copy a block of memory from the; source location to the destination location. Note that, unlike the standard libc function, the ``llvm.memcpy.*``; intrinsics do not return a value, takes extra isvolatile; arguments and the pointers can be in specified address spaces. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination, the second is a; pointer to the source. The third argument is an integer argument; specifying the number of bytes to copy, and the fourth is a; boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first and second arguments. If the ``isvolatile`` parameter is ``true``, the ``llvm.memcpy`` call is; a :ref:`volatile operation <volatile>`. The detailed access behavior is not; very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memcpy.*``' intrinsics copy a block of memory from the source; location to the destination location, which must either be equal or; non-overlapping. It copies ""len"" bytes of memory over. If the argument is known; to be aligned to some boundary, this can be specified as an attribute on the; argument. If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to; the arguments.; If ``<len>`` is not a well-defined value, the behavior is undefined.; If ``<len>`` is not zero, both ``<dest>`` and ``<src>`` should be well-defined,; otherwise the behavior is undefined. .. _int_memcpy_inline:. '``llvm.memcpy.inline``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.memcpy.inline`` on any; integer bit width and for different address spaces. Not all targets; support all bit widths however. ::. declare void @llvm.memcpy.inline.p0.p0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:547961,depend,depend,547961,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability,"y; allow atomic commits to the project, simplify CI, and make it easier for; subcommunities to collaborate. Like new targets, most projects already in the monorepo are considered to be in; the *core tier* of our :doc:`support policy<SupportPolicy>`. The burden to add; things to the LLVM monorepo needs to be very high - code that is added to this; repository is checked out by everyone in the community. As such, we hold; components to a high bar similar to ""official targets"", they:. * Must be generally aligned with the mission of the LLVM project to advance; compilers, languages, tools, runtimes, etc.; * Must conform to all of the policies laid out in this developer policy; document, including license, patent, coding standards, and code of conduct.; * Must have an active community that maintains the code, including established; code owners.; * Should have reasonable documentation about how it works, including a high; quality README file.; * Should have CI to catch breakage within the project itself or due to; underlying LLVM dependencies.; * Should have code free of issues the community finds contentious, or be on a; clear path to resolving them.; * Must be proposed through the LLVM RFC process, and have its addition approved; by the LLVM community - this ultimately mediates the resolution of the; ""should"" concerns above. If you have a project that you think would make sense to add to the LLVM; monorepo, please start an RFC topic on the `LLVM Discourse forums`_ to kick off; the discussion. This process can take some time and iteration - please don’t; be discouraged or intimidated by that!. If you have an earlier stage project that you think is aligned with LLVM, please; see the ""Incubating New Projects"" section. Incubating New Projects; -----------------------. The burden to add a new project to the LLVM monorepo is intentionally very high,; but that can have a chilling effect on new and innovative projects. To help; foster these sorts of projects, LLVM supports an ""in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:46350,depend,dependencies,46350,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['depend'],['dependencies']
Integrability,"y``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new “ContainsErrors” bit to; express “Does this expression or anything within it contain errors” semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89157,depend,dependence,89157,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependence']
Integrability,"ymbols` option,; display the full bytes of the record in binary as well. Type Record Options; +++++++++++++++++++. .. option:: -types. Dump CodeView type records from TPI stream. .. option:: -type-extras. Dump additional information from the TPI stream, such as hashes and the type; index offsets array. .. option:: -type-data. For each type record dumped, display the full bytes of the record in binary as; well. .. option:: -type-index=<uint>. Only dump types with the specified type index. .. option:: -ids. Dump CodeView type records from IPI stream. .. option:: -id-extras. Dump additional information from the IPI stream, such as hashes and the type; index offsets array. .. option:: -id-data. For each ID record dumped, display the full bytes of the record in binary as; well. .. option:: -id-index=<uint>. only dump ID records with the specified hexadecimal type index. .. option:: -dependents. When used in conjunction with :option:`-type-index` or :option:`-id-index`,; dumps the entire dependency graph for the specified index instead of just the; single record with the specified index. For example, if type index 0x4000 is; a function whose return type has index 0x3000, and you specify; `-dependents=0x4000`, then this would dump both records (as well as any other; dependents in the tree). Miscellaneous Options; +++++++++++++++++++++. .. option:: -all. Implies most other options. .. option:: -section-contribs. Dump section contributions. .. option:: -section-headers. Dump image section headers. .. option:: -section-map. Dump section map. .. option:: -string-table. Dump PDB string table. .. _bytes_subcommand:. bytes; ~~~~~. USAGE: :program:`llvm-pdbutil` bytes [*options*] <input PDB file>. .. program:: llvm-pdbutil bytes. Summary; ^^^^^^^. Like the **dump** subcommand, the **bytes** subcommand displays low level; information about the structure of a PDB file, but it is used for even deeper; forensics. The **bytes** subcommand finds various structures in a PDB file; based o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst:10078,depend,dependency,10078,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,1,['depend'],['dependency']
Integrability,"ync(""SomeFunction()"")` call. One could configure argument(s) for the command.; For that one should use `%arg1`, `%arg2` and so on identifiers. Like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; ```. User will be requested to enter arguments values, when command element clicked in the browser.; Example of the command which executes arbitrary string in application via ProcessLine looks like:. ```cpp; serv->RegisterCommand(""/Process"", ""%arg1%"");; ```. When registering command, one could specify icon name which will be displayed with the command. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; ```. In example usage of images from `$ROOTSYS/icons` directory is shown. One could prepend `button;`; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:. ```cpp; serv->Hide(""/DoSomething"");; ```. One can find example of command interface usage in [tutorials/http/httpcontrol.C](https://github.com/root-project/root/blob/master/tutorials/http/httpcontrol.C) macro. ## Customize user interface. JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - [see example](https://root.cern/js/latest/httpserver.C/). JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items [item=Files/job1.root/hpxpy&opt=colz&monitoring=1000](https://root.cern/js/latest/httpserver.C/?item=Files/job1.root/hpxpy&opt=colz&monitoring=1000). Some of such parameters can be configured already on the server:. ```cpp; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; ```. In such case URL parameters are not required - specified item will be displayed automa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:6207,interface,interface,6207,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['interface'],['interface']
Integrability,"you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18077,depend,dependent,18077,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,['depend'],"['dependency', 'dependent']"
Integrability,"your code. It is possible to change Xcode's behavior to use an; alternate version of clang for this purpose while continuing to use; the clang that came with Xcode for compiling projects.; Why try open source builds?; The advantage of using open source analyzer builds (provided on this website); is that they are often newer than the analyzer provided with Xcode, and thus can; contain bug fixes, new checks, or simply better analysis.; On the other hand, new checks can be experimental, with results of variable; quality. Users are encouraged to file bug reports; (for any version of the analyzer) where they encounter false positives or other; issues.; set-xcode-analyzer; Starting with analyzer build checker-234, analyzer builds contain a command; line utility called set-xcode-analyzer that allows users to change what; copy of clang that Xcode uses for analysis:. $ set-xcode-analyzer -h; Usage: set-xcode-analyzer [options]. Options:; -h, --help show this help message and exit; --use-checker-build=PATH; Use the Clang located at the provided absolute path,; e.g. /Users/foo/checker-1; --use-xcode-clang Use the Clang bundled with Xcode. Operationally, set-xcode-analyzer edits Xcode's configuration files; to point it to use the version of clang you specify for static; analysis. Within this model it provides you two basic modes:. --use-xcode-clang: Switch Xcode (back) to using the clang that came bundled with it for static analysis.; --use-checker-build: Switch Xcode to using the clang provided by the specified analyzer build. Things to keep in mind. You should quit Xcode prior to running set-xcode-analyzer. You will need to run set-xcode-analyzer under; sudo in order to have write privileges to modify the Xcode; configuration files. Examples; Example 1: Telling Xcode to use checker-235:. $ pwd; /tmp; $ tar xjf checker-235.tar.bz2; $ sudo checker-235/set-xcode-analyzer --use-checker-build=/tmp/checker-235. Note that you typically won't install an analyzer build in /tmp, but; th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/xcode.html:2040,message,message,2040,interpreter/llvm-project/clang/www/analyzer/xcode.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/xcode.html,1,['message'],['message']
Integrability,"ype`` is a contextual keyword; that is only permitted in the result type of an Objective-C method, e.g. .. code-block:: objc. @interface A; + (instancetype)constructAnA;; @end. The related result type can also be inferred for some methods. To determine; whether a method has an inferred related result type, the first word in the; camel-case selector (e.g., ""``init``"" in ""``initWithObjects``"") is considered,; and the method will have a related result type if its return type is compatible; with the type of its class and if:. * the first word is ""``alloc``"" or ""``new``"", and the method is a class method,; or. * the first word is ""``autorelease``"", ""``init``"", ""``retain``"", or ""``self``"",; and the method is an instance method. If a method with a related result type is overridden by a subclass method, the; subclass method must also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; via the given method. In all other respects, a method with a related result; type is treated the same way as method that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:70257,interface,interface,70257,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['interface'],['interface']
Integrability,"ypes; > Right now, I've spec'd out the language to have a pointer type, which; > works fine for lots of stuff... except that Java really has; > references: constrained pointers that cannot be manipulated: added and; > subtracted, moved, etc... Do we want to have a type like this? It; > could be very nice for analysis (pointer always points to the start of; > an object, etc...) and more closely matches Java semantics. The; > pointer type would be kept for C++ like semantics. Through analysis,; > C++ pointers could be promoted to references in the LLVM; > representation. You're right, having references would be useful. Even for C++ the *static*; compiler could generate references instead of pointers with fairly; straightforward analysis. Let's include a reference type for now. But I'm; also really concerned that LLVM is becoming big and complex and (perhaps); too high-level. After we get some initial performance results, we may have; a clearer idea of what our goals should be and we should revisit this; question then. > 2. Our ""implicit"" memory references in assembly language:; > After thinking about it, this model has two problems:; > A. If you do pointer analysis and realize that two stores are; > independent and can share the same memory source object,. not sure what you meant by ""share the same memory source object"". > there is; > no way to represent this in either the bytecode or assembly.; > B. When parsing assembly/bytecode, we effectively have to do a full; > SSA generation/PHI node insertion pass to build the dependencies; > when we don't want the ""pinned"" representation. This is not; > cool. I understand the concern. But again, let's focus on the performance first; and then look at the language design issues. E.g., it would be good to know; how big the bytecode files are before expanding them further. I am pretty; keen to explore the implications of LLVM for mobile devices. Both bytecode; size and power consumption are important to consider there. --Vikram. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-13-Reference-MemoryResponse.txt:1707,depend,dependencies,1707,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-13-Reference-MemoryResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-13-Reference-MemoryResponse.txt,1,['depend'],['dependencies']
Integrability,"ysis results from the outer analysis manager; should be immutable, so invalidation shouldn't be a concern. However, it is; possible for some inner analysis to depend on some outer analysis, and when; the outer analysis is invalidated, we need to make sure that dependent inner; analyses are also invalidated. This actually happens with alias analysis; results. Alias analysis is a function-level analysis, but there are; module-level implementations of specific types of alias analysis. Currently; ``GlobalsAA`` is the only module-level alias analysis and it generally is not; invalidated so this is not so much of a concern. See; ``OuterAnalysisManagerProxy::Result::registerOuterAnalysisInvalidation()``; for more details. Invoking ``opt``; ================. .. code-block:: shell. $ opt -passes='pass1,pass2' /tmp/a.ll -S; # -p is an alias for -passes; $ opt -p pass1,pass2 /tmp/a.ll -S. The new PM typically requires explicit pass nesting. For example, to run a; function pass, then a module pass, we need to wrap the function pass in a module; adaptor:. .. code-block:: shell. $ opt -passes='function(no-op-function),no-op-module' /tmp/a.ll -S. A more complete example, and ``-debug-pass-manager`` to show the execution; order:. .. code-block:: shell. $ opt -passes='no-op-module,cgscc(no-op-cgscc,function(no-op-function,loop(no-op-loop))),function(no-op-function,loop(no-op-loop))' /tmp/a.ll -S -debug-pass-manager. Improper nesting can lead to error messages such as. .. code-block:: shell. $ opt -passes='no-op-function,no-op-module' /tmp/a.ll -S; opt: unknown function pass 'no-op-module'. The nesting is: module (-> cgscc) -> function -> loop, where the CGSCC nesting is optional. There are a couple of special cases for easier typing:. * If the first pass is not a module pass, a pass manager of the first pass is; implicitly created. * For example, the following are equivalent. .. code-block:: shell. $ opt -passes='no-op-function,no-op-function' /tmp/a.ll -S; $ opt -passes='function(no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:18605,wrap,wrap,18605,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['wrap'],['wrap']
Integrability,"ystem where code; pages must be signed (preventing code from being updated), the memory manager; can deallocate working memory pages after linking to free memory in the process; running JITLink. Alternatively, on a system that allows RWX pages, the memory; manager may use the same pages for both working and target memory by marking; them as RWX, allowing code to be modified in place without further overhead.; Finally, if RWX pages are not permitted but dual-virtual-mappings of; physical memory pages are, then the memory manager can dual map physical pages; as RW- in the JITLink process and R-X in the executor process, allowing; modification from the JITLink process but not from the executor (at the cost of; extra administrative overhead for the dual mapping). Error Handling; --------------. JITLink makes extensive use of the ``llvm::Error`` type (see the error handling; section of :doc:`ProgrammersManual` for details). The link process itself, all; passes, the memory manager interface, and operations on the ``JITLinkContext``; are all permitted to fail. Link graph construction utilities (especially parsers; for object formats) are encouraged to validate input, and validate fixups; (e.g. with range checks) before application. Any error will halt the link process and notify the context of failure. In ORC,; reported failures are propagated to queries pending on definitions provided by; the failing link, and also through edges of the dependence graph to any queries; waiting on dependent symbols. .. _connection_to_orc_runtime:. Connection to the ORC Runtime; =============================. The ORC Runtime (currently under development) aims to provide runtime support; for advanced JIT features, including object format features that require; non-trivial action in the executor (e.g. running initializers, managing thread; local storage, registering with language runtimes, etc.). ORC Runtime support for object format features typically requires cooperation; between the runtime ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:32086,interface,interface,32086,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['interface'],['interface']
Integrability,"ystem}` option to produce the BMI for header units; which has suffix like `.h` or `.hh`.; The value of `-fmodule-header` means the user search path or the system search path.; The default value for `-fmodule-header` is `user`.; For example,. .. code-block:: c++. // foo.h; #include <iostream>; void Hello() {; std::cout << ""Hello World.\n"";; }. // use.cpp; import ""foo.h"";; int main() {; Hello();; }. We could compile it as:. .. code-block:: console. $ clang++ -std=c++20 -fmodule-header foo.h -o foo.pcm; $ clang++ -std=c++20 -fmodule-file=foo.pcm use.cpp. For headers which don't have a suffix, we need to pass ``-xc++-header``; (or ``-xc++-system-header`` or ``-xc++-user-header``) to mark it as a header.; For example,. .. code-block:: c++. // use.cpp; import ""foo.h"";; int main() {; Hello();; }. .. code-block:: console. $ clang++ -std=c++20 -fmodule-header=system -xc++-header iostream -o iostream.pcm; $ clang++ -std=c++20 -fmodule-file=iostream.pcm use.cpp. How to specify the dependent BMIs; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. We could use ``-fmodule-file`` to specify the BMIs, and this option may occur multiple times as well. With the existing implementation ``-fprebuilt-module-path`` cannot be used for header units; (since they are nominally anonymous).; For header units, use ``-fmodule-file`` to include the relevant PCM file for each header unit. This is expect to be solved in future editions of the compiler either by the tooling finding and specifying; the -fmodule-file or by the use of a module-mapper that understands how to map the header name to their PCMs. Don't compile the BMI; ~~~~~~~~~~~~~~~~~~~~~. Another difference with modules is that we can't compile the BMI from a header unit.; For example:. .. code-block:: console. $ clang++ -std=c++20 -xc++-system-header --precompile iostream -o iostream.pcm; # This is not allowed!; $ clang++ iostream.pcm -c -o iostream.o. It makes sense due to the semantics of header units, which are just like headers. Include translatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:28997,depend,dependent,28997,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['dependent']
Integrability,"yter lab. - Let use created notebooks with viewers like https://nbviewer.jupyter.org/; - Fix problem with using of local JSROOT version. ## Tutorials. - The tutorial games.C was not working properly. - Improve tutorial ErrorIntegral.C. - Schrödinger's Hydrogen Atom example. - Tutorial demonstrating how the changing of the range can zoom into the histogram. - Tutorial demonstrating how a Histogram can be read from a ROOT File. - histMax.C: a tutorial demoing how the hist->GetMaximumBin() can be used. ## Class Reference Guide. - Images for ROOT7 tutorials can be generated, in json format, using the directive using; `\macro_image (json)` in the macro header. - Clarify THStack drawing options. - Add missing documentation to TH1 functions. - Restructure the math reference guide. - Make the web gui documentation visible in the reference guide. - Make clear THtml is legacy code. Add deprecated flag on PROOF and TGeoTrack. - Improve many classes documentation: TContext, TTreePlayer, THistPainter, TGraph, TSelector,; integrator, GUI, TH1, TH2, TH3, TColor classes ... - Make the TFile layout doc visible in Reference Guide. - Update the external links of the reference guide main page. - Reformat TMVA mathcore Unuran Roostats documentation . ## Build, Configuration and Testing Infrastructure. - For users building from source the `latest-stable` branch and passing `-Droottest=ON` to the CMake command line, the corresponding revision of roottest pointed to by `latest-stable` will be downloaded as required. ## PyROOT. - The `ROOT` Python module is now properly serializable so that it is automatically available in the Python environment if a function or ROOT object needs to be serialized. See issue [#6764](https://github.com/root-project/root/issues/6764) for a concrete usecase.; - Improve overload resolution of functions that accept classes with long inheritance trees. Now prefer to call the function overload of the most derived class type (PR [#9092](https://github.com/root-proje",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:39159,integrat,integrator,39159,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['integrat'],['integrator']
Integrability,"ython and C++ types in global operators; * Capture Cling error messages from cppdef and include in the Python exception; * Add a cppexec method to evalutate statements in Cling's global scope; * Support initialization of ``std::array<>`` from sequences; * Support C++17 style initialization of common STL containers; * Allow base classes with no virtual destructor (with warning); * Support const by-value returns in Python-side method overrides; * Support for cross-language multiple inheritance of C++ bases; * Allow for pass-by-value of ``std::unique_ptr`` through move; * Reduced dependencies on upstream code; * Put remaining upstream code in CppyyLegacy namespace. 2020-06-06: 1.7.1; -----------------. * Expose protected members in Python derived classes; * Support for deep Python-side derived hierarchies; * Do not generate a copy ctor in the Python derived class if private; * include, c_include, and cppdef now raise exceptions on error; * Allow mixing of keywords and default values; * Fix by-ptr return of objects in Python derived classes; * Fix for passing numpy boolean array through ``bool*``; * Fix assignment to ``const char*`` data members; * Support ``__restrict`` and ``__restrict__`` in interfaces; * Allow passing sequence of strings through ``const char*[]`` argument. 2020-04-27: 1.7.0; -----------------. * Upgrade to cppyy-cling 6.20.4; * Pre-empt upstream's propensity of making ``std`` classes etc. global; * Allow initialization of ``std::map`` from dict with the correct types; * Allow initialization of ``std::set`` from set with the correct types; * Add optional nonst/non-const selection to ``__overload__``; * Automatic smartification of normal object passed as smartptr by value; * Fix crash when handing a by-value object to make_shared; * Fixed a few shared/unique_ptr corner cases; * Fixed conversion of ``std::function`` taking an STL class parameter; * No longer attempt auto-cast on classes without RTTI; * Fix for ``iter()`` iteration on generic STL contain",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:13034,interface,interfaces,13034,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['interface'],['interfaces']
Integrability,ython interface: PyROOT. \defgroup tutorial_pythia Pythia tutorials; \ingroup Tutorials; \brief Examples showing the pythia usage. \defgroup tutorial_quadp Quadratic programming package.; \ingroup Tutorials; \brief Example showing the usage of the quadratic programming package quadp. \defgroup tutorial_r R tutorials; \ingroup Tutorials; \brief Examples showing the R interface. \defgroup tutorial_roostats RooStats Tutorials; \ingroup Tutorials; \brief These tutorials illustrate the main features of RooStats. \defgroup tutorial_spectrum Spectrum tutorials; \ingroup Tutorials; \brief Examples showing the TSpectrum and TSpectrumPainter usage. \defgroup tutorial_splot TSPlot tutorials; \ingroup Tutorials; \brief This tutorial illustrates the use of class TSPlot. \defgroup tutorial_sql SQL tutorials; \ingroup Tutorials; \brief Examples showing the SQL classes. \defgroup tutorial_tmva TMVA tutorials; \ingroup Tutorials; \brief Example code which illustrates how to use the TMVA toolkit. \defgroup tutorial_unfold TUnfold tutorials; \ingroup Tutorials; \brief Test programs for the classes TUnfold and related. \defgroup tutorial_unuran Unuran tutorials; \ingroup Tutorials; \brief Examples showing unuran capabilities. \defgroup tutorial_vecops VecOps tutorials; \ingroup Tutorials; \brief These examples show the functionalities of the VecOps utilities. \defgroup tutorial_FITS FITS files interface tutorials; \ingroup Tutorials; \brief Examples showing the FITS file interface. \defgroup tutorial_xml XML tutorials; \ingroup Tutorials; \brief XML examples. \defgroup tutorial_proof Proof tutorials; \ingroup Tutorials; \brief These examples aim to illustrate the usage of PROOF. \defgroup tutorial_webcanv TWebCanvas tutorials; \ingroup Tutorials; \brief Examples showing the special features of web-based canvas. \defgroup tutorial_webgui Webgui tutorials; \ingroup Tutorials; \brief Webgui examples. \defgroup tutorial_legacy Legacy tutorials; \ingroup Tutorials; \brief Legacy Tutorials; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md:6004,interface,interface,6004,tutorials/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md,2,['interface'],['interface']
Integrability,"ython itself.; As a rule, Python is always the best place, far more so than any intermediate; language, to do Python-thingies.; Since all bound proxies are normal Python classes, functions, etc., Python's; introspection (and regular expressions engine) can be used to provide rule; based improvements in a way similar to the use of directives in an; intermediate language. On a practical note, it's often said that an automatic binder can provide; bindings to 95% of your code out-of-the-box, with only the remaining part; needing manual intervention.; This is broadly true, but realize that that 5% contains the most difficult; cases and is where 20-30% of the effort would have gone in case the bindings; were done fully manually.; It is therefore important to consider what manual tools an automatic binder; offers and to make sure they fit your work style and needs, because you are; going to spend a significant amount of time with them. `LLVM dependency`; -----------------. cppyy depends on `LLVM`_, through Cling.; LLVM is properly internalized, so that it doesn't conflict with other uses;; and in particular it is fine to mix `Numba`_ and cppyy code.; It does mean a download cost of about 20MB for the binary wheel (exact size; differs per platform) on installation, and additional `primarily initial`; memory overheads at run-time.; Whether this is onerous depends strongly not only on the application, but; also on the rest of the software stack. The initial cost of loading cppyy, and thus starting the Cling interpreter,; is about 45MB (platform dependent).; Initial uses of standard (e.g. STL) C++ results in deserialization of the; precompiled header at another eventual total cost of about 25MB (again,; platform dependent).; The actual bindings of course also carry overheads.; As a rule of thumb, you should budget for ~100MB all-in for the overhead; caused by the bindings. Other binders do not have this initial memory overhead, but do of course; occur an overhead per module, cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:7878,depend,depends,7878,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['depend'],['depends']
Integrability,"y}; \right|$. - $r_{ij}$ are the 3x3 rotation matrix components; - $t_x$,$t_y$,$t_z$ are the translation components; - $s_x$, $s_y$, $s_z$ are arbitrary scale constants on each axis. The disadvantage in using this approach is that computation for 4x4; matrices is expensive. Even combining two translations would become a; multiplication of their corresponding matrices, which is quite an; undesired effect. On the other hand, it is not a good idea to store a; translation as a block of 16 numbers. We have therefore chosen to; implement each basic transformation type as a class deriving from the; same basic abstract class and handling its specific data and; point/vector transformation algorithms. The base class **`TGeoMatrix`** defines abstract methods for:. - Translation, rotation and scale getters. Every derived class stores; only its specific data, e.g. a translation stores an array of 3; doubles and a rotation an array of 9. However, getting the; **`TGeoTranslation`** rotation array through the base; **`TGeoMatrix`** interface is a legal operation. The answer in this; case is a pointer to a global constant array representing an; identity rotation. ``` {.cpp}; Double_t *TGeoMatrix::GetTranslation() const;; Double_t *TGeoMatrix::GetRotation() const;; Double_t *TGeoMatrix::GetScale() const;; ```. - Master-to-local and local-to-master point and vector transformations; :. ``` {.cpp}; void TGeoMatrix::MasterToLocal(const Double_t *master,; Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local,; Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master,; Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local,; Double_t *master); ```. Here `master` and `local` are arrays of size 3. These methods allow; correct conversion also for reflections. - Transformation type finding:. ``` {.cpp}; Bool_t TGeoMatrix::IsIdentity() const;; Bool_t TGeoMatrix::IsTranslation() const;; Bool_t TGeoMatrix::IsRotation() const;; Bool_t TGeoMa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:94434,interface,interface,94434,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"zation in clang. N: Devang Patel; E: dpatel@apple.com; D: LTO tool, PassManager rewrite, Loop Pass Manager, Loop Rotate; D: GCC PCH Integration (llvm-gcc), llvm-gcc improvements; D: Optimizer improvements, Loop Index Split. N: Ana Pazos; E: apazos@codeaurora.org; D: Fixes and improvements to the AArch64 backend. N: Wesley Peck; E: peckw@wesleypeck.com; W: http://wesleypeck.com/; D: MicroBlaze backend. N: Francois Pichet; E: pichet2000@gmail.com; D: MSVC support. N: Simon Pilgrim; E: llvm-dev@redking.me.uk; D: X86 backend, Selection DAG, Scheduler Models and Cost Tables. N: Adrian Prantl; E: aprantl@apple.com; D: Debug Information. N: Vladimir Prus; W: http://vladimir_prus.blogspot.com; E: ghost@cs.msu.su; D: Made inst_iterator behave like a proper iterator, LowerConstantExprs pass. N: QIU Chaofan; E: qiucofan@cn.ibm.com; D: PowerPC Backend Developer. N: Kalle Raiskila; E: kalle.rasikila@nokia.com; D: Some bugfixes to CellSPU. N: Xerxes Ranby; E: xerxes@zafena.se; D: Cmake dependency chain and various bug fixes. N: Alex Rosenberg; E: alexr@leftfield.org; I: arosenberg; D: ARM calling conventions rewrite, hard float support. N: Chad Rosier; E: mcrosier@codeaurora.org; I: mcrosier; D: AArch64 fast instruction selection pass; D: Fixes and improvements to the ARM fast-isel pass; D: Fixes and improvements to the AArch64 backend. N: Nadav Rotem; E: nadav.rotem@me.com; D: X86 code generation improvements, Loop Vectorizer, SLP Vectorizer. N: Roman Samoilov; E: roman@codedgers.com; D: MSIL backend. N: Duncan Sands; E: baldrick@free.fr; I: baldrick; D: Ada support in llvm-gcc; D: Dragonegg plugin; D: Exception handling improvements; D: Type legalizer rewrite. N: Ruchira Sasanka; E: sasanka@uiuc.edu; D: Graph coloring register allocator for the Sparc64 backend. N: Alina Sbirlea; E: alina.sbirlea@gmail.com; D: MemorySSA, BatchAA, misc loop and new pass manager work. N: Arnold Schwaighofer; E: arnold.schwaighofer@gmail.com; D: Tail call optimization for the x86 backend. N: Shanto",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:10780,depend,dependency,10780,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,1,['depend'],['dependency']
Integrability,"zing parameters. Implementations are allowed to avoid unnecessary temporaries, and HLSL's strict; no-alias rules can enable some trivial optimizations. Array Temporaries; -----------------. Given the following example:. .. code-block:: c++. void fn(float a[4]) {; a[0] = a[1] + a[2] + a[3];; }. float4 main() : SV_Target {; float arr[4] = {1, 1, 1, 1};; fn(arr);; return float4(arr[0], arr[1], arr[2], arr[3]);; }. In C or C++, the array parameter decays to a pointer, so after the call to; ``fn``, the value of ``arr[0]`` is ``3``. In HLSL, the array is passed by value,; so modifications inside ``fn`` do not propagate out. .. note::. DXC may pass unsized arrays directly as decayed pointers, which is an; unfortunate behavior divergence. Out Parameter Temporaries; -------------------------. .. code-block:: c++. void Init(inout int X, inout int Y) {; Y = 2;; X = 1;; }. void main() {; int V;; Init(V, V); // MSVC (or clang-cl) V == 2, Clang V == 1; }. In the above example the ``Init`` function's behavior depends on the C++; implementation. C++ does not define the order in which parameters are; initialized or destroyed. In MSVC and Clang's MSVC compatibility mode, arguments; are emitted right-to-left and destroyed left-to-right. This means that the; parameter initialization and destruction occurs in the order: {``Y``, ``X``,; ``~X``, ``~Y``}. This causes the write-back of the value of ``Y`` to occur last,; so the resulting value of ``V`` is ``2``. In the Itanium C++ ABI, the parameter; ordering is reversed, so the initialization and destruction occurs in the order:; {``X``, ``Y``, ``~Y``, ``X``}. This causes the write-back of the value ``X`` to; occur last, resulting in the value of ``V`` being set to ``1``. .. code-block:: c++. void Trunc(inout int3 V) { }. void main() {; float3 F = {1.5, 2.6, 3.3};; Trunc(F); // F == {1.0, 2.0, 3.0}; }. In the above example, the argument expression ``F`` undergoes element-wise; conversion from a float vector to an integer vector to create a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst:3248,depend,depends,3248,interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,1,['depend'],['depends']
Integrability,"{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. Matcher<EnumDecl>isScoped; Matches C++11 scoped enum declaration. Example matches Y (matcher = enumDecl(isScoped())); enum X {};; enum class Y {};. Matcher<Expr>isInstantiationDependent; Matches expressions that are instantiation-dependent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bound of ""Chars"" in the following example is; value-dependent.; template<int Size> int f() { return Size; }; expr(isValueDependent()) matches return Size. Matcher<Expr>nullPointerConstant; Matches expressions that resolve to a null pointer constant, such as; GNU's __null, C++11's nullptr, or C's NULL macro. Given:; void *v1 = NULL;; void *v2 = nullptr;; void *v3 = __null; // GNU extension; char *cp = (char *)0;; int *ip = 0;; int i = 0;; expr(nullPointerConstant()); matches the initializer for v1, v2, v3, cp, and ip. Does not match the; initializer for i. Matcher<FieldDecl>hasBitWidthunsigned Width; Matches non-static data members that are bit-fields of the specified; bit width. Given; class C {; int a : 2;; int b : 4;; int c : 2;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:86797,depend,dependent,86797,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['depend'],['dependent']
Integrability,"{; ^. The C++ standard says that unqualified names like Multiply; are looked up in two ways. First, the compiler does unqualified lookup in the scope; where the name was written. For a template, this means the lookup is; done at the point where the template is defined, not where it's; instantiated. Since Multiply hasn't been declared yet at; this point, unqualified lookup won't find it. Second, if the name is called like a function, then the compiler; also does argument-dependent lookup (ADL). (Sometimes; unqualified lookup can suppress ADL; see [basic.lookup.argdep]p3 for; more information.) In ADL, the compiler looks at the types of all the; arguments to the call. When it finds a class type, it looks up the; name in that class's namespace; the result is all the declarations it; finds in those namespaces, plus the declarations from unqualified; lookup. However, the compiler doesn't do ADL until it knows all the; argument types. In our example, Multiply is called with dependent; arguments, so ADL isn't done until the template is instantiated. At; that point, the arguments both have type int, which doesn't; contain any class types, and so ADL doesn't look in any namespaces.; Since neither form of lookup found the declaration; of Multiply, the code doesn't compile. Here's another example, this time using overloaded operators,; which obey very similar rules. #include <iostream>. template<typename T>; void Dump(const T& value) {; std::cout << value << ""\n"";; }. namespace ns {; struct Data {};; }. std::ostream& operator<<(std::ostream& out, ns::Data data) {; return out << ""Some data"";; }. void Use() {; Dump(ns::Data());; }; Again, Clang complains:. my_file2.cpp:5:13: error: call to function 'operator<<' that is neither visible in the template definition nor found by argument-dependent lookup; std::cout << value << ""\n"";; ^; my_file2.cpp:17:3: note: in instantiation of function template specialization 'Dump<ns::Data>' requested here; Dump(ns::Data());; ^; my_file2.cpp:12:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:13376,depend,dependent,13376,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['depend'],['dependent']
Integrability,"{__FETCHREF}; WORKING_DIRECTORY ${repo_dir}); execute_process(COMMAND ${GIT_EXECUTABLE} checkout -f ${__FETCHREF}; WORKING_DIRECTORY ${repo_dir}); endif(); endif(); if(DEFINED __REPO_DIR_VARIABLE); set(${__REPO_DIR_VARIABLE} ${repo_dir} PARENT_SCOPE); endif(); endfunction(). #---Enable asserts------------------------------------------------------------------------------; if(asserts); string(REGEX REPLACE ""-[UD]NDEBUG(=.*)?"" """" ""CMAKE_CXX_FLAGS_${_BUILD_TYPE_UPPER}"" ""${CMAKE_CXX_FLAGS_${_BUILD_TYPE_UPPER}}""); string(REGEX REPLACE ""-[UD]NDEBUG(=.*)?"" """" ""CMAKE_C_FLAGS_${_BUILD_TYPE_UPPER}"" ""${CMAKE_C_FLAGS_${_BUILD_TYPE_UPPER}}""); endif(). #---Enable CCache ------------------------------------------------------------------------------; if(ccache); find_program(CCACHE_COMMAND NAMES ccache ccache-swig); mark_as_advanced(CCACHE_COMMAND ${CCACHE_COMMAND}). if(EXISTS ${CCACHE_COMMAND}); message(STATUS ""Found ccache: ${CCACHE_COMMAND}""); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_COMMAND}); execute_process(COMMAND ${CCACHE_COMMAND} ""-V"" OUTPUT_VARIABLE CCACHE_VERSION); string(REGEX REPLACE ""ccache version ([0-9\\.]+).*"" ""\\1"" CCACHE_VERSION ${CCACHE_VERSION}); else(); message(STATUS ""Could NOT find ccache""); set(ccache OFF CACHE BOOL ""Use ccache (disabled since ccache was not found)"" FORCE); endif(); endif(). #---Enable distcc ------------------------------------------------------------------------------; if(distcc); find_program(DISTCC_COMMAND NAMES distcc); mark_as_advanced(DISTCC_COMMAND ${DISTCC_COMMAND}); if(EXISTS ${DISTCC_COMMAND}); message(STATUS ""Found distcc: ${DISTCC_COMMAND}""); if (ccache); # If ccache is enabled, use distcc as CCACHE_PREFIX; message(STATUS ""Because ccache is enabled, CCACHE_PREFIX is set to ${DISTCC_COMMAND}""); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ""CCACHE_PREFIX=${DISTCC_COMMAND} ${CCACHE_COMMAND}""); else(); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${DISTCC_COMMAND}); endif(); execute_process(COMMAND ${DISTCC_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:8827,message,message,8827,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['message'],['message']
Integrability,"|-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDep",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:87670,depend,dependence,87670,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependence']
Integrability,"|. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. Example:. ```{.cpp}; #include ""Math/Functor.h"". class MyFunction1D {. public:. double operator()(double x) const {; return x*x;; }. double Eval(double x) const { return x+x; }; };. double freeFunction1D(double x ) {; return 2*x;; }. int main(); {; // wrapping a free function; ROOT::Math::Functor1D f1(&freeFunction1D);. MyFunction1D myf1;. // wrapping a function object implementing operator(); ROOT::Math::Functor1D f2(myf1);. // wrapping a class member function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The `ROOT::Math::GradFunctor1D` class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways:; * Any object implementing both `double operator()( double)` for the function evaluation and `double Derivative(double)` for the function derivative.; * Any object implementing any member function like `Foo::XXX(double )` for the function evaluation and any other member function like `Foo::YYY(double )` for the derivative.; * Any two function objects implementing `double operator()( double )` . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of; type `double ()(double )`. #### Wrapping Multi-dimensional Functions. The class `ROOT::Math::Functor` is used to wrap in a very simple and convenient ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:43853,wrap,wrapping,43853,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wrapping']
Integrability,"|; +--------------------+---------------+----------------+----------------+----------------+. ## Mathematical Functions. The mathematical functions are present in both `MathCore` and `MathMore`; libraries. All mathematical functions are implemented as free functions; in the namespace **`ROOT::Math`**. The most used functions are in the; `MathCore` library while the others are in the `MathMore` library. The; functions in `MathMore` are all using the implementation of the GNU; Scientific Library (GSL). The naming of the special functions is the; same defined in the C++; [Technical Report on Standard Library extensions](Technical Report on; Standard Library extensions).; The special functions are defined in the header file `Math/SpecFunc.h`. ### Special Functions in MathCore. - `ROOT::Math::beta(double x,double y) - `evaluates the beta function:; $$B(x,y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x+y)}$$. - `double ROOT::Math::erf(double x)` - evaluates the error function; encountered in integrating the normal; distribution:; $$erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt$$. - `double ROOT::Math::erfc(double x)` - evaluates the complementary; error function:; $$erfc(x) = 1 - erf(x) = \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt$$. - `double ROOT::Math::tgamma(double x)` - calculates the gamma; function:; $$\Gamma(x) = \int_{0}^{\infty} t^{x-1} e^{-t} dt$$. ### Special Functions in MathMore. - `double ROOT::Math::assoc_legendre(unsigned l,unsigned m,double x) -`computes; the associated Legendre polynomials (with `m>=0`, `l>=m` and; `|x|<1)`:; $$P_{l}^{m}(x) = (1-x^2)^{m/2} \frac{d^m}{dx^m} P_{l}(x)$$. - `double ROOT::Math::comp_ellint_1(double k)` - calculates the; complete elliptic integral of the first kind (with $0 \le k^2 \le 1$:; $$; K(k) = F(k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{\sqrt{1 - k^2 \sin^2{\theta}}}; $$. - `double ROOT::Math::comp_ellint_2(double k)` - calculates the; complete elliptic integral of the second kind (with $0 \le k^2 \le 1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:24633,integrat,integrating,24633,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integrating']
Integrability,"|; | 0x0F | 32 | SplitIndex32 | Like Index32 but pages are stored in split + delta encoding |; | 0x10 | 64 | SplitReal64 | Like Real64 but in split encoding |; | 0x11 | 32 | SplitReal32 | Like Real32 but in split encoding |; | 0x12 | 16 | SplitReal16 | Like Real16 but in split encoding |; | 0x1A | 64 | SplitInt64 | Like Int64 but in split + zigzag encoding |; | 0x13 | 64 | SplitUInt64 | Like UInt64 but in split encoding |; | 0x1B | 64 | SplitInt32 | Like Int32 but in split + zigzag encoding |; | 0x14 | 32 | SplitUInt32 | Like UInt32 but in split encoding |; | 0x1C | 16 | SplitInt16 | Like Int16 but in split + zigzag encoding |; | 0x15 | 16 | SplitUInt16 | Like UInt16 but in split encoding |; | 0x1D |10-31 | Real32Trunc | IEEE-754 single precision float with truncated mantissa |; | 0x1E | 1-32 | Real32Quant | Real value contained in a specified range with an underlying quantized integer representation |. The ""split encoding"" columns apply a byte transformation encoding to all pages of that column; and in addition, depending on the column type, delta or zigzag encoding:. Split (only); : Rearranges the bytes of elements: All the first bytes first, then all the second bytes, etc. Delta + split; : The first element is stored unmodified, all other elements store the delta to the previous element.; Followed by split encoding. Zigzag + split; : Used on signed integers only; it maps $x$ to $2x$ if $x$ is positive and to $-(2x+1)$ if $x$ is negative.; Followed by split encoding. **Note**: these encodings always happen within each page, thus decoding should be done page-wise,; not cluster-wise. The `Real32Trunc` type column is a variable-sized floating point column; with lower precision than `Real32` and `SplitReal32`.; It is an IEEE-754 single precision float with some of the mantissa's least significant bits truncated. The `Real32Quant` type column is a variable-sized real column that is internally represented as an integer within; a specified range of values. For this column",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:22690,depend,depending,22690,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['depend'],['depending']
Integrability,"} -fno-rtti""); endif(). if(MSVC); add_definitions(/DNOMINMAX); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} /Zc:preprocessor""); endif(). if (APPLE); set(CMAKE_MODULE_LINKER_FLAGS ""-Wl,-flat_namespace -Wl,-undefined -Wl,suppress""); endif (). include(CMakeParseArguments). macro(add_cling_subdirectory name); add_llvm_subdirectory(CLING TOOL ${name}); endmacro(). file (STRINGS ""VERSION"" CLING_VERSION); string(REGEX REPLACE ""([0-9]).[0-9]+~[a-zA-Z]+"" ""\\1"" CLING_VERSION_MAJOR ${CLING_VERSION}); string(REGEX REPLACE ""[0-9].([0-9]+)~[a-zA-Z]+"" ""\\1"" CLING_VERSION_MINOR ${CLING_VERSION}). if(DEFINED CLING_ROOT_BUILD); # Building as part of ROOT; visibility is ""inherited"" from ROOT/interpreter.; set(CLING_VERSION ROOT_${CLING_VERSION}); else(); # Lots of cling is needed at runtime (e.g. Value, or Interpreter::Evaluate()).; # The JIT needs to be able to resolve these symbols from cling; unhide them.; set(CMAKE_CXX_VISIBILITY_PRESET default); set(CMAKE_C_VISIBILITY_PRESET default); set(CMAKE_VISIBILITY_INLINES_HIDDEN ""ON""); endif(); message(STATUS ""Cling version (from VERSION file): ${CLING_VERSION}""). set(CLING_VERSION_PATCHLEVEL 0). macro(set_cling_windows_version_resource_properties name); if(DEFINED windows_resource_file); set_windows_version_resource_properties(${name} ${windows_resource_file}; VERSION_MAJOR ${CLING_VERSION_MAJOR}; VERSION_MINOR ${CLING_VERSION_MINOR}; VERSION_PATCHLEVEL ${CLING_VERSION_PATCHLEVEL}; VERSION_STRING ""${CLING_VERSION} (${BACKEND_PACKAGE_STRING})""; PRODUCT_NAME ""cling""); endif(); endmacro(). include_directories(BEFORE SYSTEM ${LLVM_INCLUDE_DIRS} ${CLANG_INCLUDE_DIRS}). macro(add_cling_library name); cmake_parse_arguments(ARG; ""SHARED""; """"; ""ADDITIONAL_HEADERS""; ${ARGN}); set(srcs); if(MSVC_IDE OR XCODE); # Add public headers; file(RELATIVE_PATH lib_path; ${CLING_SOURCE_DIR}/lib/; ${CMAKE_CURRENT_SOURCE_DIR}; ); if(NOT lib_path MATCHES ""^[.][.]""); file( GLOB_RECURSE headers; ${CLING_SOURCE_DIR}/include/cling/${lib_path}/*.h; ${CLING_SOURCE_DIR}/inc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt:11002,message,message,11002,interpreter/cling/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt,1,['message'],['message']
Integrability,"}""); endif(). # Must go after `DEFINED LLVM_LIBDIR_SUFFIX` check.; set(LLVM_LIBDIR_SUFFIX """" CACHE STRING ""Define suffix of library directory name (32/64)"" ). # Must go after `project(..)`.; include(GNUInstallDirs). # This C++ standard is required to build LLVM.; set(LLVM_REQUIRED_CXX_STANDARD 17). # If we find that the cache contains CMAKE_CXX_STANDARD it means that it's a old CMakeCache.txt; # and we can just inform the user and then reset it.; if($CACHE{CMAKE_CXX_STANDARD} AND $CACHE{CMAKE_CXX_STANDARD} LESS ${LLVM_REQUIRED_CXX_STANDARD}); message(WARNING ""Resetting cache value for CMAKE_CXX_STANDARD to ${LLVM_REQUIRED_CXX_STANDARD}""); unset(CMAKE_CXX_STANDARD CACHE); endif(). # if CMAKE_CXX_STANDARD is still set after the cache unset above it means that the user requested it; # and we allow it to be set to something newer than the required standard but otherwise we fail.; if(DEFINED CMAKE_CXX_STANDARD AND CMAKE_CXX_STANDARD LESS ${LLVM_REQUIRED_CXX_STANDARD}); message(FATAL_ERROR ""Requested CMAKE_CXX_STANDARD=${CMAKE_CXX_STANDARD} which is less than the required ${LLVM_REQUIRED_CXX_STANDARD}.""); endif(). set(CMAKE_CXX_STANDARD ${LLVM_REQUIRED_CXX_STANDARD} CACHE STRING ""C++ standard to conform to""); set(CMAKE_CXX_STANDARD_REQUIRED YES). if (CYGWIN); # Cygwin is a bit stricter and lack things like 'strdup', 'stricmp', etc in; # c++xx mode.; set(CMAKE_CXX_EXTENSIONS YES); else(); set(CMAKE_CXX_EXTENSIONS NO); endif(). if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES); message(FATAL_ERROR ""; No build type selected. You need to pass -DCMAKE_BUILD_TYPE=<type> in order to configure LLVM.; Available options are:; * -DCMAKE_BUILD_TYPE=Release - For an optimized build with no assertions or debug info.; * -DCMAKE_BUILD_TYPE=Debug - For an unoptimized build with assertions and debug info.; * -DCMAKE_BUILD_TYPE=RelWithDebInfo - For an optimized build with no assertions but with debug info.; * -DCMAKE_BUILD_TYPE=MinSizeRel - For a build optimized for size instead o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:3314,message,message,3314,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101964,interface,interface,101964,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameters&,\; unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameterState&,\; const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes; minimization of the $\mbox{FCN}$ and returns the result in form of a; FunctionMinimum. Minimization terminates either when the function has; been called (approximately) $\mbox{maxfcn}$ times, or when the; estimated vertical distance to minimum ($\mbox{EDM}$) is less than; $\mbox{tolerance*up}$. The default value of $\mbox{tolerance}$; is $\mbox{0.1}$. (see [howto:errordef]). ### Parameter interaction ###. MnSimplex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:49241,interface,interface,49241,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"}; cxxThrowExpr(); matches 'throw 5'. Matcher<Stmt>cxxTryStmtMatcher<CXXTryStmt>...; Matches try statements. try {} catch(int i) {}; cxxTryStmt(); matches 'try {}'. Matcher<Stmt>cxxUnresolvedConstructExprMatcher<CXXUnresolvedConstructExpr>...; Matches unresolved constructor call expressions. Example matches T(t) in return statement of f; (matcher = cxxUnresolvedConstructExpr()); template <typename T>; void f(const T& t) { return T(t); }. Matcher<Stmt>declRefExprMatcher<DeclRefExpr>...; Matches expressions that refer to declarations. Example matches x in if (x); bool x;; if (x) {}. Matcher<Stmt>declStmtMatcher<DeclStmt>...; Matches declaration statements. Given; int a;; declStmt(); matches 'int a'. Matcher<Stmt>defaultStmtMatcher<DefaultStmt>...; Matches default statements inside switch statements. Given; switch(a) { case 42: break; default: break; }; defaultStmt(); matches 'default:'. Matcher<Stmt>dependentCoawaitExprMatcher<DependentCoawaitExpr>...; Matches co_await expressions where the type of the promise is dependent. Matcher<Stmt>designatedInitExprMatcher<DesignatedInitExpr>...; Matches C99 designated initializer expressions [C99 6.7.8]. Example: Matches { [2].y = 1.0, [0].x = 1.0 }; point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };. Matcher<Stmt>doStmtMatcher<DoStmt>...; Matches do statements. Given; do {} while (true);; doStmt(); matches 'do {} while(true)'. Matcher<Stmt>explicitCastExprMatcher<ExplicitCastExpr>...; Matches explicit cast expressions. Matches any cast expression written in user code, whether it be a; C-style cast, a functional-style cast, or a keyword cast. Does not match implicit conversions. Note: the name ""explicitCast"" is chosen to match Clang's terminology, as; Clang uses the term ""cast"" to apply to implicit conversions as well as to; actual cast expressions. See also: hasDestinationType. Example: matches all five of the casts in; int((int)(reinterpret_cast<int>(static_cast<int>(const_cast<int>(42))))); but does not match the implicit con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:33729,depend,dependent,33729,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['depend'],['dependent']
Integrability,"};. // How to do it now:; RooFunctor functor{pdf, x, {}, normSet};; ROOT::Math::Functor1D func3{functor};; // Functor1D takes by reference, so the RooFunctor also needs to stay alive.; ```. For the same reason, the `RooMultiGenFunction` class that implements a multidimensional `ROOT::Math::IMultiGenFunction` is removed too.; It can easily be replaced by a `ROOT::Math::Functor`:. ```C++; RooFunctor functor{pdf, observables, {}, normSet};; ROOT::Math::Functor func4{functor, static_cast<unsigned int>(functor.nObs())};; // Functor takes by reference, so the RooFunctor also needs to stay alive.; ```. ### Define infinity as `std::numeric_limits<double>::infinity()`. RooFit has its internal representation of infinity in `RooNumber::infinity()`, which was `1e30` before. Now, it is defined as `std::numeric_limits<double>::infinity()`, to be consistent with the C++ standard library and other code. This change also affects the `RooNumber::isInfinite()` function. ### Remove `add(row, weight, weightError)` from RooAbsData interface. It was not good to have this signature in RooAbsData, because the; implementations in the two derived classes RooDataHist and RooDataSet were; inconsistent. The RooDataSet indeed took the weight error as the third argument, but; the RooDataHist version instead took the sum of weights squared, which; is equivalent to the squared weight error. Therefore, the virtual `RooAbsData::add(row, weight, weightError)` function was removed. ### Removal of `RooMomentMorphND` class. The `RooMomentMorphND` and `RooMomentMorphFuncND` were almost exactly the same,; only that one inherited from `RooAbsPdf` and the other from `RooAbsReal`. Thanks to the `RooWrapperPdf`, this code duplication in the RooFit implementation can now be avoided.; Instead of using the removed `RooMomentMorphND` (which is the pdf), you now need to use the `RooMomentMorphFuncND`,; change its behavior to exactly match the formter `RooMomentMorphND`, and then wrap it into a pdf object:. ```C++; R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:13322,interface,interface,13322,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['interface'],['interface']
Modifiability,"	addi r2, r2, 1; 	bdz later; 	b loop. This could be much better (bdnz instead of bdz) but it still beats us. If we; produced this with bdnz, the loop would be a single dispatch group. ===-------------------------------------------------------------------------===. Lump the constant pool for each function into ONE pic object, and reference; pieces of it as offsets from the start. For functions like this (contrived; to have lots of constants obviously):. double X(double Y) { return (Y*1.23 + 4.512)*2.34 + 14.38; }. We generate:. _X:; lis r2, ha16(.CPI_X_0); lfd f0, lo16(.CPI_X_0)(r2); lis r2, ha16(.CPI_X_1); lfd f2, lo16(.CPI_X_1)(r2); fmadd f0, f1, f0, f2; lis r2, ha16(.CPI_X_2); lfd f1, lo16(.CPI_X_2)(r2); lis r2, ha16(.CPI_X_3); lfd f2, lo16(.CPI_X_3)(r2); fmadd f1, f0, f1, f2; blr. It would be better to materialize .CPI_X into a register, then use immediates; off of the register to avoid the lis's. This is even more important in PIC ; mode. Note that this (and the static variable version) is discussed here for GCC:; http://gcc.gnu.org/ml/gcc-patches/2006-02/msg00133.html. Here's another example (the sgn function):; double testf(double a) {; return a == 0.0 ? 0.0 : (a > 0.0 ? 1.0 : -1.0);; }. it produces a BB like this:; LBB1_1: ; cond_true; lis r2, ha16(LCPI1_0); lfs f0, lo16(LCPI1_0)(r2); lis r2, ha16(LCPI1_1); lis r3, ha16(LCPI1_2); lfs f2, lo16(LCPI1_2)(r3); lfs f3, lo16(LCPI1_1)(r2); fsub f0, f0, f1; fsel f1, f0, f2, f3; blr . ===-------------------------------------------------------------------------===. PIC Code Gen IPO optimization:. Squish small scalar globals together into a single global struct, allowing the ; address of the struct to be CSE'd, avoiding PIC accesses (also reduces the size; of the GOT on targets with one). Note that this is discussed here for GCC:; http://gcc.gnu.org/ml/gcc-patches/2006-02/msg00133.html. ===-------------------------------------------------------------------------===. Fold add and sub with constant into non-extern, non-wea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:1933,variab,variable,1933,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,1,['variab'],['variable']
Modifiability," ! consteval {} }; void d() { if ! consteval {} else {} }; functionDecl(isConsteval()); matches the declaration of ""int a()"".; ifStmt(isConsteval()); matches the if statement in ""void b()"", ""void c()"", ""void d()"". Matcher<FunctionDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<FunctionDecl>isDefaulted; Matches defaulted function declarations. Given:; class A { ~A(); };; class B { ~B() = default; };; functionDecl(isDefaulted()); matches the declaration of ~B, but not ~A. Matcher<FunctionDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<FunctionDecl>isDeleted; Matches deleted function declarations. Given:; void Func();; void DeletedFunc() = delete;; functionDecl(isDeleted()); matches the declaration of DeletedFunc, but not Func. Matcher<FunctionDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isExternC; Matches extern ""C"" function or variable ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:91717,variab,variable,91717,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability," ""ClusterAnalysis"" predates the cluster-based organization of bindings, but; refers to the same concept: during invalidation and liveness analysis, all; bindings within a cluster must be treated in the same way for a conservative; model of program behavior. Default Bindings; ----------------. Most bindings in RegionStore are simple scalar values -- integers and pointers.; These are known as ""Direct"" bindings. However, RegionStore supports a second; type of binding called a ""Default"" binding. These are used to provide values to; all the elements of an aggregate type (struct or array) without having to; explicitly specify a binding for each individual element. When there is no Direct binding for a particular region, the store manager; looks at each super-region in turn to see if there is a Default binding. If so,; this value is used as the value of the original region. The search ends when; the base region is reached, at which point the RegionStore will pick an; appropriate default value for the region (usually a symbolic value, but; sometimes zero, for static data, or ""uninitialized"", for stack variables). .. code-block:: cpp. int manyInts[10];; manyInts[1] = 42; // Creates a Direct binding for manyInts[1].; print(manyInts[1]); // Retrieves the Direct binding for manyInts[1];; print(manyInts[0]); // There is no Direct binding for manyInts[0].; // Is there a Default binding for the entire array?; // There is not, but it is a stack variable, so we use; // ""uninitialized"" as the default value (and emit a; // diagnostic!). NOTE: The fact that bindings are stored as a base region plus an offset limits; the Default Binding strategy, because in C aggregates can contain other; aggregates. In the current implementation of RegionStore, there is no way to; distinguish a Default binding for an entire aggregate from a Default binding; for the sub-aggregate at offset 0. Lazy Bindings (LazyCompoundVal); -------------------------------. RegionStore implements an optimization for copy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:5760,variab,variables,5760,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,1,['variab'],['variables']
Modifiability," ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; you have not posted for review, but can be adapted to update existing reviews. * git interactive rebase back to the first commit you want to upload for review::. git rebase -i HEAD~<number of commits you have written>. * Mark all commits for editing by changing ""pick"" to ""edit"" in the instructions; git shows.; * Start the rebase (usually by writing and closing the instructions).; * For the first commit:. - Upload the current commit for a review (with ``arc diff`` or the web; interface). - Continue to the next commit with ``git rebase --continue``. * For the rest:. - Add the ""Depends on..."" line using ``git commit --amend``. - Upload for review. - Continue the rebase. * Once the rebase is complete, you've created your patch series. .. _finding-potential-reviewers:. Finding potential reviewers; ---------------------------. Here are a couple of ways to pick the initial reviewer(s):. * Use ``git blame`` and the commit log to find names of people who have; recently modified the same area of code tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:7831,adapt,adapted,7831,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['adapt'],['adapted']
Modifiability," ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken this rule to only; apply when the compiler-supplied default constructor would leave a member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name lookup. Some versions of GCC allow the redeclaration of function parameter names within a function prototype in C++ code, e.g. void f(int a, int a);. Clang diagnoses this error (where the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19976,variab,variable,19976,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variable']
Modifiability," ""fmadds $FRT, $FRA, $FRC, $FRB"",; [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),; F4RC:$FRB))]>;; def FADDS : AForm_2<59, 21,; (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRB),; ""fadds $FRT, $FRA, $FRB"",; [(set F4RC:$FRT, (fadd F4RC:$FRA, F4RC:$FRB))]>;. The highlighted portion of the instruction definitions indicates the pattern; used to match the instructions. The DAG operators (like ``fmul``/``fadd``); are defined in the ``include/llvm/Target/TargetSelectionDAG.td`` file.; ""``F4RC``"" is the register class of the input and result values. The TableGen DAG instruction selector generator reads the instruction patterns; in the ``.td`` file and automatically builds parts of the pattern matching code; for your target. It has the following strengths:. * At compiler-compile time, it analyzes your instruction patterns and tells you; if your patterns make sense or not. * It can handle arbitrary constraints on operands for the pattern match. In; particular, it is straight-forward to say things like ""match any immediate; that is a 13-bit sign-extended value"". For examples, see the ``immSExt16``; and related ``tblgen`` classes in the PowerPC backend. * It knows several important identities for the patterns defined. For example,; it knows that addition is commutative, so it allows the ``FMADDS`` pattern; above to match ""``(fadd X, (fmul Y, Z))``"" as well as ""``(fadd (fmul X, Y),; Z)``"", without the target author having to specially handle this case. * It has a full-featured type-inferencing system. In particular, you should; rarely have to explicitly tell the system what type parts of your patterns; are. In the ``FMADDS`` case above, we didn't have to tell ``tblgen`` that all; of the nodes in the pattern are of type 'f32'. It was able to infer and; propagate this knowledge from the fact that ``F4RC`` has type 'f32'. * Targets can define their own (and rely on built-in) ""pattern fragments"".; Pattern fragments are chunks of reusable patterns that get inlined into your; patterns during ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:48918,extend,extended,48918,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['extend'],['extended']
Modifiability," ""inline"", ""Procedure Integration""),; clEnumVal(strip , ""Strip Symbols"")));. This defines a variable that is conceptually of the type; ""``std::vector<enum Opts>``"". Thus, you can access it with standard vector; methods:. .. code-block:: c++. for (unsigned i = 0; i != OptimizationList.size(); ++i); switch (OptimizationList[i]); ... ... to iterate through the list of options specified. Note that the ""``cl::list``"" template is completely general and may be used with; any data types or other arguments that you can use with the ""``cl::opt``""; template. One especially useful way to use a list is to capture all of the; positional arguments together if there may be more than one specified. In the; case of a linker, for example, the linker takes several '``.o``' files, and; needs to capture them into a list. This is naturally specified as:. .. code-block:: c++. ...; cl::list<std::string> InputFilenames(cl::Positional, cl::desc(""<Input files>""), cl::OneOrMore);; ... This variable works just like a ""``vector<string>``"" object. As such, accessing; the list is simple, just like above. In this example, we used the; `cl::OneOrMore`_ modifier to inform the CommandLine library that it is an error; if the user does not specify any ``.o`` files on our command line. Again, this; just reduces the amount of checking we have to do. Collecting options as a set of flags; ------------------------------------. Instead of collecting sets of options in a list, it is also possible to gather; information for enum values in a **bit vector**. The representation used by the; `cl::bits`_ class is an ``unsigned`` integer. An enum value is represented by a; 0/1 in the enum's ordinal value bit position. 1 indicating that the enum was; specified, 0 otherwise. As each specified value is parsed, the resulting enum's; bit is set in the option's bit vector:. .. code-block:: c++. bits |= 1 << (unsigned)enum;. Options that are specified multiple times are redundant. Any instances after; the first are discarded.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:21032,variab,variable,21032,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability," $ # Check that the .ast file is generated:; $ ls; compile_commands.json foo.cpp.ast foo.cpp main.cpp; $. The next step is to create a CTU index file which holds the `USR` name and location of external definitions in the; source files in format `<USR-Length>:<USR> <File-Path>`:. .. code-block:: bash. $ clang-extdef-mapping -p . foo.cpp; 9:c:@F@foo# /path/to/your/project/foo.cpp; $ clang-extdef-mapping -p . foo.cpp > externalDefMap.txt. We have to modify `externalDefMap.txt` to contain the name of the `.ast` files instead of the source files:. .. code-block:: bash. $ sed -i -e ""s/.cpp/.cpp.ast/g"" externalDefMap.txt. We still have to further modify the `externalDefMap.txt` file to contain relative paths:. .. code-block:: bash. $ sed -i -e ""s|$(pwd)/||g"" externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.ast foo.cpp foo.cpp.ast main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp foo.cpp.ast main.cp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:3596,config,config,3596,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,2,['config'],['config']
Modifiability," $ opt -enable-debugify -pass-to-test sample.ll. # Suppresses verbose debugify output.; $ opt -enable-debugify -debugify-quiet -pass-to-test sample.ll. # Prepend -debugify before and append -check-debugify -strip after; # each pass on the pipeline (similar to -verify-each).; $ opt -debugify-each -O2 sample.ll. In order for ``check-debugify`` to work, the DI must be coming from; ``debugify``. Thus, modules with existing DI will be skipped. ``debugify`` can be used to test a backend, e.g:. .. code-block:: bash. $ opt -debugify < sample.ll | llc -o -. There is also a MIR-level debugify pass that can be run before each backend; pass, see:; :ref:`Mutation testing for MIR-level transformations<MIRDebugify>`. ``debugify`` in regression tests; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The output of the ``debugify`` pass must be stable enough to use in regression; tests. Changes to this pass are not allowed to break existing tests. .. note::. Regression tests must be robust. Avoid hardcoding line/variable numbers in; check lines. In cases where this can't be avoided (say, if a test wouldn't; be precise enough), moving the test to its own file is preferred. .. _MIRDebugify:. Test original debug info preservation in optimizations; ------------------------------------------------------. In addition to automatically generating debug info, the checks provided by; the ``debugify`` utility pass can also be used to test the preservation of; pre-existing debug info metadata. It could be run as follows:. .. code-block:: bash. # Run the pass by checking original Debug Info preservation.; $ opt -verify-debuginfo-preserve -pass-to-test sample.ll. # Check the preservation of original Debug Info after each pass.; $ opt -verify-each-debuginfo-preserve -O2 sample.ll. Limit number of observed functions to speed up the analysis:. .. code-block:: bash. # Test up to 100 functions (per compile unit) per pass.; $ opt -verify-each-debuginfo-preserve -O2 -debugify-func-limit=100 sample.ll. Please do note th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:13436,variab,variable,13436,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['variab'],['variable']
Modifiability," (!LHSE); return LogErrorV(""destination of '=' must be a variable"");. Unlike the rest of the binary operators, our assignment operator doesn't; follow the ""emit LHS, emit RHS, do computation"" model. As such, it is; handled as a special case before the other binary operators are handled.; The other strange thing is that it requires the LHS to be a variable. It; is invalid to have ""(x+1) = expr"" - only things like ""x = expr"" are; allowed. .. code-block:: c++. // Codegen the RHS.; Value *Val = RHS->codegen();; if (!Val); return nullptr;. // Look up the name.; Value *Variable = NamedValues[LHSE->getName()];; if (!Variable); return LogErrorV(""Unknown variable name"");. Builder->CreateStore(Val, Variable);; return Val;; }; ... Once we have the variable, codegen'ing the assignment is; straightforward: we emit the RHS of the assignment, create a store, and; return the computed value. Returning a value allows for chained; assignments like ""X = (Y = Z)"". Now that we have an assignment operator, we can mutate loop variables; and arguments. For example, we can now run code like this:. ::. # Function to print a double.; extern printd(x);. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. def test(x); printd(x) :; x = 4 :; printd(x);. test(123);. When run, this example prints ""123"" and then ""4"", showing that we did; actually mutate the value! Okay, we have now officially implemented our; goal: getting this to work requires SSA construction in the general; case. However, to be really useful, we want the ability to define our; own local variables, let's add this next!. User-defined Local Variables; ============================. Adding var/in is just like any other extension we made to; Kaleidoscope: we extend the lexer, the parser, the AST and the code; generator. The first step for adding our new 'var/in' construct is to; extend the lexer. As before, this is pretty trivial, the code looks like; thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:22209,variab,variables,22209,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability," (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; ```. #### Adding a Branch with a Fixed Length Array. At first, we create a tree and create branches for a subset of variables; in the C structure` Gctrak_t`. Then we add several types of branches.; The first branch reads seven floating-point values beginning at the; address of `'gstep.vect'`. You do not need to specify `&gstep.vect`,; because in C and C++ the array variable holds the address of the first; element. ``` {.cpp}; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; ```. #### Adding a Branch with a Variable Length Array. The next two branches are dependent on each other. The first holds the; length of the variable length array and the second holds the variable; length array. The `lmec` branch reads `nmec` number of integers; beginning at the address `gstep.lmec`. ``` {.cpp}; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; ```. The variable `nmec` is a random number and is reset for each entry. ``` {.cpp}; gstep.nmec = (Int_t)(5*gRandom->Rndm());; ```. #### Filling the Tree. In this emulation of Geant3, we generate and transport particles in a; magnetic field and store the particle parameters at each tracking step; in a ROOT tree. ### Analysis. In this analysis, we do not read the entire entry we only read one; branch. First, we set the address for the branch to the file `dstep`,; and then we use the `TBranch::GetEntry` method. Then we fill a histogram; with the `dstep` branch entries, draw it and fit it with a Gaussian. In; addition, we draw the particle's path using the three values in the; vector. Here we use the **`TTree::Draw`** method. It automatically creates",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:48458,variab,variable,48458,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,2,['variab'],['variable']
Modifiability," (also known as a “box-and whisker” plot or “candle stick” plot); is a convenient way to describe graphically a data distribution (D) with only; the five numbers. It was invented in 1977 by John Tukey. The five numbers are:. 1. The minimum value of the distribution D (Min).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1.; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q3): 75% of the data points in D are less than Q3.; 5. The maximum value of the distribution D (Max). ![A box plot describes a distribution with only five numbers. ](pictures/bp1.png). In ROOT Box Plots (Candle Plots) can be produced from a TTree using the; “candle” option in TTree::Draw(). ``` {.cpp}; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; ```. ### Using TTree::Scan; \index{tree!scan}. `TTree::Scan` can be used to print the content of the tree's entries; optional passing a selection. ``` {.cpp}; root[] MyTree->Scan();; ```. will print the first 8 variables of the tree. ``` {.cpp}; root[] MyTree->Scan(""*"");; ```. will print all the variable of the tree. Specific variables of the tree can be explicit selected by list them in; column separated list:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:104853,variab,variables,104853,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability," (code 6) contains a variable number of values representing; the bytes of a single dependent library name string, one of the libraries; mentioned in a ``deplibs`` declaration. There should be one ``DEPLIB`` record; for each library name referenced. MODULE_CODE_GLOBALVAR Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[GLOBALVAR, strtab offset, strtab size, pointer type, isconst, initid, linkage, alignment, section, visibility, threadlocal, unnamed_addr, externally_initialized, dllstorageclass, comdat, attributes, preemptionspecifier]``. The ``GLOBALVAR`` record (code 7) marks the declaration or definition of a; global variable. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the global variable.; See `STRTAB_BLOCK Contents`_. * *pointer type*: The type index of the pointer type used to point to this; global variable. * *isconst*: Non-zero if the variable is treated as constant within the module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: An encoding of the linkage type for this variable:. * ``external``: code 0; * ``weak``: code 1; * ``appending``: code 2; * ``internal``: code 3; * ``linkonce``: code 4; * ``dllimport``: code 5; * ``dllexport``: code 6; * ``extern_weak``: code 7; * ``common``: code 8; * ``private``: code 9; * ``weak_odr``: code 10; * ``linkonce_odr``: code 11; * ``available_externally``: code 12; * deprecated : code 13; * deprecated : code 14. * alignment*: The logarithm base 2 of the variable's requested alignment, plus 1. * *section*: If non-zero, the 1-based section index in the table of; `MODULE_CODE_SECTIONNAME`_ entries. .. _visibility:. * *visibility*: If present, an encoding of the visibility of this variable:. * ``default``: code 0; * ``hidden``: code 1; * ``protected``: code 2. .. _bcthreadlocal:. * *threadlocal*: If present, an encoding of the thread local storage mode of the; variable:. * ``not thread local``: code ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:27706,variab,variable,27706,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability," (data->store()->InheritsFrom(RooTreeDataStore::Class())==true)). In future release additional implementations of RooAbsDataStore will; be provided that will support new dataset functionality such as the; ability to construct 'joint' dataset from two input datasets without; the need to copy the input data and 'filtered' datasets that represent; a reduced view (in dimensions or by selecting events) of a dataset; without the need to copy content. Various workspace improvements. A number of smaller and larger improvements has been made to the RooWorkspace class. Direct interactive access to contents from CINT -; One can now directly access the contents of any RooWorkspace; on the ROOT commandline through CINT if the RooWorkspace::exportToCint() call is made.; In CINT, all workspace objects will appear as correctly typed references to workspace objects in; a C++ namespace with the same name as the RooWorkspace object. Given e.g. a workspace w, with a Gaussian p.d.f gauss in terms of variables; x,m,s one can now do. RooWorkspace w(""w"",true) ; // workspace with CINT interface activated; // ... fill workspace with RooGaussian gauss(x,m,s) ...; RooPlot* frame = w::x.frame() ;; w::gauss.plotOn(frame) ;. to access the workspace contents. Each reference has the correct type, e.g. w::gauss is; a RooGaussian&. If a workspace is deleted from memory, the corresponding CINT namespace; is removed as well. Note that this feature is strictly available in interpreted C++ only; A new tutorial macro has been added to illustrate this functionality in more detail: rf509_wsinteractive.C.; writeToFile -- A new utility method RooWorkspace::writeToFile() has been added; to simplify the process of saving a workspace to file; Named sets and parameter snapshots -- It is now possible to define and retrieve; named RooArgSets of objects that live in the workspace through methods; defineSet() and set(). While named sets merely group objects logically, methods loadSnapshot and; saveSnapshot allow to m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:16583,variab,variables,16583,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['variab'],['variables']
Modifiability," (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G ""Unix Makefiles"" ../llvm; make; Note: For subsequent Clang development, you can just run; make clang.; CMake allows you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and fin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:2800,config,configuration,2800,interpreter/llvm-project/clang/www/get_started.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html,1,['config'],['configuration']
Modifiability," (subclass of; ``TargetJITInfo``) that is used to emit binary code directly into memory. In the ``.cpp`` and ``.h``. files, initially stub up these methods and then; implement them later. Initially, you may not know which private members that; the class will need and which components will need to be subclassed. Preliminaries; -------------. To actually create your compiler backend, you need to create and modify a few; files. The absolute minimum is discussed here. But to actually use the LLVM; target-independent code generator, you must perform the steps described in the; :doc:`LLVM Target-Independent Code Generator <CodeGenerator>` document. First, you should create a subdirectory under ``lib/Target`` to hold all the; files related to your target. If your target is called ""Dummy"", create the; directory ``lib/Target/Dummy``. In this new directory, create a ``CMakeLists.txt``. It is easiest to copy a; ``CMakeLists.txt`` of another target and modify it. It should at least contain; the ``LLVM_TARGET_DEFINITIONS`` variable. The library can be named ``LLVMDummy``; (for example, see the MIPS target). Alternatively, you can split the library; into ``LLVMDummyCodeGen`` and ``LLVMDummyAsmPrinter``, the latter of which; should be implemented in a subdirectory below ``lib/Target/Dummy`` (for example,; see the PowerPC target). Note that these two naming schemes are hardcoded into ``llvm-config``. Using; any other naming scheme will confuse ``llvm-config`` and produce a lot of; (seemingly unrelated) linker errors when linking ``llc``. To make your target actually do something, you need to implement a subclass of; ``TargetMachine``. This implementation should typically be in the file; ``lib/Target/DummyTargetMachine.cpp``, but any file in the ``lib/Target``; directory will be built and should work. To use LLVM's target independent code; generator, you should do what all current machine backends do: create a; subclass of ``LLVMTargetMachine``. (To create a target from scratch, cre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:6575,variab,variable,6575,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['variab'],['variable']
Modifiability," (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:59068,variab,variables,59068,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variables']
Modifiability," * Reverse operators for ``std::complex`` targeting Python's ``complex``; * Version the precompiled header with the ``cppyy-cling`` package version; * Cover more iterator protocol use cases; * Add missing cppyy/__pyinstaller pkg to sdist; * Single-inheritance support for cross-inherited templated constructors; * Disallow ``float`` -> ``const long long&`` conversion; * Capture python exception message string in PyException from callbacks; * Thread safety in enum lookups. 2021-03-22: 1.9.5; -----------------. * Do not regulate direct smart pointers (many to one can lead to double deletion); * Use pkg_resources of ``CPyCppyy``, if available, to find the API include path. 2021-03-17: 1.9.4; -----------------. * Fix for installing into a directory that has a space in the name; * Fix empty collection printing through Cling on 64b Windows; * Fix accidental shadowing of derived class typedefs by same names in base; * Streamlined templated function lookups in namespaces; * Fix edge cases when decomposing std::function template arguments; * Enable multi-cross inheritance with non-C++ python bases; * Support Bound C++ functions as template argument; * Python functions as template arguments from ``__annotations__`` or ``__cpp_name__``; * Removed functions/apis deprecated in py3.9; * Improved support for older pip and different installation layouts. 2021-02-15: 1.9.3; -----------------. * Wheels for Linux now follow manylinux2014; * Enable direct calls of base class' methods in Python cross-overrides; * cppyy.bind_object can now re-cast types, incl. Python cross-derived ones; * Python cross-derived objects send to (and owned by) C++ retain Python state; * Ignore, for symbol lookups, libraries that can not be reloaded; * Use PathCanonicalize when resolving paths on Windows; * Add more ways of finding the backend library; * Improve error reporting when failed to find the backend library; * Workaround for mixing std::endl in JIT-ed and compiled code on Windows 32b; * Fixed a subtle ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:7357,inherit,inheritance,7357,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['inherit'],['inheritance']
Modifiability," * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed as before. .. code-block:: yaml. # Example of usage:; AlignTrailingComments:; Kind: Always; OverEmptyLines: 2. Nested configuration flags:. Alignment options. * ``TrailingCommentsAlignmentKinds Kind``; Specifies the way to align trailing comments. Possible values:. * ``TCAS_Leave`` (in configuration: ``Leave``); Leave trailing comments as they are. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Always`` (in configuration: ``Always``); Align trailing comments. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``TCAS_Never`` (in configuration: ``Never``); Don't align trailing comments but other formatter applies. .. code-block:: c++. int a; // comment; int ab; // comment. int abc; // comment; int abcd; // comment. * ``unsigned OverEmptyLines`` How many empty lines to apply alignment.; When both ``MaxEmptyLinesToKeep`` and ``OverEmptyLines`` are set to 2,; it formats like below. .. code-block:: c++. int a; // all these. int ab; // comments are. int abcdef; // aligned. When ``MaxEmptyLinesToKee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:23194,config,configuration,23194,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," * ``bool AlignFunctionPointers`` Only for ``AlignConsecutiveDeclarations``. Whether function pointers are; aligned. .. code-block:: c++. true:; unsigned i;; int &r;; int *p;; int (*f)();. false:; unsigned i;; int &r;; int *p;; int (*f)();. * ``bool PadOperators`` Only for ``AlignConsecutiveAssignments``. Whether short assignment; operators are left-padded to the same length as long ones in order to; put all assignment operators to the right of the left hand side. .. code-block:: c++. true:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. false:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. .. _AlignConsecutiveMacros:. **AlignConsecutiveMacros** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AlignConsecutiveMacros>`; Style of aligning consecutive macro definitions. ``Consecutive`` will result in formattings like:. .. code-block:: c++. #define SHORT_NAME 42; #define LONGER_NAME 0x007f; #define EVEN_LONGER_NAME (2); #define foo(x) (x * x); #define bar(y, z) (y + z). Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. For example, to align across empty lines and not across comments, either; of these work. .. code-block:: c++. AlignConsecutiveMacros: AcrossEmptyLines. AlignConsecutiveMacros:; Enabled: true; AcrossEmptyLines: true; AcrossComments: false. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. #define SHORT_NAME 42; #define LONGER_NAME 0x007f; #define EVEN_LONGER_NAME (2); #define foo(x) (x * x); #define bar(y, z) (y + z). int a = 1;; int somelongname = 2;; double c = 3;. int aaaa : 1;; int b : 12;; int ccc : 8;. int aaaa = 12;; float b = 23;; std::string ccc;. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;. false:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:16647,config,configuration,16647,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," * ``internal``: code 3; * ``linkonce``: code 4; * ``dllimport``: code 5; * ``dllexport``: code 6; * ``extern_weak``: code 7; * ``common``: code 8; * ``private``: code 9; * ``weak_odr``: code 10; * ``linkonce_odr``: code 11; * ``available_externally``: code 12; * deprecated : code 13; * deprecated : code 14. * alignment*: The logarithm base 2 of the variable's requested alignment, plus 1. * *section*: If non-zero, the 1-based section index in the table of; `MODULE_CODE_SECTIONNAME`_ entries. .. _visibility:. * *visibility*: If present, an encoding of the visibility of this variable:. * ``default``: code 0; * ``hidden``: code 1; * ``protected``: code 2. .. _bcthreadlocal:. * *threadlocal*: If present, an encoding of the thread local storage mode of the; variable:. * ``not thread local``: code 0; * ``thread local; default TLS model``: code 1; * ``localdynamic``: code 2; * ``initialexec``: code 3; * ``localexec``: code 4. .. _bcunnamedaddr:. * *unnamed_addr*: If present, an encoding of the ``unnamed_addr`` attribute of this; variable:. * not ``unnamed_addr``: code 0; * ``unnamed_addr``: code 1; * ``local_unnamed_addr``: code 2. .. _bcdllstorageclass:. * *dllstorageclass*: If present, an encoding of the DLL storage class of this variable:. * ``default``: code 0; * ``dllimport``: code 1; * ``dllexport``: code 2. * *comdat*: An encoding of the COMDAT of this function. * *attributes*: If nonzero, the 1-based index into the table of AttributeLists. .. _bcpreemptionspecifier:. * *preemptionspecifier*: If present, an encoding of the runtime preemption specifier of this variable:. * ``dso_preemptable``: code 0; * ``dso_local``: code 1. .. _FUNCTION:. MODULE_CODE_FUNCTION Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[FUNCTION, strtab offset, strtab size, type, callingconv, isproto, linkage, paramattr, alignment, section, visibility, gc, prologuedata, dllstorageclass, comdat, prefixdata, personalityfn, preemptionspecifier]``. The ``FUNCTION`` record (code 8) marks the declaration or d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:28915,variab,variable,28915,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability," * bit 6: ``noalias``; * bit 7: ``byval``; * bit 8: ``nest``; * bit 9: ``readnone``; * bit 10: ``readonly``; * bit 11: ``noinline``; * bit 12: ``alwaysinline``; * bit 13: ``optsize``; * bit 14: ``ssp``; * bit 15: ``sspreq``; * bits 16-31: ``align n``; * bit 32: ``nocapture``; * bit 33: ``noredzone``; * bit 34: ``noimplicitfloat``; * bit 35: ``naked``; * bit 36: ``inlinehint``; * bits 37-39: ``alignstack n``, represented as the logarithm; base 2 of the requested alignment, plus 1. .. _PARAMATTR_GROUP_BLOCK:. PARAMATTR_GROUP_BLOCK Contents; ------------------------------. The ``PARAMATTR_GROUP_BLOCK`` block (id 10) contains a table of entries; describing the attribute groups present in the module. These entries can be; referenced within ``PARAMATTR_CODE_ENTRY`` entries. .. _PARAMATTR_GRP_CODE_ENTRY:. PARAMATTR_GRP_CODE_ENTRY Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[ENTRY, grpid, paramidx, attr0, attr1, ...]``. The ``ENTRY`` record (code 3) contains *grpid* and *paramidx* values, followed; by a variable number of values describing a unique group of attributes. The; *grpid* value is a unique key for the attribute group, which can be referenced; within ``PARAMATTR_CODE_ENTRY`` entries. The *paramidx* value indicates which; set of attributes is represented, with 0 representing the return value; attributes, 0xFFFFFFFF representing function attributes, and other values; representing 1-based function parameters. Each *attr* is itself represented as a variable number of values:. ``kind, key [, ...], [value [, ...]]``. Each attribute is either a well-known LLVM attribute (possibly with an integer; value associated with it), or an arbitrary string (possibly with an arbitrary; string value associated with it). The *kind* value is an integer code; distinguishing between these possibilities:. * code 0: well-known attribute; * code 1: well-known attribute with an integer value; * code 3: string attribute; * code 4: string attribute with a string value. For well-known attributes ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:36344,variab,variable,36344,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability," **CompactNamespaces** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <CompactNamespaces>`; If ``true``, consecutive namespace declarations will be on the same; line. If ``false``, each namespace is declared on a new line. .. code-block:: c++. true:; namespace Foo { namespace Bar {; }}. false:; namespace Foo {; namespace Bar {; }; }. If it does not fit on a single line, the overflowing namespaces get; wrapped:. .. code-block:: c++. namespace Foo { namespace Bar {; namespace Extra {; }}}. .. _ConstructorInitializerAllOnOneLineOrOnePerLine:. **ConstructorInitializerAllOnOneLineOrOnePerLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ConstructorInitializerAllOnOneLineOrOnePerLine>`; This option is **deprecated**. See ``CurrentLine`` of; ``PackConstructorInitializers``. .. _ConstructorInitializerIndentWidth:. **ConstructorInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ConstructorInitializerIndentWidth>`; The number of characters to use for indentation of constructor; initializer lists as well as inheritance lists. .. _ContinuationIndentWidth:. **ContinuationIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ContinuationIndentWidth>`; Indent width for line continuations. .. code-block:: c++. ContinuationIndentWidth: 2. int i = // VeryVeryVeryVeryVeryLongComment; longFunction( // Again a long comment; arg);. .. _Cpp11BracedListStyle:. **Cpp11BracedListStyle** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <Cpp11BracedListStyle>`; If ``true``, format braced lists as best suited for C++11 braced; lists. Important differences:; - No spaces inside the braced list.; - No line break before the closing brace.; - Indentation with the continuation indent, not with the block indent. Fundamentally, C++11 braced lists are formatted exactly like function; calls would be formatted in their place. If the braced list follows a name; (e.g. a type or variable name), clang-format formats as if the ``{}`` were",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:58505,inherit,inheritance,58505,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['inherit'],['inheritance']
Modifiability," **LLVM_USE_INTEL_JITEVENTS**:BOOL; Enable building support for Intel JIT Events API. Defaults to OFF. **LLVM_USE_LINKER**:STRING; Add ``-fuse-ld={name}`` to the link invocation. The possible value depend on; your compiler, for clang the value can be an absolute path to your custom; linker, otherwise clang will prefix the name with ``ld.`` and apply its usual; search. For example to link LLVM with the Gold linker, cmake can be invoked; with ``-DLLVM_USE_LINKER=gold``. **LLVM_USE_OPROFILE**:BOOL; Enable building OProfile JIT support. Defaults to OFF. **LLVM_USE_PERF**:BOOL; Enable building support for Perf (linux profiling tool) JIT support. Defaults to OFF. **LLVM_USE_RELATIVE_PATHS_IN_FILES**:BOOL; Rewrite absolute source paths in sources and debug info to relative ones. The; source prefix can be adjusted via the LLVM_SOURCE_PREFIX variable. **LLVM_USE_RELATIVE_PATHS_IN_DEBUG_INFO**:BOOL; Rewrite absolute source paths in debug info to relative ones. The source prefix; can be adjusted via the LLVM_SOURCE_PREFIX variable. **LLVM_USE_SANITIZER**:STRING; Define the sanitizer used to build LLVM binaries and tests. Possible values; are ``Address``, ``Memory``, ``MemoryWithOrigins``, ``Undefined``, ``Thread``,; ``DataFlow``, and ``Address;Undefined``. Defaults to empty string. **LLVM_USE_SPLIT_DWARF**:BOOL; If enabled CMake will pass ``-gsplit-dwarf`` to the compiler. This option; reduces link-time memory usage by reducing the amount of debug information that; the linker needs to resolve. It is recommended for platforms using the ELF object; format, like Linux systems when linker memory usage is too high. **SPHINX_EXECUTABLE**:STRING; The path to the ``sphinx-build`` executable detected by CMake.; For installation instructions, see; https://www.sphinx-doc.org/en/master/usage/installation.html. **SPHINX_OUTPUT_HTML**:BOOL; If enabled (and ``LLVM_ENABLE_SPHINX`` is enabled) then the targets for; building the documentation as html are added (but not built by default unless; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:36232,variab,variable,36232,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability," **SpaceAroundPointerQualifiers** (``SpaceAroundPointerQualifiersStyle``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceAroundPointerQualifiers>`; Defines in which cases to put a space before or after pointer qualifiers. Possible values:. * ``SAPQ_Default`` (in configuration: ``Default``); Don't ensure spaces around pointer qualifiers and use PointerAlignment; instead. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Before`` (in configuration: ``Before``); Ensure that there is a space before pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void * const *x = NULL;. * ``SAPQ_After`` (in configuration: ``After``); Ensure that there is a space after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Both`` (in configuration: ``Both``); Ensure that there is a space both before and after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void * const *x = NULL;. .. _SpaceBeforeAssignmentOperators:. **SpaceBeforeAssignmentOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpaceBeforeAssignmentOperators>`; If ``false``, spaces will be removed before assignment operators. .. code-block:: c++. true: false:; int a = 5; vs. int a= 5;; a += 42; a+= 42;. .. _SpaceBeforeCaseColon:. **SpaceBeforeCaseColon** (``Boolean``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceBeforeCaseColon>`; If ``false``, spaces will be removed before case colon. .. code-block:: c++. true: false; switch (x) { vs. switch (x) {; case 1 : break; case 1: break;; } }. .. _SpaceBeforeCpp11BracedList:. **SpaceBeforeCpp11BracedList** (``Boolean``) :versionbadge:`clang-format 7` :ref:`¶ <SpaceBeforeCpp11BracedList>`; If ``true``, a space will be inserted before a C++11 braced list; used to i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:114064,config,configuration,114064,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," **`TLine`** class. The first method is used for; initializing the line objects we would build. It is called a; constructor. The second one is the `Draw` method itself. Therefore, to; build and draw a line, we have to do:. ``` {.cpp}; TLine l(0.2,0.2,0.8,0.9);; l.Draw();; ```. The first line builds the object `l` by calling its constructor. The; second line calls the **`TLine`**`::Draw()` method of this object. You; don't need to pass any parameters to this method since it applies to; the object `l`, which knows the coordinates of the line. These are; internal variables `x1`, `y1`, `x2`, `y2` that were initialized by the; constructor. ## Inheritance and Data Encapsulation. We have defined a **`TLine`** class that contains everything necessary; to draw a line. If we want to draw an arrow, is it so different from; drawing a line? We just have to draw a triangle at one end. It would; be very inefficient to define the class **`TArrow`** from scratch.; Fortunately, inheritance allows a class to be defined from an existing; class. We would write something like:. ``` {.cpp}; class TArrow : public TLine {; int ArrowHeadSize;; void Draw();; void SetArrowSize(int arrowsize);; }; ```. The keyword ""`public`"" will be explained later. The class **`TArrow`**; now contains everything that the class **`TLine`** does, and a couple; of more things, the size of the arrowhead and a function that can; change it. The Draw method of **`TArrow`** will draw the head and call; the draw method of **`TLine`**. We just have to write the code for; drawing the head!. ### Method Overriding. Giving the same name to a method (remember: method = member function; of a class) in the child class (**`TArrow`**) as in the parent; (**`TLine`**) does not give any problem. This is called **overriding**; a method. Draw in **`TArrow`** overrides Draw in **`TLine`**. There is; no possible ambiguity since, when one calls the `Draw()` method; this; applies to an object whose type is known. Suppose we have an objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:2556,inherit,inheritance,2556,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['inherit'],['inheritance']
Modifiability," **`TStyle`**. To change the current style for; histograms, the **`TStyle`** class provides a multitude of methods; ranging from setting the fill color to the axis tick marks. Here are; a few examples:. ``` {.cpp}; void SetHistFillColor(Color_t color = 1); void SetHistFillStyle(Style_t styl = 0); void SetHistLineColor(Color_t color = 1); void SetHistLineStyle(Style_t styl = 0); void SetHistLineWidth(Width_t width = 1); ```. When you change the current style and would like to propagate the; change to a previously created histogram you can call; **`TH1`**`::UseCurrentStyle()`. You will need to call; `UseCurrentStyle()` on each histogram. When reading many histograms; from a file and you wish to update them to the current style, you can; use ***`gROOT`***`::ForceStyle` and all histograms read after this; call will be updated to use the current style. See ""Graphics and the; Graphical User Interface"". When a histogram is automatically created; as a result of a **`TTree`**`::Draw` , the style of the histogram is; inherited from the tree attributes and the current style is ignored.; The tree attributes are the ones set in the current **`TStyle`** at; the time the tree was created. You can change the existing tree to use; the current style, by calling **`TTree`**`::UseCurrentStyle()` . ### Draw Options. The following draw options are supported on all histogram classes:. - ""`AXIS`"": Draw only the axis. - ""`HIST`"": When a histogram has errors, it is visualized by default; with error bars. To visualize it without errors use `HIST`; together with the required option (e.g. ""`HIST SAME C`""). - ""`SAME`"": Superimpose on previous picture in the same pad. - ""`CYL`"": Use cylindrical coordinates. - ""`POL`"": Use polar coordinates. - ""`SPH`"": Use spherical coordinates. - ""`PSR`"": Use pseudo-rapidity/phi coordinates. - ""`LEGO`"": Draw a lego plot with hidden line removal. - ""`LEGO1`"": Draw a lego plot with hidden surface removal. - ""`LEGO2`"": Draw a lego plot using colors to show the cell;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:16391,inherit,inherited,16391,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['inherit'],['inherited']
Modifiability," */; }. The code of the ``isa<>`` test in this code will eventually boil; down---after template instantiation and some other machinery---to a; check roughly like ``Circle::classof(S)``. For more information, see; :ref:`classof-contract`. The argument to ``classof`` should always be an *ancestor* class because; the implementation has logic to allow and optimize away; upcasts/up-``isa<>``'s automatically. It is as though every class; ``Foo`` automatically has a ``classof`` like:. .. code-block:: c++. class Foo {; [...]; template <class T>; static bool classof(const T *,; ::std::enable_if<; ::std::is_base_of<Foo, T>::value; >::type* = 0) { return true; }; [...]; };. Note that this is the reason that we did not need to introduce a; ``classof`` into ``Shape``: all relevant classes derive from ``Shape``,; and ``Shape`` itself is abstract (has no entry in the ``Kind`` enum),; so this notional inferred ``classof`` is all we need. See `Concrete; Bases and Deeper Hierarchies`_ for more information about how to extend; this example to more general hierarchies. Although for this small example setting up LLVM-style RTTI seems like a lot; of ""boilerplate"", if your classes are doing anything interesting then this; will end up being a tiny fraction of the code. Concrete Bases and Deeper Hierarchies; =====================================. For concrete bases (i.e. non-abstract interior nodes of the inheritance; tree), the ``Kind`` check inside ``classof`` needs to be a bit more; complicated. The situation differs from the example above in that. * Since the class is concrete, it must itself have an entry in the ``Kind``; enum because it is possible to have objects with this class as a dynamic; type. * Since the class has children, the check inside ``classof`` must take them; into account. Say that ``SpecialSquare`` and ``OtherSpecialSquare`` derive; from ``Square``, and so ``ShapeKind`` becomes:. .. code-block:: c++. enum ShapeKind {; SK_Square,; + SK_SpecialSquare,; + SK_OtherSpecial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:6944,extend,extend,6944,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['extend'],['extend']
Modifiability," *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. .. _osx-cocoa-RetainCount:. osx.cocoa.RetainCount (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaks and improper reference count management. .. code-block:: objc. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .. _osx-cocoa-RunLoopAutoreleaseLeak:. osx.cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:40754,variab,variable,40754,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variable']
Modifiability," - Flexible pattern matching file verifier; ===================================================. .. program:: FileCheck. SYNOPSIS; --------. :program:`FileCheck` *match-filename* [*--check-prefix=XXX*] [*--strict-whitespace*]. DESCRIPTION; -----------. :program:`FileCheck` reads two files (one from standard input, and one; specified on the command line) and uses one to verify the other. This; behavior is particularly useful for the testsuite, which wants to verify that; the output of some tool (e.g. :program:`llc`) contains the expected information; (for example, a movsd from esp or whatever is interesting). This is similar to; using :program:`grep`, but it is optimized for matching multiple different; inputs in one file in a specific order. The ``match-filename`` file specifies the file that contains the patterns to; match. The file to verify is read from standard input unless the; :option:`--input-file` option is used. OPTIONS; -------. Options are parsed from the environment variable ``FILECHECK_OPTS``; and from the command line. .. option:: -help. Print a summary of command line options. .. option:: --check-prefix prefix. FileCheck searches the contents of ``match-filename`` for patterns to; match. By default, these patterns are prefixed with ""``CHECK:``"".; If you'd like to use a different prefix (e.g. because the same input; file is checking multiple different tool or options), the; :option:`--check-prefix` argument allows you to specify (without the trailing; ""``:``"") one or more prefixes to match. Multiple prefixes are useful for tests; which might change for different run options, but most lines remain the same. FileCheck does not permit duplicate prefixes, even if one is a check prefix; and one is a comment prefix (see :option:`--comment-prefixes` below). .. option:: --check-prefixes prefix1,prefix2,... An alias of :option:`--check-prefix` that allows multiple prefixes to be; specified as a comma separated list. .. option:: --comment-prefixes prefix1,prefix",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:1002,variab,variable,1002,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability," - MaxPool, AveragePool, GlobalAverage; - ConvTranspose; - Gather; - Expand, Reduce; - Neg, Exp, Sqrt, Reciprocal; - Add, Sum, Mul, Div; - Reshape, Flatten, Transpose; - Squeeze, Unsqueeze, Slice; - Concat, Reduce; - Identity; - Shape. In addition a Custom (user defined) operator is supported. An example of using a Custom operator is the program `tmva/pymva/test/EmitCustomModel.cxx`. The ONNX parser supports also the fusing of the operators MatMul + Add in a Gemm operator and fusing Conv + Add and ConvTranspose + Add. #### SOFIE Keras Parser. The Keras parser supports now model with input batch size not defined (e.g `bathsize=-1`), and by default the model is generated with `batchsize=1`.; The Keras parser supports now in addition to the Dense layer the Conv2D layer, several activation functions (Relu, Selu, Sigmoid, Softmax, Tanh, LeakyRelu) and these other layers: BatchNormalization, Reshape, Convatenate, Add, Subtract, Multiply.; Models with Dropout layers are supported in case the Dropout is used only during training and not inference. For model having operators not yet supported in the Keras parser it is then reccomended to convert the Keras model to `ONNX` using the python `tf2onnx` tool. #### SOFIE PyTorch Parser. If using PyTorch it is recommended to save the model directly in `ONNX` format instad of the native `.pt` format by using the `torch.onnx.export` function of PyTorch. The support for parsing directly `.pt` files is limited to the Gemm, Conv, Relu, Selu, Sigmoid and Transpose operators. #### SOFIE RDataFrame Integration. The SOFIE inference is now integrated with RDataFrame, where a model can be evaluated on the columns of an input `TTree` with `RDataFrame` using the adapter functor class `SofieFunctor`.; Examples of using SOFIE with `RDataFrame` are the new tutorials (in the `tutorials/tmva` directory) `TMVA_SOFIE_RDataFrame.C` or `TMVA_SOFIE_RDataFrame.py`. `TMVA_SOFIE_RDataFrame_JIT.C` is an example where the SOFIE model is generated and compiled ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:28566,layers,layers,28566,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['layers'],['layers']
Modifiability, - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122424,plugin,plugins,122424,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability, - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/tools/multiplex/tests/print; - `2`; - `2`; - `0`; - :,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122764,plugin,plugins,122764,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability," - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Objective-C; instance methods. - ``objc_property``: Can be used to apply attributes to ``@property``; declarations. - ``block``: Can be used to apply attributes to block declarations. This does; not include variables/fields of block pointer type. The use of ``unless`` in match rules is currently restricted to a strict set of; sub-rules that are used by the supported attributes. That means that even though; ``variable(unless(is_parameter))`` is a valid match rule,; ``variable(unless(is_thread_local))`` is not. Supported Attributes; --------------------. Not all attributes can be used with the ``#pragma clang attribute`` directive.; Notably, statement attributes like ``[[fallthrough]]`` or type attributes; like ``address_space`` aren't supported by this directive. You can determine; whether or not an attribute is supported by the pragma by referring to the; :doc:`individual documentation for that attribute <AttributeReference>`. The attributes are applied to all matching declarations individually, even when; the attribute is semantically incorrect. The attributes that aren't applied to; any declaration are not verified semantically. Specifying section names for global objects (#pragma clang section); ===================================================================. The ``#pragma clang section`` directive provides a means to assign section-names; to global variables, functions and static variables. The section names can be ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:185565,variab,variable,185565,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,2,['variab'],['variable']
Modifiability," - handle reordering of fragments in multipart reply #319; 40. Fix - properly show non-zero entries #320; 41. Fix - display empty hist bin if fSumw2 not zero. ## Changes in 7.7.4; 1. Fix - TGraph Y range selection, do not cross 0; 2. Fix - correctly handle `#font[id]` in latex; 3. Fix - store canvas with embed geometry drawing; 4. Fix - upgrade rollup and import.meta polyfill. ## Changes in 7.7.3; 1. Fix - correctly handle in I/O empty std::map; 2. Fix - reading of small (<1KB) ROOT files; 3. Fix - race condition in zstd initialization #318; 4. Fix - deployment with zstd #317. ## Changes in 7.7.2; 1. Fix - hide empty title on the canvas; 2. Fix - properly handle zooming in THStack histogram; 3. Fix - always use 0 as minimum in THStack drawings; 4. Fix - always show all ticks for labeled axis; 5. Fix - draw TProfile2D bins content as text, not entries; 6. Fix - interactive zooming on log color palette; 7. Fix - keyboard handling while input dialog active; 8. Fix - legend entry with not configured fill attributes; 9. Fix - prevent that color palette exceed graphical range; 10. Fix - exponential log axis labels with kMoreLogLabels bit set. ## Changes in 7.7.1; 1. Fix - properly select TF1 range after zooming; 2. Fix - TH1 y-range selection; 3. Fix - add 'gl' and svg2pdf-related packages to dependencies in package.json. ## Changes in 7.7.0; 1. Let plot current time, file creation or modification time with `&optdate=[1,2,3]` URL parameters; 2. Let plot file name, full file name or item name with `&optfile=[1,2,3]` URL parameters; 3. Let define date and file name position with `&datex=0.03&datey=0.03` URL parameters; 4. Improve TRatioPlot axis and lines drawing; 5. Use localStorage to preserve custom settings and gStyle; 6. Let configure custom storage prefix with `&storage_prefix=name` URL #290; 7. Let customize URL for ""Show in new tab"" menu command; 8. Support both new and old TRatioPlot drawings; 10. Synchronize X/Y range selection with native ROOT; 11. Proper handle a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:3677,config,configured,3677,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configured']
Modifiability, - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122516,plugin,plugins,122516,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability," -- Many operator p.d.f. and function components now show; a more intuitive natural representation of their contents (these changes are mostly in the; respective p.d.f.s, but are most relevant in the context of a workspace). New object factory interface to workspace to facilitate script driven model definition; A object factory has been added to RooFit to simplify the process of creating p.d.f.; and function expressions consisting of multiple objects. The factory has two goals:; the first is to provide a back-end for higher level factories and tools to process; the creation of objects. The second is to provide a simple end-user language to; populate a RooWorkspace with function and p.d.f. objects. For the latter purpose the object creation language is executed through the factory() method; of a workspace object. RooWorkspace w(""w"") ;; RooAbsArg* arg = w.factory(""expression_goes_here"") ;. Basic Syntax; The rules at its simplest level are as follows. Expressions with square brackets create variables (discrete and continuous). ""m[-10,10]"" - Creates a RooRealVar named 'm' with range [-10,10]; ""m[5,-10,10]"" - Idem, but with initial value 5; ""m[5]"" - Creates a constant RooRealVar with name 'm' and value 5. ""tagCat[Lep,Kao,NT1,NT2]"" -- Creates a RooCategory with name tagCat and labeled states Lep,Kao,NT1,NT2; ""b0flav[B0=1,B0bar=-1]"" -- Creates a RooCategory with name b0flav and states B0 and B0bar with explicit index assignments. Expressions with parentheses create RooAbsArg function objects of any type. ""RooGaussian::g(x,m,s)"" -- Create a RooGaussian named g with variables x,m,s; This expression maps 1-1 to a createArg() call. ""Gaussian::g(x,m,s)"" -- Idem. The 'Roo' prefix on any class may be omitted. ""Gaussian(x,m,s)"" -- Create a RooGaussian with an automatically assigned name with variables x,m,s. Expressions with curly brackets creates RooArgSets or RooArgLists ""{x,y,z}"". Compound expressions; The real power of this language is that all these expressions may be nested t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:18839,variab,variables,18839,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['variab'],['variables']
Modifiability," ----------------------------------------------------. So far we have seen how the CommandLine library handles builtin types like; ``std::string``, ``bool`` and ``int``, but how does it handle things it doesn't; know about, like enums or '``int*``'s?. The answer is that it uses a table-driven generic parser (unless you specify; your own parser, as described in the `Extension Guide`_). This parser maps; literal strings to whatever type is required, and requires you to tell it what; this mapping should be. Let's say that we would like to add four optimization levels to our optimizer,; using the standard flags ""``-g``"", ""``-O0``"", ""``-O1``"", and ""``-O2``"". We; could easily implement this with boolean options like above, but there are; several problems with this strategy:. #. A user could specify more than one of the options at a time, for example,; ""``compiler -O3 -O2``"". The CommandLine library would not be able to catch; this erroneous input for us. #. We would have to test 4 different variables to see which ones are set. #. This doesn't map to the numeric levels that we want... so we cannot easily; see if some level >= ""``-O1``"" is enabled. To cope with these problems, we can use an enum value, and have the CommandLine; library fill it in with the appropriate level directly, which is used like this:. .. code-block:: c++. enum OptLevel {; g, O1, O2, O3; };. cl::opt<OptLevel> OptimizationLevel(cl::desc(""Choose optimization level:""),; cl::values(; clEnumVal(g , ""No optimizations, enable debugging""),; clEnumVal(O1, ""Enable trivial optimizations""),; clEnumVal(O2, ""Enable default optimizations""),; clEnumVal(O3, ""Enable expensive optimizations"")));. ...; if (OptimizationLevel >= O2) doPartialRedundancyElimination(...);; ... This declaration defines a variable ""``OptimizationLevel``"" of the; ""``OptLevel``"" enum type. This variable can be assigned any of the values that; are listed in the declaration. The CommandLine library enforces that; the user can only specify one of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:14296,variab,variables,14296,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variables']
Modifiability," --Wno-error=<value> - If set don't error out on the specified warning type.; =unknown - If set, unknown format options are only warned about.; This can be used to enable formatting, even if the; configuration contains unknown (newer) options.; Use with caution, as this might lead to dramatically; differing format depending on an option being; supported or not.; --assume-filename=<string> - Set filename used to determine the language and to find; .clang-format file.; Only used when reading from stdin.; If this is not passed, the .clang-format file is searched; relative to the current working directory when reading stdin.; Unrecognized filenames are treated as C++.; supported:; CSharp: .cs; Java: .java; JavaScript: .mjs .js .ts; Json: .json; Objective-C: .m .mm; Proto: .proto .protodevel; TableGen: .td; TextProto: .textpb .pb.txt .textproto .asciipb; Verilog: .sv .svh .v .vh; --cursor=<uint> - The position of the cursor when invoking; clang-format from an editor integration; --dry-run - If set, do not actually make the formatting changes; --dump-config - Dump configuration options to stdout and exit.; Can be used with -style option.; --fallback-style=<string> - The name of the predefined style used as a; fallback in case clang-format is invoked with; -style=file, but can not find the .clang-format; file to use. Defaults to 'LLVM'.; Use -fallback-style=none to skip formatting.; --ferror-limit=<uint> - Set the maximum number of clang-format errors to emit; before stopping (0 = no limit).; Used only with --dry-run or -n; --files=<filename> - A file containing a list of files to process, one per line.; -i - Inplace edit <file>s, if specified.; --length=<uint> - Format a range of this length (in bytes).; Multiple ranges can be formatted by specifying; several -offset and -length pairs.; When only a single -offset is specified without; -length, clang-format will format up to the end; of the file.; Can only be used with one input file.; --lines=<string> - <start line>:<end ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:2065,config,config,2065,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,2,['config'],"['config', 'configuration']"
Modifiability," . TMVA; ; This version corresponds to TMVA version 3.9.5.; ; . New; reference page for configuration options The; page is automatically generated for each new release. Next to; the classifiers also exist information links for hints to; improve the classifier performance (click on the ""i""; button). Many thanks to Zhiyi Liu (Fraser U) for suggesting; this.; ; Methods:. BDT: New Decision Tree Pruning algorithm: Cost; Complexity Pruning a la CART. Written by Doug Schouten; (Fraser U.). It replaces the old CostComplexity and; CostComplexity2 algorithms.; . BDT: New no splitting option (choosable with; NCuts<0) that finds best split point by first sorting the; events for each variable and then looping through all; events, placing the cuts always in the middle between two; of the sorted events, and finding the true possible; maximum separation gain in the training sample by cutting; on this variable.; . BDT, AdaBoost The beta parameter is now an; option (default is 1).; . BDT: The node purity at which a node is; classified as signal (respective background node) for; determining the error fraction in the pruning became a; parameter that can be set via the option NodePurityLimit; (default is 0.5).; . Dataset preparation:. First implementation of a new preprocessing method: transformation of the; variables first into a Gaussian distribution, then performing a decorrelation of; the ""Gaussianised"" variables. The transformation is again done by default such that; (by default) the signal distributions become Gaussian and are decorrelated. Note ; that simultaneous Gaussianisation and decorrelation of signal and background is ; only possible (and done) for methods, such as Likelihood, which test both hypotheses.; . Bug fixes:. Fix in Expected error pruning: Rather than multiplying both sides, the error on ; the node and the sub-tree, with the prune strength, now only the expected error ; of the sub-tree is scaled.; . Fix in FDA parsing of the input formula. There were problems when",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v522/index.html:88,config,configuration,88,tmva/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v522/index.html,3,"['config', 'variab']","['configuration', 'variable']"
Modifiability," .. _BreakAfterJavaFieldAnnotations:. **BreakAfterJavaFieldAnnotations** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <BreakAfterJavaFieldAnnotations>`; Break after each annotation on a field in Java files. .. code-block:: java. true: false:; @Partial vs. @Partial @Mock DataLoad loader;; @Mock; DataLoad loader;. .. _BreakArrays:. **BreakArrays** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <BreakArrays>`; If ``true``, clang-format will always break after a Json array ``[``; otherwise it will scan until the closing ``]`` to determine if it should; add newlines between elements (prettier compatible). .. note::. This is currently only for formatting JSON. .. code-block:: c++. true: false:; [ vs. [1, 2, 3, 4]; 1,; 2,; 3,; 4; ]. .. _BreakBeforeBinaryOperators:. **BreakBeforeBinaryOperators** (``BinaryOperatorStyle``) :versionbadge:`clang-format 3.6` :ref:`¶ <BreakBeforeBinaryOperators>`; The way to wrap binary operators. Possible values:. * ``BOS_None`` (in configuration: ``None``); Break after operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >; ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_NonAssignment`` (in configuration: ``NonAssignment``); Break before operators that aren't assignments. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_All`` (in configuration: ``All``); Break before operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:46230,config,configuration,46230,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," .. _meetups-social-events:. Meetups and social events; -------------------------. .. toctree::; :hidden:. MeetupGuidelines. Besides developer `meetings and conferences <https://llvm.org/devmtg/>`_,; there are several user groups called; `LLVM Socials <https://www.meetup.com/pro/llvm/>`_. We greatly encourage you to; join one in your city. Or start a new one if there is none:. :doc:`MeetupGuidelines`. .. _community-proposals:. Community wide proposals; ------------------------. Proposals for massive changes in how the community behaves and how the work flow; can be better. .. toctree::; :hidden:. Proposals/GitHubMove; BugpointRedesign; Proposals/TestSuite; Proposals/VariableNames; Proposals/VectorPredication. :doc:`Proposals/GitHubMove`; Proposal to move from SVN/Git to GitHub. :doc:`BugpointRedesign`; Design doc for a redesign of the Bugpoint tool. :doc:`Proposals/TestSuite`; Proposals for additional benchmarks/programs for llvm's test-suite. :doc:`Proposals/VariableNames`; Proposal to change the variable names coding standard. :doc:`Proposals/VectorPredication`; Proposal for predicated vector instructions in LLVM. .. _llvm-community-calendar:. LLVM community calendar; -----------------------. We aim to maintain a public calendar view of all events happening in the LLVM; community such as :ref:`online-sync-ups` and :ref:`office-hours`. The calendar; can be found at; https://calendar.google.com/calendar/u/0/embed?src=calendar@llvm.org and can; also be seen inline below:. .. raw:: html. <iframe src=""https://calendar.google.com/calendar/embed?height=600&wkst=1&bgcolor=%23ffffff&ctz=UTC&showCalendars=0&showDate=1&showNav=1&src=Y2FsZW5kYXJAbGx2bS5vcmc&color=%23039BE5"" style=""border:solid 1px #777"" width=""800"" height=""600"" frameborder=""0"" scrolling=""no""></iframe>. .. _llvm-community-calendar-host-guidance:. Guidance on what to put into LLVM community calendar invites; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. To add your event, create a calendar event ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:18770,variab,variable,18770,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['variab'],['variable']
Modifiability," .. _print_:. PRINT; ~~~~~; The following options describe the elements to print. The layout used; is determined by the :option:`--report`. In the tree layout, all the; elements have their enclosing lexical scopes printed, even when not; explicitly specified. .. option:: --print=<value[,value,...]>. With **value** being one of the options in the following lists. .. code-block:: text. =all: Include all the below attributes. The following options print the requested elements; in the case of any; given select conditions (:option:`--select`), only those elements that; match them, will be printed. The **elements** value is a convenient; way to specify instructions, lines, scopes, symbols and types all at; once. .. code-block:: text. =elements: Instructions, lines, scopes, symbols and types.; =instructions: Assembler instructions for code sections.; =lines: Source lines referenced in the debug information.; =scopes: Lexical blocks (function, class, namespace, etc).; =symbols: Symbols (variable, member, parameter, etc).; =types: Types (pointer, reference, type alias, etc). The following options print information, collected during the creation; of the elements, such as: scope contributions to the debug information;; summary of elements created, printed or matched (:option:`--select`);; warnings produced during the view creation. .. code-block:: text. =sizes: Debug Information scopes contributions.; =summary: Summary of elements allocated, selected or printed.; =warnings: Warnings detected. Note: The **--print=sizes** option is ELF specific. .. _output_:. OUTPUT; ~~~~~~; The following options describe how to control the output generated when; printing the logical elements. .. option:: --output-file=<path>. Redirect the output to a file specified by <path>, where - is the; standard output stream. :program:`llvm-debuginfo-analyzer` has the concept of **split view**.; When redirecting the output from a complex binary format, it is; **divided** into individual files, each one con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:10047,variab,variable,10047,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['variab'],['variable']
Modifiability," .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:38757,config,configuration,38757,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," ... `->` ... | `Title` | Title of the object |; +--------------------+-------------------+--------------------------------------+; | ... `->` ... | `DATA` | Data bytes associated to the object |; +--------------------+-------------------+--------------------------------------+. You see a reference to **`TKey`**. It is explained in detail in the next; section. ### The Class Description List (StreamerInfo List). The histogram records are followed by the `StreamerInfo` list of class; descriptions. The list contains the description of each class that has; been written to file. ``` {.cpp}; 20010404/092347 At:5854 N=2390 StreamerInfo CX = 3.41; ```. The class description is recursive, because to fully describe a class,; its ancestors and object data members have to be described also. In; `demo.root`, the class description list contains the description for:. - **`TH1F`**. - all classes in the **`TH1F`** inheritance tree. - all classes of the object data members. - all classes in the object data members' inheritance tree. This description is implemented by the **`TStreamerInfo`** class`,` and; is often referred to as simply `StreamerInfo`. You can print a file's; `StreamerInfo`list with the `TFile::ShowStreamerInfo` method. Below is; an example of the output. Only the first line of each class description; is shown. The `demo.root` example contains only **`TH1F`** objects. Here; we see the recursive nature of the class description; it contains the; `StreamerInfo`of all the classes needed to describe **`TH1F`**. ``` {.cpp}; root[] f.ShowStreamerInfo(); StreamerInfo for class: TH1F, version=1; BASE TH1 offset=0 type= 0 1-Dim histogram base class; BASE TArrayF offset=0 type= 0 Array of floats. StreamerInfo for class: TH1, version=3; BASE TNamed offset=0 type=67 The basis for named object(name,title); BASE TAttLine offset=0 type=0 Line attributes; BASE TAttFill offset=0 type=0 Fill area attributes; BASE TAttMarker offset=0 type=0 Marker attributes; Int_t fNcells offset=0 type=3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:10992,inherit,inheritance,10992,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['inherit'],['inheritance']
Modifiability," ...---.---.---.---.-------...; | P | P | P | P | User; '''---'---'---'---'-------'''. * Layout b) is modelled by pointing at the ``Use[]`` array. .. code-block:: none. .-------...; | User; '-------'''; |; v; .---.---.---.---...; | P | P | P | P |; '---'---'---'---'''. *(In the above figures* '``P``' *stands for the* ``Use**`` *that is stored in; each* ``Use`` *object in the member* ``Use::Prev`` *)*. .. _polymorphism:. Designing Type Hierarchies and Polymorphic Interfaces; -----------------------------------------------------. There are two different design patterns that tend to result in the use of; virtual dispatch for methods in a type hierarchy in C++ programs. The first is; a genuine type hierarchy where different types in the hierarchy model; a specific subset of the functionality and semantics, and these types nest; strictly within each other. Good examples of this can be seen in the ``Value``; or ``Type`` type hierarchies. A second is the desire to dispatch dynamically across a collection of; polymorphic interface implementations. This latter use case can be modeled with; virtual dispatch and inheritance by defining an abstract interface base class; which all implementations derive from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:129469,polymorphi,polymorphic,129469,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['polymorphi'],['polymorphic']
Modifiability," 1 tree->Draw(""fNtrack"");; 2 tree->Draw(""event.GetNtrack()"");; 3 tree->Draw(""GetNtrack()"");; 4 tree->Draw(""fH.fXaxis.fXmax"");; 5 tree->Draw(""fH.fXaxis.GetXmax()"");; 6 tree->Draw(""fH.GetXaxis().fXmax"");; 7 tree->Draw(""GetHistogram().GetXaxis().GetXmax()"");; // Expressions in the selection parameter; 8 tree->Draw(""fTracks.fPx"",""fEvtHdr.fEvtNum%10 == 0"");; 9 tree->Draw(""fPx"",""fEvtHdr.fEvtNum%10 == 0"");; // Two dimensional arrays defined as:; // Float_t fMatrix[4][4] in Event class; 10 tree->Draw(""fMatrix"");; 11 tree->Draw(""fMatrix[ ][ ]"");; 12 tree->Draw(""fMatrix[2][2]"");; 13 tree->Draw(""fMatrix[ ][0]"");; 14 tree->Draw(""fMatrix[1][ ]"");; // using two arrays... Float_t fVertex[3]; in Track class; 15 tree->Draw(""fMatrix - fVertex"");; 16 tree->Draw(""fMatrix[2][1] - fVertex[5][1]"");; 17 tree->Draw(""fMatrix[ ][1] - fVertex[5][1]"");; 18 tree->Draw(""fMatrix[2][ ] - fVertex[5][ ]"");; 19 tree->Draw(""fMatrix[ ][2] - fVertex[ ][1]"");; 20 tree->Draw(""fMatrix[ ][2] - fVertex[ ][ ]"");; 21 tree->Draw(""fMatrix[ ][ ] - fVertex[ ][ ]"");; // variable length arrays; 22 tree->Draw(""fClosestDistance"");; 23 tree->Draw(""fClosestDistance[fNvertex/2]"");; // mathematical expressions; 24 tree->Draw(""sqrt(fPx*fPx + fPy*fPy + fPz*fPz))"");; // external function call; 25 tree->Draw(""TMath::BreitWigner(fPx,3,2)"");; // strings; 26 tree->Draw(""fEvtHdr.fEvtNum"",""fType==""type1"" "");; 27 tree->Draw(""fEvtHdr.fEvtNum"",""strstr(fType,""1"" "");; // Where fPoints is defined in the track class:; // Int_t fNpoint;; // Int_t *fPoints; [fNpoint]; 28 tree->Draw(""fTracks.fPoints"");; 29 tree->Draw(""fTracks.fPoints - fTracks.fPoints[][fAvgPoints]"");; 30 tree->Draw(""fTracks.fPoints[2][]- fTracks.fPoints[][55]"");; 31 tree->Draw(""fTracks.fPoints[][] - fTracks.fVertex[][]"");; // selections; 32 tree->Draw(""fValid&0x1"",""(fNvertex>10) && (fNseg<=6000)"");; 33 tree->Draw(""fPx"",""(fBx>.4) || (fBy<=-.4)"");; 34 tree->Draw(""fPx"",""fBx*fBx*(fBx>.4) + fBy*fBy*(fBy<=-.4)"");; 35 tree->Draw(""fVertex"",""fVertex>10"");; 36 tree->Draw(""fPx[600]"");;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:78241,variab,variable,78241,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability, 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexce,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117005,variab,variable,117005,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability," 2-D and 3-D histograms. #### Projecting a Histogram. If you would like to fill a histogram, but not draw it you can use the; `TTree::Project()` method. ``` {.cpp}; root[] T->Project(""quietHisto"",""fNtrack""); ```. #### Making a Profile Histogram; \index{histogram!profile}. In case of a two dimensional expression, you can generate a; **`TProfile`** histogram instead of a two dimensional histogram by; specifying the `'prof'` or '`profs'` option. The `prof` option is; automatically selected when the output is redirected into a; **`TProfile`**. For example `y:x>>pf` where `pf `is an existing; **`TProfile`** histogram. #### Tree Information. Once we have drawn a tree, we can get information about the tree. These; are the methods used to get information from a drawn tree **`TTree`**:. - `GetSelectedRows`: Returns the number of entries accepted by the; selection expression. In case where no selection was specified, it; returns the number of entries processed. - `GetV1`: Returns a pointer to the float array of the first variable. - `GetV2`: Returns a pointer to the float array of second variable. - `GetV3`: Returns a pointer to the float array of third variable. - `GetW`: Returns a pointer to the float array of Weights where the; weight equals the result of the selection expression. To read the drawn values of `fNtrack` into an array, and loop through; the entries follow the lines below. First, open the file and draw the; `fNtrack` variable:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); ```. Then declare a pointer to a float and use the GetV1 method to retrieve; the first dimension of the tree. In this example we only drew one; dimension (`fNtrack`) if we had drawn two, we could use GetV2 to get the; second one. ``` {.cpp}; root[] Float_t *a; root[] a = T->GetV1(); ```. Loop through the first 10 entries and print the values of `fNtrack`:. ``` {.cpp}; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:118965,variab,variable,118965,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability," 2`, one top level branch is created for each array; element. If one of the array elements is a **`TCollection`**, one; top level branch will be created for each element of this; collection. In case a collection element is a **`TClonesArray`**, the special Tree; constructor for **`TClonesArray`** is called. The collection itself; cannot be a **`TClonesArray`**. If `name` is given, all branch names; will be prefixed with `name_`. *IMPORTANT NOTE1:* This function should not be called if `splitlevel<1`.; *IMPORTANT NOTE2:* The branches created by this function will have names; corresponding to the collection or object names. It is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the fu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33266,variab,variables,33266,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability," 3. The `RooAbsRootFinder`, which was the base class of `RooBrentRootFinder`.; The `RooAbsRootFinder` was only used as the base class of; `RooBrentRootFinder`, which is an implementation detail of several; RooFit/RooStats functions. However, polymorphism never not relevant for root; finding, so the `RooAbsRootFinder` is removed. In the rare case where you; might have used it, please ROOT's other functionalities: RooFit is not for; root finding.; 4. The `RooFormula` class, which was not meant as a user-facing class, but as a; shared implementation detail of `RooFormulaVar` and `RooGenericPdf`.; 5. The `RooIntegratorBinding`, which was an implementation detail of the; `RooIntegrator2D` and `RooSegmentedIntegrator2D` classes.; 6. The `RooRealAnalytic`, which was an implementation detail of the; `RooRealIntegral` class. ### Consistent default for `Extended()` command in RooAbsPdf::fitTo() and RooAbsPdf::chi2FitTo(). If no `RooFit::Extended()` command argument is passed, `RooAbsPdf::chi2FitTo()`; method now does an extended fit by default if the pdf is extendible. This makes; the behavior consistent with `RooAbsPdf::fitTo()`. Same applies to; `RooAbsPdf::createChi2()`. ## TMVA; ### SOFIE : Code generation for fast inference of Deep Learning models; TMVA SOFIE now supports parsing and further inference of Graph Neural Networks based on DeepMind's [graph_nets](https://github.com/google-deepmind/graph_nets). The list of all operators supported in the `RModel` class is the one provided below for the ONNX parser. #### SOFIE-GNN; 1. The SOFIE-GNN implementation brought a major change in SOFIE's architecture. Instead of having only the RModel class to store model information, now SOFIE has RModel, RModel_GNN and RModel_GraphIndependent classes which are inherited from RModel_Base.; 2. **RModel_GNN** is used to store a GNN model having nodes, edges, and globals with functions for their update and aggregate(for inter-relationships).; 3. **RModel_GraphIndependent** is used to stor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:16583,extend,extended,16583,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,2,['extend'],"['extended', 'extendible']"
Modifiability," 30 Black foreground; 31 Red foreground; 32 Green foreground; 33 Yellow foreground; 34 Blue foreground; 35 Magenta foreground; 36 Cyan foreground; 37 White foreground; ==== ============================ ===============================================. Common markup element syntax; ============================. All the markup elements share a common syntactic structure to facilitate simple; matching and parsing code. Each element has the form::. {{{tag:fields}}}. ``tag`` identifies one of the element types described below, and is always a; short alphabetic string that must be in lower case. The rest of the element; consists of one or more fields. Fields are separated by ``:`` and cannot contain; any ``:`` or ``}`` characters. How many fields must be or may be present and; what they contain is specified for each element type. No markup elements or ANSI SGR control sequences are interpreted inside the; contents of a field. Implementations must ignore markup fields after those expected; this allows; adding new fields to backwards-compatibly extend elements. Implementations need; not ignore them silently, but the element should behave otherwise as if the; fields were removed. In the descriptions of each element type, ``printf``-style placeholders indicate; field contents:. ``%s``; A string of printable characters, not including ``:`` or ``}``. ``%p``; An address value represented by ``0x`` followed by an even number of; hexadecimal digits (using either lower-case or upper-case for ``A``–``F``).; If the digits are all ``0`` then the ``0x`` prefix may be omitted. No more; than 16 hexadecimal digits are expected to appear in a single value (64 bits). ``%u``; A nonnegative decimal integer. ``%i``; A nonnegative integer. The digits are hexadecimal if prefixed by ``0x``, octal; if prefixed by ``0``, or decimal otherwise. ``%x``; A sequence of an even number of hexadecimal digits (using either lower-case or; upper-case for ``A``–``F``), with no ``0x`` prefix. This represents an;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:7409,extend,extend,7409,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['extend'],['extend']
Modifiability," 4096(inclusive). .. code-block:: c++. void Array(int *array, size_t n) {; [[clang::code_align(64)]] for (int i = 0; i < n; ++i) array[i] = 0;; }. template<int A>; void func() {; [[clang::code_align(A)]] for(;;) { }; }. - Clang now introduced ``[[clang::coro_lifetimebound]]`` attribute.; All parameters of a function are considered to be lifetime bound if the function; returns a type annotated with ``[[clang::coro_lifetimebound]]`` and ``[[clang::coro_return_type]]``.; This analysis can be disabled for a function by annotating the function with ``[[clang::coro_disable_lifetimebound]]``. Improvements to Clang's diagnostics; -----------------------------------; - Clang constexpr evaluator now prints template arguments when displaying; template-specialization function calls.; - Clang contexpr evaluator now displays notes as well as an error when a constructor; of a base class is not called in the constructor of its derived class.; - Clang no longer emits ``-Wmissing-variable-declarations`` for variables declared; with the ``register`` storage class.; - Clang's ``-Wswitch-default`` flag now diagnoses whenever a ``switch`` statement; does not have a ``default`` label.; - Clang's ``-Wtautological-negation-compare`` flag now diagnoses logical; tautologies like ``x && !x`` and ``!x || x`` in expressions. This also; makes ``-Winfinite-recursion`` diagnose more cases.; (`#56035 <https://github.com/llvm/llvm-project/issues/56035>`_).; - Clang constexpr evaluator now diagnoses compound assignment operators against; uninitialized variables as a read of uninitialized object.; (`#51536 <https://github.com/llvm/llvm-project/issues/51536>`_); - Clang's ``-Wformat-truncation`` now diagnoses ``snprintf`` call that is known to; result in string truncation.; (`#64871 <https://github.com/llvm/llvm-project/issues/64871>`_).; Existing warnings that similarly warn about the overflow in ``sprintf``; now falls under its own warning group ```-Wformat-overflow`` so that it can; be disabled separ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:23117,variab,variable-declarations,23117,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,2,['variab'],"['variable-declarations', 'variables']"
Modifiability," 42} # dict filled with str; >>> d[cppyy.gbl.gs] # drop-in use of std::string -> str; 42; >>>. To handle codecs other than UTF-8, the ``std::string`` pythonization adds a; ``decode`` method, with the same signature as the equivalent method of; ``bytes``.; If it is known that a specific C++ function always returns an ``std::string``; representing unicode with a codec other than UTF-8, it can in turn be; explicitly pythonized to do the conversion with that codec. `std::string_view`; """""""""""""""""""""""""""""""""""". It is possible to construct a (char-based) ``std::string_view`` from a Python; ``str``, but it requires the unicode object to be encoded and by default,; UTF-8 is chosen.; This will give the expected result if all characters in the ``str`` are from; the ASCII set, but otherwise it is recommend to encode on the Python side and; pass the resulting ``bytes`` object instead. `std::wstring`; """""""""""""""""""""""""""". C++'s ""wide"" string, ``std::wstring``, is based on ``wchar_t``, a character; type that is not particularly portable as it can be 2 or 4 bytes in size,; depending on the platform.; cppyy supports ``std::wstring`` directly, using the ``wchar_t`` array; conversions provided by Python's C-API. `const char*`; """""""""""""""""""""""""". The C representation of text, ``const char*``, is problematic for two; reasons: it does not express ownership; and its length is implicit, namely up; to the first occurrence of ``'\0'``.; The first can, up to an extent, be ameliorated: there are a range of cases; where ownership can be inferred.; In particular, if the C string is set from a Python ``str``, it is the latter; that owns the memory and the bound proxy of the former that in turn owns the; (unconverted) ``str`` instance.; However, if the ``const char*``'s memory is allocated in C/C++, memory; management is by necessity fully manual.; Length, on the other hand, can only be known in the case of a fixed array.; However even then, the more common case is to use the fixed array as a; buffer, with the a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/strings.rst:2908,portab,portable,2908,bindings/pyroot/cppyy/cppyy/doc/source/strings.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/strings.rst,1,['portab'],['portable']
Modifiability," 7.0, new ORC development work has focused on adding support for; concurrent JIT compilation. The new APIs (including new layer interfaces and; implementations, and new utilities) that support concurrency are collectively; referred to as ORCv2, and the original, non-concurrent layers and utilities; are now referred to as ORCv1. The majority of the ORCv1 layers and utilities were renamed with a 'Legacy'; prefix in LLVM 8.0, and have deprecation warnings attached in LLVM 9.0. In LLVM; 12.0 ORCv1 will be removed entirely. Transitioning from ORCv1 to ORCv2 should be easy for most clients. Most of the; ORCv1 layers and utilities have ORCv2 counterparts [2]_ that can be directly; substituted. However there are some design differences between ORCv1 and ORCv2; to be aware of:. 1. ORCv2 fully adopts the JIT-as-linker model that began with MCJIT. Modules; (and other program representations, e.g. Object Files) are no longer added; directly to JIT classes or layers. Instead, they are added to ``JITDylib``; instances *by* layers. The ``JITDylib`` determines *where* the definitions; reside, the layers determine *how* the definitions will be compiled.; Linkage relationships between ``JITDylibs`` determine how inter-module; references are resolved, and symbol resolvers are no longer used. See the; section `Design Overview`_ for more details. Unless multiple JITDylibs are needed to model linkage relationships, ORCv1; clients should place all code in a single JITDylib.; MCJIT clients should use LLJIT (see `LLJIT and LLLazyJIT`_), and can place; code in LLJIT's default created main JITDylib (See; ``LLJIT::getMainJITDylib()``). 2. All JIT stacks now need an ``ExecutionSession`` instance. ExecutionSession; manages the string pool, error reporting, synchronization, and symbol; lookup. 3. ORCv2 uses uniqued strings (``SymbolStringPtr`` instances) rather than; string values in order to reduce memory overhead and improve lookup; performance. See the subsection `How to manage symbol strings`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:20199,layers,layers,20199,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['layers'],['layers']
Modifiability," 70(!) tutorial macros is now available in $ROOTSYS/tutorials/roofit; These macros are divided in several subjects and are all referenced as iluustrations of concepts explained in the forthcoming edition on RooFit Users Manual.; All macros are extensively documented and each is fully functional standalone. The accompanying update; of the Manual is expected mid-September. ; ; BASIC FUNCTIONALITY. rf101_basics.C - Fitting, plotting, toy data generation on one-dimensional p.d.f ; rf102_dataimport.C - Importing data from ROOT TTrees and THx histograms; rf103_interprfuncs.C - Interpreted functions and p.d.f.s; rf104_classfactory.C - The class factory for functions and p.d.f.s; rf105_funcbinding.C - Demonstration of binding ROOT Math functions as RooFit functions and pdfs; rf106_plotdecoration.C - Adding boxes with parameters, statistics to RooPlots.; rf107_plotstyles.C - Demonstration of various plotting styles of data, functions; rf108_plotbinning.C - Plotting unbinned data with alternate and variable binnings; rf109_chi2residpull.C - Calculating chi^2 from histograms and curves in RooPlots,; rf110_normintegration.C - Examples on normalization & integration of p.d.f.s, construction of cumulative distribution functions.; rf111_numintconfig.C - Configuration and customization of how numeric (partial) integrals. ; ADDITION AND CONVOLUTION. rf201_composite.C - Composite p.d.f with signal and background component; rf202_extendedmlfit.C - Setting up an extended maximum likelihood fit; rf203_ranges.C - Fitting and plotting in sub ranges; rf204_extrangefit.C - Extended maximum likelihood fit with alternate range definition; rf205_compplot.C - Options for plotting components of composite p.d.f.s.; rf206_treevistools.C - Tools for visualization of RooAbsArg expression trees; rf207_comptools.C - Tools and utilities for manipulation of composite objects; rf208_convolution.C - One-dimensional numeric convolution; rf209_anaconv.C - Decay function p.d.fs with optional B physics. ; MULT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:1068,variab,variable,1068,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['variab'],['variable']
Modifiability, :part:`66%`; * - clang-tools-extra/clang-tidy/google; - `33`; - `22`; - `11`; - :part:`66%`; * - clang-tools-extra/clang-tidy/hicpp; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clang-tidy/linuxkernel; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/llvm; - `11`; - `10`; - `1`; - :part:`90%`; * - clang-tools-extra/clang-tidy/llvmlibc; - `7`; - `7`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/misc; - `33`; - `30`; - `3`; - :part:`90%`; * - clang-tools-extra/clang-tidy/modernize; - `67`; - `48`; - `19`; - :part:`71%`; * - clang-tools-extra/clang-tidy/mpi; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/objc; - `17`; - `12`; - `5`; - :part:`70%`; * - clang-tools-extra/clang-tidy/openmp; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/performance; - `31`; - `24`; - `7`; - :part:`77%`; * - clang-tools-extra/clang-tidy/plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/portability; - `5`; - `3`; - `2`; - :part:`60%`; * - clang-tools-extra/clang-tidy/readability; - `88`; - `76`; - `12`; - :part:`86%`; * - clang-tools-extra/clang-tidy/tool; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/utils; - `35`; - `31`; - `4`; - :part:`88%`; * - clang-tools-extra/clang-tidy/zircon; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd; - `97`; - `81`; - `16`; - :part:`83%`; * - clang-tools-extra/clangd/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/benchmarks/CompletionModel; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clangd/fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index; - `39`; - `36`; - `3`; - :part:`92%`; * - clang-tools-extra/clangd/index/dex; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clangd/index/dex/dexp; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:18316,portab,portability,18316,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['portab'],['portability']
Modifiability," :token:`ParentClassList` in the :token:`RecordBody` is present, or; * The :token:`Body` in the :token:`RecordBody` is present and not empty. You can declare an empty class by specifying an empty :token:`TemplateArgList`; and an empty :token:`RecordBody`. This can serve as a restricted form of; forward declaration. Note that records derived from a forward-declared; class will inherit no fields from it, because those records are built when; their declarations are parsed, and thus before the class is finally defined. .. _NAME:. Every class has an implicit template argument named ``NAME`` (uppercase),; which is bound to the name of the :token:`Def` or :token:`Defm` inheriting; from the class. If the class is inherited by an anonymous record, the name; is unspecified but globally unique. See `Examples: classes and records`_ for examples. Record Bodies; `````````````. Record bodies appear in both class and record definitions. A record body can; include a parent class list, which specifies the classes from which the; current class or record inherits fields. Such classes are called the; parent classes of the class or record. The record body also; includes the main body of the definition, which contains the specification; of the fields of the class or record. .. productionlist::; RecordBody: `ParentClassList` `Body`; ParentClassList: ["":"" `ParentClassListNE`]; ParentClassListNE: `ClassRef` ("","" `ClassRef`)*; ClassRef: (`ClassID` | `MultiClassID`) [""<"" [`ArgValueList`] "">""]; ArgValueList: `PostionalArgValueList` ["",""] `NamedArgValueList`; PostionalArgValueList: [`Value` {"","" `Value`}*]; NamedArgValueList: [`NameValue` ""="" `Value` {"","" `NameValue` ""="" `Value`}*]. A :token:`ParentClassList` containing a :token:`MultiClassID` is valid only; in the class list of a ``defm`` statement. In that case, the ID must be the; name of a multiclass. The argument values can be specified in two forms:. * Positional argument (``value``). The value is assigned to the argument in the; correspond",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:24336,inherit,inherits,24336,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherits']
Modifiability," :versionbadge:`clang-format 3.3` :ref:`¶ <AllowAllParametersOfDeclarationOnNextLine>`; If the function declaration doesn't fit on a line,; allow putting all parameters of a function declaration onto; the next line even if ``BinPackParameters`` is ``false``. .. code-block:: c++. true:; void myFunction(; int a, int b, int c, int d, int e);. false:; void myFunction(int a,; int b,; int c,; int d,; int e);. .. _AllowBreakBeforeNoexceptSpecifier:. **AllowBreakBeforeNoexceptSpecifier** (``BreakBeforeNoexceptSpecifierStyle``) :versionbadge:`clang-format 18` :ref:`¶ <AllowBreakBeforeNoexceptSpecifier>`; Controls if there could be a line break before a ``noexcept`` specifier. Possible values:. * ``BBNSS_Never`` (in configuration: ``Never``); No line break allowed. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2) noexcept(; noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_OnlyWithParen`` (in configuration: ``OnlyWithParen``); For a simple ``noexcept`` there is no line break allowed, but when we; have a condition it is. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:26114,config,configuration,26114,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132291,config,configuration,132291,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," ; IMPORTANT NOTE: while new THnSparse objects can be read and e.g. projected from in old ROOT versions, filling a new THnSparse object in old ROOT versions does NOT WORK!. Add SetBinContent(), AddBinContent(), SetBinError() taking the; linear bin index. Use it in Projection() for a considerable; speed-up. TSpectrum2Painter. New parameter bf() in the SPEC option to define the buffer size; used by TSpectrum2Painter. It is needed in case of very; large canvases like 8000x5000. New TEfficiency class. This new class from Christian Gumpert (CERN summer student 2010) handles the calculation of efficiencies and their uncertainties. It; provides several statistical methods for calculating frequentist and bayesian; confidence intervals as well as a function for combining several efficiencies.; Example of usage: Creating a TEfficiency object; ; If you start a new analysis, it is highly recommended to use the TEfficiency class; from the beginning. You can then use one of the constructors for fixed or; variable bin size and your desired dimension. These constructors append the; created TEfficiency object to the current directory. So it will be written; automatically to a file during the next TFile::Write; command.; Example 1: create a twodimensional TEfficiency object with 10; bins along X and 20 bins along Y:; ; TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;y;#epsilon"",10,0,10,20,-5,5);. You can fill the TEfficiency object by calling the Fill(Bool_t bPassed,Double_t x,Double_t y,Double_t z) method.; The boolean flag ""bPassed"" indicates whether the current event is a good; (both histograms are filled) or not (only fTotalHistogram is filled).; The variables x,y and z determine the bin which is filled. For lower; dimensions the z- or even the y-value may be omitted.; ; You can also set the number of passed or total events for a bin directly by using the SetPassedEvents or SetTotalEvents method.; If you already have two histograms filled with the number of passed and t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:8628,variab,variable,8628,hist/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html,1,['variab'],['variable']
Modifiability," <bits<3> val> {; bits<3> Value = val;; }. def NotFP : FPFormat<0>;; def ZeroArgFP : FPFormat<1>;; def OneArgFP : FPFormat<2>;; def OneArgFPRW : FPFormat<3>;; def TwoArgFP : FPFormat<4>;; def CompareFP : FPFormat<5>;; def CondMovFP : FPFormat<6>;; def SpecialFP : FPFormat<7>;. The purpose of the ``FPFormat`` class is to act as a sort of enumerated; type. It provides a single field, ``Value``, which holds a 3-bit number. Its; template argument, ``val``, is used to set the ``Value`` field. Each of the; eight records is defined with ``FPFormat`` as its parent class. The; enumeration value is passed in angle brackets as the template argument. Each; record will inherent the ``Value`` field with the appropriate enumeration; value. Here is a more complex example of classes with template arguments. First, we; define a class similar to the ``FPFormat`` class above. It takes a template; argument and uses it to initialize a field named ``Value``. Then we define; four records that inherit the ``Value`` field with its four different; integer values. .. code-block:: text. class ModRefVal <bits<2> val> {; bits<2> Value = val;; }. def None : ModRefVal<0>;; def Mod : ModRefVal<1>;; def Ref : ModRefVal<2>;; def ModRef : ModRefVal<3>;. This is somewhat contrived, but let's say we would like to examine the two; bits of the ``Value`` field independently. We can define a class that; accepts a ``ModRefVal`` record as a template argument and splits up its; value into two fields, one bit each. Then we can define records that inherit from; ``ModRefBits`` and so acquire two fields from it, one for each bit in the; ``ModRefVal`` record passed as the template argument. .. code-block:: text. class ModRefBits <ModRefVal mrv> {; // Break the value up into its bits, which can provide a nice; // interface to the ModRefVal values.; bit isMod = mrv.Value{0};; bit isRef = mrv.Value{1};; }. // Example uses.; def foo : ModRefBits<Mod>;; def bar : ModRefBits<Ref>;; def snork : ModRefBits<ModRef>;. This ill",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:31251,inherit,inherit,31251,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherit']
Modifiability," <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.timestamp``' intrinsic is used to implement temporal; profiling. Arguments:; """"""""""""""""""""; The arguments are the same as '``llvm.instrprof.increment``'. The ``index`` is; expected to always be zero. Semantics:; """"""""""""""""""""; Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores a; timestamp representing when this function was executed for the first time. '``llvm.instrprof.cover``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.cover(ptr <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.cover``' intrinsic is used to implement coverage; instrumentation. Arguments:; """"""""""""""""""""; The arguments are the same as the first four arguments of; '``llvm.instrprof.increment``'. Semantics:; """"""""""""""""""""; Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores zero to; the profiling variable to signify that the function has been covered. We store; zero because this is more efficient on some targets. '``llvm.instrprof.value.profile``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.value.profile(ptr <name>, i64 <hash>,; i64 <value>, i32 <value_kind>,; i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.value.profile``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. This will be; lowered by the ``-instrprof`` pass to find out the target values,; instrumented expressions take in a program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. ``name`` should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. It; is an erro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:530132,variab,variable,530132,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," <value>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.fptrunc``' intrinsic truncates ``value``; to type ``ty2``. Arguments:; """""""""""""""""""". The first argument to the '``llvm.experimental.constrained.fptrunc``'; intrinsic must be :ref:`floating point <t_floating>` or :ref:`vector; <t_vector>` of floating point values. This argument must be larger in size; than the result. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". The result produced is a floating point value truncated to be smaller in size; than the operand. '``llvm.experimental.constrained.fpext``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <ty2>; @llvm.experimental.constrained.fpext(<type> <value>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.fpext``' intrinsic extends a; floating-point ``value`` to a larger floating-point value. Arguments:; """""""""""""""""""". The first argument to the '``llvm.experimental.constrained.fpext``'; intrinsic must be :ref:`floating point <t_floating>` or :ref:`vector; <t_vector>` of floating point values. This argument must be smaller in size; than the result. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". The result produced is a floating point value extended to be larger in size; than the operand. All restrictions that apply to the fpext instruction also; apply to this intrinsic. '``llvm.experimental.constrained.fcmp``' and '``llvm.experimental.constrained.fcmps``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <ty2>; @llvm.experimental.constrained.fcmp(<type> <op1>, <type> <op2>,; metadata <condition code>,; metadata <exception behavior>); declare <ty2>; @llvm.experimental.constrained.fcmps(<type> <op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:882356,extend,extends,882356,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extends']
Modifiability," <workflow-checkout-commit>`.; * :ref:`Checkout/Clone Multiple Projects, with Commit Access <workflow-monocheckout-multicommit>`.; * :ref:`Commit an API Change in LLVM and Update the Sub-projects <workflow-cross-repo-commit>`.; * :ref:`Branching/Stashing/Updating for Local Development or Experiments <workflow-mono-branching>`.; * :ref:`Bisecting <workflow-mono-bisecting>`. Workflow Before/After; =====================. This section goes through a few examples of workflows, intended to illustrate; how end-users or developers would interact with the repository for; various use-cases. .. _workflow-checkout-commit:. Checkout/Clone a Single Project, with Commit Access; ---------------------------------------------------. Currently; ^^^^^^^^^. ::. # direct SVN checkout; svn co https://user@llvm.org/svn/llvm-project/llvm/trunk llvm; # or using the read-only Git view, with git-svn; git clone https://llvm.org/git/llvm.git; cd llvm; git svn init https://llvm.org/svn/llvm-project/llvm/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l # -l avoids fetching ahead of the git mirror. Commits are performed using `svn commit` or with the sequence `git commit` and; `git svn dcommit`. .. _workflow-multicheckout-nocommit:. Monorepo Variant; ^^^^^^^^^^^^^^^^. With the monorepo variant, there are a few options, depending on your; constraints. First, you could just clone the full repository:. git clone https://github.com/llvm/llvm-project.git. At this point you have every sub-project (llvm, clang, lld, lldb, ...), which; :ref:`doesn't imply you have to build all of them <build_single_project>`. You; can still build only compiler-rt for instance. In this way it's not different; from someone who would check out all the projects with SVN today. If you want to avoid checking out all the sources, you can hide the other; directories using a Git sparse checkout::. git config core.sparseCheckout true; echo /compiler-rt > .git/info/sparse-checko",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:13173,config,config,13173,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['config'],['config']
Modifiability," = 1; i < n; i++) {; b[i] = c[i] + b[i-1];; }. This code contains a statement that has a loop carried dependence on; itself creating a cycle in the DDG. The figure below illustrates; how the cycle of dependency is carried through multiple def-use relations; and a memory access dependency. .. image:: cycle.png. The DDG corresponding to this example would have a pi-block that contains; all the nodes participating in the cycle, as shown below:. .. image:: cycle_pi.png. Program Dependence Graph; ========================. The Program Dependence Graph (or PDG) has a similar structure as the; DDG, but it is capable of representing both data dependencies and; control-flow dependencies between program elements such as; instructions, groups of instructions, basic blocks or groups of; basic blocks. High-Level Design; =================. The DDG and the PDG are both directed graphs and they extend the; ``DirectedGraph`` class. Each implementation extends its corresponding; node and edge types resulting in the inheritance relationship depicted; in the UML diagram below:. .. image:: uml_nodes_and_edges.png. Graph Construction; ------------------. The graph build algorithm considers dependencies between elements of; a given set of instructions or basic blocks. Any dependencies coming; into or going out of instructions that do not belong to that range; are ignored. The steps in the build algorithm for the DDG are very; similar to the steps in the build algorithm for the PDG. As such,; one of the design goals is to reuse the build algorithm code to; allow creation of both DDG and PDG representations while allowing; the two implementations to define their own distinct and independent; node and edge types. This is achieved by using the well-known builder; design pattern to isolate the construction of the dependence graph; from its concrete representation. The following UML diagram depicts the overall structure of the design; pattern as it applies to the dependence graph implementation.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:2555,extend,extends,2555,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,2,"['extend', 'inherit']","['extends', 'inheritance']"
Modifiability," = getValue())) {; ...; }. Write Portable Code; ^^^^^^^^^^^^^^^^^^^. In almost all cases, it is possible to write completely portable code. When; you need to rely on non-portable code, put it behind a well-defined and; well-documented interface. Do not use RTTI or Exceptions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In an effort to reduce code and executable size, LLVM does not use exceptions; or RTTI (`runtime type information; <https://en.wikipedia.org/wiki/Run-time_type_information>`_, for example,; ``dynamic_cast<>``). That said, LLVM does make extensive use of a hand-rolled form of RTTI that use; templates like :ref:`isa\<>, cast\<>, and dyn_cast\<> <isa>`.; This form of RTTI is opt-in and can be; :doc:`added to any class <HowToSetUpLLVMStyleRTTI>`. Prefer C++-style casts; ^^^^^^^^^^^^^^^^^^^^^^. When casting, use ``static_cast``, ``reinterpret_cast``, and ``const_cast``,; rather than C-style casts. There are two exceptions to this:. * When casting to ``void`` to suppress warnings about unused variables (as an; alternative to ``[[maybe_unused]]``). Prefer C-style casts in this instance. * When casting between integral types (including enums that are not strongly-; typed), functional-style casts are permitted as an alternative to; ``static_cast``. .. _static constructor:. Do not use Static Constructors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Static constructors and destructors (e.g., global variables whose types have a; constructor or destructor) should not be added to the code base, and should be; removed wherever possible. Globals in different source files are initialized in `arbitrary order; <https://yosefk.com/c++fqa/ctors.html#fqa-10.12>`_, making the code more; difficult to reason about. Static constructors have negative impact on launch time of programs that use; LLVM as a library. We would really like for there to be zero cost for linking; in an additional LLVM target or other library into an application, but static; constructors undermine this goal. Use of ``class`` and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:22949,variab,variables,22949,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['variab'],['variables']
Modifiability," = phi(X1, X2);; }; } else {; for (...) {; if (false); X1' = ...; else; X2' = ...; X3' = phi(X1', X2');; }; }; X4 = phi(X3, X3'). Now, all uses of X4 will get the updated value (in general,; if a loop is in LCSSA form, in any loop transformation,; we only need to update the loop closing PHI nodes for the changes; to take effect). If we did not have Loop Closed SSA form, it means that X3 could; possibly be used outside the loop. So, we would have to introduce the; X4 (which is the new X3) and replace all uses of X3 with that.; However, we should note that because LLVM keeps a def-use chain; [#def-use-chain]_ for each Value, we wouldn't need; to perform data-flow analysis to find and replace all the uses; (there is even a utility function, replaceAllUsesWith(),; that performs this transformation by iterating the def-use chain). Another important advantage is that the behavior of all uses; of an induction variable is the same. Without this, you need to; distinguish the case when the variable is used outside of; the loop it is defined in, for example:. .. code-block:: C. for (i = 0; i < 100; i++) {; for (j = 0; j < 100; j++) {; k = i + j;; use(k); // use 1; }; use(k); // use 2; }. Looking from the outer loop with the normal SSA form, the first use of k; is not well-behaved, while the second one is an induction variable with; base 100 and step 1. Although, in practice, and in the LLVM context,; such cases can be handled effectively by SCEV. Scalar Evolution; (:ref:`scalar-evolution <passes-scalar-evolution>`) or SCEV, is a; (analysis) pass that analyzes and categorizes the evolution of scalar; expressions in loops. In general, it's easier to use SCEV in loops that are in LCSSA form.; The evolution of a scalar (loop-variant) expression that; SCEV can analyze is, by definition, relative to a loop.; An expression is represented in LLVM by an; `llvm::Instruction <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_.; If the expression is inside two (or more) loops (which",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:14701,variab,variable,14701,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['variab'],['variable']
Modifiability," => ""root"",; ""require"" => ""valid-user""; ) ). ## Integration with existing applications. In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a [THttpServer::Register()](https://root.cern/doc/master/classTHttpServer.html#a73658daf379e87a4832fe9dc5c1483ed) call. Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the `gSystem->ProcessEvents()` call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session. If an application runs in compiled code and does not contain `gSystem->ProcessEvents()` calls, two method are available. ### Asynchronous timer. The first method is to configure an asynchronous timer for the server, like for example:. ```cpp; serv->SetTimer(100, kFALSE);; ```. Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of **`TH1::Fill()`** calls and an histogram object may be incomplete. Therefore such method is not recommended. ### Regular calls of THttpServer::ProcessRequests() method. The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:. ```cpp; serv->ProcessRequests();; ```. In such case, one can fully disable the timer of the server:. ```cpp; serv->SetTimer(0, kTRUE);; ```. ## Data access from command shell. The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:13506,config,configure,13506,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configure']
Modifiability," @putchard(double). define double @printstar(double %n) {; entry:; ; initial value = 1.0 (inlined into phi); br label %loop. loop: ; preds = %loop, %entry; %i = phi double [ 1.000000e+00, %entry ], [ %nextvar, %loop ]; ; body; %calltmp = call double @putchard(double 4.200000e+01); ; increment; %nextvar = fadd double %i, 1.000000e+00. ; termination test; %cmptmp = fcmp ult double %i, %n; %booltmp = uitofp i1 %cmptmp to double; %loopcond = fcmp one double %booltmp, 0.000000e+00; br i1 %loopcond, label %loop, label %afterloop. afterloop: ; preds = %loop; ; loop always returns 0.0; ret double 0.000000e+00; }. This loop contains all the same constructs we saw before: a phi node,; several expressions, and some basic blocks. Let's see how this fits; together. Code Generation for the 'for' Loop; ----------------------------------. The first part of codegen is very simple: we just output the start; expression for the loop value:. .. code-block:: c++. Value *ForExprAST::codegen() {; // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. With this out of the way, the next step is to set up the LLVM basic; block for the start of the loop body. In the case above, the whole loop; body is one block, but remember that the body code itself could consist; of multiple blocks (e.g. if it contains an if/then/else or a for/in; expression). .. code-block:: c++. // Make the new basic block for the loop header, inserting after current; // block.; Function *TheFunction = Builder->GetInsertBlock()->getParent();; BasicBlock *PreheaderBB = Builder->GetInsertBlock();; BasicBlock *LoopBB =; BasicBlock::Create(*TheContext, ""loop"", TheFunction);. // Insert an explicit fall through from the current block to the LoopBB.; Builder->CreateBr(LoopBB);. This code is similar to what we saw for if/then/else. Because we will; need it to create the Phi node, we remember the block that falls through; into the loop. Once we have that, we ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:20601,variab,variable,20601,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability," Add the record to the final record list. Because references between fields are resolved (step 5) after ``let`` bindings are; applied (step 3), the ``let`` statement has unusual power. For example:. .. code-block:: text. class C <int x> {; int Y = x;; int Yplus1 = !add(Y, 1);; int xplus1 = !add(x, 1);; }. let Y = 10 in {; def rec1 : C<5> {; }; }. def rec2 : C<5> {; let Y = 10;; }. In both cases, one where a top-level ``let`` is used to bind ``Y`` and one; where a local ``let`` does the same thing, the results are:. .. code-block:: text. def rec1 { // C; int Y = 10;; int Yplus1 = 11;; int xplus1 = 6;; }; def rec2 { // C; int Y = 10;; int Yplus1 = 11;; int xplus1 = 6;; }. ``Yplus1`` is 11 because the ``let Y`` is performed before the ``!add(Y,; 1)`` is resolved. Use this power wisely. Using Classes as Subroutines; ============================. As described in `Simple values`_, a class can be invoked in an expression; and passed template arguments. This causes TableGen to create a new anonymous; record inheriting from that class. As usual, the record receives all the; fields defined in the class. This feature can be employed as a simple subroutine facility. The class can; use the template arguments to define various variables and fields, which end; up in the anonymous record. Those fields can then be retrieved in the; expression invoking the class as follows. Assume that the field ``ret``; contains the final value of the subroutine. .. code-block:: text. int Result = ... CalcValue<arg>.ret ...;. The ``CalcValue`` class is invoked with the template argument ``arg``. It; calculates a value for the ``ret`` field, which is then retrieved at the; ""point of call"" in the initialization for the Result field. The anonymous; record created in this example serves no other purpose than to carry the; result value. Here is a practical example. The class ``isValidSize`` determines whether a; specified number of bytes represents a valid data size. The bit ``ret`` is; set appropriately.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:55191,inherit,inheriting,55191,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inheriting']
Modifiability," As with a ``StringRef``, ``Twine`` objects point to external memory and should; almost never be stored or mentioned directly. They are intended solely for use; when defining a function which should be able to efficiently accept concatenated; strings. .. _formatting_strings:. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacement sequence is a string of the form ``{N[[,align]:style]}``. ``N`` refers to the 0-based index of the argument from the list of replacement; values. Note that this means it is possible to reference the same parameter; multiple times, possibly with different style and/or alignment options, in any order. ``align`` is an optional string specifying the width of the field to format; the value into, and the alignment of the v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:11839,portab,portable,11839,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['portab'],['portable']
Modifiability, C++ compiler and linker invocations. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html). - `CMAKE_C_COMPILER`. Select the C compiler executable to be used. Note that the C++ compiler is; inferred automatically i.e. when specifying `path/to/clang` CMake will; automatically use `path/to/clang++` as the C++ compiler. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html). - `CMAKE_Fortran_COMPILER`. Select the Fortran compiler executable to be used. Not set by default and not; required unless running the Fortran Test Suite. - `CMAKE_BUILD_TYPE`. Select a build type like `OPTIMIZE` or `DEBUG` selecting a set of predefined; compiler flags. These flags are applied regardless of the `CMAKE_C_FLAGS`; option and may be changed by modifying `CMAKE_C_FLAGS_OPTIMIZE` etc. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html). - `TEST_SUITE_FORTRAN`. Activate that Fortran tests. This is a work in progress. More information can be; found in the [Flang documentation](https://flang.llvm.org/docs/FortranLLVMTestSuite.html). - `TEST_SUITE_RUN_UNDER`. Prefix test invocations with the given tool. This is typically used to run; cross-compiled tests within a simulator tool. - `TEST_SUITE_BENCHMARKING_ONLY`. Disable tests that are unsuitable for performance measurements. The disabled; tests either run for a very short time or are dominated by I/O performance; making them unsuitable as compiler performance tests. - `TEST_SUITE_SUBDIRS`. Semicolon-separated list of directories to include. This can be used to only; build parts of the test-suite or to include external suites. This option; does not work reliably with deeper subdirectories as it skips intermediate; `CMakeLists.txt` files which may be required. - `TEST_SUITE_CO,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:5125,variab,variable,5125,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['variab'],['variable']
Modifiability," C++ implementation for the import of GDML into ROOT.; They act as a converter between the GDML geometry files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geometry. The actual; application-specific (ROOT) binding is implemented in ROOTwriter; module. It contains 'binding methods' for TGeo geometry classes which; can be exported in GDML format. Please refere to the comment part of; the ROOTwriter.py file for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:1221,config,configure,1221,geom/gdml/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md,1,['config'],['configure']
Modifiability," C++ programming; language.; The LLVM bug tracker uses; the ""c++"" label, as well as mode-specific labels such as ""c++11"", ""c++14"",; and so on, to track known bugs with Clang's language conformance.; C++2c implementation status. Clang has support for some of the features of the C++ standard following; C++23, informally referred to as C++26.; You can use Clang in C++2c mode with the -std=c++2c option. List of features and minimum Clang version with support. Language Feature; C++26 Proposal; Available in Clang?. Remove undefined behavior from lexing; P2621R2 (DR); Clang 3.3. Making non-encodable string literals ill-formed; P1854R4 (DR); Clang 14. Unevaluated strings; P2361R6; Clang 18. Add @, $, and ` to the basic character set; P2558R2; Yes. constexpr cast from void*; P2738R1; Clang 17. On the ignorability of standard attributes; P2552R3 (DR); No. Static storage for braced initializers; P2752R3 (DR); No. User-generated static_assert messages; P2741R3; Clang 17. Placeholder variables with no name; P2169R4; Clang 18. Template parameter initialization; P2308R1 (DR); Clang 18. Pack Indexing; P2662R3; No. Remove Deprecated Arithmetic Conversion on Enumerations; P2864R2; Clang 18. C++23 implementation status. Clang has support for some of the features of the ISO C++ 2023 standard.; You can use Clang in C++23 mode with the -std=c++23 option. List of features and minimum Clang version with support. Language Feature; C++23 Proposal; Available in Clang?. Literal suffix uz, z for size_t, ssize_t; P0330R8; Clang 13. Make () in lambdas optional in all cases; P1102R2; Clang 13. Simpler implicit move; P2266R1; Clang 13. if consteval; P1938R3; Clang 14. Allow duplicate attributes; P2156R1; Clang 13. Narrowing contextual conversions to bool; P1401R5; Clang 14. Trimming whitespaces before line splicing; P2223R2; Yes. Make declaration order layout mandated; P1874R4; Yes. C++ identifier syntax using UAX 31; P1949R7; Clang 14. Mixed string literal concatenation; P2201R1; Yes. Deducing this",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:1713,variab,variables,1713,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,1,['variab'],['variables']
Modifiability," C++ standards. Has no effect except on; the types and targets listed above.; * ``fast`` - Accepted for GCC compatibility, but currently treated as an; alias for ``standard``.; * ``16`` - Forces ``_Float16`` operations to be emitted without using excess; precision arithmetic. .. option:: -fcx-limited-range:. This option enables the naive mathematical formulas for complex division and; multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by the ``-ffast-math``; option. .. option:: -fcx-fortran-rules:. This option enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69094,config,configured,69094,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configured']
Modifiability," C17 6.5.6p8, C++ [expr.add]).; This means that arbitrary integer values stored in pointer-type variables must; not be passed to these builtins. For those use cases, the builtins can still be; used, but the operation must be performed on the pointer cast to ``uintptr_t``. If Clang can determine that the alignment is not a power of two at compile time,; it will result in a compilation failure. If the alignment argument is not a; power of two at run time, the behavior of these builtins is undefined. Non-standard C++11 Attributes; =============================. Clang's non-standard C++11 attributes live in the ``clang`` attribute; namespace. Clang supports GCC's ``gnu`` attribute namespace. All GCC attributes which; are accepted with the ``__attribute__((foo))`` syntax are also accepted as; ``[[gnu::foo]]``. This only extends to attributes which are specified by GCC; (see the list of `GCC function attributes; <https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html>`_, `GCC variable; attributes <https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html>`_, and; `GCC type attributes; <https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html>`_). As with the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaration or; immediately after the name being declared. For example, this applies the GNU ``unused`` attribute to ``a`` and ``f``, and; also applies the GNU ``noreturn`` attribute to ``f``. .. code-block:: c++. [[gnu::unused]] int a, f [[gnu::noreturn]] ();. Target-Specific Extensions; ==========================. Clang supports some language features conditionally on some targets. ARM/AArch64 Language Extensions; -------------------------------. Memory Barrier Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^; Clang implements the ``__dmb``, ``__dsb`` and ``__isb`` intrinsics as defined; in the `Arm C Language Extensions; <https://github.com/ARM-software/acle/releases>`_.; Not",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:153783,variab,variable,153783,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variable']
Modifiability, CD5; Class template argument deduction with array declarator; Unknown. 2377; NAD; Explicit copy constructor vs function viability; Unknown. 2378; C++20; Inconsistent grammar for reference init-capture of pack; Unknown. 2379; CD5; Missing prohibition against constexpr in friend declaration; Unknown. 2380; CD5; capture-default makes too many references odr-usable; Unknown. 2381; CD5; Composite pointer type of pointers to plain and noexcept member functions; Unknown. 2382; CD5; Array allocation overhead for non-allocating placement new; Unknown. 2383; NAD; Variadic member functions of variadic class templates; Unknown. 2384; CD5; Conversion function templates and qualification conversions; Unknown. 2385; CD5; Lookup for conversion-function-ids; N/A. 2386; CD5; tuple_size requirements for structured binding; Clang 9. 2387; CD5; Linkage of const-qualified variable template; Clang 9. 2388; NAD; Applicability of contract-attribute-specifiers; Unknown. 2389; CD6; Agreement of deduced and explicitly-specified variable types; Unknown. 2390; CD5; Is the argument of __has_cpp_attribute macro-expanded?; Clang 14. 2391; dup; Additional template parameters following pack expansion; Unknown. 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD5; Const-default-constructible for members; Clang 15. 2395; drafting; Parameters following a pack expansion; Not resolved. 2396; CD6; Lookup of names in complex conversion-type-ids; No. 2397; CD6; auto specifier for pointers and references to arrays; Clang 17. 2398; drafting; Template template parameter matching and deduction; Not resolved. 2399; CD5; Unclear referent of “expression” in assignment-expression; Unknown. 2400; CD5; Constexpr virtual functions and temporary objects; Unknown. 2401; drafting; Array decay vs prohibition of subobject non-type arguments; Not resolved. 2402; CD6; When is the restriction to a single c-char in a Unicode literal enfor,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:163290,variab,variable,163290,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability," CMake variables are ""stringly"" typed. All variables are represented as; strings throughout evaluation. Wrapping a variable in ``${}`` dereferences it; and results in a literal substitution of the name for the value. CMake refers to; this as ""variable evaluation"" in their documentation. Dereferences are performed; *before* the command being called receives the arguments. This means; dereferencing a list results in multiple separate arguments being passed to the; command. Variable dereferences can be nested and be used to model complex data. For; example:. .. code-block:: cmake. set(var_name var1); set(${var_name} foo) # same as ""set(var1 foo)""; set(${${var_name}}_var bar) # same as ""set(foo_var bar)"". Dereferencing an unset variable results in an empty expansion. It is a common; pattern in CMake to conditionally set variables knowing that it will be used in; code paths that the variable isn't set. There are examples of this throughout; the LLVM CMake build system. An example of variable empty expansion is:. .. code-block:: cmake. if(APPLE); set(extra_sources Apple.cpp); endif(); add_executable(HelloWorld HelloWorld.cpp ${extra_sources}). In this example the ``extra_sources`` variable is only defined if you're; targeting an Apple platform. For all other targets the ``extra_sources`` will be; evaluated as empty before add_executable is given its arguments. Lists; -----. In CMake lists are semi-colon delimited strings, and it is strongly advised that; you avoid using semi-colons in lists; it doesn't go smoothly. A few examples of; defining lists:. .. code-block:: cmake. # Creates a list with members a, b, c, and d; set(my_list a b c d); set(my_list ""a;b;c;d""). # Creates a string ""a b c d""; set(my_string ""a b c d""). Lists of Lists; --------------. One of the more complicated patterns in CMake is lists of lists. Because a list; cannot contain an element with a semi-colon to construct a list of lists you; make a list of variable names that refer to other lists. For exampl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:3841,variab,variable,3841,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variable']
Modifiability," CORS on Apache web server, hosting ROOT files, one should add following lines to `.htaccess` file:. <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>. More details about configuring of CORS headers can be found [here](https://developer.mozilla.org/en/http_access_control). Alternative - enable CORS requests in the browser. It can be easily done with [CORS Everywhere plugin](https://addons.mozilla.org/de/firefox/addon/cors-everywhere/) for the Firefox browser or [Allow CORS plugin](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?hl=en) for the Chrome browser. Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to `modules/gui.mjs` script like:. ```javascript; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; ```. In the main `<div>` element one can specify many custom parameters like one do it in URL string:. ```html; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; ```. ## Reading local ROOT files. JSROOT can read files from local file system using HTML5 FileReader functionality.; Main limitation here - user should interactively select files for reading.; There is button __""...""__ on the main JSROOT page, which starts file selection dialog.; If valid ROOT file is selected, JSROOT will be able to normally read content of such file. ## JSROOT with THttpServer. THttpServer provi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:28733,config,configuration,28733,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configuration']
Modifiability," CXType_RValueReference){ // or an RValue Reference (&&),; CXType pointed_to_type = clang_getPointeeType(cursor_type);// retrieve the pointed-to type. CXString pointed_to_type_spelling = clang_getTypeSpelling(pointed_to_type); // Spell out the entire; std::cout << ""pointing to type: "" << clang_getCString(pointed_to_type_spelling);// pointed-to type; clang_disposeString(pointed_to_type_spelling);; }; else if(cursor_type.kind == CXType_Record){; CXString type_spelling = clang_getTypeSpelling(cursor_type);; std::cout << "", namely "" << clang_getCString(type_spelling);; clang_disposeString(type_spelling);; }; std::cout << ""\n"";; return CXChildVisit_Recurse;; },; nullptr; );. The expected output of program is:. .. code-block::. Type Kind: Record, namely A; Type Kind: Int; Type Kind: Record, namely B; Type Kind: Int; Type Kind: Record, namely A; Type Kind: Record, namely A. Reiterating the difference between ``CXType`` and ``CXTypeKind``: For an example. .. code-block:: cpp. const char* __restrict__ variable;. - Type Kind will be: ``CXType_Pointer`` spelled ``""Pointer""``; - Type will be a complex ``CXType`` structure, spelled ``""const char* __restrict__``. Retrieving source locations; """""""""""""""""""""""""""""""""""""""""""""""""""""". ``CXSourceRange clang_getCursorExtent(CXCursor)`` returns a ``CXSourceRange``, representing a half-open range in the source code. Use ``clang_getRangeStart(CXSourceRange)`` and ``clang_getRangeEnd(CXSourceRange)`` to retrieve the starting and end ``CXSourceLocation`` from a source range, respectively. Given a ``CXSourceLocation``, use ``clang_getExpansionLocation`` to retrieve file, line and column of a source location. Code example; """"""""""""""""""""""""; .. code-block:: cpp. // Again, file.cpp; struct foo{; int bar;; int* bar_pointer;; };; .. code-block:: cpp. clang_visitChildren(; cursor,; [](CXCursor current_cursor, CXCursor parent, CXClientData client_data){. CXType cursor_type = clang_getCursorType(current_cursor);; CXString cursor_spelling = clang_getCursorSpelling(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst:7155,variab,variable,7155,interpreter/llvm-project/clang/docs/LibClang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst,1,['variab'],['variable']
Modifiability," Calling explicit object member functions; Not resolved. 2689; tentatively ready; Are cv-qualified std::nullptr_t fundamental types?; Unknown. 2690; C++23; Semantics of defaulted move assignment operator for unions; Unknown. 2691; C++23; hexadecimal-escape-sequence is too greedy; Unknown. 2692; C++23; Static and explicit object member functions with the same parameter-type-lists; Unknown. 2693; open; Escape sequences for the string-literal of #line; Not resolved. 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:186555,inherit,inheritance,186555,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inherit'],['inheritance']
Modifiability," Chapter 2 of the ""Building an ORC-based JIT in LLVM"" tutorial. In; `Chapter 1 <BuildingAJIT1.html>`_ of this series we examined a basic JIT; class, KaleidoscopeJIT, that could take LLVM IR modules as input and produce; executable code in memory. KaleidoscopeJIT was able to do this with relatively; little code by composing two off-the-shelf *ORC layers*: IRCompileLayer and; ObjectLinkingLayer, to do much of the heavy lifting. In this layer we'll learn more about the ORC layer concept by using a new layer,; IRTransformLayer, to add IR optimization support to KaleidoscopeJIT. Optimizing Modules using the IRTransformLayer; =============================================. In `Chapter 4 <LangImpl04.html>`_ of the ""Implementing a language with LLVM""; tutorial series the llvm *FunctionPassManager* is introduced as a means for; optimizing LLVM IR. Interested readers may read that chapter for details, but; in short: to optimize a Module we create an llvm::FunctionPassManager; instance, configure it with a set of optimizations, then run the PassManager on; a Module to mutate it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In this Chapter we will make optimization a phase of our JIT; instead. For now this will provide us a motivation to learn more about ORC; layers, but in the long term making optimization part of our JIT will yield an; important benefit: When we begin lazily compiling code (i.e. deferring; compilation of each function until the first time it's run) having; optimization managed by our JIT will allow us to optimize lazily too, rather; than having to do all our optimization up-front. To add optimization support to our JIT we will take the KaleidoscopeJIT from; Chapter 1 and compose an ORC *IRTransformLayer* on top. We will look at how the; IRTransformLayer works in more detail below, but the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:1682,config,configure,1682,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['config'],['configure']
Modifiability," ClassDef(Event,1) //Event structure; };; ```. ### The EventHeader Class. The `EventHeader` class (also defined in `Event.h`) does not inherit; from **`TObject`**. Beginning with ROOT 3.0, an object can be placed on; a branch even though it does not inherit from **`TObject`**. In previous; releases branches were restricted to objects inheriting from the; **`TObject`**. However, it has always been possible to write a class not; inheriting from **`TObject`** to a tree by encapsulating it in a; **`TObject`** descending class as is the case in `EventHeader` and; `Event`. ``` {.cpp}; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; ```. ### The Track Class. The `Track` class descends from **`TObject`** since tracks are in a; **`TClonesArray`** (i.e. a ROOT collection class) and contains a; selection of basic types and an array of vertices. Its **`TObject`**; inheritance enables `Track` to be in a collection and in `Event` is a; **`TClonesArray`** of `Tracks`. ``` {.cpp}; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:60968,inherit,inheritance,60968,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['inherit'],['inheritance']
Modifiability," Code command. .. option:: --macho-dsymtab. Display the Dsymtab command. .. option:: --macho-indirect-symbols. Display indirect symbols. .. option:: --macho-linker-options. Display the Mach-O-specific linker options. .. option:: --macho-segment. Display the Segment command. .. option:: --macho-version-min. Display the version min command. PE/COFF SPECIFIC OPTIONS; ------------------------. The following options are implemented only for the PE/COFF file format. .. option:: --codeview. Display CodeView debug information. .. option:: --codeview-ghash. Enable global hashing for CodeView type stream de-duplication. .. option:: --codeview-merged-types. Display the merged CodeView type stream. .. option:: --codeview-subsection-bytes. Dump raw contents of CodeView debug sections and records. .. option:: --coff-basereloc. Display the .reloc section. .. option:: --coff-debug-directory. Display the debug directory. .. option:: --coff-tls-directory. Display the TLS directory. .. option:: --coff-directives. Display the .drectve section. .. option:: --coff-exports. Display the export table. .. option:: --coff-imports. Display the import table. .. option:: --coff-load-config. Display the load config. .. option:: --coff-resources. Display the .rsrc section. XCOFF SPECIFIC OPTIONS; ----------------------. The following options are implemented only for the XCOFF file format. .. option:: --auxiliary-header. Display XCOFF Auxiliary header. .. option:: --exception-section. Display XCOFF exception section entries. .. option:: --loader-section-header. Display XCOFF loader section header. .. option:: --loader-section-symbols. Display symbol table of loader section. .. option:: --loader-section-relocations. Display relocation entries of loader section. EXIT STATUS; -----------. :program:`llvm-readobj` returns 0 under normal operation. It returns a non-zero; exit code if there were any errors. SEE ALSO; --------. :manpage:`llvm-nm(1)`, :manpage:`llvm-objdump(1)`, :manpage:`llvm-readelf(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst:8279,config,config,8279,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst,2,['config'],['config']
Modifiability," Contents`_. * *pointer type*: The type index of the pointer type used to point to this; global variable. * *isconst*: Non-zero if the variable is treated as constant within the module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: An encoding of the linkage type for this variable:. * ``external``: code 0; * ``weak``: code 1; * ``appending``: code 2; * ``internal``: code 3; * ``linkonce``: code 4; * ``dllimport``: code 5; * ``dllexport``: code 6; * ``extern_weak``: code 7; * ``common``: code 8; * ``private``: code 9; * ``weak_odr``: code 10; * ``linkonce_odr``: code 11; * ``available_externally``: code 12; * deprecated : code 13; * deprecated : code 14. * alignment*: The logarithm base 2 of the variable's requested alignment, plus 1. * *section*: If non-zero, the 1-based section index in the table of; `MODULE_CODE_SECTIONNAME`_ entries. .. _visibility:. * *visibility*: If present, an encoding of the visibility of this variable:. * ``default``: code 0; * ``hidden``: code 1; * ``protected``: code 2. .. _bcthreadlocal:. * *threadlocal*: If present, an encoding of the thread local storage mode of the; variable:. * ``not thread local``: code 0; * ``thread local; default TLS model``: code 1; * ``localdynamic``: code 2; * ``initialexec``: code 3; * ``localexec``: code 4. .. _bcunnamedaddr:. * *unnamed_addr*: If present, an encoding of the ``unnamed_addr`` attribute of this; variable:. * not ``unnamed_addr``: code 0; * ``unnamed_addr``: code 1; * ``local_unnamed_addr``: code 2. .. _bcdllstorageclass:. * *dllstorageclass*: If present, an encoding of the DLL storage class of this variable:. * ``default``: code 0; * ``dllimport``: code 1; * ``dllexport``: code 2. * *comdat*: An encoding of the COMDAT of this function. * *attributes*: If nonzero, the 1-based index into the table of AttributeLists. .. _bcpreemptionspecifier:. * *preemptionspecifier*: If present, an encoding of the run",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:28457,variab,variable,28457,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability," Cortex-M4.; Multilib can also choose between libraries for the same architecture based on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:1920,config,configuration,1920,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['config'],['configuration']
Modifiability," DRAM, and MTYPE UC (used for; remote fine grain memory) bypasses the L2, so both will never result in; dirty L2 cache lines.; * To ensure coherence of local and remote memory reads of work-groups in; different agents a ``buffer_invl2`` is required. It will invalidate L2; cache lines with MTYPE NC (used for remote coarse grain memory). Note that; MTYPE CC (used for local fine grain memory) and MTYPE RW (used for local; coarse memory) cause local reads to be invalidated by remote writes with; with the PTE C-bit so these cache lines are not invalidated. Note that; MTYPE UC (used for remote fine grain memory) bypasses the L2, so will; never result in L2 cache lines that need to be invalidated. * PCIe access from the GPU to the CPU memory is kept coherent by using the; MTYPE UC (uncached) which bypasses the L2. Scalar memory operations are only used to access memory that is proven to not; change during the execution of the kernel dispatch. This includes constant; address space and global address space for program scope ``const`` variables.; Therefore, the kernel machine code does not have to maintain the scalar cache to; ensure it is coherent with the vector caches. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:239996,variab,variables,239996,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variables']
Modifiability," Defs -----------------. Inheritance is done by putting the class you want to inherit from after `:`, before the opening `{`. You'll know that `D` inherits from `C` by the `// C` comment on the `class D {` line in the output. Not very interesting though, what are we actually inheriting? The members of the parent class. ```tablegen; class C {; int a;; }; class D : C {}; ```. ------------- Classes -----------------; class C {; int a = ?;; }; class D {	// C; int a = ?;; }; ------------- Defs -----------------. Note that `D` now has the `a` member which was defined in the class `C`. You can inherit from multiple classes. In that case the order that that happens in matches the order you write the class names after the `:`. ```tablegen; class C {; int a = 1;; }; class D {; int a = 2;; }; class E : C, D {}; ```. ------------- Classes -----------------; class C {; int a = 1;; }; class D {; int a = 2;; }; class E {	// C D; int a = 2;; }; ------------- Defs -----------------. Class `E` first inherits from class `C`. This gives `E` a member `a` with value `1`. Then it inherits from class `D` which also has a member `a` but with a value of `2`. Meaning the final value of `E`'s `a` is `2`. When a member has the same name this is handled on a ""last one in wins"" basis. Assuming the types match. ```tablegen; class C {; string a = """";; }; class D {; int a = 2;; }; class E : C, D {}; ```. <stdin>:7:14: error: New definition of 'a' of type 'int' is incompatible with previous definition of type 'string'; class E : C, D {}; ^. When they don't match, we get an error. Luckily for us, we're about to learn all about types. ## Types. TableGen is statically typed with error checking to prevent you from assigning things with mismatched types. ```tablegen; class C {; int a;; bit b = 0;; string s = ""Hello"";; }; ```. ------------- Classes -----------------; class C {; int a = ?;; bit b = 0;; string s = ""Hello"";; }; ------------- Defs -----------------. Here we've created a class C with integer, bi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:4140,inherit,inherits,4140,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['inherit'],['inherits']
Modifiability," EXPORT LLVMExports; ARCHIVE DESTINATION lib${LLVM_LIBDIR_SUFFIX} COMPONENT tf_xla_runtime); set_property(GLOBAL APPEND PROPERTY LLVM_EXPORTS tf_xla_runtime); # Once we add more modules, we should handle this more automatically.; if (DEFINED LLVM_OVERRIDE_MODEL_HEADER_INLINERSIZEMODEL); set(LLVM_INLINER_MODEL_PATH ""none""); elseif(NOT DEFINED LLVM_INLINER_MODEL_PATH; OR ""${LLVM_INLINER_MODEL_PATH}"" STREQUAL """"; OR ""${LLVM_INLINER_MODEL_PATH}"" STREQUAL ""autogenerate""); set(LLVM_INLINER_MODEL_PATH ""autogenerate""); set(LLVM_INLINER_MODEL_AUTOGENERATED 1); endif(); if (DEFINED LLVM_OVERRIDE_MODEL_HEADER_REGALLOCEVICTMODEL); set(LLVM_RAEVICT_MODEL_PATH ""none""); elseif(NOT DEFINED LLVM_RAEVICT_MODEL_PATH; OR ""${LLVM_RAEVICT_MODEL_PATH}"" STREQUAL """"; OR ""${LLVM_RAEVICT_MODEL_PATH}"" STREQUAL ""autogenerate""); set(LLVM_RAEVICT_MODEL_PATH ""autogenerate""); set(LLVM_RAEVICT_MODEL_AUTOGENERATED 1); endif(). endif(). # Configure the three LLVM configuration header files.; configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/config.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/config.h); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/llvm-config.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/llvm-config.h); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/abi-breaking.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/abi-breaking.h). # Add target for generating source rpm package.; set(LLVM_SRPM_USER_BINARY_SPECFILE ${CMAKE_CURRENT_SOURCE_DIR}/llvm.spec.in; CACHE FILEPATH "".spec file to use for srpm generation""); set(LLVM_SRPM_BINARY_SPECFILE ${CMAKE_CURRENT_BINARY_DIR}/llvm.spec); set(LLVM_SRPM_DIR ""${CMAKE_CURRENT_BINARY_DIR}/srpm""). get_source_info(${CMAKE_CURRENT_SOURCE_DIR} revision repository); string(LENGTH ""${revision}"" revision_length); set(LLVM_RPM_SPEC_REVISION ""${revision}""). configure_file(; ${LLVM_SRPM_USER_BINARY_SPECFILE}; ${LLVM_SRPM_BINARY_SPECFILE} @ONLY). add_custom_target(srpm; COMMAND cpack -G TGZ --config CPackSourceConfig.cmake -B ${LLVM_SRPM_DIR}/SOURCES; COMMAND rp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:44913,config,config,44913,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config']
Modifiability," EXTENSION __cl_clang_non_portable_kernel_param_types : disable. Remove address space builtin function; -------------------------------------. ``__remove_address_space`` allows to derive types in C++ for OpenCL; that have address space qualifiers removed. This utility only affects; address space qualifiers, therefore, other type qualifiers such as; ``const`` or ``volatile`` remain unchanged. **Example of Use**:. .. code-block:: c++. template<typename T>; void foo(T *par){; T var1; // error - local function variable with global address space; __private T var2; // error - conflicting address space qualifiers; __private __remove_address_space<T>::type var3; // var3 is __private int; }. void bar(){; __global int* ptr;; foo(ptr);; }. Legacy 1.x atomics with generic address space; ---------------------------------------------. Clang allows use of atomic functions from the OpenCL 1.x standards; with the generic address space pointer in C++ for OpenCL mode. This is a non-portable feature and might not be supported by all; targets. **Example of Use**:. .. code-block:: c++. void foo(__generic volatile unsigned int* a) {; atomic_add(a, 1);; }. WebAssembly Features; ====================. Clang supports the WebAssembly features documented below. For further; information related to the semantics of the builtins, please refer to the `WebAssembly Specification <https://webassembly.github.io/spec/core/>`_.; In this section, when we refer to reference types, we are referring to; WebAssembly reference types, not C++ reference types unless stated; otherwise. ``__builtin_wasm_table_set``; ----------------------------. This builtin function stores a value in a WebAssembly table.; It takes three arguments.; The first argument is the table to store a value into, the second; argument is the index to which to store the value into, and the; third argument is a value of reference type to store in the table.; It returns nothing. .. code-block:: c++. static __externref_t table[0];; extern __exter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:91413,portab,portable,91413,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['portab'],['portable']
Modifiability," Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template arguments for a name are; available. Also, for functions, all tags from the <bare-function-type>; (which might include the return type for template functions) are available. For <local-name>s all active tags used in the local part (<function-; encoding>) are available, but not implicit tags which were not active. Implicit and explicit tags used in the <unqualified-name> for a function (as; in the type of a cast operator) are NOT available. Example: a cast operator to std::string (which is; std::__cxx11::basic_string<...>) will use 'cxx11' as an active tag, as it is; required from the return type `std::string` but not available.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:2298,variab,variable,2298,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,2,['variab'],['variable']
Modifiability, Explicit conversion of a scoped enumeration value to a floating type; Unknown. 834; CD2; What is an “ordinary string literal”?; Unknown. 835; CD2; Scoped enumerations and the “usual arithmetic conversions”; Unknown. 836; NAD; [[noreturn]] applied to function types; Unknown. 837; C++11; Constexpr functions and return braced-init-list; Unknown. 838; C++11; Use of this in a brace-or-equal-initializer; Unknown. 839; dup; sizeof with opaque enumerations; Unknown. 840; CD2; Rvalue references as nontype template parameters; Unknown. 842; CD2; Casting to rvalue reference type; Unknown. 845; CD2; What is the “first declaration” of an explicit specialization?; Unknown. 846; CD2; Rvalue references to functions; Unknown. 847; CD2; Error in rvalue reference deduction example; Unknown. 850; CD2; Restrictions on use of non-static data members; Unknown. 852; CD6; using-declarations and dependent base classes; Unknown. 853; CD2; Support for relaxed pointer safety; Unknown. 854; CD2; Left shift and unsigned extended types; Unknown. 855; CD2; Incorrect comments in braced-init-list assignment example; Unknown. 858; CD2; Example binding an rvalue reference to an lvalue; Unknown. 860; C++11; Explicit qualification of constexpr member functions; Unknown. 861; CD2; Unintended ambiguity in inline namespace lookup; Unknown. 862; CD2; Undefined behavior with enumerator value overflow; Unknown. 863; CD2; Rvalue reference cast to incomplete type; Unknown. 864; C++11; braced-init-list in the range-based for statement; Unknown. 865; CD2; Initializing a std::initializer_list; Unknown. 869; CD2; Uninitialized thread_local objects; Unknown. 872; CD2; Lexical issues with raw strings; Unknown. 873; C++11; Deducing rvalue references in declarative contexts; Clang 3.0. 874; CD2; Class-scope definitions of enumeration types; Unknown. 876; CD2; Type references in rvalue reference deduction specification; Unknown. 877; CD2; Viable functions and binding references to rvalues; Unknown. 879; CD2; Missing buil,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:57306,extend,extended,57306,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['extend'],['extended']
Modifiability," Fix crash in implicit conversions from initialize list to arrays of unknown; bound for C++20. Fixes; (`#62945 <https://github.com/llvm/llvm-project/issues/62945>`_); - Clang now allows an ``_Atomic`` qualified integer in a switch statement. Fixes; (`#65557 <https://github.com/llvm/llvm-project/issues/65557>`_); - Fixes crash when trying to obtain the common sugared type of; `decltype(instantiation-dependent-expr)`.; Fixes (`#67603 <https://github.com/llvm/llvm-project/issues/67603>`_); - Fixes a crash caused by a multidimensional array being captured by a lambda; (`#67722 <https://github.com/llvm/llvm-project/issues/67722>`_).; - Fixes a crash when instantiating a lambda with requires clause.; (`#64462 <https://github.com/llvm/llvm-project/issues/64462>`_); - Fixes a regression where the ``UserDefinedLiteral`` was not properly preserved; while evaluating consteval functions. (`#63898 <https://github.com/llvm/llvm-project/issues/63898>`_).; - Fix a crash when evaluating value-dependent structured binding; variables at compile time.; Fixes (`#67690 <https://github.com/llvm/llvm-project/issues/67690>`_); - Fixes a ``clang-17`` regression where ``LLVM_UNREACHABLE_OPTIMIZE=OFF``; cannot be used with ``Release`` mode builds. (`#68237 <https://github.com/llvm/llvm-project/issues/68237>`_).; - Fix crash in evaluating ``constexpr`` value for invalid template function.; Fixes (`#68542 <https://github.com/llvm/llvm-project/issues/68542>`_); - Clang will correctly evaluate ``noexcept`` expression for template functions; of template classes. Fixes; (`#68543 <https://github.com/llvm/llvm-project/issues/68543>`_,; `#42496 <https://github.com/llvm/llvm-project/issues/42496>`_,; `#77071 <https://github.com/llvm/llvm-project/issues/77071>`_,; `#77411 <https://github.com/llvm/llvm-project/issues/77411>`_); - Fixed an issue when a shift count larger than ``__INT64_MAX__``, in a right; shift operation, could result in missing warnings about; ``shift count >= width of type`` or internal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:37321,variab,variables,37321,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability," Float_t destep;; TBranch *b_destep = t2->GetBranch(""destep"");; b_destep->SetAddress(&destep);. //create one histogram; TH1F *hdestep = new TH1F(""hdestep"",""destep in Mev"",100,1e-5,3e-5);; //read only the destep branch for all entries; Int_t nentries = (Int_t)t2->GetEntries();; for (Int_t i=0;i<nentries;i++) {; b_destep->GetEntry(i);; // fill the histogram with the destep entry; hdestep->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d viewer; gPad->GetViewer3D(""x3d"");; }; ```. ## Example 3: Adding Friends to Trees. In this example, we will show how to extend a tree with a branch from; another tree with the Friends feature. ### Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example, if one; variable in the tree was computed with a certain algorithm, you may want; to try another algorithm and compare the results. One solution is to add; a new branch, fill it, and save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:50910,extend,extend,50910,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['extend'],['extend']
Modifiability," Flow Integrity. LLVM Builds and Distributions; -----------------------------. :doc:`BuildingADistribution`; A best-practices guide for using LLVM's CMake build system to package and; distribute LLVM-based tools. :doc:`CMake`; An addendum to the main Getting Started guide for those using the `CMake; build system <http://www.cmake.org>`_. :doc:`Docker`; A reference for using Dockerfiles provided with LLVM. :doc:`Support Library <SupportLibrary>`; This document describes the LLVM Support Library (``lib/Support``) and; how to keep LLVM source code portable. :doc:`AdvancedBuilds`; This document describes more advanced build configurations. Optimizations; -------------. :doc:`WritingAnLLVMPass`; Information on how to write LLVM transformations and analyses. :doc:`WritingAnLLVMNewPMPass`; Information on how to write LLVM transformations under the new pass; manager. :doc:`Passes`; A list of optimizations and analyses implemented in LLVM. :doc:`StackSafetyAnalysis`; This document describes the design of the stack safety analysis of local; variables. :doc:`MergeFunctions`; Describes functions merging optimization. :doc:`AliasAnalysis`; Information on how to write a new alias analysis implementation or how to; use existing analyses. :doc:`MemorySSA`; Information about the MemorySSA utility in LLVM, as well as how to use it. :doc:`LoopTerminology`; A document describing Loops and associated terms as used in LLVM. :doc:`CycleTerminology`; A document describing cycles as a generalization of loops. :doc:`Vectorizers`; This document describes the current status of vectorization in LLVM. :doc:`LinkTimeOptimization`; This document describes the interface between LLVM intermodular optimizer; and the linker and its design. :doc:`GoldPlugin`; How to build your programs with link-time optimization on Linux. :doc:`Remarks`; A reference on the implementation of remarks in LLVM. :doc:`Source Level Debugging with LLVM <SourceLevelDebugging>`; This document describes the design and philosophy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:3003,variab,variables,3003,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['variab'],['variables']
Modifiability," FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed description. .. _debug-AnalysisOrder:. debug.AnalysisOrder; """"""""""""""""""""""""""""""""""""""; Print callbacks that are called during analysis in order. .. _debug-ConfigDumper:. debug.ConfigDumper; """"""""""""""""""""""""""""""""""""; Dump config table. .. _debug-DumpCFG Display:. debug.DumpCFG Display; """"""""""""""""""""""""""""""""""""""""""; Control-Flow Graphs. .. _debug-DumpCallGraph:. debug.DumpCallGraph; """"""""""""""""""""""""""""""""""""""; Display Call Graph. .. _debug-DumpCalls:. debug.DumpCalls; """"""""""""""""""""""""""""""; Print calls as they are traversed by the engine. .. _debug-DumpDominators:. debug.DumpDominators; """"""""""""""""""""""""""""""""""""""""; Print the dominance tree for a given CFG. .. _debug-DumpLiveVars:. debug.DumpLiveVars; """"""""""""""""""""""""""""""""""""; Print results of live variable analysis. .. _debug-DumpTraversal:. debug.DumpTraversal; """"""""""""""""""""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85930,variab,variables,85930,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variables']
Modifiability," If enabled then sphinx documentation warnings will be treated as; errors. Defaults to ON. Advanced variables; ~~~~~~~~~~~~~~~~~~. These are niche, and changing them from their defaults is more likely to cause; things to go wrong. They are also unstable across LLVM versions. **LLVM_TOOLS_INSTALL_DIR**:STRING; The path to install the main LLVM tools, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to *CMAKE_INSTALL_BINDIR*. **LLVM_UTILS_INSTALL_DIR**:STRING; The path to install auxiliary LLVM utilities, relative to the *CMAKE_INSTALL_PREFIX*.; Only matters if *LLVM_INSTALL_UTILS* is enabled.; Defaults to *LLVM_TOOLS_INSTALL_DIR*. **LLVM_EXAMPLES_INSTALL_DIR**:STRING; The path for examples of using LLVM, relative to the *CMAKE_INSTALL_PREFIX*.; Only matters if *LLVM_BUILD_EXAMPLES* is enabled.; Defaults to ""examples"". CMake Caches; ============. Recently LLVM and Clang have been adding some more complicated build system; features. Utilizing these new features often involves a complicated chain of; CMake variables passed on the command line. Clang provides a collection of CMake; cache scripts to make these features more approachable. CMake cache files are utilized using CMake's -C flag:. .. code-block:: console. $ cmake -C <path to cache file> <path to sources>. CMake cache scripts are processed in an isolated scope, only cached variables; remain set when the main configuration runs. CMake cached variables do not reset; variables that are already set unless the FORCE option is specified. A few notes about CMake Caches:. - Order of command line arguments is important. - -D arguments specified before -C are set before the cache is processed and; can be read inside the cache file; - -D arguments specified after -C are set after the cache is processed and; are unset inside the cache file. - All -D arguments will override cache file settings; - CMAKE_TOOLCHAIN_FILE is evaluated after both the cache file and the command; line arguments; - It is recommended that all -D opti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:38718,variab,variables,38718,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability," If we want to; target a specific feature (such as SSE) or a specific CPU (such as; Intel's Sandylake), we do so now. To see which features and CPUs that LLVM knows about, we can use; ``llc``. For example, let's look at x86:. ::. $ llvm-as < /dev/null | llc -march=x86 -mattr=help; Available CPUs for this target:. amdfam10 - Select the amdfam10 processor.; athlon - Select the athlon processor.; athlon-4 - Select the athlon-4 processor.; ... Available features for this target:. 16bit-mode - 16-bit mode (i8086).; 32bit-mode - 32-bit mode (80386).; 3dnow - Enable 3DNow! instructions.; 3dnowa - Enable 3DNow! Athlon instructions.; ... For our example, we'll use the generic CPU without any additional feature or; target option. .. code-block:: c++. auto CPU = ""generic"";; auto Features = """";. TargetOptions opt;; auto TargetMachine = Target->createTargetMachine(TargetTriple, CPU, Features, opt, Reloc::PIC_);. Configuring the Module; ======================. We're now ready to configure our module, to specify the target and; data layout. This isn't strictly necessary, but the `frontend; performance guide <../../Frontend/PerformanceTips.html>`_ recommends; this. Optimizations benefit from knowing about the target and data; layout. .. code-block:: c++. TheModule->setDataLayout(TargetMachine->createDataLayout());; TheModule->setTargetTriple(TargetTriple);. Emit Object Code; ================. We're ready to emit object code! Let's define where we want to write; our file to:. .. code-block:: c++. auto Filename = ""output.o"";; std::error_code EC;; raw_fd_ostream dest(Filename, EC, sys::fs::OF_None);. if (EC) {; errs() << ""Could not open file: "" << EC.message();; return 1;; }. Finally, we define a pass that emits object code, then we run that; pass:. .. code-block:: c++. legacy::PassManager pass;; auto FileType = CodeGenFileType::ObjectFile;. if (TargetMachine->addPassesToEmitFile(pass, dest, nullptr, FileType)) {; errs() << ""TargetMachine can't emit a file of this type"";; return 1;; }.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst:3460,config,configure,3460,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,1,['config'],['configure']
Modifiability," Improved the ``alpha.unix.Stream`` checker by modeling more functions; ``fputs``, ``fputc``, ``fgets``, ``fgetc``, ``fdopen``, ``ungetc``, ``fflush``,; ``getdelim``, ``getline`` and no not recognize alternative; ``fopen`` and ``tmpfile`` implementations.; (`#78693 <https://github.com/llvm/llvm-project/pull/78693>`_,; `#76776 <https://github.com/llvm/llvm-project/pull/76776>`_,; `#74296 <https://github.com/llvm/llvm-project/pull/74296>`_,; `#73335 <https://github.com/llvm/llvm-project/pull/73335>`_,; `#72627 <https://github.com/llvm/llvm-project/pull/72627>`_,; `#71518 <https://github.com/llvm/llvm-project/pull/71518>`_,; `#72016 <https://github.com/llvm/llvm-project/pull/72016>`_,; `#70540 <https://github.com/llvm/llvm-project/pull/70540>`_,; `#73638 <https://github.com/llvm/llvm-project/pull/73638>`_,; `#77331 <https://github.com/llvm/llvm-project/pull/77331>`_). - The ``alpha.security.taint.TaintPropagation`` checker no longer propagates; taint on ``strlen`` and ``strnlen`` calls, unless these are marked; explicitly propagators in the user-provided taint configuration file.; This removal empirically reduces the number of false positive reports.; Read the PR for the details.; (`#66086 <https://github.com/llvm/llvm-project/pull/66086>`_). - Other taint-related improvements.; (`#66358 <https://github.com/llvm/llvm-project/pull/66358>`_,; `#66074 <https://github.com/llvm/llvm-project/pull/66074>`_,; `#66358 <https://github.com/llvm/llvm-project/pull/66358>`_). - Checkers can query constraint bounds to improve diagnostic messages.; (`#74141 <https://github.com/llvm/llvm-project/pull/74141>`_). - Improved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:75602,config,configuration,75602,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['config'],['configuration']
Modifiability," In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimization options (print level, tolerance, max iterations, etc...); - setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::P",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:38414,config,configurations,38414,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['config'],['configurations']
Modifiability," L with one memory location description SL; on the stack. SL is the target architecture specific memory location; description that corresponds to the thread-local storage address TA. The meaning of the thread-local storage address TA is defined by the; run-time environment. If the run-time environment supports multiple; thread-local storage blocks for a single thread, then the block; corresponding to the executable or shared library containing this DWARF; expression is used. *Some implementations of C, C++, Fortran, and other languages, support a; thread-local storage class. Variables with this storage class have distinct; values and addresses in distinct threads, much as automatic variables have; distinct values and addresses in each subprogram invocation. Typically,; there is a single block of storage containing all thread-local variables; declared in the main executable, and a separate block for the variables; declared in each shared library. Each thread-local variable can then be; accessed in its block using an identifier. This identifier is typically a; byte offset into the block and pushed onto the DWARF stack by one of the*; ``DW_OP_const*`` *operations prior to the* ``DW_OP_form_tls_address``; *operation. Computing the address of the appropriate block can be complex; (in some cases, the compiler emits a function call to do it), and difficult; to describe using ordinary DWARF location descriptions. Instead of forcing; complex thread-local storage calculations into the DWARF expressions, the*; ``DW_OP_form_tls_address`` *allows the consumer to perform the computation; based on the target architecture specific run-time environment.*. 5. ``DW_OP_call_frame_cfa``. ``DW_OP_call_frame_cfa`` pushes the location description L of the Canonical; Frame Address (CFA) of the current subprogram, obtained from the call frame; information on the stack. See :ref:`amdgpu-dwarf-call-frame-information`. *Although the value of the* ``DW_AT_frame_base`` *attribute of the debugger; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:113240,variab,variable,113240,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability, List of features and minimum Clang version with support. Language Feature; C99 Proposal; Available in Clang?. restricted character set support via digraphs and <iso646.h>; Unknown; Unknown. more precise aliasing rules via effective type; Unknown; Unknown. restricted pointers; N448; Unknown. variable length arrays; N683; Yes. flexible array members; Unknown; Yes. static and type qualifiers in parameter array declarators; Unknown; Yes. more precise aliasing rules via effective type; Unknown; Unknown. complex and imaginary support in <complex.h>. N620; Unknown. N638; Unknown. N657; Unknown. N694; Unknown. N809; Unknown. type-generic math macros in <tgmath.h>; N693; Yes. the long long int type; N601; Yes. increase minimum translation limits; N590; Unknown. additional floating-point characteristics in <float.h>; Unknown; Unknown. remove implicit int. N635; Yes. N692; Yes. N722; Yes. reliable integer division; N617; Yes. universal character names (\u and \U); Unknown; Yes. extended identifiers; N717; Unknown. hexadecimal floating-point constants; N308. Yes. compound literals; N716; Yes. designated initializers; N494; Yes. // comments; N644; Yes. extended integer types and library functions in <inttypes.h> and <stdint.h>; Unknown. Yes. remove implicit function declaration; N636; Yes. preprocessor arithmetic done in intmax_t/uintmax_t; N736; Yes. mixed declarations and code; N740; Yes. new block scopes for selection and iteration statements; Unknown; Unknown. integer constant type rules; N629; Yes. integer promotion rules; N725; Yes. macros with a variable number of arguments; N707; Yes. IEC 60559 support; Unknown; Unknown. trailing comma allowed in enum declaration; Unknown; Yes. inline functions; N741; Yes. boolean type in <stdbool.h>; N815; Yes. idempotent type qualifiers; N505; Yes. empty macro arguments; N570; Unknown. new structure type compatibility (tag compatibility); N522; Unknown. additional predefined macro names; Unknown; Unknown. _Pragma preprocessing operator,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:2374,extend,extended,2374,interpreter/llvm-project/clang/www/c_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html,1,['extend'],['extended']
Modifiability," MachineMemOperand in addition to explicit; operands. If the result size is larger than the memory size, the; high bits are undefined, sign-extended, or zero-extended respectively. Only G_LOAD is valid if the result is a vector type. If the result is larger; than the memory size, the high elements are undefined (i.e. this is not a; per-element, vector anyextload). Unlike in SelectionDAG, atomic loads are expressed with the same; opcodes as regular loads. G_LOAD, G_SEXTLOAD and G_ZEXTLOAD may all; have atomic memory operands. G_INDEXED_LOAD; ^^^^^^^^^^^^^^. Generic indexed load. Combines a GEP with a load. $newaddr is set to $base + $offset.; If $am is 0 (post-indexed), then the value is loaded from $base; if $am is 1 (pre-indexed); then the value is loaded from $newaddr. G_INDEXED_SEXTLOAD; ^^^^^^^^^^^^^^^^^^. Same as G_INDEXED_LOAD except that the load performed is sign-extending, as with G_SEXTLOAD. G_INDEXED_ZEXTLOAD; ^^^^^^^^^^^^^^^^^^. Same as G_INDEXED_LOAD except that the load performed is zero-extending, as with G_ZEXTLOAD. G_STORE; ^^^^^^^. Generic store. Expects a MachineMemOperand in addition to explicit; operands. If the stored value size is greater than the memory size,; the high bits are implicitly truncated. If this is a vector store, the; high elements are discarded (i.e. this does not function as a per-lane; vector, truncating store). G_INDEXED_STORE; ^^^^^^^^^^^^^^^. Combines a store with a GEP. See description of G_INDEXED_LOAD for indexing behaviour. G_ATOMIC_CMPXCHG_WITH_SUCCESS; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Generic atomic cmpxchg with internal success check. Expects a; MachineMemOperand in addition to explicit operands. G_ATOMIC_CMPXCHG; ^^^^^^^^^^^^^^^^. Generic atomic cmpxchg. Expects a MachineMemOperand in addition to explicit; operands. G_ATOMICRMW_XCHG, G_ATOMICRMW_ADD, G_ATOMICRMW_SUB, G_ATOMICRMW_AND,; G_ATOMICRMW_NAND, G_ATOMICRMW_OR, G_ATOMICRMW_XOR, G_ATOMICRMW_MAX,; G_ATOMICRMW_MIN, G_ATOMICRMW_UMAX, G_ATOMICRMW_UMIN, G_ATOMICRMW_FA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst:16540,extend,extending,16540,interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,1,['extend'],['extending']
Modifiability," MnPlot() ###. The default constructor initializes default settings for the text window; size. ### operator() ###. MnPlot::operator()(const std::vector$<$std::pair$<$double,double$>$; $>$&) prints a vector of (x,y) points on the text terminal.; operator()(double xmin, double ymin, const; std::vector$<$std::pair$<$double,double$>$ $>$&) prints in addition the; coordinates of the (x,y) values at the minimum. ## MnScan and ScanMinimizer ##. [api:scan]. MnScan scans the value of the user function by varying one parameter. It; is sometimes useful for debugging the user function or finding a; reasonable starting point. Constructor arguments, methods arguments and; names of methods are the same as for MnMigrad and; VariableMetricMinimizer. ### scan(unsigned int par, unsigned int npoint, double low, double high) ###. Scans the value of the user function by varying parameter number; $\mbox{par}$, leaving all other parameters fixed at the current; value. If $\mbox{par}$ is not specified, all variable parameters are; scanned in sequence. The number of points $\mbox{npoints}$ in the; scan is 40 by default, and cannot exceed 100. The range of the scan is; by default 2 standard deviations on each side of the current best value,; but can be specified as from $\mbox{low}$ to $\mbox{high}$.; After each scan, if a new minimum is found, the best parameter values; are retained as start values for future scans or minimizations. The; curve resulting from each scan can be plotted on the output terminal; using MnPlot [api:plot] in order to show the approximate behaviour of; the function. ### ScanMinimizer ###. Although the $\mbox{SCAN}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:47620,variab,variable,47620,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability," Modules Technology Preview. ROOT has several features which interact with libraries and require implicit; header inclusion. This can be triggered by reading or writing data on disk,; or user actions at the prompt. Often, the headers are immutable and reparsing is; redundant. C++ Modules are designed to minimize the reparsing of the same; header content by providing an efficient on-disk representation of C++ Code. This is an experimental feature which can be enabled by compiling ROOT with; `-Druntime_cxxmodules=On`. You can read more about the current state of the; feature [here](../../README.CXXMODULES.md). ## Core Libraries. ### New command line flag ""--version"" for root. `root --version` now displays ROOT version and build info and quits:. ```; ROOT Version: 6.15/01; Built for linuxx8664gcc on Sep 20 2018, 11:04:35; From heads/master@v6-13-04-1273-gea3f4333a2; ```. ### Fish support for thisroot script. `. bin/thisroot.fish` sets up the needed ROOT environment variables for one of the ROOT team's favorite shells, the [fish shell](https://fishshell.com/). ### Change of setting the compression algorithm in `rootrc`. The previous setting called `ROOT.ZipMode` is now unused and ignored.; Instead, use `Root.CompressionAlgorithm` which sets the compression algorithm according to the values of [ECompression](https://root.cern/doc/master/Compression_8h.html#a0a7df9754a3b7be2b437f357254a771c):. * 0: use the default value of `R__ZipMode` (currently selecting ZLIB); * 1: use ZLIB (the default until 6.12 and from 6.16); * 2: use LZMA; * 3: legacy, please don't use; * 4: LZ4. ### TRef. * Improve thread scalability of `TRef`. Creating and looking up a lot of `TRef` from the same `processID` now has practically perfect weak scaling. ### Parallelism; * Upgrade the built-in TBB version to 2019_U1. ### Type System; * Upgrade the `TClass::GetMissingDictionaries` method to support `std::unique_ptr`, `std::array` and `std::tuple` without getting trapped in the internal STL implementati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:2882,variab,variables,2882,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['variab'],['variables']
Modifiability," More user friendly stacktrace in case of a crash, with hints where; the problem might be. On Linux and MacOS X these stacktraces are generated; by the script $ROOTSYS/etc/gdb-backtrace.sh. Using the Root.StackTraceMessage; resource one can customize the message printed by the script. The entire; script can be replaced using the Root.StacktraceScript resource.; Numerous minor bug fixes... New module editline ; The new module editline enhances the prompt, giving type and syntax feedback using e.g. colors.; Class names are highlighted blue when typed, indicating that it is known to ROOT.; Matching parenthesis pairs are highlighted green when typed, or when the cursor is moved to a bracket. This works for () {} and [] brackets.; Any mismatched brackets (those without a matching partner) will be highlighted red when typed or when the cursor is moved to the bracket.; Tab completion output is colored magenta to differentiate between tab completion output and user input.; All of the colors are configurable in the .rootrc file.; They can be specified as #rgb or #rrggbb or color names:; black, red, green, yellow, blue, magenta, cyan or white.; They can be followed by an optional bold (alias light) or underlined.; Rint.ReverseColor allows to quickly toggle between the default ""light on dark"" (yes) instead of ""dark on light"" (no), depending on the terminal background.; An example configuration would be:. Rint.TypeColor: blue; Rint.BracketColor: bold green; Rint.BadBracketColor: underlined red; Rint.TabColor: magenta; Rint.PromptColor: black; Rint.ReverseColor: no. The enhanced prompt is available on all platforms with [n]curses, including Linux, Solaris and MacOS; the bold and underline options are available also for black and white terminals. You can export (or setenv) TERM=xterm-256color for nicer colors.; With editline comes also an improved terminal input handler.; It supports e.g. ^O (Ctrl-o) to replay the history: suppose you have entered. ...; root [3] i = func(); root [",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v526/index.html:2079,config,configurable,2079,core/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v526/index.html,1,['config'],['configurable']
Modifiability," Note that today with SVN or git-svn, this step is not possible since the; ""rebase"" implicitly happens while committing (unless a conflict occurs). Checkout/Clone Multiple Projects, with Commit Access; ----------------------------------------------------. Let's look how to assemble llvm+clang+libcxx at a given revision. Currently; ^^^^^^^^^. ::. svn co https://llvm.org/svn/llvm-project/llvm/trunk llvm -r $REVISION; cd llvm/tools; svn co https://llvm.org/svn/llvm-project/clang/trunk clang -r $REVISION; cd ../projects; svn co https://llvm.org/svn/llvm-project/libcxx/trunk libcxx -r $REVISION. Or using git-svn::. git clone https://llvm.org/git/llvm.git; cd llvm/; git svn init https://llvm.org/svn/llvm-project/llvm/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l; git checkout `git svn find-rev -B r258109`; cd tools; git clone https://llvm.org/git/clang.git; cd clang/; git svn init https://llvm.org/svn/llvm-project/clang/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l; git checkout `git svn find-rev -B r258109`; cd ../../projects/; git clone https://llvm.org/git/libcxx.git; cd libcxx; git svn init https://llvm.org/svn/llvm-project/libcxx/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l; git checkout `git svn find-rev -B r258109`. Note that the list would be longer with more sub-projects. .. _workflow-monocheckout-multicommit:. Monorepo Variant; ^^^^^^^^^^^^^^^^. The repository contains natively the source for every sub-projects at the right; revision, which makes this straightforward::. git clone https://github.com/llvm/llvm-project.git; cd llvm-projects; git checkout $REVISION. As before, at this point clang, llvm, and libcxx are stored in directories; alongside each other. .. _workflow-cross-repo-commit:. Commit an API Change in LLVM and Update the Sub-projects; -------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:16067,config,config,16067,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['config'],['config']
Modifiability," OFF CACHE BOOL ""Set to ON for a ccache enabled build""); if(LLVM_CCACHE_BUILD); find_program(CCACHE_PROGRAM ccache); if(CCACHE_PROGRAM); set(LLVM_CCACHE_MAXSIZE """" CACHE STRING ""Size of ccache""); set(LLVM_CCACHE_DIR """" CACHE STRING ""Directory to keep ccached data""); set(LLVM_CCACHE_PARAMS ""CCACHE_CPP2=yes CCACHE_HASHDIR=yes""; CACHE STRING ""Parameters to pass through to ccache""). if(NOT CMAKE_SYSTEM_NAME MATCHES ""Windows""); set(CCACHE_PROGRAM ""${LLVM_CCACHE_PARAMS} ${CCACHE_PROGRAM}""); if (LLVM_CCACHE_MAXSIZE); set(CCACHE_PROGRAM ""CCACHE_MAXSIZE=${LLVM_CCACHE_MAXSIZE} ${CCACHE_PROGRAM}""); endif(); if (LLVM_CCACHE_DIR); set(CCACHE_PROGRAM ""CCACHE_DIR=${LLVM_CCACHE_DIR} ${CCACHE_PROGRAM}""); endif(); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_PROGRAM}); else(); if(LLVM_CCACHE_MAXSIZE OR LLVM_CCACHE_DIR OR; NOT LLVM_CCACHE_PARAMS MATCHES ""CCACHE_CPP2=yes CCACHE_HASHDIR=yes""); message(FATAL_ERROR ""Ccache configuration through CMake is not supported on Windows. Please use environment variables.""); endif(); # RULE_LAUNCH_COMPILE should work with Ninja but currently has issues; # with cmd.exe and some MSVC tools other than cl.exe; set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); endif(); else(); message(FATAL_ERROR ""Unable to find the program ccache. Set LLVM_CCACHE_BUILD to OFF""); endif(); endif(). set(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS """" CACHE STRING; ""Optional arguments for the native tool used in CMake --build invocations for external projects.""); mark_as_advanced(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS). option(LLVM_DEPENDENCY_DEBUGGING ""Dependency debugging mode to verify correctly expressed library dependencies (Darwin only)"" OFF). # Some features of the LLVM build may be disallowed when dependency debugging is; # enabled. In particular you cannot use ccache because we want to force compile; # operations to always happen.; if(LLVM_DEPENDENCY_DEBUGGING); if(NOT CMAKE_HOST_APPLE); message(FATAL_ERROR ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:11473,variab,variables,11473,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['variab'],['variables']
Modifiability," Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:11138,variab,variable,11138,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variable']
Modifiability," Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; -------------------------------. Here are some of the CMake variables that are used often, along with a; brief explanation. For full documentation, consult the CMake manual,; or execute ``cmake --help-variable VARIABLE_NAME``. See `Frequently; Used LLVM-related Variables`_ below for information about commonly; used variables that control features of LLVM and enabled subprojects. .. _cmake_build_type:. **CMAKE_BUILD_TYPE**:STRING; This configures the optimization level for ``make`` or ``ninja`` builds. Possible values:. =========================== ============= ========== ========== ==========================; Build Type Optimizations Debug Info Assertions Best suited for; =========================== ============= ========== ========== ==========================; **Release** For Speed No No Users of LLVM and Clang; **Debug** None Yes Yes Developers of LLVM; **RelWithDebInfo** For Speed Yes No Users that also need Debug; **MinSizeRel** For Size No No When disk space matters; =========================== ============= ========== ========== ==========================. * Optimizations make LLVM/Clang run faster, but can be an impediment for; step-by-step debuggin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:6761,variab,variable,6761,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability," Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Oksana Shadura, UNL,\; Arthur Tsang, CERN/SFT, \; Peter van Gemmeren, ANL,\; Vassil Vassilev, Princeton Univ./CMS,\; Xavier Valls Pla, CERN/UJI, \; Wouter Verkerke, NIKHEF/Atlas, RooFit,\; Stefan Wunsch, KIT,\; Omar Zapata. ## General News. This release now supports building with C++17 enabled using either libstdc++ or; libc++. This requires Clang >= 5.0, or GCC >= 7.3.0. At the date of this; release, GCC 7.2.0 still does not provide full support to compile ROOT with C++17. ## Removed interfaces. The following interfaces have been removed, after deprecation in v6.10. - Remove the deprecated `TSelectorCint.h` and `TSelectorCint.cxx`.; - Remove the deprecated `Riosfwd.h` and `Rtypeinfo.h`.; - `TTreeReader::SetLastEntry()` was replaced by `TTreeReader::SetEntriesRange()`. ## Core Libraries. - Added support for XCode 9 and MacOS High Sierra.; - When invoking root with the ""-t"" argument, ROOT enables thread-safety and,; if configured, implicit multithreading within ROOT.; - `NULL` is not defined by `Rtypes.h` anymore. Instead, its definition is expected to be; provided by `Rtype.h`'s `#include` of `stddef.h`.; - ROOT now supports dictionaries, autoload and autoparse for classes with template parameter packs.; - std::make_unique has been backported; - If a class overloads TObject::Hash, this derived class should also add; ```; ROOT::CallRecursiveRemoveIfNeeded(*this); ```; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this; type of object, the transversal of THashList and THashTable containers will; will have to be done without call Hash (and hence be linear rather than; logarithmic complexity). You will also see warnings like; ```; Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; ```; - When a container relies on TObject::H",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:1787,config,configured,1787,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['config'],['configured']
Modifiability," Process and Library Symbols to JITDylibs; ===================================================. JIT'd code may need to access symbols in the host program or in supporting; libraries. The best way to enable this is to reflect these symbols into your; JITDylibs so that they appear the same as any other symbol defined within the; execution session (i.e. they are findable via `ExecutionSession::lookup`, and; so visible to the JIT linker during linking). One way to reflect external symbols is to add them manually using the; absoluteSymbols function:. .. code-block:: c++. const DataLayout &DL = getDataLayout();; MangleAndInterner Mangle(ES, DL);. auto &JD = ES.createJITDylib(""main"");. JD.define(; absoluteSymbols({; { Mangle(""puts""), ExecutorAddr::fromPtr(&puts)},; { Mangle(""gets""), ExecutorAddr::fromPtr(&getS)}; }));. Using absoluteSymbols is reasonable if the set of symbols to be reflected is; small and fixed. On the other hand, if the set of symbols is large or variable; it may make more sense to have the definitions added for you on demand by a; *definition generator*.A definition generator is an object that can be attached; to a JITDylib, receiving a callback whenever a lookup within that JITDylib fails; to find one or more symbols. The definition generator is given a chance to; produce a definition of the missing symbol(s) before the lookup proceeds. ORC provides the ``DynamicLibrarySearchGenerator`` utility for reflecting symbols; from the process (or a specific dynamic library) for you. For example, to reflect; the whole interface of a runtime library:. .. code-block:: c++. const DataLayout &DL = getDataLayout();; auto &JD = ES.createJITDylib(""main"");. if (auto DLSGOrErr =; DynamicLibrarySearchGenerator::Load(""/path/to/lib""; DL.getGlobalPrefix())); JD.addGenerator(std::move(*DLSGOrErr);; else; return DLSGOrErr.takeError();. // IR added to JD can now link against all symbols exported by the library; // at '/path/to/lib'.; CompileLayer.add(JD, loadModule(...));. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:32539,variab,variable,32539,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['variab'],['variable']
Modifiability," Processor register names. The following attributes are associated with low level details, such; as: offsets in the binary file; discriminators added to the lines of; inlined functions in order to distinguish specific instances; debug; lines state machine registers; elements discarded by the compiler; (inlining) or by the linker optimizations (dead-stripping); system; compile units generated by the MS toolchain in PDBs. .. code-block:: text. =discarded: Discarded elements by the linker.; =discriminator: Discriminators for inlined function instances.; =inserted: Generated inlined abstract references.; =linkage: Object file linkage name.; =offset: Debug information offset.; =qualifier: Line qualifiers (Newstatement, BasicBlock, etc).; =zero: Zero line numbers. The following attribute described specific information for the **PE/COFF**; file format. It includes MS runtime types. .. code-block:: text. =system: Display PDB's MS system elements. The above attributes are grouped into *standard* and *extended*; categories that can be enabled. The *standard* group, contains those attributes that add sufficient; information to describe a logical element and that can cover the; normal situations while dealing with debug information. .. code-block:: text. =base; =coverage; =directories; =discriminator; =filename; =files; =format; =level; =producer; =publics; =range; =reference; =zero. The *extended* group, contains those attributes that require a more; extended knowledge about debug information. They are intended when a; lower level of detail is required. .. code-block:: text. =argument; =discarded; =encoded; =gaps; =generated; =global; =inserted; =linkage; =local; =location; =offset; =operation; =pathname; =qualified; =qualifier; =register; =subrange; =system; =typename. .. _print_:. PRINT; ~~~~~; The following options describe the elements to print. The layout used; is determined by the :option:`--report`. In the tree layout, all the; elements have their enclosing lexical scope",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:8271,extend,extended,8271,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['extend'],['extended']
Modifiability," RNTuple data source also supports multi-threaded dataframes, parallelized on the file and cluster level. The data source exposes inner fields of complex collections.; For instance, if the data model contains a vector of `Event` classes, where each `Event` has `pt` and `eta` floats,; the dataframe can use the event vector itself (`Event` column) as well as the `float` columns `Event.pt` and `Event.eta`. ### RClusterPool; The RClusterPool is an internal class owned be a page source.; The cluster pool maintains an I/O thread that asynchronously prefetches the next few clusters.; Through `RPageSource::SetEntryRange()`, the cluster pool is instructed to not read beyond the given limit.; This is used in the RNTuple data source when multiple threads work on different clusters of the same file. ### RMiniFile; The RMiniFile is an internal class used to read and write RNTuple data in a ROOT file.; It provides a minimal subset of the `TFile` functionality.; Its purpose is to reduce the coupling between RNTuple and the ROOT I/O library. For writing data, the RMiniFile can either use a proper `TFile` (descendant) or a C file stream (only for new ROOT files with a single RNTuple).; For reading, the `RMiniFile` always uses an `RRawFile`. ### RRawFile; The RRawFile internal abstract class provides an interface to read byte ranges from a file, including vector reads.; Concrete implementations exist for local files, XRootD and HTTP (the latter two through the ROOT plugin mechanism).; The local file implementation on Linux uses uring for vector reads, if available.; `RRawFileTFile` wraps an existing `TFile` and provides access to the full set of implementations, e.g. `TMemFile`. Tooling; -------. ### RNTupleMerger; The `RNTupleMerger` is an internal class and part of the core RNTuple library.; It concatenates RNTuple data from several sources into a combined sink.; It implements ""fast merging"", i.e. copy-based merging that does not decompress and recompress pages.; The RNTupler merger",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:15661,coupling,coupling,15661,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['coupling'],['coupling']
Modifiability," Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRequirement()); );. The ``createRefactoringActionRule`` function takes in a list of refactoring; action rule requirement values. These values describe the initiation; requirements that have to be satisfied by the refactoring engine before the; provided action rule can be constructed and invoked. The next section; describes how these requirements are evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type must define an; ``evaluate`` member function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:6797,refactor,refactoring,6797,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactoring']
Modifiability," SSA values will replace this call with possibly multiple; calls to `llvm.dbg.value`. Passes that delete stores are effectively partial; promotion, and they will insert a mix of calls to ``llvm.dbg.value`` to track; the source variable value when it is available. After optimization, there may be; multiple calls to ``llvm.dbg.declare`` describing the program points where the; variables lives in memory. All calls for the same concrete source variable must; agree on the memory location. ``llvm.dbg.value``; ^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.value(metadata, metadata, metadata). This intrinsic provides information when a user source variable is set to a new; value. The first argument is the new value (wrapped as metadata). The second; argument is a `local variable <LangRef.html#dilocalvariable>`_ containing a; description of the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a source variable; directly, not its address. Note that the value operand of this intrinsic may; be indirect (i.e, a pointer to the source variable), provided that interpreting; the complex expression derives the direct value. ``llvm.dbg.assign``; ^^^^^^^^^^^^^^^^^^^; .. toctree::; :hidden:. AssignmentTracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression). This intrinsic marks the position in IR where a source assignment occurred. It; encodes the value of the variable. It references the store, if any, that; performs the assignment, and the destination address. The first three arguments are the same as for an ``llvm.dbg.value``. The fourth; argument is a ``DIAssignID`` used to reference a store. The fifth is the; destination of the store (wrapped as metadata), and the sixth is a `complex; expression <LangRef.html#diexpression>`_ that modifies it. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:10671,variab,variable,10671,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability," See the; section `Design Overview`_ for more details. Unless multiple JITDylibs are needed to model linkage relationships, ORCv1; clients should place all code in a single JITDylib.; MCJIT clients should use LLJIT (see `LLJIT and LLLazyJIT`_), and can place; code in LLJIT's default created main JITDylib (See; ``LLJIT::getMainJITDylib()``). 2. All JIT stacks now need an ``ExecutionSession`` instance. ExecutionSession; manages the string pool, error reporting, synchronization, and symbol; lookup. 3. ORCv2 uses uniqued strings (``SymbolStringPtr`` instances) rather than; string values in order to reduce memory overhead and improve lookup; performance. See the subsection `How to manage symbol strings`_. 4. IR layers require ThreadSafeModule instances, rather than; std::unique_ptr<Module>s. ThreadSafeModule is a wrapper that ensures that; Modules that use the same LLVMContext are not accessed concurrently.; See `How to use ThreadSafeModule and ThreadSafeContext`_. 5. Symbol lookup is no longer handled by layers. Instead, there is a; ``lookup`` method on JITDylib that takes a list of JITDylibs to scan. .. code-block:: c++. ExecutionSession ES;; JITDylib &JD1 = ...;; JITDylib &JD2 = ...;. auto Sym = ES.lookup({&JD1, &JD2}, ES.intern(""_main""));. 6. The removeModule/removeObject methods are replaced by; ``ResourceTracker::remove``.; See the subsection `How to remove code`_. For code examples and suggestions of how to use the ORCv2 APIs, please see; the section `How-tos`_. How-tos; =======. How to manage symbol strings; ----------------------------. Symbol strings in ORC are uniqued to improve lookup performance, reduce memory; overhead, and allow symbol names to function as efficient keys. To get the; unique ``SymbolStringPtr`` for a string value, call the; ``ExecutionSession::intern`` method:. .. code-block:: c++. ExecutionSession ES;; /// ...; auto MainSymbolName = ES.intern(""main"");. If you wish to perform lookup using the C/IR name of a symbol you will also; need to app",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:21483,layers,layers,21483,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['layers'],['layers']
Modifiability," Sort each ``#include`` block separately. .. code-block:: c++. #include ""b.h"" into #include ""b.h"". #include <lib/main.h> #include ""a.h""; #include ""a.h"" #include <lib/main.h>. * ``IBS_Merge`` (in configuration: ``Merge``); Merge multiple ``#include`` blocks together and sort as one. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h> #include <lib/main.h>; #include ""a.h"". * ``IBS_Regroup`` (in configuration: ``Regroup``); Merge multiple ``#include`` blocks together and sort as one.; Then split into groups based on category priority. See; ``IncludeCategories``. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h>; #include ""a.h"" #include <lib/main.h>. .. _IncludeCategories:. **IncludeCategories** (``List of IncludeCategories``) :versionbadge:`clang-format 3.8` :ref:`¶ <IncludeCategories>`; Regular expressions denoting the different ``#include`` categories; used for ordering ``#includes``. `POSIX extended; <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>`_; regular expressions are supported. These regular expressions are matched against the filename of an include; (including the <> or """") in order. The value belonging to the first; matching regular expression is assigned and ``#includes`` are sorted first; according to increasing category number and then alphabetically within; each category. If none of the regular expressions match, INT_MAX is assigned as; category. The main header for a source file automatically gets category 0.; so that it is generally kept at the beginning of the ``#includes``; (https://llvm.org/docs/CodingStandards.html#include-style). However, you; can also assign negative priorities if you have certain headers that; always need to be first. There is a third and optional field ``SortPriority`` which can used while; ``IncludeBlocks = IBS_Regroup`` to define the priority in which; ``#includes`` should be ordered. The value of ``Priority`` d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:66390,extend,extended,66390,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['extend'],['extended']
Modifiability," Superclasses: GlobalValue_, Constant_, User_, Value_. Global variables are represented with the (surprise surprise) ``GlobalVariable``; class. Like functions, ``GlobalVariable``\ s are also subclasses of; GlobalValue_, and as such are always referenced by their address (global values; must live in memory, so their ""name"" refers to their constant address). See; GlobalValue_ for more on this. Global variables may have an initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:159601,variab,variable,159601,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability," T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadge:`clang-format 16` :ref:`¶ <RequiresExpressionIndentation>`; The indentation used for requires expression bodies. Possible values:. * ``REI_OuterScope`` (in configuration: ``OuterScope``); Align requires expression body relative to the indentation level of the; outer scope the requires expression resides in.; This is the default. .. code-block:: c++. template <typename T>; concept C = requires(T t) {; ...; }. * ``REI_Keyword`` (in configuration: ``Keyword``); Align requires expression body relative to the ``requires`` keyword. .. code-block:: c++. template <typename T>; concept C = requires(T t) {; ...; }. .. _SeparateDefinitionBlocks:. **SeparateDefinitionBlocks** (``SeparateDefinitionStyle``) :versionbadge:`clang-format 14` :ref:`¶ <SeparateDefinitionBlocks>`; Specifies the use of empty lines to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private:; } int t;; enum List {; ITEM1, int method1() {; ITEM2 // ...; }; }; template<typename T>; int method2(T x) { enum List {; // ... ITEM1,; } ITEM2; int i, j, k; };; int method3(int par) {; // ... template<typename T>; } int method2(T x) {; }; // ...; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:106696,config,configuration,106696,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," TMVA version 4.0.4 is included in this root release. Methods. A new Category method allowing the user to; separate the training data (and accordingly the application; data) into disjoint sub-populations exhibiting significantly; different properties. The separation into phase space regions is; done by applying requirements on the input and/or spectator; variables. In each of these disjoint regions (each event must; belong to one and only one region), an independent training is; performed using the most appropriate MVA method, training; options and set of training variables in that zone. The division; into categories in presence of distinct sub-populations reduces; the correlations between the training variables, improves the; modelling, and hence increases the classification and regression; performance. Presently, the Category method works for; classification only, but regression will follow soon. Please; contact us if urgently needed. An example scripts and data files illustrating how the new; Category method is configured and used. Please check the macros; test/TMVAClassificationCategory.C and; test/TMVAClassificationCategoryApplication.C or the; corresponding executables.; Regression functionality for gradient boosted trees using a Huber loss function. Comments. On Input Data: . New TMVA event vector building. The code for splitting the input; data into training and test samples for all classes and the; mixing of those samples to one training and one test sample has; been rewritten completely. The new code is more performant and; has a clearer structure. This fixes several bugs which have been; reported by the TMVA users. On Minimization: . Variables, targets and spectators are now checked if they are; constant. (The execution of TMVA is stopped for variables and; targets, a warning is given for spectators.). On Regression:; ; The analysis type is no longer defined by calling a dedicated; TestAllMethods-member-function of the Factory, but with the; option ""Analy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html:1037,config,configured,1037,tmva/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html,1,['config'],['configured']
Modifiability," TProof::AddInputData(TObject *); if the input-data objects are in a; file you can use TProof::SetInputDataFile(const char *file); the final; set of input-data objects is assembled from the objects added via; AddInputData and those found in the file defined bySetInputDataFile.  . Improvements:. More; complete set of tests in test/stressProof . To run with PROOF-Lite pass; the argument 'lite' as master URL, e.g. './stressProof lite'.Possibility; to control on the client via rc variable the location of the sandbox,; package directory, cache and dataset directory (the latters two only; for PROOF-Lite); the variable names are 'Proof.Sandbox', ; 'Proof.PackageDir', 'Proof.CacheDir' and 'Proof.DataSetDir'. The default location of the sandbox has been changed from ""~/proof"" to ""~/.proof"" to avoid interferences with possible users' working areas.XrdProofd plug-in. Overall refactorization for easier; maintainance and improved solidity; Improved format of printout messages: all information; messages contain now the tag 'xpd-I' and all error messages the; tag 'xpd-E', so that they can easily be grepped out from the; log file.; . Log sending. Implement selective sending of logs from workers to master to avoid duplicating; too many text lines on the master log. Logs are now sent only after Exec, Print; requests and in case an error (level >= kError) occured. Of course, the full; logs can always be retrieved via TProofMgr::GetSessionLogs; . Log retrieval:. for 'grep' operations, use the system 'grep' command; via 'popen'; instead of a handmade filtering; this implies that the full grep; functionality is now available; set the default number of displayed lines to 100; instead of 10. Improve diagnostic in case of worker death: clients will; now; receive a message containing the low level reason for the failure and a; hint for getting more informationIn; TProofOutputFile, support the ""<user>"" and ""<group>""; placeholders in the output file name to automatically re-direct the; output ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:4489,refactor,refactorization,4489,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['refactor'],['refactorization']
Modifiability," TableGen source files by the; TableGen parser. Note that the term *class* refers to an abstract record; class, while the term *record* refers to a concrete record. Unless otherwise noted, functions associated with classes are instance; functions. ``RecordKeeper``; ----------------. An instance of the ``RecordKeeper`` class acts as the container for all the; classes and records parsed and collected by TableGen. The ``RecordKeeper``; instance is passed to the backend when it is invoked by TableGen. This class; is usually abbreviated ``RK``. There are two maps in the recordkeeper, one for classes and one for records; (the latter often referred to as *defs*). Each map maps the class or record; name to an instance of the ``Record`` class (see `Record`_), which contains; all the information about that class or record. In addition to the two maps, the ``RecordKeeper`` instance contains:. * A map that maps the names of global variables to their values.; Global variables are defined in TableGen files with outer; ``defvar`` statements. * A counter for naming anonymous records. The ``RecordKeeper`` class provides a few useful functions. * Functions to get the complete class and record maps. * Functions to get a subset of the records based on their parent classes. * Functions to get individual classes, records, and globals, by name. A ``RecordKeeper`` instance can be printed to an output stream with the ``<<``; operator. ``Record``; ----------. Each class or record built by TableGen is represented by an instance of; the ``Record`` class. The ``RecordKeeper`` instance contains one map for the; classes and one for the records. The primary data members of a record are; the record name, the vector of field names and their values, and the vector of; superclasses of the record. The record name is stored as a pointer to an ``Init`` (see `Init`_), which; is a class whose instances hold TableGen values (sometimes referred to as; *initializers*). The field names and values are stored in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:2509,variab,variables,2509,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['variab'],['variables']
Modifiability," TableGenFile: (`Statement` | `IncludeDirective`; :| `PreprocessorDirective`)*; Statement: `Assert` | `Class` | `Def` | `Defm` | `Defset` | `Defvar`; :| `Dump` | `Foreach` | `If` | `Let` | `MultiClass`. The following sections describe each of these top-level statements. ``class`` --- define an abstract record class; ---------------------------------------------. A ``class`` statement defines an abstract record class from which other; classes and records can inherit. .. productionlist::; Class: ""class"" `ClassID` [`TemplateArgList`] `RecordBody`; TemplateArgList: ""<"" `TemplateArgDecl` ("","" `TemplateArgDecl`)* "">""; TemplateArgDecl: `Type` `TokIdentifier` [""="" `Value`]. A class can be parameterized by a list of ""template arguments,"" whose values; can be used in the class's record body. These template arguments are; specified each time the class is inherited by another class or record. If a template argument is not assigned a default value with ``=``, it is; uninitialized (has the ""value"" ``?``) and must be specified in the template; argument list when the class is inherited (required argument). If an; argument is assigned a default value, then it need not be specified in the; argument list (optional argument). In the declaration, all required template; arguments must precede any optional arguments. The template argument default; values are evaluated from left to right. The :token:`RecordBody` is defined below. It can include a list of; parent classes from which the current class inherits, along with field; definitions and other statements. When a class ``C`` inherits from another; class ``D``, the fields of ``D`` are effectively merged into the fields of; ``C``. A given class can only be defined once. A ``class`` statement is; considered to define the class if *any* of the following are true (the; :token:`RecordBody` elements are described below). * The :token:`TemplateArgList` is present, or; * The :token:`ParentClassList` in the :token:`RecordBody` is present, or; * T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:22434,inherit,inherited,22434,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherited']
Modifiability," Tests are identified by the test suite they are contained within, and the; relative path inside that suite. Note that the relative path may not refer to; an actual file on disk; some test formats (such as *GoogleTest*) define; ""virtual tests"" which have a path that contains both the path to the actual; test file and a subpath to identify the virtual test. .. _local-configuration-files:. LOCAL CONFIGURATION FILES; ~~~~~~~~~~~~~~~~~~~~~~~~~. When :program:`lit` loads a subdirectory in a test suite, it instantiates a; local test configuration by cloning the configuration for the parent directory; --- the root of this configuration chain will always be a test suite. Once the; test configuration is cloned :program:`lit` checks for a *lit.local.cfg* file; in the subdirectory. If present, this file will be loaded and can be used to; specialize the configuration for each individual directory. This facility can; be used to define subdirectories of optional tests, or to change other; configuration parameters --- for example, to change the test format, or the; suffixes which identify test files. SUBSTITUTIONS; ~~~~~~~~~~~~~. :program:`lit` allows patterns to be substituted inside RUN commands. It also; provides the following base set of substitutions, which are defined in; TestRunner.py:. ======================= ==============; Macro Substitution; ======================= ==============; %s source path (path to the file currently being run); %S source dir (directory of the file currently being run); %p same as %S; %{pathsep} path separator; %{fs-src-root} root component of file system paths pointing to the LLVM checkout; %{fs-tmp-root} root component of file system paths pointing to the test's temporary directory; %{fs-sep} file system path separator; %t temporary file name unique to the test; %basename_t The last path component of %t but without the ``.tmp`` extension; %T parent directory of %t (not unique, deprecated, do not use); %% %; %/s %s but ``\`` is replaced by ``/``;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:18820,config,configuration,18820,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['configuration']
Modifiability," The CoreCLR GC; -------------------------. .. code-block:: c++. F.setGC(""coreclr"");. This GC leverages the ``gc.statepoint`` mechanism to support the; `CoreCLR <https://github.com/dotnet/coreclr>`__ runtime. Support for this GC strategy is a work in progress. This strategy will; differ from; :ref:`statepoint-example GC<statepoint_example_gc>` strategy in; certain aspects like:. * Base-pointers of interior pointers are not explicitly; tracked and reported. * A different format is used for encoding stack maps. * Safe-point polls are only needed before loop-back edges; and before tail-calls (not needed at function-entry). Custom GC Strategies; ====================. If none of the built in GC strategy descriptions met your needs above, you will; need to define a custom GCStrategy and possibly, a custom LLVM pass to perform; lowering. Your best example of where to start defining a custom GCStrategy; would be to look at one of the built in strategies. You may be able to structure this additional code as a loadable plugin library.; Loadable plugins are sufficient if all you need is to enable a different; combination of built in functionality, but if you need to provide a custom; lowering pass, you will need to build a patched version of LLVM. If you think; you need a patched build, please ask for advice on llvm-dev. There may be an; easy way we can extend the support to make it work for your use case without; requiring a custom build. Collector Requirements; ----------------------. You should be able to leverage any existing collector library that includes the following elements:. #. A memory allocator which exposes an allocation function your compiled; code can call. #. A binary format for the stack map. A stack map describes the location; of references at a safepoint and is used by precise collectors to identify; references within a stack frame on the machine stack. Note that collectors; which conservatively scan the stack don't require such a structure. #. A stack craw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:21908,plugin,plugin,21908,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability," The central part of a class are its members. Some are available to you; some; are hidden from you, because they are only meant to be used internally.; As an example, a class might allow you to set, access, and print its values, or store; them into a file.; Because methods should have reasonable names, often the method name itself is already; a hint on what it does.; If you want to get a TNamed's; name, you will immediately see TNamed::GetName() in its list of functions.; A click on this name will send you to the documentation for the method.; If you enabled the display of inherited members you will see; some members with a class name prefix. It tells you where this method has been defined.; Display Options; The info box contains options that influence how; the list of members is displayed: you can e.g. show or hide non-public methods. If you; just want to use ROOT you should hide them - you cannot access protected or private; members anyway. And you can select whether member that are inherited from a base class; should be shown. Again, if you just want to use ROOT you should probably show them,; as you often want to use them whether they are defined in the current class or in one; of its base classes. Whatever you set these options to should be stored in a cookie,; so you will have the same setting next time you look at the class documentation. Access (public / protected / private); Not all members are available to everyone (check any C++ introduction to learn why).; Public members have a green bar on their left, protected ones have a yellow one, and; private members are marked with a red bar. Of course you won't see any protected or; private members if you hide them in the display options. Inheritance; You can often access members of a class's base classes, just as if they are defined; in the derived class. A histogram,; for example, has a name, and you can access it using GetName() as defined in its base; class TNamed. If you want to see; all available members, an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:5700,inherit,inherited,5700,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,1,['inherit'],['inherited']
Modifiability," The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:32981,config,configuration,32981,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability," The emit method; applies our transform to each module that it is called on and, if the transform; succeeds, passes the transformed module to the base layer. If the transform; fails, our emit function calls; ``MaterializationResponsibility::failMaterialization`` (this JIT clients who; may be waiting on other threads know that the code they were waiting for has; failed to compile) and logs the error with the execution session before bailing; out. The other half of the IRLayer interface we inherit unmodified from the IRLayer; class:. .. code-block:: c++. Error IRLayer::add(JITDylib &JD, ThreadSafeModule TSM, VModuleKey K) {; return JD.define(std::make_unique<BasicIRLayerMaterializationUnit>(; *this, std::move(K), std::move(TSM)));; }. This code, from ``llvm/lib/ExecutionEngine/Orc/Layer.cpp``, adds a; ThreadSafeModule to a given JITDylib by wrapping it up in a; ``MaterializationUnit`` (in this case a ``BasicIRLayerMaterializationUnit``).; Most layers that derived from IRLayer can rely on this default implementation; of the ``add`` method. These two operations, ``add`` and ``emit``, together constitute the layer; concept: A layer is a way to wrap a part of a compiler pipeline (in this case; the ""opt"" phase of an LLVM compiler) whose API is opaque to ORC with an; interface that ORC can call as needed. The add method takes an; module in some input program representation (in this case an LLVM IR module); and stores it in the target ``JITDylib``, arranging for it to be passed back; to the layer's emit method when any symbol defined by that module is requested.; Each layer can complete its own work by calling the ``emit`` method of its base; layer. For example, in this tutorial our IRTransformLayer calls through to; our IRCompileLayer to compile the transformed IR, and our IRCompileLayer in; turn calls our ObjectLayer to link the object file produced by our compiler. So far we have learned how to optimize and compile our LLVM IR, but we have; not focused on when compilation ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:9420,layers,layers,9420,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['layers'],['layers']
Modifiability," The following is a list of acronyms considered sufficiently useful that the; benefit of using them outweighs the cost of learning them. Acronyms that are; either not on the list or are used to refer to a different type should be; expanded. ============================ =============; Class name Variable name; ============================ =============; DeterministicFiniteAutomaton dfa; DominatorTree dt; LoopInfo li; MachineFunction mf; MachineInstr mi; MachineRegisterInfo mri; ScalarEvolution se; TargetInstrInfo tii; TargetLibraryInfo tli; TargetRegisterInfo tri; ============================ =============. In some cases renaming acronyms to the full type name will result in overly; verbose code. Unlike most classes, a variable's scope is limited and therefore; some of its purpose can implied from that scope, meaning that fewer words are; necessary to give it a clear name. For example, in an optimization pass the reader; can assume that a variable's purpose relates to optimization and therefore an; ``OptimizationRemarkEmitter`` variable could be given the name ``remarkEmitter``; or even ``remarker``. The following is a list of longer class names and the associated shorter; variable name. ========================= =============; Class name Variable name; ========================= =============; BasicBlock block; ConstantExpr expr; ExecutionEngine engine; MachineOperand operand; OptimizationRemarkEmitter remarker; PreservedAnalyses analyses; PreservedAnalysesChecker checker; TargetLowering lowering; TargetMachine machine; ========================= =============. Transition Options; ==================. There are three main options for transitioning:. 1. Keep the current coding standard; 2. Laissez faire; 3. Big bang. Keep the current coding standard; --------------------------------. Proponents of keeping the current coding standard (i.e. not transitioning at; all) question whether the cost of transition outweighs the benefit; [EmersonConcern]_ [ReamesConcern]_ [Bradbur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:6674,variab,variable,6674,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,2,['variab'],['variable']
Modifiability," The new APIs (including new layer interfaces and; implementations, and new utilities) that support concurrency are collectively; referred to as ORCv2, and the original, non-concurrent layers and utilities; are now referred to as ORCv1. The majority of the ORCv1 layers and utilities were renamed with a 'Legacy'; prefix in LLVM 8.0, and have deprecation warnings attached in LLVM 9.0. In LLVM; 12.0 ORCv1 will be removed entirely. Transitioning from ORCv1 to ORCv2 should be easy for most clients. Most of the; ORCv1 layers and utilities have ORCv2 counterparts [2]_ that can be directly; substituted. However there are some design differences between ORCv1 and ORCv2; to be aware of:. 1. ORCv2 fully adopts the JIT-as-linker model that began with MCJIT. Modules; (and other program representations, e.g. Object Files) are no longer added; directly to JIT classes or layers. Instead, they are added to ``JITDylib``; instances *by* layers. The ``JITDylib`` determines *where* the definitions; reside, the layers determine *how* the definitions will be compiled.; Linkage relationships between ``JITDylibs`` determine how inter-module; references are resolved, and symbol resolvers are no longer used. See the; section `Design Overview`_ for more details. Unless multiple JITDylibs are needed to model linkage relationships, ORCv1; clients should place all code in a single JITDylib.; MCJIT clients should use LLJIT (see `LLJIT and LLLazyJIT`_), and can place; code in LLJIT's default created main JITDylib (See; ``LLJIT::getMainJITDylib()``). 2. All JIT stacks now need an ``ExecutionSession`` instance. ExecutionSession; manages the string pool, error reporting, synchronization, and symbol; lookup. 3. ORCv2 uses uniqued strings (``SymbolStringPtr`` instances) rather than; string values in order to reduce memory overhead and improve lookup; performance. See the subsection `How to manage symbol strings`_. 4. IR layers require ThreadSafeModule instances, rather than; std::unique_ptr<Module>s. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:20272,layers,layers,20272,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['layers'],['layers']
Modifiability," The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". The result produced is a floating point value truncated to be smaller in size; than the operand. '``llvm.experimental.constrained.fpext``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <ty2>; @llvm.experimental.constrained.fpext(<type> <value>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.fpext``' intrinsic extends a; floating-point ``value`` to a larger floating-point value. Arguments:; """""""""""""""""""". The first argument to the '``llvm.experimental.constrained.fpext``'; intrinsic must be :ref:`floating point <t_floating>` or :ref:`vector; <t_vector>` of floating point values. This argument must be smaller in size; than the result. The second argument specifies the exception behavior as described above. Semantics:; """""""""""""""""""". The result produced is a floating point value extended to be larger in size; than the operand. All restrictions that apply to the fpext instruction also; apply to this intrinsic. '``llvm.experimental.constrained.fcmp``' and '``llvm.experimental.constrained.fcmps``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <ty2>; @llvm.experimental.constrained.fcmp(<type> <op1>, <type> <op2>,; metadata <condition code>,; metadata <exception behavior>); declare <ty2>; @llvm.experimental.constrained.fcmps(<type> <op1>, <type> <op2>,; metadata <condition code>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.fcmp``' and; '``llvm.experimental.constrained.fcmps``' intrinsics return a boolean; value or vector of boolean values based on comparison of its operands. If the operands are floating-point scalars, then the result type is a; boolean (:ref:`i1 <t_integer>`). If the operands are floating-point vectors, then ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:882826,extend,extended,882826,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extended']
Modifiability," There must be some limit to the width of the code in; order to allow developers to have multiple files side-by-side in; windows on a modest display. If you are going to pick a width limit, it is; somewhat arbitrary but you might as well pick something standard. Going with 90; columns (for example) instead of 80 columns wouldn't add any significant value; and would be detrimental to printing out code. Also many other projects have; standardized on 80 columns, so some people have already configured their editors; for it (vs something else, like 90 columns). Whitespace; ^^^^^^^^^^. In all cases, prefer spaces to tabs in source files. People have different; preferred indentation levels, and different styles of indentation that they; like; this is fine. What isn't fine is that different editors/viewers expand; tabs out to different tab stops. This can cause your code to look completely; unreadable, and it is not worth dealing with. As always, follow the `Golden Rule`_ above: follow the style of existing code; if you are modifying and extending it. Do not add trailing whitespace. Some common editors will automatically remove; trailing whitespace when saving a file which causes unrelated changes to appear; in diffs and commits. Format Lambdas Like Blocks Of Code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". When formatting a multi-line lambda, format it like a block of code. If there; is only one multi-line lambda in a statement, and there are no expressions; lexically after it in the statement, drop the indent to the standard two space; indent for a block of code, as if it were an if-block opened by the preceding; part of the statement:. .. code-block:: c++. std::sort(foo.begin(), foo.end(), [&](Foo a, Foo b) -> bool {; if (a.blah < b.blah); return true;; if (a.baz < b.baz); return true;; return a.bam < b.bam;; });. To take best advantage of this formatting, if you are designing an API which; accepts a continuation or single callable argument (be it a function object, or; a ``std",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:18639,extend,extending,18639,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['extend'],['extending']
Modifiability," This document; describes the high level goals of the project, the guiding principles, as well; as some idiosyncrasies of the HLSL language and how we intend to support them in; Clang. Project Goals; =============. The long term goal of this project is to enable Clang to function as a; replacement for the `DirectXShaderCompiler (DXC); <https://github.com/microsoft/DirectXShaderCompiler/>`_ in all its supported; use cases. Accomplishing that goal will require Clang to be able to process most; existing HLSL programs with a high degree of source compatibility. Non-Goals; ---------. HLSL ASTs do not need to be compatible between DXC and Clang. We do not expect; identical code generation or that features will resemble DXC's implementation or; architecture. In fact, we explicitly expect to deviate from DXC's implementation; in key ways. Guiding Principles; ==================. This document lacks details for architectural decisions that are not yet; finalized. Our top priorities are quality, maintainability, and flexibility. In; accordance with community standards we are expecting a high level of test; coverage, and we will engineer our solutions with long term maintenance in mind.; We are also working to limit modifications to the Clang C++ code paths and; share as much functionality as possible. Architectural Direction; =======================. HLSL support in Clang is expressed as C++ minus unsupported C and C++ features.; This is different from how other Clang languages are implemented. Most languages; in Clang are additive on top of C. HLSL is not a formally or fully specified language, and while our goals require; a high level of source compatibility, implementations can vary and we have some; flexibility to be more or less permissive in some cases. For modern HLSL DXC is; the reference implementation. The HLSL effort prioritizes following similar patterns for other languages,; drivers, runtimes and targets. Specifically, We will maintain separation between; HSLS-spe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:1157,maintainab,maintainability,1157,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,1,['maintainab'],['maintainability']
Modifiability," This new default integrator has much improved stability and speed; for relatively smooth p.d.f.s in two or three dimensions and can; generally be used well for p.d.f. normalization integrals without; causing MINUIT converge problems due to numeric precision issues. In future release some more numeric integrators will be migrated to; a MathCore implementation. Interface to TFoam adaptive MC sampler added; RooFit can now use the TFoam adaptive MC sampler for event generation of p.d.f.s that; do not have an internal generator. The TFoam generator adaptively subdivides the; observable space and is generally more efficient both warmup and generation than the original; RooAcceptReject algorithm. In its current interface in RooFit, TFoam cannot; handle problems yet with discrete observables or conditional observables. For those problems; the original RooAcceptReject generator is still used. The choice of MC sampling algorithm can be steered through class RooNumGenConfig, which; is similar in style and structure, to RooNumIntConfig which configures the choice of; numeric integration algorithm. A new tutorial macro rf902_numgenconfig.C has been added to $ROOTSYS/tutorials/roofit; to illustrate the use of the steering. A macro that demonstrates of the power of these newly interface numeric algorithms is provided at the; end of the RooFit section of the release notes. Optional persistent caching of numeric integrals; For p.d.f.s with numeric integrals that remain difficult or very time consuming,; a new persistent caching technique is now available that allows to precalculate; these integrals and store their values for future use. This technique works transparently; for any p.d.f. stored in a RooWorkspace. One can store numeric integral values for problems with zero, one or two floating parameters.; In the first case, the value is simply stored. In cases with one or two floating parameters; a grid (histogram) of integral values is stored, which are interpolated to return inte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:5932,config,configures,5932,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['config'],['configures']
Modifiability," This section; includes best practices and some recommendations as to how to achieve; that end. The goal; In 2020, the monorepo had just under 35 thousand commits. This works; out to an average of 4 commits per hour. Already, we can see that a; builder must cycle in less than 15 minutes to have a hope of being; useful. However, those commits are not uniformly distributed. They; tend to cluster strongly during US working hours. Looking at a couple; of recent (Nov 2021) working days, we routinely see ~10 commits per; hour during peek times, with occasional spikes as high as ~15 commits; per hour. Thus, as a rule of thumb, we should plan for our builder to; complete ~10-15 builds an hour. Resource Appropriately; At 10-15 builds per hour, we need to complete a new build on average every; 4 to 6 minutes. For anything except the fastest of hardware/build configs,; this is going to be well beyond the ability of a single machine. In buildbot; terms, we likely going to need multiple workers to build requests in parallel; under a single builder configuration. For some rough back of the envelope; numbers, if your build config takes e.g. 30 minutes, you will need something; on the order of 5-8 workers. If your build config takes ~2 hours, you'll; need something on the order of 20-30 workers. The rest of this section; focuses on how to reduce cycle times. Restrict what you build and test; Think hard about why you're setting up a bot, and restrict your build; configuration as much as you can. Basic functionality is probably; already covered by other bots, and you don't need to duplicate that; testing. You only need to be building and testing the *unique* parts; of the configuration. (e.g. For a multi-stage clang builder, you probably; don't need to be enabling every target or building all the various utilities.). It can sometimes be worthwhile splitting a single builder into two or more,; if you have multiple distinct purposes for the same builder. As an example,; if you want to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:9041,config,configuration,9041,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['configuration']
Modifiability," To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:4013,refactor,refactorings,4013,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactorings']
Modifiability," To set an alphanumeric bin label call:. ``` {.cpp}; TAxis::SetBinLabel(bin,label);; ```. This can always be done before or after filling. Bin labels will be; automatically drawn with the histogram. ![Histograms with alphanumeric bin labels](pictures/0600003B.png). See example in `$ROOTSYS/tutorials/hist/hlabels1.C` , `hlabels2.C`. ### Option 2: Fill. You can also call a `Fill()` function with one of the arguments being; a string:. ``` {.cpp}; hist1->Fill(somename,weigth);; hist2->Fill(x,somename,weight);; hist2->Fill(somename,y,weight);; hist2->Fill(somenamex,somenamey,weight);; ```. ### Option 3: TTree::Draw. You can use a char\* variable type to histogram strings with; **`TTree`**`::Draw()`. ``` {.cpp}; // here ""Nation"" and ""Division"" are two char* branches of a Tree; tree.Draw(""Nation::Division"", """", ""text"");; ```. ![Using a \*char variable type in TTree::Draw](pictures/0200003C.png). There is an example in `$ROOTSYS/tutorials/tree/cernstaff.C.`. If a variable is defined as `char*` it is drawn as a string by default.; You change that and draw the value of `char[0]` as an integer by; adding an arithmetic operation to the expression as shown below. ``` {.cpp}; // draw the integer value of MyChar[0] where ""MyChar"" is char[5]; tree.Draw(""MyChar + 0"");; ```. ### Sort Options. When using the options 2 or 3 above, the labels are automatically; added to the list (**`THashList`**) of labels for a given axis. By; default, an axis is drawn with the order of bins corresponding to the; filling sequence. It is possible to reorder the axis alphabetically or; by increasing or decreasing values. The reordering can be triggered; via the **`TAxis`** context menu by selecting the menu item; ""`LabelsOption` "" or by calling directly. ``` {.cpp}; TH1::LabelsOption(option,axis);; ```. Here `axis` may be X, Y, or Z. The parameter `option` may be:. - ""`a`"" sort by alphabetic order; - ""`>`"" sort by decreasing values; - ""`<`"" sort by increasing values; - ""`h`"" draw labels horizontal; - ""`v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:57216,variab,variable,57216,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variable']
Modifiability, Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initialization?; Unknown. 1490; CD4; List-initialization from a string literal; Clang 3.7 (C++11 onwards). 1491; CD3; Move construction and rvalue reference members; Unknown. 1492; CD4; Exception specifications on template destructors; Unknown. 1493; C++14; Criteria for move-construction; Unknown. 1494; CD3; Temporary initialization for reference binding in list-initialization; Unknown. 1495; CD3; Partial specialization of variadic class template; Clang 4. 1496; CD4; Triviality with deleted and missing default constructors; No. 1497; NAD; Aggregate initialization with parenthesized string literal; Unknown. 1498; dup; Lifetime of temporaries in range-based for; Unknown. 1499; drafting; Missing case for deleted move assignment operator; Not resolved. 1500; CD6; Name lookup of dependent conversion function; Unknown. 1501; NAD; Nested,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:99911,inherit,inheriting,99911,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inherit'],['inheriting']
Modifiability," Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost. NegWeightTreatment No InverseBoostNegWeights InverseBoostNegWeights, IgnoreNegWeightsInTraining, PairNegWeightsGlobal, Pray How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining; Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!). NodePurityLimit No 0.5 − In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise. SeparationType No GiniIndex CrossEntropy, GiniIndex, GiniIndexWithLaplace, MisClassificationError, SDivSqrtSPlusB, RegressionVariance Separation criterion for node splitting. DoBoostMonitor No False − Create control plot with ROC integral vs tree number. UseFisherCuts No False − Use multivariate splits using the Fisher criterion. MinLinCorrForFisher No 0.8 − The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting. UseExclusiveVars No False − Variables already used in fisher criterion are not anymore analysed individually for node splitting. DoPreselection No False − and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training. RenormByClass No False − Individually re-normalize each event class to the original size after boosting. SigToBkgFraction No 1 − Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost. PruneMethod No NoPruning NoPruning, ExpectedError, CostComplexity Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning: Pruning: Method used for pruning (removal) of statistically insignificant branches . PruneStrength No 0 − Pruning strength. PruningValFraction No 0.5 − Fraction of events to use for optimizing automatic pruning. nEventsMin No 0 − deprecated: Use MinNodeSize (in % of training events) instead. GradBaggingFraction No 0.6 − deprecated: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:14231,variab,variables,14231,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variables']
Modifiability," Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). FitMethod No GA GA, SA, MC, MCEvents, MINUIT, EventScan Minimisation Method (GA, SA, and MC are the primary methods to be used; the others have been introduced for testing purposes and are depreciated). EffMethod No EffSel EffSel, EffPDF Selection Method. CutRangeMin Yes -1 − Minimum of allowed cut range (set per variable). CutRangeMax Yes -1 − Maximum of allowed cut range (set per variable). VarProp Yes NotEnforced NotEnforced, FMax, FMin, FSmart Categorisation of cuts. Configuration options for MVA method :. Configuration options reference for MVA method: PDEFoam. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:25539,variab,variable,25539,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variable']
Modifiability," Villanueva, CERN/SFT,\; Olivier Couet, CERN/SFT,\; Alexandra Dobrescu, CERN/SFT,\; Giulio Eulisse, CERN/ALICE,\; Gerri Ganis, CERN/SFT,\; Andrei Gheata, CERN/SFT,\; Enrico Guiraud, CERN/SFT,\; Stephan Hageboeck, CERN/SFT,\; Jan Knedlik, GSI,\; Sergey Linev, GSI,\; Pere Mato, CERN/SFT,\; Lorenzo Moneta, CERN/SFT,\; Alja Mrak-Tadel, UCSD/CMS,\; Axel Naumann, CERN/SFT,\; Vincenzo Eduardo Padulano, Bicocca/SFT,\; Danilo Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Henry Schreiner, Princeton,\; Oksana Shadura, Nebraska,\; Simon Spies, GSI,\; Yuka Takahashi, Princeton and CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Matevz Tadel, UCSD/CMS,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/Atlas,\; Zhe Zhang, Nebraska,\; Stefan Wunsch, CERN/SFT. ## Deprecation and Removal. ### Deprecated packages. The Virtual Monte Carlo (VMC) interfaces have been deprecated for this release; and will be removed in a future release. It is no longer built by default, but; can still be enabled with the option `-Dvmc=ON` in the CMake configuration phase.; A standalone version of VMC is being developed at [https://github.com/vmc-project/vmc](https://github.com/vmc-project/vmc); to replace the deprecated version in ROOT. ### Removed packages. Support for the following optional components of ROOT has been removed:. * afdsmgrd (Dataset manager for PROOF-based analysis facilities); * bonjour (Avahi/Bonjour/Zeroconf); * castor (CERN Advanced STORage manager); * geocad (OpenCascade); * globus (Globus authentication); * hdfs (Hadoop Distributed File System); * krb5 (Kerberos 5 authentication); * ldap (OpenLDAP authentication); * memstat (legacy memory statistics utility); * qt, qtgsi, qtroot (Qt4-based GUI components); * rfio (Remote File IO for CASTOR); * table (libTable contrib library). In addition, the following deprecated parts of ROOT components have been; removed:. * PROOF's PQ2 module; * `THttpServer::ExecuteHttp()` and `THttpServer::SubmitHttp` from `THttpServer`. ### Other ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:1554,config,configuration,1554,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['config'],['configuration']
Modifiability," When threads diverge at a divergent; branch, they may later *reconverge* at a common program point.; Subsequent operations are performed convergently, but the inputs may; be non-uniform, thus producing divergent outputs. Uniformity is also useful by itself on targets that execute threads in; groups with shared execution resources (e.g. waves, warps, or; subgroups):. - Uniform outputs can potentially be computed or stored on shared; resources.; - These targets must ""linearize"" a divergent branch to ensure that; each side of the branch is followed by the corresponding threads in; the same group. But linearization is unnecessary at uniform; branches, since the whole group of threads follows either one side; of the branch or the other. This document presents a definition of convergence that is reasonable; for real targets and is compatible with the currently implicit; semantics of convergent operations in LLVM IR. This is accompanied by; a *uniformity analysis* that extends previous work on divergence analysis; [DivergenceSPMD]_ to cover irreducible control-flow. .. [DivergenceSPMD] Julian Rosemann, Simon Moll, and Sebastian; Hack. 2021. An Abstract Interpretation for SPMD Divergence on; Reducible Control Flow Graphs. Proc. ACM Program. Lang. 5, POPL,; Article 31 (January 2021), 35 pages.; https://doi.org/10.1145/3434312. Terminology; ===========. Cycles; Described in :ref:`cycle-terminology`. Closed path; Described in :ref:`cycle-closed-path`. Disjoint paths; Two paths in a CFG are said to be disjoint if the only nodes common; to both are the start node or the end node, or both. Join node; A join node of a branch is a node reachable along disjoint paths; starting from that branch. Diverged path; A diverged path is a path that starts from a divergent branch and; either reaches a join node of the branch or reaches the end of the; function without passing through any join node of the branch. .. _convergence-dynamic-instances:. Threads and Dynamic Instances; =============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst:2368,extend,extends,2368,interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergenceAndUniformity.rst,1,['extend'],['extends']
Modifiability," Wrong analytic integrals when using Gaussians with sigma depending on the observable; * [[#14303](https://github.com/root-project/root/issues/14303)] - Test failure with `nbconvert-7.14`; * [[#14302](https://github.com/root-project/root/issues/14302)] - The command ""root --notebook"" is not allowed on Windows 11; * [[#14277](https://github.com/root-project/root/issues/14277)] - Cling triggers a huge number of `openat` calls when loading libraries; * [[#14263](https://github.com/root-project/root/issues/14263)] - [tmva] When using DNN_USE_CBLAS, CMakeLists should link publicly to gsl instead of privately; * [[#14256](https://github.com/root-project/root/issues/14256)] - TAxis::GetTicks and TAxis::SetTicks are inconsistent. Significantly so.; * [[#14244](https://github.com/root-project/root/issues/14244)] - String comparison operators defined in TString.h should be defined as constexpr; * [[#14229](https://github.com/root-project/root/issues/14229)] - [6.30] root-config --git-revision broken; * [[#14225](https://github.com/root-project/root/issues/14225)] - [RF] Segmentation fault in ROOT 6.30 workspace creation; * [[#14223](https://github.com/root-project/root/issues/14223)] - Extremely long startup time when loading dictionaries with pyroot; * [[#14219](https://github.com/root-project/root/issues/14219)] - [cling] Use deduction guides for llvm::ArrayRef; * [[#14211](https://github.com/root-project/root/issues/14211)] - Implement value printing for `std::source_location`; * [[#14205](https://github.com/root-project/root/issues/14205)] - [cling] Replace llvm::Optional and llvm::None with std::optional; * [[#14199](https://github.com/root-project/root/issues/14199)] - Memory hoarding triggered by the TPluginManager; * [[#14188](https://github.com/root-project/root/issues/14188)] - cmake find_package ROOT 6.30 broken: it requires nlohmann-json; * [[#14163](https://github.com/root-project/root/issues/14163)] - cmake find_package ROOT broken with 6.30, nlohmann and vdt ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:34183,config,config,34183,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['config'],['config']
Modifiability," X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LambdaCapture>capturesVarMatcher<ValueDecl> InnerMatcher; Matches a `LambdaCapture` that refers to the specified `VarDecl`. The; `VarDecl` can be a separate variable that is captured by value or; reference, or a synthesized variable if the capture has an initializer. Given; void foo() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher; lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName(""x"")))),; capturesVar(hasName(""x"")) matches `x` and `x = 1`. Matcher<LambdaExpr>forEachLambdaCaptureMatcher<LambdaCapture> InnerMatcher; Matches each lambda capture in a lambda expression. Given; int main() {; int x, y;; float z;; auto f = [=]() { return x + y + z; };; }; lambdaExpr(forEachLambdaCapture(; lambdaCapture(capturesVar(varDecl(hasType(isInteger())))))); will trigger two matches, binding for 'x' and 'y' respectively. Matcher<LambdaExpr>hasAnyCaptureMatcher<LambdaCapture> InnerMatcher; Matches any capture in a lambda expression. Given; void foo() {; int t = 5;; auto f = [=](){ return t; };; }; lambdaExpr(hasAnyCapture(lambdaCapture())) and; lambdaExpr(hasAnyCapture(lambdaCapture(refersToVarDecl(hasName(""t""))))); both match `[=](){ return t; }`. Matcher<Membe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:211980,variab,variable,211980,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability," YAML and denormalizes x,y; coordinates into polar when reading YAML. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. template <>; struct MappingTraits<Polar> {. class NormalizedPolar {; public:; NormalizedPolar(IO &io); : x(0.0), y(0.0) {; }; NormalizedPolar(IO &, Polar &polar); : x(polar.distance * cos(polar.angle)),; y(polar.distance * sin(polar.angle)) {; }; Polar denormalize(IO &) {; return Polar(sqrt(x*x+y*y), arctan(x,y));; }. float x;; float y;; };. static void mapping(IO &io, Polar &polar) {; MappingNormalization<NormalizedPolar, Polar> keys(io, polar);. io.mapRequired(""x"", keys->x);; io.mapRequired(""y"", keys->y);; }; };. When writing YAML, the local variable ""keys"" will be a stack allocated; instance of NormalizedPolar, constructed from the supplied polar object which; initializes it x and y fields. The mapRequired() methods then write out the x; and y values as key/value pairs. When reading YAML, the local variable ""keys"" will be a stack allocated instance; of NormalizedPolar, constructed by the empty constructor. The mapRequired; methods will find the matching key in the YAML document and fill in the x and y; fields of the NormalizedPolar object keys. At the end of the mapping() method; when the local keys variable goes out of scope, the denormalize() method will; automatically be called to convert the read values back to polar coordinates,; and then assigned back to the second parameter to mapping(). In some cases, the normalized class may be a subclass of the native type and; could be returned by the denormalize() method, except that the temporary; normalized instance is stack allocated. In these cases, the utility template; MappingNormalizationHeap<> can be used instead. It just like; MappingNormalization<> except that it heap allocates the normalized object; when reading YAML. It never destroys the normalized object. The denormalize(); method can this return ""this"". Default values; --------------; Within a mapping() metho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:18896,variab,variable,18896,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['variab'],['variable']
Modifiability," You can optionally provide a name for it; (probably based on the name of the translation unit). * | ``Module::iterator`` - Typedef for function list iterator; | ``Module::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's :ref:`Function <c_Function>` list. * ``Module::FunctionListType &getFunctionList()``. Returns the list of :ref:`Function <c_Function>`\ s. This is necessary to use; when you need to update the list or perform a complex action that doesn't have; a forwarding method. ----------------. * | ``Module::global_iterator`` - Typedef for global variable list iterator; | ``Module::const_global_iterator`` - Typedef for const_iterator.; | ``Module::insertGlobalVariable()`` - Inserts a global variable to the list.; | ``Module::removeGlobalVariable()`` - Removes a global variable from the list.; | ``Module::eraseGlobalVariable()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTable_ for this ``Module``. ----------------. * ``Function *getFunction(StringRef Name) const``. Look up the specified function in the ``Module`` SymbolTable_. If it does not; exist, return ``null``. * ``FunctionCallee getOrInsertFunction(const std::string &Name,; const FunctionType *T)``. Look up the specified function in the ``Module`` SymbolTable_. If; it does not exist, add an external declaration for the function and; return it. Note that the function signature already present may not; match the requested signature. Thus, in order to enable the common; usage of passing the result directly to EmitCall, the return type is; a struct of ``{FunctionType *T, C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:139283,variab,variable,139283,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability," [LLDB]_, [Google]_, [Rust]_ and [Python]_. ``camelBack`` is already used for function names, which may be considered an; advantage [LattnerFunction]_ or a disadvantage [CarruthFunction]_. Approval for ``camelBack`` was expressed by [DenisovCamelBack]_; [LattnerFunction]_ [IvanovicDistinguish]_.; Opposition to ``camelBack`` was expressed by [CarruthCamelBack]_; [TurnerCamelBack]_.; Approval for ``lower_case`` was expressed by [CarruthLower]_; [CarruthCamelBack]_ [TurnerLLDB]_.; Opposition to ``lower_case`` was expressed by [LattnerLower]_. Differentiating variable kinds; ------------------------------. An additional requested change is to distinguish between different kinds of; variables [RobinsonDistinguish]_ [RobinsonDistinguish2]_ [JonesDistinguish]_; [IvanovicDistinguish]_ [CarruthDistinguish]_ [MalyutinDistinguish]_. Others oppose this idea [HähnleDistinguish]_ [GreeneDistinguish]_; [HendersonPrefix]_. A possibility is for member variables to be prefixed with ``m_`` and for global; variables to be prefixed with ``g_`` to distinguish them from local variables.; This is consistent with [LLDB]_. The ``m_`` prefix is consistent with [WebKit]_. A variation is for member variables to be prefixed with ``m``; [IvanovicDistinguish]_ [BeylsDistinguish]_. This is consistent with [Mozilla]_. Another option is for member variables to be suffixed with ``_`` which is; consistent with [Google]_ and similar to [Python]_. Opposed by; [ParzyszekDistinguish]_. Reducing the number of acronyms; ===============================. While switching coding standard will make it easier to use non-acronym names for; new code, it doesn't improve the existing large body of code that uses acronyms; extensively to the detriment of its readability. Further, it is natural and; generally encouraged that new code be written in the style of the surrounding; code. Therefore it is likely that much newly written code will also use; acronyms despite what the coding standard says, much as it is today. As ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:4073,variab,variables,4073,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,3,['variab'],['variables']
Modifiability," [Liveness analysis](https://en.wikipedia.org/wiki/Live_variable_analysis) is a; generalization of this idea, which is often used to answer many related; questions, for example:. * finding dead stores,; * finding uninitialized variables,; * finding a good point to deallocate memory,; * finding out if it would be safe to move an object. ## Example: definitive initialization. Definitive initialization proves that variables are known to be initialized when; read. If we find a variable which is read when not initialized then we generate; a warning. ```c++; void Init() {; int x; // x is uninitialized; if (cond()) {; x = 10; // x is initialized; } else {; x = 20; // x is initialized; }; print(x); // x is initialized; }; ```. ```c++; void Uninit() {; int x; // x is uninitialized; if (cond()) {; x = 10; // x is initialized; }; print(x); // x is maybe uninitialized, x is being read, report a bug.; }; ```. For this purpose we can use lattice in a form of a mapping from variable; declarations to initialization states; each initialization state is represented; by the following lattice:. ![Lattice for definitive initialization analysis](DataFlowAnalysisIntroImages/DefinitiveInitializationLattice.svg). A lattice element could also capture the source locations of the branches that; lead us to the corresponding program point. Diagnostics would use this; information to show a sample buggy code path to the user. ## Example: refactoring raw pointers to `unique_ptr`. Modern idiomatic C++ uses smart pointers to express memory ownership, however in; pre-C++11 code one can often find raw pointers that own heap memory blocks. Imagine that we would like to refactor raw pointers that own memory to; `unique_ptr`. There are multiple ways to design a data flow analysis for this; problem; let's look at one way to do it. For example, we would like to refactor the following code that uses raw; pointers:. ```c++; void UniqueOwnership1() {; int *pi = new int;; if (...) {; Borrow(pi);; delete pi;; } ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:20979,variab,variable,20979,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['variab'],['variable']
Modifiability," _BreakBeforeTernaryOperators:. **BreakBeforeTernaryOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeTernaryOperators>`; If ``true``, ternary operators will be placed after line breaks. .. code-block:: c++. true:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription; ? firstValue; : SecondValueVeryVeryVeryVeryLong;. false:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?; firstValue :; SecondValueVeryVeryVeryVeryLong;. .. _BreakConstructorInitializers:. **BreakConstructorInitializers** (``BreakConstructorInitializersStyle``) :versionbadge:`clang-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:54550,config,configuration,54550,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," __block_copy_4(struct __block_literal_4 *dst, struct __block_literal_4 *src) {; //_Block_copy_assign(&dst->existingBlock, src->existingBlock, 0);; _Block_object_assign(&dst->existingBlock, src->existingBlock, BLOCK_FIELD_IS_BLOCK);; }. void __block_dispose_4(struct __block_literal_4 *src) {; // was _Block_destroy; _Block_object_dispose(src->existingBlock, BLOCK_FIELD_IS_BLOCK);; }. static struct __block_descriptor_4 {; unsigned long int reserved;; unsigned long int Block_size;; void (*copy_helper)(struct __block_literal_4 *dst, struct __block_literal_4 *src);; void (*dispose_helper)(struct __block_literal_4 *);; } __block_descriptor_4 = {; 0,; sizeof(struct __block_literal_4),; __block_copy_4,; __block_dispose_4,; };. and where said ``Block`` is used:. .. code-block:: c. struct __block_literal_4 _block_literal = {; &_NSConcreteStackBlock,; (1<<25)|(1<<29), <uninitialized>; __block_invoke_4,; & __block_descriptor_4; existingBlock,; };. Importing ``__attribute__((NSObject))`` variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. GCC introduces ``__attribute__((NSObject))`` on structure pointers to mean ""this; is an object"". This is useful because many low level data structures are; declared as opaque structure pointers, e.g. ``CFStringRef``, ``CFArrayRef``,; etc. When used from C, however, these are still really objects and are the; second case where that requires copy and dispose helper functions to be; generated. The copy helper functions generated by the compiler should use the; ``_Block_object_assign`` runtime helper function and in the dispose helper the; ``_Block_object_dispose`` runtime helper function should be called. For example, ``Block`` foo in the following:. .. code-block:: c. struct Opaque *__attribute__((NSObject)) objectPointer = ...;; ...; void (^foo)(void) = ^{ CFPrint(objectPointer); };. would have the following helper functions generated:. .. code-block:: c. void __block_copy_foo(struct __block_literal_5 *dst, struct __block_literal_5 *sr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:10102,variab,variables,10102,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability, `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - open,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122347,plugin,plugins,122347,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability," `ROOT::Math::AdaptiveIntegratorMultiDim` |; | `ROOT::Math::IntegratorMultiDim::kVEGAS` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when usin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61208,adapt,adaptive,61208,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['adapt'],['adaptive']
Modifiability," `TRANSFORM1_HARTLEY`; - `TRANSFORM1_FOURIER_WALSH`; - `TRANSFORM1_FOURIER_HAAR`; - `TRANSFORM1_WALSH_HAAR`; - `TRANSFORM1_COS_WALSH`; - `TRANSFORM1_COS_HAAR`; - `TRANSFORM1_SIN_WALSH`; - `TRANSFORM1_SIN_HAAR`; - **`direction`**: transform direction (forward, inverse); - `TRANSFORM1_FORWARD`; - `TRANSFORM1_INVERSE`; - **`degree`**: applies only for mixed transforms. Let us illustrate the applications of the transform using an example. In Figure 6.1 we have spectrum with many peaks, complicated background and high level of noise. ![Spectrum with many peaks](figures/image196.png). In Figures 6.2, 6.3, 6.4 we present this spectrum transformed using Haar,; Walsh and Cosine transforms, respectively. ![Spectrum transformed using Haar transform](figures/image198.png). ![Spectrum transformed using Walsh transform](figures/image200.png). ![Spectrum transformed using Cosine transform](figures/image202.png). Haar transforms (Figure 6.2) creates clusters of data. These coefficients; can be analyzed and then filtered, enhanced, etc. On the other hand, the Walsh; transform (Figure 6.3) concentrates the dominant components near zero of; the coordinate system. It is more suitable to process data of a; rectangular shape (e.g., in the field of digital signal processing).; Finally, Cosine transform concentrates in the best way the transform; coefficients to the beginning of the coordinate system. From the point; of view of the variance distribution, it is sometimes called suboptimal.; One can notice that approximately one half of the coefficients are; negligible. This fact can be used to the compression purposes (in; two- or more dimensional data), filtering (smoothing), etc. We have implemented several application functions exploiting; the properties of the orthogonal transforms. Let us start with zonal; filtration function. It has the following form:. ```{.cpp}; char *Filter1Zonal(const float *source,; float *dest,; int size,; int type,; int degree,; int xmin,; int xmax,; float filt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:60656,enhance,enhanced,60656,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['enhance'],['enhanced']
Modifiability," ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,; which specifies how to generate additional flags bas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2073,config,configuration,2073,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['config'],['configuration']
Modifiability," ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plugin`` option to; ``ld``. It will not look for an alternate linker without ``-fuse-ld=gold``,; which is why you otherwise need gold to be the installed system linker in; your path. ``ar`` and ``nm`` also accept the ``-plugin`` option and it's possible to; to install ``LLVMgold.so`` to ``/usr/lib/bfd-plugins`` for a seamless setup.; If you built your own gold, be sure to install the ``ar`` and ``nm-new`` you; built to ``/usr/bin``. Example of link time optimization; ---------------------------------. The following example shows a worked example of the gold plugin mixing LLVM; bitcode and native code. .. code-block:: c. --- a.c ---; #include <stdio.h>. extern void foo1(void);; extern void foo4(void);. void foo2(void) {; printf(""Foo2\n"");; }. void foo3(void) {; foo4();; }. int main(void) {; foo1();; }. --- b.c ---; #include <stdio.h>. extern void foo2(void);. void foo1(void) {; foo2();; }. void foo4(void) {; printf(""Foo4"");; }. .. code-block:: bash. --- command lines ---; $ clang -flto a.c -c -o a.o # <-- a.o is LLVM bitcode file; $ ar q a.a a.o # <-- a.a is an archive with LLVM bitcode; $ clang b.c -c -o b.o # <-- b.o is native object file; $ clang -flto a.a b.o -o main # <-- link with LLVMgold plugin. Gold informs the plugin that foo3 is never referenced outside the IR,; leading LLVM t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:3575,plugin,plugins,3575,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugins']
Modifiability," ``AND`` of the current ``EXEC`` mask with the condition mask. Then the; ``ELSE`` region is executed by negating the ``EXEC`` mask and logical ``AND`` of; the saved ``EXEC`` mask at the start of the region. After the ``IF/THEN/ELSE``; region the ``EXEC`` mask is restored to the value it had at the beginning of the; region. This is shown below. Other approaches are possible, but the basic; concept is the same. .. code::; :number-lines:. $lex_start:; a;; %1 = EXEC; %2 = c1; $lex_1_start:; EXEC = %1 & %2; $if_1_then:; b;; %3 = EXEC; %4 = c2; $lex_1_1_start:; EXEC = %3 & %4; $lex_1_1_then:; c;; EXEC = ~EXEC & %3; $lex_1_1_else:; d;; EXEC = %3; $lex_1_1_end:; e;; EXEC = ~EXEC & %1; $lex_1_else:; f;; EXEC = %1; $lex_1_end:; g;; $lex_end:. To create the DWARF location list expression that defines the location; description of a vector of lane program locations, the LLVM MIR ``DBG_VALUE``; pseudo instruction can be used to annotate the linearized control flow. This can; be done by defining an artificial variable for the lane PC. The DWARF location; list expression created for it is used as the value of the; ``DW_AT_LLVM_lane_pc`` attribute on the subprogram's debugger information entry. A DWARF procedure is defined for each well nested structured control flow region; which provides the conceptual lane program location for a lane if it is not; active (namely it is divergent). The DWARF operation expression for each region; conceptually inherits the value of the immediately enclosing region and modifies; it according to the semantics of the region. For an ``IF/THEN/ELSE`` region the divergent program location is at the start of; the region for the ``THEN`` region since it is executed first. For the ``ELSE``; region the divergent program location is at the end of the ``IF/THEN/ELSE``; region since the ``THEN`` region has completed. The lane PC artificial variable is assigned at each region transition. It uses; the immediately enclosing region's DWARF procedure to compute the pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:102861,variab,variable,102861,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variable']
Modifiability," ``_Block_object_dispose``. There should be no code generated that uses; ``*-retain`` or ``*-release`` methods. ``Blocks`` as Objects; ---------------------. The compiler will treat ``Blocks`` as objects when synthesizing property setters; and getters, will characterize them as objects when generating garbage; collection strong and weak layout information in the same manner as objects, and; will issue strong and weak write-barrier assignments in the same manner as; objects. ``__weak __block`` Support; --------------------------. Objective-C (and Objective-C++) support the ``__weak`` attribute on ``__block``; variables. Under normal circumstances the compiler uses the Objective-C runtime; helper support functions ``objc_assign_weak`` and ``objc_read_weak``. Both; should continue to be used for all reads and writes of ``__weak __block``; variables:. .. code-block:: c. objc_read_weak(&block->byref_i->forwarding->i). The ``__weak`` variable is stored in a ``_block_byref_foo`` structure and the; ``Block`` has copy and dispose helpers for this structure that call:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src-> _block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BYREF);. and:. .. code-block:: c. _Block_object_dispose(src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BYREF);. In turn, the ``block_byref`` copy support helpers distinguish between whether; the ``__block`` variable is a ``Block`` or not and should either call:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_OBJECT | BLOCK_BYREF_CALLER);. for something declared as an object or:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER);. for something declared as a ``Block``. A full example follows:. .. code-block:: c. __block __weak id obj = <initialization expression>;; functioncall(^{ [obj somemessage]; });. would tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:19838,variab,variable,19838,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variable']
Modifiability," ```. However, most of the time, the user will not need **or want** such direct control over the type, but rather just let RooFit figure out what exact likelihood type (`RooAbsL` derived class) is best.; For this situation, the `buildLikelihood` function was created that can be used (for instance) as:; ``` {.cpp}; std::shared_ptr<RooFit::TestStatistics::RooAbsL> likelihood = RooFit::TestStatistics::buildLikelihood(pdf, data);; ```; `buildLikelihood` actually returns a `unique_ptr`; storing the result in a `shared_ptr` as done here is just one possible use-case. ### Usage example: Create a likelihood of a simultaneous PDF with constraint terms and global observables (and other optional arguments); The `RooAbsPdf::fitTo` or `RooAbsPdf::createNLL` interfaces could take in a set of optional parameters as `RooCmdArg` objects.; In `TestStatistics::buildLikelihood`, we have implemented 4 of these options as separate types while an additional one is supported as a simple string:; - `RooAbsL::Extended`: an enum class used to set extended term calculation `on`, `off` or use `Extended::Auto` to determine automatically based on the pdf whether to activate or not.; - `ConstrainedParameters`: Initialized with a `RooArgSet` of parameters that are constrained. Pdf components dependent on these alone are added to a subsidiary likelihood term.; - `ExternalConstraints`: Initialized with a `RooArgSet` of external constraint pdfs, i.e. constraints not necessarily in the pdf itself. These are always added to the subsidiary likelihood.; - `GlobalObservables`: Initialized with a `RooArgSet` of observables that have a constant value, independent of the dataset events. Pdf components dependent on these alone are added to the subsidiary likelihood. \note This overrides all other likelihood parameters (like those in the `ConstrainedParameters` argument) if present.; - Finally, a string argument `global_observables_tag` can be given, which should be set as attribute in any pdf component to indic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:3775,extend,extended,3775,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['extend'],['extended']
Modifiability," ``ccmake`` or ``cmake-gui``). This file is available in two different locations. * ``<LLVM_INSTALL_PACKAGE_DIR>/LLVMConfig.cmake`` where; ``<LLVM_INSTALL_PACKAGE_DIR>`` is the location where LLVM CMake modules are; installed as part of an installed version of LLVM. This is typically; ``cmake/llvm/`` within the lib directory. On Linux, this is typically; ``/usr/lib/cmake/llvm/LLVMConfig.cmake``. * ``<LLVM_BUILD_ROOT>/lib/cmake/llvm/LLVMConfig.cmake`` where; ``<LLVM_BUILD_ROOT>`` is the root of the LLVM build tree. **Note: this is only; available when building LLVM with CMake.**. If LLVM is installed in your operating system's normal installation prefix (e.g.; on Linux this is usually ``/usr/``) ``find_package(LLVM ...)`` will; automatically find LLVM if it is installed correctly. If LLVM is not installed; or you wish to build directly against the LLVM build tree you can use; ``LLVM_DIR`` as previously mentioned. The ``LLVMConfig.cmake`` file sets various useful variables. Notable variables; include. ``LLVM_CMAKE_DIR``; The path to the LLVM CMake directory (i.e. the directory containing; LLVMConfig.cmake). ``LLVM_DEFINITIONS``; A list of preprocessor defines that should be used when building against LLVM. ``LLVM_ENABLE_ASSERTIONS``; This is set to ON if LLVM was built with assertions, otherwise OFF. ``LLVM_ENABLE_EH``; This is set to ON if LLVM was built with exception handling (EH) enabled,; otherwise OFF. ``LLVM_ENABLE_RTTI``; This is set to ON if LLVM was built with run time type information (RTTI),; otherwise OFF. ``LLVM_INCLUDE_DIRS``; A list of include paths to directories containing LLVM header files. ``LLVM_PACKAGE_VERSION``; The LLVM version. This string can be used with CMake conditionals, e.g., ``if; (${LLVM_PACKAGE_VERSION} VERSION_LESS ""3.5"")``. ``LLVM_TOOLS_BINARY_DIR``; The path to the directory containing the LLVM tools (e.g. ``llvm-as``). Notice that in the above example we link ``simple-tool`` against several LLVM; libraries. The list of libraries i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:43520,variab,variables,43520,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability," ``standard``.; * ``16`` - Forces ``_Float16`` operations to be emitted without using excess; precision arithmetic. .. option:: -fcx-limited-range:. This option enables the naive mathematical formulas for complex division and; multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by the ``-ffast-math``; option. .. option:: -fcx-fortran-rules:. This option enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point envir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69226,config,configuration,69226,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability," ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73266,config,configuration,73266,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['configuration']
Modifiability," a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum suspicious. #### An Ill-posed Problem. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the; following:. - Excessive numerical round off - be especially careful of; exponential and factorial functions which get big ve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:63486,parameteriz,parameterization,63486,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['parameteriz'],['parameterization']
Modifiability," a DWARF expression involving the set of SIMT lanes active on entry to a; subprogram is required. The SIMT active lane mask may be held in a register that; is modified as the subprogram executes. However, its value may be saved on entry; to the subprogram. The Call Frame Information (CFI) already encodes such register saving, so it is; more efficient to provide an operation to return the location of a saved; register than have to generate a loclist to describe the same information. This; is now possible since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack`; allows location descriptions on the stack. See ``DW_OP_LLVM_call_frame_entry_reg`` in; :ref:`amdgpu-dwarf-general-location-description-operations` and; :ref:`amdgpu-dwarf-call-frame-information`. 2.12 Support for Source Languages Mapped to SIMT Hardware; ---------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner,; then the variable DWARF location expressions must compute the location for a; single lane of the wavefront. Therefore, a DWARF operation is required to denote; the current lane, much like ``DW_OP_push_object_address`` denotes the current; object. See ``DW_OP_LLVM_push_lane`` in :ref:`amdgpu-dwarf-literal-operations`. In addition, a way is needed for the compiler to communicate how many source; language threads of execution are mapped to a target architecture thread's SIMT; lanes. See ``DW_AT_LLVM_lanes`` in :ref:`amdgpu-dwarf-low-level-information`. .. _amdgpu-dwarf-support-for-divergent-control-flow-of-simt-hardware:. 2.13 Support for Divergent Control Flow of SIMT Hardware; --------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner the; compiler can use the AMDGPU execution mask register to control which lanes are; active. To describe the conceptual location of non-active lanes requires an; attribute that has an expression",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:28091,variab,variable,28091,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability," a flag is NOT present; on a matched instruction, and to remove a flag from a generated instruction. .. code-block:: text; :caption: Example. ; We match NoInfs but we don't want NoNans/Reassoc to be set. $zext may have more flags.; ; Copy them all into the output instruction but remove NoInfs on the output inst.; def TestNot : GICombineRule<; (defs root:$dst),; (match (G_FOO $dst, $src, (MIFlags FmNoInfs, (not FmNoNans, FmReassoc))):$zext),; (apply (G_BAR $dst, $src, (MIFlags $zext, (not FmNoInfs))))>;. Limitations; -----------. This a non-exhaustive list of known issues with MIR patterns at this time. * Matching intrinsics is not yet possible.; * Using ``GICombinePatFrag`` within another ``GICombinePatFrag`` is not; supported.; * ``GICombinePatFrag`` can only have a single root.; * Instructions with multiple defs cannot be the root of a ``GICombinePatFrag``.; * Using ``GICombinePatFrag`` in the ``apply`` pattern of a ``GICombineRule``; is not supported.; * We cannot rewrite a matched instruction other than the root.; * Matching/creating a (CImm) immediate >64 bits is not supported; (see comment in ``GIM_CheckConstantInt``); * There is currently no way to constrain two register/immediate types to; match. e.g. if a pattern needs to work on both i32 and i64, you either; need to leave it untyped and check the type in C++, or duplicate the; pattern. GICombineRule; -------------. MIR patterns can appear in the ``match`` or ``apply`` patterns of a; ``GICombineRule``. The ``root`` of the rule can either be a def of an instruction, or a; named pattern. The latter is helpful when the instruction you want; to match has no defs. The former is generally preferred because; it's less verbose. .. code-block:: text; :caption: Combine Rule root is a def. // Fold x op 1 -> x; def right_identity_one: GICombineRule<; (defs root:$dst),; (match (G_MUL $dst, $x, 1)),; // Note: Patterns always need to create something, we can't just replace $dst with $x, so we need a COPY.; (apply (COPY $d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:6300,rewrite,rewrite,6300,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['rewrite'],['rewrite']
Modifiability," a given body. Note that in case of functions or; coroutines this matcher only matches the definition itself and not the; other declarations of the same function or coroutine. Given; for (;;) {}; forStmt(hasBody(compoundStmt())); matches 'for (;;) {}'; with compoundStmt(); matching '{}'. Given; void f();; void f() {}; functionDecl(hasBody(compoundStmt())); matches 'void f() {}'; with compoundStmt(); matching '{}'; but does not match 'void f();'. Matcher<DoStmt>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. Matcher<ElaboratedTypeLoc>hasNamedTypeLocMatcher<TypeLoc> InnerMatcher; Matches elaborated `TypeLoc`s that have a named `TypeLoc` matching; `InnerMatcher`. Given; template <typename T>; class C {};; class C<int> c;. class D {};; class D d;; elaboratedTypeLoc(hasNamedTypeLoc(templateSpecializationTypeLoc()));; matches the `TypeLoc` of the variable declaration of `c`, but not `d`. Matcher<ElaboratedType>hasQualifierMatcher<NestedNameSpecifier> InnerMatcher; Matches ElaboratedTypes whose qualifier, a NestedNameSpecifier,; matches InnerMatcher if the qualifier exists. Given; namespace N {; namespace M {; class D {};; }; }; N::M::D d;. elaboratedType(hasQualifier(hasPrefix(specifiesNamespace(hasName(""N"")))); matches the type of the variable declaration of d. Matcher<ElaboratedType>namesTypeMatcher<QualType> InnerMatcher; Matches ElaboratedTypes whose named type matches InnerMatcher. Given; namespace N {; namespace M {; class D {};; }; }; N::M::D d;. elaboratedType(namesType(recordType(; hasDeclaration(namedDecl(hasName(""D"")))))) matches the type of the variable; declaration of d. Matcher<EnumType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the decla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:189805,variab,variable,189805,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability," a is an integer and the expression means all the version numbers smaller; than or equal to a; – ""a-"" - a is an integer and the expression means all the version numbers greater; than or equal to a; * checksum - A list of checksums of the source class that can be an input for this; rule. The list has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target - A semicolon-separated list of target class data member names that this rule; is capable of calculating.; * embed - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include - A list of header files that should be included in order to provide the func-; tionality used in the code snippet; the list is comma delimited.; * code - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj - variable representing the target in-memory object, it’s type is that of the; target object; * oldObj - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer - in raw conversion rules, an object of TBuﬀer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt:4763,variab,variables,4763,io/doc/DataModelEvolution.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt,1,['variab'],['variables']
Modifiability," a judge on when to exit the loop and how to widen it.; Given that the constructor is going to be a default constructor,; a nice 95% solution might be to execute exactly one constructor and; then default-bind the resulting LazyCompoundVal to the whole array;; it'll work whenever the default constructor doesn't touch global state; but only initializes the object to various default values.; But if, say, we're making an array of strings,; depending on the implementation you might have to allocate a new buffer; for each string, and in this case default-binding won't cut it.; We might want to come up with an auxiliary analysis in order to perform; widening of these simple loops more precisely.; . Handle constructors that can be elided due to Named Return Value Optimization (NRVO); Local variables which are returned by values on all return statements; may be stored directly at the address for the return value,; eliding the copy or move constructor call.; Such variables can be identified using the AST call VarDecl::isNRVOVariable.; . Handle constructors of lambda captures; Variables which are captured by value into a lambda require a call to; a copy constructor.; This call is not currently modeled.; . Handle constructors for default arguments; Default arguments in C++ are recomputed at every call,; and are therefore local, and not static, variables.; See tests cases in handle_constructors_for_default_arguments.cpp.; . Default arguments are annoying because the initializer expression is; evaluated at the call site but doesn't syntactically belong to the; caller's AST; instead it belongs to the ParmVarDecl for the default; parameter. This can lead to situations when the same expression has to; carry different values simultaneously -; when multiple instances of the same function are evaluated as part of the; same full-expression without specifying the default arguments.; Even simply calling the function twice (not necessarily within the; same full-expression) may lead to prog",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:4177,variab,variables,4177,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['variab'],['variables']
Modifiability," a mix of calls to ``llvm.dbg.value`` to track; the source variable value when it is available. After optimization, there may be; multiple calls to ``llvm.dbg.declare`` describing the program points where the; variables lives in memory. All calls for the same concrete source variable must; agree on the memory location. ``llvm.dbg.value``; ^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.value(metadata, metadata, metadata). This intrinsic provides information when a user source variable is set to a new; value. The first argument is the new value (wrapped as metadata). The second; argument is a `local variable <LangRef.html#dilocalvariable>`_ containing a; description of the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a source variable; directly, not its address. Note that the value operand of this intrinsic may; be indirect (i.e, a pointer to the source variable), provided that interpreting; the complex expression derives the direct value. ``llvm.dbg.assign``; ^^^^^^^^^^^^^^^^^^^; .. toctree::; :hidden:. AssignmentTracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression). This intrinsic marks the position in IR where a source assignment occurred. It; encodes the value of the variable. It references the store, if any, that; performs the assignment, and the destination address. The first three arguments are the same as for an ``llvm.dbg.value``. The fourth; argument is a ``DIAssignID`` used to reference a store. The fifth is the; destination of the store (wrapped as metadata), and the sixth is a `complex; expression <LangRef.html#diexpression>`_ that modifies it. The formal LLVM-IR signature is:. .. code-block:: llvm. void @llvm.dbg.assign(metadata, metadata, metadata, metadata, metadata, metadata). See :doc:`AssignmentTracking` f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:10801,variab,variable,10801,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability," a poison; dbg.value before the dbg.value for ``!3``:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); %g = call i32 @gazonk(); call @llvm.dbg.value(metadata i32 poison, metadata !1, metadata !2); call @llvm.dbg.value(metadata i32 %g, metadata !3, metadata !2); %addoper = select i1 %cond, i32 11, i32 12; %plusten = add i32 %bar, %addoper; %toret = add i32 %plusten, %g; call @llvm.dbg.value(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. There are a few other dbg.value configurations that mean it terminates; dominating location definitions without adding a new location. The complete; list is:. * Any location operand is ``poison`` (or ``undef``).; * Any location operand is an empty metadata tuple (``!{}``) (which cannot; occur in a ``!DIArgList``).; * There are no location operands (empty ``DIArgList``) and the ``DIExpression``; is empty. This class of dbg.value that kills variable locations is called a ""kill; dbg.value"" or ""kill location"", and for legacy reasons the term ""undef; dbg.value"" may be used in existing code. The ``DbgVariableIntrinsic`` methods; ``isKillLocation`` and ``setKillLocation`` should be used where possible rather; than inspecting location operands directly to check or set whether a dbg.value; is a kill location. In general, if any dbg.value has its operand optimized out and cannot be; recovered, then a kill dbg.value is necessary to terminate earlier variable; locations. Additional kill dbg.values may be necessary when the debugger can; observe re-ordering of assignments. How variable location metadata is transformed during CodeGen; ============================================================. LLVM preserves debug information throughout mid-level and backend passes,; ultimately producing a mapping between source-level information and; instruction ranges. This; is relatively straightforwards for line number information, as mapping; instructions ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:23191,variab,variable,23191,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability," a positive, constant integer with; ``%Stride >= <Rows>``. ``%Stride`` is used to compute the column memory; addresses. I.e., for a column ``C``, its start memory addresses is calculated; with ``%Ptr + C * %Stride``. The fourth argument ``<IsVolatile>`` is a boolean; value. The arguments ``<Rows>`` and ``<Cols>`` correspond to the number of rows; and columns, respectively, and must be positive, constant integers. The :ref:`align <attr_align>` parameter attribute can be provided; for the ``%Ptr`` arguments. Half Precision Floating-Point Intrinsics; ----------------------------------------. For most target platforms, half precision floating-point is a; storage-only format. This means that it is a dense encoding (in memory); but does not support computation in the format. This means that code must first load the half-precision floating-point; value as an i16, then convert it to float with; :ref:`llvm.convert.from.fp16 <int_convert_from_fp16>`. Computation can; then be performed on the float value (including extending to double; etc). To store the value back to memory, it is first converted to float; if needed, then converted to i16 with; :ref:`llvm.convert.to.fp16 <int_convert_to_fp16>`, then storing as an; i16 value. .. _int_convert_to_fp16:. '``llvm.convert.to.fp16``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i16 @llvm.convert.to.fp16.f32(float %a); declare i16 @llvm.convert.to.fp16.f64(double %a). Overview:; """""""""""""""""". The '``llvm.convert.to.fp16``' intrinsic function performs a conversion from a; conventional floating-point type to half precision floating-point format. Arguments:; """""""""""""""""""". The intrinsic function contains single argument - the value to be; converted. Semantics:; """""""""""""""""""". The '``llvm.convert.to.fp16``' intrinsic function performs a conversion from a; conventional floating-point format to half precision floating-point format. The; return value is an ``i16`` which contains the converted number. Examples:; """"""""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:681234,extend,extending,681234,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extending']
Modifiability," a price of making checkers heavy); or instead relying on the Store to do exactly what it's designed to do. > I think the key criterion here is: ""is the region accessible from outside; > the library"". That is, does the library expose the region as a pointer that; > can be read to or written from in the client program? If so, then it makes; > sense for this to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > for them just to get invalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additiona",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:16227,variab,variable,16227,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,2,['variab'],['variable']
Modifiability," a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; =================================. Now that we know the sort of problem we want to tackle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for induction variables, and; redefining those only goes so far :). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. # Recursive fib, we could do this before.; def fib(x); if (x < 3) then; 1; else; fib(x-1)+fib(x-2);. # Iterative fib.; def fibi(x); var a = 1, b = 1, c in; (for i = 3, i < x in; c = a + b :; a = b :; b = c) :; b;. # Call it.; fibi(10);. In order to mutate variables, we have to change our existing variables; to use the ""alloca trick"". Once we have that, we'll add our new; operator, then extend Kaleidoscope to support new variable definitions. Adjusting Existing Variables for Mutation; =========================================. The symbol table in Kaleidoscope is managed at code generation ti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:10606,variab,variables,10606,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,2,['variab'],['variables']
Modifiability," a source language type; which may apply to objects allocated in different kinds of storage. Therefore,; it is desirable that the expression that uses the address can do so without; regard to what kind of storage it specifies, including the address space of a; memory location description. For example, a pointer to member value may want to; be applied to an object that may reside in any address space. The DWARF ``DW_OP_xderef*`` operations allow a value to be converted into an; address of a specified address space which is then read. But it provides no; way to create a memory location description for an address in the non-default; address space. For example, AMDGPU variables can be allocated in the local; address space at a fixed address. The ``DW_OP_LLVM_form_aspace_address`` (see; :ref:`amdgpu-dwarf-memory-location-description-operations`) operation is defined; to create a memory location description from an address and address space. If; can be used to specify the location of a variable that is allocated in a; specific address space. This allows the size of addresses in an address space to; be larger than the generic type. It also allows a consumer great implementation; freedom. It allows the implicit conversion back to a value to be limited only to; the default address space to maintain compatibility with DWARF Version 5. For; other address spaces the producer can use the new operations that explicitly; specify the address space. In contrast, if the ``DW_OP_LLVM_form_aspace_address`` operation had been; defined to produce a value, and an implicit conversion to a memory location; description was defined, then it would be limited to the size of the generic; type (which matches the size of the default address space). An implementation; would likely have to use *reserved ranges* of value to represent different; address spaces. Such a value would likely not match any address value in the; actual hardware. That would require the consumer to have special treatment for; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:19747,variab,variable,19747,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability," a static object that gets created in every translation; unit that includes ``<iostream>``. This object has a static constructor; and destructor that initializes and destroys the global iostream objects; before they could possibly be used in the file. The code that you see in the; ``.ll`` file corresponds to the constructor and destructor registration code. If you would like to make it easier to *understand* the LLVM code generated; by the compiler in the demo page, consider using ``printf()`` instead of; ``iostream``\s to print values. Where did all of my code go??; -----------------------------; If you are using the LLVM demo page, you may often wonder what happened to; all of the code that you typed in. Remember that the demo script is running; the code through the LLVM optimizers, so if your code doesn't actually do; anything useful, it might all be deleted. To prevent this, make sure that the code is actually needed. For example, if; you are computing some expression, return the value from the function instead; of leaving it in a local variable. If you really want to constrain the; optimizer, you can read from and assign to ``volatile`` global variables. What is this ""``undef``"" thing that shows up in my code?; --------------------------------------------------------; ``undef`` is the LLVM way of representing a value that is not defined. You; can get these if you do not initialize a variable before you use it. For; example, the C function:. .. code-block:: c. int X() { int i; return i; }. Is compiled to ""``ret i32 undef``"" because ""``i``"" never has a value specified; for it. Why does instcombine + simplifycfg turn a call to a function with a mismatched calling convention into ""unreachable""? Why not make the verifier reject it?; ----------------------------------------------------------------------------------------------------------------------------------------------------------; This is a common problem run into by authors of front-ends that are using; custom ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:8473,variab,variable,8473,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['variab'],['variable']
Modifiability," a user to the tree that is not depending on the entry number. For; example:. ``` {.cpp}; tree->GetUserInfo()->Add(myruninfo);; ```. ### Indexing a Tree. Use `TTree::BuildIndex()`, to build an index table using expressions; depending on the value in the leaves. ``` {.cpp}; tree->BuildIndex(majorname, minorname);; ```. The index is built in the following way:. - a pass on all entries is made like in `TTree::Draw()`; - `var1 = majorname`; - `var2 = minorname`; - `sel = ` $2^{31} \times majorname + minorname$; - for each entry in the tree the sel expression is evaluated and the; results array is sorted into `fIndexValues`. Once the index is computed, using the; `TTree::GetEntryWithIndex(majornumber, minornumber)` one entry can be; retrieved. Example:. ``` {.cpp}; // to create an index using leaves Run and Event; tree.BuildIndex(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; ```. Note that `majorname` and `minorname` may be expressions using original; tree variables e.g.: ""`run-90000`"", ""`event +3*xx`"". In case an; expression is specified, the equivalent expression must be computed when; calling `GetEntryWithIndex()`. To build an index with only `majorname`,; specify `minorname=""0""` (default). Note that once the index is built, it can be saved with the **`TTree`**; object with:. ``` {.cpp}; tree.Write(); //if the file has been open in ""update"" mode; ```. The most convenient place to create the index is at the end of the; filling process just before saving the tree header. If a previous index; was computed, it is redefined by this new call. Note that this function can also be applied to a **`TChain`**. The; return value is the number of entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variabl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:17254,variab,variables,17254,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability," a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, and there is a more detailed introduction to it; by Sean Parent in several of his talks and papers:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:131794,polymorphi,polymorphism,131794,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['polymorphi'],['polymorphism']
Modifiability," a; // returned block; }. .. _alpha-core-StdVariant:. alpha.core.StdVariant (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check if a value of active type is retrieved from an ``std::variant`` instance with ``std::get``.; In case of bad variant type access (the accessed type differs from the active type); a warning is emitted. Currently, this checker does not take exception handling into account. .. code-block:: cpp. void test() {; std::variant<int, char> v = 25;; char c = stg::get<char>(v); // warn: ""int"" is the active alternative; }. .. _alpha-core-TestAfterDivZero:. alpha.core.TestAfterDivZero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. .. code-block:: c. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. alpha.cplusplus; ^^^^^^^^^^^^^^^. .. _alpha-cplusplus-ArrayDelete:. alpha.cplusplus.ArrayDelete (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of arrays of polymorphic objects that are destructed as their base class.; This checker corresponds to the CERT rule `EXP51-CPP: Do not delete an array through a pointer of the incorrect type <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_. .. code-block:: cpp. class Base {; virtual ~Base() {}; };; class Derived : public Base {}. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void foo() {; Base *x = create();; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' is undefined; }. .. _alpha-cplusplus-DeleteWithNonVirtualDtor:. alpha.cplusplus.DeleteWithNonVirtualDtor (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of polymorphic objects with a non-virtual destructor in their base class. .. code-block:: cpp. class NonVirtual {};; class NVDerived : public NonVirtual {};. NonVirtual *cre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:52646,polymorphi,polymorphic,52646,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['polymorphi'],['polymorphic']
Modifiability," able to print out the variables; we have in scope. Let's get our function arguments set up so we can get; decent backtraces and see how our functions are being called. It isn't; a lot of code, and we generally handle it when we're creating the; argument allocas in ``FunctionAST::codegen``. .. code-block:: c++. // Record the function arguments in the NamedValues map.; NamedValues.clear();; unsigned ArgIdx = 0;; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Create a debug descriptor for the variable.; DILocalVariable *D = DBuilder->createParameterVariable(; SP, Arg.getName(), ++ArgIdx, Unit, LineNo, KSDbgInfo.getDoubleTy(),; true);. DBuilder->insertDeclare(Alloca, D, DBuilder->createExpression(),; DILocation::get(SP->getContext(), LineNo, 0, SP),; Builder->GetInsertBlock());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. Here we're first creating the variable, giving it the scope (``SP``),; the name, source location, type, and since it's an argument, the argument; index. Next, we create an ``lvm.dbg.declare`` call to indicate at the IR; level that we've got a variable in an alloca (and it gives a starting; location for the variable), and setting a source location for the; beginning of the scope on the declare. One interesting thing to note at this point is that various debuggers have; assumptions based on how code and debug information was generated for them; in the past. In this case we need to do a little bit of a hack to avoid; generating line information for the function prologue so that the debugger; knows to skip over those instructions when setting a breakpoint. So in; ``FunctionAST::CodeGen`` we add some more lines:. .. code-block:: c++. // Unset the location for the prologue emission (leading instructions with no; // ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:13963,variab,variable,13963,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['variab'],['variable']
Modifiability," add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for induction variables, and; redefining those only goes so far :). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. # Recursive fib, we could do this before.; def fib(x); if (x < 3) then; 1; else; fib(x-1)+fib(x-2);. # Iterative fib.; def fibi(x); var a = 1, b = 1, c in; (for i = 3, i < x in; c = a + b :; a = b :; b = c) :; b;. # Call it.; fibi(10);. In order to mutate variables, we have to change our existing variables; to use the ""alloca trick"". Once we have that, we'll add our new; operator, then extend Kaleidoscope to support new variable definitions. Adjusting Existing Variables for Mutation; =========================================. The symbol table in Kaleidoscope is managed at code generation time by; the '``NamedValues``' map. This map currently keeps track of the LLVM; ""Value\*"" that holds the double value for the named variable. In order; to support mutation, we need to change this slightly, so that; ``NamedValues`` holds the *memory location* of the variable in question.; Note that this change is a refactoring: it changes the structure of the; code, but does not (by itself) change the behavior of the compiler. All; of these changes are isolated in the Kaleidoscope code generator. At this point in Kaleidoscope's development, it only supports variables; for two things: incoming arguments to functions and the induction; variable of 'for' loops. For consistency, we'll allow mutation of these; variables in addition to other user-defined variables. This means that; these wil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:11421,extend,extend,11421,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,2,"['extend', 'variab']","['extend', 'variable']"
Modifiability," addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a TGraph which on exit will be filled with the scanned or contour points. ; TH1. Re-implement TH1::Fit using the functions defined in HFitImpl.cxx.; Add new function TH1::Interpolate to approximate the value via linear interpolation. Implementation from Any Mastbaum. ; Fixed a bug in rebinning in a new variable bin histogram.; Fixed a bug in copy constructor of histograms; define now kNstat as an enumeration in the TH1 class, to avoid using wrong values for this constant variable. This fixes a previous bug in TProfile3D; ; TH2. Share a common implementation for (FitSlicesX,FitSclicesY) and (ProfileX, ProfileY) using a common protected method.; Add possibility to be used in the FitPanel (add a TH2::FitPanel() method).; Add also here the new function TH2::Interpolate. ; fix a bug in the resulting statistics in TH2::ProjectionX(Y) when all range was used; fix a bug in getting the right axis and limits in TH2::ProfileX(Y); ; TH3. Add new option ""NUF"" and ""NOF"" in TH3::Project to have excluded the underflow/overflow (they are included by default).; Add option ""UF"" and ""OF"" in TH3::ProjectProfile to include the underflow/overflow. By default they are now excluded while in the previous version they were included. This is consistent with the projection from a TH2.; ; Fixed a bug in TH3::Project reported by Marco Van Leeuwen in setting the bin error in the projected histogram when a range was",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:2901,variab,variable,2901,hist/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html,1,['variab'],['variable']
Modifiability," all greek and math symbols are printed correctly by `TTexDump`.; - Implement dummy operators `#mbox` and `#hbox` to improve the compatibility; between `TLatex`, `TMathText` and `TTexDump`.; - Some operators like `#minus`, `#plus`, `#mp`, `#hbar` etc ...; ignored the color defined by the operator `#color`.; - With the Cocoa backend on Mac the text string were a bit too large; compared to the TTF rendering. ### TPave. - Implement `SetX1()` etc ... for `TPave` and inherited classes to make sure the; NDC coordinates are also defined. ### TLinearGradient and TRadialGradient. - Two new classes to support color gradient: `TLinearGradient` and `TRadialGradient`.; Both classes inherit from `TColor` and can be used the same way as ROOT's; standard colors in `TAttFill` (`SetFillColor(newColorIndex)`).; Gradient fill can be created using either RGBA values directly, or from; color indices (colors from the ROOT's color table).; - TRadialGradient supports a simple radial gradient (center + radius); and an ""extended"" radial gradient (starting/ending points + two radii).; - The new gradient fill option is available either with OpenGL (""gl-in-pad""); or with a Cocoa backend (OS X only).; - Please note, at the moment, a color gradient can not be saved; in a ROOT file or a pdf/ps file. It can be saved as an image (png/jpg etc.).; - There are several demos in the tutorials/cocoa and tutorials/gl sub-directories; explaining how to use these new classes:; * grad.C; * grad2.C; * radialgradients.C. ![TRadialGradient example](ellipses.png ""TEllipse objects with a radial gradient fill""). ![TLinearGradient example](lingrad.png ""Two histograms with a linear gradient fill and transparency""). ![Gradient example](mixgrad.png ""TPie with a radial fill + a linear gradient fill as a background""). ### TGCocoa and TGQuartz. - Correct font metrics for greek and math symbols are implemented now.; - Added support for linear and radial color gradients (see the notes above).; - ""GL-in-pad"" implemented for C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:8104,extend,extended,8104,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['extend'],['extended']
Modifiability," all other architectures. Constraining test execution; ---------------------------. Some tests can be run only in specific configurations, such as; with debug builds or on particular platforms. Use ``REQUIRES``; and ``UNSUPPORTED`` to control when the test is enabled. Some tests are expected to fail. For example, there may be a known bug; that the test detect. Use ``XFAIL`` to mark a test as an expected failure.; An ``XFAIL`` test will be successful if its execution fails, and; will be a failure if its execution succeeds. .. code-block:: llvm. ; This test will be only enabled in the build with asserts.; ; REQUIRES: asserts; ; This test is disabled when running on Linux.; ; UNSUPPORTED: system-linux; ; This test is expected to fail when targeting PowerPC.; ; XFAIL: target=powerpc{{.*}}. ``REQUIRES`` and ``UNSUPPORTED`` and ``XFAIL`` all accept a comma-separated; list of boolean expressions. The values in each expression may be:. - Features added to ``config.available_features`` by configuration files such as ``lit.cfg``.; String comparison of features is case-sensitive. Furthermore, a boolean expression can; contain any Python regular expression enclosed in ``{{ }}``, in which case the boolean; expression is satisfied if any feature matches the regular expression. Regular; expressions can appear inside an identifier, so for example ``he{{l+}}o`` would match; ``helo``, ``hello``, ``helllo``, and so on.; - The default target triple, preceded by the string ``target=`` (for example,; ``target=x86_64-pc-windows-msvc``). Typically regular expressions are used; to match parts of the triple (for example, ``target={{.*}}-windows{{.*}}``; to match any Windows target triple). | ``REQUIRES`` enables the test if all expressions are true.; | ``UNSUPPORTED`` disables the test if any expression is true.; | ``XFAIL`` expects the test to fail if any expression is true. As a special case, ``XFAIL: *`` is expected to fail everywhere. .. code-block:: llvm. ; This test is disabled when ru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:20461,config,configuration,20461,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configuration']
Modifiability," all public members of class and struct will be; generated. If the '`class+protected`' flag is used, the dictionary for; protected members will also be generated. However, dictionary for; protected constructor and destructor will not be generated. This '; `class+protected` ' flag will help you only for plain protected member; access, but not for virtual function resolution. If you use the '`namespace`' flag, it is recommended to add also:. ``` {.cpp}; #pragma link C++ nestedclass;; #pragma link C++ nestedtypedef;; ```. The behavior of '`class`', '`struct`' and '`namespace`' flag are; identical. Example:. ``` {.cpp}; // some C++ header definition; #ifdef __ROOTCLING__; #pragma link off all class;; #pragma link C++ class A;; #pragma link C++ class B;; #pragma link C++ class C<int>;; #pragma link C++ class+protected D;; #pragma link C++ namespace project1;; #pragma link C++ nestedclass;; #pragma link C++ nestedtypedef;; #endif; ```. The next pragma statement selectively turns on or off the dictionary; generation for global variables and typedef. ``` {.cpp}; #pragma link [C|C++|off] [global|typedef] [name];; ```. Example:. ``` {.cpp}; // some C/C++ header definition; #ifdef __ROOTCLING__; #pragma link off all global;; #pragma link off all typedef;; #pragma link C++ global a;; #pragma link C++ typedef Int_t;; #endif; ```. This pragma statement turns on the dictionary generation for nested; classes and nested typedefs. ``` {.cpp}; #pragma link [C|C++|off] [nestedclass|nestedtypedef];; ```. Example:. ``` {.cpp}; // some C/C++ header definition; #ifdef __ROOTCLING__; #pragma link off all global;; #pragma link off all typedef;; #pragma link C++ global a;; #pragma link C++ typedef Int_t;; #endif; ```. The next pragma statements turn on or off the dictionary generation for; the specified function(s) or member function(s). The list of arguments'; type is optional. If you omit argument types, all function with; specified [`name`] will be affected. If the list of arguments' type i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:27036,variab,variables,27036,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['variab'],['variables']
Modifiability," already installed at; ``/usr/bin/ld.gold``, one option is to simply make that the default by; backing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plugin`` option to; ``ld``. It will not look for an alternate linker without ``-fuse-ld=go",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:2390,plugin,plugin,2390,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin']
Modifiability," also accept the ``-plugin`` option and it's possible to; to install ``LLVMgold.so`` to ``/usr/lib/bfd-plugins`` for a seamless setup.; If you built your own gold, be sure to install the ``ar`` and ``nm-new`` you; built to ``/usr/bin``. Example of link time optimization; ---------------------------------. The following example shows a worked example of the gold plugin mixing LLVM; bitcode and native code. .. code-block:: c. --- a.c ---; #include <stdio.h>. extern void foo1(void);; extern void foo4(void);. void foo2(void) {; printf(""Foo2\n"");; }. void foo3(void) {; foo4();; }. int main(void) {; foo1();; }. --- b.c ---; #include <stdio.h>. extern void foo2(void);. void foo1(void) {; foo2();; }. void foo4(void) {; printf(""Foo4"");; }. .. code-block:: bash. --- command lines ---; $ clang -flto a.c -c -o a.o # <-- a.o is LLVM bitcode file; $ ar q a.a a.o # <-- a.a is an archive with LLVM bitcode; $ clang b.c -c -o b.o # <-- b.o is native object file; $ clang -flto a.a b.o -o main # <-- link with LLVMgold plugin. Gold informs the plugin that foo3 is never referenced outside the IR,; leading LLVM to delete that function. However, unlike in the :ref:`libLTO; example <libLTO-example>` gold does not currently eliminate foo4. Quickstart for using LTO with autotooled projects; =================================================. Once your system ``ld``, ``ar``, and ``nm`` all support LLVM bitcode,; everything is in place for an easy to use LTO build of autotooled projects:. * Follow the instructions :ref:`on how to build LLVMgold.so; <lto-how-to-build>`. * Install the newly built binutils to ``$PREFIX``. * Copy ``Release/lib/LLVMgold.so`` to ``$PREFIX/lib/bfd-plugins/``. * Set environment variables (``$PREFIX`` is where you installed clang and; binutils):. .. code-block:: bash. export CC=""$PREFIX/bin/clang -flto""; export CXX=""$PREFIX/bin/clang++ -flto""; export AR=""$PREFIX/bin/ar""; export NM=""$PREFIX/bin/nm""; export RANLIB=/bin/true #ranlib is not needed, and doesn't support .bc fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:4486,plugin,plugin,4486,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin']
Modifiability," an explicit section specified. Section; information is retained in LLVM IR for targets that make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values are ""tiny"", ""small"", ""kernel"", ""medium"", ""large"".; This may be extended in the future to specify global data layout that; doesn't cleanly fit into a specific code model. By default, global initializers are optimized by assuming that global; variables defined within the module are not modified from their; initial values before the start of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:34137,variab,variables,34137,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability," an extension of the functionality provided by the \ref MathCore. The; current set includes classes and functions for:. * \ref SpecFunc, with all the major functions (Bessel functions, Legendre polynomial, etc..); * \ref StatFunc, Mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse (quantiles).; * Numerical algorithms:; * \ref Integration; * \ref MCIntegration; * \ref Deriv; * \ref RootFinders; * \ref Min1D; * \ref MultiMin; * \ref Interpolation; * \ref FuncApprox, based on Chebyshev polynomials; * \ref Random. The mathematical functions are implemented as a set of free functions in the namespace \em; ROOT::Math. The naming used for the special functions is the same proposed for the C++; standard (see C++ standard extension [proposal document](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1687.pdf)).; The MathMore library is implemented wrapping in C++ the GNU Scientific Library; ([GSL](http://www.gnu.org/software/gsl)). To build MathMore you need to have first GSL; installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar; file of GSL can be downloaded from the [GSL Web site](http://www.gnu.org/software/gsl/#downloading),; or (for version 1.8) from [here](http://seal.web.cern.ch/seal/MathLibs/gsl-1.8.tar.gz).; Windows binaries, compiled using Visual Studio 7.1 can be downloaded from; [this location](http://seal.web.cern.ch/seal/MathLibs/GSL-1.8.zip). MathMore (and its %ROOT CINT dictionary) can be built within %ROOT whenever a GSL library; is found in the system. Optionally the GSL library and header file location can be specified; in the %ROOT configure script with _configure --with-gsl-incdir=... --with-gsl-libdir=..._; MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL; needs to be compiled with the option _--with-pic_.; The source code of MathMore is distributed under the GNU General Public License; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/doc/index.md:1943,config,configure,1943,math/mathmore/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/doc/index.md,1,['config'],['configure']
Modifiability," an unbalanced; release followed by a ""balancing"" retain. .. _arc.optimization.liveness:. Object liveness; ---------------. ARC may not allow a retainable object ``X`` to be deallocated at a; time ``T`` in a computation history if:. * ``X`` is the value stored in a ``__strong`` object ``S`` with; :ref:`precise lifetime semantics <arc.optimization.precise>`, or. * ``X`` is the value stored in a ``__strong`` object ``S`` with; imprecise lifetime semantics and, at some point after ``T`` but; before the next store to ``S``, the computation history features a; load from ``S`` and in some way depends on the value loaded, or. * ``X`` is a value described as being released at the end of the; current full-expression and, at some point after ``T`` but before; the end of the full-expression, the computation history depends; on that value. .. admonition:: Rationale. The intent of the second rule is to say that objects held in normal; ``__strong`` local variables may be released as soon as the value in; the variable is no longer being used: either the variable stops; being used completely or a new value is stored in the variable. The intent of the third rule is to say that return values may be; released after they've been used. A computation history depends on a pointer value ``P`` if it:. * performs a pointer comparison with ``P``,; * loads from ``P``,; * stores to ``P``,; * depends on a pointer value ``Q`` derived via pointer arithmetic; from ``P`` (including an instance-variable or field access), or; * depends on a pointer value ``Q`` loaded from ``P``. Dependency applies only to values derived directly or indirectly from; a particular expression result and does not occur merely because a; separate pointer value dynamically aliases ``P``. Furthermore, this; dependency is not carried by values that are stored to objects. .. admonition:: Rationale. The restrictions on dependency are intended to make this analysis; feasible by an optimizer with only incomplete information about ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:79530,variab,variables,79530,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,4,['variab'],"['variable', 'variables']"
Modifiability," and Concurrency Guide; ==============================================. .. contents::; :local:. Introduction; ============. LLVM supports instructions which are well-defined in the presence of threads and; asynchronous signals. The atomic instructions are designed specifically to provide readable IR and; optimized code generation for the following:. * The C++ ``<atomic>`` header and C ``<stdatomic.h>`` headers. These; were originally added in C++11 and C11. The memory model has been; subsequently adjusted to correct errors in the initial; specification, so LLVM currently intends to implement the version; specified by C++20. (See the `C++20 draft standard; <https://isocpp.org/files/papers/N4860.pdf>`_ or the unofficial; `latest C++ draft <https://eel.is/c++draft/>`_. A `C2x draft; <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3047.pdf>`_ is; also available, though the text has not yet been updated with the; errata corrected by C++20.). * Proper semantics for Java-style memory, for both ``volatile`` and regular; shared variables. (`Java Specification; <http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html>`_). * gcc-compatible ``__sync_*`` builtins. (`Description; <https://gcc.gnu.org/onlinedocs/gcc/_005f_005fsync-Builtins.html>`_). * Other scenarios with atomic semantics, including ``static`` variables with; non-trivial constructors in C++. Atomic and volatile in the IR are orthogonal; ""volatile"" is the C/C++ volatile,; which ensures that every volatile load and store happens and is performed in the; stated order. A couple examples: if a SequentiallyConsistent store is; immediately followed by another SequentiallyConsistent store to the same; address, the first store can be erased. This transformation is not allowed for a; pair of volatile stores. On the other hand, a non-volatile non-atomic load can; be moved across a volatile load freely, but not an Acquire load. This document is intended to provide a guide to anyone either writing a frontend; for LLVM o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:1110,variab,variables,1110,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['variab'],['variables']
Modifiability," and categorize scalar; expressions in loops. It specializes in recognizing general induction; variables, representing them with the abstract and opaque ``SCEV`` class.; Given this analysis, trip counts of loops and other important properties can be; obtained. This analysis is primarily useful for induction variable substitution and; strength reduction. ``scev-aa``: ScalarEvolution-based Alias Analysis; -------------------------------------------------. Simple alias analysis implemented in terms of ``ScalarEvolution`` queries. This differs from traditional loop dependence analysis in that it tests for; dependencies within a single iteration of a loop, rather than dependencies; between different iterations. ``ScalarEvolution`` has a more complete understanding of pointer arithmetic; than ``BasicAliasAnalysis``' collection of ad-hoc analyses. ``stack-safety``: Stack Safety Analysis; ---------------------------------------. The ``StackSafety`` analysis can be used to determine if stack allocated; variables can be considered safe from memory access bugs. This analysis' primary purpose is to be used by sanitizers to avoid unnecessary; instrumentation of safe variables. Transform Passes; ================. This section describes the LLVM Transform Passes. ``adce``: Aggressive Dead Code Elimination; ------------------------------------------. ADCE aggressively tries to eliminate code. This pass is similar to :ref:`DCE; <passes-dce>` but it assumes that values are dead until proven otherwise. This; is similar to :ref:`SCCP <passes-sccp>`, except applied to the liveness of; values. ``always-inline``: Inliner for ``always_inline`` functions; ----------------------------------------------------------. A custom inliner that handles only functions that are marked as ""always; inline"". ``argpromotion``: Promote 'by reference' arguments to scalars; -------------------------------------------------------------. This pass promotes ""by reference"" arguments to be ""by value"" arguments. I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:11533,variab,variables,11533,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variables']
Modifiability," and destroy objects of their wrapped type; (cf. `CreateValue()`, `CreateObject()`, `GetDeleter()` methods).; Existing objects in memory can be bound to fields (cf. `BindValue()` method). On the ""on-disk"" side, fields know about the possible column representations of their wrapped type.; Upon connecting a field to a page source or page sink,; fields create `RColumn` objects and register them with the page source/sink.; When reading and writing data, the field maps the in-memory information of an object to read/write calls on its columns.; For instance, when writing a `std::vector<float>`,; the field writes to an index column (storing information about the size of the vector).; Its subfield writes the actual values to a float column. During its lifetime, a field undergoes the following possible state transitions:; ```; [*] --> Unconnected --> ConnectedToSink ----; | | |; | --> ConnectedToSource ---> [*]; | |; -------------------------------; ```. The RField class hierarchy is fixed and not meant to be extended by user classes. ### RField::RValue; The `RValue` class makes the connection between an object in memory and the corresponding field used for I/O.; It contains a shared pointer of the object, i.e. RNTuple and the application share ownership of objects.; The object in an RValue can either be created by an RNTuple field (cf. `RField<T>::CreateValue()` method); or provided by the application (cf. `RField<T>::BindValue()` method).; Raw pointers can be passed with the understanding that the raw pointer is owned by the application and are kept alive during I/O operations. `RValue` objects can only be created from fields, and they are linked to their originating field. ### RNTupleModel; The RNTupleModel represents a data schema as a tree of fields.; The model owns its fields.; A model undergoes the following possible state transitions:; ```; [*] ---> Building / --> Frozen --; Updating | |; ^ | |; |------------- v; ----------------->[*]; ```; During the building/updati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:9510,extend,extended,9510,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['extend'],['extended']
Modifiability," and maximum set by the; user on the `TGraph2D`. This problem was reported; [here](http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=16937&p=72314#p72314). ### TPaletteAxis. - The histogram Z axis title is now painted along the palette axis. ### TAxis. - The Axis has a new public bit `TAxis::kCanExtend`, which control the axis extensions (for example in case of time axis) and used to; replace the old bit `TH1::kCanRebin` (see below).; Note that this bit is automatically set when the axis has labels associated to each bin. In this case the axis becomes alphanumeric and; there is no more relation to the observed quantities. Note that when an axis is alphanumeric the mean and the rms of the histograms are not anymore; coputed and they are set to zero. ### TH1. - The bit `TH1::kCanRebin` used to extend the histogram axes is now deprecated. The bit exists still in ROOT 6.0 but it has no effect.; One should use now the new function `TH1::SetCanExtend(..)` passing the axis (using the appropriate enumeration), which needs to be extended.; In addition to extend each axis individually, the function can be used also to enable/disable extension for all axes.; For example `TH1::SetCanExtend(TH1::kXaxis)` will make extendable only the X axis; `TH1::SetCanExtend(TH1::kAllAxes)` will; make extendable all the axes (this is the same functionality of the previous function `SetBit(TH1::kCanRebin)` and; `TH1::SetCanExtend(TH1::kNoAxis)` will remove the extendable functionality to all the axes (equivalent to the old `ResetBit(TH1::kCanRebin)`).; The functionality of `TestBit(TH1::kCanRebin)` is now replaced by `TH1::CanExtendAllAxis()`. - An histogram filled with weights different than one has now automatically the sum of the weight squared stored inside, without the need to call anymore; `TH1::Sumw2()`. As a consequences an histogram filled with weights will always draw the errors by default. If one desire to continue having the histogram drawn; without the errors, one should use the `hist",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:7350,extend,extended,7350,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['extend'],['extended']
Modifiability," and may have a; greater performance impact since pointer reads are more frequent than writes. .. _plugin:. .. _builtin-gc-strategies:. Built In GC Strategies; ======================. LLVM includes built in support for several varieties of garbage collectors. The Shadow Stack GC; ----------------------. To use this collector strategy, mark your functions with:. .. code-block:: c++. F.setGC(""shadow-stack"");. Unlike many GC algorithms which rely on a cooperative code generator to compile; stack maps, this algorithm carefully maintains a linked list of stack roots; [:ref:`Henderson2002 <henderson02>`]. This so-called ""shadow stack"" mirrors the; machine stack. Maintaining this data structure is slower than using a stack map; compiled into the executable as constant data, but has a significant portability; advantage because it requires no special support from the target code generator,; and does not require tricky platform-specific code to crawl the machine stack. The tradeoff for this simplicity and portability is:. * High overhead per function call. * Not thread-safe. Still, it's an easy way to get started. After your compiler and runtime are up; and running, writing a :ref:`plugin <plugin>` will allow you to take advantage; of :ref:`more advanced GC features <collector-algos>` of LLVM in order to; improve performance. The shadow stack doesn't imply a memory allocation algorithm. A semispace; collector or building atop ``malloc`` are great places to start, and can be; implemented with very little code. When it comes time to collect, however, your runtime needs to traverse the stack; roots, and for this it needs to integrate with the shadow stack. Luckily, doing; so is very simple. (This code is heavily commented to help you understand the; data structure, but there are only 20 lines of meaningful code.). .. code-block:: c++. /// The map for a single function's stack frame. One of these is; /// compiled as constant data into the executable for each function.; ///; /// S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:16723,portab,portability,16723,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['portab'],['portability']
Modifiability," and the top-level ``VALUE_SYMTAB_BLOCK`` may only contain; ``FNENTRY`` records. MODULE_CODE_TRIPLE Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[TRIPLE, ...string...]``. The ``TRIPLE`` record (code 2) contains a variable number of values representing; the bytes of the ``target triple`` specification string. MODULE_CODE_DATALAYOUT Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DATALAYOUT, ...string...]``. The ``DATALAYOUT`` record (code 3) contains a variable number of values; representing the bytes of the ``target datalayout`` specification string. MODULE_CODE_ASM Record; ^^^^^^^^^^^^^^^^^^^^^^. ``[ASM, ...string...]``. The ``ASM`` record (code 4) contains a variable number of values representing; the bytes of ``module asm`` strings, with individual assembly blocks separated; by newline (ASCII 10) characters. .. _MODULE_CODE_SECTIONNAME:. MODULE_CODE_SECTIONNAME Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[SECTIONNAME, ...string...]``. The ``SECTIONNAME`` record (code 5) contains a variable number of values; representing the bytes of a single section name string. There should be one; ``SECTIONNAME`` record for each section name referenced (e.g., in global; variable or function ``section`` attributes) within the module. These records; can be referenced by the 1-based index in the *section* fields of ``GLOBALVAR``; or ``FUNCTION`` records. MODULE_CODE_DEPLIB Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DEPLIB, ...string...]``. The ``DEPLIB`` record (code 6) contains a variable number of values representing; the bytes of a single dependent library name string, one of the libraries; mentioned in a ``deplibs`` declaration. There should be one ``DEPLIB`` record; for each library name referenced. MODULE_CODE_GLOBALVAR Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[GLOBALVAR, strtab offset, strtab size, pointer type, isconst, initid, linkage, alignment, section, visibility, threadlocal, unnamed_addr, externally_initialized, dllstorageclass, comdat, attributes, preemptionspecifier]``. The ``GLOBALVAR`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:26214,variab,variable,26214,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability," and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3380,extend,extendable,3380,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['extend'],['extendable']
Modifiability," and we sort it in different ways:; ``` {.cpp}; root [0] using doubles = std::vector<double>;; root [1] auto pVec = [](const doubles& v){for (auto&& x:v) cout << x << endl;};; root [2] doubles v{0,3,5,4,1,2};; root [3] pVec(v);; 0; 3; 5; 4; 1; 2; root [4] std::sort(v.begin(),v.end());; root [5] pVec(v);; 0; 1; 2; 3; 4; 5; root [6] std::sort(v.begin(),v.end(),[](double a, double b){return a>b;});; root [7] pVec(v);; 5; 4; 3; 2; 1; 0; ```; Or, if you prefer random number generation:; ``` {.cpp}; root [0] std::default_random_engine generator;; root [1] std::normal_distribution<double> distribution(0.,1.);; root [2] distribution(generator); (std::normal_distribution<double>::result_type) -1.219658e-01; root [3] distribution(generator); (std::normal_distribution<double>::result_type) -1.086818e+00; root [4] distribution(generator); (std::normal_distribution<double>::result_type) 6.842899e-01; ```; Impressive isn't it?. ## ROOT as function plotter ##; Using one of ROOT's powerful classes, here `TF1` [^2], will allow us to; display a function of one variable, *x*. Try the following:. ``` {.cpp}; root [11] TF1 f1(""f1"",""sin(x)/x"",0.,10.);; root [12] f1.Draw();; ```. `f1` is an instance of a TF1 class, the arguments are used; in the constructor; the first one of type string is a name to be entered; in the internal ROOT memory management system, the second string type; parameter defines the function, here `sin(x)/x`, and the two parameters; of type double define the range of the variable *x*. The `Draw()`; method, here without any parameters, displays the function in a window; which should pop up after you typed the above two lines. A slightly extended version of this example is the definition of a; function with parameters, called `[0]`, `[1]` and so on in the ROOT; formula syntax. We now need a way to assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; roo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:3249,variab,variable,3249,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['variab'],['variable']
Modifiability," approaches have typically been seen as a ; tradeoff between performance and portability. On a deeper level, however, ; there are two reasons that optimal system performance may be obtained by a; system somewhere in between these two extremes: Dynamic application ; behavior and social constraints. From a technical perspective, pure static compilation cannot ever give ; optimal performance in all cases, because applications have varying dynamic; behavior that the static compiler cannot take into consideration. Even ; compilers that support profile guided optimization generate poor code in ; the real world, because using such optimization tunes that application ; to one particular usage pattern, whereas real programs (as opposed to ; benchmarks) often have several different usage patterns. On a social level, static compilation is a very shortsighted solution to ; the performance problem. Instruction set architectures (ISAs) continuously ; evolve, and each implementation of an ISA (a processor) must choose a set ; of tradeoffs that make sense in the market context that it is designed for. ; With every new processor introduced, the vendor faces two fundamental ; problems: First, there is a lag time between when a processor is introduced ; to when compilers generate quality code for the architecture. Secondly, ; even when compilers catch up to the new architecture there is often a large ; body of legacy code that was compiled for previous generations and will ; not or can not be upgraded. Thus a large percentage of code running on a ; processor may be compiled quite sub-optimally for the current ; characteristics of the dynamic execution environment. For these reasons, LLVM has been designed from the beginning as a long-term ; solution to these problems. Its design allows the large body of platform ; independent, static, program optimizations currently in compilers to be ; reused unchanged in their current form. It also provides important static ; type information to ena",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt:1798,evolve,evolve,1798,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt,1,['evolve'],['evolve']
Modifiability," are already using the module):. .. code-block:: console. % mount -t binfmt_misc none /proc/sys/fs/binfmt_misc; % echo ':llvm:M::BC::/path/to/lli:' > /proc/sys/fs/binfmt_misc/register; % chmod u+x hello.bc (if needed); % ./hello.bc. This allows you to execute LLVM bitcode files directly. On Debian, you can also; use this command instead of the 'echo' command above:. .. code-block:: console. % sudo update-binfmts --install llvm /path/to/lli --magic 'BC'. .. _Program Layout:; .. _general layout:. Directory Layout; ================. One useful source of information about the LLVM source base is the LLVM `doxygen; <http://www.doxygen.org/>`_ documentation available at; `<https://llvm.org/doxygen/>`_. The following is a brief introduction to code; layout:. ``llvm/cmake``; --------------; Generates system build files. ``llvm/cmake/modules``; Build configuration for llvm user defined options. Checks compiler version and; linker flags. ``llvm/cmake/platforms``; Toolchain configuration for Android NDK, iOS systems and non-Windows hosts to; target MSVC. ``llvm/examples``; -----------------. - Some simple examples showing how to use LLVM as a compiler for a custom; language - including lowering, optimization, and code generation. - Kaleidoscope Tutorial: Kaleidoscope language tutorial run through the; implementation of a nice little compiler for a non-trivial language; including a hand-written lexer, parser, AST, as well as code generation; support using LLVM- both static (ahead of time) and various approaches to; Just In Time (JIT) compilation.; `Kaleidoscope Tutorial for complete beginner; <https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html>`_. - BuildingAJIT: Examples of the `BuildingAJIT tutorial; <https://llvm.org/docs/tutorial/BuildingAJIT1.html>`_ that shows how LLVM’s; ORC JIT APIs interact with other parts of LLVM. It also, teaches how to; recombine them to build a custom JIT that is suited to your use-case. ``llvm/include``; ----------------. Public he",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:34334,config,configuration,34334,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configuration']
Modifiability," are ignored in the training (but are included for testing and performance evaluation). nkNN No 20 − Number of k-nearest neighbors. BalanceDepth No 6 − Binary tree balance depth. ScaleFrac No 0.8 − Fraction of events used to compute variable width. SigmaFact No 1 − Scale factor for sigma in Gaussian kernel. Kernel No Gaus − Use polynomial (=Poln) or Gaussian (=Gaus) kernel. Trim No False − Use equal number of signal and background events. UseKernel No False − Use polynomial kernel weight. UseWeight No True − Use weight to count kNN events. UseLDA No False − Use local linear discriminant - experimental feature. Configuration options for MVA method :. Configuration options reference for MVA method: BDT. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NTrees No 800 − Number of trees in the forest. MaxDepth No 3 − Max depth of the decision tree allowed. MinNodeSize No 5% − Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%). nCuts No 20 − Number of grid points in variable range used in finding optimal cut in node splitting. BoostType No AdaBoost AdaBoost, RealAdaBoost, Bagging, AdaBoostR2, Grad Boosting type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:11278,variab,variable,11278,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variable']
Modifiability," are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:8332,flexible,flexible,8332,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['flexible'],['flexible']
Modifiability," are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18974,plugin,plugin,18974,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,['plugin'],['plugin']
Modifiability," are useful during development, it is often more useful to; refer to optimization remarks post-compilation, typically during performance; analysis. For that, LLVM can serialize the remarks produced for each compilation unit to; a file that can be consumed later. By default, the format of the serialized remarks is :ref:`YAML; <yamlremarks>`, and it can be accompanied by a :ref:`section <remarkssection>`; in the object files to easily retrieve it. :doc:`llc <CommandGuide/llc>` and :doc:`opt <CommandGuide/opt>` support the; following options:. ``Basic options``. .. option:: -pass-remarks-output=<filename>. Enables the serialization of remarks to a file specified in <filename>. By default, the output is serialized to :ref:`YAML <yamlremarks>`. .. option:: -pass-remarks-format=<format>. Specifies the output format of the serialized remarks. Supported formats:. * :ref:`yaml <yamlremarks>` (default); * :ref:`yaml-strtab <yamlstrtabremarks>`; * :ref:`bitstream <bitstreamremarks>`. ``Content configuration``. .. option:: -pass-remarks-filter=<regex>. Only passes whose name match the given (POSIX) regular expression will be; serialized to the final output. .. option:: -pass-remarks-with-hotness. With PGO, include profile count in optimization remarks. .. option:: -pass-remarks-hotness-threshold. The minimum profile count required for an optimization remark to be; emitted. Other tools that support remarks:. :program:`llvm-lto`. .. option:: -lto-pass-remarks-output=<filename>; .. option:: -lto-pass-remarks-filter=<regex>; .. option:: -lto-pass-remarks-format=<format>; .. option:: -lto-pass-remarks-with-hotness; .. option:: -lto-pass-remarks-hotness-threshold. :program:`gold-plugin` and :program:`lld`. .. option:: -opt-remarks-filename=<filename>; .. option:: -opt-remarks-filter=<regex>; .. option:: -opt-remarks-format=<format>; .. option:: -opt-remarks-with-hotness. Serialization modes; ===================. There are two modes available for serializing remarks:. ``Separate``. In ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:2958,config,configuration,2958,interpreter/llvm-project/llvm/docs/Remarks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst,1,['config'],['configuration']
Modifiability," are; processed. ``print-module``: Print module to stderr; ----------------------------------------. This pass simply prints out the entire module when it is executed. ``regions``: Detect single entry single exit regions; ----------------------------------------------------. The ``RegionInfo`` pass detects single entry single exit regions in a function,; where a region is defined as any subgraph that is connected to the remaining; graph at only two spots. Furthermore, a hierarchical region tree is built. .. _passes-scalar-evolution:. ``scalar-evolution``: Scalar Evolution Analysis; -----------------------------------------------. The ``ScalarEvolution`` analysis can be used to analyze and categorize scalar; expressions in loops. It specializes in recognizing general induction; variables, representing them with the abstract and opaque ``SCEV`` class.; Given this analysis, trip counts of loops and other important properties can be; obtained. This analysis is primarily useful for induction variable substitution and; strength reduction. ``scev-aa``: ScalarEvolution-based Alias Analysis; -------------------------------------------------. Simple alias analysis implemented in terms of ``ScalarEvolution`` queries. This differs from traditional loop dependence analysis in that it tests for; dependencies within a single iteration of a loop, rather than dependencies; between different iterations. ``ScalarEvolution`` has a more complete understanding of pointer arithmetic; than ``BasicAliasAnalysis``' collection of ad-hoc analyses. ``stack-safety``: Stack Safety Analysis; ---------------------------------------. The ``StackSafety`` analysis can be used to determine if stack allocated; variables can be considered safe from memory access bugs. This analysis' primary purpose is to be used by sanitizers to avoid unnecessary; instrumentation of safe variables. Transform Passes; ================. This section describes the LLVM Transform Passes. ``adce``: Aggressive Dead Code Eliminat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:10833,variab,variable,10833,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variable']
Modifiability," arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. Here we're first creating the variable, giving it the scope (``SP``),; the name, source location, type, and since it's an argument, the argument; index. Next, we create an ``lvm.dbg.declare`` call to indicate at the IR; level that we've got a variable in an alloca (and it gives a starting; location for the variable), and setting a source location for the; beginning of the scope on the declare. One interesting thing to note at this point is that various debuggers have; assumptions based on how code and debug information was generated for them; in the past. In this case we need to do a little bit of a hack to avoid; generating line information for the function prologue so that the debugger; knows to skip over those instructions when setting a breakpoint. So in; ``FunctionAST::CodeGen`` we add some more lines:. .. code-block:: c++. // Unset the location for the prologue emission (leading instructions with no; // location in a function are considered part of the prologue and the debugger; // will run past them when breaking on a function); KSDbgInfo.emitLocation(nullptr);. and then emit a new location when we actually start generating code for the; body of the function:. .. code-block:: c++. KSDbgInfo.emitLocation(Body.get());. With this we have enough debug information to set breakpoints in functions,; print out argument variables, and call functions. Not too bad for just a; few simple lines of code!. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; debug information. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter9/toy.cpp; :language: c++. `Next: Conclusion and other useful LLVM tidbits <LangImpl10.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:15381,variab,variables,15381,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,3,"['config', 'enhance', 'variab']","['config', 'enhanced', 'variables']"
Modifiability," arr = [ 1, 2, 3 ]; vs. var arr = [1, 2, 3];; f({a : 1, b : 2, c : 3}); f({a: 1, b: 2, c: 3});. .. _SpacesInLineCommentPrefix:. **SpacesInLineCommentPrefix** (``SpacesInLineComment``) :versionbadge:`clang-format 13` :ref:`¶ <SpacesInLineCommentPrefix>`; How many spaces are allowed at the start of a line comment. To disable the; maximum set it to ``-1``, apart from that the maximum takes precedence; over the minimum. .. code-block:: c++. Minimum = 1; Maximum = -1; // One space is forced. // but more spaces are possible. Minimum = 0; Maximum = 0; //Forces to start every comment directly after the slashes. Note that in line comment sections the relative indent of the subsequent; lines is kept, that means the following:. .. code-block:: c++. before: after:; Minimum: 1; //if (b) { // if (b) {; // return true; // return true;; //} // }. Maximum: 0; /// List: ///List:; /// - Foo /// - Foo; /// - Bar /// - Bar. This option has only effect if ``ReflowComments`` is set to ``true``. Nested configuration flags:. Control of spaces within a single line comment. * ``unsigned Minimum`` The minimum number of spaces at the start of the comment. * ``unsigned Maximum`` The maximum number of spaces at the start of the comment. .. _SpacesInParens:. **SpacesInParens** (``SpacesInParensStyle``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParens>`; Defines in which cases spaces will be inserted after ``(`` and before; ``)``. Possible values:. * ``SIPO_Never`` (in configuration: ``Never``); Never put a space in parentheses. .. code-block:: c++. void f() {; if(true) {; f();; }; }. * ``SIPO_Custom`` (in configuration: ``Custom``); Configure each individual space in parentheses in; `SpacesInParensOptions`. .. _SpacesInParensOptions:. **SpacesInParensOptions** (``SpacesInParensCustom``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParensOptions>`; Control of individual spaces in parentheses. If ``SpacesInParens`` is set to ``Custom``, use this to specify; how each individual space in par",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:125774,config,configuration,125774,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," arrays A and B point to; disjointed memory locations. If arrays A and B overlap, then the scalar version; of the loop is executed. .. code-block:: c++. void bar(float *A, float* B, float K, int n) {; for (int i = 0; i < n; ++i); A[i] *= B[i] + K;; }. Reductions; ^^^^^^^^^^. In this example the ``sum`` variable is used by consecutive iterations of; the loop. Normally, this would prevent vectorization, but the vectorizer can; detect that 'sum' is a reduction variable. The variable 'sum' becomes a vector; of integers, and at the end of the loop the elements of the array are added; together to create the correct result. We support a number of different; reduction operations, such as addition, multiplication, XOR, AND and OR. .. code-block:: c++. int foo(int *A, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); sum += A[i] + 5;; return sum;; }. We support floating point reduction operations when `-ffast-math` is used. Inductions; ^^^^^^^^^^. In this example the value of the induction variable ``i`` is saved into an; array. The Loop Vectorizer knows to vectorize induction variables. .. code-block:: c++. void bar(float *A, int n) {; for (int i = 0; i < n; ++i); A[i] = i;; }. If Conversion; ^^^^^^^^^^^^^. The Loop Vectorizer is able to ""flatten"" the IF statement in the code and; generate a single stream of instructions. The Loop Vectorizer supports any; control flow in the innermost loop. The innermost loop may contain complex; nesting of IFs, ELSEs and even GOTOs. .. code-block:: c++. int foo(int *A, int *B, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); if (A[i] > B[i]); sum += A[i] + 5;; return sum;; }. Pointer Induction Variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. This example uses the ""accumulate"" function of the standard c++ library. This; loop uses C++ iterators, which are pointers, and not integer indices.; The Loop Vectorizer detects pointer induction variables and can vectorize; this loop. This feature is important because many C++ programs use itera",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:6560,variab,variable,6560,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['variab'],['variable']
Modifiability," as `llvm_blake3_hasher_finalize`, but with an additional `seek`; parameter for the starting byte position in the output stream. To; efficiently stream a large output without allocating memory, call this; function in a loop, incrementing `seek` by the output length each time. ---. ```c; void llvm_blake3_hasher_reset(; llvm_blake3_hasher *self);; ```. Reset the hasher to its initial state, prior to any calls to; `llvm_blake3_hasher_update`. Currently this is no different from calling; `llvm_blake3_hasher_init` or similar again. However, if this implementation gains; multithreading support in the future, and if `llvm_blake3_hasher` holds (optional); threading resources, this function will reuse those resources. # Building. This implementation is just C and assembly files. ## x86. Dynamic dispatch is enabled by default on x86. The implementation will; query the CPU at runtime to detect SIMD support, and it will use the; widest instruction set available. By default, `blake3_dispatch.c`; expects to be linked with code for five different instruction sets:; portable C, SSE2, SSE4.1, AVX2, and AVX-512. For each of the x86 SIMD instruction sets, four versions are available:; three flavors of assembly (Unix, Windows MSVC, and Windows GNU) and one; version using C intrinsics. The assembly versions are generally; preferred. They perform better, they perform more consistently across; different compilers, and they build more quickly. On the other hand, the; assembly versions are x86\_64-only, and you need to select the right; flavor for your target platform. ## ARM NEON. The NEON implementation is enabled by default on AArch64, but not on; other ARM targets, since not all of them support it. To enable it, set; `BLAKE3_USE_NEON=1`. To explicitiy disable using NEON instructions on AArch64, set; `BLAKE3_USE_NEON=0`. ## Other Platforms. The portable implementation should work on most other architectures. # Multithreading. The implementation doesn't currently support multithreading.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:7272,portab,portable,7272,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,2,['portab'],['portable']
Modifiability," as appropriate. #. Apply the process to the following projects, with a suitable delay between; each (at least 4 weeks after the first change, at least 2 weeks subsequently); to allow gathering further feedback.; This list should exclude projects that must adhere to an externally defined; standard e.g. libcxx.; The list is roughly in chronological order of renaming.; Some items may not make sense to rename individually - it is expected that; this list will change following experimentation:. * TableGen; * llvm/tools; * clang-tools-extra; * clang; * ARM backend; * AArch64 backend; * AMDGPU backend; * ARC backend; * AVR backend; * BPF backend; * Hexagon backend; * Lanai backend; * MIPS backend; * NVPTX backend; * PowerPC backend; * RISC-V backend; * Sparc backend; * SystemZ backend; * WebAssembly backend; * X86 backend; * XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old variable name rule from the policy page. #. Repeat many of the steps in the sequence, using a script to expand acronyms. References; ==========. .. [LLDB] LLDB Coding Conventions https://llvm.org/svn/llvm-project/lldb/branches/release_39/www/lldb-coding-conventions.html; .. [Google] Google C++ Style Guide https://google.github.io/styleguide/cppguide.html#Variable_Names; .. [WebKit] WebKit Code Style Guidelines https://webkit.org/code-style-guidelines/#names; .. [Qt] Qt Coding Style https://wiki.qt.io/Qt_Coding_Style#Declaring_variables; .. [Rust] Rust naming conventions https://doc.rust-lang.org/1.0.0/style/style/naming/README.html; .. [Swift] Swift API Design Guidelines https://swift.org/documentation/api-design-guidelines/#general-conventions; .. [Python] Style Guide for Python Code https://www.python.org/dev/peps/pep-0008/#function-and-variable-names; .. [Mozilla] Mozilla Coding style: Prefixes https://firefox-source-docs.mozilla.org/tools/lint/coding-style/coding_style_cpp.html#prefixes; .. [S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:13158,variab,variable,13158,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability, as member-declaration; Clang 2.9. 1804; CD4; Partial specialization and friendship; Clang 2.7. 1805; CD4; Conversions of array operands in conditional-expressions; Unknown. 1806; CD4; Virtual bases and move-assignment; Unknown. 1807; CD4; Order of destruction of array elements after an exception; Clang 3.0. 1808; drafting; Constructor templates vs default constructors; Not resolved. 1809; CD4; Narrowing and template argument deduction; Unknown. 1810; CD4; Invalid ud-suffixes; Unknown. 1811; CD4; Lookup of deallocation function in a virtual destructor definition; Unknown. 1812; C++17; Omission of template in a typename-specifier; No. 1813; CD4; Direct vs indirect bases in standard-layout classes; Clang 7. 1814; CD4; Default arguments in lambda-expressions; Yes. 1815; CD4; Lifetime extension in aggregate initialization; No. 1816; CD4; Unclear specification of bit-field values; Unknown. 1817; drafting; Linkage specifications and nested scopes; Not resolved. 1818; CD6; Visibility and inherited language linkage; Unknown. 1819; CD4; Acceptable scopes for definition of partial specialization; Unknown. 1820; CD6; Qualified typedef names; Unknown. 1821; CD6; Qualified redeclarations in a class member-specification; Clang 2.9. 1822; CD6; Lookup of parameter names in lambda-expressions; Yes. 1823; CD4; String literal uniqueness in inline functions; Unknown. 1824; CD4; Completeness of return type vs point of instantiation; Unknown. 1825; C++17; Partial ordering between variadic and non-variadic function templates; Unknown. 1826; NAD; const floating-point in constant expressions; Unknown. 1827; drafting; Reference binding with ambiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declar,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:123452,inherit,inherited,123452,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inherit'],['inherited']
Modifiability," at 0x7f7ddab8c084 thread T0; #0 0x403c8c in main example_UseAfterFree.cc:4; #1 0x7f7ddabcac4d in __libc_start_main ??:0; ... Note that on macOS you may need to run ``dsymutil`` on your binary to have the; file\:line info in the AddressSanitizer reports. Additional Checks; =================. Initialization order checking; -----------------------------. AddressSanitizer can optionally detect dynamic initialization order problems,; when initialization of globals defined in one translation unit uses; globals defined in another translation unit. To enable this check at runtime,; you should set environment variable; ``ASAN_OPTIONS=check_initialization_order=1``. Note that this option is not supported on macOS. Stack Use After Return (UAR); ----------------------------. AddressSanitizer can optionally detect stack use after return problems.; This is available by default, or explicitly; (``-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for detection, but it can be disable via the; runtime environment (``ASAN_OPTIONS=detect_stack_use_after_return=0``).; * ``always``: Enables detection of UAR errors in all cases. (reduces code; size, but not as much as ``never``). Memory leak detection; ---------------------. For more information on leak detector in AddressSanitizer, see; :doc:`LeakSanitizer`. The leak detection is turned on by default on Linux,; and can be enabled using ``ASAN_OPTIONS=detect_leaks=1`` on macOS;; however, it is not yet supported on other platforms. Issue Suppression",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:5978,variab,variable,5978,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['variab'],['variable']
Modifiability," attached columns.; The subfield corresponds to the inner type `T`. ### User-defined enums. User-defined enums are stored as a leaf field with a single subfield named `_0`.; The parent field has no attached columns.; The subfield corresponds to the integer type the underlies the enum.; Unscoped and scoped enums are supported as long as the enum has a dictionary. ### User-defined classes. User-defined classes might behave either as a record or as a collection of elements of a given type.; The behavior depends on whether the class has an associated collection proxy. #### Regular class / struct. User defined C++ classes are supported with the following limitations; - The class must have a dictionary; - All persistent members and base classes must be themselves types with RNTuple I/O support; - Transient members must be marked, e.g. by a `//!` comment; - The class must not be in the `std` namespace; - The class must be empty or splittable (e.g., the class must not provide a custom streamer); - There is no support for polymorphism,; i.e. a field of class `A` cannot store class `B` that derives from `A`; - Virtual inheritance is unsupported. User classes are stored as a record parent field with no attached columns.; Direct base classes and persistent members are stored as subfields with their respective types.; The field name of member subfields is identical to the C++ field name.; The field name of base class subfields are numbered and preceded by a colon (`:`), i.e. `:_0`, `:_1`, ... #### Classes with an associated collection proxy. User classes that specify a collection proxy behave as collections of a given value type. The on-disk representation of non-associative collections is identical to a `std::vector<T>`, using two fields:; - Collection parent field whose principal column is of type `(Split)Index[64|32]`.; - Child field of type `T`, which must be a type with RNTuple I/O support. The on-disk representation of associative collections is identical to a `std::map<K,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:45157,polymorphi,polymorphism,45157,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['polymorphi'],['polymorphism']
Modifiability," attribute describing the parameter's name. *Examples using call site entries and related attributes are found in Appendix; D.15.*. .. _amdgpu-dwarf-lexical-block-entries:. A.3.5 Lexical Block Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section is the same as DWARF Version 5 section 3.5. A.4 Data Object and Object List Entries; ---------------------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 4 sections. .. _amdgpu-dwarf-data-object-entries:. A.4.1 Data Object Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~. Program variables, formal parameters and constants are represented by debugging; information entries with the tags ``DW_TAG_variable``,; ``DW_TAG_formal_parameter`` and ``DW_TAG_constant``, respectively. *The tag DW_TAG_constant is used for languages that have true named constants.*. The debugging information entry for a program variable, formal parameter or; constant may have the following attributes:. 1. A ``DW_AT_location`` attribute, whose value is a DWARF expression E that; describes the location of a variable or parameter at run-time. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language thread of execution upon which; the user is focused, if any. The result of the evaluation is the location; description of the base of the data object. See :ref:`amdgpu-dwarf-control-flow-operations` for special evaluation rules; used by the ``DW_OP_call*`` operations. .. note::. Delete the description of how the ``DW_OP_call*`` operations evaluate a; ``DW_AT_location`` attribute as that is now described in the operations. .. note::. See the discussion about the ``DW_AT_location`` attribute in the; ``DW_OP_call*`` operat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:172686,variab,variable,172686,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability," attributes - to proxy requests to the relevant; ""config owner"" in a timely manner. Most issues with a buildbot should be addressed directly with a bot owner; via email. Please CC `Galina Kistanova <mailto:gkistanova@gmail.com>`_. Steps To Add Builder To LLVM Buildbot; =====================================; Volunteers can provide their build machines to work as build workers to; public LLVM Buildbot. Here are the steps you can follow to do so:. #. Check the existing build configurations to make sure the one you are; interested in is not covered yet or gets built on your computer much; faster than on the existing one. We prefer faster builds so developers; will get feedback sooner after changes get committed. #. The computer you will be registering with the LLVM buildbot; infrastructure should have all dependencies installed and be able to; build your configuration successfully. Please check what degree; of parallelism (-j param) would give the fastest build. You can build; multiple configurations on one computer. #. Install buildbot-worker (currently we are using buildbot version 2.8.4).; This specific version can be installed using ``pip``, with a command such; as ``pip3 install buildbot-worker==2.8.4``. #. Create a designated user account, your buildbot-worker will be running under,; and set appropriate permissions. #. Choose the buildbot-worker root directory (all builds will be placed under; it), buildbot-worker access name and password the build master will be using; to authenticate your buildbot-worker. #. Create a buildbot-worker in context of that buildbot-worker account. Point it; to the **lab.llvm.org** port **9994** (see `Buildbot documentation,; Creating a worker; <http://docs.buildbot.net/current/tutorial/firstrun.html#creating-a-worker>`_; for more details) by running the following command:. .. code-block:: bash. $ buildbot-worker create-worker <buildbot-worker-root-directory> \; lab.llvm.org:9994 \; <buildbot-worker-access-name> \; <buildbot-worker-ac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:2989,config,configurations,2989,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['configurations']
Modifiability," automatically using; long long or unsigned long long as the; underlying type of the constant; however, Clang fails to diagnose the; extension in C89 mode with such constants.; . 299; C99; Is cabs() a type-generic macro?; N/A. 300; NAD; Translation-time expresssion evaluation; Yes. 301; NAD; Meaning of FE_* macros in <fenv.h>; Yes. 302; C99; 6.10.2p5: Adding underscore to portable include file name character set; Yes. 303; C99; 6.10p2: Breaking up the very long sentence describing preprocessing directive; Yes. 304; C99; Clarifying illegal tokens in #if directives; Yes. 305; C99; 6.10.1p3: Clarifying handling of keywords in #if directives; Yes. 306; C99; 6.10.3p9: Clarifying that rescanning applies to object-like macros; Yes. 307; C99; 6.10.3p10: Clarifiying arguments vs. parameters; Yes. 308; C99; Clarify that source files et al. need not be ""files""; Yes. 309; C99; Clarifying trigraph substitution; Yes. 310; C99; Add non-corner case example of trigraphs; Yes. 311; C99; Definition of variably modified types; Yes. 312; C99; Meaning of ""known constant size""; Yes. 313; NAD; Incomplete arrays of VLAs; Yes. 314; NAD; Cross-translation-unit tagged type compatibility; Unknown. 315; C99; Implementation-defined bit-field types; Yes. 316; NAD; Unprototyped function types; Yes. 317; NAD; Function definitions with empty parentheses; Yes. 318; C99; (double)0.1f with FLT_EVAL_METHOD being 2; Unknown. 319; NAD; printf(""%a"", 1.0) and trailing zeros; N/A. 320; C99; Scope of variably modified type; Yes. 321; C99; Wide character code values for members of the basic character set; Yes. 322; C99; Problem with TC2 Change #67 (Add perror to the list defining byte input/output functions); N/A. 323; C99; Potential problems with TC2 #34, #35, and #36; N/A. 324; C99; Tokenization obscurities; Yes. 325; NAD; strerror(); N/A. 326; C99; asctime(); N/A. 327; C99; Italicize definition of variable length array type, add forward references; Yes. 328; C99; String literals in compound literal initializ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:19029,variab,variably,19029,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,1,['variab'],['variably']
Modifiability," autorelease the receiver. The other limit permits some amount of; optimization. The phrase ""derived from"" is intended to encompass the results; both of pointer transformations, such as casts and arithmetic, and of loading; from such derived pointers; furthermore, it applies whether or not such; derivations are applied directly in the calling code or by other utility code; (for example, the C library routine ``strchr``). However, the implementation; never need account for uses after a return from the code which calls the; method returning an interior pointer. As an exception, no extension is required if the receiver is loaded directly; from a ``__strong`` object with :ref:`precise lifetime semantics; <arc.optimization.precise>`. .. admonition:: Rationale. Implicit autoreleases carry the risk of significantly inflating memory use,; so it's important to provide users a way of avoiding these autoreleases.; Tying this to precise lifetime semantics is ideal, as for local variables; this requires a very explicit annotation, which allows ARC to trust the user; with good cheer. .. _arc.misc.c-retainable:. C retainable pointer types; --------------------------. A type is a :arc-term:`C retainable pointer type` if it is a pointer to; (possibly qualified) ``void`` or a pointer to a (possibly qualifier) ``struct``; or ``class`` type. .. admonition:: Rationale. ARC does not manage pointers of CoreFoundation type (or any of the related; families of retainable C pointers which interoperate with Objective-C for; retain/release operation). In fact, ARC does not even know how to; distinguish these types from arbitrary C pointer types. The intent of this; concept is to filter out some obviously non-object types while leaving a hook; for later tightening if a means of exhaustively marking CF types is made; available. .. _arc.misc.c-retainable.audit:. Auditing of C retainable pointer interfaces; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. :when-revised:`[beginning Apple 4.0, LLVM 3.1]`.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:101789,variab,variables,101789,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability," available to Cling. Since it is non-selective, use; with care. `ExecScript(const char* name,int argc=0,const char** argv=0)` - the; argument is a name of a python file that is to be executed ('execfile'); in a private namespace to minimize side-effects. Optionally, you can add; CLI-style arguments which are handed to the script through 'sys.argv' in; the normal way. `Exec(const char* cmd) `- the argument is a string of Python code that; is executed as a statement. There is no return value, but an error; message will be printed if there are problems such as syntax errors. `Eval(const char* expr) `- the argument is a string of Python code that; is evaluated as an expression. The result of the expression is returned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is needed; to assign the return value to a local pointer (which may have a; different type), whereas builtin types will be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first with `gSystem->Load()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling sess",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:16948,variab,variable,16948,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['variab'],['variable']
Modifiability," backslash to ""escape""; a special character, which is the convention used by GNU Make. The -MV; option tells Clang to put double-quotes around the entire filename, which; is the convention used by NMake and Jom. .. option:: -femit-dwarf-unwind=<value>. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:30663,config,configuration,30663,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability," base address register if the original; debug intrinsic referred to memory. ``$noreg`` indicates the variable; location is undefined, equivalent to an ``undef`` dbg.value operand.; * The type of the second operand indicates whether the variable location is; directly referred to by the DBG_VALUE, or whether it is indirect. The; ``$noreg`` register signifies the former, an immediate operand (0) the; latter.; * Operand 3 is the Variable field of the original debug intrinsic.; * Operand 4 is the Expression field of the original debug intrinsic. The second form, ``DBG_VALUE_LIST``, appears thus:. .. code-block:: text. DBG_VALUE_LIST !123, !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_plus), %1, %2. And has the following operands:; * The first operand is the Variable field of the original debug intrinsic.; * The second operand is the Expression field of the original debug intrinsic.; * Any number of operands, from the 3rd onwards, record a sequence of variable; location operands, which may take any of the same values as the first; operand of the ``DBG_VALUE`` instruction above. These variable location; operands are inserted into the final DWARF Expression in positions indicated; by the DW_OP_LLVM_arg operator in the `DIExpression; <LangRef.html#diexpression>`_. The position at which the DBG_VALUEs are inserted should correspond to the; positions of their matching ``llvm.dbg.value`` intrinsics in the IR block. As; with optimization, LLVM aims to preserve the order in which variable; assignments occurred in the source program. However SelectionDAG performs some; instruction scheduling, which can reorder assignments (discussed below).; Function parameter locations are moved to the beginning of the function if; they're not already, to ensure they're immediately available on function entry. To demonstrate variable locations during instruction selection, consider; the following example:. .. code-block:: llvm. define i32 @foo(i32* %addr) {; entry:; call void @llvm.dbg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:28428,variab,variable,28428,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability," be an integral type; value that represents an address A. The second must be an integral type; value that represents a target architecture specific address space; identifier AS. The operation is equivalent to performing ``DW_OP_swap;; DW_OP_LLVM_form_aspace_address; DW_OP_deref``. The value V retrieved is left; on the stack with the generic type. *This operation is deprecated as the* ``DW_OP_LLVM_form_aspace_address``; *operation can be used and provides greater expressiveness.*. 6. ``DW_OP_xderef_size`` *Deprecated*. ``DW_OP_xderef_size`` has a single 1-byte unsigned integral constant that; represents a byte result size S. It pops two stack entries. The first must be an integral type value that; represents an address A. The second must be an integral type value that; represents a target architecture specific address space identifier AS. The operation is equivalent to performing ``DW_OP_swap;; DW_OP_LLVM_form_aspace_address; DW_OP_deref_size S``. The zero-extended; value V retrieved is left on the stack with the generic type. *This operation is deprecated as the* ``DW_OP_LLVM_form_aspace_address``; *operation can be used and provides greater expressiveness.*. 7. ``DW_OP_xderef_type`` *Deprecated*. ``DW_OP_xderef_type`` has two operands. The first is a 1-byte unsigned; integral constant S. The second operand is an unsigned LEB128 integer DR; that represents the byte offset of a debugging information entry D relative; to the beginning of the current compilation unit, that provides the type T; of the result value. It pops two stack entries. The first must be an integral type value that; represents an address A. The second must be an integral type value that; represents a target architecture specific address space identifier AS. The operation is equivalent to performing ``DW_OP_swap;; DW_OP_LLVM_form_aspace_address; DW_OP_deref_type S DR``. The value V; retrieved is left on the stack with the type T. *This operation is deprecated as the* ``DW_OP_LLVM_form_aspace_address`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:94237,extend,extended,94237,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extended']
Modifiability," be cached on the CPU.; Subsequent access from the GPU will automatically invalidate or writeback; the CPU cache due to the L2 probe filter.; * To ensure coherence of local memory writes of CUs with different L1 caches; in the same agent a ``buffer_wbl2`` is required. It does nothing if the; agent is configured to have a single L2, or will writeback dirty L2 cache; lines if configured to have multiple L2 caches.; * To ensure coherence of local memory writes of CUs in different agents a; ``buffer_wbl2 sc1`` is required. It will writeback dirty L2 cache lines.; * To ensure coherence of local memory reads of CUs with different L1 caches; in the same agent a ``buffer_inv sc1`` is required. It does nothing if the; agent is configured to have a single L2, or will invalidate non-local L2; cache lines if configured to have multiple L2 caches.; * To ensure coherence of local memory reads of CUs in different agents a; ``buffer_inv sc0 sc1`` is required. It will invalidate non-local L2 cache; lines if configured to have multiple L2 caches. * PCIe access from the GPU to the CPU can be kept coherent by using the MTYPE; UC (uncached) which bypasses the L2. Scalar memory operations are only used to access memory that is proven to not; change during the execution of the kernel dispatch. This includes constant; address space and global address space for program scope ``const`` variables.; Therefore, the kernel machine code does not have to maintain the scalar cache to; ensure it is coherent with the vector caches. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted bef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:289637,config,configured,289637,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['config'],['configured']
Modifiability," be equal to `size`; - **`size`**: basic length of the source and dest spectra; - **`type`**: type of transform; - `TRANSFORM1_HAAR`; - `TRANSFORM1_WALSH`; - `TRANSFORM1_COS`; - `TRANSFORM1_SIN`; - `TRANSFORM1_FOURIER`; - `TRANSFORM1_HARTLEY`; - `TRANSFORM1_FOURIER_WALSH`; - `TRANSFORM1_FOURIER_HAAR`; - `TRANSFORM1_WALSH_HAAR`; - `TRANSFORM1_COS_WALSH`; - `TRANSFORM1_COS_HAAR`; - `TRANSFORM1_SIN_WALSH`; - `TRANSFORM1_SIN_HAAR`; - **`degree`**: applied only for mixed transforms; - **`xmin`**: low limit of filtered region; - **`xmax`**: high limit of filtered region; - **`enhance_coeff`**: value by which the filtered region is multiplied. An example of enhancement of the coefficients from region 380-800 by the; constant 2 in the Cosine transform domain is given in the Figure 6.6. The; determination of the region is a matter of analysis in the appropriate; transform domain. We assumed that low frequency components are placed in; the low coefficients. As it can be observed, the enhancement changes the; peak-to-background ratio. ![Enhancement of the coefficients from region 380-800 by the constant 2 in the Cosine transform domain](figures/image206.png). ## 2-DIMENSIONAL SPECTRA ##. Similarly to 1-dimensional data, we have implemented the; transforms also for 2-dimensional data. Besides the classic; orthogonal transforms like. - Haar; - Walsh; - Cos; - Sin; - Fourier; - Hartley; - Fourier-Haar; - Fourier-Walsh; - Walsh-Haar; - Cos-Walsh; - Cos-Haar; - Sin-Walsh; - Sin-Haar. ```{.cpp}; char *Transform2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int direction,; int degree);; ```. This function transforms the source spectrum. The calling program should; fill in the input parameters. Transformed data are written into the dest; spectrum. Function parameters:. - **`source`**: pointer to the matrix of the source spectrum, its size should; be `sizex`*`sizey` except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR; transform. These need `sizex`\*2\*`sizey` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:65165,enhance,enhancement,65165,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['enhance'],['enhancement']
Modifiability," be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19648,plugin,plugin,19648,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['plugin'],['plugin']
Modifiability," be included in; `translate()` function. - Inputs: `key` (the name of the node to add the result for), `value` (the; new name to assign/overwrite).; - Output: Adds (or overwrites) the string representing the result of a node. - **RooFit::Detail::CodeSquashContext::getResult()**: It helps lookup the; result of a child node (the string that the child node previously saved in a; variable using the `addResult()` function). - Input: `key` (the node to get the result string for).; - Output: String representing the result of this node. - **RooFit::Detail::CodeSquashContext::addToCodeBody()**: Takes whatever string; is computed in its arguments and adds it to the overall function string (which; will later be just-in-time compiled). - Inputs: `klass` (the class requesting this addition, usually 'this'), `in`; (string to add to the squashed code).; - Output: Adds the input string to the squashed code body. - **RooFit::Detail::CodeSquashContext::addToGlobalScope()**: Helps declare and; initialize the results variable, so that it can be available globally; (throughout the function body). - Input: `str` (the string to add to the global scope).; - Output: Adds the given string to the string block that will be emitted at; the top of the squashed function. - **RooFit::Detail::CodeSquashContext::assembleCode()**: combines the generated; code statements into the final code body of the squashed function. - Input: `returnExpr` (he string representation of what the squashed function; should return, usually the head node).; - Output: The final body of the function. - **RooFit::Detail::CodeSquashContext::beginLoop()**: The code squashing task; will automatically build a For loop around the indented statements that follow; this function. - Input: `in` (a pointer to the calling class, used to determine the loop; dependent variables).; - Output: A scope for iterating over vector observables. - **RooFit::Detail::CodeSquashContext::buildArg()**: helps convert RooFit; objects into arrays or othe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:35793,variab,variable,35793,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['variab'],['variable']
Modifiability," be put before named; arguments. .. productionlist::; Body: "";"" | ""{"" `BodyItem`* ""}""; BodyItem: (`Type` | ""code"") `TokIdentifier` [""="" `Value`] "";""; :| ""let"" `TokIdentifier` [""{"" `RangeList` ""}""] ""="" `Value` "";""; :| ""defvar"" `TokIdentifier` ""="" `Value` "";""; :| `Assert`. A field definition in the body specifies a field to be included in the class; or record. If no initial value is specified, then the field's value is; uninitialized. The type must be specified; TableGen will not infer it from; the value. The keyword ``code`` may be used to emphasize that the field; has a string value that is code. The ``let`` form is used to reset a field to a new value. This can be done; for fields defined directly in the body or fields inherited from parent; classes. A :token:`RangeList` can be specified to reset certain bits in a; ``bit<n>`` field. The ``defvar`` form defines a variable whose value can be used in other; value expressions within the body. The variable is not a field: it does not; become a field of the class or record being defined. Variables are provided; to hold temporary values while processing the body. See `Defvar in a Record; Body`_ for more details. When class ``C2`` inherits from class ``C1``, it acquires all the field; definitions of ``C1``. As those definitions are merged into class ``C2``, any; template arguments passed to ``C1`` by ``C2`` are substituted into the; definitions. In other words, the abstract record fields defined by ``C1`` are; expanded with the template arguments before being merged into ``C2``. .. _def:. ``def`` --- define a concrete record; ------------------------------------. A ``def`` statement defines a new concrete record. .. productionlist::; Def: ""def"" [`NameValue`] `RecordBody`; NameValue: `Value` (parsed in a special mode). The name value is optional. If specified, it is parsed in a special mode; where undefined (unrecognized) identifiers are interpreted as literal; strings. In particular, global identifiers are considered unreco",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:26811,variab,variable,26811,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability," be queried for; the gradient. In summary, the important ingredient to enable AD in RooFit is to support the; **C++ code generation** from RooFit classes. # Steps to enable Code Generation in RooFit classes. There are multiple code generation approaches that can be followed to add Code; Generation support in RooFit classes. **Approach 1:** For very simple cases like `RooRatio`, it may be preferable to; write the entire code in a single string. **Approach 2:** Another approach could be to extract free functions in a; separate header file.; Since Clad prefers the code for models to be within a single translation unit,; in many classes, this has been implemented by moving the computational; aspects of the RooFit class; to free functions in a single header file named [MathFuncs] (and/or; [MathFuncs], where relevant). This approach enables easier debugging; (e.g., you can standalone-compile the generated code with just a few header; files copied outside ROOT). *Refactoring* It is important to refactor the code such that:. - the footprint of the generated code is minimized by referring to existing; functions with the definition known by interpreter (i.e., they are in public; header files). - to reuse common code, both in the generated code, and in the existing; RooAbsReal::evaluate() method (meaning that the refactoring of `evaluate()` is; optional, but it is recommended). \htmlonly; <div class=""pyrootbox"">; \endhtmlonly. *Implement Code Generation support in custom classes*: Framework developers; that want to implement Code Generation support for their custom classes, this; approach of extracting free functions in a separate header file is not; suitable, since they can't put the code in a header that is part of the ROOT; installation. Please note the following recommendations:. - while developing your custom class, add these functions to your classes; header file (e.g., as part of the class definition), and. - if/when your class is upstreamed to RooFit, expect to move int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:6108,refactor,refactor,6108,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['refactor'],['refactor']
Modifiability," behavior of; the paste operator. Statements; ==========. The following statements may appear at the top level of TableGen source; files. .. productionlist::; TableGenFile: (`Statement` | `IncludeDirective`; :| `PreprocessorDirective`)*; Statement: `Assert` | `Class` | `Def` | `Defm` | `Defset` | `Defvar`; :| `Dump` | `Foreach` | `If` | `Let` | `MultiClass`. The following sections describe each of these top-level statements. ``class`` --- define an abstract record class; ---------------------------------------------. A ``class`` statement defines an abstract record class from which other; classes and records can inherit. .. productionlist::; Class: ""class"" `ClassID` [`TemplateArgList`] `RecordBody`; TemplateArgList: ""<"" `TemplateArgDecl` ("","" `TemplateArgDecl`)* "">""; TemplateArgDecl: `Type` `TokIdentifier` [""="" `Value`]. A class can be parameterized by a list of ""template arguments,"" whose values; can be used in the class's record body. These template arguments are; specified each time the class is inherited by another class or record. If a template argument is not assigned a default value with ``=``, it is; uninitialized (has the ""value"" ``?``) and must be specified in the template; argument list when the class is inherited (required argument). If an; argument is assigned a default value, then it need not be specified in the; argument list (optional argument). In the declaration, all required template; arguments must precede any optional arguments. The template argument default; values are evaluated from left to right. The :token:`RecordBody` is defined below. It can include a list of; parent classes from which the current class inherits, along with field; definitions and other statements. When a class ``C`` inherits from another; class ``D``, the fields of ``D`` are effectively merged into the fields of; ``C``. A given class can only be defined once. A ``class`` statement is; considered to define the class if *any* of the following are true (the; :token:`RecordBody",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:22213,inherit,inherited,22213,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherited']
Modifiability," being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; does not yet handle dropping qualifiers from the function return type.; . 424; Dup; Underspecification of tss_t; Duplicate of 416. 425; NAD; No specification for the access to variables with temporary lifetime; Yes. 426; C11; G.5.1: -yv and -x/v are ambiguous; N/A. 427; NAD; Function Parameter and Return Value Assignments; Unknown. 428; C11; Runtime-constraint issue with sprintf family of routines in Annex K; N/A. 429; C11; Should gets_s discard next input line when (s == NULL) ?; N/A. 430; C11; getenv_s, maxsize should be allowed to be zero; N/A. 431; C11; atomic_compare_exchange: What does it mean to say two structs compare equal?; Unknown. 432; C11; Possible defect report: Is 0.0 required to be a representable value?; Yes. 433; C11; Issue with constraints for wide character function arguments involving RSIZE_MAX; N/A. 434; C11; Possible defect report: Missing constraint w.r.t. Atomic; Yes. 435; NAD; Possible defect report: Missing constraint w.r.t. Imaginary; Yes. 436; C11; Request for interpretation of C11 6.8.5#6; Yes. 437; C11; clock overflow problems; N/A. 438; C11; ungetc / ungetwc and file position after discarding push back problems; N/A. 439; C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:22748,variab,variables,22748,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,1,['variab'],['variables']
Modifiability," block. ### TODO list. As this is an experimental work in progress so there are some items we still need; to tackle:. * As mentioned in test llvm/test/DebugInfo/assignment-tracking/X86/diamond-3.ll,; the analysis should treat escaping calls like untagged stores. * The system expects locals to be backed by a local alloca. This isn't always; the case - sometimes a pointer to storage is passed into a function; (e.g. sret, byval). We need to be able to handle those cases. See; llvm/test/DebugInfo/Generic/assignment-tracking/track-assignments.ll and; clang/test/CodeGen/assignment-tracking/assignment-tracking.cpp for examples. * `trackAssignments` doesn't yet work for variables that have their; `llvm.dbg.declare` location modified by a `DIExpression`, e.g. when the; address of the variable is itself stored in an `alloca` with the; `llvm.dbg.declare` using `DIExpression(DW_OP_deref)`. See `indirectReturn` in; llvm/test/DebugInfo/Generic/assignment-tracking/track-assignments.ll and in; clang/test/CodeGen/assignment-tracking/assignment-tracking.cpp for an; example. * In order to solve the first bullet-point we need to be able to specify that a; memory location is available without using a `DIAssignID`. This is because; the storage address is not computed by an instruction (it's an argument; value) and therefore we have nowhere to put the metadata attachment. To solve; this we probably need another marker intrinsic to denote ""the variable's; stack home is X address"" - similar to `llvm.dbg.declare` except that it needs; to compose with `llvm.dbg.assign` intrinsics such that the stack home address; is only selected as a location for the variable when the `llvm.dbg.assign`; intrinsics agree it should be. * Given the above (a special ""the stack home is X"" intrinsic), and the fact; that we can only track assignments with fixed offsets and sizes, I think we; can probably get rid of the address and address-expression part, since it; will always be computable with the info we have.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:10807,variab,variable,10807,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,2,['variab'],['variable']
Modifiability," bound). As pointer; arithmetic overflow will make the pointer smaller than the original pointer,; it will cause a trap at runtime. Similar to ``__bidi_indexable``, an; ``__indexable`` pointer is allowed to have a pointer value above the upper; bound and creating such a pointer is well-defined behavior. Dereferencing such; a pointer, however, will cause a run-time trap. * ``__bidi_indexable`` offers the best flexibility out of all the pointer; annotations in this model, as ``__bidi_indexable`` pointers can be used for; any pointer operation. However, this comes with the largest code size and; memory cost out of the available pointer annotations in this model. In some; cases, use of the ``__bidi_indexable`` annotation may be duplicating bounds; information that exists elsewhere in the program. In such cases, using; external bounds annotations may be a better choice. ``__bidi_indexable`` is the default annotation for non-ABI visible pointers,; such as local pointer variables — that is, if the programmer does not specify; another bounds annotation, a local pointer variable is implicitly; ``__bidi_indexable``. Since ``__bidi_indexable`` pointers automatically carry; bounds information and have no restrictions on kinds of pointer operations that; can be used with these pointers, most code inside a function works as is without; modification. In the example below, ``int *buf`` doesn't require manual; annotation as it's implicitly ``int *__bidi_indexable buf``, carrying the bounds; information passed from the return value of malloc, which is necessary to insert; bounds checking for ``buf[i]``. .. code-block:: c. void *__sized_by(size) malloc(size_t size);. int *__counted_by(n) get_array_with_0_to_n_1(size_t n) {; int *buf = malloc(sizeof(int) * n);; for (size_t i = 0; i < n; ++i); buf[i] = i;; return buf;; }. Annotations for sentinel-delimited arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A C string is an array of characters. The null terminator — the first null; chara",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:16917,variab,variables,16917,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,['variab'],"['variable', 'variables']"
Modifiability," br label %if.end. if.end:; %av = phi i8 [0, %entry], [%0, %if.then]; ret i8 %av; }. Going solely by ``MemorySSA``'s analysis, hoisting the ``load`` to ``entry`` may; seem legal. Because it's a volatile load, though, it's not. Design tradeoffs; ----------------. Precision; ^^^^^^^^^. ``MemorySSA`` in LLVM deliberately trades off precision for speed.; Let us think about memory variables as if they were disjoint partitions of the; memory (that is, if you have one variable, as above, it represents the entire; memory, and if you have multiple variables, each one represents some; disjoint portion of the memory). First, because alias analysis results conflict with each other, and; each result may be what an analysis wants (IE; TBAA may say no-alias, and something else may say must-alias), it is; not possible to partition the memory the way every optimization wants.; Second, some alias analysis results are not transitive (IE A noalias B,; and B noalias C, does not mean A noalias C), so it is not possible to; come up with a precise partitioning in all cases without variables to; represent every pair of possible aliases. Thus, partitioning; precisely may require introducing at least N^2 new virtual variables,; phi nodes, etc. Each of these variables may be clobbered at multiple def sites. To give an example, if you were to split up struct fields into; individual variables, all aliasing operations that may-def multiple struct; fields, will may-def more than one of them. This is pretty common (calls,; copies, field stores, etc). Experience with SSA forms for memory in other compilers has shown that; it is simply not possible to do this precisely, and in fact, doing it; precisely is not worth it, because now all the optimizations have to; walk tons and tons of virtual variables and phi nodes. So we partition. At the point at which you partition, again,; experience has shown us there is no point in partitioning to more than; one variable. It simply generates more IR, and optimiz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:17413,variab,variables,17413,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['variab'],['variables']
Modifiability," break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`` (in configuration: ``Custom``); Configure each individual brace in ``BraceWrapping``. .. _BreakBeforeConceptDeclarations:. **BreakBeforeConceptDeclarations** (``BreakBeforeConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old));. * ``BBIAS_Always`` (in configuration: ``Always``); Always break before inline ASM colon. .. code-block:: c++. asm volatile(""string"",; :; : val);. .. _BreakBeforeTernaryOperators:. **BreakBeforeTernaryOperators",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:52616,config,configuration,52616,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," but break before function definitions, ``catch``, and; ``else``. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; }; catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; }; else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Allman`` (in configuration: ``Allman``); Always break before braces. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Whitesmiths`` (in configuration: ``Whitesmiths``); Like ``Allman`` but always indent braces and line up code with braces. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_GNU`` (in configuration: ``GNU``); Always break before braces and add an extra level of indentation to; braces of control statements, not to those of class, function; or other definitions. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; }; while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:50281,config,configuration,50281,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," but different sizes. A way to do this would; be to create as many different volumes and shapes. The modeller allows; however the definition of a single volume having undefined shape; parameters. ``` {.cpp}; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);; ```. - `name:` the name of the newly created volume;; - `shape:`the type of the associated shape. This has to contain the; case-insensitive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:55835,parameteriz,parameterizations,55835,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['parameteriz'],['parameterizations']
Modifiability," but different sizes. A way to do this would; be to create as many different volumes and shapes. The modeller allows; however the definition of a single volume having undefined shape; parameters. ~~~ {.cpp}; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);; ~~~. - `name:` the name of the newly created volume;; - `shape:`the type of the associated shape. This has to contain the; case-insensitive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. \defgroup Tubes Tubes; \ingroup Shapes_classes; Tubes have Z as their symmetry axis. \defgroup Cones Cones; \ingroup Shapes_classes; Conical tube",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md:9605,parameteriz,parameterizations,9605,geom/geom/doc/shapes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/shapes.md,1,['parameteriz'],['parameterizations']
Modifiability," but no previous; compiler experience is necessary. Welcome to the ""My First Language Frontend with LLVM"" tutorial. Here we; run through the implementation of a simple language, showing; how fun and easy it can be. This tutorial will get you up and running; fast and show a concrete example of something that uses LLVM to generate; code. This tutorial introduces the simple ""Kaleidoscope"" language, building it; iteratively over the course of several chapters, showing how it is built; over time. This lets us cover a range of language design and LLVM-specific; ideas, showing and explaining the code for it all along the way,; and reduces the overwhelming amount of details up front. We strongly; encourage that you *work with this code* - make a copy and hack it up and; experiment. **Warning**: In order to focus on teaching compiler techniques and LLVM; specifically,; this tutorial does *not* show best practices in software engineering; principles. For example, the code uses global variables; pervasively, doesn't use; `visitors <http://en.wikipedia.org/wiki/Visitor_pattern>`_, etc... but; instead keeps things simple and focuses on the topics at hand. This tutorial is structured into chapters covering individual topics,; allowing you to skip ahead as you wish:. - `Chapter #1: Kaleidoscope language and Lexer <LangImpl01.html>`_ -; This shows where we are; going and the basic functionality that we want to build. A lexer; is also the first part of building a parser for a language, and we; use a simple C++ lexer which is easy to understand.; - `Chapter #2: Implementing a Parser and AST <LangImpl02.html>`_ -; With the lexer in place, we can talk about parsing techniques and; basic AST construction. This tutorial describes recursive descent; parsing and operator precedence parsing.; - `Chapter #3: Code generation to LLVM IR <LangImpl03.html>`_ - with; the AST ready, we show how easy it is to generate LLVM IR, and show; a simple way to incorporate LLVM into your project.; - `Chapter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:1327,variab,variables,1327,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,1,['variab'],['variables']
Modifiability," c = a + b :; a = b :; b = c) :; b;. # Call it.; fibi(10);. In order to mutate variables, we have to change our existing variables; to use the ""alloca trick"". Once we have that, we'll add our new; operator, then extend Kaleidoscope to support new variable definitions. Adjusting Existing Variables for Mutation; =========================================. The symbol table in Kaleidoscope is managed at code generation time by; the '``NamedValues``' map. This map currently keeps track of the LLVM; ""Value\*"" that holds the double value for the named variable. In order; to support mutation, we need to change this slightly, so that; ``NamedValues`` holds the *memory location* of the variable in question.; Note that this change is a refactoring: it changes the structure of the; code, but does not (by itself) change the behavior of the compiler. All; of these changes are isolated in the Kaleidoscope code generator. At this point in Kaleidoscope's development, it only supports variables; for two things: incoming arguments to functions and the induction; variable of 'for' loops. For consistency, we'll allow mutation of these; variables in addition to other user-defined variables. This means that; these will both need memory locations. To start our transformation of Kaleidoscope, we'll change the; ``NamedValues`` map so that it maps to AllocaInst\* instead of Value\*. Once; we do this, the C++ compiler will tell us what parts of the code we need; to update:. .. code-block:: c++. static std::map<std::string, AllocaInst*> NamedValues;. Also, since we will need to create these allocas, we'll use a helper; function that ensures that the allocas are created in the entry block of; the function:. .. code-block:: c++. /// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.; static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction,; const std::string &VarName) {; IRBuilder<> TmpB(&TheFunction->getEnt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:12190,variab,variables,12190,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,2,['variab'],"['variable', 'variables']"
Modifiability," c++. /// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.; static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction,; const std::string &VarName) {; IRBuilder<> TmpB(&TheFunction->getEntryBlock(),; TheFunction->getEntryBlock().begin());; return TmpB.CreateAlloca(Type::getDoubleTy(*TheContext), nullptr,; VarName);; }. This funny looking code creates an IRBuilder object that is pointing at; the first instruction (.begin()) of the entry block. It then creates an; alloca with the expected name and returns it. Because all values in; Kaleidoscope are doubles, there is no need to pass in a type to use. With this in place, the first functionality change we want to make belongs to; variable references. In our new scheme, variables live on the stack, so; code generating a reference to them actually needs to produce a load; from the stack slot:. .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; AllocaInst *A = NamedValues[Name];; if (!A); return LogErrorV(""Unknown variable name"");. // Load the value.; return Builder->CreateLoad(A->getAllocatedType(), A, Name.c_str());; }. As you can see, this is pretty straightforward. Now we need to update; the things that define the variables to set up the alloca. We'll start; with ``ForExprAST::codegen()`` (see the `full code listing <#id1>`_ for; the unabridged code):. .. code-block:: c++. Function *TheFunction = Builder->GetInsertBlock()->getParent();. // Create an alloca for the variable in the entry block.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);. // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. // Store the value into the alloca.; Builder->CreateStore(StartVal, Alloca);; ... // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Reload, increme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:13942,variab,variable,13942,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability," c. _Block_object_dispose(->target, BLOCK_FIELD_<apropos>);. in the dispose helper where ``<apropos>`` is:. .. code-block:: c. enum {; BLOCK_FIELD_IS_OBJECT = 3, // id, NSObject, __attribute__((NSObject)), block, ...; BLOCK_FIELD_IS_BLOCK = 7, // a block variable; BLOCK_FIELD_IS_BYREF = 8, // the on stack structure holding the __block variable. BLOCK_FIELD_IS_WEAK = 16, // declared __weak. BLOCK_BYREF_CALLER = 128, // called from byref copy/dispose helpers; };. and of course the constructors/destructors for ``const`` copied C++ objects. The ``block_byref`` data structure similarly requires copy/dispose helpers for; block variables, ``__attribute__((NSObject))`` variables, or C++ ``const``; copied objects with constructor/destructors, and again the (1<<26) bit is set; and functions are generated in the same manner. Under ObjC we allow ``__weak`` as an attribute on ``__block`` variables, and; this causes the addition of ``BLOCK_FIELD_IS_WEAK`` orred onto the; ``BLOCK_FIELD_IS_BYREF`` flag when copying the ``block_byref`` structure in the; ``Block`` copy helper, and onto the ``BLOCK_FIELD_<apropos>`` field within the; ``block_byref`` copy/dispose helper calls. The prototypes, and summary, of the helper functions are:. .. code-block:: c. /* Certain field types require runtime assistance when being copied to the; heap. The following function is used to copy fields of types: blocks,; pointers to byref structures, and objects (including; __attribute__((NSObject)) pointers. BLOCK_FIELD_IS_WEAK is orthogonal to; the other choices which are mutually exclusive. Only in a Block copy; helper will one see BLOCK_FIELD_IS_BYREF.; */; void _Block_object_assign(void *destAddr, const void *object, const int flags);. /* Similarly a compiler generated dispose helper needs to call back for each; field of the byref data structure. (Currently the implementation only; packs one field into the byref structure but in principle there could be; more). The same flags used in the copy helper shou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:29202,variab,variables,29202,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability," call.*. 3. Each call site parameter entry may also have a ``DW_AT_call_parameter``; attribute which contains a reference to a ``DW_TAG_formal_parameter`` entry,; ``DW_AT_type attribute`` referencing the type of the parameter or; ``DW_AT_name`` attribute describing the parameter's name. *Examples using call site entries and related attributes are found in Appendix; D.15.*. .. _amdgpu-dwarf-lexical-block-entries:. A.3.5 Lexical Block Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section is the same as DWARF Version 5 section 3.5. A.4 Data Object and Object List Entries; ---------------------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 4 sections. .. _amdgpu-dwarf-data-object-entries:. A.4.1 Data Object Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~. Program variables, formal parameters and constants are represented by debugging; information entries with the tags ``DW_TAG_variable``,; ``DW_TAG_formal_parameter`` and ``DW_TAG_constant``, respectively. *The tag DW_TAG_constant is used for languages that have true named constants.*. The debugging information entry for a program variable, formal parameter or; constant may have the following attributes:. 1. A ``DW_AT_location`` attribute, whose value is a DWARF expression E that; describes the location of a variable or parameter at run-time. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language thread of execution upon which; the user is focused, if any. The result of the evaluation is the location; description of the base of the data object. See :ref:`amdgpu-dwarf-control-flow-operations` for special evaluation rules; used by the ``DW_OP_call*`` operations. .. note::. D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:172363,variab,variables,172363,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variables']
Modifiability," called by ExprEngine; to tell the Checker that we are about to analyze a CallExpr, and the; checker is asked to check for any preconditions that might not be; satisfied. The checker can do nothing, or it can generate a new; ProgramState and ExplodedNode which contains updated checker state. If it; finds a bug, it can tell the BugReporter object about the bug,; providing it an ExplodedNode which is the last node in the path that; triggered the problem. = Notes about C++ =. Since now constructors are seen before the variable that is constructed; in the CFG, we create a temporary object as the destination region that; is constructed into. See ExprEngine::VisitCXXConstructExpr(). In ExprEngine::processCallExit(), we always bind the object region to the; evaluated CXXConstructExpr. Then in VisitDeclStmt(), we compute the; corresponding lazy compound value if the variable is not a reference, and; bind the variable region to the lazy compound value. If the variable; is a reference, just use the object region as the initializer value. Before entering a C++ method (or ctor/dtor), the 'this' region is bound; to the object region. In ctors, we synthesize 'this' region with; CXXRecordDecl*, which means we do not use type qualifiers. In methods, we; synthesize 'this' region with CXXMethodDecl*, which has getThisType(); taking type qualifiers into account. It does not matter we use qualified; 'this' region in one method and unqualified 'this' region in another; method, because we only need to ensure the 'this' region is consistent; when we synthesize it and create it directly from CXXThisExpr in a single; method call. = Working on the Analyzer =. If you are interested in bringing up support for C++ expressions, the; best place to look is the visitation logic in ExprEngine, which; handles the simulation of individual expressions. There are plenty of; examples there of how other expressions are handled. If you are interested in writing checkers, look at the Checker and; CheckerVis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt:4268,variab,variable,4268,interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,1,['variab'],['variable']
Modifiability," called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake optio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1621,config,configured,1621,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['configured']
Modifiability," can be automatically generated if the; build system knows about the list of header files in every package. . ### Header parsing in ROOT. ```cpp; // A.h; #include <string>; #include <vector>; template <class T, class U = int> struct AStruct {; void doIt() { /*...*/ }; std::string Name; ; std::vector<U> Collection;; // ...; };. template<class T, class U = AStruct<T>>; inline void freeFunction() { /* ... */ }; inline void do(unsigned N = 1) { /* ... */ }. ``` ; The associated with libA header files form libA's full descriptor. A.h,; potentially only part of the descriptor of libA, expands to more than 26000; lines of code. ```cpp; // Main.cpp; #include ""A.h""; int main() {; do();; return 0;; }. ```; Main.cpp, reuses code from libA by including libA's descriptor and links against; libA. The full descriptor can contain thousands of files expanding to millions; of lines of code -- a common case for framework libraries, for instance. ROOT goes further and enhances C++ by allowing the following code to work without; explicitly requiring to `#include <A.h>`. Currently, ROOT's lack of support of; line `#5` is a long-standing, known limitation that is lifted with modules. ```cpp; // ROOT prompt; root [] AStruct<float> S0; // #1: implicit loading of libA. Full descriptor required.; root [] AStruct<float>* S1; // #2: implicit loading of libA. No full descriptor required.; root [] if (gFile) S1->doIt(); // #3: implicit loading of libA. Full descriptor required.; root [] gSystem->Load(""libA""); // #4: explicit loading of libA. No full descriptor required.; root [] do(); // #5: error: implicit loading of libA is currently unsupported. ```. This pattern is not only used in the ROOT prompt but in I/O hotspots such as; `ShowMembers` and `TClass::IsA`. A naive implementation of this feature would require inclusion of all reachable; library descriptors (aka header files) at ROOT startup time. Of course this is; not feasible and ROOT inserts a set of optimizations to fence itself from the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:4570,enhance,enhances,4570,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['enhance'],['enhances']
Modifiability," can be passed to; :ref:`llvm.stackrestore <int_stackrestore>`. When an; ``llvm.stackrestore`` intrinsic is executed with a value saved from; ``llvm.stacksave``, it effectively restores the state of the stack to; the state it was in when the ``llvm.stacksave`` intrinsic executed. In; practice, this pops any :ref:`alloca <i_alloca>` blocks from the stack; that were allocated after the ``llvm.stacksave`` was executed. The; address space should typically be the; :ref:`alloca address space <alloca_addrspace>`. .. _int_stackrestore:. '``llvm.stackrestore``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackrestore.p0(ptr %ptr); declare void @llvm.stackrestore.p5(ptr addrspace(5) %ptr). Overview:; """""""""""""""""". The '``llvm.stackrestore``' intrinsic is used to restore the state of; the function stack to the state it was in when the corresponding; :ref:`llvm.stacksave <int_stacksave>` intrinsic executed. This is; useful for implementing language features like scoped automatic; variable sized arrays in C99. The address space should typically be; the :ref:`alloca address space <alloca_addrspace>`. Semantics:; """""""""""""""""""". See the description for :ref:`llvm.stacksave <int_stacksave>`. .. _int_get_dynamic_area_offset:. '``llvm.get.dynamic.area.offset``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.get.dynamic.area.offset.i32(); declare i64 @llvm.get.dynamic.area.offset.i64(). Overview:; """""""""""""""""". The '``llvm.get.dynamic.area.offset.*``' intrinsic family is used to; get the offset from native stack pointer to the address of the most; recent dynamic alloca on the caller's stack. These intrinsics are; intended for use in combination with; :ref:`llvm.stacksave <int_stacksave>` to get a; pointer to the most recent dynamic alloca. This is useful, for example,; for AddressSanitizer's stack unpoisoning routines. Semantics:; """""""""""""""""""". These intrinsics return a non-negative integer value that can",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:521016,variab,variable,521016,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 test.cl. More information about the default headers is provided in :doc:`OpenCLSupport`. OpenCL Extensions; -----------------. Most of the ``cl_khr_*`` extensions to OpenCL C from `the official OpenCL; registry <https://www.khronos.org/registry/OpenCL/>`_ are available and; configured per target depending on the support available in the specific; architecture. It is possible to alter the default extensions setting per target using; ``-cl-ext`` flag. (See :ref:`flags description <opencl_cl_ext>` for more details). Vendor extensions can be added flexibly by declaring the list of types and; functions associated with each extensions enclosed within the following; compiler pragma directives:. .. code-block:: c. #pragma OPENCL EXTENSION the_new_extension_name : begin; // declare types and functions associated with the extension here; #pragma OPENCL EXTENSION the_new_extension_name : end. For example, parsing the following code adds ``my_t`` type and ``my_func``; function to the custom ``my_ext`` extension. .. code-block:: c. #pragma OPENCL EXTENSION my_ext : begin; typedef struct{; int a;; }my_t;; void my_func(my_t);; #pragma OPENCL EXTENSION my_ext : end. There is no conflict resolution for identifier clashes among extensions.; It is therefore recommended that the identifiers are p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:147798,config,configured,147798,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configured']
Modifiability," case, this includes the platform-dependent steps necessary to compile the .cpp; file. The generated package also takes advantage of the __init__.py load-time; mechanism to enhance the bindings:. * The bindings are rehosted in a ""native"" namespace so that C++ code from; KF5::Config appears in Python via ""import KF5.Config"".; * (TBD) Load Pythonizations. Both of these need/can use the output of the; :ref:`cppyy-generator <cppyy-generator>` (included in the package) as well as; other runtime support included in ``cppyy``. CMake usage; -----------. The CMake usage is via two modules:. * FindLibClang.cmake provides some bootstrap support needed to locate clang.; This is provided mostly as a temporary measure; hopefully upstream support; will allow this to be eliminated in due course.; * FindCppyy.cmake provides the interface described further here. Details of the usage of these modules is within the modules themselves, but; here is a summary of the usage. ``FindLibClang.cmake`` sets the following; variables:. ::. LibClang_FOUND - True if libclang is found.; LibClang_LIBRARY - Clang library to link against.; LibClang_VERSION - Version number as a string (e.g. ""3.9"").; LibClang_PYTHON_EXECUTABLE - Compatible python version. ``FindCppyy.cmake`` sets the following variables:. ::. Cppyy_FOUND - set to true if Cppyy is found; Cppyy_DIR - the directory where Cppyy is installed; Cppyy_EXECUTABLE - the path to the Cppyy executable; Cppyy_INCLUDE_DIRS - Where to find the Cppyy header files.; Cppyy_VERSION - the version number of the Cppyy backend. and also defines the following functions::. cppyy_add_bindings - Generate a set of bindings from a set of header files.; cppyy_find_pips - Return a list of available pip programs. cppyy_add_bindings; ^^^^^^^^^^^^^^^^^^. Generate a set of bindings from a set of header files. Somewhat like CMake's; add_library(), the output is a compiler target. In addition ancillary files; are also generated to allow a complete set of bindings to be compi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:2824,variab,variables,2824,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['variab'],['variables']
Modifiability," cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed description. .. _debug-AnalysisOrder:. debug.AnalysisOrder; """"""""""""""""""""""""""""""""""""""; Print callbacks that are called during analysis in order. .. _debug-ConfigDumper:. debug.ConfigDumper; """"""""""""""""""""""""""""""""""""; Dump config table. .. _debug-DumpCFG Display:. debug.DumpCFG Display; """"""""""""""""""""""""""""""""""""""""""; Control-Flow Graphs. .. _debug-DumpCallGraph:. debug.DumpCallGraph; """"""""""""""""""""""""""""""""""""""; Display Call Graph. .. _debug-DumpCalls:. debug.DumpCalls; """"""""""""""""""""""""""""""; Print calls as they are traversed by the engine. .. _debug-DumpDominators:. debug.DumpDominators; """"""""""""""""""""""""""""""""""""""""; Print the dominance tree for a given CFG. .. _debug-DumpLiveVars:. debug.DumpLiveVars; """"""""""""""""""""""""""""""""""""; Print results of live variable analysis. .. _debug-DumpTraversal:. debug.DumpTraversal; """"""""""""""""""""""""""""""""""""""; Print branch conditions as they are traversed by the engine. .. _debug-ExprInspection:. debug.ExprInspection; """"""""""""""""""""""""""""""""""""""""; Check the analyzer's understanding of expressions. .. _debug-Stats:. debug.Stats; """"""""""""""""""""""; Emit warnings with analyzer statistics. .. _debug-TaintTest:. debug.TaintTest; """"""""""""""""""""""""""""""; Mark tainted symbols as such. .. _debug-ViewCFG:. debug.ViewCFG; """"""""""""""""""""""""""; View Control-Flow Graphs using GraphViz. .. _debug-ViewCallGraph:. debug.ViewCallGraph; """"""""""""""""""""""""""""""""""""""; View Call Graph using GraphViz. .. _debug-ViewExplodedGraph:. debug.ViewExplodedGraph; """"""""""""""""""""""""""""""""""""""""""""""; View Exploded Graphs using GraphViz.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:86822,variab,variable,86822,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variable']
Modifiability," char *RHS) const;; };; } // namespace. static void runHelper() {; ...; }. bool StringSort::operator<(const char *RHS) const {; ...; }. Avoid putting declarations other than classes into anonymous namespaces:. .. code-block:: c++. namespace {. // ... many declarations ... void runHelper() {; ...; }. // ... many declarations ... } // namespace. When you are looking at ""``runHelper``"" in the middle of a large C++ file,; you have no immediate way to tell if this function is local to the file. In; contrast, when the function is marked static, you don't need to cross-reference; faraway places in the file to tell that the function is local. Don't Use Braces on Simple Single-Statement Bodies of if/else/loop Statements; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When writing the body of an ``if``, ``else``, or for/while loop statement, we; prefer to omit the braces to avoid unnecessary line noise. However, braces; should be used in cases where the omission of braces harm the readability and; maintainability of the code. We consider that readability is harmed when omitting the brace in the presence; of a single statement that is accompanied by a comment (assuming the comment; can't be hoisted above the ``if`` or loop statement, see below). Similarly, braces should be used when a single-statement body is complex enough; that it becomes difficult to see where the block containing the following; statement began. An ``if``/``else`` chain or a loop is considered a single; statement for this rule, and this rule applies recursively. This list is not exhaustive. For example, readability is also harmed if an; ``if``/``else`` chain does not use braced bodies for either all or none of its; members, or has complex conditionals, deep nesting, etc. The examples below; intend to provide some guidelines. Maintainability is harmed if the body of an ``if`` ends with a (directly or; indirectly) nested ``if`` statement with no ``else``. Braces on the outer ``i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:61845,maintainab,maintainability,61845,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['maintainab'],['maintainability']
Modifiability," cl::ParseCommandLineOptions(argc, argv);; ...; }. ... which actually parses the arguments and fills in the variable declarations. Now that you are ready to support command line arguments, we need to tell the; system which ones we want, and what type of arguments they are. The CommandLine; library uses a declarative syntax to model command line arguments with the; global variable declarations that capture the parsed values. This means that; for every command line option that you would like to support, there should be a; global variable declaration to capture the result. For example, in a compiler,; we would like to support the Unix-standard '``-o <filename>``' option to specify; where to put the output. With the CommandLine library, this is represented like; this:. .. _scalars arguments:; .. _here:. .. code-block:: c++. cl::opt<string> OutputFilename(""o"", cl::desc(""Specify output filename""), cl::value_desc(""filename""));. This declares a global variable ""``OutputFilename``"" that is used to capture the; result of the ""``o``"" argument (first parameter). We specify that this is a; simple scalar option by using the ""``cl::opt``"" template (as opposed to the; ""``cl::list``"" template), and tell the CommandLine library that the data; type that we are parsing is a string. The second and third parameters (which are optional) are used to specify what to; output for the ""``-help``"" option. In this case, we get a line that looks like; this:. ::. USAGE: compiler [options]. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. Because we specified that the command line option should parse using the; ``string`` data type, the variable declared is automatically usable as a real; string in all contexts that a normal C++ string object may be used. For; example:. .. code-block:: c++. ...; std::ofstream Output(OutputFilename.c_str());; if (Output.good()) ...; ... There are many different options that you can us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:5150,variab,variable,5150,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability," clang section`` directive provides a means to assign section-names; to global variables, functions and static variables. The section names can be specified as:. .. code-block:: c++. #pragma clang section bss=""myBSS"" data=""myData"" rodata=""myRodata"" relro=""myRelro"" text=""myText"". The section names can be reverted back to default name by supplying an empty; string to the section kind, for example:. .. code-block:: c++. #pragma clang section bss="""" data="""" text="""" rodata="""" relro="""". The ``#pragma clang section`` directive obeys the following rules:. * The pragma applies to all global variable, statics and function declarations; from the pragma to the end of the translation unit. * The pragma clang section is enabled automatically, without need of any flags. * This feature is only defined to work sensibly for ELF targets. * If section name is specified through _attribute_((section(""myname""))), then; the attribute name gains precedence. * Global variables that are initialized to zero will be placed in the named; bss section, if one is present. * The ``#pragma clang section`` directive does not does try to infer section-kind; from the name. For example, naming a section ""``.bss.mySec``"" does NOT mean; it will be a bss section name. * The decision about which section-kind applies to each global is taken in the back-end.; Once the section-kind is known, appropriate section name, as specified by the user using; ``#pragma clang section`` directive, is applied to that global. Specifying Linker Options on ELF Targets; ========================================. The ``#pragma comment(lib, ...)`` directive is supported on all ELF targets.; The second parameter is the library name (without the traditional Unix prefix of; ``lib``). This allows you to provide an implicit link of dependent libraries. Evaluating Object Size Dynamically; ==================================. Clang supports the builtin ``__builtin_dynamic_object_size``, the semantics are; the same as GCC's ``__builtin_objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:187409,variab,variables,187409,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variables']
Modifiability," class MPIProcess deals with starting and terminating the MPI process. Each process calculates independently the derivatives for a given set of parameters.; A Minuit2 library with MPI support can be built by defining before compilation the environment variables USE_PARALLEL_MINUIT2 and USE_MPI. Unuran; Add constructor of Tunuran distributions using function objects defined using the mathcore interfaces:. TUnuranContDist (const ROOT::Math::IGenFunction & pdf, const ROOT::Math::IGenFunction * dpdf, bool isLogPdf);; TUnuranMultiContDist (const ROOT::Math::IMultiGenFunction & pdf, bool isLogPdf );; TUnuranDiscrDist (const ROOT::Math::IGenFunction & func );. TRolke; New version of TRolke from J. Lundberg. The interface of the class has been changed. The old user interface was very hard to use, and the documentation in the source was also not on par with the correct usage. The old interface was a single get-function with 12 arguments, and the user was supposed to figure out which ~ 5 arguments were relevant for a specific model (1 out of 7 models).; ; The new user interface is is easy to use correctly and hard to use incorrectly (TM). It's a single set-method for each method:. SetPoissonBkgBinomialEff(Int_t x,Int_t y,Int_t z,Double_t tau,Int_t m);; SetPoissonBkgGaussianEff(Int_t x,Int_t y,Double_t em, Double_t tau,Double_t sde);; SetGaussianBkgGaussianEff(Int_t x,Double_t bm,Double_t em, Double_t sde,Double_t sdb);; SetPoissondBkgknownEff(Int_t x,Int_t y,Double_t tau,Double_t e);; SetGaussianBkgknownEff(Int_t x,Double_t bm,Double_t sdb,Double_t e);; SetKnownBkgBinomialEff(Int_t x, Int_t z,Int_t m,Double_t b);; SetknownBkgGaussianEff(Int_t x,Double_t em,Double_t sde,Double_t b);. New methods for getting sensitivity (average limits) and related quantities and for critical number related to rejection of the null-hypothesis (no signal).; Some small Bug fixes. Some variables were used uninitialized. (Eg, input arguments which were not supposed to be used were used anyway.). ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:9452,variab,variables,9452,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,1,['variab'],['variables']
Modifiability," clearer structure. This fixes several; bugs which have been reported by some users of TMVA.; Code and performance test framework: A unit; test framework for daily software and method performance; validation has been implemented.; . Methods. BDT Automatic parameter optimisation for building the; tree architecture: The optimisation procedure uses the; performance of the trained classifier on the ""test sample"" for; finding the set of optimal parameters. Two different methods to; traverse the parameter space are available (scanning, genetic; algorithm). Currently parameter optimization is implemented only; for these three parameters that influence the tree architectur:; the maximum depth of a tree, MaxDepth, the minimum; number of events in each node, NodeMinEvents, and; the number of tress, NTrees. Optimization can; is invoked by calling; factory->OptimizeAllMethods(); prior to the call; factory->TrainAllMethods();. Automated and configurable parameter optimization is soon to; be enabled for all methods (for those parameters where; optimization is applicable).; . BDT node splitting: While Decision Trees; typically have only univariate splits, in TMVA one can now; also opt for multivariate splits that use a ""Fisher; Discriminant"" (option: UseFisherCuts), built from all; observables that show correlations larger than some threshold; (MinLinCorrForFisher). The training will then test at each; split a cut on this fisher discriminant in addition to all; univariate cuts on the variables (or only on those variables; that have not been used in the Fisher discriminant, option; UseExcusiveVars). No obvious improvement betwen very simple; decision trees after boosting has been observed so far, but; only a limited number of studies has been performed concerning; potiential benenfit of these simple multivariate splits.; . Bug fixes. A problem in the BDTG has been fixed, leading to a much; improved regression performance.; A problem in the TMVA::Reader has been fixed.; With the new ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html:2257,config,configurable,2257,tmva/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html,1,['config'],['configurable']
Modifiability," closing PHI nodes for the changes; to take effect). If we did not have Loop Closed SSA form, it means that X3 could; possibly be used outside the loop. So, we would have to introduce the; X4 (which is the new X3) and replace all uses of X3 with that.; However, we should note that because LLVM keeps a def-use chain; [#def-use-chain]_ for each Value, we wouldn't need; to perform data-flow analysis to find and replace all the uses; (there is even a utility function, replaceAllUsesWith(),; that performs this transformation by iterating the def-use chain). Another important advantage is that the behavior of all uses; of an induction variable is the same. Without this, you need to; distinguish the case when the variable is used outside of; the loop it is defined in, for example:. .. code-block:: C. for (i = 0; i < 100; i++) {; for (j = 0; j < 100; j++) {; k = i + j;; use(k); // use 1; }; use(k); // use 2; }. Looking from the outer loop with the normal SSA form, the first use of k; is not well-behaved, while the second one is an induction variable with; base 100 and step 1. Although, in practice, and in the LLVM context,; such cases can be handled effectively by SCEV. Scalar Evolution; (:ref:`scalar-evolution <passes-scalar-evolution>`) or SCEV, is a; (analysis) pass that analyzes and categorizes the evolution of scalar; expressions in loops. In general, it's easier to use SCEV in loops that are in LCSSA form.; The evolution of a scalar (loop-variant) expression that; SCEV can analyze is, by definition, relative to a loop.; An expression is represented in LLVM by an; `llvm::Instruction <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_.; If the expression is inside two (or more) loops (which can only; happen if the loops are nested, like in the example above) and you want; to get an analysis of its evolution (from SCEV),; you have to also specify relative to what Loop you want it.; Specifically, you have to use; `getSCEVAtScope() <https://llvm.org/doxygen/classllv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:15034,variab,variable,15034,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['variab'],['variable']
Modifiability," coding style. <string> can be:; 1. A preset: LLVM, GNU, Google, Chromium, Microsoft,; Mozilla, WebKit.; 2. 'file' to load style configuration from a; .clang-format file in one of the parent directories; of the source file (for stdin, see --assume-filename).; If no .clang-format file is found, falls back to; --fallback-style.; --style=file is the default.; 3. 'file:<format_file_path>' to explicitly specify; the configuration file.; 4. ""{key: value, ...}"" to set specific parameters, e.g.:; --style=""{BasedOnStyle: llvm, IndentWidth: 8}""; --verbose - If set, shows the list of processed files. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. .. END_FORMAT_HELP. When the desired code formatting style is different from the available options,; the style can be customized using the ``-style=""{key: value, ...}""`` option or; by putting your style configuration in the ``.clang-format`` or ``_clang-format``; file in your project's directory and using ``clang-format -style=file``. An easy way to create the ``.clang-format`` file is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. Available style options are described in :doc:`ClangFormatStyleOptions`. .clang-format-ignore; ====================. You can create ``.clang-format-ignore`` files to make ``clang-format`` ignore; certain files. A ``.clang-format-ignore`` file consists of patterns of file path; names. It has the following format:. * A blank line is skipped.; * Leading and trailing spaces of a line are trimmed.; * A line starting with a hash (``#``) is a comment.; * A non-comment line is a single pattern.; * The slash (``/``) is used as the directory separator.; * A pattern is relative to the directory of the ``.clang-format-ignore`` file; (or the root directory if the pattern starts with a slash). Patterns; containing drive names (e.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:4748,config,configuration,4748,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['config'],['configuration']
Modifiability," combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow a very accurate events; filtering. Selections allow making precise events choices: a single outlying; event is clearly visible when the lines are displayed as “solid” therefore; it is easy to make cuts in order to eliminate one single event from a; selection. Such selection (to filter one single event) on a scatter plot; would be much more difficult. ![Selections allow to easily filter one single event.](pictures/para9.png). Once a selection has been defined, it is possible to use it to generate a; `TEntryList` which is applied on the tree and used at drawing time. In our; example the selection we defined allows to select exactly the two; correlated “random spheres”. ![Output of `nt->Draw(“x:y:z”)` and `nt->Draw(“u:v:w”)` after applying the selection.](pictures/para10.png). Another technique has been implemented in order to show clusters when; the picture is cluttered. A weight is assigned to each event",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:101404,variab,variables,101404,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,2,['variab'],['variables']
Modifiability," commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:4279,variab,variables,4279,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['variab'],['variables']
Modifiability," common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; =================================. Now that we know the sort of problem we want to tackle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for induction variables, and; redefining those only goes so far :). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. # Recursive fib, we could do this before.; def fib(x); if (x < 3) then; 1; else; fib(x-1)+fib(x-2);. # Iterative fib.; def fibi(x); var a = 1, b = 1, c in; (for i = 3, i < x in; c = a + b :; a = b :; b = c) :; b;. # Call it.; fibi(10);. In order to mutate variables, we have to change our existing variables; to use the ""alloca trick"". Once we have that, we'll add our new; operator, then extend Kaleidoscope to support new variable definitions. Adjusting Existing Variables for Mutation; =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:10530,variab,variables,10530,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability," commonality; between multiple records, multiclasses allow a convenient method for; defining many records at once. For example, consider a 3-address; instruction architecture whose instructions come in two formats: ``reg = reg; op reg`` and ``reg = reg op imm`` (e.g., SPARC). We would like to specify in; one place that these two common formats exist, then in a separate place; specify what all the operations are. The ``multiclass`` and ``defm``; statements accomplish this goal. You can think of a multiclass as a macro or; template that expands into multiple records. .. productionlist::; MultiClass: ""multiclass"" `TokIdentifier` [`TemplateArgList`]; : `ParentClassList`; : ""{"" `MultiClassStatement`+ ""}""; MultiClassID: `TokIdentifier`; MultiClassStatement: `Assert` | `Def` | `Defm` | `Defvar` | `Foreach` | `If` | `Let`. As with regular classes, the multiclass has a name and can accept template; arguments. A multiclass can inherit from other multiclasses, which causes; the other multiclasses to be expanded and contribute to the record; definitions in the inheriting multiclass. The body of the multiclass; contains a series of statements that define records, using :token:`Def` and; :token:`Defm`. In addition, :token:`Defvar`, :token:`Foreach`, and; :token:`Let` statements can be used to factor out even more common elements.; The :token:`If` and :token:`Assert` statements can also be used. Also as with regular classes, the multiclass has the implicit template; argument ``NAME`` (see NAME_). When a named (non-anonymous) record is; defined in a multiclass and the record's name does not include a use of the; template argument ``NAME``, such a use is automatically *prepended*; to the name. That is, the following are equivalent inside a multiclass::. def Foo ...; def NAME # Foo ... The records defined in a multiclass are created when the multiclass is; ""instantiated"" or ""invoked"" by a ``defm`` statement outside the multiclass; definition. Each ``def`` statement in the multiclass ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:35844,inherit,inherit,35844,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,2,['inherit'],"['inherit', 'inheriting']"
Modifiability," complete; list is:. * Any location operand is ``poison`` (or ``undef``).; * Any location operand is an empty metadata tuple (``!{}``) (which cannot; occur in a ``!DIArgList``).; * There are no location operands (empty ``DIArgList``) and the ``DIExpression``; is empty. This class of dbg.value that kills variable locations is called a ""kill; dbg.value"" or ""kill location"", and for legacy reasons the term ""undef; dbg.value"" may be used in existing code. The ``DbgVariableIntrinsic`` methods; ``isKillLocation`` and ``setKillLocation`` should be used where possible rather; than inspecting location operands directly to check or set whether a dbg.value; is a kill location. In general, if any dbg.value has its operand optimized out and cannot be; recovered, then a kill dbg.value is necessary to terminate earlier variable; locations. Additional kill dbg.values may be necessary when the debugger can; observe re-ordering of assignments. How variable location metadata is transformed during CodeGen; ============================================================. LLVM preserves debug information throughout mid-level and backend passes,; ultimately producing a mapping between source-level information and; instruction ranges. This; is relatively straightforwards for line number information, as mapping; instructions to line numbers is a simple association. For variable locations; however the story is more complex. As each ``llvm.dbg.value`` intrinsic; represents a source-level assignment of a value to a source variable, the; variable location intrinsics effectively embed a small imperative program; within the LLVM IR. By the end of CodeGen, this becomes a mapping from each; variable to their machine locations over ranges of instructions.; From IR to object emission, the major transformations which affect variable; location fidelity are:. 1. Instruction Selection; 2. Register allocation; 3. Block layout. each of which are discussed below. In addition, instruction scheduling can; signifi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:23829,variab,variable,23829,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability," compound statements.; With ``applyFirst``, these rules can be expressed compactly as:. .. code-block:: c++. applyFirst({; makeRule(compoundStmt(statementCountIs(0)).bind(""empty""), ...),; makeRule(compoundStmt().bind(""non-empty""),...); }). The second rule does not need to explicitly specify that the compound statement; is non-empty -- it follows from the rules position in ``applyFirst``. For more; complicated examples, this can lead to substantially more readable code. Sometimes, a modification to the code might require the inclusion of a; particular header file. To this end, users can modify rules to specify include; directives with ``addInclude``. For additional documentation on these functions, see the header file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Using a RewriteRule as a clang-tidy check; -----------------------------------------. Transformer supports executing a rewrite rule as a; `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ check, with the class; ``clang::tidy::utils::TransformerClangTidyCheck``. It is designed to require; minimal code in the definition. For example, given a rule; ``MyCheckAsRewriteRule``, one can define a tidy check as follows:. .. code-block:: c++. class MyCheck : public TransformerClangTidyCheck {; public:; MyCheck(StringRef Name, ClangTidyContext *Context); 	 : TransformerClangTidyCheck(MyCheckAsRewriteRule, Name, Context) {}; };. ``TransformerClangTidyCheck`` implements the virtual ``registerMatchers`` and; ``check`` methods based on your rule specification, so you don't need to implement; them yourself. If the rule needs to be configured based on the language options; and/or the clang-tidy configuration, it can be expressed as a function taking; these as parameters and (optionally) returning a ``RewriteRule``. This would be; useful, for example, for our method-renaming rule, which is parameterized by the; original",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:16418,rewrite,rewrite,16418,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability," configure access restriction in THttpServer. ### Configure fastcgi with Apache2. Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more.; One only need to enable `mod_proxy` and `mod_proxy_fcgi` modules and add following line to **Apache2** configuration file:. ```; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; ```. More information can be found in [FastCGI proxy docu](https://httpd.apache.org/docs/2.4/mod/mod_proxy_fcgi.html).; After restarting apache server one should be able to open address: `http://apache_host_name/root.app/`.; There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:. ```; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; ```. ### Configure fastcgi with lighttpd. An example of configuration file for **lighttpd** server is:. ```; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); ```. Be aware, that with *lighttpd* one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: `http://lighttpd_host_name/root.app/`. Example of authorization configuration for FastCGI connection:. auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ). ## Integration with existing applications. In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a [THttpServer::Register()](https://root.cern/doc/master/classTHttpServer.html#a73658da",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:11967,config,configuration,11967,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configuration']
Modifiability," console (useful for; debugging). These functions will appear again in this document with more contextual; examples. For detailed in-line documentation (code comments), please see:. > [roofit/roofitcore/src/RooFuncWrapp9er.cxx](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooFuncWrapper.cxx). ## Appendix C - Helper functions discussed in this document. - **RooFit::Detail::CodeSquashContext::addResult()**: For a specific class, it; will add whatever is represented on the right-hand side (a function call, an; expression, etc.) to the result of this class, which can then be propagated in; the rest of the compute graph. A to call `addResult()`must be included in; `translate()` function. - Inputs: `key` (the name of the node to add the result for), `value` (the; new name to assign/overwrite).; - Output: Adds (or overwrites) the string representing the result of a node. - **RooFit::Detail::CodeSquashContext::getResult()**: It helps lookup the; result of a child node (the string that the child node previously saved in a; variable using the `addResult()` function). - Input: `key` (the node to get the result string for).; - Output: String representing the result of this node. - **RooFit::Detail::CodeSquashContext::addToCodeBody()**: Takes whatever string; is computed in its arguments and adds it to the overall function string (which; will later be just-in-time compiled). - Inputs: `klass` (the class requesting this addition, usually 'this'), `in`; (string to add to the squashed code).; - Output: Adds the input string to the squashed code body. - **RooFit::Detail::CodeSquashContext::addToGlobalScope()**: Helps declare and; initialize the results variable, so that it can be available globally; (throughout the function body). - Input: `str` (the string to add to the global scope).; - Output: Adds the given string to the string block that will be emitted at; the top of the squashed function. - **RooFit::Detail::CodeSquashContext::assembleCode()**: combin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:35159,variab,variable,35159,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['variab'],['variable']
Modifiability," const;. If the compression level is set to 0, then no compression will be; done. All of the currently supported algorithms allow the level to be; set to any value from 1 to 9. The higher the level, the larger the; compression factors will be (smaller compressed data size). The; tradeoff is that for higher levels more CPU time is used for; compression and possibly more memory. The ZLIB algorithm takes less; CPU time during compression than the LZMA algorithm, but the LZMA; algorithm usually delivers higher compression factors. The header file core/zip/inc/Compression.h declares the function; ""CompressionSettings"" and the enumeration for the algorithms.; Currently the following selections can be made for the algorithm:; kZLIB (1), kLZMA (2), kOldCompressionAlgo (3), and kUseGlobalSetting; (0). The last option refers to an older interface used to control the; algorithm that is maintained for backward compatibility. The following; function is defined in core/zip/inc/Bits.h and it set the global; variable. R__SetZipMode(int algorithm);. If the algorithm is set to kUseGlobalSetting (0), the global variable; controls the algorithm for compression operations. This is the; default and the default value for the global variable is kZLIB. gDirectory; gDirectory is now a thread local!. The value of gDirectory and gFile are now all accessed via a static function of their respective class. The access is made transparent via a CPP macro. Note: Whenever a thread has an associated TThread object, the value of gDirectory is now thread local, i.e. all modifications direct or indirect of gDirectory will not be seen by the other thread. In particular this means that several I/O operations (including TDirectory::Write) are thread safe (as long as all the required TClass and TStreamerInfo has been previously setup).; Note: This model does not support sharing TFile amongst threads (i.e. a TFile must be accessed from exactly one thread). This means that whenever a TFile's control is passed ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:2672,variab,variable,2672,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,1,['variab'],['variable']
Modifiability," construct distributions. This is not an exhaustive list, and many; additional options are documented in the :doc:`CMake` page. Some key options; that are already documented include: *LLVM_TARGETS_TO_BUILD*, *LLVM_ENABLE_PROJECTS*,; *LLVM_ENABLE_RUNTIMES*, *LLVM_BUILD_LLVM_DYLIB*, and *LLVM_LINK_LLVM_DYLIB*. **LLVM_ENABLE_RUNTIMES**:STRING; When building a distribution that includes LLVM runtime projects (i.e. libcxx,; compiler-rt, libcxxabi, libunwind...), it is important to build those projects; with the just-built compiler. **LLVM_DISTRIBUTION_COMPONENTS**:STRING; This variable can be set to a semi-colon separated list of LLVM build system; components to install. All LLVM-based tools are components, as well as most; of the libraries and runtimes. Component names match the names of the build; system targets. **LLVM_DISTRIBUTIONS**:STRING; This variable can be set to a semi-colon separated list of distributions. See; the :ref:`Multi-distribution configurations` section above for details on this; and other CMake variables to configure multiple distributions. **LLVM_RUNTIME_DISTRIBUTION_COMPONENTS**:STRING; This variable can be set to a semi-colon separated list of runtime library; components. This is used in conjunction with *LLVM_ENABLE_RUNTIMES* to specify; components of runtime libraries that you want to include in your distribution.; Just like with *LLVM_DISTRIBUTION_COMPONENTS*, component names match the names; of the build system targets. **LLVM_DYLIB_COMPONENTS**:STRING; This variable can be set to a semi-colon separated name of LLVM library; components. LLVM library components are either library names with the LLVM; prefix removed (i.e. Support, Demangle...), LLVM target names, or special; purpose component names. The special purpose component names are:. #. ``all`` - All LLVM available component libraries; #. ``Native`` - The LLVM target for the Native system; #. ``AllTargetsAsmParsers`` - All the included target ASM parsers libraries; #. ``AllTargetsDescs`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:11894,config,configurations,11894,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,3,"['config', 'variab']","['configurations', 'configure', 'variables']"
Modifiability," construct-expression.; Apart from the technical difficulties of juggling program points around; correctly to avoid accidentally merging paths together, we'll have to; be a judge on when to exit the loop and how to widen it.; Given that the constructor is going to be a default constructor,; a nice 95% solution might be to execute exactly one constructor and; then default-bind the resulting LazyCompoundVal to the whole array;; it'll work whenever the default constructor doesn't touch global state; but only initializes the object to various default values.; But if, say, we're making an array of strings,; depending on the implementation you might have to allocate a new buffer; for each string, and in this case default-binding won't cut it.; We might want to come up with an auxiliary analysis in order to perform; widening of these simple loops more precisely.; . Handle constructors that can be elided due to Named Return Value Optimization (NRVO); Local variables which are returned by values on all return statements; may be stored directly at the address for the return value,; eliding the copy or move constructor call.; Such variables can be identified using the AST call VarDecl::isNRVOVariable.; . Handle constructors of lambda captures; Variables which are captured by value into a lambda require a call to; a copy constructor.; This call is not currently modeled.; . Handle constructors for default arguments; Default arguments in C++ are recomputed at every call,; and are therefore local, and not static, variables.; See tests cases in handle_constructors_for_default_arguments.cpp.; . Default arguments are annoying because the initializer expression is; evaluated at the call site but doesn't syntactically belong to the; caller's AST; instead it belongs to the ParmVarDecl for the default; parameter. This can lead to situations when the same expression has to; carry different values simultaneously -; when multiple instances of the same function are evaluated as part of the; s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:4002,variab,variables,4002,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['variab'],['variables']
Modifiability, constructors and destructors of templates; Yes. 636; CD4; Dynamic type of objects and aliasing; Unknown. 637; CD1; Sequencing rules and example disagree; Yes. 638; CD2; Explicit specialization and friendship; No. 639; CD1; What makes side effects “different” from one another?; Clang 3.3. 640; NAD; Accessing destroyed local objects of static storage duration; Unknown. 641; CD2; Overload resolution and conversion-to-same-type operators; Yes. 642; CD2; Definition and use of “block scope” and “local scope”; Yes. 643; NAD; Use of decltype in a class member-specification; Clang 3.2. 644; CD1; Should a trivial class type be a literal type?; Partial. 645; CD2; Are bit-field and non-bit-field members layout compatible?; N/A. 646; NAD; Can a class with a constexpr copy constructor be a literal type?; Superseded by 981. 647; CD1; Non-constexpr instances of constexpr constructor templates; Clang 3.1. 648; CD1; Constant expressions in constexpr initializers; Yes. 649; CD1; Optionally ill-formed extended alignment requests; Clang 3.5. 650; CD2; Order of destruction for temporaries bound to the returned value of a function; Unknown. 651; CD1; Problems in decltype specification and examples; Yes. 652; CD2; Compile-time evaluation of floating-point expressions; Yes. 653; CD2; Copy assignment of unions; Unknown. 654; CD1; Conversions to and from nullptr_t; Superseded by 1423. 655; C++11; Initialization not specified for forwarding constructors; Yes. 656; CD2; Direct binding to the result of a conversion operator; Yes. 657; CD2; Abstract class parameter in synthesized declaration; Partial. 658; CD2; Defining reinterpret_cast for pointer types; Unknown. 659; CD1; Alignment of function types; Clang 3.0. 660; CD1; Unnamed scoped enumerations; Clang 3.0. 661; CD1; Semantics of arithmetic comparisons; Unknown. 662; NAD; Forming a pointer to a reference type; Yes. 663; CD1; Valid Cyrillic identifier characters; Superseded by P1949. 664; CD2; Direct binding of references to non-class rvalue,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:44360,extend,extended,44360,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['extend'],['extended']
Modifiability," constructs to describe source locations and variable locations. Source locations; ^^^^^^^^^^^^^^^^. Every MIR instruction may optionally have a trailing reference to a; ``DILocation`` metadata node, after all operands and symbols, but before; memory operands:. .. code-block:: text. $rbp = MOV64rr $rdi, debug-location !12. The source location attachment is synonymous with the ``!dbg`` metadata; attachment in LLVM-IR. The absence of a source location attachment will be; represented by an empty ``DebugLoc`` object in the machine instruction. Fixed variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^. There are several ways of specifying variable locations. The simplest is; describing a variable that is permanently located on the stack. In the stack; or fixedStack attribute of the machine function, the variable, scope, and; any qualifying location modifier are provided:. .. code-block:: text. - { id: 0, name: offset.addr, offset: -24, size: 8, alignment: 8, stack-id: default,; 4 debug-info-variable: '!1', debug-info-expression: '!DIExpression()',; debug-info-location: '!2' }. Where:. - ``debug-info-variable`` identifies a DILocalVariable metadata node,. - ``debug-info-expression`` adds qualifiers to the variable location,. - ``debug-info-location`` identifies a DILocation metadata node. These metadata attributes correspond to the operands of a ``llvm.dbg.declare``; IR intrinsic, see the :ref:`source level debugging<format_common_intrinsics>`; documentation. Varying variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Variables that are not always on the stack or change location are specified; with the ``DBG_VALUE`` meta machine instruction. It is synonymous with the; ``llvm.dbg.value`` IR intrinsic, and is written:. .. code-block:: text. DBG_VALUE $rax, $noreg, !123, !DIExpression(), debug-location !456. The operands to which respectively:. 1. Identifies a machine location such as a register, immediate, or frame index,. 2. Is either $noreg, or immediate value zero if an extra level",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:24937,variab,variable,24937,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability," contents::; :local:. Overview; ========. The LLVM build system is designed to facilitate the building of third party; projects that use LLVM header files, libraries, and tools. In order to use; these facilities, a ``Makefile`` from a project must do the following things:. * Set ``make`` variables. There are several variables that a ``Makefile`` needs; to set to use the LLVM build system:. * ``PROJECT_NAME`` - The name by which your project is known.; * ``LLVM_SRC_ROOT`` - The root of the LLVM source tree.; * ``LLVM_OBJ_ROOT`` - The root of the LLVM object tree.; * ``PROJ_SRC_ROOT`` - The root of the project's source tree.; * ``PROJ_OBJ_ROOT`` - The root of the project's object tree.; * ``PROJ_INSTALL_ROOT`` - The root installation directory.; * ``LEVEL`` - The relative path from the current directory to the; project's root ``($PROJ_OBJ_ROOT)``. * Include ``Makefile.config`` from ``$(LLVM_OBJ_ROOT)``. * Include ``Makefile.rules`` from ``$(LLVM_SRC_ROOT)``. There are two ways that you can set all of these variables:. * You can write your own ``Makefiles`` which hard-code these values. * You can use the pre-made LLVM sample project. This sample project includes; ``Makefiles``, a configure script that can be used to configure the location; of LLVM, and the ability to support multiple object directories from a single; source directory. If you want to devise your own build system, studying other projects and LLVM; ``Makefiles`` will probably provide enough information on how to write your own; ``Makefiles``. Source Tree Layout; ==================. In order to use the LLVM build system, you will want to organize your source; code so that it can benefit from the build system's features. Mainly, you want; your source tree layout to look similar to the LLVM source tree layout. Underneath your top level directory, you should have the following directories:. **lib**. This subdirectory should contain all of your library source code. For each; library that you build, you will hav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:1100,variab,variables,1100,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,1,['variab'],['variables']
Modifiability," context specified by ``--dump-input-context``. When; there are multiple occurrences of this option, the ``<value>`` that appears; earliest in the list below has precedence. The default is ``error`` when; ``--dump-input=fail``, and it's ``all`` when ``--dump-input=always``. * ``all`` - All input lines; * ``annotation-full`` - Input lines with annotations; * ``annotation`` - Input lines with starting points of annotations; * ``error`` - Input lines with starting points of error annotations. .. option:: --enable-var-scope. Enables scope for regex variables. Variables with names that start with ``$`` are considered global and; remain set throughout the file. All other variables get undefined after each encountered ``CHECK-LABEL``. .. option:: -D<VAR=VALUE>. Sets a filecheck pattern variable ``VAR`` with value ``VALUE`` that can be; used in ``CHECK:`` lines. .. option:: -D#<FMT>,<NUMVAR>=<NUMERIC EXPRESSION>. Sets a filecheck numeric variable ``NUMVAR`` of matching format ``FMT`` to; the result of evaluating ``<NUMERIC EXPRESSION>`` that can be used in; ``CHECK:`` lines. See section; ``FileCheck Numeric Variables and Expressions`` for details on supported; numeric expressions. .. option:: -version. Show the version number of this program. .. option:: -v. Print good directive pattern matches. However, if ``-dump-input=fail`` or; ``-dump-input=always``, add those matches as input annotations instead. .. option:: -vv. Print information helpful in diagnosing internal FileCheck issues, such as; discarded overlapping ``CHECK-DAG:`` matches, implicit EOF pattern matches,; and ``CHECK-NOT:`` patterns that do not have matches. Implies ``-v``.; However, if ``-dump-input=fail`` or ``-dump-input=always``, just add that; information as input annotations instead. .. option:: --allow-deprecated-dag-overlap. Enable overlapping among matches in a group of consecutive ``CHECK-DAG:``; directives. This option is deprecated and is only provided for convenience; as old tests are migrated to t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:6311,variab,variable,6311,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability," copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has; a name and a type separated by a ""/"" and it is separated from the next; leaf by a ""`:`"". ``` {.cpp}; <Variable>/<type>:<Variable>/<type>; ```. The example on the next line has two leafs: a floating-point number; called temp and an integer named `ntrack`. ``` {.cpp}; ""temp/F:ntrack/I:""; ```. The type can be omitted and if no type is given, the same type as the; previous variable is assumed. This leaf list has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a charact",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:20143,variab,variable,20143,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability," corresponding floating-point value. If the; value cannot be exactly represented, it is rounded using the default rounding; mode. Example:; """""""""""""""". .. code-block:: llvm. %X = sitofp i32 257 to float ; yields float:257.0; %Y = sitofp i8 -1 to double ; yields double:-1.0. .. _i_ptrtoint:. '``ptrtoint .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = ptrtoint <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``ptrtoint``' instruction converts the pointer or a vector of; pointers ``value`` to the integer (or vector of integers) type ``ty2``. Arguments:; """""""""""""""""""". The '``ptrtoint``' instruction takes a ``value`` to cast, which must be; a value of type :ref:`pointer <t_pointer>` or a vector of pointers, and a; type to cast it to ``ty2``, which must be an :ref:`integer <t_integer>` or; a vector of integers type. Semantics:; """""""""""""""""""". The '``ptrtoint``' instruction converts ``value`` to integer type; ``ty2`` by interpreting the pointer value as an integer and either; truncating or zero extending that value to the size of the integer type.; If ``value`` is smaller than ``ty2`` then a zero extension is done. If; ``value`` is larger than ``ty2`` then a truncation is done. If they are; the same size, then nothing is done (*no-op cast*) other than a type; change. Example:; """""""""""""""". .. code-block:: llvm. %X = ptrtoint ptr %P to i8 ; yields truncation on 32-bit architecture; %Y = ptrtoint ptr %P to i64 ; yields zero extension on 32-bit architecture; %Z = ptrtoint <4 x ptr> %P to <4 x i64>; yields vector zero extension for a vector of addresses on 32-bit architecture. .. _i_inttoptr:. '``inttoptr .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = inttoptr <ty> <value> to <ty2>[, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>] ; yields ty2. Overview:; """""""""""""""""". The '``inttoptr``' instruction converts an integer ``value`` to a; pointer type, ``ty2``.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:453345,extend,extending,453345,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extending']
Modifiability," could create a pointer type that; has an ABI mismatch. Looking at the following example, ``int *local`` is; implicitly ``int *__bidi_indexable`` and thus the type of ``&local`` is a; pointer to ``int *__bidi_indexable``. On the other hand, in ``void foo(int; **)``, the parameter type is a pointer to ``int *__single`` (i.e., ``void; foo(int *__single *__single)``) (or a pointer to ``int *__unsafe_indexable`` if; it's from a system header). The compiler reports an error for casts between; pointers whose elements have incompatible pointer attributes. This way,; ``-fbounds-safety`` prevents pointers that are implicitly ``__bidi_indexable``; from silently escaping thereby breaking the ABI. .. code-block:: c. void foo(int **);. void bar(void) {; int *local = 0;; // error: passing 'int *__bidi_indexable*__bidi_indexable' to parameter of; // incompatible nested pointer type 'int *__single*__single'; foo(&local);; }. A local variable may still be exposed to the ABI if ``typeof()`` takes the type; of local variable to define an interface as shown in the following example. .. code-block:: C. // bar.c; void bar(int *) { ... }. // foo.c; void foo(void) {; int *p; // implicitly `int *__bidi_indexable p`; extern void bar(typeof(p)); // creates an interface of type; // `void bar(int *__bidi_indexable)`; }. Doing this may break the ABI if the parameter is not ``__bidi_indexable`` at the; definition of function ``bar()`` which is likely the case because parameters are; ``__single`` by default without an explicit annotation. In order to avoid an implicitly wide pointer from silently breaking the ABI, the; compiler reports a warning when ``typeof()`` is used on an implicit wide pointer; at any ABI visible context (e.g., function prototype, struct definition, etc.). .. _Default pointer types in typeof:. Default pointer types in ``typeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``typeof()`` takes an expression, it respects the bounds annotation on; the expression type, including ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:24519,variab,variable,24519,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,['variab'],['variable']
Modifiability," cppyy.gbl.std.string at 0x7fa75edbf8a0>; >>> s == ""aap""; True; >>>. To pass an argument through a C++ ``char`` (signed or unsigned) use a Python; string of size 1.; In many cases, the explicit C types from module ``ctypes`` can also be used,; but that module does not have a public API (for type conversion or otherwise),; so support is somewhat limited. There are automatic conversions between C++'s ``std::vector`` and Python's; ``list`` and ``tuple``, where possible, as they are often used in a similar; manner.; These datatypes have completely different memory layouts, however, and the; ``std::vector`` requires that all elements are of the same type and laid; out consecutively in memory.; Conversion thus requires type checks, memory allocation, and copies.; This can be rather expensive.; See the section on :ref:`STL <stl>`. `Arrays`; """""""""""""""". Builtin arrays are supported through arrays from module ``array`` (or any; other builtin-type array that implements the Python buffer interface, such; as numpy arrays) and a low-level view type from ``cppyy`` for returns and; variable access (that implements the buffer interface as well).; Out-of-bounds checking is limited to those cases where the size is known at; compile time.; Example:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> from array import array; >>> c = Concrete(); >>> c.array_method(array('d', [1., 2., 3., 4.]), 4); 1 2 3 4; >>> c.m_data[4] # static size is 4, so out of bounds; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: buffer index out of range; >>>. Arrays of arrays are supported through the C++ low-level view objects.; This only works well if sizes are known at compile time or can be inferred.; If sizes are not known, the size is set to a large integer (depending on the; array element size) to allow access.; It is then up to the developer not to access the array out-of-bounds.; There is limited support for arrays of instances, but those should be avo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst:3329,variab,variable,3329,bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,1,['variab'],['variable']
Modifiability," create objects: a tool bar and its picture buttons.; This sample code creates the following three toolbar buttons:. ![](pictures/03000218.png). First we need to complete a `ToolBarData_t` structure for each tool bar; button before adding it to the tool bar. This structure contains:. - the icon file name ""`filename.xpm`"". - the tool tip text - a short help message explaining the button; purpose. - the Boolean variable defining the button behavior when is clicked. - `kFALSE` - do not stay down. - `kTRUE` - to stay down. - the button ID. - the button pointer (**`TGButton *`**) - should be `NULL`. We create an array `*xpms[]` containing the icon file names that will be; used for a picture button creation. If you write only the file names; here ROOT will search these files in `$ROOTSYS/icons` directory. If the; icon files are not there, you should provide the full path name also.; The array `*tips[] `contains the tool tip texts for buttons. The integer; variable separator is used to set the distance between two groups of; toolbar buttons. It defines the amount of pixels to the left for each; button. We create a tool bar object and add the buttons using the `AddButton`; method. The variable separator helps us to define no space between the; buttons in a group (0), and 5 pixels extra-space before and after. All; buttons added via this method will be deleted by the toolbar. On return; the **`TGButton`** field of the `ToolBarData_t` structure is filled in; (if the icon pixmap was valid). The first parameter is the window to; which the button messages will be sent. Lastly, we create an object of; class **`TGHorizontal3DLine`** - a horizontal 3D line. It will separate; the toolbar from the menu bar because the layout hints we define as; `kLHintsTop` | `kLHintsExpandX`. It is user friendly to allow the possibility for the tool bar to be; turned on or off (via a menu). If you use a single tool bar, it should; fill the complete width of its parent. When using more than one, you;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:76834,variab,variable,76834,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['variab'],['variable']
Modifiability," data flow analysis to identify an output; parameter. The refactoring can be safely done when the data flow algorithm; computes a normal state with all of the fields proven to be overwritten in the; exit basic block of the function. ```c++; struct Customer {; int account_id;; std::string name;; };. void GetCustomer(Customer* c) {; // Overwritten: {}; c->account_id = ...; // Overwritten: {c->account_id}; if (...) {; c->name = ...; // Overwritten: {c->account_id, c->name}; } else {; c->name = ...; // Overwritten: {c->account_id, c->name}; }; // Overwritten: {c->account_id, c->name}; }; ```. When the data flow algorithm computes a normal state, but not all fields are; proven to be overwritten we can't perform the refactoring. ```c++; void target(bool b, Customer* c) {; // Overwritten: {}; if (b) {; c->account_id = 42; // Overwritten: {c->account_id}; } else {; c->name = ""Konrad""; // Overwritten: {c->name}; }; // Overwritten: {}; }; ```. Similarly, when the data flow algorithm computes a failure state, we also can't; perform the refactoring. ```c++; Customer* kGlobalCustomer;. void GetCustomer(Customer* c) {; // Overwritten: {}; c->account_id = ...; // Overwritten: {c->account_id}; if (...) {; print(c->name); // Unsafe read; } else {; kGlobalCustomer = c; // Pointer escape; }; // Unsafe read, Pointer escape; }; ```. ## Example: finding dead stores. Let's say we want to find redundant stores, because they indicate potential; bugs. ```c++; x = GetX();; x = GetY();; ```. The first store to `x` is never read, probably there is a bug. The implementation of dead store analysis is very similar to output parameter; analysis: we need to track stores and loads, and find stores that were never; read. [Liveness analysis](https://en.wikipedia.org/wiki/Live_variable_analysis) is a; generalization of this idea, which is often used to answer many related; questions, for example:. * finding dead stores,; * finding uninitialized variables,; * finding a good point to deallocate memory,; *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:19332,refactor,refactoring,19332,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactoring']
Modifiability," data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y values with the uncertainty; of $\pm 0.5$, assuming the probability that Y takes any value between Y-0.5; and Y+0.5 is uniform (the same argument for Y uniformly distributed; between Y and Y+1). An example is an ADC measurement. The '`G`' option; is useful, if all Y variables are distributed according to some known; Gaussian of standard deviation Sigma. For example when all Y's are; experimental quantities measured with the same instrument with; precision Sigma. The next figure shows the graphic output of this; simple example of a profile histogram. ``` {.cpp}; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Profile example"",200,10,700,500);. // Create a profile with the name, title, the number of bins,; // the low and high limit of the x-axis and the low and high; // limit of the y-axis.; // No option is given so the default is used.; hprof = new TProfile(""hprof"",; ""Profile of pz versus px"",100,-4,4,0,20);. // Fill the profile 25000 times with random numbers; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; // Use the random number generator to get two numbers following; // a gaussian distribution with mean=0 and sigma=1; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }; ```. ![A p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:65425,variab,variables,65425,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variables']
Modifiability," data there. Installing the Virtual Analysis Facility client; -----------------------------------------------. ### Download the client from Git. The Virtual Analysis Facility client is available on; [GitHub](https://github.com/dberzano/virtual-analysis-facility):. ``` {.bash}; git clone git://github.com/dberzano/virtual-analysis-facility.git /dest/dir; ```. The client will be found in `/dest/dir/client/bin/vaf-enter`: it is; convenient to add it to the `$PATH` so that the users might simply start; it by typing `vaf-enter`. ### Install the experiment's configuration files system-wide. A system administrator might find convenient to install the experiment; environment scripts system-wide. Configuration scripts for LHC experiments are shipped with the VAF; client and can be found in; `/dest/dir/client/config-samples/<experiment_name>`. To make them used; by default by the VAF client, place them in the `/dest/dir/etc`; directory like this:. ``` {.bash}; rsync -a /dest/dir/client/config-samples/<experiment_name>/ /dest/dir/etc/; ```. Remember that the trailing slash in the source directory name has a; meaning in `rsync` and must not be omitted. > Remember that system-wide configuration files will always have; > precedence over user's configuration files, so *don't place there; > files that are supposed to be provided by the user!*. Entering the Virtual Analysis Facility environment; --------------------------------------------------. The Virtual Analysis Facility client is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:7745,config,config-samples,7745,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['config'],['config-samples']
Modifiability," default, a histogram axis is drawn with its numeric bin labels. One; can specify alphanumeric labels instead. ### Option 1: SetBinLabel. To set an alphanumeric bin label call:. ``` {.cpp}; TAxis::SetBinLabel(bin,label);; ```. This can always be done before or after filling. Bin labels will be; automatically drawn with the histogram. ![Histograms with alphanumeric bin labels](pictures/0600003B.png). See example in `$ROOTSYS/tutorials/hist/hlabels1.C` , `hlabels2.C`. ### Option 2: Fill. You can also call a `Fill()` function with one of the arguments being; a string:. ``` {.cpp}; hist1->Fill(somename,weigth);; hist2->Fill(x,somename,weight);; hist2->Fill(somename,y,weight);; hist2->Fill(somenamex,somenamey,weight);; ```. ### Option 3: TTree::Draw. You can use a char\* variable type to histogram strings with; **`TTree`**`::Draw()`. ``` {.cpp}; // here ""Nation"" and ""Division"" are two char* branches of a Tree; tree.Draw(""Nation::Division"", """", ""text"");; ```. ![Using a \*char variable type in TTree::Draw](pictures/0200003C.png). There is an example in `$ROOTSYS/tutorials/tree/cernstaff.C.`. If a variable is defined as `char*` it is drawn as a string by default.; You change that and draw the value of `char[0]` as an integer by; adding an arithmetic operation to the expression as shown below. ``` {.cpp}; // draw the integer value of MyChar[0] where ""MyChar"" is char[5]; tree.Draw(""MyChar + 0"");; ```. ### Sort Options. When using the options 2 or 3 above, the labels are automatically; added to the list (**`THashList`**) of labels for a given axis. By; default, an axis is drawn with the order of bins corresponding to the; filling sequence. It is possible to reorder the axis alphabetically or; by increasing or decreasing values. The reordering can be triggered; via the **`TAxis`** context menu by selecting the menu item; ""`LabelsOption` "" or by calling directly. ``` {.cpp}; TH1::LabelsOption(option,axis);; ```. Here `axis` may be X, Y, or Z. The parameter `option` may be:. - ""`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:57094,variab,variable,57094,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variable']
Modifiability," defaults to lowering such barriers to normal loads; and stores unless you arrange otherwise. Implementing a collector plugin; -------------------------------. User code specifies which GC code generation to use with the ``gc`` function; attribute or, equivalently, with the ``setGC`` method of ``Function``. To implement a GC plugin, it is necessary to subclass ``llvm::GCStrategy``,; which can be accomplished in a few lines of boilerplate code. LLVM's; infrastructure provides access to several important algorithms. For an; uncontroversial collector, all that remains may be to compile LLVM's computed; stack map to assembly code (using the binary representation expected by the; runtime library). This can be accomplished in about 100 lines of code. This is not the appropriate place to implement a garbage collected heap or a; garbage collector itself. That code should exist in the language's runtime; library. The compiler plugin is responsible for generating code which conforms; to the binary interface defined by library, most essentially the :ref:`stack map; <stack-map>`. To subclass ``llvm::GCStrategy`` and register it with the compiler:. .. code-block:: c++. // lib/MyGC/MyGC.cpp - Example LLVM GC plugin. #include ""llvm/CodeGen/GCStrategy.h""; #include ""llvm/CodeGen/GCMetadata.h""; #include ""llvm/Support/Compiler.h"". using namespace llvm;. namespace {; class LLVM_LIBRARY_VISIBILITY MyGC : public GCStrategy {; public:; MyGC() {}; };. GCRegistry::Add<MyGC>; X(""mygc"", ""My bespoke garbage collector."");; }. This boilerplate collector does nothing. More specifically:. * ``llvm.gcread`` calls are replaced with the corresponding ``load``; instruction. * ``llvm.gcwrite`` calls are replaced with the corresponding ``store``; instruction. * No safe points are added to the code. * The stack map is not compiled into the executable. Using the LLVM makefiles, this code; can be compiled as a plugin using a simple makefile:. .. code-block:: make. # lib/MyGC/Makefile. LEVEL := ../..; LIBRAR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:24195,plugin,plugin,24195,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability," definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Always break after the return type of function definitions. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int f();; int; f() {; return 1;; }. * ``RTBS_TopLevelDefinitions`` (in configuration: ``TopLevelDefinitions``); Always break after the return type of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int; f() {; return 1;; }. .. _AlwaysBreakBeforeMultilineStrings:. **AlwaysBreakBeforeMultilineStrings** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakBeforeMultilineStrings>`; If ``true``, always",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:33365,config,configuration,33365,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability, delegating constructors is enabled. C++11 ``deleted`` functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_deleted_functions)`` or; ``__has_extension(cxx_deleted_functions)`` to determine if support for deleted; function definitions (with ``= delete``) is enabled. C++11 explicit conversion functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_explicit_conversions)`` to determine if support for; ``explicit`` conversion functions is enabled. C++11 generalized initializers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_generalized_initializers)`` to determine if support for; generalized initializers (using braced lists and ``std::initializer_list``) is; enabled. C++11 implicit move constructors/assignment operators; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_implicit_moves)`` to determine if Clang will implicitly; generate move constructors and move assignment operators where needed. C++11 inheriting constructors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_inheriting_constructors)`` to determine if support for; inheriting constructors is enabled. C++11 inline namespaces; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_inline_namespaces)`` or; ``__has_extension(cxx_inline_namespaces)`` to determine if support for inline; namespaces is enabled. C++11 lambdas; ^^^^^^^^^^^^^. Use ``__has_feature(cxx_lambdas)`` or ``__has_extension(cxx_lambdas)`` to; determine if support for lambdas is enabled. C++11 local and unnamed types as template arguments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_local_type_template_args)`` or; ``__has_extension(cxx_local_type_template_args)`` to determine if support for; local and unnamed types as template arguments is enabled. C++11 noexcept; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_noexcept)`` or ``__has_extension(cxx_noexcept)`` to; determine if support for noexcept exception specifications is enabled. C++11 in-class non-sta,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:43673,inherit,inheriting,43673,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['inherit'],['inheriting']
Modifiability," density:. ~~~{.cpp}; TGeoMixture(const char *name,Int_t nel,Double_t rho);; ~~~. Elements have to be further defined one by one:. ~~~{.cpp}; void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,; Double_t weigth);; void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; ~~~. or:. ~~~{.cpp}; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight); ~~~. - `iel:` index of the element` [0,nel-1]`; - `a` and `z:` the atomic mass and charge; - `weight:` proportion by mass of the elements; - `natoms`: number of atoms of the element in the molecule making the; mixture. The radiation length is automatically computed when all elements are; defined. Since tracking MC provide several other ways to create; materials/mixtures, the materials classes are likely to evolve as the; interfaces to these engines are being developed. Generally in the; process of tracking material properties are not enough and more specific; media properties have to be defined. These highly depend on the MC; performing tracking and sometimes allow the definition of different; media properties (e.g. energy or range cuts) for the same material. \anchor GM00b; ### Radionuclides. A new class TGeoElementRN was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (TGeoElementTable class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ~~~{.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md:4552,evolve,evolve,4552,geom/geom/doc/materials.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md,1,['evolve'],['evolve']
Modifiability," depth. The ROOT default for; the split-level is 99. This means the object will be split to the; maximum. #### Memory Considerations when Splitting a Branch. Splitting a branch can quickly generate many branches. Each branch has; its own buffer in memory. In case of many branches (say more than 100),; you should adjust the buffer size accordingly. A recommended buffer size; is 32000 bytes if you have less than 50 branches. Around 16000 bytes if; you have less than 100 branches and 4000 bytes if you have more than 500; branches. These numbers are recommended for computers with memory size; ranging from 32MB to 256MB. If you have more memory, you should specify; larger buffer sizes. However, in this case, do not forget that your file; might be used on another machine with a smaller memory configuration. #### Performance Considerations when Splitting a Branch. A split branch is faster to read, but slightly slower to write. The; reading is quicker because variables of the same type are stored; consecutively and the type does not have to be read each time. It is; slower to write because of the large number of buffers as described; above. See "". Performance Benchmarks"" for performance impact of split and non-split; mode. #### Rules for Splitting. When splitting a branch, variables of different types are handled; differently. Here are the rules that apply when splitting a branch. - If a data member is a basic type, it becomes one branch of class; **`TBranchElement`**. - A data member can be an array of basic types. In this case, one; single branch is created for the array. - A data member can be a pointer to an array of basic types. The; length can vary, and must be specified in the comment field of the; data member in the class definition. See ""Input/Output"". - Pointer data member are not split, except for pointers to a; **`TClonesArray`**. The **`TClonesArray`** (pointed to) is split if; the split level is greater than two. When the split level is one,; the **`TClonesArr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:26557,variab,variables,26557,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability," dereferenced. struct LinkedList {; int data;; struct LinkedList *next;; };. struct LinkedList * _Nullable getNext(struct LinkedList *l);. void updateNextData(struct LinkedList *list, int newData) {; struct LinkedList *next = getNext(list);; // Warning: Nullable pointer is dereferenced; next->data = 7;; }. nullability.NullablePassedToNonnull; (ObjC); Warns when a nullable pointer is passed to a pointer which has a _Nonnull type. typedef struct Dummy { int val; } Dummy;; Dummy *_Nullable returnsNullable();; void takesNonnull(Dummy *_Nonnull);. void test() {; Dummy *p = returnsNullable();; takesNonnull(p); // warn; }. Optin Checkers. Name, DescriptionExample. cplusplus.UninitializedObject; (C++); This checker reports uninitialized fields in objects created after a constructor; call. It doesn't only find direct uninitialized fields, but rather makes a deep; inspection of the object, analyzing all of it's fields subfields. ; The checker regards inherited fields as direct fields, so one will recieve; warnings for uninitialized inherited data members as well. . It has several options:. ""Pedantic"" (boolean). If its not set or is set to false, the; checker won't emit warnings for objects that don't have at least one; initialized field. This may be set with ; -analyzer-config cplusplus.UninitializedObject:Pedantic=true.; . ""NotesAsWarnings"" (boolean). If set to true, the checker will; emit a warning for each uninitalized field, as opposed to emitting one; warning per constructor call, and listing the uninitialized fields that; belongs to it in notes. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:NotesAsWarnings=true.; . ""CheckPointeeInitialization"" (boolean). If set to false, the; checker will not analyze the pointee of pointer/reference fields, and will; only check whether the object itself is initialized. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:CheckPointeeInitialization=true.; . ""IgnoreRecordsWithField"" (string). If supplie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:7900,inherit,inherited,7900,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['inherit'],['inherited']
Modifiability," described later.; Instructions are available on this; website on how to use open source builds of the analyzer as a replacement for; the one bundled with Xcode.; Using scan-build directly; If you wish to use scan-build with your iPhone project, keep the; following things in mind:. Analyze your project in the Debug configuration, either by setting; this as your configuration with Xcode or by passing -configuration; Debug to xcodebuild.; Analyze your project using the Simulator as your base SDK. It is; possible to analyze your code when targeting the device, but this is much; easier to do when using Xcode's Build and Analyze feature.; Check that your code signing SDK is set to the simulator SDK as well, and make sure this option is set to Don't Code Sign. Note that you can most of this without actually modifying your project. For; example, if your application targets iPhoneOS 2.2, you could run; scan-build in the following manner from the command line:. $ scan-build xcodebuild -configuration Debug -sdk iphonesimulator2.2. Alternatively, if your application targets iPhoneOS 3.0:. $ scan-build xcodebuild -configuration Debug -sdk iphonesimulator3.0. Gotcha: using the right compiler; Recall that scan-build analyzes your project by using a compiler to; compile the project and clang to analyze your project. The script uses; simple heuristics to determine which compiler should be used (it defaults to; clang on Darwin and gcc on other platforms). When analyzing; iPhone projects, scan-build may pick the wrong compiler than the one; Xcode would use to build your project. For example, this could be because; multiple versions of a compiler may be installed on your system, especially if; you are developing for the iPhone.; When compiling your application to run on the simulator, it is important that scan-build; finds the correct version of gcc/clang. Otherwise, you may see strange build; errors that only happen when you run scan-build. scan-build provides the --use-cc and --use-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:9544,config,configuration,9544,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['config'],['configuration']
Modifiability," determine volume size. KernelEstimator No Box Box, Sphere, Teepee, Gauss, Sinc3, Sinc5, Sinc7, Sinc9, Sinc11, Lanczos2, Lanczos3, Lanczos5, Lanczos8, Trim Kernel estimation function. DeltaFrac No 3 − nEventsMin/Max for minmax and rms volume range. NEventsMin No 100 − nEventsMin for adaptive volume range. NEventsMax No 200 − nEventsMax for adaptive volume range. MaxVIterations No 150 − MaxVIterations for adaptive volume range. InitialScale No 0.99 − InitialScale for adaptive volume range. GaussSigma No 0.1 − Width (wrt volume size) of Gaussian kernel estimator. NormTree No False − Normalize binary search tree. Configuration options for MVA method :. Configuration options reference for MVA method: FDA. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Formula No (0) − The discrimination formula. ParRanges No () − Parameter ranges. FitMethod No MINUIT MC, GA, SA, MINUIT Optimisation Method. Converger No None None, MINUIT FitMethod uses Converger to improve result. Configuration options for MVA method :. Configuration options reference for MVA method: LD. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:5430,variab,variable,5430,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variable']
Modifiability," directory. This is where tests will be run and temporary output files; placed. **environment** A dictionary representing the environment to use when executing; tests in the suite. **standalone_tests** When true, mark a directory with tests expected to be run; standalone. Test discovery is disabled for that directory. *lit.suffixes* and; *lit.excludes* must be empty when this variable is true. **suffixes** For **lit** test formats which scan directories for tests, this; variable is a list of suffixes to identify test files. Used by: *ShTest*. **substitutions** For **lit** test formats which substitute variables into a test; script, the list of substitutions to perform. Used by: *ShTest*. **unsupported** Mark an unsupported directory, all tests within it will be; reported as unsupported. Used by: *ShTest*. **parent** The parent configuration, this is the config object for the directory; containing the test suite, or None. **root** The root configuration. This is the top-most :program:`lit` configuration in; the project. **pipefail** Normally a test using a shell pipe fails if any of the commands; on the pipe fail. If this is not desired, setting this variable to false; makes the test fail only if the last command in the pipe fails. **available_features** A set of features that can be used in `XFAIL`,; `REQUIRES`, and `UNSUPPORTED` directives. TEST DISCOVERY; ~~~~~~~~~~~~~~. Once test suites are located, :program:`lit` recursively traverses the source; directory (following *test_source_root*) looking for tests. When :program:`lit`; enters a sub-directory, it first checks to see if a nested test suite is; defined in that directory. If so, it loads that test suite recursively,; otherwise it instantiates a local test config for the directory (see; :ref:`local-configuration-files`). Tests are identified by the test suite they are contained within, and the; relative path inside that suite. Note that the relative path may not refer to; an actual file on disk; some test forma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:17027,config,configuration,17027,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['configuration']
Modifiability," do not; want to use true type fonts. Removing the `UseTTFonts `statement in; the local `.rootrc` file will not disable true fonts. The value of the; environment variable `ROOTDEBUG` overrides the value in the `.rootrc`; file at startup. Its value is used to set ***`gDebug`*** and helps for; quick turn on debug mode in **`TROOT`** startup. ROOT looks for scripts in the path specified in the `.rootrc` file in; the `Root.Macro.Path` variable. You can expand this path to hold your; own directories. ### Logon and Logoff Scripts. The `rootlogon.C` and `rootlogoff.C` files are scripts loaded and; executed at start-up and shutdown. The `rootalias.C` file is loaded; but not executed. It typically contains small utility functions. For; example, the `rootalias.C` script that comes with the ROOT; distributions (located in `$ROOTSYS/tutorials)` defines the function; `edit(char *file)`. This allows the user to call the editor from the; command line. This particular function will start the VI editor if the; environment variable `EDITOR` is not set. ``` {.cpp}; root[0] edit(""c1.C""); ```. For more details, see `$ROOTSYS/tutorials/rootalias.C`. ### History File. You can use the up and down arrow at the command line, to access the; previous and next command. The commands are recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system.rootrc`; file, by setting the `Rint.History `option. You can also turn off the; command logging in the `system.rootrc` file with the option:; `Rint.History: -`. The number of history lines to be kept can be set also in `.rootrc`; by:. ```; Rint.HistSize: 500; Rint.HistSave: 400; ```. The first value defines the maximum of lines kept; once it is reached; all, the last `HistSave` lines will be removed. One can set `HistSize`; to 0 to disable history line management. There is also implemented an; environment variable called `ROOT_HIST`. By setting; `ROOT_HIST",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:38275,variab,variable,38275,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['variab'],['variable']
Modifiability," does now. This; would lead to a pipeline like this:. Static optimizations, xlation unit at a time:; .c --GCC--> .llvm --llvmopt--> .llvm . Link time optimizations:; .llvm --llvm-ld--> .llvm --llvm-link-opt--> .llvm . Of course, many optimizations could be shared between llvmopt and; llvm-link-opt, but the wouldn't need to be shared... Thus compile time; could be faster, because we are using a ""smarter"" IR (SSA based). > BTW, about SGI, ""borrowing"" SSA-based optimizations from one compiler and; > putting it into another is not necessarily easier than re-doing it.; > Optimization code is usually heavily tied in to the specific IR they use. Understood. The only reason that I brought this up is because SGI's IR is; more similar to LLVM than it is different in many respects (SSA based,; relatively low level, etc), and could be easily adapted. Also their; optimizations are written in C++ and are actually somewhat; structured... of course it would be no walk in the park, but it would be; much less time consuming to adapt, say, SSA-PRE than to rewrite it. > But your larger point is valid that adding SSA based optimizations is; > feasible and should be fun. (Again, link time cost is the issue.). Assuming linktime cost wasn't an issue, the question is: ; Does using GCC's backend buy us anything?. > It also occurs to me that GCC is probably doing quite a bit of back-end; > optimization (step 16 in your list). Do you have a breakdown of that?. Not really. The irritating part of GCC is that it mixes it all up and; doesn't have a clean separation of concerns. A lot of the ""back end; optimization"" happens right along with other data optimizations (ie, CSE; of machine specific things). As far as REAL back end optimizations go, it looks something like this:. 1. Instruction combination: try to make CISCy instructions, if available; 2. Register movement: try to get registers in the right places for the; architecture to avoid register to register moves. For example, try to get; the fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt:1516,adapt,adapt,1516,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt,2,"['adapt', 'rewrite']","['adapt', 'rewrite']"
Modifiability," double %iftmp; }. This is a trivial case for mem2reg, since there are no redefinitions of; the variable. The point of showing this is to calm your tension about; inserting such blatant inefficiencies :). After the rest of the optimizers run, we get:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %cmptmp = fcmp ult double %x, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp ueq double %booltmp, 0.000000e+00; br i1 %ifcond, label %else, label %ifcont. else:; %subtmp = fsub double %x, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %subtmp5 = fsub double %x, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; ret double %addtmp. ifcont:; ret double 1.000000e+00; }. Here we see that the simplifycfg pass decided to clone the return; instruction into the end of the 'else' block. This allowed it to; eliminate some branches and the PHI node. Now that all symbol table references are updated to use stack variables,; we'll add the assignment operator. New Assignment Operator; =======================. With our current framework, adding a new assignment operator is really; simple. We will parse it just like any other binary operator, but handle; it internally (instead of allowing the user to define it). The first; step is to set a precedence:. .. code-block:: c++. int main() {; // Install standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['='] = 2;; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;. Now that the parser knows the precedence of the binary operator, it; takes care of all the parsing and AST generation. We just need to; implement codegen for the assignment operator. This looks like:. .. code-block:: c++. Value *BinaryExprAST::codegen() {; // Special case '=' because we don't want to emit the LHS as an expression.; if (Op == '=') {; // This assume we're building without RTTI because LLVM builds that way by; // defau",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:20025,variab,variables,20025,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability," double-free, use-after-free and offset problems involving C++ ; delete. void f(int *p);. void testUseMiddleArgAfterDelete(int *p) {; delete p;; f(p); // warn: use after free; }. class SomeClass {; public:; void f();; };. void test() {; SomeClass *c = new SomeClass;; delete c;; c->f(); // warn: use after free; }. void test() {; int *p = (int *)__builtin_alloca(sizeof(int));; delete p; // warn: deleting memory allocated by alloca; }. void test() {; int *p = new int;; delete p;; delete p; // warn: attempt to free released; }. void test() {; int i;; delete &i; // warn: delete address of local; }. void test() {; int *p = new int[1];; delete[] (++p);; // warn: argument to 'delete[]' is offset by 4 bytes; // from the start of memory allocated by 'new[]'; }. cplusplus.NewDeleteLeaks; (C++); Check for memory leaks. Traces memory managed by new/; delete. void test() {; int *p = new int;; } // warn. Dead Code Checkers. Name, DescriptionExample. deadcode.DeadStores; (C); Check for values stored to variables that are never read afterwards. void test() {; int x;; x = 1; // warn; }. Nullability Checkers. Name, DescriptionExample. nullability.NullPassedToNonnull; (ObjC); Warns when a null pointer is passed to a pointer which has a; _Nonnull type. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. nullability.NullReturnedFromNonnull; (ObjC); Warns when a null pointer is returned from a function that has; _Nonnull return type. - (nonnull id)firstChild {; id result = nil;; if ([_children count] > 0); result = _children[0];. // Warning: nil returned from a method that is expected; // to return a non-null value; return result;; }. nullability.NullableDereferenced; (ObjC); Warns when a nullable pointer is dereferenced. struct LinkedList {; int data;; struct LinkedList *next;; };. struct LinkedList * _Nullable getNext(struct LinkedList *l);. void updateNextData(struct LinkedL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:6119,variab,variables,6119,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['variab'],['variables']
Modifiability," e.g. by acquiring the memory; with ``calloc`` or using ``bzero`` to zero it out. A ``__strong`` or; ``__weak`` object may be properly deinitialized by assigning a null pointer; into it. A ``__strong`` object may also be properly initialized; by copying into it (e.g. with ``memcpy``) the representation of a; different ``__strong`` object whose storage has been properly initialized;; doing this properly deinitializes the source object and causes its storage; to no longer be properly initialized. A ``__weak`` object may not be; representation-copied in this way. These requirements are followed automatically for objects whose; initialization and deinitialization are under the control of ARC:. * objects of static, automatic, and temporary storage duration; * instance variables of Objective-C objects; * elements of arrays where the array object's initialization and; deinitialization are under the control of ARC; * fields of Objective-C struct types where the struct object's; initialization and deinitialization are under the control of ARC; * non-static data members of Objective-C++ non-union class types; * Objective-C++ objects and arrays of dynamic storage duration created; with the ``new`` or ``new[]`` operators and destroyed with the; corresponding ``delete`` or ``delete[]`` operator. They are not followed automatically for these objects:. * objects of dynamic storage duration created in other memory, such as; that returned by ``malloc``; * union members. .. admonition:: Rationale. ARC must perform special operations when initializing an object and; when destroying it. In many common situations, ARC knows when an; object is created and when it is destroyed and can ensure that these; operations are performed correctly. Otherwise, however, ARC requires; programmer cooperation to establish its initialization invariants; because it is infeasible for ARC to dynamically infer whether they; are intact. For example, there is no syntactic difference in C between; an assignment ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:46198,variab,variables,46198,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability," effectively helping the interpreter; use a value from the compiled code. .. code-block:: console. int Global = 42;; void setGlobal(int val) { Global = val; }; int getGlobal() { return Global; }; Interp.ParseAndExecute(“void setGlobal(int val);”);; Interp.ParseAndExecute(“int getGlobal();”);; Value V;; Interp.ParseAndExecute(“getGlobal()”, &V);; std::cout << V.getAs<int>() << “\n”; // Prints 42. **Note:** Above is an example of interoperability between the compiled code and; the interpreted code. Interoperability between languages (e.g., C++ and Python); works similarly. 2. Dump Captured Execution Results; ==================================. This feature helps create a temporary dump to display the value and type; (pretty print) of the desired data. This is a good way to interact with the; interpreter during interactive programming. How value printing is simplified (Automatic Printf); ---------------------------------------------------. The ``Automatic Printf`` feature makes it easy to display variable values during; program execution. Using the ``printf`` function repeatedly is not required.; This is achieved using an extension in the ``libclangInterpreter`` library. To automatically print the value of an expression, simply write the expression; in the global scope **without a semicolon**. .. graphviz::; :name: automaticprintf; :caption: Automatic PrintF; :alt: Shows how Automatic PrintF can be used; :align: center. digraph ""AutomaticPrintF"" {; size=""6,4"";; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. manual [label="" Manual PrintF "", shape=""box""];; int1 [label="" int ( &) 42 "", shape=""box""]; auto [label="" Automatic PrintF "", shape=""box""];; int2 [label="" int ( &) 42 "", shape=""box""]. auto -> int2 [label=""int x = 42; \n x""];; manual -> int1 [label=""int x = 42; \n printf(&quot;(int &) %d \\n&quot;, x);""];; }. Significance of this feature; ----------------------------. Inspired",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:14083,variab,variable,14083,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['variab'],['variable']
Modifiability," enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:3905,variab,variables,3905,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,2,['variab'],['variables']
Modifiability," encoding of the visibility of this variable:. * ``default``: code 0; * ``hidden``: code 1; * ``protected``: code 2. .. _bcthreadlocal:. * *threadlocal*: If present, an encoding of the thread local storage mode of the; variable:. * ``not thread local``: code 0; * ``thread local; default TLS model``: code 1; * ``localdynamic``: code 2; * ``initialexec``: code 3; * ``localexec``: code 4. .. _bcunnamedaddr:. * *unnamed_addr*: If present, an encoding of the ``unnamed_addr`` attribute of this; variable:. * not ``unnamed_addr``: code 0; * ``unnamed_addr``: code 1; * ``local_unnamed_addr``: code 2. .. _bcdllstorageclass:. * *dllstorageclass*: If present, an encoding of the DLL storage class of this variable:. * ``default``: code 0; * ``dllimport``: code 1; * ``dllexport``: code 2. * *comdat*: An encoding of the COMDAT of this function. * *attributes*: If nonzero, the 1-based index into the table of AttributeLists. .. _bcpreemptionspecifier:. * *preemptionspecifier*: If present, an encoding of the runtime preemption specifier of this variable:. * ``dso_preemptable``: code 0; * ``dso_local``: code 1. .. _FUNCTION:. MODULE_CODE_FUNCTION Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[FUNCTION, strtab offset, strtab size, type, callingconv, isproto, linkage, paramattr, alignment, section, visibility, gc, prologuedata, dllstorageclass, comdat, prefixdata, personalityfn, preemptionspecifier]``. The ``FUNCTION`` record (code 8) marks the declaration or definition of a; function. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the function.; See `STRTAB_BLOCK Contents`_. * *type*: The type index of the function type describing this function. * *callingconv*: The calling convention number:; * ``ccc``: code 0; * ``fastcc``: code 8; * ``coldcc``: code 9; * ``anyregcc``: code 13; * ``preserve_mostcc``: code 14; * ``preserve_allcc``: code 15; * ``swiftcc`` : code 16; * ``cxx_fast_tlscc``: code 17; * ``tailcc`` : code 18; * ``cfguard_checkcc`` : code 19; * ``swi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:29463,variab,variable,29463,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability," end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.; Value *CurVar = Builder->CreateLoad(Alloca->getAllocatedType(), Alloca,; VarName.c_str());; Value *NextVar = Builder->CreateFAdd(CurVar, StepVal, ""nextvar"");; Builder->CreateStore(NextVar, Alloca);; ... This code is virtually identical to the code `before we allowed mutable; variables <LangImpl05.html#code-generation-for-the-for-loop>`_. The big difference is that we; no longer have to construct a PHI node, and we use load/store to access; the variable as needed. To support mutable argument variables, we need to also make allocas for; them. The code for this is also pretty simple:. .. code-block:: c++. Function *FunctionAST::codegen() {; ...; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. if (Value *RetVal = Body->codegen()) {; ... For each argument, we make an alloca, store the input value to the; function into the alloca, and register the alloca as the memory location; for the argument. This method gets invoked by ``FunctionAST::codegen()``; right after it sets up the entry block for the function. The final missing piece is adding the mem2reg pass, which allows us to; get good codegen once again:. .. code-block:: c++. // Promote allocas to registers.; TheFPM->add(createPromoteMemoryToRegisterPass());; // Do simple ""peephole"" optimizations and bit-twiddling optzns.; TheFPM->add(createInstructionCombiningPass());; // Reassociate expressions.; TheFPM->add(createReassociatePass",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:15866,variab,variable,15866,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability," entry point. The layout of the HSA kernel descriptor is; defined in :ref:`amdgpu-amdhsa-kernel-descriptor`. Kernel entry point; Every HSA kernel also has a symbol for its machine code entry point. .. _amdgpu-relocation-records:. Relocation Records; ------------------. The AMDGPU backend generates ``Elf64_Rela`` relocation records for; AMDHSA or ``Elf64_Rel`` relocation records for Mesa/AMDPAL. Supported; relocatable fields are:. ``word32``; This specifies a 32-bit field occupying 4 bytes with arbitrary byte; alignment. These values use the same byte order as other word values in the; AMDGPU architecture. ``word64``; This specifies a 64-bit field occupying 8 bytes with arbitrary byte; alignment. These values use the same byte order as other word values in the; AMDGPU architecture. Following notations are used for specifying relocation calculations:. **A**; Represents the addend used to compute the value of the relocatable field. If; the addend field is smaller than 64 bits then it is zero-extended to 64 bits; for use in the calculations below. (In practice this only affects ``_HI``; relocation types on Mesa/AMDPAL, where the addend comes from the 32-bit field; but the result of the calculation depends on the high part of the full 64-bit; address.). **G**; Represents the offset into the global offset table at which the relocation; entry's symbol will reside during execution. **GOT**; Represents the address of the global offset table. **P**; Represents the place (section offset for ``et_rel`` or address for ``et_dyn``); of the storage unit being relocated (computed using ``r_offset``). **S**; Represents the value of the symbol whose index resides in the relocation; entry. Relocations not using this must specify a symbol index of; ``STN_UNDEF``. **B**; Represents the base address of a loaded executable or shared object which is; the difference between the ELF address and the actual load address.; Relocations using this are only valid in executable or shared objects. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:80133,extend,extended,80133,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['extend'],['extended']
Modifiability," error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$. Therefore, it is; recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the; limits should then be removed if possible, in order to perform or; re-perform the error analysis without limits. ### How to Get the Right Answer from Minuit. `Minuit` offers the user a choice of several minimization algorithms.; The `MIGRAD` algorithm is in general the best minimized for nearly all; functions. It is a variable-metric method with inexact line search, a; stable metric updating scheme, and checks for positive-definiteness.; Its main weakness is that it depends heavily on knowledge of the first; derivatives, and fails miserably if they are very inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. #### Getting the Right Minimum with Limits. If MIGRAD converges normally to a point where no parameter is near one; of its limits, then the existence of limits has probably not prevented; `Minuit` from finding the right minimum. On the other hand, if one or; more parameters is near its limit at the minimum, this may be because; the true minimum is indeed at a limit, or it may be because the; minimized has become ''blocked'' at a limit. This may normally happen; only if the parameter is so close to a limit (internal value at an odd; multiple of $\pm \frac{\pi}{2}$ that `Minuit` prints a warning to this; effect when it prints the p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:57642,variab,variable-metric,57642,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['variab'],['variable-metric']
Modifiability," example through the pass, for example, you'll get:. .. code-block:: bash. $ llvm-as < example.ll | opt -passes=mem2reg | llvm-dis; @G = weak global i32 0; @H = weak global i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.01; }. The mem2reg pass implements the standard ""iterated dominance frontier""; algorithm for constructing SSA form and has a number of optimizations; that speed up (very common) degenerate cases. The mem2reg optimization; pass is the answer to dealing with mutable variables, and we highly; recommend that you depend on it. Note that mem2reg only works on; variables in certain circumstances:. #. mem2reg is alloca-driven: it looks for allocas and if it can handle; them, it promotes them. It does not apply to global variables or heap; allocations.; #. mem2reg only looks for alloca instructions in the entry block of the; function. Being in the entry block guarantees that the alloca is only; executed once, which makes analysis simpler.; #. mem2reg only promotes allocas whose uses are direct loads and stores.; If the address of the stack object is passed to a function, or if any; funny pointer arithmetic is involved, the alloca will not be; promoted.; #. mem2reg only works on allocas of `first; class <../../LangRef.html#first-class-types>`_ values (such as pointers,; scalars and vectors), and only if the array size of the allocation is; 1 (or missing in the .ll file). mem2reg is not capable of promoting; structs or arrays to registers. Note that the ""sroa"" pass is; more powerful and can promote structs, ""unions"", and arrays in many; cases. All of these properties are easy to satisfy for most imperative; languages, and we'll illustrate it below with Kaleidoscope. The final; question you may be asking i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:7878,variab,variables,7878,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability," f(""AFile.root"",""RECREATE"");; ... stuff ...; f.Write();; }; ```. To prevent an object in a function from being deleted when it goes out; of scope, you can create it on the heap instead of on the stack. This; will create a **`TFile`** object `f`, that is available on a global; scope, and it will still be available when exiting the function. ``` {.cpp}; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; ```. ### Retrieving Objects from Disk. If you have a ROOT session running, please quit and start fresh. We saw that multiple versions of an object with the same name could be; in a ROOT file. In our example, we saved a modified histogram `hpx` to; the file, which resulted in two `hpx's` uniquely identified by the cycle; number: `hpx;1` and `hpx;2`. The question is how we can retrieve the; right version of `hpx`. When opening the file and using `hpx`, Cling; retrieves the one with the highest cycle number. To read the `hpx;1`; into memory, rather than the `hpx:2` we would get by default, we have to; explicitly get it and assign it to a variable. ``` {.cpp}; root[] TFile *f1 = new TFile(""hsimple.root""); root[] TH1F *hpx1; f1->GetObject(""hpx;1"",hpx); root[] hpx1->Draw(); ```. ### Subdirectories and Navigation. The **`TDirectory`** class lets you organize its contents into; subdirectories, and **`TFile`** being a descendent of **`TDirectory`**; inherits this ability. Here is an example of a ROOT file with multiple; subdirectories as seen in the ROOT browser. To add a subdirectory to a; file use `TDirectory::mkdir`. The example below opens the file for; writing and creates a subdirectory called ""Wed011003"". Listing the; contents of the file shows the new directory in the file and the; **`TDirectory`** object in memory. ``` {.cpp}; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] f->mkdir(""Wed011003""); (class TDirectory*)0x1072b5c8; ```. ``` {.cpp}; root[] f->ls(); TFile** AFile.root; TFile* AFile.root; TDirectory* Wed011003 Wed011003; KEY: TDirecto",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:36958,variab,variable,36958,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability," factory->AddSignalTrainingEvent( vars, signalWeight );; (and replacing ""Signal"" by ""Background"", and ""Training"" by; ""Test""). After the event loop, everything continues as in; the standard method.; . Methods:. Simulated Annealing in Cuts,FDA: Entirely new; Simulated Annealing (SA) algorithm for global minimisation; in presence of local minima (optionally used in cut; optimisation (MethodCuts) and the Function Discriminant; (MethodFDA)). The SA algorithm features two approaches,; one starting at minimal temperature (ie, from within a; local minimum), slowly increasing, and another one; starting at high temperature, slowly decreasing into a; minimum. Code developed and written by Kamil Bartlomiej; Kraszewski, Maciej Kruk and Krzysztof Danielowski from IFJ; and AGH/UJ, Krakow, Poland.; ; Cuts: Added printouts, quoting the explicit cut; application for given signal efficiency. In case of; transformations of the input variables, the full expressions; are given. Added warning to Fisher in case of variable; normalisation. ; ; Cuts: Added physical limits to min/max cuts if; smart option is used.; ; BDT: removed hard-coded weight file name; now,; paths and names of weight files are written as TObjStrings; into ROOT target file, and retrieved for plotting;; available weight files (corresponding to target used) can; be chosen from pop-up GUI.; ; BDT: Changes in handling negative weights in BDT; algorithm. Events with negative weights now get their; weight reduced (*= 1/boostweight) rather than increased; (*= boostweight) as the other events do. Otherwise these; events tend to receive increasingly stronger boosts,; because their effects on the separation gain are as if; background events were selected as signal and vice versa; (hence the events tend to be ""wanted"" in signal nodes, but; are boosted as if they were misclassified). In addition,; the separation indices are protected against negative S or; S+B returning 0.5 (no separation at all) in case that; occurs.; ; BDT: In add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html:2294,variab,variable,2294,tmva/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html,1,['variab'],['variable']
Modifiability," file for building ROOT math/unurun package; ############################################################################. #---Define package related variables-----------------------------------------------------------------. if(builtin_unuran). set(UNR_SRCDIR ${CMAKE_CURRENT_SOURCE_DIR}/src); set(UNR_VERSION ""1.8.0-root""); set(UNR_TARNAME ""unuran-${UNR_VERSION}""); set(UNR_TARGZFILE ${UNR_SRCDIR}/${UNR_TARNAME}.tar.gz); set(UNR_TARFILE ${UNR_SRCDIR}/${UNR_TARNAME}.tar); set(UNR_UNTARDIR ${CMAKE_CURRENT_BINARY_DIR}/${UNR_TARNAME}). #---Untar sources at configuration/generation time (needed for listing sources); if(NOT EXISTS ${UNR_UNTARDIR}); execute_process( COMMAND ${CMAKE_COMMAND} -E tar xzf ${UNR_TARGZFILE}; WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR} ); # This is necessary to replace the config.guess of unuran 1.8.0 as it does not allow to compile the ; # package on arm64.; execute_process( COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/config.guess_patch1 ${UNR_UNTARDIR}/autoconf/config.guess; WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR} ); endif(). if(WIN32); configure_file(${CMAKE_CURRENT_SOURCE_DIR}/config.h.win.in ${UNR_UNTARDIR}/config.h); else(); #---Define special compiler settings for unurun-----------------------------------------------------; set(UNR_CC ${CMAKE_C_COMPILER}); if(ROOT_ARCHITECTURE MATCHES hpuxia64acc); set(UNR_CC ""${UNR_CC} +DD64 -Ae""); elseif(ROOT_ARCHITECTURE MATCHES linuxppc64gcc); set(UNR_CC ""${UNR_CC} -m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664gcc); set(UNR_CFLAGS ""-m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxicc); set(UNR_CFLAGS ""-m32""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664icc); set(UNR_CFLAGS ""-m64""); elseif(ROOT_ARCHITECTURE MATCHES win32 OR ROOT_ARCHITECTURE MATCHES win64); set(UNR_CFLAGS ""-MD -G5 -GX""); endif(); if(CMAKE_OSX_SYSROOT); set(UNR_CFLAGS ""${UNR_CFLAGS} -isysroot ${CMAKE_OSX_SYSROOT}""); endif(). #---configure unuran (required for creating the config.h used by unuran source",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt:1305,config,config,1305,math/unuran/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt,1,['config'],['config']
Modifiability," file with one class and two record definitions. .. code-block:: text. class C {; bit V = true;; }. def X : C;; def Y : C {; let V = false;; string Greeting = ""Hello!"";; }. First, the abstract class ``C`` is defined. It has one field named ``V``; that is a bit initialized to true. Next, two records are defined, derived from class ``C``; that is, with ``C``; as their parent class. Thus they both inherit the ``V`` field. Record ``Y``; also defines another string field, ``Greeting``, which is initialized to; ``""Hello!""``. In addition, ``Y`` overrides the inherited ``V`` field,; setting it to false. A class is useful for isolating the common features of multiple records in; one place. A class can initialize common fields to default values, but; records inheriting from that class can override the defaults. TableGen supports the definition of parameterized classes as well as; nonparameterized ones. Parameterized classes specify a list of variable; declarations, which may optionally have defaults, that are bound when the; class is specified as a parent class of another class or record. .. code-block:: text. class FPFormat <bits<3> val> {; bits<3> Value = val;; }. def NotFP : FPFormat<0>;; def ZeroArgFP : FPFormat<1>;; def OneArgFP : FPFormat<2>;; def OneArgFPRW : FPFormat<3>;; def TwoArgFP : FPFormat<4>;; def CompareFP : FPFormat<5>;; def CondMovFP : FPFormat<6>;; def SpecialFP : FPFormat<7>;. The purpose of the ``FPFormat`` class is to act as a sort of enumerated; type. It provides a single field, ``Value``, which holds a 3-bit number. Its; template argument, ``val``, is used to set the ``Value`` field. Each of the; eight records is defined with ``FPFormat`` as its parent class. The; enumeration value is passed in angle brackets as the template argument. Each; record will inherent the ``Value`` field with the appropriate enumeration; value. Here is a more complex example of classes with template arguments. First, we; define a class similar to the ``FPFormat`` class above.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:30081,variab,variable,30081,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability," flag.; This is not supported on every platform. Atomics library; ---------------. If your program makes use of atomic operations and the compiler is not able; to lower them all directly to machine instructions (because there either is; no known suitable machine instruction or the operand is not known to be; suitably aligned), a call to a runtime library ``__atomic_*`` function; will be generated. A runtime library containing these atomics functions is; necessary for such programs. compiler-rt (LLVM); ^^^^^^^^^^^^^^^^^^. compiler-rt contains an implementation of an atomics library. libatomic (GNU); ^^^^^^^^^^^^^^^. libgcc_s does not provide an implementation of an atomics library. Instead,; `GCC's libatomic library <https://gcc.gnu.org/wiki/Atomic/GCCMM>`_ can be; used to supply these when using libgcc_s. .. note::. Clang does not currently automatically link against libatomic when using; libgcc_s. You may need to manually add ``-latomic`` to support this; configuration when using non-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:8146,config,configuration,8146,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['config'],['configuration']
Modifiability," float %valC, float addrspace(1)* %ptrC, align 4. ret void; }. !nvvm.annotations = !{!0}; !0 = !{void (float addrspace(1)*,; float addrspace(1)*,; float addrspace(1)*)* @kernel, !""kernel"", i32 1}. To compile this kernel, we perform the following steps:. 1. Link with libdevice; 2. Internalize all but the public kernel function; 3. Run ``NVVMReflect`` and set ``__CUDA_FTZ`` to 0; 4. Optimize the linked module; 5. Codegen the module. These steps can be performed by the LLVM ``llvm-link``, ``opt``, and ``llc``; tools. In a complete compiler, these steps can also be performed entirely; programmatically by setting up an appropriate pass configuration (see; :ref:`libdevice`). .. code-block:: text. # llvm-link t2.bc libdevice.compute_20.10.bc -o t2.linked.bc; # opt -internalize -internalize-public-api-list=kernel -nvvm-reflect-list=__CUDA_FTZ=0 -nvvm-reflect -O3 t2.linked.bc -o t2.opt.bc; # llc -mcpu=sm_20 t2.opt.bc -o t2.ptx. .. note::. The ``-nvvm-reflect-list=_CUDA_FTZ=0`` is not strictly required, as any; undefined variables will default to zero. It is shown here for evaluation; purposes. This gives us the following PTX (excerpt):. .. code-block:: text. //; // Generated by LLVM NVPTX Back-End; //. .version 3.1; .target sm_20; .address_size 64. // .globl kernel; // @kernel; .visible .entry kernel(; .param .u64 kernel_param_0,; .param .u64 kernel_param_1,; .param .u64 kernel_param_2; ); {; .reg .pred %p<30>;; .reg .f32 %f<111>;; .reg .s32 %r<21>;; .reg .s64 %rl<8>;. // %bb.0: // %entry; ld.param.u64 %rl2, [kernel_param_0];; mov.u32 %r3, %tid.x;; ld.param.u64 %rl3, [kernel_param_1];; mul.wide.s32 %rl4, %r3, 4;; add.s64 %rl5, %rl2, %rl4;; ld.param.u64 %rl6, [kernel_param_2];; add.s64 %rl7, %rl3, %rl4;; add.s64 %rl1, %rl6, %rl4;; ld.global.f32 %f1, [%rl5];; ld.global.f32 %f2, [%rl7];; setp.eq.f32 %p1, %f1, 0f3F800000;; setp.eq.f32 %p2, %f2, 0f00000000;; or.pred %p3, %p1, %p2;; @%p3 bra BB0_1;; bra.uni BB0_2;; BB0_1:; mov.f32 %f110, 0f3F800000;; st.global.f32 [%rl1], %f110;; r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:25809,variab,variables,25809,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['variab'],['variables']
Modifiability," for (int i = 1; i < n; i+=1) // coincident loop; B[i] = 2 + B[i];; for (int i = 1; i < n; i+=1) // sequential loop; C[i] = 3 + C[i - 1];; } else {; for (int i = 1; i < n; i+=1) { // fallback loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }; }. where ``rtc`` is a generated runtime check. ``llvm.loop.distribute.followup_coincident`` sets the loop attributes of; all loops without loop-carried dependencies (i.e. vectorizable loops).; There might be more than one such loops. If not defined, the loops will; inherit the original loop's attributes. ``llvm.loop.distribute.followup_sequential`` sets the loop attributes of the; loop with potentially unsafe dependencies. There should be at most one; such loop. If not defined, the loop will inherit the original loop's; attributes. ``llvm.loop.distribute.followup_fallback`` defines the loop attributes; for the fallback loop, which is a copy of the original loop for when; loop versioning is required. If undefined, the fallback loop inherits; all attributes from the original loop. Attributes defined in ``llvm.loop.distribute.followup_all`` are added to; all of the aforementioned output loops. It is recommended to add ``llvm.loop.disable_nonforced`` to; ``llvm.loop.distribute.followup_fallback``. This avoids that the; fallback version (which is likely never executed) is further optimized; which would increase the code size. Versioning LICM; ---------------. The pass hoists code out of loops that are only loop-invariant when; dynamic conditions apply. For instance, it transforms the loop. .. code-block:: c. for (int i = 0; i < n; i+=1) // original loop; A[i] = B[0];. into:. .. code-block:: c. if (rtc) {; auto b = B[0];; for (int i = 0; i < n; i+=1) // versioned loop; A[i] = b;; } else {; for (int i = 0; i < n; i+=1) // unversioned loop; A[i] = B[0];; }. The runtime condition (``rtc``) checks that the array ``A`` and the; element `B[0]` do not alias. Currently, this transformation does not support followup-attributes. Loop I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:12347,inherit,inherits,12347,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['inherit'],['inherits']
Modifiability," for labeled axis; 5. Fix - draw TProfile2D bins content as text, not entries; 6. Fix - interactive zooming on log color palette; 7. Fix - keyboard handling while input dialog active; 8. Fix - legend entry with not configured fill attributes; 9. Fix - prevent that color palette exceed graphical range; 10. Fix - exponential log axis labels with kMoreLogLabels bit set. ## Changes in 7.7.1; 1. Fix - properly select TF1 range after zooming; 2. Fix - TH1 y-range selection; 3. Fix - add 'gl' and svg2pdf-related packages to dependencies in package.json. ## Changes in 7.7.0; 1. Let plot current time, file creation or modification time with `&optdate=[1,2,3]` URL parameters; 2. Let plot file name, full file name or item name with `&optfile=[1,2,3]` URL parameters; 3. Let define date and file name position with `&datex=0.03&datey=0.03` URL parameters; 4. Improve TRatioPlot axis and lines drawing; 5. Use localStorage to preserve custom settings and gStyle; 6. Let configure custom storage prefix with `&storage_prefix=name` URL #290; 7. Let customize URL for ""Show in new tab"" menu command; 8. Support both new and old TRatioPlot drawings; 10. Synchronize X/Y range selection with native ROOT; 11. Proper handle attributes from TH2Poly bins, support ""p"" for markers drawing; 12. Correctly scale size of axis ticks - take into account NDC axis length; 13. Set name and userData in geometry `build()` function #303; 14. Draw histogram title afterwards - place in front of stats box; 15. Upgrade three.js r158 -> r162, last with WebGL1 support; 16. Split extras into three_addons.mjs, provide jsroot geometry build without three.js; 17. Fix - correctly draw only grids with AXIG draw option; 18. Fix - log scales on TH3 drawings #306; 19. Fix - draw geometry top node volume if all childs not visible #308; 20. Fix - properly process 206 server response without Accept-Ranges header https://root-forum.cern.ch/t/59426/. ## Changes in 7.6.1; 1. Remove source_dir output in node.js #296; 2. Fully integr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:4429,config,configure,4429,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configure']
Modifiability," for the same type. The; most famous example is the `int` type. It may be 16 bits on some old; machines and 32 bits on some newer ones. To ensure the size of your; variables, use these pre defined types in ROOT:. - **`Char_t`** Signed Character 1 byte. - **`UChar_t`** Unsigned Character 1 byte. - **`Short_t`** Signed Short integer 2 bytes. - **`UShort_t`** Unsigned Short integer 2 bytes. - **`Int_t`** Signed integer 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float 8 bytes. - **`Double32_t`** Double 8 bytes in memory, written as a Float 4; bytes. - **`Bool_t`** Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use `int` or; `Int_t`, the result will be the same and the interpreter or the; compiler will treat them in exactly the same way. ### TObject. In ROOT, almost all classes inherit from a common base class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for all objects in the ROOT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:31169,inherit,inherit,31169,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['inherit'],['inherit']
Modifiability," for these type qualifiers. By storing the type qualifiers as bits in the conceptual pair, it is extremely; efficient to get the set of qualifiers on a ``QualType`` (just return the field; of the pair), add a type qualifier (which is a trivial constant-time operation; that sets a bit), and remove one or more type qualifiers (just return a; ``QualType`` with the bitfield set to empty). Further, because the bits are stored outside of the type itself, we do not need; to create duplicates of types with different sets of qualifiers (i.e. there is; only a single heap allocated ""``int``"" type: ""``const int``"" and ""``volatile; const int``"" both point to the same heap allocated ""``int``"" type). This; reduces the heap size used to represent bits and also means we do not have to; consider qualifiers when uniquing types (:ref:`Type <Type>` does not even; contain qualifiers). In practice, the two most common type qualifiers (``const`` and ``restrict``); are stored in the low bits of the pointer to the ``Type`` object, together with; a flag indicating whether extended qualifiers are present (which must be; heap-allocated). This means that ``QualType`` is exactly the same size as a; pointer. .. _DeclarationName:. Declaration names; -----------------. The ``DeclarationName`` class represents the name of a declaration in Clang.; Declarations in the C family of languages can take several different forms.; Most declarations are named by simple identifiers, e.g., ""``f``"" and ""``x``"" in; the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct Class { Class(); }``), class; destructors (""``~Class``""), overloaded operator names (""``operator+``""), and; conversion functions (""``operator void const *``""). In Objective-C,; declaration names can refer to the names of Objective-C methods, which involve; the method name and the parameters, collectively called a *selector*, e.g.,; ""``setWidth:height:``"". Since all of these kinds of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:67963,extend,extended,67963,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['extend'],['extended']
Modifiability," for your pass. The :ref:`Hello World; <writing-an-llvm-pass-basiccode>` example uses the :ref:`FunctionPass; <writing-an-llvm-pass-FunctionPass>` class for its implementation, but we did; not discuss why or when this should occur. Here we talk about the classes; available, from the most general to the most specific. When choosing a superclass for your ``Pass``, you should choose the **most; specific** class possible, while still being able to meet the requirements; listed. This gives the LLVM Pass Infrastructure information necessary to; optimize how passes are run, so that the resultant compiler isn't unnecessarily; slow. The ``ImmutablePass`` class; ---------------------------. The most plain and boring type of pass is the ""`ImmutablePass; <https://llvm.org/doxygen/classllvm_1_1ImmutablePass.html>`_"" class. This pass; type is used for passes that do not have to be run, do not change state, and; never need to be updated. This is not a normal type of transformation or; analysis, but can provide information about the current compiler configuration. Although this pass class is very infrequently used, it is important for; providing information about the current target machine being compiled for, and; other static information that can affect the various transformations. ``ImmutablePass``\ es never invalidate other transformations, are never; invalidated, and are never ""run"". .. _writing-an-llvm-pass-ModulePass:. The ``ModulePass`` class; ------------------------. The `ModulePass <https://llvm.org/doxygen/classllvm_1_1ModulePass.html>`_ class; is the most general of all superclasses that you can use. Deriving from; ``ModulePass`` indicates that your pass uses the entire program as a unit,; referring to function bodies in no predictable order, or adding and removing; functions. Because nothing is known about the behavior of ``ModulePass``; subclasses, no optimization can be done for their execution. A module pass can use function level passes (e.g. dominators) using the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:12275,config,configuration,12275,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['config'],['configuration']
Modifiability," for; the one bundled with Xcode.; Using scan-build directly; If you wish to use scan-build with your iPhone project, keep the; following things in mind:. Analyze your project in the Debug configuration, either by setting; this as your configuration with Xcode or by passing -configuration; Debug to xcodebuild.; Analyze your project using the Simulator as your base SDK. It is; possible to analyze your code when targeting the device, but this is much; easier to do when using Xcode's Build and Analyze feature.; Check that your code signing SDK is set to the simulator SDK as well, and make sure this option is set to Don't Code Sign. Note that you can most of this without actually modifying your project. For; example, if your application targets iPhoneOS 2.2, you could run; scan-build in the following manner from the command line:. $ scan-build xcodebuild -configuration Debug -sdk iphonesimulator2.2. Alternatively, if your application targets iPhoneOS 3.0:. $ scan-build xcodebuild -configuration Debug -sdk iphonesimulator3.0. Gotcha: using the right compiler; Recall that scan-build analyzes your project by using a compiler to; compile the project and clang to analyze your project. The script uses; simple heuristics to determine which compiler should be used (it defaults to; clang on Darwin and gcc on other platforms). When analyzing; iPhone projects, scan-build may pick the wrong compiler than the one; Xcode would use to build your project. For example, this could be because; multiple versions of a compiler may be installed on your system, especially if; you are developing for the iPhone.; When compiling your application to run on the simulator, it is important that scan-build; finds the correct version of gcc/clang. Otherwise, you may see strange build; errors that only happen when you run scan-build. scan-build provides the --use-cc and --use-c++; options to hardwire which compiler scan-build should use for building your code.; Note that although you are chiefly intere",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:9672,config,configuration,9672,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['config'],['configuration']
Modifiability," frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2151,adapt,adaption,2151,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['adapt'],['adaption']
Modifiability," from ORCv1 to ORCv2; =================================. Since LLVM 7.0, new ORC development work has focused on adding support for; concurrent JIT compilation. The new APIs (including new layer interfaces and; implementations, and new utilities) that support concurrency are collectively; referred to as ORCv2, and the original, non-concurrent layers and utilities; are now referred to as ORCv1. The majority of the ORCv1 layers and utilities were renamed with a 'Legacy'; prefix in LLVM 8.0, and have deprecation warnings attached in LLVM 9.0. In LLVM; 12.0 ORCv1 will be removed entirely. Transitioning from ORCv1 to ORCv2 should be easy for most clients. Most of the; ORCv1 layers and utilities have ORCv2 counterparts [2]_ that can be directly; substituted. However there are some design differences between ORCv1 and ORCv2; to be aware of:. 1. ORCv2 fully adopts the JIT-as-linker model that began with MCJIT. Modules; (and other program representations, e.g. Object Files) are no longer added; directly to JIT classes or layers. Instead, they are added to ``JITDylib``; instances *by* layers. The ``JITDylib`` determines *where* the definitions; reside, the layers determine *how* the definitions will be compiled.; Linkage relationships between ``JITDylibs`` determine how inter-module; references are resolved, and symbol resolvers are no longer used. See the; section `Design Overview`_ for more details. Unless multiple JITDylibs are needed to model linkage relationships, ORCv1; clients should place all code in a single JITDylib.; MCJIT clients should use LLJIT (see `LLJIT and LLLazyJIT`_), and can place; code in LLJIT's default created main JITDylib (See; ``LLJIT::getMainJITDylib()``). 2. All JIT stacks now need an ``ExecutionSession`` instance. ExecutionSession; manages the string pool, error reporting, synchronization, and symbol; lookup. 3. ORCv2 uses uniqued strings (``SymbolStringPtr`` instances) rather than; string values in order to reduce memory overhead and improve loo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:20135,layers,layers,20135,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['layers'],['layers']
Modifiability," from and override. However, this; implementation strategy forces an **""is-a""** relationship to exist that is not; actually meaningful. There is often not some nested hierarchy of useful; generalizations which code might interact with and move up and down. Instead,; there is a singular interface which is dispatched across a range of; implementations. The preferred implementation strategy for the second use case is that of; generic programming (sometimes called ""compile-time duck typing"" or ""static; polymorphism""). For example, a template over some type parameter ``T`` can be; instantiated across any particular implementation that conforms to the; interface or *concept*. A good example here is the highly generic properties of; any type which models a node in a directed graph. LLVM models these primarily; through templates and generic programming. Such templates include the; ``LoopInfoBase`` and ``DominatorTreeBase``. When this type of polymorphism; truly needs **dynamic** dispatch you can generalize it using a technique; called *concept-based polymorphism*. This pattern emulates the interfaces and; behaviors of templates using a very limited form of virtual dispatch for type; erasure inside its implementation. You can find examples of this technique in; the ``PassManager.h`` system, and there is a more detailed introduction to it; by Sean Parent in several of his talks and papers:. #. `Inheritance Is The Base Class of Evil; <http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil>`_; - The GoingNative 2013 talk describing this technique, and probably the best; place to start.; #. `Value Semantics and Concepts-based Polymorphism; <http://www.youtube.com/watch?v=_BpMYeUFXv8>`_ - The C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:130609,polymorphi,polymorphism,130609,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,['polymorphi'],['polymorphism']
Modifiability," function ``foo``. Now lets take another example. .. code-block:: llvm. call void @llvm.dbg.declare(metadata i32* %Z, metadata !17, metadata !13), !dbg !19; ; [debug line = 5:9] [debug variable = Z]. The third intrinsic ``%llvm.dbg.declare`` encodes debugging information for; variable ``Z``. The metadata ``!dbg !19`` attached to the intrinsic provides; scope information for the variable ``Z``. .. code-block:: text. !18 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5); !19 = !DILocation(line: 5, column: 11, scope: !18). Here ``!19`` indicates that ``Z`` is declared at line number 5 and column; number 11 inside of lexical scope ``!18``. The lexical scope itself resides; inside of subprogram ``!4`` described above. The scope information attached with each instruction provides a straightforward; way to find instructions covered by a scope. Object lifetime in optimized code; =================================. In the example above, every variable assignment uniquely corresponds to a; memory store to the variable's position on the stack. However in heavily; optimized code LLVM promotes most variables into SSA values, which can; eventually be placed in physical registers or memory locations. To track SSA; values through compilation, when objects are promoted to SSA values an; ``llvm.dbg.value`` intrinsic is created for each assignment, recording the; variable's new location. Compared with the ``llvm.dbg.declare`` intrinsic:. * A dbg.value terminates the effect of any preceding dbg.values for (any; overlapping fragments of) the specified variable.; * The dbg.value's position in the IR defines where in the instruction stream; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:17891,variab,variable,17891,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['variab'],['variable']
Modifiability," function never raises an; exception. If the function does raise an exception, its runtime; behavior is undefined. However, functions marked nounwind may still; trap or generate asynchronous exceptions. Exception handling schemes; that are recognized by LLVM to handle asynchronous exceptions, such; as SEH, will still provide their implementation defined semantics.; ``nosanitize_bounds``; This attribute indicates that bounds checking sanitizer instrumentation; is disabled for this function.; ``nosanitize_coverage``; This attribute indicates that SanitizerCoverage instrumentation is disabled; for this function.; ``null_pointer_is_valid``; If ``null_pointer_is_valid`` is set, then the ``null`` address; in address-space 0 is considered to be a valid address for memory loads and; stores. Any analysis or optimization should not treat dereferencing a; pointer to ``null`` as undefined behavior in this function.; Note: Comparing address of a global variable to ``null`` may still; evaluate to false because of a limitation in querying this attribute inside; constant expressions.; ``optdebug``; This attribute suggests that optimization passes and code generator passes; should make choices that try to preserve debug info without significantly; degrading runtime performance.; This attribute is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that this function should be optimized; for maximum fuzzing signal.; ``optnone``; This function attribute indicates that most optimization passes will skip; this function, with the exception of interprocedural optimization passes.; Code generation defaults to the ""fast"" instruction selector.; This attribute cannot be used together with the ``alwaysinline``; attribute; this attribute is also incompatible; with the ``minsize``, ``optsize``, and ``optdebug`` attributes. This attribute requires the ``noinline`` attribute to be specified on; the function as well, so the funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:95200,variab,variable,95200,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," functions generated:. .. code-block:: c. void __block_copy_foo(struct __block_literal_5 *dst, struct __block_literal_5 *src) {; _Block_object_assign(&dst->objectPointer, src-> objectPointer, BLOCK_FIELD_IS_OBJECT);; }. void __block_dispose_foo(struct __block_literal_5 *src) {; _Block_object_dispose(src->objectPointer, BLOCK_FIELD_IS_OBJECT);; }. Imported ``__block`` marked variables; -------------------------------------. Layout of ``__block`` marked variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The compiler must embed variables that are marked ``__block`` in a specialized; structure of the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct Block_byref *forwarding;; int flags; //refcount;; int size;; typeof(marked_variable) marked_variable;; };. Variables of certain types require helper functions for when ``Block_copy()``; and ``Block_release()`` are performed upon a referencing ``Block``. At the ""C""; level only variables that are of type ``Block`` or ones that have; ``__attribute__((NSObject))`` marked require helper functions. In Objective-C; objects require helper functions and in C++ stack based objects require helper; functions. Variables that require helper functions use the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct _block_byref_foo *forwarding;; int flags; //refcount;; int size;; // helper functions called via Block_copy() and Block_release(); void (*byref_keep)(void *dst, void *src);; void (*byref_dispose)(void *);; typeof(marked_variable) marked_variable;; };. The structure is initialized such that:. a. The ``forwarding`` pointer is set to the beginning of its enclosing; structure. b. The ``size`` field is initialized to the total size of the enclosing; structure. c. The ``flags`` field is set to either 0 if no helper functions are needed; or (1<<25) if they are. d. The helper functions are initialized (if present). e. The variable itself is set to its initial value. f. The ``isa`` field is set to ``N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:11942,variab,variables,11942,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability," g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<FunctionDecl>isMain; Determines whether the function is ""main"", which is the entry point; into an executable program. Matcher<FunctionDecl>isNoReturn; Matches FunctionDecls that have a noreturn attribute. Given; void nope();; [[noreturn]] void a();; __attribute__((noreturn)) void b();; struct c { [[noreturn]] c(); };; functionDecl(isNoReturn()); matches all of those except; void nope();. Matcher<FunctionDecl>isNoThrow; Matches functions that have a non-throwing exception specification. Given:; void f();; void g() noexcept;; void h() throw();; void i() throw(int);; void j() noexcept(false);; functionDecl(isNoThrow()) and functionProtoType(isNoThrow()); match the declarations of g, and h, but not f, i or j. Matcher<FunctionDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<FunctionDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:94140,variab,variable,94140,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability," general lowering process converting MachineFunction's into MC; label constructs. The AsmPrinter base class provides a number of useful; methods and routines, and also allows you to override the lowering process in; some important ways. You should get much of the lowering for free if you are; implementing an ELF, COFF, or MachO target, because the; TargetLoweringObjectFile class implements much of the common logic. #. Second, you need to implement an instruction printer for your target. The; instruction printer takes an `MCInst`_ and renders it to a raw_ostream as; text. Most of this is automatically generated from the .td file (when you; specify something like ""``add $dst, $src1, $src2``"" in the instructions), but; you need to implement routines to print operands. #. Third, you need to implement code that lowers a `MachineInstr`_ to an MCInst,; usually implemented in ""<target>MCInstLower.cpp"". This lowering process is; often target specific, and is responsible for turning jump table entries,; constant pool indices, global variable addresses, etc into MCLabels as; appropriate. This translation layer is also responsible for expanding pseudo; ops used by the code generator into the actual machine instructions they; correspond to. The MCInsts that are generated by this are fed into the; instruction printer or the encoder. Finally, at your choosing, you can also implement a subclass of MCCodeEmitter; which lowers MCInst's into machine code bytes and relocations. This is; important if you want to support direct .o file emission, or would like to; implement an assembler for your target. Emitting function stack size information; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A section containing metadata on function stack sizes will be emitted when; ``TargetLoweringObjectFile::StackSizesSection`` is not null, and; ``TargetOptions::EmitStackSizeSection`` is set (-stack-size-section). The; section will contain an array of pairs of function symbol values (pointer size); and stack ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:77183,variab,variable,77183,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['variab'],['variable']
Modifiability," generate the coverage data on one machine, and then use llvm-cov on a; different machine where you have the same files on a different path. Multiple; `-path-equivalence` arguments can be passed to specify different mappings. Each; argument consists of a source path `<from>` and its corresponding local path `<to>`.; The mappings are applied in the order they are specified. If multiple mappings can; be applied to a single path, the first mapping encountered is used. .. option:: -coverage-watermark=<high>,<low>. Set high and low watermarks for coverage in html format output. This allows you; to set the high and low watermark of coverage as desired, green when; coverage >= high, red when coverage < low, and yellow otherwise. Both high and; low should be between 0-100 and high > low. .. option:: -debuginfod. Use debuginfod to look up coverage mapping for binary IDs present in the; profile but not in any object given on the command line. Defaults to true if; debuginfod is compiled in and configured via the DEBUGINFOD_URLS environment; variable. .. option:: -debug-file-directory=<dir>. Provides local directories to search for objects corresponding to binary IDs in; the profile (as with debuginfod). Defaults to system build ID directories. .. option:: -check-binary-ids. Fail if an object file cannot be found for a binary ID present in the profile,; neither on the command line nor via binary ID lookup. .. program:: llvm-cov report. .. _llvm-cov-report:. REPORT COMMAND; --------------. SYNOPSIS; ^^^^^^^^. :program:`llvm-cov report` [*options*] -instr-profile *PROFILE* [*BIN*] [*-object BIN*]... [*-sources*] [*SOURCE*]... DESCRIPTION; ^^^^^^^^^^^. The :program:`llvm-cov report` command displays a summary of the coverage of; the binaries *BIN*... using the profile data *PROFILE*. It can optionally be; filtered to only show the coverage for the files listed in *SOURCE*.... *BIN* may be an executable, object file, dynamic library, or archive (thin or; otherwise). If no source fil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst:13217,config,configured,13217,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,2,"['config', 'variab']","['configured', 'variable']"
Modifiability," generator""``. To see a list of the available generators on your system, execute. .. code-block:: console. $ cmake --help. This will list the generator names at the end of the help text. Generators' names are case-sensitive, and may contain spaces. For this reason,; you should enter them exactly as they are listed in the ``cmake --help``; output, in quotes. For example, to generate project files specifically for; Visual Studio 12, you can execute:. .. code-block:: console. $ cmake -G ""Visual Studio 12"" path/to/llvm/source/root. For a given development platform there can be more than one adequate; generator. If you use Visual Studio, ""NMake Makefiles"" is a generator you can use; for building with NMake. By default, CMake chooses the most specific generator; supported by your development environment. If you want an alternative generator,; you must tell this to CMake with the ``-G`` option. .. todo::. Explain variables and cache. Move explanation here from #options section. .. _Options and variables:. Options and variables; =====================. Variables customize how the build will be generated. Options are boolean; variables, with possible values ON/OFF. Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; --",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:5563,variab,variables,5563,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability," generators; -----------------------------------------------------------------------. This transformation is designed for use by code generators which do not yet; support stack unwinding. This pass converts ``invoke`` instructions to; ``call`` instructions, so that any exception-handling ``landingpad`` blocks; become dead code (which can be removed by running the ``-simplifycfg`` pass; afterwards). ``lowerswitch``: Lower ``SwitchInst``\ s to branches; ----------------------------------------------------. Rewrites switch instructions with a sequence of branches, which allows targets; to get away with not implementing the switch instruction until it is; convenient. .. _passes-mem2reg:. ``mem2reg``: Promote Memory to Register; ---------------------------------------. This file promotes memory references to be register references. It promotes; alloca instructions which only have loads and stores as uses. An ``alloca`` is; transformed by using dominator frontiers to place phi nodes, then traversing; the function in depth-first order to rewrite loads and stores as appropriate.; This is just the standard SSA construction algorithm to construct ""pruned"" SSA; form. ``memcpyopt``: MemCpy Optimization; ----------------------------------. This pass performs various transformations related to eliminating ``memcpy``; calls, or transforming sets of stores into ``memset``\ s. ``mergefunc``: Merge Functions; ------------------------------. This pass looks for equivalent functions that are mergeable and folds them. Total-ordering is introduced among the functions set: we define comparison; that answers for every two functions which of them is greater. It allows to; arrange functions into the binary tree. For every new function we check for equivalent in tree. If equivalent exists we fold such functions. If both functions are overridable,; we move the functionality into a new internal function and leave two; overridable thunks to it. If there is no equivalent, then we add this functio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:30743,rewrite,rewrite,30743,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['rewrite'],['rewrite']
Modifiability," getchar()))); IdentifierStr += LastChar;. if (IdentifierStr == ""def""); return tok_def;; if (IdentifierStr == ""extern""); return tok_extern;; return tok_identifier;; }. Note that this code sets the '``IdentifierStr``' global whenever it; lexes an identifier. Also, since language keywords are matched by the; same loop, we handle them here inline. Numeric values are similar:. .. code-block:: c++. if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+; std::string NumStr;; do {; NumStr += LastChar;; LastChar = getchar();; } while (isdigit(LastChar) || LastChar == '.');. NumVal = strtod(NumStr.c_str(), 0);; return tok_number;; }. This is all pretty straightforward code for processing input. When; reading a numeric value from input, we use the C ``strtod`` function to; convert it to a numeric value that we store in ``NumVal``. Note that; this isn't doing sufficient error checking: it will incorrectly read; ""1.23.45.67"" and handle it as if you typed in ""1.23"". Feel free to; extend it! Next we handle comments:. .. code-block:: c++. if (LastChar == '#') {; // Comment until end of line.; do; LastChar = getchar();; while (LastChar != EOF && LastChar != '\n' && LastChar != '\r');. if (LastChar != EOF); return gettok();; }. We handle comments by skipping to the end of the line and then return; the next token. Finally, if the input doesn't match one of the above; cases, it is either an operator character like '+' or the end of the; file. These are handled with this code:. .. code-block:: c++. // Check for end of file. Don't eat the EOF.; if (LastChar == EOF); return tok_eof;. // Otherwise, just return the character as its ascii value.; int ThisChar = LastChar;; LastChar = getchar();; return ThisChar;; }. With this, we have the complete lexer for the basic Kaleidoscope; language (the `full code listing <LangImpl02.html#full-code-listing>`_ for the Lexer; is available in the `next chapter <LangImpl02.html>`_ of the tutorial).; Next we'll `build a simple parser that uses this",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:5241,extend,extend,5241,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,1,['extend'],['extend']
Modifiability," have sub widgets. For example, a dialog box can contain; buttons, text fields, a combo-box, etc. On the screen widgets look like rectangular areas with special; behaviors. In terms of the object-oriented programming we can define a; widget in ROOT as an object of a class deriving from **`TGObject`**. This section presents all currently supported widgets in ROOT and their; most useful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TGNumberEntry`**, **`TGScrollBar`**,; **`TGShutterItem`**, **`TGTextEntry`**, **`TGSlider`**, **`TGListBox`**,; **`TGVi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:20844,inherit,inherit,20844,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inherit']
Modifiability," histfactory/*.C # histfactory requires xml; histfactory/*.py; roostats/*.C # most roostats tutorials require xml too,; roostats/*.py) # because they create test data with histfactory; endif(). if(NOT ROOT_unfold_FOUND); list(APPEND xml_veto unfold/*.C); endif(). if(NOT ROOT_mpi_FOUND); set(mpi_veto io/testTMPIFile.C); endif(). if(NOT xrootd); set(xrootd_veto dataframe/df101_h1Analysis.C; dataframe/df102_NanoAODDimuonAnalysis.C; dataframe/df103_NanoAODHiggsAnalysis.C; dataframe/df106_HiggsToFourLeptons.C; tmva/tmva103_Application.C; dataframe/df033_Describe.py; dataframe/df102_NanoAODDimuonAnalysis.py; dataframe/df103_NanoAODHiggsAnalysis.py; dataframe/df104_HiggsToTwoPhotons.py; dataframe/df105_WBosonAnalysis.py; dataframe/df106_HiggsToFourLeptons.py; dataframe/df107_SingleTopAnalysis.py; roofit/rf618_mixture_models.py # depends on df106_HiggsToFourLeptons.py; rcanvas/df104.py; rcanvas/df105.py; ); endif(). # variables identifying the package must have the package name in lower case (it corresponds to the CMake option name); if(NOT ROOT_r_FOUND); set(r_veto r/*.C); endif(). set(histfactory_veto histfactory/makeExample.C). if(NOT ROOT_fitsio_FOUND); set(fitsio_veto fitsio/*.C); endif(). if(NOT ROOT_mathmore_FOUND); set(mathmore_veto; math/quasirandom.C; math/exampleMultiRoot.C; math/Bessel.C; math/LegendreAssoc.C; math/Legendre.C; math/mathmoreIntegration.C; math/multivarGaus.C; math/tStudent.C; math/normalDist.C; roostats/TestNonCentral.C; roostats/TestNonCentral.py; math/Legendre.py; math/Bessel.py; math/tStudent.py); endif(). if(NOT ROOT_fftw3_FOUND); set(fftw3_veto roofit/rf208_convolution.C; roofit/rf210_angularconv.C; roofit/rf211_paramconv.C; roofit/rf512_wsfactory_oper.C; roofit/rf208_convolution.py; roofit/rf210_angularconv.py; roofit/rf211_paramconv.py; roofit/rf512_wsfactory_oper.py; fft/FFT.C; fit/fitConvolution.C; fit/fitConvolution.py); endif(). if(NOT ROOT_opengl_FOUND); set(opengl_veto tree/staff.C; gl/*.C); endif(). if(NOT GRAPHVIZ_FOUND); set(gviz_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:7590,variab,variables,7590,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['variab'],['variables']
Modifiability," histograms in the stack.; - New drawing option `NOSTACKB`. histograms are drawn next to each other as; bar charts. Example:. ``` {.cpp}; TCanvas* nostackb() {; TCanvas *cst0 = new TCanvas(""cst0"",""cst0"",600,400);; THStack *hs = new THStack(""hs"",""Stacked 1D histograms: option #font[82]{\""nostackb\""}"");. TH1F *h1 = new TH1F(""h1"",""h1"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);. TH1F *h2 = new TH1F(""h2"",""h2"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);. TH1F *h3 = new TH1F(""h3"",""h3"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);. hs->Draw(""nostackb"");; return cst0;; }. ```; ![NOSTACKB plot example](nostackb.png ""NOSTACKB plot example""). ## GUI Libraries. ### TGTextViewostream. - A new `TGTextViewostream` class has been added. It is a text viewer widget and is a specialization of `TGTextView` and `std::ostream`. It uses a `TGTextViewStreamBuf`, which inherits from `std::streambuf`, allowing to stream text directly to the text view in a `cout` - like fashion. A new tutorial showing how to use the `TGTextViewostream` widget has also been added. ## 2D Graphics Libraries. ### TText. - The character position was not correct with the Cocoa backend.; (see https://sft.its.cern.ch/jira/browse/ROOT-6561); - Interactive update of `TText` position did not work in NDC mode.; (se https://sft.its.cern.ch/jira/browse/ROOT-7284). ### TLegend. - Use the new `TStyle` global attribute `gStyle->GetLegendTextSize()` to set the; legend item text size. If this value is 0 and if the text size directly set on; the `TLegend` object is also 0, then the text size is automatically computed to; fit the legend box. If `gStyle->GetLegendTextSize()` is non equal to 0 and if; text size directly set on the `TLegend` object is 0, then the `gStyle` value is; used to draw the legend text. If the text size directly set on the `TLegend`; object is not null, then it is used to draw the legend text. ### TTex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:20108,inherit,inherits,20108,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['inherit'],['inherits']
Modifiability," i.e. use; ``@property (readonly)`` instead of ``@property(readonly)``. .. _ObjCSpaceBeforeProtocolList:. **ObjCSpaceBeforeProtocolList** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCSpaceBeforeProtocolList>`; Add a space in front of an Objective-C protocol list, i.e. use; ``Foo <Protocol>`` instead of ``Foo<Protocol>``. .. _PPIndentWidth:. **PPIndentWidth** (``Integer``) :versionbadge:`clang-format 13` :ref:`¶ <PPIndentWidth>`; The number of columns to use for indentation of preprocessor statements.; When set to -1 (default) ``IndentWidth`` is used also for preprocessor; statements. .. code-block:: c++. PPIndentWidth: 1. #ifdef __linux__; # define FOO; #else; # define BAR; #endif. .. _PackConstructorInitializers:. **PackConstructorInitializers** (``PackConstructorInitializersStyle``) :versionbadge:`clang-format 14` :ref:`¶ <PackConstructorInitializers>`; The pack constructor initializers style to use. Possible values:. * ``PCIS_Never`` (in configuration: ``Never``); Always put each constructor initializer on its own line. .. code-block:: c++. Constructor(); : a(),; b(). * ``PCIS_BinPack`` (in configuration: ``BinPack``); Bin-pack constructor initializers. .. code-block:: c++. Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_CurrentLine`` (in configuration: ``CurrentLine``); Put all constructor initializers on the current line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; ddddddddddddd(). * ``PCIS_NextLine`` (in configuration: ``NextLine``); Same as ``PCIS_CurrentLine`` except that if all constructor initializers; do not fit on the current line, try to fit them on the next line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; ccccccccccc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:92202,config,configuration,92202,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id* ',' *string-literal*. The *module-id* of the *conflict-declaration* specifies the module with which the enclosing module conflicts. The specified module shall not have been imported in the translation unit when the enclosing module is imported. The *string-literal* provides a message to be provided as part ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47816,config,configuration,47816,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['config'],['configuration']
Modifiability," if (x == 0) { } // warn; }. alpha.cplusplus; ^^^^^^^^^^^^^^^. .. _alpha-cplusplus-ArrayDelete:. alpha.cplusplus.ArrayDelete (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of arrays of polymorphic objects that are destructed as their base class.; This checker corresponds to the CERT rule `EXP51-CPP: Do not delete an array through a pointer of the incorrect type <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_. .. code-block:: cpp. class Base {; virtual ~Base() {}; };; class Derived : public Base {}. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void foo() {; Base *x = create();; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' is undefined; }. .. _alpha-cplusplus-DeleteWithNonVirtualDtor:. alpha.cplusplus.DeleteWithNonVirtualDtor (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of polymorphic objects with a non-virtual destructor in their base class. .. code-block:: cpp. class NonVirtual {};; class NVDerived : public NonVirtual {};. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void foo() {; NonVirtual *x = create();; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. .. _alpha-cplusplus-InvalidatedIterator:. alpha.cplusplus.InvalidatedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of invalidated iterators. .. code-block:: cpp. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. .. _alpha-cplusplus-IteratorRange:. alpha.cplusplus.IteratorRange (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for iterators used outside their valid ranges. .. code-block:: cpp. void simple_bad_end(const std::vect",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:53462,polymorphi,polymorphic,53462,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['polymorphi'],['polymorphic']
Modifiability," if(LLVM_BUILD_LLVM_C_DYLIB AND MSVC); # Build the LLVM-C.dll library that exports the C API. set(LLVM_LINK_COMPONENTS; ${LLVM_DYLIB_COMPONENTS}; ). llvm_map_components_to_libnames(LIB_NAMES ${LLVM_DYLIB_COMPONENTS}); list(REMOVE_DUPLICATES LIB_NAMES). # The python script needs to know whether symbols are prefixed with underscores or not.; if(LLVM_HOST_TRIPLE MATCHES ""i?86-.*win.*""); set(GEN_UNDERSCORE ""--underscore""); else(); set(GEN_UNDERSCORE """"); endif(). # Set this name here, not used in multi conf loop,; # but add script will pick the right one.; set(LIBSFILE ${LLVM_BINARY_DIR}/${CMAKE_CFG_INTDIR}/libllvm-c.args). # Get the full name to the libs so the python script understands them.; foreach(lib ${LIB_NAMES}); list(APPEND FULL_LIB_NAMES ${LLVM_LIBRARY_DIR}/${lib}.lib); endforeach(). # Need to separate lib names with newlines.; string(REPLACE "";"" ""\n"" FILE_CONTENT ""${FULL_LIB_NAMES}""). if(NOT ""${CMAKE_CFG_INTDIR}"" STREQUAL "".""); foreach(BUILD_MODE ${CMAKE_CONFIGURATION_TYPES}); # Replace the special string with a per config directory.; string(REPLACE ${CMAKE_CFG_INTDIR} ${BUILD_MODE} PER_CONF_CONTENT ""${FILE_CONTENT}""). # Write out the full lib names into file to be read by the python script.; # One libsfile per build, the add_custom_command should expand; # ${CMAKE_CFG_INTDIR} correctly and select the right one.; file(WRITE ${LLVM_BINARY_DIR}/${BUILD_MODE}/libllvm-c.args ""${PER_CONF_CONTENT}""); endforeach(); else(); # Write out the full lib names into file to be read by the python script.; file(WRITE ${LIBSFILE} ""${FILE_CONTENT}""); endif(). # Generate the exports file dynamically.; set(GEN_SCRIPT ${CMAKE_CURRENT_SOURCE_DIR}/gen-msvc-exports.py). set(LLVM_EXPORTED_SYMBOL_FILE ${LLVM_BINARY_DIR}/${CMAKE_CFG_INTDIR}/libllvm-c.exports); get_host_tool_path(llvm-nm LLVM_NM llvm_nm_exe llvm_nm_target). add_custom_command(OUTPUT ${LLVM_EXPORTED_SYMBOL_FILE}; COMMAND ""${Python3_EXECUTABLE}"" ${GEN_SCRIPT} --libsfile ${LIBSFILE} ${GEN_UNDERSCORE} --nm ""${llvm_nm_exe}"" -o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-shlib/CMakeLists.txt:5613,config,config,5613,interpreter/llvm-project/llvm/tools/llvm-shlib/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-shlib/CMakeLists.txt,1,['config'],['config']
Modifiability," in :ref:`debug intrinsics<dbg_intrinsics>`; (such as ``llvm.dbg.declare`` and ``llvm.dbg.value``) to describe how the; referenced LLVM variable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and evaluate; opcodes from the DIExpression until the final variable description is produced. The current supported opcode vocabulary is limited:. - ``DW_OP_deref`` dereferences the top of the expression stack.; - ``DW_OP_plus`` pops the last two entries from the expression stack, adds; them together and appends the result to the expression stack.; - ``DW_OP_minus`` pops the last two entries from the expression stack, subtracts; the last entry from the second last entry and appends the result to the; expression stack.; - ``DW_OP_plus_uconst, 93`` adds ``93`` to the working expression.; - ``DW_OP_LLVM_fragment, 16, 8`` specifies the offset and size (``16`` and ``8``; here, respectively) of the variable fragment from the working expression. Note; that contrary to DW_OP_bit_piece, the offset is describing the location; within the described source variable.; - ``DW_OP_LLVM_convert, 16, DW_ATE_signed`` specifies a bit size and encoding; (``16`` and ``DW_ATE_signed`` here, respectively) to which the top of the; expression stack is to be converted. Maps into a ``DW_OP_convert`` operation; that references a base type constructed from the supplied values.; - ``DW_OP_LLVM_tag_offset, tag_offset`` specifies that a memory tag should be; optionally applied to the pointer. The memory tag is derived from the; given tag offset in an implementation-defined manner.; - ``DW_OP_swap`` swaps top two stack entries.; - ``DW_OP_xderef`` provides extended dereference mechanism. The entry at the top; of the stack is treated as an address. The second stack entry is treated as an; address space identifier.; - ``DW_OP_stack_value`` marks a constant value.; - ``DW_OP_LLVM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:262048,variab,variable,262048,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," in JSROOT.cleanup; 5. Fix - repair TTree player UI; 6. Fix - error in TH3 filling; 7. Fix - correctly access top element in simple layout; 8. Fix - exclude duplicated points when drawing TH2 with SURF3 options. ## Changes in 5.6.3; 1. Fix - support clipping for tracks and points in geo painter; 2. Fix - geometry with TGeoNodeOffset was not correctly drawn; 3. Fix - use proper formatting for entries and integral (#179); 4. Fix - TTree::Draw for 3d histogram was not properly performed. ## Changes in 5.6.2; 1. Fix - correctly handle negative parameter values in TF1/TF2. ## Changes in 5.6.1; 1. Add TMath.BreitWigner function; 2. Support custom streamers for TMaterial and TMixture (very old examples); 3. Fix Y-scale drawing of THStack (https://root-forum.cern.ch/t/31266); 4. Fix - select palette from colz element; 5. Fix - LZ4 uncompression of large buffers. ## Changes in 5.6.0; 1. By drawing outline speed up (factor 10) canvas with many small sub-pads; 2. Let configure user click and double-click handlers, extend tooltip.htm example; 3. Implement workaround for standard THREE.SVGRenderer - no need for patched version; 4. When producing 3D graphical images in batch, use normal THREE.CanvasRenderer; 5. Use WebGL renderer in Chrome headless mode for 3D images generation; 6. Provide possibility to create SVG files for canvas or frame (#172); 7. Support text drawing with TH1 bar option; 8. Fix - when drawing text, reserve extra y range to show it correctly; 9. Migrate to Node.js 8, do not support older versions. ## Changes in 5.5.2; 1. Fix - draw TH2Poly bins outline when no content specified; 2. Fix - always set axis interactive handlers (#170); 3. Fix - take into account zaxis properties when drawing color palette (#171). ## Changes in 5.5.1; 1. Fix - adjust v7 part to new class naming convention, started with R; 2. Fix - show RCanvas title; 3. New - implement 'nocache' option for JSROOT scripts loading. When specified in URL with; JSRootCore.js script, tries to avoid scr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:32298,config,configure,32298,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,2,"['config', 'extend']","['configure', 'extend']"
Modifiability," in `nobrowser` mode.; - Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; - Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE. ## TTree Libraries. ### TTree Behavior change. #### Merging. Added fast cloning support to TTree::MergeTrees and TTree::Merge(TCollection*,Option_t*). #### TTreeCache. The TTreeCache is now enabled by default. The default size of the TTreeCache; is the estimated size of a cluster size for the TTree. The TTreeCache; prefilling is also enabled by default; when in learning phase rather than; reading each requested branch individually, the TTreeCache will read all the; branches thus trading off the latencies inherent to multiple small reads for; the potential of requesting more data than needed by read from the disk or; server the baskets for too many branches. The default behavior can be changed by either updating one of the rootrc files; or by setting environment variables. The rootrc files, both the global and the; local ones, now support the following the resource variable TTreeCache.Size; which set the default size factor for auto sizing TTreeCache for TTrees. The; estimated cluster size for the TTree and this factor is used to give the cache; size. If option is set to zero auto cache creation is disabled and the default; cache size is the historical one (equivalent to factor 1.0). If set to; non zero auto cache creation is enabled and both auto created and; default sized caches will use the configured factor: 0.0 no automatic cache; and greater than 0.0 to enable cache. This value can be overridden by the; environment variable ROOT_TTREECACHE_SIZE. The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling; type. The prefill type may be: 0 for no prefilling and 1 to prefill all; the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL. In part",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:13153,variab,variables,13153,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['variab'],['variables']
Modifiability," in a `DebugValueUser` base class. This refers to a `ValueAsMetadata` object referring to `Value`s, via the `TrackingMetadata` facility. The various kinds of debug intrinsic (value, declare, assign) are all stored in the `DPValue` object, with a ""Type"" field disamgibuating which is which. ## Finding debug info records. Utilities such as `findDbgUsers` and the like now have an optional argument that will return the set of `DPValue` records that refer to a `Value`. You should be able to treat them the same as intrinsics. ## Examining debug info records at positions. Call `Instruction::getDbgValueRange()` to get the range of `DPValue` objects that are attached to an instruction. ## Moving around, deleting. You can use `DPValue::removeFromParent` to unlink a `DPValue` from it's marker, and then `BasicBlock::insertDPValueBefore` or `BasicBlock::insertDPValueAfter` to re-insert the `DPValue` somewhere else. You cannot insert a `DPValue` at an arbitary point in a list of `DPValue`s (if you're doing this with `dbg.value`s then it's unlikely to be correct). Erase `DPValue`s by calling `eraseFromParent` or `deleteInstr` if it's already been removed. ## What about dangling `DPValue`s?. If you have a block like so:. ```text; foo:; %bar = add i32 %baz...; dbg.value(metadata i32 %bar,...; br label %xyzzy; ```. your optimisation pass may wish to erase the terminator and then do something to the block. This is easy to do when debug info is kept in instructions, but with `DPValue`s there is no trailing instruction to attach the variable information to in the block above, once the terminator is erased. For such degenerate blocks, `DPValue`s are stored temporarily in a map in `LLVMContext`, and are re-inserted when a terminator is reinserted to the block or other instruction inserted at `end()`. This can technically lead to trouble in the vanishingly rare scenario where an optimisation pass erases a terminator and then decides to erase the whole block. (We recommend not doing that).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RemoveDIsDebugInfo.md:6062,variab,variable,6062,interpreter/llvm-project/llvm/docs/RemoveDIsDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RemoveDIsDebugInfo.md,1,['variab'],['variable']
Modifiability," in a boolean expression. The; ID of each condition corresponds to a bit index in the condition bitmap which; is set based on the evaluation of the condition. '``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.tvbitmap.update(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>); i32 <bitmap-index>,; ptr <mcdc-temp-addr>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.tvbitmap.update``' intrinsic is used to track MC/DC; test vector execution after each boolean expression has been fully executed.; The overall value of the condition bitmap, after it has been successively; updated using the '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic with; the true or false evaluation of each condition, uniquely identifies an executed; MC/DC test vector and is used as a bit index into the global test vector; bitmap. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. The fourth argument is the byte index into the global test vector bitmap; corresponding to the function. The fifth argument is the address of the condition bitmap, which contains a; value representing an executed MC/DC test vector. It is loaded and used as the; bit index of the test vector bitmap. Semantics:; """""""""""""""""""". This intrinsic represents the final operation of an MC/DC instrumentation; sequence and will cause the ``-instrprof`` pass to generate the code to; instrument an update of a function's global test vector bitmap to indicate that; a test vector has been execute",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:535584,variab,variable,535584,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," in any case faster than the general inverter method for all symmetric matrices (SMatrix::Invert), which uses the Bunch-Kaufman decomposition.; Add also a new free function, ROOT::Math::SolveChol for solving a symmetric linear system. For users who need the solution, using this functions avoid for them performing the inversion and then a matrix multiplication. Add support in the SMatrix class for operator m[i][j]; Add in the dictionary the typedefs for some square and symmetrix matrices based on double and floats (up to size 7) defined in the file Math/SMatrixDfwd and Math/SMatrixFfwd; . Minuit. Apply various improvements in the TMInuitMInimizer class thanks to the feedback of Alfio Lazzaro:; ; implement Hess() and CovMatrixStatus();; add new method based on SEEK. The Tolerance() value can be used to specify the volume (in unit of sigma) for searching for the global minimum; fix some of the methods, like NCalls() and GlobalCC(); . Minuit2. Apply some fixes in MnHesse and MnPosDef classes to check correctly variables to not be zero.; (use same checks as in F77Minuit); ; Fix a bug introduced in DavidonErrorCalculator when checking for delgam. Negative values are allowed. This fixes a test problem given privately by A. Suter.; ; Uses also a tighter condition on edm when exiting the iterations (factor of 5 smaller). This is more consistent with conditions used by F77Minuit.; ; Fix a bug in MnCross in the standalone version of Minuit (when WARNINGMSG was not defined).; ; Fix a bug in the sign of the derivative for sine transformation which are used with double bound parameters. The bug could affect the minimization of function with user provided gradient and bound parameters and bound parameters. It could also affected Fumili2. Furthermore, a wrong sign for the correlation matrix could also have been obtained in some cases with bound parameters.; ; Use a tolerance of 0.01 instead of 0.05 in MnContours. The value of 0.01 is the same used in Minos. This is sufficient to ge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:5413,variab,variables,5413,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,1,['variab'],['variables']
Modifiability," in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:32216,config,configuration,32216,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability," in signed order of the lower bound and; they must be non-contiguous. For vector-typed instructions, the range is applied element-wise. Examples:. .. code-block:: llvm. %a = load i8, ptr %x, align 1, !range !0 ; Can only be 0 or 1; %b = load i8, ptr %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1; %c = call i8 @foo(), !range !2 ; Can only be 0, 1, 3, 4 or 5; %d = invoke i8 @bar() to label %cont; unwind label %lpad, !range !3 ; Can only be -2, -1, 3, 4 or 5; %e = load <2 x i8>, ptr %x, !range 0 ; Can only be <0 or 1, 0 or 1>; ...; !0 = !{ i8 0, i8 2 }; !1 = !{ i8 255, i8 2 }; !2 = !{ i8 0, i8 2, i8 3, i8 6 }; !3 = !{ i8 -2, i8 0, i8 3, i8 6 }. '``absolute_symbol``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``absolute_symbol`` metadata may be attached to a global variable; declaration. It marks the declaration as a reference to an absolute symbol,; which causes the backend to use absolute relocations for the symbol even; in position independent code, and expresses the possible ranges that the; global variable's *address* (not its value) is in, in the same format as; ``range`` metadata, with the extension that the pair ``all-ones,all-ones``; may be used to represent the full set. Example (assuming 64-bit pointers):. .. code-block:: llvm. @a = external global i8, !absolute_symbol !0 ; Absolute symbol in range [0,256); @b = external global i8, !absolute_symbol !1 ; Absolute symbol in range [0,2^64). ...; !0 = !{ i64 0, i64 256 }; !1 = !{ i64 -1, i64 -1 }. '``callees``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^. ``callees`` metadata may be attached to indirect call sites. If ``callees``; metadata is attached to a call site, and any callee is not among the set of; functions provided by the metadata, the behavior is undefined. The intent of; this metadata is to facilitate optimizations such as indirect-call promotion.; For example, in the code below, the call instruction may only target the; ``add`` or ``sub`` functions:. .. code-block:: llvm. %result = call i64 %binop(i64 %x, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:286646,variab,variable,286646,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," in the example above:. - *ExecutionSession* represents the JIT'd program and provides context for the; JIT: It contains the JITDylibs, error reporting mechanisms, and dispatches the; materializers. - *JITDylibs* provide the symbol tables. - *Layers* (ObjLinkingLayer and CXXLayer) are wrappers around compilers and; allow clients to add uncompiled program representations supported by those; compilers to JITDylibs. - *ResourceTrackers* allow you to remove code. Several other important APIs are used explicitly. JIT clients need not be aware; of them, but Layer authors will use them:. - *MaterializationUnit* - When XXXLayer::add is invoked it wraps the given; program representation (in this example, C++ source) in a MaterializationUnit,; which is then stored in the JITDylib. MaterializationUnits are responsible for; describing the definitions they provide, and for unwrapping the program; representation and passing it back to the layer when compilation is required; (this ownership shuffle makes writing thread-safe layers easier, since the; ownership of the program representation will be passed back on the stack,; rather than having to be fished out of a Layer member, which would require; synchronization). - *MaterializationResponsibility* - When a MaterializationUnit hands a program; representation back to the layer it comes with an associated; MaterializationResponsibility object. This object tracks the definitions; that must be materialized and provides a way to notify the JITDylib once they; are either successfully materialized or a failure occurs. Absolute Symbols, Aliases, and Reexports; ========================================. ORC makes it easy to define symbols with absolute addresses, or symbols that; are simply aliases of other symbols:. Absolute Symbols; ----------------. Absolute symbols are symbols that map directly to addresses without requiring; further materialization, for example: ""foo"" = 0x1234. One use case for; absolute symbols is allowing resolution ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:12340,layers,layers,12340,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['layers'],['layers']
Modifiability," in the matrix operations test. Minuit. Implement in the TMinuitMinimizer class the method SetPrecision() using the ""SET EPS"" Minuit command; Fix a problem when using the user provided gradient in TMinuitMinimizer. The gradient calculation is always forced, i.e. Minuit will always use the derivatives calculations provided by the user. This is now the same behavior as in Minuit2Minimizer.; Implement in TMinuitMinimizer a method to retrieve the variable name given the index.; Fix a printout in TMinuit::mnscan and a problem observed with valgrind. Minuit2. Fix a bug in MnFunctionCross. ; Add a protection against very small step sizes which can cause; nan values in InitialGradientCalculator.; Implement a new function in the MnUserTransformation class, FindIndex(name), which returns -1 when the parameter name does not exist.; Implement new methods in Minuit2Minimizer as requested by the Minimizer interface:; SetPrecision(double eps) to change the precision value used internally in Minuit2 (in MnPrecision), VariableName(index) to return the name of a variable (parameter) given an index, and VariableIndex(name) to return the index of a variable given a name.; Set a status code in Minuit2Minimizer according to the following convention:; status = minimizeStatus + 10 * minosStatus + 100 * hesseStatus.; See the Minuit2Minimizer reference documentation for the possible values of minimizeStatus , minosStatus and hesseStatus.; In MnHesse. when the inversion of the hessian matrix failed, return MnInvertFailed instead of MnHesseFailed. Mathcore Fitting classes. Fix the fitting with the integral option in multi-dimensions.; Force the gradient calculation when requested in the minimizer; classes and avoid to perform the check when using TMinuit. This was; already the case in Minuit2.; Add new class ROOT::Fit::SparseData for dealing with binned sparse data. This class automatically merges the empty region, so they can be considered, whenever possible as a larger single bin. This impro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html:2164,variab,variable,2164,math/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html,2,['variab'],['variable']
Modifiability," index = dataHist.getIndex(externalCoordinates); // No side effect; ```; This will allow for marking more functions const, or for lying less about const correctness. - RooDataHist now supports fits with RooFit's faster `BatchMode()`.; - Lower memory footprint. If weight errors are not needed, RooDataHist now allocates only 40% of the memory that the old implementation used. #### Fix bin volume correction logic in `RooDataHist::sum()`. The public member function `RooDataHist::sum()` has three overloads.; Two of these overloads accept a `sumSet` parameter to not sum over all variables.; These two overloads previously behaved inconsistently when the `correctForBinSize` or `inverseBinCor` flags were set.; If you use the `RooDataHist::sum()` function in you own classes, please check that it can still be used with its new logic.; The new and corrected bin correction behaviour is:. - `correctForBinSize`: multiply counts in each bin by the bin volume corresponding to the variables in `sumSet`; - `inverseBinCor`: divide counts in each bin by the bin volume corresponding to the variables *not* in `sumSet`. ### New fully parametrised Crystal Ball shape class. So far, the Crystal Ball distribution has been represented in RooFit only by the `RooCBShape` class, which has a Gaussian core and a single power-law tail on one side.; This release introduces [`RooCrystalBall`](https://root.cern/doc/v624/classRooCrystalBall.html), which implements some common generalizations of the Crystal Ball shape:. - symmetric or asymmetric power-law tails on both sides; - different width parameters for the left and right sides of the Gaussian core. The new `RooCrystalBall` class can substitute the `RooDSCBShape` and `RooSDSCBShape`, which were passed around in the community. ## 2D Graphics Libraries. - Add the method `AddPoint`to `TGraph(x,y)` and `TGraph2D(x,y,z)`, equivalent to `SetPoint(g->GetN(),x,y)`and `SetPoint(g->GetN(),x,y,z)`; - Option `E0` draws error bars and markers are drawn for bins w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:23811,variab,variables,23811,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,2,['variab'],['variables']
Modifiability," initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial value for a ``GlobalVariable``. It is not legal to call; this method if there is no initializer. .. _BasicBlock:. The ``BasicBlock`` class; ------------------------. ``#include ""llvm/IR/BasicBlock.h""``. header source: `BasicBlock.h; <https://llvm.org/doxygen/BasicBlock_8h_source.html>`_. doxygen info: `BasicBlock Class; <https://llvm.org/doxygen/classllvm_1_1BasicBlock.html>`_. Superclass: Value_. This class represents a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:160045,variab,variable,160045,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,['variab'],['variable']
Modifiability," input for our; VM. Performance is not wonderful, but it works right.; * The file is scheduled to be compiled (rigorously) at a later; time. This could be done by some background process or by a second; processor in the system during idle time or something...; * To keep things ""safe"" ie to enforce a sandbox on Java/foreign code,; we could sign the generated VM code with a host specific private; key. Then before the code is executed/loaded, we can check to see if; the trusted compiler generated the code. This would be much quicker; than having to validate consistency (especially if bounds checks have; been removed, for example). > This is important because the audiences for these two goals are very; > different. Architects and many compiler people care much more about; > the second question. The Java compiler and OS community care much more; > about the first one. 3. By focusing on a more low level virtual machine, we have much more room; for value add. The nice safe ""sandbox"" VM can be provided as a layer; on top of it. It also lets us focus on the more interesting compilers; related projects. > 2. Design issues to consider (an initial list that we should continue; > to modify). Note that I'm not trying to suggest actual solutions here,; > but just various directions we can pursue:. Understood. :). > a. A single-assignment VM, which we've both already been thinking; > about. Yup, I think that this makes a lot of sense. I am still intrigued,; however, by the prospect of a minimally allocated VM representation... I; think that it could have definite advantages for certain applications; (think very small machines, like PDAs). I don't, however, think that our; initial implementations should focus on this. :). Here are some other auxiliary goals that I think we should consider:. 1. Primary goal: Support a high performance dynamic compilation; system. This means that we have an ""ideal"" division of labor between; the runtime and static compilers. Of course, the other goals ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:2366,sandbox,sandbox,2366,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['sandbox'],['sandbox']
Modifiability," instantiation. Given; int j;; template<typename T> void A(T t) { T i; j += 42;}; A(0);; A(0U);; declStmt(isInTemplateInstantiation()); matches 'int i;' and 'unsigned i'.; unless(stmt(isInTemplateInstantiation())); will NOT match j += 42; as it's shared between the template definition and; instantiation. Matcher<StringLiteral>hasSizeunsigned N; Matches nodes that have the specified size. Given; int a[42];; int b[2 * 21];; int c[41], d[43];; char *s = ""abcd"";; wchar_t *ws = L""abcd"";; char *w = ""a"";; constantArrayType(hasSize(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"". Matcher<TagDecl>isClass; Matches TagDecl object that are spelled with ""class."". Example matches C, but not S, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<TagDecl>isEnum; Matches TagDecl object that are spelled with ""enum."". Example matches E, but not C, S or U.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isStruct; Matches TagDecl object that are spelled with ""struct."". Example matches S, but not C, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isUnion; Matches TagDecl object that are spelled with ""union."". Example matches U, but not C, S or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TemplateArgument>equalsIntegralValuestd::string Value; Matches a TemplateArgument of integral type with a given value. Note that 'Value' is a string as the templa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:117828,variab,variable,117828,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability," instead of 8).; This reduces the addressable memory per process to 4GB - but that is; usally sufficient. The advantages are reduced memory consumption (due to; the smaller pointers) and increased performance compared to 32 bit; applications due to the availability of the 64 bit instructions. The; Clang developers mailing list archive [contains a good; comparison](http://clang-developers.42468.n3.nabble.com/Re-PATCH-add-x32-psABI-support-td4024297.html). To build and run binaries compiled in x32, toolchain support is needed.; That is available in the in binutils (2.22), GCC (4.8), glibc (2.16),; Linux kernel (3.4) and even GDB (7.5). These versions are not available; in regular distributions yet (except for [this beta Gentoo; distro](http://dev.gentoo.org/~vapier/x32/stage3-amd64-x32-20120605.tar.xz); built in x32); once they are, building and running x86-64 and x32; side-by-side will be possible. ## Build System; ROOT 6.00/00 can be built either using the classic ""./configure;make"" method or using CMake.; The CMake system has been completed for this version and should be functionally equivalent; to the classic one. The [detailed instructions](https://root.cern/install/build_from_source/) are available.; In upcoming releases the classic method will slowly be deprecated in favor of the CMake one. ## Core Libraries. ### Cling vs CINT. Cling follows the C++ standard much more strictly than CINT. In; particular some code that used to run with CINT will either issue new; warnings or new compilation errors. For example when CINT was parsing; Namespace::%Symbol it would not only apply the C++ search rules but also; search in the outer scopes and for this example could actually return; ::%Symbol instead of (as Cling now does) issuing a compilation error. #### Template class names; Cling no longer supports refering to a class template instantiation of a; class template that has all default template parameter without the \<\>.; With:. ``` {.cpp}; template <typename T = int> cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:2002,config,configure,2002,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,1,['config'],['configure']
Modifiability," into a std:vector, and ""adds""; them to TMVA, using the dedicated calls:; factory->AddSignalTrainingEvent( vars, signalWeight );; (and replacing ""Signal"" by ""Background"", and ""Training"" by; ""Test""). After the event loop, everything continues as in; the standard method.; . Methods:. Simulated Annealing in Cuts,FDA: Entirely new; Simulated Annealing (SA) algorithm for global minimisation; in presence of local minima (optionally used in cut; optimisation (MethodCuts) and the Function Discriminant; (MethodFDA)). The SA algorithm features two approaches,; one starting at minimal temperature (ie, from within a; local minimum), slowly increasing, and another one; starting at high temperature, slowly decreasing into a; minimum. Code developed and written by Kamil Bartlomiej; Kraszewski, Maciej Kruk and Krzysztof Danielowski from IFJ; and AGH/UJ, Krakow, Poland.; ; Cuts: Added printouts, quoting the explicit cut; application for given signal efficiency. In case of; transformations of the input variables, the full expressions; are given. Added warning to Fisher in case of variable; normalisation. ; ; Cuts: Added physical limits to min/max cuts if; smart option is used.; ; BDT: removed hard-coded weight file name; now,; paths and names of weight files are written as TObjStrings; into ROOT target file, and retrieved for plotting;; available weight files (corresponding to target used) can; be chosen from pop-up GUI.; ; BDT: Changes in handling negative weights in BDT; algorithm. Events with negative weights now get their; weight reduced (*= 1/boostweight) rather than increased; (*= boostweight) as the other events do. Otherwise these; events tend to receive increasingly stronger boosts,; because their effects on the separation gain are as if; background events were selected as signal and vice versa; (hence the events tend to be ""wanted"" in signal nodes, but; are boosted as if they were misclassified). In addition,; the separation indices are protected against negative S or; S+B r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html:2215,variab,variables,2215,tmva/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html,1,['variab'],['variables']
Modifiability," into the program. These libraries must be libraries that come from; your **lib** directory. The libraries must be specified without their; ``lib`` prefix. For example, to link ``libsample.a``, you would set; ``USEDLIBS`` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. Note that this works only for statically linked libraries. LLVM is split; into a large number of static libraries, and the list of libraries you; require may be much longer than the list above. To see a full list of; libraries use: ``llvm-config --libs all``. Using ``LINK_COMPONENTS`` as; described below, obviates the need to set ``LLVMLIBS``. ``LINK_COMPONENTS``. This variable holds a space separated list of components that the LLVM; ``Makefiles`` pass to the ``llvm-config`` tool to generate a link line for; the program. For example, to link with all LLVM libraries use; ``LINK_COMPONENTS = all``. ``LIBS``. To link dynamic libraries, add ``-l<library base name>`` to the ``LIBS``; variable. The LLVM build system will look in the same places for dynamic; libraries as it does for static libraries. For example, to link ``libsample.so``, you would have the following line in; your ``Makefile``:. .. code-block:: makefile. LIBS += -lsample. Note that ``LIBS`` must occur in the Makefile after the inclusion of; ``Makefile.common``. Miscellaneous Variables; -----------------------. ``CFLAGS`` & ``CPPFLAGS``. This variable can be used to add options to the C and C++ compiler,; respectively. It is typically used to add ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:7162,config,config,7162,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,1,['config'],['config']
Modifiability," invocation.; set(extra_deps """"); if(""openmp"" IN_LIST LLVM_ENABLE_RUNTIMES); foreach(dep opt llvm-link llvm-extract clang clang-offload-packager); if(TARGET ${dep} AND OPENMP_ENABLE_LIBOMPTARGET); list(APPEND extra_deps ${dep}); endif(); endforeach(); endif(); if(""libc"" IN_LIST LLVM_ENABLE_PROJECTS AND; (LLVM_LIBC_FULL_BUILD OR LIBC_GPU_BUILD OR LIBC_GPU_ARCHITECTURES)); if(LIBC_HDRGEN_EXE); set(hdrgen_exe ${LIBC_HDRGEN_EXE}); else(); if(TARGET ${LIBC_TABLEGEN_EXE}); set(hdrgen_exe $<TARGET_FILE:${LIBC_TABLEGEN_EXE}>); else(); set(hdrgen_exe ${LIBC_TABLEGEN_EXE}); endif(); set(hdrgen_deps ${LIBC_TABLEGEN_TARGET}); endif(); if(NOT hdrgen_exe); message(FATAL_ERROR ""libc-hdrgen executable missing""); endif(); set(libc_cmake_args ""-DLIBC_HDRGEN_EXE=${hdrgen_exe}""; ""-DLLVM_LIBC_FULL_BUILD=ON""); list(APPEND extra_deps ${hdrgen_deps}); if(LIBC_GPU_BUILD OR LIBC_GPU_ARCHITECTURES); foreach(dep clang-offload-packager nvptx-arch amdgpu-arch); if(TARGET ${dep}); list(APPEND extra_deps ${dep}); endif(); endforeach(); endif(); endif(); if(NOT LLVM_RUNTIME_TARGETS); runtime_default_target(; DEPENDS ${builtins_dep} ${extra_deps}; CMAKE_ARGS ${libc_cmake_args}; PREFIXES ${prefixes}); set(test_targets check-runtimes); else(); if(""default"" IN_LIST LLVM_RUNTIME_TARGETS); runtime_default_target(; DEPENDS ${builtins_dep} ${extra_deps}; CMAKE_ARGS ${libc_cmake_args}; PREFIXES ${prefixes}); list(REMOVE_ITEM LLVM_RUNTIME_TARGETS ""default""); else(); add_custom_target(runtimes); add_custom_target(runtimes-configure); add_custom_target(install-runtimes); add_custom_target(install-runtimes-stripped); if(LLVM_INCLUDE_TESTS); add_custom_target(check-runtimes); add_custom_target(runtimes-test-depends); set(test_targets """"); endif(); if(LLVM_RUNTIME_DISTRIBUTION_COMPONENTS); foreach(component ${LLVM_RUNTIME_DISTRIBUTION_COMPONENTS}); add_custom_target(${component}); add_custom_target(install-${component}); add_custom_target(install-${component}-stripped); endforeach(); endif(); endif(). foreach(nam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:16879,config,configure,16879,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,1,['config'],['configure']
Modifiability," is a list of directories that can be built in parallel. These will be; built after the directories in DIRS have been built. ``OPTIONAL_DIRS``. This is a list of directories that can be built if they exist, but will not; cause an error if they do not exist. They are built serially in the order; in which they are listed. Variables for Building Libraries; --------------------------------. ``LIBRARYNAME``. This variable contains the base name of the library that will be built. For; example, to build a library named ``libsample.a``, ``LIBRARYNAME`` should; be set to ``sample``. ``BUILD_ARCHIVE``. By default, a library is a ``.o`` file that is linked directly into a; program. To build an archive (also known as a static library), set the; ``BUILD_ARCHIVE`` variable. ``SHARED_LIBRARY``. If ``SHARED_LIBRARY`` is defined in your Makefile, a shared (or dynamic); library will be built. Variables for Building Programs; -------------------------------. ``TOOLNAME``. This variable contains the name of the program that will be built. For; example, to build an executable named ``sample``, ``TOOLNAME`` should be set; to ``sample``. ``USEDLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be libraries that come from; your **lib** directory. The libraries must be specified without their; ``lib`` prefix. For example, to link ``libsample.a``, you would set; ``USEDLIBS`` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. No",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:5897,variab,variable,5897,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,1,['variab'],['variable']
Modifiability," is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old));. * ``BBIAS_Always`` (in configuration: ``Always``); Always break before inline ASM colon. .. code-block:: c++. asm volatile(""string"",; :; : val);. .. _BreakBeforeTernaryOperators:. **BreakBeforeTernaryOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeTernaryOperators>`; If ``true``, ternary operators will be placed after line breaks. .. code-block:: c++. true:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription; ? firstValue; : SecondValueVeryVeryVeryVeryLong;. false:; veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?; firstValue :; SecondValueVeryVeryVeryVeryLong;. .. _BreakConstructorInitializers:. **BreakConstructorInitializers** (``BreakConstructorInitializersStyle``) :versionbadge:`clang-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:53476,config,configuration,53476,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," is attached to SDNodes in SelectionDAGs. After instruction selection; has occurred and a MIR function is created, if the SDNode associated with debug; metadata is allocated a virtual register, that virtual register is used as the; variable location. If the SDNode is folded into a machine instruction or; otherwise transformed into a non-register, the variable location becomes; unavailable. Locations that are unavailable are treated as if they have been optimized out:; in IR the location would be assigned ``undef`` by a debug intrinsic, and in MIR; the equivalent location is used. After MIR locations are assigned to each variable, machine pseudo-instructions; corresponding to each ``llvm.dbg.value`` intrinsic are inserted. There are two; forms of this type of instruction. The first form, ``DBG_VALUE``, appears thus:. .. code-block:: text. DBG_VALUE %1, $noreg, !123, !DIExpression(). And has the following operands:; * The first operand can record the variable location as a register,; a frame index, an immediate, or the base address register if the original; debug intrinsic referred to memory. ``$noreg`` indicates the variable; location is undefined, equivalent to an ``undef`` dbg.value operand.; * The type of the second operand indicates whether the variable location is; directly referred to by the DBG_VALUE, or whether it is indirect. The; ``$noreg`` register signifies the former, an immediate operand (0) the; latter.; * Operand 3 is the Variable field of the original debug intrinsic.; * Operand 4 is the Expression field of the original debug intrinsic. The second form, ``DBG_VALUE_LIST``, appears thus:. .. code-block:: text. DBG_VALUE_LIST !123, !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_plus), %1, %2. And has the following operands:; * The first operand is the Variable field of the original debug intrinsic.; * The second operand is the Expression field of the original debug intrinsic.; * Any number of operands, from the 3rd onwards, record a sequence ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:27387,variab,variable,27387,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability," is described by its center position, entered in the ‘Center; X', ‘Center Y' and ‘Center Z' edit boxes, and its lengths (extents); entered in the ‘Length X', ‘Length Y' and ‘Length Z' edit boxes. This clipping is achieved using OpenGL clip plane support; as such,; there are certain limitations:. - Solid shapes are not capped - they appear hollow. - Only shapes, which can be described with combination of planes, can; be rendered in this fashion - e.g. a clipping tube is not possible. - Each additional clipping plane requires an additional render pass -; so the more active planes the more time the render will take. Set the current clip object with **`TGLClipSet::SetClipType`**. ``` {.cpp}; v->GetClipSet()->SetClipType(TGLClipSet::kClipPlane);; ```. Configure the clip object with **`TGLClipSet::SetClipState`**. ``` {.cpp}; Double_t planeEq[4] = {0.5,1.0,-1.0, 2.0};; v->GetClipSet()->SetClipState(TGLClipSet::kClipPlane, planeEq);; ```. As with cameras, any clip can be configured at any time, but you must; set the clip current to see the effect. #### Manipulators. *Manipulators* are GUI ‘widgets' or controls attached to a 3D object in; the viewer, allowing a direct manipulation of the object's geometry.; There are three manipulators for the three basic geometries; transformations. In each case, the *manipulator* consists of three; components, one for each local axis of the object, shown in standard; colors: red (X), green (Y) and blue (Z). ![GL Viewer object manipulators](pictures/030000DE.png). Activate the *manipulator* by moving the mouse over one of these; components (which turns yellow to indicate active state). Click with; left mouse and drag this active component to perform the manipulation.; Toggle between the *manipulator* types using the ‘x', ‘c', ‘v' keys; while the mouse cursor is above the manipulator. Note: Manipulators; cannot be controlled via the API at present. #### Guides. Guides are visual aids drawn into the viewer world. Controls for these; are under",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:116034,config,configured,116034,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['config'],['configured']
Modifiability," is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35287,config,configuration,35287,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,"['config', 'portab']","['configuration', 'portable']"
Modifiability," is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if you call `mybranch.SetAutoDelete(kTRUE)`; (default is `kFALSE`). Consider the example in `$ROOTSYS/test/Event.h`. The top-level branch in; the tree `T` is declared with:. ``` {.cpp}; Event *event = 0;; // event must be null or point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; ```. When reading the Tree, one can choose one of these 3 options:. Option 1:. ``` {.cpp}; for (Int_t i = 0; i<nentries; i++) {; T.GetEntry(i);; //the object event has been filled at this point; }; ```. This is the default and recommended way to create an object of the class; `Event. `It will be pointed by `event`. At the following entries, `event` will be overwritte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:38708,variab,variables,38708,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability," is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This exam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33875,variab,variable,33875,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability," is synonymous with the; ``llvm.dbg.value`` IR intrinsic, and is written:. .. code-block:: text. DBG_VALUE $rax, $noreg, !123, !DIExpression(), debug-location !456. The operands to which respectively:. 1. Identifies a machine location such as a register, immediate, or frame index,. 2. Is either $noreg, or immediate value zero if an extra level of indirection is to be added to the first operand,. 3. Identifies a ``DILocalVariable`` metadata node,. 4. Specifies an expression qualifying the variable location, either inline or as a metadata node reference,. While the source location identifies the ``DILocation`` for the scope of the; variable. The second operand (``IsIndirect``) is deprecated and to be deleted.; All additional qualifiers for the variable location should be made through the; expression metadata. .. _instruction-referencing-locations:. Instruction referencing locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This experimental feature aims to separate the specification of variable; *values* from the program point where a variable takes on that value. Changes; in variable value occur in the same manner as ``DBG_VALUE`` meta instructions; but using ``DBG_INSTR_REF``. Variable values are identified by a pair of; instruction number and operand number. Consider the example below:. .. code-block:: text. $rbp = MOV64ri 0, debug-instr-number 1, debug-location !12; DBG_INSTR_REF !123, !DIExpression(DW_OP_LLVM_arg, 0), dbg-instr-ref(1, 0), debug-location !456. Instruction numbers are directly attached to machine instructions with an; optional ``debug-instr-number`` attachment, before the optional; ``debug-location`` attachment. The value defined in ``$rbp`` in the code; above would be identified by the pair ``<1, 0>``. The 3rd operand of the ``DBG_INSTR_REF`` above records the instruction; and operand number ``<1, 0>``, identifying the value defined by the ``MOV64ri``.; The first two operands to ``DBG_INSTR_REF`` are identical to ``DBG_VALUE_LIST``,; and the ``DBG_INSTR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:26591,variab,variable,26591,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,2,['variab'],['variable']
Modifiability," is the one that; contains D, and the initial stack is empty. The location description; result is pushed on the stack. .. note::. This rule avoids having to define how to execute a matched location list; entry operation expression on the same stack as the call when there are; multiple matches. But it allows the call to obtain the location; description for a variable or formal parameter which may use a location; list expression. An alternative is to treat the case when D has a ``DW_AT_location``; attribute that is encoded as a ``loclist`` or ``loclistsptr``, and the; specified location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB implements ``DW_OP_call*`` by always executing E on the same stack.; If the location list has multiple matching entries, it simply picks the; first one and ignores the rest. This seems fundamentally at odds with; the desire to support multiple places for variables. So, it feels like ``DW_OP_call*`` should both support pushing a location; description on the stack for a variable or formal parameter, and also; support being able to execute an operation expression on the same stack.; Being able to specify a different operation expression for different; program locations seems a desirable feature to retain. A solution to that is to ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:77013,variab,variable,77013,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability," is unresponsive with `SIGKILL`).; Defaults to **0 (no timeout)**. dsmgrd.corruptafterfails *n*; : Set this to a number above zero to tell the daemon to mark files as; corrupted after a certain number of either download or verification; failures. A value of **0 (default)** tells the daemon to retry; forever. Configuring the MonALISA monitoring plugin; ------------------------------------------. The Dataset Stager supports generic monitoring plugins. The only plugin; distributed with the stager is the MonALISA monitoring plugin. dsmgrd.notifyplugin */path/to/libafdsmgrd\_notify\_apmon.so*; : Set it to the path of the MonALISA plugin shared object. By default,; notification plugin is disabled. dsmgrd.apmonurl *apmon://apmon.cern.ch*; : This variable tells the ApMon notification plugin how to contact one; or more MonALISA server(s) to activate monitoring via ApMon. It; supports two kinds of URLs:. - `http[s]://host/path/configuration_file.conf` (a remote file; where to fetch the list of servers from). - `apmon://[:password@]monalisahost[:8884]` (a single server to; contact directly). If the variable is not set, yet the plugin is loaded, MonALISA; monitoring is inhibited until a valid configuration variable is; provided. dsmgrd.apmonprefix *MY::CLUSTER::PREFIX*; : Since MonALISA organizes information in ""clusters"" and ""hosts"", here; you can specify what to use as cluster prefix for monitoring; datasets information and daemon status. If this variable is not set,; MonALISA monitoring is inhibited. Please note that the suffix; `_datasets` or `_status` is appended for each of the two types of; monitoring. A sample configuration file; ---------------------------. xpd.stagereqrepo /opt/aaf/var/proof/datasets; dsmgrd.purgenoopds true; dsmgrd.urlregex alien://(.*)$ /storage$1; dsmgrd.sleepsecs 20; dsmgrd.scandseveryloops 30; dsmgrd.parallelxfrs 10; dsmgrd.stagecmd /opt/aaf/bin/af-xrddm-verify.sh ""$URLTOSTAGE"" ""$TREENAME""; dsmgrd.cmdtimeoutsecs 3600; dsmgrd.corruptafterfails 0; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md:5512,variab,variable,5512,proof/doc/confman/DatasetStager.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md,6,"['config', 'plugin', 'variab']","['configuration', 'plugin', 'variable']"
Modifiability," is used to inform LLVM that a stack variable; references an object on the heap and is to be tracked for garbage collection.; The exact impact on generated code is specified by the Function's selected; :ref:`GC strategy <plugin>`. All calls to ``llvm.gcroot`` **must** reside; inside the first basic block. The first argument **must** be a value referring to an alloca instruction or a; bitcast of an alloca. The second contains a pointer to metadata that should be; associated with the pointer, and **must** be a constant or global value; address. If your target collector uses tags, use a null pointer for metadata. A compiler which performs manual SSA construction **must** ensure that SSA; values representing GC references are stored in to the alloca passed to the; respective ``gcroot`` before every call site and reloaded after every call.; A compiler which uses mem2reg to raise imperative code using ``alloca`` into; SSA form need only add a call to ``@llvm.gcroot`` for those variables which; are pointers into the GC heap. It is also important to mark intermediate values with ``llvm.gcroot``. For; example, consider ``h(f(), g())``. Beware leaking the result of ``f()`` in the; case that ``g()`` triggers a collection. Note, that stack variables must be; initialized and marked with ``llvm.gcroot`` in function's prologue. The ``%metadata`` argument can be used to avoid requiring heap objects to have; 'isa' pointers or tag bits. [Appel89_, Goldberg91_, Tolmach94_] If specified,; its value will be tracked along with the location of the pointer in the stack; frame. Consider the following fragment of Java code:. .. code-block:: java. {; Object X; // A null-initialized reference to an object; ...; }. This block (which may be located in the middle of a function or in a loop nest),; could be compiled to this LLVM code:. .. code-block:: llvm. Entry:; ;; In the entry block for the function, allocate the; ;; stack space for X, which is an LLVM pointer.; %X = alloca %Object*. ;; Tell L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:11169,variab,variables,11169,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['variab'],['variables']
Modifiability," is:. # Build an LLVM toolchain with support for Windows Itanium.; # Use the toolchain from step 1. to build libc++, libc++abi, and libunwind. It is also possible to cross-compile from Linux. One method of building the libraries in step 2. is to build them ""stand-alone"".; A stand-alone build doesn't involve the rest of the LLVM tree. The steps are:. * ``cd build-dir``; * ``cmake -DLLVM_PATH=<path to llvm checkout e.g. /llvm-project/> -DCMAKE_INSTALL_PREFIX=<install path> <other options> <path to project e.g. /llvm-project/libcxxabi>``; * ``<make program e.g. ninja>``; * ``<make program> install``. More information on standalone builds can be found in the build documentation for; the respective libraries. The next section discuss the salient options and modifications; required for building and installing the libraries using standalone builds. This assumes; that we are building libunwind and ibc++ as DLLs and statically linking libc++abi into; libc++. Other build configurations are possible, but they are not discussed here. Common CMake configuration options:; -----------------------------------. * ``-D_LIBCPP_ABI_FORCE_ITANIUM'``. Tell the libc++ headers that the Itanium C++ ABI is being used. * ``-DCMAKE_C_FLAGS=""-lmsvcrt -llegacy_stdio_definitions -D_NO_CRT_STDIO_INLINE""``. Supply CRT definitions including stdio definitions that have been removed from the MS VS CRT.; We don't want the stdio functions declared inline as they will cause multiple definition; errors when the same symbols are pulled in from legacy_stdio_definitions.ib. * ``-DCMAKE_INSTALL_PREFIX=<install path>``. Where to install the library and headers. Building libunwind:; -------------------. * ``-DLIBUNWIND_ENABLE_SHARED=ON``; * ``-DLIBUNWIND_ENABLE_STATIC=OFF``. libunwind can be built as a DLL. It is not dependent on other projects. * ``-DLIBUNWIND_USE_COMPILER_RT=OFF``. We use the MS runtime. The CMake files will need to be edited to prevent them adding GNU specific libraries to the link line. Bui",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst:4011,config,configurations,4011,interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,1,['config'],['configurations']
Modifiability," it references is collected, as long as the; ``__block`` variable resides in the heap (either by default or via; ``Block_copy()``). The initial Apple implementation does in fact; start ``__block`` variables on the stack and migrate them to the heap; only as a result of a ``Block_copy()`` operation. It is a runtime error to attempt to assign a reference to a; stack-based Block into any storage marked ``__weak``, including; ``__weak`` ``__block`` variables. C++ Extensions; ==============. Block literal expressions within functions are extended to allow const; use of C++ objects, pointers, or references held in automatic storage. As usual, within the block, references to captured variables become; const-qualified, as if they were references to members of a const; object. Note that this does not change the type of a variable of; reference type. For example, given a class Foo:. .. code-block:: c. Foo foo;; Foo &fooRef = foo;; Foo *fooPtr = &foo;. A Block that referenced these variables would import the variables as; const variations:. .. code-block:: c. const Foo block_foo = foo;; Foo &block_fooRef = fooRef;; Foo *const block_fooPtr = fooPtr;. Captured variables are copied into the Block at the instant of; evaluating the Block literal expression. They are also copied when; calling ``Block_copy()`` on a Block allocated on the stack. In both; cases, they are copied as if the variable were const-qualified, and; it's an error if there's no such constructor. Captured variables in Blocks on the stack are destroyed when control; leaves the compound statement that contains the Block literal; expression. Captured variables in Blocks on the heap are destroyed; when the reference count of the Block drops to zero. Variables declared as residing in ``__block`` storage may be initially; allocated in the heap or may first appear on the stack and be copied; to the heap as a result of a ``Block_copy()`` operation. When copied; from the stack, ``__block`` variables are copied using their ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:11504,variab,variables,11504,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,2,['variab'],['variables']
Modifiability," it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr``,; ``fpsr``, ``svcr`` and ``mte_ctrl``. ::. (lldb) register read cpsr; cpsr = 0x80001000; = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource directory) now uses glob patterns instead of a variant of POSIX; Extended Regular Expression (where ``*`` is tran",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:16892,variab,variable,16892,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['variab'],['variable']
Modifiability, its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 17,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:115957,variab,variable,115957,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability," just define the loop as always returning 0.0. In the; future when we have mutable variables, it will get more useful. As before, let's talk about the changes that we need to Kaleidoscope to; support this. Lexer Extensions for the 'for' Loop; -----------------------------------. The lexer extensions are the same sort of thing as for if/then/else:. .. code-block:: c++. ... in enum Token ...; // control; tok_if = -6, tok_then = -7, tok_else = -8,; tok_for = -9, tok_in = -10. ... in gettok ...; if (IdentifierStr == ""def""); return tok_def;; if (IdentifierStr == ""extern""); return tok_extern;; if (IdentifierStr == ""if""); return tok_if;; if (IdentifierStr == ""then""); return tok_then;; if (IdentifierStr == ""else""); return tok_else;; if (IdentifierStr == ""for""); return tok_for;; if (IdentifierStr == ""in""); return tok_in;; return tok_identifier;. AST Extensions for the 'for' Loop; ---------------------------------. The AST node is just as simple. It basically boils down to capturing the; variable name and the constituent expressions in the node. .. code-block:: c++. /// ForExprAST - Expression class for for/in.; class ForExprAST : public ExprAST {; std::string VarName;; std::unique_ptr<ExprAST> Start, End, Step, Body;. public:; ForExprAST(const std::string &VarName, std::unique_ptr<ExprAST> Start,; std::unique_ptr<ExprAST> End, std::unique_ptr<ExprAST> Step,; std::unique_ptr<ExprAST> Body); : VarName(VarName), Start(std::move(Start)), End(std::move(End)),; Step(std::move(Step)), Body(std::move(Body)) {}. Value *codegen() override;; };. Parser Extensions for the 'for' Loop; ------------------------------------. The parser code is also fairly standard. The only interesting thing here; is handling of the optional step value. The parser code handles it by; checking to see if the second comma is present. If not, it sets the step; value to null in the AST node:. .. code-block:: c++. /// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression; static std::unique_pt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:16875,variab,variable,16875,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability," known retain-agnostic. An expression is :arc-term:`known retain-agnostic` if it is:. * an Objective-C string literal,; * a load from a ``const`` system global variable of :ref:`C retainable pointer; type <arc.misc.c-retainable>`, or; * a null pointer constant. An expression is :arc-term:`known unretained` if it is an rvalue of :ref:`C; retainable pointer type <arc.misc.c-retainable>` and it is:. * a direct call to a function, and either that function has the; ``cf_returns_not_retained`` attribute or it is an :ref:`audited; <arc.misc.c-retainable.audit>` function that does not have the; ``cf_returns_retained`` attribute and does not follow the create/copy naming; convention,; * a message send, and the declared method either has the; ``cf_returns_not_retained`` attribute or it has neither the; ``cf_returns_retained`` attribute nor a :ref:`selector family; <arc.method-families>` that implies a retained result, or; * :when-revised:`[beginning LLVM 3.6]` :revision:`a load from a` ``const``; :revision:`non-system global variable.`. An expression is :arc-term:`known retained` if it is an rvalue of :ref:`C; retainable pointer type <arc.misc.c-retainable>` and it is:. * a message send, and the declared method either has the; ``cf_returns_retained`` attribute, or it does not have the; ``cf_returns_not_retained`` attribute but it does have a :ref:`selector; family <arc.method-families>` that implies a retained result. Furthermore:. * a comma expression is classified according to its right-hand side,; * a statement expression is classified according to its result expression, if; it has one,; * an lvalue-to-rvalue conversion applied to an Objective-C property lvalue is; classified according to the underlying message send, and; * a conditional operator is classified according to its second and third; operands, if they agree in classification, or else the other if one is known; retain-agnostic. If the cast operand is known retained, the conversion is treated as a; ``__bridge_trans",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:27040,variab,variable,27040,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability," leaves after compression; TObjArray fBranches offset= 0 type=61 -> List of Branches of this branch; TObjArray fLeaves offset= 0 type=61 -> List of leaves of this branch; TObjArray fBaskets offset= 0 type=61 -> List of baskets of this branch; Int_t* fBasketBytes offset= 0 type=43 [fMaxBaskets] Length of baskets on file; Int_t* fBasketEntry offset= 0 type=43 [fMaxBaskets] Table of first entry in eack basket; Seek_t* fBasketSeek offset= 0 type=43 [fMaxBaskets] Addresses of baskets on file; TString fFileName offset= 0 type=65 Name of file where buffers are stored ("""" if in same file as Tree header). StreamerInfo for class: TBranchElement, version=7; BASE TBranch offset= 0 type= 0 Branch descriptor; TString fClassName offset= 0 type=65 Class name of referenced object; TString fParentName offset= 0 type=65 Name of parent class; TString fClonesName offset= 0 type=65 Name of class in TClonesArray (if any); Int_t fClassVersion offset= 0 type= 3 Version number of class; Int_t fID offset= 0 type= 3 element serial number in fInfo; Int_t fType offset= 0 type= 3 branch type; Int_t fStreamerType offset= 0 type= 3 branch streamer type; Int_t fMaximum offset= 0 type= 3 Maximum entries for a TClonesArray or variable array; TBranchElement*fBranchCount offset= 0 type=64 pointer to primary branchcount branch; TBranchElement*fBranchCount2 offset= 0 type=64 pointer to secondary branchcount branch. StreamerInfo for class: TLeaf, version=2; BASE TNamed offset= 0 type=67 The basis for a named object (name, title); Int_t fLen offset= 0 type= 3 Number of fixed length elements; Int_t fLenType offset= 0 type= 3 Number of bytes for this data type; Int_t fOffset offset= 0 type= 3 Offset in ClonesArray object (if one); Bool_t fIsRange offset= 0 type=11 (=kTRUE if leaf has a range, kFALSE otherwise); Bool_t fIsUnsigned offset= 0 type=11 (=kTRUE if unsigned, kFALSE otherwise); TLeaf* fLeafCount offset= 0 type=64 Pointer to Leaf count if variable length. StreamerInfo for class: TLeafElement, version=1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/ttree.md:4446,variab,variable,4446,io/doc/TFile/ttree.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/ttree.md,1,['variab'],['variable']
Modifiability," library; sets out to achieve exactly that, exporting to and importing from JSON; and YML. ### Backend. The default backend for this is the `nlohmann` JSON implementation,; which ships with ROOT as a builtin dependency and will import from and; export to JSON. Alternatively, the RapidYAML (`RYML`) implementation; can be used to also import from and export to YML. This implementation; can be selected at compile time with the `cmake` flag; `roofit_hs3_ryml`. ### Usage. The main class providing import from and export to JSON and YML is the; RooJSONFactoryWSTool. ### Open-world philosophy. One of the most challenging aspects of providing serialization and; deserialization for `RooFit` is the fact that `RooFit` follows an; ""open-world"" philosophy with respect to the functions and pdfs it can; handle. Over the years, `RooFit` has also accumulated a significant; number of different pre-implemented functions and pdfs. What is more,; you can easily create your own `RooFit` function by inheriting from; `RooAbsReal` or your own `RooFit` pdf by inheriting from; `RooAbsPdf`. This means that feature-complete serialization and; deserialization to and from JSON and YML will probably never be fully; achieved. However, this may not impede your usage of this library, as; it was written in such a way as to allow users (that is, people like; you) to easily add missing importers and exporters for existing; `RooFit` classes as well as custom implementations you might be using. ### Native and proxy-based importers and exporters. `RooFitHS3` allows to different types of importers and exporters:; *Native* implementations, and *proxy-based* ones. If for a certain; class several implementations are provided, the native; implementation(s) take precedence. ### Writing your own importers and exporters: Proxy-based. Proxy-based implementations can be added very easily and without; actually writing any `C++` code -- you only need to add a short item; to a list in a `JSON` file, namely the; [export k",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md:1664,inherit,inheriting,1664,roofit/doc/developers/roofit_hs3.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md,2,['inherit'],['inheriting']
Modifiability," load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; is useful to be able to control whether certain things in your pass; happen or not. For example, there are times the minimization tooling; can only easily give you large testcases. You would like to narrow; your bug down to a specific transformation happening or not happening,; automatically, using bisection. This is where debug counters help.; They provide a framework for making parts of your code only execute a; certain number of times. The ``llvm/Support/DebugCounter.h`` (`doxygen; <https://llvm.org/doxygen/DebugCounter_8h_source.html>`__) file; provides a class named ``DebugCounter`` that can be used to create; command line counter options that control execution of parts of your code. Define your DebugCounter like this:. .. code-block:: c++. DEBUG",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:49633,maintainab,maintainable,49633,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['maintainab'],['maintainable']
Modifiability," location description in the target architecture default address; space:. If a stack entry is required to be a location description, but is a value V; with an integral type, then it is implicitly converted to a location; description L with a one memory location description SL. If the type size of; V is less than the generic type size, then the value V is zero extended to; the size of the generic type. The least significant generic type size bits; are treated as an unsigned value to be used as an address A. SL specifies; memory location storage corresponding to the target architecture default; address space with a bit offset equal to A scaled by 8 (the byte size). The implicit conversion could also be defined as target architecture specific.; For example, GDB checks if V is an integral type. If it is not it gives an; error. Otherwise, GDB zero-extends V to 64 bits. If the GDB target defines a; hook function, then it is called. The target specific hook function can modify; the 64-bit value, possibly sign extending based on the original value type.; Finally, GDB treats the 64-bit value V as a memory location address. If a stack entry is required to be a location description, but it is an implicit; pointer value IPV with the target architecture default address space, then it is; implicitly converted to a location description with one single location; description specified by IPV. See; :ref:`amdgpu-dwarf-implicit-location-description-operations`. .. note::. Is this rule required for DWARF Version 5 backwards compatibility? If not, it; can be eliminated, and the producer can use; ``DW_OP_LLVM_form_aspace_address``. If a stack entry is required to be a value, but it is a location description L; with one memory location description SL in the target architecture default; address space with a bit offset B that is a multiple of 8, then it is implicitly; converted to a value equal to B divided by 8 (the byte size) with the generic; type. 1. ``DW_OP_addr``. ``DW_OP_addr`` has a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:107780,extend,extending,107780,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extending']
Modifiability," locations applies. Rules for updating debug values; ===============================. Deleting an IR-level Instruction; --------------------------------. When an ``Instruction`` is deleted, its debug uses change to ``undef``. This is; a loss of debug info: the value of one or more source variables becomes; unavailable, starting with the ``llvm.dbg.value(undef, ...)``. When there is no; way to reconstitute the value of the lost instruction, this is the best; possible outcome. However, it's often possible to do better:. * If the dying instruction can be RAUW'd, do so. The; ``Value::replaceAllUsesWith`` API transparently updates debug uses of the; dying instruction to point to the replacement value. * If the dying instruction cannot be RAUW'd, call ``llvm::salvageDebugInfo`` on; it. This makes a best-effort attempt to rewrite debug uses of the dying; instruction by describing its effect as a ``DIExpression``. * If one of the **operands** of a dying instruction would become trivially; dead, use ``llvm::replaceAllDbgUsesWith`` to rewrite the debug uses of that; operand. Consider the following example function:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %b = sext i16 %a to i32; %c = and i32 %b, 15; call void @llvm.dbg.value(metadata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, theSimplifiedAndInstruction, ...). This results in better debug info because the debug use of ``%c`` is preserved:. .. code-block:: llvm. define i1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:7443,rewrite,rewrite,7443,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['rewrite'],['rewrite']
Modifiability," main.o"",; ""file"": ""main.cpp""; }; ]. The `invocation list`:. .. code-block:: bash. ""/path/to/your/project/foo.cpp"":; - ""clang++""; - ""-c""; - ""/path/to/your/project/foo.cpp""; - ""-o""; - ""/path/to/your/project/foo.o"". ""/path/to/your/project/main.cpp"":; - ""clang++""; - ""-c""; - ""/path/to/your/project/main.cpp""; - ""-o""; - ""/path/to/your/project/main.o"". We'd like to analyze `main.cpp` and discover the division by zero bug.; As we are using On-demand mode, we only need to create a CTU index file which holds the `USR` name and location of; external definitions in the source files in format `<USR-Length>:<USR> <File-Path>`:. .. code-block:: bash. $ clang-extdef-mapping -p . foo.cpp; 9:c:@F@foo# /path/to/your/project/foo.cpp; $ clang-extdef-mapping -p . foo.cpp > externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-config -Xclang ctu-invocation-list=invocations.yaml \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.cpp main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:9384,config,config,9384,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,2,['config'],['config']
Modifiability," make the variable; mutable again and cause the loop to retain the objects it encounters. .. _arc.misc.blocks:. Blocks; ------. The implicit ``const`` capture variables created when evaluating a block; literal expression have the same ownership semantics as the local variables; they capture. The capture is performed by reading from the captured variable; and initializing the capture variable with that value; the capture variable is; destroyed when the block literal is, i.e. at the end of the enclosing scope. The :ref:`inference <arc.ownership.inference>` rules apply equally to; ``__block`` variables, which is a shift in semantics from non-ARC, where; ``__block`` variables did not implicitly retain during capture. ``__block`` variables of retainable object owner type are moved off the stack; by initializing the heap copy with the result of moving from the stack copy. With the exception of retains done as part of initializing a ``__strong``; parameter variable or reading a ``__weak`` variable, whenever these semantics; call for retaining a value of block-pointer type, it has the effect of a; ``Block_copy``. The optimizer may remove such copies when it sees that the; result is used only as an argument to a call. When a block pointer type is converted to a non-block pointer type (such as; ``id``), ``Block_copy`` is called. This is necessary because a block allocated; on the stack won't get copied to the heap when the non-block pointer escapes.; A block pointer is implicitly converted to ``id`` when it is passed to a; function as a variadic argument. .. _arc.misc.exceptions:. Exceptions; ----------. By default in Objective C, ARC is not exception-safe for normal releases:. * It does not end the lifetime of ``__strong`` variables when their scopes are; abnormally terminated by an exception.; * It does not perform releases which would occur at the end of a; full-expression if that full-expression throws an exception. A program may be compiled with the option ``-fobjc-arc-e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:97029,variab,variable,97029,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['variab'],['variable']
Modifiability," manual runs through a simple CommandLine'ification of a; basic compiler tool. This is intended to show you how to jump into using the; CommandLine library in your own program, and show you some of the cool things it; can do. To start out, you need to include the CommandLine header file into your program:. .. code-block:: c++. #include ""llvm/Support/CommandLine.h"". Additionally, you need to add this as the first line of your main program:. .. code-block:: c++. int main(int argc, char **argv) {; cl::ParseCommandLineOptions(argc, argv);; ...; }. ... which actually parses the arguments and fills in the variable declarations. Now that you are ready to support command line arguments, we need to tell the; system which ones we want, and what type of arguments they are. The CommandLine; library uses a declarative syntax to model command line arguments with the; global variable declarations that capture the parsed values. This means that; for every command line option that you would like to support, there should be a; global variable declaration to capture the result. For example, in a compiler,; we would like to support the Unix-standard '``-o <filename>``' option to specify; where to put the output. With the CommandLine library, this is represented like; this:. .. _scalars arguments:; .. _here:. .. code-block:: c++. cl::opt<string> OutputFilename(""o"", cl::desc(""Specify output filename""), cl::value_desc(""filename""));. This declares a global variable ""``OutputFilename``"" that is used to capture the; result of the ""``o``"" argument (first parameter). We specify that this is a; simple scalar option by using the ""``cl::opt``"" template (as opposed to the; ""``cl::list``"" template), and tell the CommandLine library that the data; type that we are parsing is a string. The second and third parameters (which are optional) are used to specify what to; output for the ""``-help``"" option. In this case, we get a line that looks like; this:. ::. USAGE: compiler [options]. OPTIONS:; -h - Alia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:4725,variab,variable,4725,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability," matches using Base<T>::Foo ; Matcher<Decl>unresolvedUsingValueDeclMatcher<UnresolvedUsingValueDecl>...; Matches unresolved using value declarations. Given; template<typename X>; class C : private X {; using X::x;; };; unresolvedUsingValueDecl(); matches using X::x ; Matcher<Decl>usingDeclMatcher<UsingDecl>...; Matches using declarations. Given; namespace X { int x; }; using X::x;; usingDecl(); matches using X::x ; Matcher<Decl>usingDirectiveDeclMatcher<UsingDirectiveDecl>...; Matches using namespace declarations. Given; namespace X { int x; }; using namespace X;; usingDirectiveDecl(); matches using namespace X ; Matcher<Decl>usingEnumDeclMatcher<UsingEnumDecl>...; Matches using-enum declarations. Given; namespace X { enum x {...}; }; using enum X::x;; usingEnumDecl(); matches using enum X::x ; Matcher<Decl>valueDeclMatcher<ValueDecl>...; Matches any value declaration. Example matches A, B, C and F; enum X { A, B, C };; void F();. Matcher<Decl>varDeclMatcher<VarDecl>...; Matches variable declarations. Note: this does not match declarations of member variables, which are; ""field"" declarations in Clang parlance. Example matches a; int a;. Matcher<LambdaCapture>lambdaCaptureMatcher<LambdaCapture>...; Matches lambda captures. Given; int main() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher `lambdaExpr(hasAnyCapture(lambdaCapture()))`,; `lambdaCapture()` matches `x` and `x=1`. Matcher<NestedNameSpecifierLoc>nestedNameSpecifierLocMatcher<NestedNameSpecifierLoc>...; Same as nestedNameSpecifier but matches NestedNameSpecifierLoc. Matcher<NestedNameSpecifier>nestedNameSpecifierMatcher<NestedNameSpecifier>...; Matches nested name specifiers. Given; namespace ns {; struct A { static void f(); };; void A::f() {}; void g() { A::f(); }; }; ns::A a;; nestedNameSpecifier(); matches ""ns::"" and both ""A::"". Matcher<OMPClause>ompDefaultClauseMatcher<OMPDefaultClause>...; Matches OpenMP ``default`` clause. Given. #pragma omp parallel default(none); #pragma omp pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:19930,variab,variable,19930,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability," matching '{}'; but does not match 'void f();'. Matcher<DoStmt>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. Matcher<ElaboratedTypeLoc>hasNamedTypeLocMatcher<TypeLoc> InnerMatcher; Matches elaborated `TypeLoc`s that have a named `TypeLoc` matching; `InnerMatcher`. Given; template <typename T>; class C {};; class C<int> c;. class D {};; class D d;; elaboratedTypeLoc(hasNamedTypeLoc(templateSpecializationTypeLoc()));; matches the `TypeLoc` of the variable declaration of `c`, but not `d`. Matcher<ElaboratedType>hasQualifierMatcher<NestedNameSpecifier> InnerMatcher; Matches ElaboratedTypes whose qualifier, a NestedNameSpecifier,; matches InnerMatcher if the qualifier exists. Given; namespace N {; namespace M {; class D {};; }; }; N::M::D d;. elaboratedType(hasQualifier(hasPrefix(specifiesNamespace(hasName(""N"")))); matches the type of the variable declaration of d. Matcher<ElaboratedType>namesTypeMatcher<QualType> InnerMatcher; Matches ElaboratedTypes whose named type matches InnerMatcher. Given; namespace N {; namespace M {; class D {};; }; }; N::M::D d;. elaboratedType(namesType(recordType(; hasDeclaration(namedDecl(hasName(""D"")))))) matches the type of the variable; declaration of d. Matcher<EnumType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; clas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:190202,variab,variable,190202,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability," may be a mixture of; memory, registers, or even implicit values. See ``DW_OP_push_object_address`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.8 General Support for Address Spaces; --------------------------------------. AMDGPU needs to be able to describe addresses that are in different kinds of; memory. Optimized code may need to describe a variable that resides in pieces; that are in different kinds of storage which may include parts of registers,; memory that is in a mixture of memory kinds, implicit values, or be undefined. DWARF has the concept of segment addresses. However, the segment cannot be; specified within a DWARF expression, which is only able to specify the offset; portion of a segment address. The segment index is only provided by the entity; that specifies the DWARF expression. Therefore, the segment index is a property; that can only be put on complete objects, such as a variable. That makes it only; suitable for describing an entity (such as variable or subprogram code) that is; in a single kind of memory. AMDGPU uses multiple address spaces. For example, a variable may be allocated in; a register that is partially spilled to the call stack which is in the private; address space, and partially spilled to the local address space. DWARF mentions; address spaces, for example as an argument to the ``DW_OP_xderef*`` operations.; A new section that defines address spaces is added (see; :ref:`amdgpu-dwarf-address-spaces`). A new attribute ``DW_AT_LLVM_address_space`` is added to pointer and reference; types (see :ref:`amdgpu-dwarf-type-modifier-entries`). This allows the compiler; to specify which address space is being used to represent the pointer or; reference type. DWARF uses the concept of an address in many expression operations but does not; define how it relates to address spaces. For example,; ``DW_OP_push_object_address`` pushes the address of an object. Other contexts; implicitly push an address on the stack before eval",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:17614,variab,variable,17614,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability," mechanism, a client creates metadata nodes with two elements:. 1. a byte offset into the global (generally zero for functions); 2. a metadata object representing an identifier for the type. These metadata nodes are associated with globals by using global object; metadata attachments with the ``!type`` metadata kind. Each type identifier must exclusively identify either global variables; or functions. .. admonition:: Limitation. The current implementation only supports attaching metadata to functions on; the x86-32 and x86-64 architectures. An intrinsic, :ref:`llvm.type.test <type.test>`, is used to test whether a; given pointer is associated with a type identifier. .. _control flow integrity: https://clang.llvm.org/docs/ControlFlowIntegrity.html. Representing Type Information using Type Metadata; =================================================. This section describes how Clang represents C++ type information associated with; virtual tables using type metadata. Consider the following inheritance hierarchy:. .. code-block:: c++. struct A {; virtual void f();; };. struct B : A {; virtual void f();; virtual void g();; };. struct C {; virtual void h();; };. struct D : A, C {; virtual void f();; virtual void h();; };. The virtual table objects for A, B, C and D look like this (under the Itanium ABI):. .. csv-table:: Virtual Table Layout for A, B, C, D; :header: Class, 0, 1, 2, 3, 4, 5, 6. A, A::offset-to-top, &A::rtti, &A::f; B, B::offset-to-top, &B::rtti, &B::f, &B::g; C, C::offset-to-top, &C::rtti, &C::h; D, D::offset-to-top, &D::rtti, &D::f, &D::h, D::offset-to-top, &D::rtti, thunk for &D::h. When an object of type A is constructed, the address of ``&A::f`` in A's; virtual table object is stored in the object's vtable pointer. In ABI parlance; this address is known as an `address point`_. Similarly, when an object of type; B is constructed, the address of ``&B::f`` is stored in the vtable pointer. In; this way, the vtable in B's virtual table object is compatible wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst:1549,inherit,inheritance,1549,interpreter/llvm-project/llvm/docs/TypeMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst,1,['inherit'],['inheritance']
Modifiability," member; functions. 45. **`tree->Draw(""This->GetReadEntry()"");`**. You can refer to the tree (or chain) containing the data by using the; string '`This`'. You can also call any **`TTree`** methods. Next example; will display the name of the first '`user info`' object:. `tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");`. 46. **`tree->Draw(""mybr.mystring"");`**. **`TString`** and `std::string` object are plotted directly. The example; 45 draws the same results - i.e. an histogram whose labels are the; string value of '`mystring`':. `tree->Draw(""mybr.mystring.c_str()"");`. or. `tree->Draw(""mybr.mytstring.Data()"");`. 47. **`tree->Draw(""myTimeStamp"");`**. You can plot plot objects of any class which has either `AsDouble` or; `AsString` (`AsDouble` has priority). For such a class (for example; **`TTimeStamp`**), the line 46 will plot the same as:. `tree->Draw(""myTimeStamp.AsDouble"");`. `AsString` can be returning either a `char*`, or a **`TString`** or an; `std::string`. ### Multiple variables visualisation. This section presents the visualization technique available in ROOT; to represent multiple variables (>4) data sets. #### Spider (Radar) Plots. Spider plots (sometimes called “web-plots” or “radar plots”) are used; to compare series of data points (events). They use the human ability; to spot un-symmetry. ![Example of spider plot.](pictures/spider1.png). Variables are represented on individual axes displayed along a circle.; For each variable the minimum value sits on the circle’s center, and; the maximum on the circle’s radius. Spider plots are not suitable for; an accurate graph reading since, by their nature, it can be difficult; to read out very detailed values, but they give quickly a global view; of an event in order to compare it with the others. In ROOT the spider; plot facility is accessed from the tree viewer GUI. The variables to; be visualized are selected in the tree viewer and can be scanned using; the spider plot button. ![The tree viewer Graphical Us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:93977,variab,variables,93977,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability," might be a; better fit for your project. Second, Clang implements many MSVC language extensions, such as; ``__declspec(dllexport)`` and a handful of pragmas. These are typically; controlled by ``-fms-extensions``. Third, MSVC accepts some C++ code that Clang will typically diagnose as; invalid. When these constructs are present in widely included system headers,; Clang attempts to recover and continue compiling the user's program. Most; parsing and semantic compatibility tweaks are controlled by; ``-fms-compatibility`` and ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interesting; and distinct mangling. Fortunately, incorrect manglings usually do not result; in runtime errors. Non-inline functions with incorrect manglings usually; result in link errors, which are relatively easy to diagnose. Incorrect; manglings for inline functions and templates result in multiple copies in the; final image. The C++ standard requires that those addresses be equal, but few; programs rely on this. * Member pointers: :good:`Mostly complete`. Standard C++ member pointers are; fully implemented and should be ABI compatible. Both `#pragma; pointers_to_members`_ and the `/vm`_ flags are supported. However, MSVC; supports",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:1799,inherit,inheritance,1799,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,3,['inherit'],['inheritance']
Modifiability," minimizer to use ##. One of the historically interesting advantages of M is that it was; probably the first minimization program to offer the user a choice of; several minimization algorithms. This could be taken as a reflection of; the fact that none of the algorithms known at that time were good enough; to be universal, so users were encouraged to find the one that worked; best for them. Since then, algorithms have improved considerably, but M; still offers several, mostly so that old users will not feel cheated,; but also to help the occasional user who does manage to defeat the best; algorithms. M currently offers four applications which can be used to; find a smaller function value, in addition to $\mbox{MINOS}$, which; will retain a smaller function value if it stumbles on one unexpectedly.; The objects which can be used to minimize are:. ### $\mbox{MIGRAD}$ ###. This is the best minimizer for nearly all functions. It is a; variable-metric method with inexact line search, a stable metric; updating scheme, and checks for positive-definiteness. It will run; faster if you instantiate it with a low–level MnStrategy and will be; more reliable if you instantiate it with a high–level MnStrategy; (although the latter option may not help much). Its main weakness is; that it depends heavily on knowledge of the first derivatives, and fails; miserably if they are very inaccurate. If first derivatives are a; problem, they can be calculated analytically inside $\mbox{FCN}$; (see [howto:fcn]) or if this is not feasible, the user can try to; improve the accuracy of M 's numerical approximation by adjusting values; of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and; [api:strategy]). ### $\mbox{MINIMIZE}$ ###. This is equivalent to $\mbox{MIGRAD}$, except that if; $\mbox{MIGRAD}$ fails, it reverts to $\mbox{SIMPLEX}$ and then; calls $\mbox{MIGRAD}$ again. ### $\mbox{SCAN}$ ###. This is not intended to minimize, and just scans the function, one; parameter at a time. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:61006,variab,variable-metric,61006,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable-metric']
Modifiability," mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core clang tool, it will; live in the ``clang-tools-extra`` repository. .. code-block:: console. cd ~/clang-llvm/llvm-project; mkdir clang-tools-extra/loop-convert; echo 'add_subdirectory(loop-convert)' >> clang-tools-extra/CMakeLists.txt; vim c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:2048,config,configuring,2048,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['config'],['configuring']
Modifiability," model of global variables can now be overridden by means of the newly; added LLVM IR attribute, ``code_model``.; * Added support for the ``llvm.is.fpclass`` intrinsic.; * ``mulodi4`` and ``muloti4`` libcalls were disabled due to absence in libgcc.; * Added initial support for auto vectorization.; * Added initial support for linker relaxation.; * Assorted codegen improvements. Changes to the MIPS Backend; ---------------------------. Changes to the PowerPC Backend; ------------------------------. * LLJIT's JIT linker now defaults to JITLink on 64-bit ELFv2 targets.; * Initial-exec TLS model is supported on AIX.; * Implemented new resource based scheduling model of POWER7 and POWER8.; * ``frexp`` libcall now references correct symbol name for ``fp128``.; * Optimized materialization of 64-bit immediates, code generation of; ``vec_promote`` and atomics.; * Global constant strings are pooled in the TOC under one entry to reduce the; number of entries in the TOC.; * Added a number of missing Power10 extended mnemonics.; * Added the SCV instruction.; * Fixed register class for the paddi instruction.; * Optimize VPERM and fix code order for swapping vector operands on LE.; * Added various bug fixes and code gen improvements. AIX Support/improvements:. * Support for a non-TOC-based access sequence for the local-exec TLS model (called small local-exec).; * XCOFF toc-data peephole optimization and bug fixes.; * Move less often used __ehinfo TOC entries to the end of the TOC section.; * Fixed problems when the AIX libunwind unwinds starting from a signal handler; and the function that raised the signal happens to be a leaf function that; shares the stack frame with its caller or a leaf function that does not store; the stack frame backchain. Changes to the RISC-V Backend; -----------------------------. * The Zfa extension version was upgraded to 1.0 and is no longer experimental.; * Zihintntl extension version was upgraded to 1.0 and is no longer experimental.; * Intrinsics wer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:6005,extend,extended,6005,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['extend'],['extended']
Modifiability," modules, we should handle this more automatically.; if (DEFINED LLVM_OVERRIDE_MODEL_HEADER_INLINERSIZEMODEL); set(LLVM_INLINER_MODEL_PATH ""none""); elseif(NOT DEFINED LLVM_INLINER_MODEL_PATH; OR ""${LLVM_INLINER_MODEL_PATH}"" STREQUAL """"; OR ""${LLVM_INLINER_MODEL_PATH}"" STREQUAL ""autogenerate""); set(LLVM_INLINER_MODEL_PATH ""autogenerate""); set(LLVM_INLINER_MODEL_AUTOGENERATED 1); endif(); if (DEFINED LLVM_OVERRIDE_MODEL_HEADER_REGALLOCEVICTMODEL); set(LLVM_RAEVICT_MODEL_PATH ""none""); elseif(NOT DEFINED LLVM_RAEVICT_MODEL_PATH; OR ""${LLVM_RAEVICT_MODEL_PATH}"" STREQUAL """"; OR ""${LLVM_RAEVICT_MODEL_PATH}"" STREQUAL ""autogenerate""); set(LLVM_RAEVICT_MODEL_PATH ""autogenerate""); set(LLVM_RAEVICT_MODEL_AUTOGENERATED 1); endif(). endif(). # Configure the three LLVM configuration header files.; configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/config.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/config.h); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/llvm-config.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/llvm-config.h); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/abi-breaking.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/abi-breaking.h). # Add target for generating source rpm package.; set(LLVM_SRPM_USER_BINARY_SPECFILE ${CMAKE_CURRENT_SOURCE_DIR}/llvm.spec.in; CACHE FILEPATH "".spec file to use for srpm generation""); set(LLVM_SRPM_BINARY_SPECFILE ${CMAKE_CURRENT_BINARY_DIR}/llvm.spec); set(LLVM_SRPM_DIR ""${CMAKE_CURRENT_BINARY_DIR}/srpm""). get_source_info(${CMAKE_CURRENT_SOURCE_DIR} revision repository); string(LENGTH ""${revision}"" revision_length); set(LLVM_RPM_SPEC_REVISION ""${revision}""). configure_file(; ${LLVM_SRPM_USER_BINARY_SPECFILE}; ${LLVM_SRPM_BINARY_SPECFILE} @ONLY). add_custom_target(srpm; COMMAND cpack -G TGZ --config CPackSourceConfig.cmake -B ${LLVM_SRPM_DIR}/SOURCES; COMMAND rpmbuild -bs --define '_topdir ${LLVM_SRPM_DIR}' ${LLVM_SRPM_BINARY_SPECFILE}); set_target_properties(srpm PROPERTIES FOLDER ""Misc""). if(APPLE AND DARWIN_LTO_LIBRARY); set(CMAKE_E",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:45084,config,config,45084,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config']
Modifiability," more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files).",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4171,config,configures,4171,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['configures']
Modifiability," must agree). If a new patch; does not address all outstanding feedback, the author should explicitly state; that when providing the updated patch. When using the web-based code-review; tool, such notes can be provided in the ""Diff"" description (which is different; from the description of the ""Differential Revision"" as a whole used for the; commit message). If you suggest changes in a code review, but don't wish the suggestion to be; interpreted this strongly, please state so explicitly. Aim to Make Efficient Use of Everyone's Time; --------------------------------------------. Aim to limit the number of iterations in the review process. For example, when; suggesting a change, if you want the author to make a similar set of changes at; other places in the code, please explain the requested set of changes so that; the author can make all of the changes at once. If a patch will require; multiple steps prior to approval (e.g., splitting, refactoring, posting data; from specific performance tests), please explain as many of these up front as; possible. This allows the patch author and reviewers to make the most efficient; use of their time. LGTM - How a Patch Is Accepted; ------------------------------. A patch is approved to be committed when a reviewer accepts it, and this is; almost always associated with a message containing the text ""LGTM"" (which; stands for Looks Good To Me). Only approval from a single reviewer is required. When providing an unqualified LGTM (approval to commit), it is the; responsibility of the reviewer to have reviewed all of the discussion and; feedback from all reviewers ensuring that all feedback has been addressed and; that all other reviewers will almost surely be satisfied with the patch being; approved. If unsure, the reviewer should provide a qualified approval, (e.g.,; ""LGTM, but please wait for @someone, @someone_else""). You may also do this if; you are fairly certain that a particular community member will wish to review,; even if th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:6196,refactor,refactoring,6196,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['refactor'],['refactoring']
Modifiability," must have ::ref:`vector type <t_vector>` with an; element type that matches the ``splat`` operand.; **Zero initialization**; The string '``zeroinitializer``' can be used to zero initialize a; value to zero of *any* type, including scalar and; :ref:`aggregate <t_aggregate>` types. This is often used to avoid; having to print large zero initializers (e.g. for large arrays) and; is always exactly equivalent to using explicit zero initializers.; **Metadata node**; A metadata node is a constant tuple without types. For example:; ""``!{!0, !{!2, !0}, !""test""}``"". Metadata can reference constant values,; for example: ""``!{!0, i32 0, ptr @global, ptr @function, !""str""}``"".; Unlike other typed constants that are meant to be interpreted as part of; the instruction stream, metadata is a place to attach additional; information such as debug info. Global Variable and Function Addresses; --------------------------------------. The addresses of :ref:`global variables <globalvars>` and; :ref:`functions <functionstructure>` are always implicitly valid; (link-time) constants. These constants are explicitly referenced when; the :ref:`identifier for the global <identifiers>` is used and always have; :ref:`pointer <t_pointer>` type. For example, the following is a legal LLVM; file:. .. code-block:: llvm. @X = global i32 17; @Y = global i32 42; @Z = global [2 x ptr] [ ptr @X, ptr @Y ]. .. _undefvalues:. Undefined Values; ----------------. The string '``undef``' can be used anywhere a constant is expected, and; indicates that the user of the value may receive an unspecified; bit-pattern. Undefined values may be of any type (other than '``label``'; or '``void``') and be used anywhere a constant is permitted. .. note::. A '``poison``' value (described in the next section) should be used instead of; '``undef``' whenever possible. Poison values are stronger than undef, and; enable more optimizations. Just the existence of '``undef``' blocks certain; optimizations (see the examples below). Und",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:190265,variab,variables,190265,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability," mutually exclusive to the existing local storage; qualifiers auto, register, and static. [testme] Variables qualified by; ``__block`` act as if they were in allocated storage and this storage; is automatically recovered after last use of said variable. An; implementation may choose an optimization where the storage is; initially automatic and only ""moved"" to allocated (heap) storage upon; a Block_copy of a referencing Block. Such variables may be mutated as; normal variables are. In the case where a ``__block`` variable is a Block one must assume; that the ``__block`` variable resides in allocated storage and as such; is assumed to reference a Block that is also in allocated storage; (that it is the result of a ``Block_copy`` operation). Despite this; there is no provision to do a ``Block_copy`` or a ``Block_release`` if; an implementation provides initial automatic storage for Blocks. This; is due to the inherent race condition of potentially several threads; trying to update the shared variable and the need for synchronization; around disposing of older values and copying new ones. Such; synchronization is beyond the scope of this language specification. Control Flow; ============. The compound statement of a Block is treated much like a function body; with respect to control flow in that goto, break, and continue do not; escape the Block. Exceptions are treated *normally* in that when; thrown they pop stack frames until a catch clause is found. Objective-C Extensions; ======================. Objective-C extends the definition of a Block reference type to be; that also of id. A variable or expression of Block type may be; messaged or used as a parameter wherever an id may be. The converse is; also true. Block references may thus appear as properties and are; subject to the assign, retain, and copy attribute logic that is; reserved for objects. All Blocks are constructed to be Objective-C objects regardless of; whether the Objective-C runtime is operational in the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:8141,variab,variable,8141,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variable']
Modifiability," my-monorepo/submodule-map.txt; echo ""tools/lldb lldb"" >> my-monorepo/submodule-map.txt; echo ""projects/openmp openmp"" >> my-monorepo/submodule-map.txt; echo ""tools/polly polly"" >> my-monorepo/submodule-map.txt; echo ""projects/myproj local/myproj"" >> my-monorepo/submodule-map.txt. # Rewrite history; (; cd my-monorepo; zip-downstream-fork.py \; refs/remotes/umbrella \; --new-repo-prefix=refs/remotes/upstream/monorepo \; --old-repo-prefix=refs/remotes/upstream/split \; --revmap-in=monorepo-map.txt \; --revmap-out=zip-map.txt \; --subdir=llvm \; --submodule-map=submodule-map.txt \; --update-tags; ). # Create the zip branch (assuming umbrella main is wanted).; git -C my-monorepo branch --no-track local/zip/main refs/remotes/umbrella/main. Comments at the top of ``zip-downstream-fork.py`` describe in more; detail how the tool works and various implications of its operation. Importing local repositories; ----------------------------. You may have additional repositories that integrate with the LLVM; ecosystem, essentially extending it with new tools. If such; repositories are tightly coupled with LLVM, it may make sense to; import them into your local mirror of the monorepo. If such repositories participated in the umbrella repository used; during the zipping process above, they will automatically be added to; the monorepo. For downstream repositories that don't participate in; an umbrella setup, the ``import-downstream-repo.py`` tool at; https://github.com/greened/llvm-git-migration/tree/import can help with; getting them into the monorepo. A recipe follows::. # Import downstream repo history into the monorepo.; git -C my-monorepo remote add myrepo https://my.local.mirror.org/myrepo.git; git fetch myrepo. my_local_tags=( refs/tags/release; refs/tags/hotfix ). (; cd my-monorepo; import-downstream-repo.py \; refs/remotes/myrepo \; ${my_local_tags[@]} \; --new-repo-prefix=refs/remotes/upstream/monorepo \; --subdir=myrepo \; --tag-prefix=""myrepo-""; ). # Preserve release branc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:34524,extend,extending,34524,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['extend'],['extending']
Modifiability," mystical process! Now that you've seen some of; the basics, I strongly encourage you to take the code and hack on it.; For example, try adding:. - **global variables** - While global variables have questionable value; in modern software engineering, they are often useful when putting; together quick little hacks like the Kaleidoscope compiler itself.; Fortunately, our current setup makes it very easy to add global; variables: just have value lookup check to see if an unresolved; variable is in the global variable symbol table before rejecting it.; To create a new global variable, make an instance of the LLVM; ``GlobalVariable`` class.; - **typed variables** - Kaleidoscope currently only supports variables; of type double. This gives the language a very nice elegance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard"". As you extend the language to add higher-level; constructs, often these constructs make the most sense if they are; lowered to calls into a language-supplied runtime. For example, if; you add hash tables to the language, it would probably make sense to; add the routines to a runtime, instead of inlining them ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:2184,variab,variable,2184,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,2,['variab'],['variable']
Modifiability," name; (:token:`TokIdentifier`). The specified type must be ``list<``\ *class*\ ``>``, where *class* is some; record class. The ``defset`` statement establishes a scope for its; statements. It is an error to define a record in the scope of the; ``defset`` that is not of type *class*. The ``defset`` statement can be nested. The inner ``defset`` adds the; records to its own set, and all those records are also added to the outer; set. Anonymous records created inside initialization expressions using the; ``ClassID<...>`` syntax are not collected in the set. ``defvar`` --- define a variable; --------------------------------. A ``defvar`` statement defines a global variable. Its value can be used; throughout the statements that follow the definition. .. productionlist::; Defvar: ""defvar"" `TokIdentifier` ""="" `Value` "";"". The identifier on the left of the ``=`` is defined to be a global variable; whose value is given by the value expression on the right of the ``=``. The; type of the variable is automatically inferred. Once a variable has been defined, it cannot be set to another value. Variables defined in a top-level ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1);. Variables can also be defined with ``defvar`` in a record body. See; `Defvar in a Record Body`_ for more details. ``foreach`` --- iterate over a sequence of statements; -----------------------------------------------------. The ``foreach`` statement iterates over a series of statements, varying a; variable over a sequence of values. .. productionlist::; Foreach: ""foreach"" `ForeachIterator` ""in"" ""{"" `Statement`* ""}""; :| ""foreach"" `ForeachIterator` ""in"" `Statement`; ForeachIterator: `TokIdentifier` ""="" (""{"" `RangeList` ""}"" | `RangePiece` | `Value`). The body of the ``foreach`` is a series of statements in braces or a; single statement with no braces. The stateme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:45131,variab,variable,45131,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability," necessary to; provide the location of the source files manually using the static RooWorkspace; member functions addClassDeclImportDir() and addClassImplImportDir().; ; When a TFile with a RooWorkspace containing source code is opened in a ROOT; session that does not have the class code already loaded for the classes; contained in the workspace, the code in the workspace is written to file,; compiled and loaded into the ROOT session on the fly. The code repository of RooWorkspace is designed to handle classes that; have either their own implementation and header file, or are part of a group; of classes that share a common header and implementation file. More complicated; structuring of source code into files is not supported. ; ; Also new accessors have been added for discrete-valued functions catfunc(); and stored category functions are now also printed under their own heading in Print(); Parameterized ranges. It is now possible to use RooAbsReal derived functions as range definition for variables; to construct ranges that vary as function of another variable. For example. RooRealVar x(""x"",""x"",-10,10) ; // variable with fixed range [-10,10] ; RooRealVar y(""y"",""y"",0,20) ; // variable with fixed range [-10,10] ; ; RooFormulaVar x_lo(""x_lo"",""y-20"",y) ; ; RooFormulaVar x_hi(""x_hi"",""sin(y)*5"",y) ; ; x.setRange(x_lo,x_hi) ; // Change x to have variable range depending on y; ; It is also possible to define parameterized named ranges in the same way. x.setRange(""signalRegion"",x_lo,x_hi) ;. There are no fundamental limits to the complexity of the parameterized ranges; that can be defined as long as the problem is uniquely defined. For example, given three observables ; x, y and z, one can define a parameterized named range 'R' of x in terms of y and of y in terms of z; and ask to calculate the three dimensional integral of any function or p.d.f in terms of (x,y,z); over that range 'R' and it will be calculated correctly, taking recursive range dependencies into; account. A d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:3263,variab,variables,3263,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,2,['variab'],"['variable', 'variables']"
Modifiability," need to be done once. After; you have the suite checked out and configured, you don't need to do it; again (unless the test code or configure script changes). Configuring External Tests; ==========================. In order to run the External tests in the ``test-suite`` module, you; must specify *--with-externals*. This must be done during the; *re-configuration* step (see above), and the ``llvm`` re-configuration; must recognize the previously-built ``llvm-gcc``. If any of these is; missing or neglected, the External tests won't work. * *--with-externals*. * *--with-externals=<directory>*. This tells LLVM where to find any external tests. They are expected to; be in specifically named subdirectories of <``directory``>. If; ``directory`` is left unspecified, ``configure`` uses the default value; ``/home/vadve/shared/benchmarks/speccpu2000/benchspec``. Subdirectory; names known to LLVM include:. * spec95. * speccpu2000. * speccpu2006. * povray31. Others are added from time to time, and can be determined from; ``configure``. Running Different Tests; =======================. In addition to the regular ""whole program"" tests, the ``test-suite``; module also provides a mechanism for compiling the programs in different; ways. If the variable TEST is defined on the ``gmake`` command line, the; test system will include a Makefile named; ``TEST.<value of TEST variable>.Makefile``. This Makefile can modify; build rules to yield different results. For example, the LLVM nightly tester uses ``TEST.nightly.Makefile`` to; create the nightly test reports. To run the nightly tests, run; ``gmake TEST=nightly``. There are several TEST Makefiles available in the tree. Some of them are; designed for internal LLVM research and will not work outside of the; LLVM research group. They may still be valuable, however, as a guide to; writing your own TEST Makefile for any optimization or analysis passes; that you develop with LLVM. Generating Test Output; ======================. There are a nu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:2737,config,configure,2737,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['config'],['configure']
Modifiability," negative values for 'workers still; sending' in PROOF-Lite .; Fix locking issue while building packages locally.; Fix issue setting permission and ownership of the dataset; user directories.Fix; a subtle bug affecting the (possibly rare) case when not all entries; are required and # entries does not correspond to an complete subset of; files (e.g. # entries = 1001000 with files of 100000 entries each). The; effect was uncomplete processing (skipped events, magenta bar) or a; session freeze.; Fix problem with packet re-assignment in case of a worker death (some packets were processed twice or more times).; Fix problem with the transmission of non-default file; attributes (e.g. the number of entries) from TChainElement to; TDSetElement during TChain processing in PROOF; Fix problem in the default packetizer with validating the; exact number of needed files when the information about the entries is; already available.; Fix problem with 'xpd.putenv' and 'xpd.putrc' occuring when the variables themselves contain commas.; Avoid resolving the workers FQDN when running in PROOF-Lite,; creating unnecessary delays when running PROOF-Lite within virtual; machines.; Fix problem with the permissions of the user data directory.; Add files to the list of files to process only when finally validated.; Fix; problem with canvases when the feedback canvas and the final canvas are; the same (do not delete the feedback canvas at the end of processing); Make sure that TProof::Load, TProofPlayer::SendSelector and; TSelector::GetSelector treat consistently the extensions of the; implementation files.; Unlock the cache after failure to load a selector; prevents session freezing; Correctly update the number of submergers when workers die; Add missing protection causing a crash in submergers when the output list contained TProofOutputFile objects.; Move the creation and start of the idle timeout from the end; of SetupCommon to the end of CreateServer, so that the timeout is not; active during",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:11869,variab,variables,11869,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['variab'],['variables']
Modifiability," new :program:`lit` testing implementation, or extending an existing one. :program:`lit` proper is primarily an infrastructure for discovering and running; arbitrary tests, and to expose a single convenient interface to these; tests. :program:`lit` itself doesn't know how to run tests, rather this logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~~~~. As described in :ref:`test-discovery`, tests are always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The name of the test suite, for use in reports and; diagnostics. **test_format** *[required]* The test format object which will be used to; discover and run tests in the test suite. Generally this will be a builtin test; format available from the *lit.formats* module. **test_source_root** T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:14819,config,config,14819,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['config']
Modifiability," new machine learning tools provided in TMVA such as the Deep Learning module.; The method `TMVA::Types::kDL` should be used now for building Deep Learning architecture in TMVA, while `TMVA::Types::kDNN` is now deprecated. `TMVA::Types::kDL` provides all the functionality of `TMVA::Types::kDNN`, i.e building fully connected dense layer, but in addition supports building convolutional and recurrent neural network architectures.; These release contains improvements in the `MethodDL` such as:; - fix droput support for dense layer; - add protection to avoid returning NaN in the cross-entropy loss function. In addition we have :. - New `TMVA::Executor` class to control the multi-thread running of TMVA. By default now MT running will be enabled only when `ROOT::EnabledImplicitMT()` is called. But we can take the control of the threads by using `TMVA::gConfig().EnableMT(...)` and `TMVA::gConfig().DisableMT()`. ### PyMVA; - add support when using the Tensorflow backend in Keras to control the number of threads; - add possibility to control options for configuring GPU running. FOr example we can now set the mode to allocate memory only as needed. This is required when using the new RTX gaming cards from NVIDIA. ## 2D Graphics Libraries. - In the statistics painting for 2D histograms, the central cell of; the underflow/overflow grid was not properly rendered for very large contents.; This problem was reported [here](https://root-forum.cern.ch/t/stat-box-for-th2/).; - The automatic placement of legend now ""sees"" TMultiGraph and THStack.; - Improve and simplify the drawing the 2D histogram's option ""ARR"".; - The option ARR can be combined with the option COL or COLZ.; - `TBox::DistancetoPrimitive` and `TBox::ExecuteEvent` now work in log scales (by Jérémie Dudouet).; - Take the line attributes into account when drawing a histogram with option bar or hbar.; They were ignored until now.; - The new draw option MIN0 makes same effect as gStyle->SetHistMinimumZero(1), but can be spe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:18301,config,configuring,18301,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['config'],['configuring']
Modifiability," nil, [[NSBundle alloc] init], nil,@""""); // warn; }. .. _optin-osx-cocoa-localizability-NonLocalizedStringChecker:. optin.osx.cocoa.localizability.NonLocalizedStringChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns about uses of non-localized NSStrings passed to UI methods expecting localized NSStrings. .. code-block:: objc. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. .. _optin-performance-GCDAntipattern:. optin.performance.GCDAntipattern; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for performance anti-patterns when using Grand Central Dispatch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""""""""""""""""""""; Check for excessively padded structs. .. _optin-portability-UnixAPI:. optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"". When environment array is modified using some modification function; such as ``putenv``, ``setenv`` or others, It may happen that memory is reallocated,; however ""envp"" is not updated to reflect the changes and points to old memory; region. * **ENV34-C**:; Some functions return a pointer to a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:19636,portab,portability,19636,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['portab'],['portability']
Modifiability," no location) for each variable. In order to; make those decisions we run a standard fixed-point dataflow analysis that makes; the choice at each instruction, iteratively joining the results for each block. ### TODO list. As this is an experimental work in progress so there are some items we still need; to tackle:. * As mentioned in test llvm/test/DebugInfo/assignment-tracking/X86/diamond-3.ll,; the analysis should treat escaping calls like untagged stores. * The system expects locals to be backed by a local alloca. This isn't always; the case - sometimes a pointer to storage is passed into a function; (e.g. sret, byval). We need to be able to handle those cases. See; llvm/test/DebugInfo/Generic/assignment-tracking/track-assignments.ll and; clang/test/CodeGen/assignment-tracking/assignment-tracking.cpp for examples. * `trackAssignments` doesn't yet work for variables that have their; `llvm.dbg.declare` location modified by a `DIExpression`, e.g. when the; address of the variable is itself stored in an `alloca` with the; `llvm.dbg.declare` using `DIExpression(DW_OP_deref)`. See `indirectReturn` in; llvm/test/DebugInfo/Generic/assignment-tracking/track-assignments.ll and in; clang/test/CodeGen/assignment-tracking/assignment-tracking.cpp for an; example. * In order to solve the first bullet-point we need to be able to specify that a; memory location is available without using a `DIAssignID`. This is because; the storage address is not computed by an instruction (it's an argument; value) and therefore we have nowhere to put the metadata attachment. To solve; this we probably need another marker intrinsic to denote ""the variable's; stack home is X address"" - similar to `llvm.dbg.declare` except that it needs; to compose with `llvm.dbg.assign` intrinsics such that the stack home address; is only selected as a location for the variable when the `llvm.dbg.assign`; intrinsics agree it should be. * Given the above (a special ""the stack home is X"" intrinsic), and the fact; that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:10149,variab,variable,10149,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['variab'],['variable']
Modifiability," nodes tie a :ref:`DIGlobalVariable` together; with a :ref:`DIExpression`. .. code-block:: text. @lower = global i32, !dbg !0; @upper = global i32, !dbg !1; !0 = !DIGlobalVariableExpression(; var: !2,; expr: !DIExpression(DW_OP_LLVM_fragment, 0, 32); ); !1 = !DIGlobalVariableExpression(; var: !2,; expr: !DIExpression(DW_OP_LLVM_fragment, 32, 32); ); !2 = !DIGlobalVariable(name: ""split64"", linkageName: ""split64"", scope: !3,; file: !4, line: 8, type: !5, declaration: !6). All global variable expressions should be referenced by the `globals:` field of; a :ref:`compile unit <DICompileUnit>`. .. _DISubprogram:. DISubprogram; """""""""""""""""""""""". ``DISubprogram`` nodes represent functions from the source language. A distinct; ``DISubprogram`` may be attached to a function definition using ``!dbg``; metadata. A unique ``DISubprogram`` may be attached to a function declaration; used for call site debug info. The ``retainedNodes:`` field is a list of; :ref:`variables <DILocalVariable>` and :ref:`labels <DILabel>` that must be; retained, even if their IR counterparts are optimized out of the IR. The; ``type:`` field must point at an :ref:`DISubroutineType`. .. _DISubprogramDeclaration:. When ``spFlags: DISPFlagDefinition`` is not present, subprograms describe a; declaration in the type tree as opposed to a definition of a function. In this; case, the ``declaration`` field must be empty. If the scope is a composite type; with an ODR ``identifier:`` and that does not set ``flags: DIFwdDecl``, then; the subprogram declaration is uniqued based only on its ``linkageName:`` and; ``scope:``. .. code-block:: text. define void @_Z3foov() !dbg !0 {; ...; }. !0 = distinct !DISubprogram(name: ""foo"", linkageName: ""_Zfoov"", scope: !1,; file: !2, line: 7, type: !3,; spFlags: DISPFlagDefinition | DISPFlagLocalToUnit,; scopeLine: 8, containingType: !4,; virtuality: DW_VIRTUALITY_pure_virtual,; virtualIndex: 10, flags: DIFlagPrototyped,; isOptimized: true, unit: !5, templateParams: !6,; declaration: !",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:257797,variab,variables,257797,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability," number of rows (columns) at instantiation. It will allocate; an array of the length $nrow*(nrow+1)/2$ and initialize it to $0$.; Elements can then be set using the method operator()(unsigned int,; unsigned int). ### MnUserCovariance::operator()(unsigned int, unsigned int) ###. Individual elements can be accessed via the operator(), both for reading; and writing. ## MnUserParameters ##. [api:parameters] MnUserParameters is the main class for user interaction; with the parameters. It serves both as input to the minimization as well; as output as the result of the minimization is converted into the user; representable format in order to allow for further interaction.; Parameters for M can be added (defined) specifying a name, value and; initial uncertainty. ### add(...) ###. The method MnUserParameters::add(...) is overloaded for three kind of; parameters:. - add(const char\*, double, double) for adding a free variable; parameter. - add(const char\*, double, double, double, double) for adding a; variable parameter with limits (lower and upper). - add(const char\*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will; be the same as in the std::vector$<$double$>$ in the; FCNBase::operator(). That means the first parameter the user adds gets; index 0, the second index 1, and so on. When calculating the function; value inside FCN, M will call FCNBase::operator() with the elements at; their positions. ### setValue(...) ###. [api:setvalue] setValue(unsigned int parno, double value) or; setValue(const char\* name, double value) set the value of parameter; $\mbox{parno}$ or with name $\mbox{name}$ to; $\mbox{ value}$. The parameter in question may be variable, fixed,; or constant, but must be defined. ### setError(...) ###. [api:seterror] setError(unsigned int parno, double error) or; setError(const char\* name, double error) set the error (sigma) of; parameter $\mbox{parno}$ or with name $\mbox{name}$ to; $\mbox{val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:53681,variab,variable,53681,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability," of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10544,variab,variables,10544,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variables']
Modifiability," of a; template, rather than having distinct declarations for an instantiation of; the declaration versus the definition, so template instantiation often; updates parts of existing declarations.; * Some parts of declarations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. As a consequence of this design principle, we typically do not provide setters; for AST state. (Some are provided for short-term modifications intended to be; used immediately after an AST node is created and before it's ""published"" as; part of the complete AST, or where language semantics require after-the-fact; updates.). Faithfulness; ^^^^^^^^^^^^. The AST intends to provide a representation of the program that is faithful to; the original source. We intend for it to be possible to write refactoring tools; using only information stored in, or easily reconstructible from, the Clang AST.; This means that the AST representation should either not desugar source-level; constructs to simpler forms, or -- where made necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally and wrap the result; in a construct representing the original source form. For example, ``CXXForRangeStmt`` directly represents the syntactic form of a; range-based for statement, but also holds a semantic representation of the; range declaration and iterator declarations. It does not contain a; fully-desugared ``ForStmt``, however. Some AST nodes (for example, ``ParenExpr``) represent only syntax, and others; (for example, ``ImplicitCastExpr``) represent only semantics, but most nodes; will represent a combination of syntax and associated semantics. Inheritance; is typically used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:60038,refactor,refactoring,60038,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['refactor'],['refactoring']
Modifiability," of an expression. .. productionlist::; If: ""if"" `Value` ""then"" `IfBody`; :| ""if"" `Value` ""then"" `IfBody` ""else"" `IfBody`; IfBody: ""{"" `Statement`* ""}"" | `Statement`. The value expression is evaluated. If it evaluates to true (in the same; sense used by the bang operators), then the statements following the; ``then`` reserved word are processed. Otherwise, if there is an ``else``; reserved word, the statements following the ``else`` are processed. If the; value is false and there is no ``else`` arm, no statements are processed. Because the braces around the ``then`` statements are optional, this grammar rule; has the usual ambiguity with ""dangling else"" clauses, and it is resolved in; the usual way: in a case like ``if v1 then if v2 then {...} else {...}``, the; ``else`` associates with the inner ``if`` rather than the outer one. The :token:`IfBody` of the then and else arms of the ``if`` establish an; inner scope. Any ``defvar`` variables defined in the bodies go out of scope; when the bodies are finished (see `Defvar in a Record Body`_ for more details). The ``if`` statement can also be used in a record :token:`Body`. ``assert`` --- check that a condition is true; ---------------------------------------------. The ``assert`` statement checks a boolean condition to be sure that it is true; and prints an error message if it is not. .. productionlist::; Assert: ""assert"" `condition` "","" `message` "";"". If the boolean condition is true, the statement does nothing. If the; condition is false, it prints a nonfatal error message. The **message**, which; can be an arbitrary string expression, is included in the error message as a; note. The exact behavior of the ``assert`` statement depends on its; placement. * At top level, the assertion is checked immediately. * In a record definition, the statement is saved and all assertions are; checked after the record is completely built. * In a class definition, the assertions are saved and inherited by all; the subclasses and recor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:48648,variab,variables,48648,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variables']
Modifiability," of class Background (default: 0 = all). V No False − Verbosity (default: true). VerboseLevel No Info Debug, Verbose, Info VerboseLevel (Debug/Verbose/Info). Configuration options for the PDF class :. Configuration options reference for class: PDF. Option Array Default value Predefined values Description. NSmooth No 0 − Number of smoothing iterations for the input histograms. MinNSmooth No -1 − Min number of smoothing iterations, for bins with most data. MaxNSmooth No -1 − Max number of smoothing iterations, for bins with least data. NAvEvtPerBin No 50 − Average number of events per PDF bin. Nbins No 0 − Defined number of bins for the histogram from which the PDF is created. CheckHist No False − Whether or not to check the source histogram of the PDF. PDFInterpol No Spline2 Spline0, Spline1, Spline2, Spline3, Spline5, KDE Interpolation method for reference histograms (e.g. Spline2 or KDE). KDEtype No Gauss Gauss KDE kernel type (1=Gauss). KDEiter No Nonadaptive Nonadaptive, Adaptive Number of iterations (1=non-adaptive, 2=adaptive). KDEFineFactor No 1 − Fine tuning factor for Adaptive KDE: Factor to multyply the width of the kernel. KDEborder No None None, Renorm, Mirror Border effects treatment (1=no treatment , 2=kernel renormalization, 3=sample mirroring). Configuration options for Factory running :. Configuration options reference for class: Factory. Option Array Default value Predefined values Description. V No False − Verbose flag. Color No True − Flag for coloured screen output (default: True, if in batch mode: False). Transformations No − List of transformations to test; formatting example: Transformations=I;D;P;U;G,D, for identity, decorrelation, PCA, Uniform and Gaussianisation followed by decorrelation transformations. Silent No False − Batch mode: boolean silent flag inhibiting any output from TMVA after the creation of the factory class object (default: False). DrawProgressBar No True − Draw progress bar to display training, testing and evaluation sched",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:34300,adapt,adaptive,34300,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['adapt'],['adaptive']
Modifiability," of commented code for all four of our expression nodes.; First we'll do numeric literals:. .. code-block:: c++. Value *NumberExprAST::codegen() {; return ConstantFP::get(*TheContext, APFloat(Val));; }. In the LLVM IR, numeric constants are represented with the; ``ConstantFP`` class, which holds the numeric value in an ``APFloat``; internally (``APFloat`` has the capability of holding floating point; constants of Arbitrary Precision). This code basically just creates; and returns a ``ConstantFP``. Note that in the LLVM IR that constants; are all uniqued together and shared. For this reason, the API uses the; ""foo::get(...)"" idiom instead of ""new foo(..)"" or ""foo::Create(..)"". .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; Value *V = NamedValues[Name];; if (!V); LogErrorV(""Unknown variable name"");; return V;; }. References to variables are also quite simple using LLVM. In the simple; version of Kaleidoscope, we assume that the variable has already been; emitted somewhere and its value is available. In practice, the only; values that can be in the ``NamedValues`` map are function arguments.; This code simply checks to see that the specified name is in the map (if; not, an unknown variable is being referenced) and returns the value for; it. In future chapters, we'll add support for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(TheCont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:5849,variab,variable,5849,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variable']
Modifiability," of events in DataSet. Implemented; the usage of this feature for MLP.; ; TMlpANN (interface to TMultiLayerPerceptron) now also uses event weights; and writes standalone C++ class. k-NN:; A new global knn search function has been added to NodekNN that searches for; k-nearest neighbor using event weights instead of raw event counts. ModulekNN; has been modified to allow searches using ""weight"" or ""count"" option, where; ""count"" is default. Added UseWeight option to MethodKNN to allow using of; ""weight"" or ""count"". ; (Work by Rustem Ospanov, CERN). . Likelihood (and general PDF treatment):; Adaptive smoothing the PDF class, allowing it to smooth between MinSmoothNum ; (for regions with more signal) and MaxSmoothNum (for regions with less signal). . Configuration of the PDF parameters from the option string moved to PDF class,; allowing the user to define all the PDF functionalities in every classifier; the PDF is used (i.e., also for the MVA PDFs). The reading of these variables; was removed from MethodBase and MethodLikelihood. This also allows improved ; (full) PDF configuration of MVA output via the ""CreateMvaPdf"" option.; (Work by Or Cohen, CERN & Weizmann); ; New generalisation methods:. ; MethodCompositeBase: combines more than one; classifier within one. MethodBoost: boosts/bags any classifier; type. A special booking procedure for it was added to; Factory class. MethodDT: a classifier composed of a single; decision tree, boosted using MethodBoost. Results are; compatible with BDT, but BDT remains the default for boosted; decision trees, because it has pruning (among other; additional features). . Other improvements . Improved handling of small Likelihood values such that; Likelihood performance increases in analyses with many variables; (~>10). Thanks to Ralph Schaefer (Bonn U.) for reporting this. Nicer plotting: custom variable titles and units can be; assigned in ""AddVariable"" call. Introduced the inverse transformation InverseTransform for; the variable tra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html:4374,variab,variables,4374,tmva/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html,1,['variab'],['variables']
Modifiability," of itself, whether directly or via other; substitutions, should be avoided. It usually produces an infinitely recursive; definition that cannot be fully expanded. It does *not* define the; substitution in terms of its previous value, even when using ``REDEFINE:``. The relationship between the ``DEFINE:`` and ``REDEFINE:`` directive is; analogous to the relationship between a variable declaration and variable; assignment in many programming languages:. - ``DEFINE: %{name} = value``. This directive assigns the specified value to a new substitution whose; pattern is ``%{name}``, or it reports an error if there is already a; substitution whose pattern contains ``%{name}`` because that could produce; confusing expansions (e.g., a lit configuration file might define a; substitution with the pattern ``%{name}\[0\]``). The new substitution is; inserted at the start of the substitution list so that it will expand first.; Thus, its value can contain any substitution previously defined, whether in; the same test file or in a lit configuration file, and both will expand. - ``REDEFINE: %{name} = value``. This directive assigns the specified value to an existing substitution whose; pattern is ``%{name}``, or it reports an error if there are no substitutions; with that pattern or if there are multiple substitutions whose patterns; contain ``%{name}``. The substitution's current position in the substitution; list does not change so that expansion order relative to other existing; substitutions is preserved. The following properties apply to both the ``DEFINE:`` and ``REDEFINE:``; directives:. - **Substitution name**: In the directive, whitespace immediately before or; after ``%{name}`` is optional and discarded. ``%{name}`` must start with; ``%{``, it must end with ``}``, and the rest must start with a letter or; underscore and contain only alphanumeric characters, hyphens, underscores, and; colons. This syntax has a few advantages:. - It is impossible for ``%{name}`` to contain se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:33107,config,configuration,33107,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configuration']
Modifiability," of people excited. Unfortunately,; these people are usually thinking about C or a language from the C; family when they are asking questions about language portability. I say; ""unfortunately"", because there is really no way to make (fully general); C code portable, other than shipping the source code around (and of; course, C source code is not actually portable in general either - ever; port a really old application from 32- to 64-bits?). The problem with C (again, in its full generality) is that it is heavily; laden with target specific assumptions. As one simple example, the; preprocessor often destructively removes target-independence from the; code when it processes the input text:. .. code-block:: c. #ifdef __i386__; int X = 1;; #else; int X = 42;; #endif. While it is possible to engineer more and more complex solutions to; problems like this, it cannot be solved in full generality in a way that; is better than shipping the actual source code. That said, there are interesting subsets of C that can be made portable.; If you are willing to fix primitive types to a fixed size (say int =; 32-bits, and long = 64-bits), don't care about ABI compatibility with; existing binaries, and are willing to give up some other minor features,; you can have portable code. This can make sense for specialized domains; such as an in-kernel language. Safety Guarantees; -----------------. Many of the languages above are also ""safe"" languages: it is impossible; for a program written in Java to corrupt its address space and crash the; process (assuming the JVM has no bugs). Safety is an interesting; property that requires a combination of language design, runtime; support, and often operating system support. It is certainly possible to implement a safe language in LLVM, but LLVM; IR does not itself guarantee safety. The LLVM IR allows unsafe pointer; casts, use after free bugs, buffer over-runs, and a variety of other; problems. Safety needs to be implemented as a layer on top of LLVM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:7518,portab,portable,7518,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['portab'],['portable']
Modifiability," of rows, and number of columns. Standard Conversions; --------------------. The standard conversions are extended as follows. Note that these conversions; are intentionally not listed as satisfying the constraints for assignment,; which is to say, they are only permitted as explicit casts, not as implicit; conversions. A value of matrix type can be converted to another matrix type if the number of; rows and columns are the same and the value's elements can be converted to the; element type of the result type. The result is a matrix where each element is; the converted corresponding element. A value of any real type (as in C23 6.2.5p14) can be converted to a matrix type; if it can be converted to the element type of the matrix. The result is a; matrix where all elements are the converted original value. If the number of rows or columns differ between the original and resulting; type, the program is ill-formed. Arithmetic Conversions; ----------------------. The usual arithmetic conversions are extended as follows. Insert at the start:. * If both operands are of matrix type, no arithmetic conversion is performed.; * If one operand is of matrix type and the other operand is of a real type,; convert the real type operand to the matrix type; according to the standard conversion rules. Matrix Type Element Access Operator; -----------------------------------. An expression of the form ``E1 [E2] [E3]``, where ``E1`` has matrix type ``cv; M``, is a matrix element access expression. Let ``T`` be the element type; of ``M``, and let ``R`` and ``C`` be the number of rows and columns in ``M``; respectively. The index expressions shall have integral or unscoped; enumeration type and shall not be uses of the comma operator unless; parenthesized. The first index expression shall evaluate to a; non-negative value less than ``R``, and the second index expression shall; evaluate to a non-negative value less than ``C``, or else the expression has; undefined behavior. If ``E1`` is a prv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:3140,extend,extended,3140,interpreter/llvm-project/clang/docs/MatrixTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst,1,['extend'],['extended']
Modifiability," of target features, that affect ISA generation. It is target; specific if a target ID is supported, or if the target triple alone is; sufficient to specify the ISA generation. It is used with the ``-mcpu=<target-id>`` and ``--offload-arch=<target-id>``; Clang compilation options to specify the kind of code to generate. It is also used as part of the bundle entry ID to identify the code object. See; :ref:`clang-bundle-entry-id`. Target ID syntax is defined by the following BNF syntax:. .. code::. <target-id> ::== <processor> ( "":"" <target-feature> ( ""+"" | ""-"" ) )*. Where:. **processor**; Is a the target specific processor or any alternative processor name. **target-feature**; Is a target feature name that is supported by the processor. Each target; feature must appear at most once in a target ID and can have one of three; values:. *Any*; Specified by omitting the target feature from the target ID.; A code object compiled with a target ID specifying the default; value of a target feature can be loaded and executed on a processor; configured with the target feature on or off. *On*; Specified by ``+``, indicating the target feature is enabled. A code; object compiled with a target ID specifying a target feature on; can only be loaded on a processor configured with the target feature on. *Off*; specified by ``-``, indicating the target feature is disabled. A code; object compiled with a target ID specifying a target feature off; can only be loaded on a processor configured with the target feature off. .. _compatibility-target-id:. Compatibility Rules for Target ID; ---------------------------------. A code object compiled for a Target ID is considered compatible for a; target, if:. * Their processor is same.; * Their feature set is compatible as defined above. There are two forms of target ID:. *Non-Canonical Form*; The non-canonical form is used as the input to user commands to allow the user; greater convenience. It allows both the primary and alternative processor na",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:12103,config,configured,12103,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,1,['config'],['configured']
Modifiability," of the ``this`` pointer. .. _RuntimeHelperFunctions:. Runtime Helper Functions; ========================. The runtime helper functions are described in; ``/usr/local/include/Block_private.h``. To summarize their use, a ``Block``; requires copy/dispose helpers if it imports any block variables, ``__block``; storage variables, ``__attribute__((NSObject))`` variables, or C++ ``const``; copied objects with constructor/destructors. The (1<<26) bit is set and; functions are generated. The block copy helper function should, for each of the variables of the type; mentioned above, call:. .. code-block:: c. _Block_object_assign(&dst->target, src->target, BLOCK_FIELD_<apropos>);. in the copy helper and:. .. code-block:: c. _Block_object_dispose(->target, BLOCK_FIELD_<apropos>);. in the dispose helper where ``<apropos>`` is:. .. code-block:: c. enum {; BLOCK_FIELD_IS_OBJECT = 3, // id, NSObject, __attribute__((NSObject)), block, ...; BLOCK_FIELD_IS_BLOCK = 7, // a block variable; BLOCK_FIELD_IS_BYREF = 8, // the on stack structure holding the __block variable. BLOCK_FIELD_IS_WEAK = 16, // declared __weak. BLOCK_BYREF_CALLER = 128, // called from byref copy/dispose helpers; };. and of course the constructors/destructors for ``const`` copied C++ objects. The ``block_byref`` data structure similarly requires copy/dispose helpers for; block variables, ``__attribute__((NSObject))`` variables, or C++ ``const``; copied objects with constructor/destructors, and again the (1<<26) bit is set; and functions are generated in the same manner. Under ObjC we allow ``__weak`` as an attribute on ``__block`` variables, and; this causes the addition of ``BLOCK_FIELD_IS_WEAK`` orred onto the; ``BLOCK_FIELD_IS_BYREF`` flag when copying the ``block_byref`` structure in the; ``Block`` copy helper, and onto the ``BLOCK_FIELD_<apropos>`` field within the; ``block_byref`` copy/dispose helper calls. The prototypes, and summary, of the helper functions are:. .. code-block:: c. /* Certain field types requ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:28569,variab,variable,28569,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,2,['variab'],['variable']
Modifiability," of the allocator can be configured on a per process basis; through the following ways:. - at compile time, by defining ``SCUDO_DEFAULT_OPTIONS`` to the options string; you want set by default;. - by defining a ``__scudo_default_options`` function in one's program that; returns the options string to be parsed. Said function must have the following; prototype: ``extern ""C"" const char* __scudo_default_options(void)``, with a; default visibility. This will override the compile time define;. - through the environment variable SCUDO_OPTIONS, containing the options string; to be parsed. Options defined this way will override any definition made; through ``__scudo_default_options``. - via the standard ``mallopt`` `API <https://man7.org/linux/man-pages/man3/mallopt.3.html>`_,; using parameters that are Scudo specific. When dealing with the options string, it follows a syntax similar to ASan, where; distinct options can be assigned in the same string, separated by colons. For example, using the environment variable:. .. code:: console. SCUDO_OPTIONS=""delete_size_mismatch=false:release_to_os_interval_ms=-1"" ./a.out. Or using the function:. .. code:: cpp. extern ""C"" const char *__scudo_default_options() {; return ""delete_size_mismatch=false:release_to_os_interval_ms=-1"";; }. The following ""string"" options are available:. +---------------------------------+----------------+-------------------------------------------------+; | Option | Default | Description |; +---------------------------------+----------------+-------------------------------------------------+; | quarantine_size_kb | 0 | The size (in Kb) of quarantine used to delay |; | | | the actual deallocation of chunks. Lower value |; | | | may reduce memory usage but decrease the |; | | | effectiveness of the mitigation; a negative |; | | | value will fallback to the defaults. Setting |; | | | *both* this and thread_local_quarantine_size_kb |; | | | to zero will disable the quarantine entirely. |; +-----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:8082,variab,variable,8082,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['variab'],['variable']
Modifiability," of the block where; an additional DBG_VALUE is added. Were any other DBG_VALUE for ``!1`` to occur; in the instructions that the MOV32rm was sunk past, the DBG_VALUE for ``%1``; would be dropped and the debugger would never observe it in the variable. This; accurately reflects that the value is not available during the corresponding; portion of the original program. Variable locations during Register Allocation; ---------------------------------------------. To avoid debug instructions interfering with the register allocator, the; LiveDebugVariables pass extracts variable locations from a MIR function and; deletes the corresponding DBG_VALUE instructions. Some localized copy; propagation is performed within blocks. After register allocation, the; VirtRegRewriter pass re-inserts DBG_VALUE instructions in their original; positions, translating virtual register references into their physical; machine locations. To avoid encoding incorrect variable locations, in this; pass any DBG_VALUE of a virtual register that is not live, is replaced by; the undefined location. The LiveDebugVariables may insert redundant DBG_VALUEs; because of virtual register rewriting. These will be subsequently removed by; the RemoveRedundantDebugValues pass. LiveDebugValues expansion of variable locations; -----------------------------------------------. After all optimizations have run and shortly before emission, the; LiveDebugValues pass runs to achieve two aims:. * To propagate the location of variables through copies and register spills,; * For every block, to record every valid variable location in that block. After this pass the DBG_VALUE instruction changes meaning: rather than; corresponding to a source-level assignment where the variable may change value,; it asserts the location of a variable in a block, and loses effect outside the; block. Propagating variable locations through copies and spills is; straightforwards: determining the variable location in every basic block; requires t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:36137,variab,variable,36137,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability," of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with the options in the; `.rootrc` file. Examples of the tunable parameters are the ones related; to the operating and window system, to the fonts to be used, to the; location of start-up files. At start-up, ROOT looks for a `.rootrc` file; in the following order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `TEnv`.; Have a look to its documentation if you need such rather advanced; features. The file `.rootrc` defines the location of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:17633,adapt,adaptive,17633,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['adapt'],['adaptive']
Modifiability," of the predicate state tracking. A primary challenge to passing; the predicate state between functions is that we would like to not require a; change to the ABI or calling convention in order to make this mitigation more; deployable, and further would like code mitigated in this way to be easily; mixed with code not mitigated in this way and without completely losing the; value of the mitigation. ##### Embed the predicate state into the high bit(s) of the stack pointer. We can use the same technique that allows hardening pointers to pass the; predicate state into and out of functions. The stack pointer is trivially; passed between functions and we can test for it having the high bits set to; detect when it has been marked due to misspeculation. The callsite instruction; sequence looks like (assuming a misspeculated state value of `-1`):; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; shlq $47, %rax; orq %rax, %rsp; callq other_function; movq %rsp, %rax; sarq 63, %rax # Sign extend the high bit to all bits.; ```. This first puts the predicate state into the high bits of `%rsp` before calling; the function and then reads it back out of high bits of `%rsp` afterward. When; correctly executing (speculatively or not), these are all no-ops. When; misspeculating, the stack pointer will end up negative. We arrange for it to; remain a canonical address, but otherwise leave the low bits alone to allow; stack adjustments to proceed normally without disrupting this. Within the; called function, we can extract this predicate state and then reset it on; return:; ```; other_function:; # prolog; callq other_function; movq %rsp, %rax; sarq 63, %rax # Sign extend the high bit to all bits.; # ... .LBB0_N:; cmovneq %r8, %rax # Conditionally update predicate state.; shlq $47, %rax; orq %rax, %rsp; retq; ```. This approach is effective when all code is mitigated in this fashion, and can; even survive very limited reaches into unmitigated code (th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:39166,extend,extend,39166,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['extend'],['extend']
Modifiability," of the vector function. ``preallocated(<ty>)``; This attribute is required on calls to ``llvm.call.preallocated.arg``; and cannot be used on any other call. See; :ref:`llvm.call.preallocated.arg<int_call_preallocated_arg>` for more; details. .. _glattrs:. Global Attributes; -----------------. Attributes may be set to communicate additional information about a global variable.; Unlike :ref:`function attributes <fnattrs>`, attributes on a global variable; are grouped into a single :ref:`attribute group <attrgrp>`. ``no_sanitize_address``; This attribute indicates that the global variable should not have; AddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""address"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``no_sanitize_hwaddress``; This attribute indicates that the global variable should not have; HWAddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""hwaddress"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``sanitize_memtag``; This attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; suppression of certain optimisations, like GlobalMerge, as well as ensuring; extra directives are emitted in the assembly and extra bits of metadata are; placed in the object file so that the linker can ensure the accesses are; protected by MTE. This attribute is added by clang when; `-fsanitize=memtag-globals` is provided, as long as the global is not marked; with `__attribute__((no_sanitize(""memtag"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file. The AArch64 Globals Tagging pass may remove; this attribute when it's not possible to tag the global (e.g. it's a TLS; variable).; ``sanitize_address_dy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:115529,variab,variable,115529,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," of whether the mature heap; is compacting), but bring the added complexity of requiring write barriers. Threaded; Denotes a multithreaded mutator; the collector must still stop the mutator; (""stop the world"") before beginning reachability analysis. Stopping a; multithreaded mutator is a complicated problem. It generally requires highly; platform-specific code in the runtime, and the production of carefully; designed machine code at safe points. Concurrent; In this technique, the mutator and the collector run concurrently, with the; goal of eliminating pause times. In a *cooperative* collector, the mutator; further aids with collection should a pause occur, allowing collection to take; advantage of multiprocessor hosts. The ""stop the world"" problem of threaded; collectors is generally still present to a limited extent. Sophisticated; marking algorithms are necessary. Read barriers may be necessary. As the matrix indicates, LLVM's garbage collection infrastructure is already; suitable for a wide variety of collectors, but does not currently extend to; multithreaded programs. This will be added in the future as there is; interest. .. _stack-map:. Computing stack maps; --------------------. LLVM automatically computes a stack map. One of the most important features; of a ``GCStrategy`` is to compile this information into the executable in; the binary representation expected by the runtime library. The stack map consists of the location and identity of each GC root in the; each function in the module. For each root:. * ``RootNum``: The index of the root. * ``StackOffset``: The offset of the object relative to the frame pointer. * ``RootMetadata``: The value passed as the ``%metadata`` parameter to the; ``@llvm.gcroot`` intrinsic. Also, for the function as a whole:. * ``getFrameSize()``: The overall size of the function's initial stack frame,; not accounting for any dynamic allocation. * ``roots_size()``: The count of roots in the function. To access the stack map, use ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:31865,extend,extend,31865,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['extend'],['extend']
Modifiability," of zero. This has been implemented by Jeromy Tompkins <Tompkins@nscl.msu.edu>. ## Geometry Libraries; A new module geom/vecgeom was introduced to give transparent access to VecGeom ; solid primitives. VecGeom is a high performance geometry package (link) providing ; SIMD vectorization for the CPU-intensive geometry algorithms used for geometry; navigation. The module creates a new library libConverterVG.so depending on the; VecGeom main library and loaded using the ROOT plug-in mechanism. The main functionality provided by the new vecgeom module is to make a conversion ; in memory of all the shapes in a loaded TGeo geometry into a special adapter; shape TGeoVGShape, redirecting all navigation calls to the corresponding VecGeom ; solid. The library loading and geometry conversion can be done with a single call ; `TVirtualGeoConverter::Instance()->ConvertGeometry()`; . After the conversion is done, all existing TGeo functionality is available as for; a native geometry, only that most of the converted solids provide better navigation ; performance, despite the overhead introduced by the new adapter shape. Prerequisites: installation of VecGeom. ; The installation instructions are available at <http://geant.web.cern.ch/content/installation>; Due to the fact that VecGeom provides for the moment static libraries ; and depends on ROOT, is is advised to compile first ROOT without VecGeom support, ; then compile VecGeom against this ROOT version, then re-configure ROOT to enable ; VecGeom and Vc support, using the flags -Dvc=ON -Dvecgeom=on; ; This has been implemented by Mihaela Gheata <Mihaela.Gheata@cern.ch>. ## Database Libraries. * Fix `TPgSQLStatement::SetBinary` to actually handle binary data (previous limited to ascii). ## Networking Libraries. * When seeing too many requested ranges, Apache 2.4 now simply sends the whole file; (MaxRanges configuration parameter). TWebFile can handle this case now, but this can; trigger multiple transmissions of the full file. TWebF",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:24050,adapt,adapter,24050,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['adapt'],['adapter']
Modifiability," off the latencies inherent to multiple small reads for; the potential of requesting more data than needed by read from the disk or; server the baskets for too many branches. The default behavior can be changed by either updating one of the rootrc files; or by setting environment variables. The rootrc files, both the global and the; local ones, now support the following the resource variable TTreeCache.Size; which set the default size factor for auto sizing TTreeCache for TTrees. The; estimated cluster size for the TTree and this factor is used to give the cache; size. If option is set to zero auto cache creation is disabled and the default; cache size is the historical one (equivalent to factor 1.0). If set to; non zero auto cache creation is enabled and both auto created and; default sized caches will use the configured factor: 0.0 no automatic cache; and greater than 0.0 to enable cache. This value can be overridden by the; environment variable ROOT_TTREECACHE_SIZE. The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling; type. The prefill type may be: 0 for no prefilling and 1 to prefill all; the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL. In particular the default can be set back to the same as in version 5 by; setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill; (or ROOT_TTREECACHE_PREFILL) both to zero. TTree methods which are expected to modify a cache, like AddBranchToCache, will; attempt to setup a cache of default size if one does not exist, irrespective of; whether the auto cache creation is enabled. Additionally several methods giving; control of the cache have changed return type from void to Int_t, to be able to; return a code to indicate if there was an error. Usually TTree::SetCacheSize will no longer reset the list of branches to be; cached (either set or previously learnt) nor restart the learning phase.; The learning phase is restarted when a new cache is created",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:13869,variab,variable,13869,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['variab'],['variable']
Modifiability," offset; | 0x........ | uint32_t HashData[3] DIE offset; | 0x00002023 | uint32_t KeyType (.debug_str[0x0002023] => ""print""); | 0x00000002 | uint32_t HashData count; | 0x........ | uint32_t HashData[0] DIE offset; | 0x........ | uint32_t HashData[1] DIE offset; | 0x00000000 | uint32_t KeyType (end of hash chain); `------------'. Current testing with real world C++ binaries has shown that there is around 1; 32 bit hash collision per 100,000 name entries. Contents; ^^^^^^^^. As we said, we want to strictly define exactly what is included in the; different tables. For DWARF, we have 3 tables: ""``.apple_names``"",; ""``.apple_types``"", and ""``.apple_namespaces``"". ""``.apple_names``"" sections should contain an entry for each DWARF DIE whose; ``DW_TAG`` is a ``DW_TAG_label``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_subprogram`` that has address attributes: ``DW_AT_low_pc``,; ``DW_AT_high_pc``, ``DW_AT_ranges`` or ``DW_AT_entry_pc``. It also contains; ``DW_TAG_variable`` DIEs that have a ``DW_OP_addr`` in the location (global and; static variables). All global and static variables should be included,; including those scoped within functions and classes. For example using the; following code:. .. code-block:: c. static int var = 0;. void f (); {; static int var = 0;; }. Both of the static ``var`` variables would be included in the table. All; functions should emit both their full names and their basenames. For C or C++,; the full name is the mangled name (if available) which is usually in the; ``DW_AT_MIPS_linkage_name`` attribute, and the ``DW_AT_name`` contains the; function basename. If global or static variables have a mangled name in a; ``DW_AT_MIPS_linkage_name`` attribute, this should be emitted along with the; simple name found in the ``DW_AT_name`` attribute. ""``.apple_types``"" sections should contain an entry for each DWARF DIE whose; tag is one of:. * DW_TAG_array_type; * DW_TAG_class_type; * DW_TAG_enumeration_type; * DW_TAG_pointer_type; * DW_TAG_reference_typ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:77707,variab,variables,77707,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability," on block capture and destruction. It; also affects C++ features such as lambda capture, ``decltype``, and template; argument deduction. Implicitly, the implementation assumes that the :ref:`self parameter in a; non-init method <arc.misc.self>` and the :ref:`variable in a for-in loop; <arc.misc.enumeration>` are externally-retained. Externally-retained semantics can also be opted into with the; ``objc_externally_retained`` attribute. This attribute can apply to strong local; variables, functions, methods, or blocks:. .. code-block:: objc. @class WobbleAmount;. @interface Widget : NSObject; -(void)wobble:(WobbleAmount *)amount;; @end. @implementation Widget. -(void)wobble:(WobbleAmount *)amount; __attribute__((objc_externally_retained)) {; // 'amount' and 'alias' aren't retained on entry, nor released on exit.; __attribute__((objc_externally_retained)) WobbleAmount *alias = amount;; }; @end. Annotating a function with this attribute makes every parameter with strong; retainable object pointer type externally-retained, unless the variable was; explicitly qualified with ``__strong``. For instance, ``first_param`` is; externally-retained (and therefore ``const``) below, but not ``second_param``:. .. code-block:: objc. __attribute__((objc_externally_retained)); void f(NSArray *first_param, __strong NSArray *second_param) {; // ...; }. You can test if your compiler has support for ``objc_externally_retained`` with; ``__has_attribute``:. .. code-block:: objc. #if __has_attribute(objc_externally_retained); // Use externally retained...; #endif. .. _arc.misc.self:. ``self``; --------. The ``self`` parameter variable of an non-init Objective-C method is considered; :ref:`externally-retained <arc.misc.externally_retained>` by the implementation.; It is undefined behavior, or at least dangerous, to cause an object to be; deallocated during a message send to that object. In an init method, ``self``; follows the :ref:``init family rules <arc.family.semantics.init>``. .. admonitio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:93631,variab,variable,93631,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability," on each iteration. If the struct were 8 bytes, this gets turned into; a memset. In order to handle this we have to:; A) Teach clang to generate metadata for memsets of structs that have holes in; them.; B) Teach clang to use such a memset for zero init of this struct (since it has; a hole), instead of doing elementwise zeroing. //===---------------------------------------------------------------------===//. clang -O3 currently compiles this code:. extern const int magic;; double f() { return 0.0 * magic; }. into. @magic = external constant i32. define double @_Z1fv() nounwind readnone {; entry:; %tmp = load i32* @magic, align 4, !tbaa !0; %conv = sitofp i32 %tmp to double; %mul = fmul double %conv, 0.000000e+00; ret double %mul; }. We should be able to fold away this fmul to 0.0. More generally, fmul(x,0.0); can be folded to 0.0 if we can prove that the LHS is not -0.0, not a NaN, and; not an INF. The CannotBeNegativeZero predicate in value tracking should be; extended to support general ""fpclassify"" operations that can return ; yes/no/unknown for each of these predicates. In this predicate, we know that uitofp is trivially never NaN or -0.0, and; we know that it isn't +/-Inf if the floating point type has enough exponent bits; to represent the largest integer value as < inf. //===---------------------------------------------------------------------===//. When optimizing a transformation that can change the sign of 0.0 (such as the; 0.0*val -> 0.0 transformation above), it might be provable that the sign of the; expression doesn't matter. For example, by the above rules, we can't transform; fmul(sitofp(x), 0.0) into 0.0, because x might be -1 and the result of the; expression is defined to be -0.0. If we look at the uses of the fmul for example, we might be able to prove that; all uses don't care about the sign of zero. For example, if we have:. fadd(fmul(sitofp(x), 0.0), 2.0). Since we know that x+2.0 doesn't care about the sign of any zeros in X, we can; transform",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:60963,extend,extended,60963,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['extend'],['extended']
Modifiability," on the command-line, but addresses; are, the first address value is treated as an input name. If an input value is not; recognized, it reports that source information is not found. Input names can be specified together with the addresses either on standard; input or as positional arguments on the command-line. By default, input names; are interpreted as object file paths. However, prefixing a name with; ``BUILDID:`` states that it is a hex build ID rather than a path. This will look; up the corresponding debug binary. For consistency, prefixing a name with; ``FILE:`` explicitly states that it is an object file path (the default). A positional argument or standard input value can be preceded by ""DATA"" or; ""CODE"" to indicate that the address should be symbolized as data or executable; code respectively. If neither is specified, ""CODE"" is assumed. DATA is; symbolized as address and symbol size rather than line number. :program:`llvm-symbolizer` parses options from the environment variable; ``LLVM_SYMBOLIZER_OPTS`` after parsing options from the command line.; ``LLVM_SYMBOLIZER_OPTS`` is primarily useful for supplementing the command-line; options when :program:`llvm-symbolizer` is invoked by another program or; runtime. EXAMPLES; --------. All of the following examples use the following two source files as input. They; use a mixture of C-style and C++-style linkage to illustrate how these names are; printed differently (see :option:`--demangle`). .. code-block:: c. // test.h; extern ""C"" inline int foz() {; return 1234;; }. .. code-block:: c. // test.cpp; #include ""test.h""; int bar=42;. int foo() {; return bar;; }. int baz() {; volatile int k = 42;; return foz() + k;; }. int main() {; return foo() + baz();; }. These files are built as follows:. .. code-block:: console. $ clang -g test.cpp -o test.elf; $ clang -g -O2 test.cpp -o inlined.elf. Example 1 - addresses and object on command-line:. .. code-block:: console. $ llvm-symbolizer --obj=test.elf 0x4004d0 0x400490; foz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:1702,variab,variable,1702,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['variab'],['variable']
Modifiability," one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:19411,variab,variables,19411,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability," only if the build; process respects the `CC` and `CXX` environment variables. (Some build; process can override these variable as command line parameter only. This case; you need to pass the compiler wrappers manually. eg.: `intercept-build; --override-compiler make CC=intercept-cc CXX=intercept-c++ all` where the; original build command would have been `make all` only.). The 1. runs the analyzer right after the real compilation. So, if the build; process removes removes intermediate modules (generated sources) the analyzer; output still kept. The 2. and 3. generate the compilation database first, and filters out those; modules which are not exists. So, it's suitable for incremental analysis during; the development. The 2. mode is available only on FreeBSD and Linux. Where library preload; is available from the dynamic loader. Not supported on OS X (unless System; Integrity Protection feature is turned off). `intercept-build` command uses only the 2. and 3. mode to generate the; compilation database. `analyze-build` does only run the analyzer against the; captured compiler calls. Known problems; --------------. Because it uses `LD_PRELOAD` or `DYLD_INSERT_LIBRARIES` environment variables,; it does not append to it, but overrides it. So builds which are using these; variables might not work. (I don't know any build tool which does that, but; please let me know if you do.). Problem reports; ---------------. If you find a bug in this documentation or elsewhere in the program or would; like to propose an improvement, please use the project's [issue tracker][3].; Please describing the bug and where you found it. If you have a suggestion; how to fix it, include that as well. Patches are also welcome. License; -------. The project is licensed under Apache-2.0 with LLVM exceptions.; See LICENSE.TXT for details. [1]: http://clang.llvm.org/docs/JSONCompilationDatabase.html; [2]: https://pypi.python.org/pypi/scan-build; [3]: https://llvm.org/bugs/enter_bug.cgi?product=clang; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md:4152,variab,variables,4152,interpreter/llvm-project/clang/tools/scan-build-py/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md,2,['variab'],['variables']
Modifiability," operand (when; the bit is 1) or an encoding operand (when the bit is 0). #. Literal operands --- :raw-html:`<tt>` [1\ :sub:`1`, litvalue\; :sub:`vbr8`] :raw-html:`</tt>` --- Literal operands specify that the value in; the result is always a single specific value. This specific value is emitted; as a vbr8 after the bit indicating that it is a literal operand. #. Encoding info without data --- :raw-html:`<tt>` [0\ :sub:`1`, encoding\; :sub:`3`] :raw-html:`</tt>` --- Operand encodings that do not have extra data; are just emitted as their code. #. Encoding info with data --- :raw-html:`<tt>` [0\ :sub:`1`, encoding\; :sub:`3`, value\ :sub:`vbr5`] :raw-html:`</tt>` --- Operand encodings that do; have extra data are emitted as their code, followed by the extra data. The possible operand encodings are:. * Fixed (code 1): The field should be emitted as a `fixed-width value`_, whose; width is specified by the operand's extra data. * VBR (code 2): The field should be emitted as a `variable-width value`_, whose; width is specified by the operand's extra data. * Array (code 3): This field is an array of values. The array operand has no; extra data, but expects another operand to follow it, indicating the element; type of the array. When reading an array in an abbreviated record, the first; integer is a vbr6 that indicates the array length, followed by the encoded; elements of the array. An array may only occur as the last operand of an; abbreviation (except for the one final operand that gives the array's; type). * Char6 (code 4): This field should be emitted as a `char6-encoded value`_.; This operand type takes no extra data. Char6 encoding is normally used as an; array element type. * Blob (code 5): This field is emitted as a vbr6, followed by padding to a; 32-bit boundary (for alignment) and an array of 8-bit objects. The array of; bytes is further followed by tail padding to ensure that its total length is a; multiple of 4 bytes. This makes it very efficient for the reader ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:13591,variab,variable-width,13591,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable-width']
Modifiability," optimization; pass named ""mem2reg"" that handles this case, promoting allocas like this; into SSA registers, inserting Phi nodes as appropriate. If you run this; example through the pass, for example, you'll get:. .. code-block:: bash. $ llvm-as < example.ll | opt -passes=mem2reg | llvm-dis; @G = weak global i32 0; @H = weak global i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.01; }. The mem2reg pass implements the standard ""iterated dominance frontier""; algorithm for constructing SSA form and has a number of optimizations; that speed up (very common) degenerate cases. The mem2reg optimization; pass is the answer to dealing with mutable variables, and we highly; recommend that you depend on it. Note that mem2reg only works on; variables in certain circumstances:. #. mem2reg is alloca-driven: it looks for allocas and if it can handle; them, it promotes them. It does not apply to global variables or heap; allocations.; #. mem2reg only looks for alloca instructions in the entry block of the; function. Being in the entry block guarantees that the alloca is only; executed once, which makes analysis simpler.; #. mem2reg only promotes allocas whose uses are direct loads and stores.; If the address of the stack object is passed to a function, or if any; funny pointer arithmetic is involved, the alloca will not be; promoted.; #. mem2reg only works on allocas of `first; class <../../LangRef.html#first-class-types>`_ values (such as pointers,; scalars and vectors), and only if the array size of the allocation is; 1 (or missing in the .ll file). mem2reg is not capable of promoting; structs or arrays to registers. Note that the ""sroa"" pass is; more powerful and can promote structs, ""unions"", and arrays in many; cases. All",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:7717,variab,variables,7717,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability," option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that representation directly. Thus, a module's headers will only be parsed once per language configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:13964,config,configuration,13964,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['config'],['configuration']
Modifiability," or expression of Block type may be; messaged or used as a parameter wherever an id may be. The converse is; also true. Block references may thus appear as properties and are; subject to the assign, retain, and copy attribute logic that is; reserved for objects. All Blocks are constructed to be Objective-C objects regardless of; whether the Objective-C runtime is operational in the program or; not. Blocks using automatic (stack) memory are objects and may be; messaged, although they may not be assigned into ``__weak`` locations; if garbage collection is enabled. Within a Block literal expression within a method definition; references to instance variables are also imported into the lexical; scope of the compound statement. These variables are implicitly; qualified as references from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains all objects held in; variables of automatic storage referenced within the Block expression; (or form strong references if running under garbage collection).; Object variables of ``__block`` storage type are assumed to hold; normal pointers with no provision for retain and release messages. Foundation defines (and supplies) ``-copy`` and ``-release`` methods for; Blocks. In the Objective-C and Objective-C++ languages, we allow the; ``__weak`` specifier for ``__block`` variables of object type. If; garbage collection is not enabled, this qualifier causes these; variables to be kept without retain messages being sent. This; knowingly leads to dangling pointers if the Block (or a copy) outlives; the lifetime of this object. In garbage collected environments, the ``__weak`` variable is set to; nil when the object it references is collected, as long as the; ``__block`` variable resides in the heap (either by default or via; ``Block_copy()``). The initial Apple implementation does in fact; start ``__block`` variables on the stack and migrate them",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:9720,variab,variables,9720,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variables']
Modifiability," or in; your cloud's image repository. > For convenience we provide the direct link for the working versions:; >; > - [CernVM 2.7.1 batch 64-bit for; > **KVM**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.hdd.gz); >; > - [CernVM 2.7.1 batch 64-bit for; > **Xen**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.ext3.gz); >; > Images are gzipped. In most cases you'll need to gunzip them before; > registering to your image repository. ### Create VM configuration profiles. CernVM images are base images supporting boot-time customization via; configuration profiles called ""contexts"". Context creation can be; performed through the [CernVM Online](https://cernvm-online.cern.ch/); website. The site is immediately accessible if you have a CERN account. Go to your [CernVM Online; Dashboard](https://cernvm-online.cern.ch/dashboard), click on the; **Create new context...** dropdown and select **Virtual Analysis Facility; node**. There's only a few parameters to configure. Context name; : A name for your context (such as *VAF Master for ATLAS*). Any name; will work. Role; : Use this to configure either a *master* or a *slave*. VAF master (only available when configuring a slave); : IP address or FQDN of the Virtual Analysis Facility master. Auth method; : Choose between *ALICE LDAP* (useful only for ALICE users) or *Pool; accounts* (good for authenticating all the other Grid users). Num. pool accounts (only available when using pool accounts auth); : Number of pool accounts to create. Proxy for CVMFS; : An URL specifying the proxy server for CernVM-FS, such as; `http://ca-proxy.cern.ch:3128/`. If you leave it empty, proxy will; be automatically discovered. HTCondor shared secret; : VMs part of the same cluster should have the same value of this; field. It is used to mutually authenticate VMs and it is used like a; password. Context password; : Current profile will be saved on the [CernVM Online; repository](http://cernvm-online.cer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:2145,config,configure,2145,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['config'],['configure']
Modifiability, or the GNU Lesser General Public License. See; # LICENSE.TXT for details.; #------------------------------------------------------------------------------. # Keep symbols for JIT resolution; set(LLVM_NO_DEAD_STRIP 1). set(LLVM_LINK_COMPONENTS Support); if(BUILD_SHARED_LIBS); set(LIBS. clangFrontendTool. clingInterpreter; clingMetaProcessor; clingUserInterface; clingUtils; ); add_cling_executable(cling; cling.cpp; ); else(); set(LIBS; clangASTMatchers; clangFrontendTool. clingUserInterface; ); add_cling_executable(cling; cling.cpp; $<TARGET_OBJECTS:obj.clingInterpreter>; $<TARGET_OBJECTS:obj.clingMetaProcessor>; $<TARGET_OBJECTS:obj.clingUtils>; ); endif(BUILD_SHARED_LIBS). set_target_properties(cling; PROPERTIES ENABLE_EXPORTS 1). if(MSVC); set_target_properties(cling PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS 1). # RTTI/C++ symbols; set(cling_exports ${cling_exports} ??_7type_info@@6B@; ?__type_info_root_node@@3U__type_info_node@@A; ?nothrow@std@@3Unothrow_t@1@B; ). # Compiler added symbols for static variables. NOT for VStudio < 2015; set(cling_exports ${cling_exports} _Init_thread_abort _Init_thread_epoch; _Init_thread_footer _Init_thread_header _tls_index; ). if(CMAKE_SIZEOF_VOID_P EQUAL 8); # new/delete variants needed when linking to static msvc runtime (esp. Debug); set(cling_exports ${cling_exports}; ??2@YAPEAX_K@Z; ??3@YAXPEAX@Z; ??_U@YAPEAX_K@Z; ??_V@YAXPEAX@Z; ??3@YAXPEAX_K@Z; ??2@YAPEAX_KAEBUnothrow_t@std@@@Z; ??_U@YAPEAX_KAEBUnothrow_t@std@@@Z; ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z; ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z; ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z; ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z; ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z; ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z; ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@P,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/driver/CMakeLists.txt:1258,variab,variables,1258,interpreter/cling/tools/driver/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/driver/CMakeLists.txt,1,['variab'],['variables']
Modifiability," or to the FDEs that use it. The version number; conforms to [SEMVER]_. 2. ``address_size`` for the ``Global`` address space is defined in; :ref:`amdgpu-dwarf-address-space-identifier`. 3. ``segment_selector_size`` is 0 as AMDGPU does not use a segment selector. 4. ``code_alignment_factor`` is 4 bytes. .. TODO::. Add to :ref:`amdgpu-processor-table` table. 5. ``data_alignment_factor`` is 4 bytes. .. TODO::. Add to :ref:`amdgpu-processor-table` table. 6. ``return_address_register`` is ``PC_32`` for 32-bit processes and ``PC_64``; for 64-bit processes defined in :ref:`amdgpu-dwarf-register-identifier`. 7. ``initial_instructions`` Since a subprogram X with fewer registers can be; called from subprogram Y that has more allocated, X will not change any of; the extra registers as it cannot access them. Therefore, the default rule; for all columns is ``same value``. For AMDGPU the register number follows the numbering defined in; :ref:`amdgpu-dwarf-register-identifier`. For AMDGPU the instructions are variable size. A consumer can subtract 1 from; the return address to get the address of a byte within the call site; instructions. See DWARF Version 5 section 6.4.4. Accelerated Access; ------------------. See DWARF Version 5 section 6.1. Lookup By Name Section Header; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. See DWARF Version 5 section 6.1.1.4.1 and :ref:`amdgpu-dwarf-lookup-by-name`. For AMDGPU the lookup by name section header table:. ``augmentation_string_size`` (uword). Set to the length of the ``augmentation_string`` value which is always a; multiple of 4. ``augmentation_string`` (sequence of UTF-8 characters). Contains the following UTF-8 string null padded to a multiple of 4 bytes:. ::. [amdgpu:v0.0]. The ""vX.Y"" specifies the major X and minor Y version number of the AMDGPU; extensions used in the DWARF of this index. The version number conforms to; [SEMVER]_. .. note::. This is different to the DWARF Version 5 definition that requires the first; 4 characters to be the vendor ID",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:112296,variab,variable,112296,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variable']
Modifiability," other compiler systems, which do try to version memory; objects. In LLVM, instead of encoding dataflow analysis of memory into; the LLVM IR, it is handled with `Analysis; Passes <../../WritingAnLLVMPass.html>`_ which are computed on demand. With this in mind, the high-level idea is that we want to make a stack; variable (which lives in memory, because it is on the stack) for each; mutable object in a function. To take advantage of this trick, we need; to talk about how LLVM represents stack variables. In LLVM, all memory accesses are explicit with load/store instructions,; and it is carefully designed not to have (or need) an ""address-of""; operator. Notice how the type of the @G/@H global variables is actually; ""i32\*"" even though the variable is defined as ""i32"". What this means is; that @G defines *space* for an i32 in the global data area, but its; *name* actually refers to the address for that space. Stack variables; work the same way, except that instead of being declared with global; variable definitions, they are declared with the `LLVM alloca; instruction <../../LangRef.html#alloca-instruction>`_:. .. code-block:: llvm. define i32 @example() {; entry:; %X = alloca i32 ; type of %X is i32*.; ...; %tmp = load i32, i32* %X ; load the stack value %X from the stack.; %tmp2 = add i32 %tmp, 1 ; increment it; store i32 %tmp2, i32* %X ; store it back; ... This code shows an example of how you can declare and manipulate a stack; variable in the LLVM IR. Stack memory allocated with the alloca; instruction is fully general: you can pass the address of the stack slot; to functions, you can store it in other variables, etc. In our example; above, we could rewrite the example to use the alloca technique to avoid; using a PHI node:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; %X = alloca i32 ; type of %X is i32*.; br i1 %Condition, label %cond_true, label %cond_fal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:4744,variab,variables,4744,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,2,['variab'],"['variable', 'variables']"
Modifiability," other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function prototypes are considered ABI-visible. All ABI-visible pointers are treated as ``__single`` by default unless annotated; otherwise. This default both preserves ABI and makes these pointers safe by; default. This behavior can be controlled with macros, i.e.,; ``__ptrcheck_abi_assume_*ATTR*()``, to set the default annotation for; ABI-visible pointers to be either ``__single``, ``__bidi_indexable``,; ``__indexable``, or ``__unsafe_indexable``. For instance,; ``__ptrcheck_abi_assume_unsafe_indexable()`` will make all ABI-visible pointers; be ``__unsafe_indexable``. Non-ABI visible pointers — the outermost pointer; types of local variables — are ``__bidi_indexable`` by default, so that these; pointers have the bounds information necessary to perform bounds checks without; the need for a manual annotation. All ``const char`` pointers or any typedefs; equivalent to ``const char`` pointers are ``__null_terminated`` by default. This; means that ``char8_t`` is ``unsigned char`` so ``const char8_t *`` won't be; ``__null_terminated`` by default. Similarly, ``const wchar_t *`` won't be; ``__null_terminated`` by default unless the platform defines it as ``typedef; char wchar_t``. Please note, however, that the programmers can still explicitly; use ``__null_terminated`` in any other pointers, e.g., ``char8_t; *__null_terminated``, ``wchar_t *__null_terminated``, ``int; *__null_terminated``, etc. if they should be treated as ``__null_terminated``.; The same applies to other annotations.; In system headers, the default pointer attribute for ABI-visible pointers is set; to ``__unsafe_indexable`` by default. The ``__ptrcheck_abi_assume_*ATTR*()`` macros are defined as pragmas in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:21767,variab,variables,21767,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variables']
Modifiability," other nodes:. ``` {.cpp}; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); ```. The last method allows replacing an existing daughter of a volume with; another one. Providing only the node to be replaced will just create a; new volume for the node but having exactly the same parameters as the; old one. This helps in case of divisions for decoupling a node from the; logical hierarchy so getting new content/properties. For non-divided; volumes, one can change the shape and/or the position of the daughter. #### Virtual Containers and Assemblies of Volumes. Virtual containers are volumes that do not represent real objects, but; they are needed for grouping and positioning together other volumes.; Such grouping helps not only geometry creation, but also optimizes; tracking performance; therefore, it is highly recommended. Virtual; volumes need to inherit material/medium properties from the volume they; are placed into in order to be ""invisible"" at tracking time. Let us suppose that we need to group together two volumes `A` and `B`; into a structure and position this into several other volumes `D,E,` and; `F`. What we need to do is to create a virtual container volume `C`; holding `A` and `B`, then position `C` in the other volumes. Note that `C` is a volume having a determined medium. Since it is not a; real volume, we need to manually set its medium the same as that of; `D,E` or `F` in order to make it ‘invisible' (same physics properties).; In other words, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C'`; and `C""`, having the same shape but different media matching the; corresponding containers. This might not happen so often, but when it; does, it forces the creation of several extra virtual volumes. Other; limitation com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:69945,inherit,inherit,69945,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['inherit'],['inherit']
Modifiability," outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger alignment on these variables. The maximum alignment; is ``1 << 32``. For global variable declarations, as well as definitions that may be; replaced at link time (``linkonce``, ``weak``, ``extern_weak`` and ``common``; linkage types), the allocation size and alignment of the definition it resolves; to must be greater than or equal to that of the declaration or replaceable; definition, otherwise the behavior is undefined. Globals can also have a :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`runtime preemption specifier <runtime_preemption_model>`,; an optional :ref:`global attributes <glattrs>` and; an optional list of attached :ref:`metadata <metadata>`. Variables and aliases can have a; :ref:`Thread Local Storage Model <tls_model>`. Globals cannot be or contain :ref:`Scalable vectors <t_vector>` because their; size is unknown at compile time. They are allowed in structs to facilitate; intrinsics returning multiple values. Generally, structs containing scalabl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:35204,variab,variables,35204,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability," overlap, then the scalar version; of the loop is executed. .. code-block:: c++. void bar(float *A, float* B, float K, int n) {; for (int i = 0; i < n; ++i); A[i] *= B[i] + K;; }. Reductions; ^^^^^^^^^^. In this example the ``sum`` variable is used by consecutive iterations of; the loop. Normally, this would prevent vectorization, but the vectorizer can; detect that 'sum' is a reduction variable. The variable 'sum' becomes a vector; of integers, and at the end of the loop the elements of the array are added; together to create the correct result. We support a number of different; reduction operations, such as addition, multiplication, XOR, AND and OR. .. code-block:: c++. int foo(int *A, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); sum += A[i] + 5;; return sum;; }. We support floating point reduction operations when `-ffast-math` is used. Inductions; ^^^^^^^^^^. In this example the value of the induction variable ``i`` is saved into an; array. The Loop Vectorizer knows to vectorize induction variables. .. code-block:: c++. void bar(float *A, int n) {; for (int i = 0; i < n; ++i); A[i] = i;; }. If Conversion; ^^^^^^^^^^^^^. The Loop Vectorizer is able to ""flatten"" the IF statement in the code and; generate a single stream of instructions. The Loop Vectorizer supports any; control flow in the innermost loop. The innermost loop may contain complex; nesting of IFs, ELSEs and even GOTOs. .. code-block:: c++. int foo(int *A, int *B, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); if (A[i] > B[i]); sum += A[i] + 5;; return sum;; }. Pointer Induction Variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. This example uses the ""accumulate"" function of the standard c++ library. This; loop uses C++ iterators, which are pointers, and not integer indices.; The Loop Vectorizer detects pointer induction variables and can vectorize; this loop. This feature is important because many C++ programs use iterators. .. code-block:: c++. int baz(int *A, int n) {; return std::accumu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:6649,variab,variables,6649,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['variab'],['variables']
Modifiability," parent scope; containing the lambda signature. Possible values:. * ``LBI_Signature`` (in configuration: ``Signature``); Align lambda body relative to the lambda signature. This is the default. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. * ``LBI_OuterScope`` (in configuration: ``OuterScope``); For statements within block scope, align lambda body relative to the; indentation level of the outer scope the lambda signature resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83399,config,configuration,83399,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," passed through; the ""variable argument"" area of a function call. It is used to implement; the ``va_arg`` macro in C. Arguments:; """""""""""""""""""". This instruction takes a ``va_list*`` value and the type of the; argument. It returns a value of the specified argument type and; increments the ``va_list`` to point to the next argument. The actual; type of ``va_list`` is target specific. Semantics:; """""""""""""""""""". The '``va_arg``' instruction loads an argument of the specified type; from the specified ``va_list`` and causes the ``va_list`` to point to; the next argument. For more information, see the variable argument; handling :ref:`Intrinsic Functions <int_varargs>`. It is legal for this instruction to be called in a function which does; not take a variable number of arguments, for example, the ``vfprintf``; function. ``va_arg`` is an LLVM instruction instead of an :ref:`intrinsic; function <intrinsics>` because it takes a type as an argument. Example:; """""""""""""""". See the :ref:`variable argument processing <int_varargs>` section. Note that the code generator does not yet fully support va\_arg on many; targets. Also, it does not currently support va\_arg with aggregate; types on any target. .. _i_landingpad:. '``landingpad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = landingpad <resultty> <clause>+; <resultval> = landingpad <resultty> cleanup <clause>*. <clause> := catch <type> <value>; <clause> := filter <array constant type> <array constant>. Overview:; """""""""""""""""". The '``landingpad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.html#overview>`_ to specify that a basic block; is a landing pad --- one where the exception lands, and corresponds to the; code found in the ``catch`` portion of a ``try``/``catch`` sequence. It; defines values supplied by the :ref:`personality function <personalityfn>` upon; re-entry to the function. The ``resultval`` has the type ``resultty``. Arguments:; """""""""""""""""""". The optional; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:480227,variab,variable,480227,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," path entry per linked module with summary. Example:. .. code-block:: text. ^0 = module: (path: ""/path/to/file.o"", hash: (2468601609, 1329373163, 1565878005, 638838075, 3148790418)). The ``path`` field is a string path to the bitcode file, and the ``hash``; field is the 160-bit SHA-1 hash of the IR bitcode contents, used for; incremental builds and caching. .. _gv_summary:. Global Value Summary Entry; --------------------------. Each global value summary entry corresponds to a global value defined or; referenced by a summarized module. Example:. .. code-block:: text. ^4 = gv: (name: ""f""[, summaries: (Summary)[, (Summary)]*]?) ; guid = 14740650423002898831. For declarations, there will not be a summary list. For definitions, a; global value will contain a list of summaries, one per module containing; a definition. There can be multiple entries in a combined summary index; for symbols with weak linkage. Each ``Summary`` format will depend on whether the global value is a; :ref:`function<function_summary>`, :ref:`variable<variable_summary>`, or; :ref:`alias<alias_summary>`. .. _function_summary:. Function Summary; ^^^^^^^^^^^^^^^^. If the global value is a function, the ``Summary`` entry will look like:. .. code-block:: text. function: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), insts: 2[, FuncFlags]?[, Calls]?[, TypeIdInfo]?[, Params]?[, Refs]?. The ``module`` field includes the summary entry id for the module containing; this definition, and the ``flags`` field contains information such as; the linkage type, a flag indicating whether it is legal to import the; definition, whether it is globally live and whether the linker resolved it; to a local definition (the latter two are populated during the thin link).; The ``insts`` field contains the number of IR instructions in the function.; Finally, there are several optional fields: :ref:`FuncFlags<funcflags_summary>`,; :ref:`Calls<calls_summary>`, :ref:`TypeIdInfo<typeidinfo_summ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:341254,variab,variable,341254,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," path to GnuWin32 tools for tests. Valid on Windows host. Defaults to; the empty string, in which case lit will look for tools needed for tests; (e.g. ``grep``, ``sort``, etc.) in your %PATH%. If GnuWin32 is not in your; %PATH%, then you can set this variable to the GnuWin32 directory so that; lit can find tools needed for tests in that directory. **LLVM_NATIVE_TOOL_DIR**:STRING; Full path to a directory containing executables for the build host; (containing binaries such as ``llvm-tblgen`` and ``clang-tblgen``). This is; intended for cross-compiling: if the user sets this variable and the; directory contains executables with the expected names, no separate; native versions of those executables will be built. **LLVM_NO_INSTALL_NAME_DIR_FOR_BUILD_TREE**:BOOL; Defaults to ``OFF``. If set to ``ON``, CMake's default logic for library IDs; on Darwin in the build tree will be used. Otherwise the install-time library; IDs will be used in the build tree as well. Mainly useful when other CMake; library ID control variables (e.g., ``CMAKE_INSTALL_NAME_DIR``) are being; set to non-standard values. **LLVM_OPTIMIZED_TABLEGEN**:BOOL; If enabled and building a debug or asserts build the CMake build system will; generate a Release build tree to build a fully optimized tablegen for use; during the build. Enabling this option can significantly speed up build times; especially when building LLVM in Debug configurations. **LLVM_PARALLEL_COMPILE_JOBS**:STRING; Define the maximum number of concurrent compilation jobs. **LLVM_PARALLEL_LINK_JOBS**:STRING; Define the maximum number of concurrent link jobs. **LLVM_RAM_PER_COMPILE_JOB**:STRING; Calculates the amount of Ninja compile jobs according to available resources.; Value has to be in MB, overwrites LLVM_PARALLEL_COMPILE_JOBS. Compile jobs ; will be between one and amount of logical cores. **LLVM_RAM_PER_LINK_JOB**:STRING; Calculates the amount of Ninja link jobs according to available resources.; Value has to be in MB, overwrites LLVM_P",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:31990,variab,variables,31990,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability," pattern follows a strict insert-then-query approach, you can; trivially use the same approach as :ref:`sorted vectors for set-like containers; <dss_sortedvectorset>`. The only difference is that your query function (which; uses std::lower_bound to get efficient log(n) lookup) should only compare the; key, not both the key and value. This yields the same advantages as sorted; vectors for sets. .. _dss_stringmap:. llvm/ADT/StringMap.h; ^^^^^^^^^^^^^^^^^^^^. Strings are commonly used as keys in maps, and they are difficult to support; efficiently: they are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking up a value (even when hash collisions happen),; hash table growth does not recompute the hash values for strings already in the; table, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:89037,variab,variable,89037,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability," performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31257,config,config,31257,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['config']
Modifiability," pi = make_unique<int>();; Borrow(pi);; if (smth) {; pi = make_unique<int>();; Borrow(pi);; }; }; ```. In the following example, the raw pointer is used to access the heap object; after the ownership has been transferred. ```c++; void UniqueOwnership3() {; int *pi = new int; // pi is Defined; if (...) {; Borrow(pi);; delete pi; // pi is Compatible; } else {; vector<unique_ptr<int>> v = {std::unique_ptr(pi)}; // pi is Compatible; print(*pi);; use(v);; }; // pi is Compatible; }; ```. We can refactor this code to use `unique_ptr`, however we would have to; introduce a non-owning pointer variable, since we can't use the moved-from; `unique_ptr` to access the object:. ```c++; void UniqueOwnership3() {; std::unique_ptr<int> pi = std::make_unique<int>();; if (...) {; Borrow(pi);; } else {; int *pi_non_owning = pi.get();; vector<unique_ptr<int>> v = {std::move(pi)};; print(*pi_non_owning);; use(v);; }; }; ```. If the original code didn't call `delete` at the very end of the function, then; our refactoring may change the point at which we run the destructor and release; memory. Specifically, if there is some user code after `delete`, then extending; the lifetime of the object until the end of the function may hold locks for; longer than necessary, introduce memory overhead etc. One solution is to always replace `delete` with a call to `reset()`, and then; perform another analysis that removes unnecessary `reset()` calls. ```c++; void AddedMemoryOverhead() {; HugeObject *ho = new HugeObject();; use(ho);; delete ho; // Release the large amount of memory quickly.; LongRunningFunction();; }; ```. This analysis will refuse to refactor code that mixes borrowed pointer values; and unique ownership. In the following code, `GetPtr()` returns a borrowed; pointer, which is assigned to `pi`. Then, `pi` is used to hold a uniquely-owned; pointer. We don't distinguish between these two assignments, and we want each; assignment to be paired with a corresponding sink; otherwise, we transitio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:24200,refactor,refactoring,24200,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactoring']
Modifiability," placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; the lists of names lexicographically, and within those groups, names are; in case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::chrono::duration_cast;; using std::move;; using std::string;. * ``SUD_LexicographicNumeric`` (in configuration: ``LexicographicNumeric``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. The; last element of each list is a non-namespace name; all others are; namespace names. Sort the lists of names lexicographically, where the; sort order of individual names is that all non-namespace names come; before all namespace names, and within those groups, names are in; case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::move;; using st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:111122,config,configuration,111122,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," point and; create the PHI node for the loop induction variable. Since we already; know the incoming value for the starting value, we add it to the Phi; node. Note that the Phi will eventually get a second value for the; backedge, but we can't set it up yet (because it doesn't exist!). .. code-block:: c++. // Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.; Value *OldVal = NamedValues[VarName];; NamedValues[VarName] = Variable;. // Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.; if (!Body->codegen()); return nullptr;. Now the code starts to get more interesting. Our 'for' loop introduces a; new variable to the symbol table. This means that our symbol table can; now contain either function arguments or loop variables. To handle this,; before we codegen the body of the loop, we add the loop variable as the; current value for its name. Note that it is possible that there is a; variable of the same name in the outer scope. It would be easy to make; this an error (emit an error and return null if there is already an; entry for VarName) but we choose to allow shadowing of variables. In; order to handle this correctly, we remember the Value that we are; potentially shadowing in ``OldVal`` (which will be null if there is no; shadowed variable). Once the loop variable is set into the symbol table, the code; recursively codegen's the body. This allows the body to use the loop; variable: any references to it will naturally find it in the symbol; table. .. code-block:: c++. // Emit the step value.; Value *StepVal = nullptr;; if (Step) {; StepVal = Step->codegen();; if (!StepVal); return nullptr;; } else {; // If not specified, use 1.0.; StepVal = ConstantFP::get(*TheContext, APFloat(1.0));; }. Value *NextVar = Builder->CreateFAdd(Variable, StepVal, ""nextvar"");. Now t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:23116,variab,variable,23116,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability," pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25894,variab,variables,25894,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability," points. Then the user would write a; $\mbox{FCN}$ which calculates the $\chi^2$ between a polynomial and; the data; the variable parameters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the user would request M to minimize the $\mbox{FCN}$ with respect; to the parameters, that is, find those values of the coefficients which; give the lowest value of chisquare. The user must therefore supply, in addition to the function to be; analyzed, via a set or sequence of M applications the instructions which; analysis is wanted. The instructions are coded in in the calling program; (main.cpp), which allows looping, conditional execution, and all the; other possibilities of , but not interactivity, since it must be; compiled before execution. ## Design aspects of M in ##. What M is:. - platform independent. - written in an object-oriented way using standard. - independent of any external package. The maintainability should be guaranteed with the choice of a modern; computer language. Choosing object-oriented technology M should profit; from an increased flexibility and functionality and make it also; extendable (recursiveness, new algorithms, new functionality). What M does not:. - histogramming. - data handling. - graphics. M is kept as a low-level package with optimal performance. The main usages of M are. - from a user's program (such as int main()...). - from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provide",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:3624,maintainab,maintainability,3624,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['maintainab'],['maintainability']
Modifiability," preprocessing directive; Yes. 304; C99; Clarifying illegal tokens in #if directives; Yes. 305; C99; 6.10.1p3: Clarifying handling of keywords in #if directives; Yes. 306; C99; 6.10.3p9: Clarifying that rescanning applies to object-like macros; Yes. 307; C99; 6.10.3p10: Clarifiying arguments vs. parameters; Yes. 308; C99; Clarify that source files et al. need not be ""files""; Yes. 309; C99; Clarifying trigraph substitution; Yes. 310; C99; Add non-corner case example of trigraphs; Yes. 311; C99; Definition of variably modified types; Yes. 312; C99; Meaning of ""known constant size""; Yes. 313; NAD; Incomplete arrays of VLAs; Yes. 314; NAD; Cross-translation-unit tagged type compatibility; Unknown. 315; C99; Implementation-defined bit-field types; Yes. 316; NAD; Unprototyped function types; Yes. 317; NAD; Function definitions with empty parentheses; Yes. 318; C99; (double)0.1f with FLT_EVAL_METHOD being 2; Unknown. 319; NAD; printf(""%a"", 1.0) and trailing zeros; N/A. 320; C99; Scope of variably modified type; Yes. 321; C99; Wide character code values for members of the basic character set; Yes. 322; C99; Problem with TC2 Change #67 (Add perror to the list defining byte input/output functions); N/A. 323; C99; Potential problems with TC2 #34, #35, and #36; N/A. 324; C99; Tokenization obscurities; Yes. 325; NAD; strerror(); N/A. 326; C99; asctime(); N/A. 327; C99; Italicize definition of variable length array type, add forward references; Yes. 328; C99; String literals in compound literal initialization. Partial; Clang properly implements the use of string literals in a compound; literal initializer, but fails to diagnose use of a variably-modified; type at file scope. DR339 (about variably-modified types) is marked as; a duplicate of DR328.; . 329; C99; Math functions and directed rounding; N/A. 330; C99; Externally visible exceptional conditions; N/A. 331; NAD; permit FE_DIVBYZERO when errno says EDOM; N/A. 332; C99; gets is generally unsafe; N/A. 333; C99; Missing Predef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:19512,variab,variably,19512,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,1,['variab'],['variably']
Modifiability," processed twice or more times).; Fix problem with the transmission of non-default file; attributes (e.g. the number of entries) from TChainElement to; TDSetElement during TChain processing in PROOF; Fix problem in the default packetizer with validating the; exact number of needed files when the information about the entries is; already available.; Fix problem with 'xpd.putenv' and 'xpd.putrc' occuring when the variables themselves contain commas.; Avoid resolving the workers FQDN when running in PROOF-Lite,; creating unnecessary delays when running PROOF-Lite within virtual; machines.; Fix problem with the permissions of the user data directory.; Add files to the list of files to process only when finally validated.; Fix; problem with canvases when the feedback canvas and the final canvas are; the same (do not delete the feedback canvas at the end of processing); Make sure that TProof::Load, TProofPlayer::SendSelector and; TSelector::GetSelector treat consistently the extensions of the; implementation files.; Unlock the cache after failure to load a selector; prevents session freezing; Correctly update the number of submergers when workers die; Add missing protection causing a crash in submergers when the output list contained TProofOutputFile objects.; Move the creation and start of the idle timeout from the end; of SetupCommon to the end of CreateServer, so that the timeout is not; active during worker setup.; Make sure that the TProof instance on the client is invalidated after an idle timeout.; Fix an old issue with DeactivateWorker(""*"") (the session is; was terminated because no worker was active; this call coudl not be; used as intermediate step to select a small number of workers).; Consistently check both Proof.Sandbox and ProofLite.Sandbox for sandbox non-default location as done in TProofLite; Fix a problem with the registration of missing files in the; 'MissingFiles' list (files which could not be open on the workers were; not always added to the list). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:13238,sandbox,sandbox,13238,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['sandbox'],['sandbox']
Modifiability," program. .. parsed-literal::. *link-declaration*:; ``link`` ``framework``:sub:`opt` *string-literal*. The *string-literal* specifies the name of the library or framework against which the program should be linked. For example, specifying ""clangBasic"" would instruct the linker to link with ``-lclangBasic`` for a Unix-style linker. A *link-declaration* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46411,config,config-macros-declaration,46411,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,2,['config'],"['config-macro-list', 'config-macros-declaration']"
Modifiability," programs in the process. As a result,; clang-proto-fuzzer is better at stressing deeper layers of Clang and LLVM. Some of the fuzzers have example corpuses inside the corpus_examples directory. ===================================; Building clang-fuzzer; ===================================; Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address. Then build the clang-fuzzer target. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZE_COVERAGE=YES -DLLVM_USE_SANITIZER=Address; ninja clang-fuzzer. ======================; Running clang-fuzzer; ======================; bin/clang-fuzzer CORPUS_DIR. ===================================; Building clang-objc-fuzzer; ===================================; Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address. Then build the clang-objc-fuzzer target. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZE_COVERAGE=YES -DLLVM_USE_SANITIZER=Address; ninja clang-objc-fuzzer. ======================; Running clang-objc-fuzzer; ======================; bin/clang-objc-fuzzer CORPUS_DIR. e.g. using the example objc corpus,. bin/clang-objc-fuzzer <path to corpus_examples/objc> <path to new directory to store corpus findings>. =======================================================; Building clang-proto-fuzzer (Linux-only instructions); =======================================================; Install the necessary dependencies:; - binutils // needed for libprotobuf-mutator; - liblzma-dev // needed for libprotobuf-mutator; - libz-dev // needed for libprotobuf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt:1732,variab,variable,1732,interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,1,['variab'],['variable']
Modifiability," proxy docu](https://httpd.apache.org/docs/2.4/mod/mod_proxy_fcgi.html).; After restarting apache server one should be able to open address: `http://apache_host_name/root.app/`.; There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:. ```; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; ```. ### Configure fastcgi with lighttpd. An example of configuration file for **lighttpd** server is:. ```; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); ```. Be aware, that with *lighttpd* one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: `http://lighttpd_host_name/root.app/`. Example of authorization configuration for FastCGI connection:. auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ). ## Integration with existing applications. In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a [THttpServer::Register()](https://root.cern/doc/master/classTHttpServer.html#a73658daf379e87a4832fe9dc5c1483ed) call. Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the `gSystem->ProcessEvents()` call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session. If an application runs in compiled code and does not contain `gSystem->ProcessEvents()` cal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:12423,config,configuration,12423,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configuration']
Modifiability," quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62089,config,configuration,62089,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['config'],['configuration']
Modifiability," r0, lsr #24; 	orr	r0, r2, r0, lsl #24; 	orr	r0, r0, r1; 	bx	lr. Something like the following would be better (fewer instructions/registers):; 	eor r1, r0, r0, ror #16; 	bic r1, r1, #0xff0000; 	mov r1, r1, lsr #8; 	eor r0, r1, r0, ror #8; 	bx	lr. A custom Thumb version would also be a slight improvement over the generic; version. //===---------------------------------------------------------------------===//. Consider the following simple C code:. void foo(unsigned char *a, unsigned char *b, int *c) {; if ((*a | *b) == 0) *c = 0;; }. currently llvm-gcc generates something like this (nice branchless code I'd say):. ldrb r0, [r0]; ldrb r1, [r1]; orr r0, r1, r0; tst r0, #255; moveq r0, #0; streq r0, [r2]; bx lr. Note that both ""tst"" and ""moveq"" are redundant. //===---------------------------------------------------------------------===//. When loading immediate constants with movt/movw, if there are multiple; constants needed with the same low 16 bits, and those values are not live at; the same time, it would be possible to use a single movw instruction, followed; by multiple movt instructions to rewrite the high bits to different values.; For example:. volatile store i32 -1, i32* inttoptr (i32 1342210076 to i32*), align 4,; !tbaa; !0; volatile store i32 -1, i32* inttoptr (i32 1342341148 to i32*), align 4,; !tbaa; !0. is compiled and optimized to:. movw r0, #32796; mov.w r1, #-1; movt r0, #20480; str r1, [r0]; movw r0, #32796 @ <= this MOVW is not needed, value is there already; movt r0, #20482; str r1, [r0]. //===---------------------------------------------------------------------===//. Improve codegen for select's:; if (x != 0) x = 1; if (x == 1) x = 1. ARM codegen used to look like this:; mov r1, r0; cmp r1, #1; mov r0, #0; moveq r0, #1. The naive lowering select between two different values. It should recognize the; test is equality test so it's more a conditional move rather than a select:; cmp r0, #1; movne r0, #0. Currently this is a ARM specific dag combine. W",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:19668,rewrite,rewrite,19668,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['rewrite'],['rewrite']
Modifiability," ratio comparing to ZLIB); - If two or more files have an identical streamer info record, this is only treated once therewith avoiding to take the global lock.; - Allow writing temporary objects (with same address) in the same TBuffer(s). A new flag to TBuffer*::WriteObject allows to skip the mechanism that prevent the 2nd streaming of an object. This allows the (re)use of temporary objects to store different data in the same buffer.; - Reuse branch proxies internally used by TTreeReader{Value,Array} therewith increasing performance when having multiple readers pointing to the same branch.; - Implement reading of objects data from JSON; - Provide TBufferJSON::ToJSON() and TBufferJSON::FromJSON() methods; - Provide TBufferXML::ToXML() and TBufferXML::FromXML() methods; - Converts NaN and Infinity values into null in JSON, there are no other direct equivalent. ## TTree Libraries; - Enable the TTreeCache by default of `TTree::Draw`, `TTreeReader` and `RDataFrame`; - Significant enhancement in the `TTreeCache` filling algorithm to increase robustness in case of oddly clustered `TTree` and under provisioned cache size. See the [merge request](https://github.com/root-project/root/pull/1960) for more details.; - Proxies are now properly re-used when multiple TTreeReader{Value,Array}s are associated to a single branch. Deserialisation is therefore performed once. This is an advantage for complex TDataFrame graphs.; - Add TBranch::BackFill to allow the addition of new branches to an existing tree and keep the new basket clustered in the same way as the rest of the TTree. Use with the following pattern,; make sure to to call BackFill for the same entry for all the branches consecutively:; ```; for(auto e = 0; e < tree->GetEntries(); ++e) { // loop over entries.; for(auto branch : branchCollection) {; ... Make change to the data associated with the branch ...; branch->BackFill();; }; }; ```; Since we loop over all the branches for each new entry all the baskets for a cluster ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:4570,enhance,enhancement,4570,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['enhance'],['enhancement']
Modifiability," read,; so larger clusters increase the memory footprint. A second option in `RNTupleWriteOptions` specifies the maximum uncompressed cluster size.; The default is 1 GiB.; This setting acts as an ""emergency break"" and should prevent very compressible clusters from growing too large. Given the two settings, writing works as follows:; when the current cluster is larger than the maximum uncompressed size, it will be flushed unconditionally.; When the current cluster size reaches the estimate for the compressed cluster size, it will be flushed, too.; The estimated compression ratio for the first cluster is 0.5 if compression is used, and 1 otherwise.; The following clusters use the average compression ratio of all so-far written clusters as an estimate.; See the notes below on a discussion of this approximation. Page Sizes; ==========. Pages contain consecutive elements of a certain column.; They are the unit of compression and of addressability on storage.; RNTuple puts a configurable maximum uncompressed size for pages.; This limit is by default set to 1 MiB.; When the limit is reached, a page will be flushed to disk. In addition, RNTuple maintains a memory budget for the combined allocated size of the pages that are currently filled.; By default, this limit is set to twice the compressed target cluster size when compression is used,; and to the cluster target size for uncompressed data.; Initially, and after flushing, all columns use small pages,; just big enough to hold the configurable minimum number of elements (64 by default).; Page sizes are doubled as more data is filled into them.; When a page reaches the maximum page size (see above), it is flushed.; When the overall page budget is reached,; pages larger than the page at hand are flushed before the page at hand is flushed.; For the parallel writer, every fill context maintains the page memory budget independently. Note that the total amount of memory consumed for writing is usually larger than the write page ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md:1648,config,configurable,1648,tree/ntuple/v7/doc/tuning.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md,1,['config'],['configurable']
Modifiability," reduction in function calls and code; branches at the expense of some code duplication. There are 3 versions of this loop implemented in TBufferFile and overloaded in TBufferXML and TBufferSQL:. virtual Int_t ReadSequence(const TStreamerInfoActions::TActionSequence &sequence, void *object);; virtual Int_t ReadSequence(const TStreamerInfoActions::TActionSequence &sequence,; void *start_collection, void *end_collection);; virtual Int_t ReadSequence(const TStreamerInfoActions::TActionSequence &sequence,; void *start_collection, void *end_collection);. The 1st version is optimized to read a single object. The 2nd version is optimized to read the content of TClonesArrays and vectors of pointers to objects. The 3rd version is used to streamed any collections. TBufferXML and TBufferSQL overload the loops to introduce extra code to help the buffer keep track of which streamer element is being streamed (this functionality is not used by TBufferFile.). A TStreamerInfoActions::TActionSequence is an ordered sequence of configured actions. A configured action has both an action which is a free standing function and a configuration object deriving; from TStreamerInfoActions::TConfiguration. The configuration contains information that is specific to the action; but varies from use to use, including the offset from the beginning of the object that needs to be updated.; Other examples of configuration include the number of bits requested for storing a Double32_t or its factor and minimum. When the sequence is intended for a collection, the sequence has a configuration object deriving; from TStreamerInfoActions::TLoopConfiguration which contains for example the size of the element of; a vector or the pointers to the iterators functions (see below). Each TStreamerInfo has 2 reading sequences, one for object-wise reading (GetReadObjectWiseActions); and one for member-wise reading (GetReadMemberWiseActions) which is used when streaming a TClonesArray; of a vector of pointer to the type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:4197,config,configured,4197,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,1,['config'],['configured']
Modifiability," references to the symbol without being impeded as it would be; by ``@llvm.used``. This is a rare construct that should only be used in rare circumstances,; and should not be exposed to source languages. .. _gv_llvmglobalctors:. The '``llvm.global_ctors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_ctors = appending global [1 x %0] [%0 { i32 65535, ptr @ctor, ptr @data }]. The ``@llvm.global_ctors`` array contains a list of constructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in ascending order; of priority (i.e. lowest first) when the module is loaded. The order of; functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the initializer function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. .. _llvmglobaldtors:. The '``llvm.global_dtors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_dtors = appending global [1 x %0] [%0 { i32 65535, ptr @dtor, ptr @data }]. The ``@llvm.global_dtors`` array contains a list of destructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in descending; order of priority (i.e. highest first) when the module is unloaded. The; order of functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the destructor function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. Instruction Reference; =====================. The LLVM instruction set consists of several different classifications; of instructio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:353324,variab,variable,353324,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," registers of the specified size, starting from blocks given by; indexes. This will almost certainly be mapped to sub-register COPYs after; register banks have been selected.; The output operands are always ordered from lowest bits to highest:. .. code-block:: none. %bits_0_7:(s8), %bits_8_15:(s8),; %bits_16_23:(s8), %bits_24_31:(s8) = G_UNMERGE_VALUES %0:(s32). G_BSWAP; ^^^^^^^. Reverse the order of the bytes in a scalar. .. code-block:: none. %1:_(s32) = G_BSWAP %0:_(s32). G_BITREVERSE; ^^^^^^^^^^^^. Reverse the order of the bits in a scalar. .. code-block:: none. %1:_(s32) = G_BITREVERSE %0:_(s32). G_SBFX, G_UBFX; ^^^^^^^^^^^^^^. Extract a range of bits from a register. The source operands are registers as follows:. - Source; - The least-significant bit for the extraction; - The width of the extraction. The least-significant bit (lsb) and width operands are in the range:. ::. 0 <= lsb < lsb + width <= source bitwidth, where all values are unsigned. G_SBFX sign-extends the result, while G_UBFX zero-extends the result. .. code-block:: none. ; Extract 5 bits starting at bit 1 from %x and store them in %a.; ; Sign-extend the result.; ;; ; Example:; ; %x = 0...0000[10110]1 ---> %a = 1...111111[10110]; %lsb_one = G_CONSTANT i32 1; %width_five = G_CONSTANT i32 5; %a:_(s32) = G_SBFX %x, %lsb_one, %width_five. ; Extract 3 bits starting at bit 2 from %x and store them in %b. Zero-extend; ; the result.; ;; ; Example:; ; %x = 1...11111[100]11 ---> %b = 0...00000[100]; %lsb_two = G_CONSTANT i32 2; %width_three = G_CONSTANT i32 3; %b:_(s32) = G_UBFX %x, %lsb_two, %width_three. Integer Operations; -------------------. G_ADD, G_SUB, G_MUL, G_AND, G_OR, G_XOR, G_SDIV, G_UDIV, G_SREM, G_UREM; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These each perform their respective integer arithmetic on a scalar. .. code-block:: none. %dst:_(s32) = G_ADD %src0:_(s32), %src1:_(s32). The above example adds %src1 to %src0 and stores the result in %dst. G_SDIVREM, G_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst:5302,extend,extends,5302,interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,2,['extend'],['extends']
Modifiability," regular; expression interpreter into native code with LLVM?. Have fun - try doing something crazy and unusual. Building a language; like everyone else always has, is much less fun than trying something a; little crazy or off the wall and seeing how it turns out. If you get; stuck or want to talk about it, please post on the `LLVM forums ; <https://discourse.llvm.org>`_: it has lots of people who are interested; in languages and are often willing to help out. Before we end this tutorial, I want to talk about some ""tips and tricks""; for generating LLVM IR. These are some of the more subtle things that; may not be obvious, but are very useful if you want to take advantage of; LLVM's capabilities. Properties of the LLVM IR; =========================. We have a couple of common questions about code in the LLVM IR form -; let's just get these out of the way right now, shall we?. Target Independence; -------------------. Kaleidoscope is an example of a ""portable language"": any program written; in Kaleidoscope will work the same way on any target that it runs on.; Many other languages have this property, e.g. lisp, java, haskell,; javascript, python, etc (note that while these languages are portable,; not all their libraries are). One nice aspect of LLVM is that it is often capable of preserving target; independence in the IR: you can take the LLVM IR for a; Kaleidoscope-compiled program and run it on any target that LLVM; supports, even emitting C code and compiling that on targets that LLVM; doesn't support natively. You can trivially tell that the Kaleidoscope; compiler generates target-independent code because it never queries for; any target-specific information when generating code. The fact that LLVM provides a compact, target-independent,; representation for code gets a lot of people excited. Unfortunately,; these people are usually thinking about C or a language from the C; family when they are asking questions about language portability. I say; ""unfortunately"", b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:5647,portab,portable,5647,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['portab'],['portable']
Modifiability," reliability of the; remaining information. To illustrate some potential issues, consider the following example:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); br i1 %cond, label %truebr, label %falsebr; truebr:; %tval = add i32 %bar, 1; call @llvm.dbg.value(metadata i32 %tval, metadata !1, metadata !2); %g1 = call i32 @gazonk(); br label %exit; falsebr:; %fval = add i32 %bar, 2; call @llvm.dbg.value(metadata i32 %fval, metadata !1, metadata !2); %g2 = call i32 @gazonk(); br label %exit; exit:; %merge = phi [ %tval, %truebr ], [ %fval, %falsebr ]; %g = phi [ %g1, %truebr ], [ %g2, %falsebr ]; call @llvm.dbg.value(metadata i32 %merge, metadata !1, metadata !2); call @llvm.dbg.value(metadata i32 %g, metadata !3, metadata !2); %plusten = add i32 %merge, 10; %toret = add i32 %plusten, %g; call @llvm.dbg.value(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. Containing two source-level variables in ``!1`` and ``!3``. The function could,; perhaps, be optimized into the following code:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; %g = call i32 @gazonk(); %addoper = select i1 %cond, i32 11, i32 12; %plusten = add i32 %bar, %addoper; %toret = add i32 %plusten, %g; ret i32 %toret; }. What ``llvm.dbg.value`` intrinsics should be placed to represent the original variable; locations in this code? Unfortunately the second, third and fourth; dbg.values for ``!1`` in the source function have had their operands; (%tval, %fval, %merge) optimized out. Assuming we cannot recover them, we; might consider this placement of dbg.values:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); %g = call i32 @gazonk(); call @llvm.dbg.value(metadata i32 %g, metadata !3, metadata !2); %addoper = select i1 %cond, i32 11, i32 12; %plusten = add i32 %bar, %addoper; %toret = add i32 %plusten, %",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:20805,variab,variables,20805,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability," result offline (online symbolization can be; force disabled by setting ``ASAN_OPTIONS=symbolize=0``):. .. code-block:: console. % ASAN_OPTIONS=symbolize=0 ./a.out 2> log; % projects/compiler-rt/lib/asan/scripts/asan_symbolize.py / < log | c++filt; ==9442== ERROR: AddressSanitizer heap-use-after-free on address 0x7f7ddab8c084 at pc 0x403c8c bp 0x7fff87fb82d0 sp 0x7fff87fb82c8; READ of size 4 at 0x7f7ddab8c084 thread T0; #0 0x403c8c in main example_UseAfterFree.cc:4; #1 0x7f7ddabcac4d in __libc_start_main ??:0; ... Note that on macOS you may need to run ``dsymutil`` on your binary to have the; file\:line info in the AddressSanitizer reports. Additional Checks; =================. Initialization order checking; -----------------------------. AddressSanitizer can optionally detect dynamic initialization order problems,; when initialization of globals defined in one translation unit uses; globals defined in another translation unit. To enable this check at runtime,; you should set environment variable; ``ASAN_OPTIONS=check_initialization_order=1``. Note that this option is not supported on macOS. Stack Use After Return (UAR); ----------------------------. AddressSanitizer can optionally detect stack use after return problems.; This is available by default, or explicitly; (``-fsanitize-address-use-after-return=runtime``).; To disable this check at runtime, set the environment variable; ``ASAN_OPTIONS=detect_stack_use_after_return=0``. Enabling this check (``-fsanitize-address-use-after-return=always``) will; reduce code size. The code size may be reduced further by completely; eliminating this check (``-fsanitize-address-use-after-return=never``). To summarize: ``-fsanitize-address-use-after-return=<mode>``; * ``never``: Completely disables detection of UAR errors (reduces code size).; * ``runtime``: Adds the code for detection, but it can be disable via the; runtime environment (``ASAN_OPTIONS=detect_stack_use_after_return=0``).; * ``always``: Enables detection of UAR er",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:5588,variab,variable,5588,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['variab'],['variable']
Modifiability," ret i8 %2; }. define zeroext i8 @p2(i8 zeroext %b, i8 zeroext %a) nounwind readnone ssp {; entry:; %0 = and i8 %b, 63 ; <i8> [#uses=1]; %.masked = and i8 %a, 64 ; <i8> [#uses=1]; %1 = and i8 %a, -128 ; <i8> [#uses=1]; %2 = or i8 %1, %0 ; <i8> [#uses=1]; %3 = or i8 %2, %.masked ; <i8> [#uses=1]; ret i8 %3; }. //===---------------------------------------------------------------------===//. IPSCCP does not currently propagate argument dependent constants through; functions where it does not not all of the callers. This includes functions; with normal external linkage as well as templates, C99 inline functions etc.; Specifically, it does nothing to:. define i32 @test(i32 %x, i32 %y, i32 %z) nounwind {; entry:; %0 = add nsw i32 %y, %z ; %1 = mul i32 %0, %x ; %2 = mul i32 %y, %z ; %3 = add nsw i32 %1, %2 ; ret i32 %3; }. define i32 @test2() nounwind {; entry:; %0 = call i32 @test(i32 1, i32 2, i32 4) nounwind; ret i32 %0; }. It would be interesting extend IPSCCP to be able to handle simple cases like; this, where all of the arguments to a call are constant. Because IPSCCP runs; before inlining, trivial templates and inline functions are not yet inlined.; The results for a function + set of constant arguments should be memoized in a; map. //===---------------------------------------------------------------------===//. The libcall constant folding stuff should be moved out of SimplifyLibcalls into; libanalysis' constantfolding logic. This would allow IPSCCP to be able to; handle simple things like this:. static int foo(const char *X) { return strlen(X); }; int bar() { return foo(""abcd""); }. //===---------------------------------------------------------------------===//. function-attrs doesn't know much about memcpy/memset. This function should be; marked readnone rather than readonly, since it only twiddles local memory, but; function-attrs doesn't handle memset/memcpy/memmove aggressively:. struct X { int *p; int *q; };; int foo() {; int i = 0, j = 1;; struct X x, y;; int ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:46148,extend,extend,46148,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['extend'],['extend']
Modifiability," returning either a `char*`, or a **`TString`** or an; `std::string`. ### Multiple variables visualisation. This section presents the visualization technique available in ROOT; to represent multiple variables (>4) data sets. #### Spider (Radar) Plots. Spider plots (sometimes called “web-plots” or “radar plots”) are used; to compare series of data points (events). They use the human ability; to spot un-symmetry. ![Example of spider plot.](pictures/spider1.png). Variables are represented on individual axes displayed along a circle.; For each variable the minimum value sits on the circle’s center, and; the maximum on the circle’s radius. Spider plots are not suitable for; an accurate graph reading since, by their nature, it can be difficult; to read out very detailed values, but they give quickly a global view; of an event in order to compare it with the others. In ROOT the spider; plot facility is accessed from the tree viewer GUI. The variables to; be visualized are selected in the tree viewer and can be scanned using; the spider plot button. ![The tree viewer Graphical User Interface and the Spider Plot Editor.](pictures/spider2.png). The spider plot graphics editor provides two tabs to interact with; the spider plots’ output: the tab “Style” defining the spider layout; and the tab “Browse” to navigate in the tree. #### Parallel Coordinates Plots; \index{parallel coordinates}. The Parallel Coordinates Plots are a common way of studying and; visualizing multiple variables data sets. They were proposed by in; A.Inselberg in 1981 as a new way to represent multi-dimensional; information. In traditional Cartesian coordinates, axes are mutually; perpendicular. In Parallel coordinates, all axes are parallel which; allows representing data in much more than three dimensions. To show; a set of points in Parallel Coordinates, a set of parallel lines is; drawn, typically vertical and equally spaced. A point in n-dimensional; space is represented as a polyline with vertices on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:94842,variab,variables,94842,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability," returns the address of the beginning of the small buffer; - `begin()`, `end()`, `front()`, `back()`, etc. Basically the same as the corresponding LLVM class.; It contains the parts that are independent of whether T is a POD or not. `SmallVectorTemplateBase<T, bool TriviallyCopiable>` and the specialization `SmallVectorTemplateBase<T, true>`; - `grow()`, `uninitialized_copy`, `uninitialized_move`, `push_back()`, `pop_back()`. This class contains the parts of `RVec` that can be optimized for trivially copiable types.; In particular, destruction can be skipped and memcpy can be used in place of copy/move construction.; These optimizations are inherited from LLVM's SmallVector. `RVecImpl<T>`; The analogous of LLVM's `SmallVectorImpl`, it factors out of `RVec` the parts that are independent of; the small buffer size, to limit the amount of code generated and provide a way to slice the small buffer; size when passing around `RVec` objects. `RVecN<T, N>`; It aggregates `RVecImpl` and `SmallVectorStorage` (see below) through public inheritance.; `N` is the small buffer size. `RVec<T>`; Inherits from `RVecN` and fixes the small buffer size `N` to a reasonable default.; We expect most users to use this type and only very rarely switch to `RVecN` to tweak the small buffer size. ### Helper types. - `SmallVectorAlignmentAndSize`: used to figure out the offset of the first small-buffer element in; `SmallVectorTemplateCommon::getFirstEl`; - `SmallVectorStorage`: properly aligned ""small buffer"" storage. It's a separate type so that it can be specialized to; be properly aligned also for the case of small buffer size = 0; - `RVecInlineStorageSize`: calculates the size of the small buffer in `RVec`. ## Memory adoption. We need RVec to be able to act as a view over an existing buffer rather than use its own; to save copies and allocations when reading ROOT data into `RVec`s, e.g. in `RDataFrame`. The feature is exposed via a dedicated constructor: `RVec(pointer, size)`.; `RVec` then sw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/ARCHITECTURE.md:3397,inherit,inheritance,3397,math/vecops/ARCHITECTURE.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/ARCHITECTURE.md,1,['inherit'],['inheritance']
Modifiability," rf102_dataimport.C - Importing data from ROOT TTrees and THx histograms; rf103_interprfuncs.C - Interpreted functions and p.d.f.s; rf104_classfactory.C - The class factory for functions and p.d.f.s; rf105_funcbinding.C - Demonstration of binding ROOT Math functions as RooFit functions and pdfs; rf106_plotdecoration.C - Adding boxes with parameters, statistics to RooPlots.; rf107_plotstyles.C - Demonstration of various plotting styles of data, functions; rf108_plotbinning.C - Plotting unbinned data with alternate and variable binnings; rf109_chi2residpull.C - Calculating chi^2 from histograms and curves in RooPlots,; rf110_normintegration.C - Examples on normalization & integration of p.d.f.s, construction of cumulative distribution functions.; rf111_numintconfig.C - Configuration and customization of how numeric (partial) integrals. ; ADDITION AND CONVOLUTION. rf201_composite.C - Composite p.d.f with signal and background component; rf202_extendedmlfit.C - Setting up an extended maximum likelihood fit; rf203_ranges.C - Fitting and plotting in sub ranges; rf204_extrangefit.C - Extended maximum likelihood fit with alternate range definition; rf205_compplot.C - Options for plotting components of composite p.d.f.s.; rf206_treevistools.C - Tools for visualization of RooAbsArg expression trees; rf207_comptools.C - Tools and utilities for manipulation of composite objects; rf208_convolution.C - One-dimensional numeric convolution; rf209_anaconv.C - Decay function p.d.fs with optional B physics. ; MULTIDIMENSIONAL MODELS. rf301_composition.C - Multi-dimensional p.d.f.s through composition, e.g. substituting a p.d.f parameter with a function that depends on other observables; rf302_utilfuncs.C - Utility functions classes available for use in tailoring; rf303_conditional.C - Use of tailored p.d.f as conditional p.d.fs.s; rf304_uncorrprod.C - Simple uncorrelated multi-dimensional p.d.f.s; rf305_condcorrprod.C - Multi-dimensional p.d.f.s with conditional p.d.fs in product; rf3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:1531,extend,extended,1531,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['extend'],['extended']
Modifiability," run ``/usr/bin/ld -v``. It will report ""GNU; gold"" or else ""GNU ld"" if not. If gold is already installed at; ``/usr/bin/ld.gold``, one option is to simply make that the default by; backing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:2242,config,configure,2242,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,2,"['config', 'plugin']","['configure', 'plugins']"
Modifiability," runtime, we need to be able to build few libc build; # tools from the ""libc"" project. So, we add it to the list of enabled; # projects.; if (NOT ""libc"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""Enabling libc project to build libc build tools""); list(APPEND LLVM_ENABLE_PROJECTS ""libc""); endif(); endif(). # LLVM_ENABLE_PROJECTS_USED is `ON` if the user has ever used the; # `LLVM_ENABLE_PROJECTS` CMake cache variable. This exists for; # several reasons:; #; # * As an indicator that the `LLVM_ENABLE_PROJECTS` list is now the single; # source of truth for which projects to build. This means we will ignore user; # supplied `LLVM_TOOL_<project>_BUILD` CMake cache variables and overwrite; # them.; #; # * The case where the user previously had `LLVM_ENABLE_PROJECTS` set to a; # non-empty list but now the user wishes to disable building all other projects; # by setting `LLVM_ENABLE_PROJECTS` to an empty string. In that case we still; # need to set the `LLVM_TOOL_${upper_proj}_BUILD` variables so that we disable; # building all the projects that were previously enabled.; set(LLVM_ENABLE_PROJECTS_USED OFF CACHE BOOL """"); mark_as_advanced(LLVM_ENABLE_PROJECTS_USED). if (LLVM_ENABLE_PROJECTS_USED OR NOT LLVM_ENABLE_PROJECTS STREQUAL """"); set(LLVM_ENABLE_PROJECTS_USED ON CACHE BOOL """" FORCE); foreach(proj ${LLVM_KNOWN_PROJECTS} ${LLVM_EXTERNAL_PROJECTS}); string(TOUPPER ""${proj}"" upper_proj); string(REGEX REPLACE ""-"" ""_"" upper_proj ${upper_proj}); if (""${proj}"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); set(PROJ_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}""); if(NOT EXISTS ""${PROJ_DIR}"" OR NOT IS_DIRECTORY ""${PROJ_DIR}""); message(FATAL_ERROR ""LLVM_ENABLE_PROJECTS requests ${proj} but directory not found: ${PROJ_DIR}""); endif(); if( LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR STREQUAL """" ); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """" FORCE); else(); set(LLVM_EXTER",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:8524,variab,variables,8524,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['variab'],['variables']
Modifiability, rvalue reference deduction specification; Unknown. 877; CD2; Viable functions and binding references to rvalues; Unknown. 879; CD2; Missing built-in comparison operators for pointer types; Unknown. 880; CD2; Built-in conditional operator for scoped enumerations; Unknown. 882; CD2; Defining main as deleted; Unknown. 883; CD2; std::memcpy vs std::memmove; Unknown. 884; CD2; Defining an explicitly-specialized static data member; Unknown. 885; NAD; Partial ordering of function templates with unordered parameter pairs; Unknown. 886; CD2; Member initializers and aggregates; Unknown. 887; CD2; Move construction of thrown object; Unknown. 888; CD2; Union member initializers; Unknown. 891; CD2; const_cast to rvalue reference from objectless rvalue; Unknown. 892; C++11; Missing requirements for constexpr constructors; Unknown. 893; NAD; Brace syntax for enumerator-definitions; Unknown. 896; CD2; Rvalue references and rvalue-reference conversion functions; Unknown. 897; open; _Pragma and extended string-literals; Not resolved. 898; C++11; Declarations in constexpr functions; Unknown. 899; CD2; Explicit conversion functions in direct class initialization; Unknown. 900; C++23; Lifetime of temporaries in range-based for; Unknown. 901; drafting; Deleted operator delete; Not resolved. 902; NAD; In-class initialization of non-constant static data members; Unknown. 903; CD3; Value-dependent integral null pointer constants; Unknown. 904; CD2; Parameter packs in lambda-captures; Unknown. 905; CD2; Explicit defaulted copy constructors and trivial copyability; Unknown. 906; CD2; Which special member functions can be defaulted?; Unknown. 908; CD2; Deleted global allocation and deallocation functions; Unknown. 909; NAD; Old-style casts with conversion functions; Unknown. 910; CD2; Move constructors and implicitly-declared copy constructors; Unknown. 912; CD3; Character literals and universal-character-names; Unknown. 913; CD2; Deduction rules for array- and function-type conversion functio,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:59149,extend,extended,59149,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['extend'],['extended']
Modifiability," scenarios are possible:. 1 - where `analyticalIntegral()` will be able to support AD. 2 - where `analyticalIntegral()` will *not* be able to support AD. This requires further research. ### What if my evaluate() function cannot support AD?. In some cases. the `evaluate()` function is written in a piece-wise format; (multiple evaluations based on multiple chunks of code). You can review the; `MathFuncs.h` file to find AD support for several piece-wise (`if code==1; {...} else if code==2 {...}` ) code snippets. However, there may still be some cases where AD support may not be possible; due to the way that `evaluate()` function works in that instance. ### What if my evaluate() function depends heavily on caching?. For simple caching, the caching logic can be separated from the; mathematical code that is being moved to `MathFuncs.h`, so that it can; retained in the original file. For more complicated scenarios, the `code` variable can be used to identify; use cases (parts of the mathematical code in `evaluate()`) that should be; supported, while other parts that are explicitly not be supported (e.g., using; `if code==1 {...} else if code==2 {...}`). ### Can classes using Numerical Integration support AD?. So far, no. This needs further exploration. Hint: classes using Numerical; Integration can be identified with the absence of the `analyticalIntegral()`; function. ### Why is my code falling back to Numeric Differentiation?. If you call in to an external Math library, and you use a function that has a; customized variant with an already defined custom derivative, then you may see; a warning like ""falling back to Numeric Differentiation"". In most such cases,; your derivative should still work, since Numeric Differentiation is already; well-tested in Clad. To handle this, either define a custom derivative for that external function,; or find a way to expose it to Clad. An example of this can be seen with `gamma_cdf()` in MathFuncs.h`,; for which the custom derivative is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:26969,variab,variable,26969,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['variab'],['variable']
Modifiability," script, which provides very similar (but not identical!) functionality as with `v6` via global `JSROOT` object. * `JSROOT.define()` and `JSROOT.require()` functions only available after `JSRoot.core.js` loading. * Support of `require.js` and `openui5` loaders was removed. * Global hierarchy painter `JSROOT.hpainter` no longer existing, one can use `getHPainter` function:. ```javascript; import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();; ```. * All math functions previously available via `JSROOT.Math` should be imported from `base/math.mjs` module:. ```javascript; import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';; ```. * Indication of batch mode `JSROOT.batch_mode` should be accessed via functions:. ```javascript; import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);; ```. * `JSROOT.extend()` function was removed, use `Object.assign()` instead. ### Migration v5 -> v6. * Main script was renamed to `JSRoot.core.js`. Old `JSRootCore.js` was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use `JSROOT.require` function. To create standard GUI, `JSROOT.buildGUI` function has to be used. * Instead of `JSROOT.JSONR_unref()` one can use `JSROOT.parse()`. If object is provided to `JSROOT.parse()` it just replaces all references which were introduced by `TBufferJSON::ToJSON()` method. * Instead of `JSROOT.console()` one should use `console.log()`. Instead of `JSROOT.alert()` one should use `console.error()`. * Many settings were moved from `JSROOT.gStyle` to `JSROOT.settings` object. It was done to keep only TStyle-related members in `JSROOT.gStyle`. * Basic painter classes were renamed and made public:; - `JSROOT.TBasePainter` -> `JSROOT.BasePainter`; - `JSROOT.TObjectPainter` -> `JSROOT.ObjectPainter`. * Internal `ObjectPai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:48510,extend,extend,48510,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['extend'],['extend']
Modifiability," section of the class documentation](https://root.cern/doc/master/group__Tutorials.html). ## Build, Configuration and Testing Infrastructure; - `root-config` does not suppress deprecation warnings (-Wno-deprecated-declarations) anymore. This means compilers will now diagnose the use of deprecated interfaces in user code.; - Added new 'builtin_vc' option to bundle a version of Vc within ROOT.; The default is OFF, however if the Vc package is not found in the system the option is switched to; ON if the option 'vc' option is ON.; - Many improvements (provided by Mattias Ellert):; - Build RFIO using dpm libraries if castor libraries are not available; - Add missing glib header path in GFAL module for version > 2; - Search also for globus libraries wouthout the flavour in the name; - Add missing io/hdfs/CMakeLists.txt; - net/globusauth has no installed headers - remove ROOT_INSTALL_HEADERS(); - Add missing pieces to the cmake config that are built by configure: bin/pq2, bin/rootd, bin/xpdtest, initd and xinitd start-up scripts; - Only link to libgfortranbegin.a when it is provided by the compiler; - Don't remove -Wall without also removing -Werror=*; - Don't overwrite the initial value of CMAKE_Fortran_FLAGS. Inconsistent case variant of CMAKE_Fortran_FLAGS; - Use the same sonames in cmake as in configure; - Allow building for ppc64 as well as ppc64le; - Add build instructions for 32 bit ARM; - Add build instructions for System Z (s390 and s390x); - Make sure that the roots wrapper can be executed; - Move gl2ps.h to its own subdir; - Added new 'builtin-unuran' option (provided by Mattias Ellert); - Added new 'builtin-gl2ps' option (provided by Mattias Ellert); - Added new 'macos_native' option (only for MacOS) to disable looking for binaries, libraires and headers for dependent; packages at locations other than native MacOS installations. Needed when wanting to ignore packages from Fink, Brew or Ports.; - Added new 'cuda' option to enable looking for CUDA in the system. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:29389,config,configure,29389,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['config'],['configure']
Modifiability," semi-interesting (but probably still useless) toy. :). It is interesting to see how far we've come, and how little code it has; taken. We built the entire lexer, parser, AST, code generator, an; interactive run-loop (with a JIT!), and emitted debug information in; standalone executables - all in under 1000 lines of (non-comment/non-blank); code. Our little language supports a couple of interesting features: it; supports user defined binary and unary operators, it uses JIT; compilation for immediate evaluation, and it supports a few control flow; constructs with SSA construction. Part of the idea of this tutorial was to show you how easy and fun it; can be to define, build, and play with languages. Building a compiler; need not be a scary or mystical process! Now that you've seen some of; the basics, I strongly encourage you to take the code and hack on it.; For example, try adding:. - **global variables** - While global variables have questionable value; in modern software engineering, they are often useful when putting; together quick little hacks like the Kaleidoscope compiler itself.; Fortunately, our current setup makes it very easy to add global; variables: just have value lookup check to see if an unresolved; variable is in the global variable symbol table before rejecting it.; To create a new global variable, make an instance of the LLVM; ``GlobalVariable`` class.; - **typed variables** - Kaleidoscope currently only supports variables; of type double. This gives the language a very nice elegance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:1358,variab,variables,1358,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,2,['variab'],['variables']
Modifiability," separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when creating a rule. Refactoring Options; -------------------. Refactoring options are values that affect a refactoring operation and are; specified either using command-line options or another client-specific; mechanism. Options should be created using a class that derives either from; the ``OptionalRequiredOption`` or ``RequiredRefactoringOption``. The following; example shows how one can created a required string option that corresponds to; the ``-new-name`` command-line option in clang-refactor:. .. code-block:: c++. class NewNameOption : publi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:9326,refactor,refactoring,9326,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactoring']
Modifiability," set of Clang options. This option is; only recommended if the program source cannot be changed or if the; program also relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4296,portab,portable,4296,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['portab'],['portable']
Modifiability," set(LLVM_ENABLE_PROJECTS_USED ON CACHE BOOL """" FORCE); foreach(proj ${LLVM_KNOWN_PROJECTS} ${LLVM_EXTERNAL_PROJECTS}); string(TOUPPER ""${proj}"" upper_proj); string(REGEX REPLACE ""-"" ""_"" upper_proj ${upper_proj}); if (""${proj}"" IN_LIST LLVM_ENABLE_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); set(PROJ_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}""); if(NOT EXISTS ""${PROJ_DIR}"" OR NOT IS_DIRECTORY ""${PROJ_DIR}""); message(FATAL_ERROR ""LLVM_ENABLE_PROJECTS requests ${proj} but directory not found: ${PROJ_DIR}""); endif(); if( LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR STREQUAL """" ); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """" FORCE); else(); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """"); endif(); elseif (""${proj}"" IN_LIST LLVM_EXTERNAL_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); else(); message(STATUS ""${proj} project is disabled""); set(SHOULD_ENABLE_PROJECT FALSE); endif(); # Force `LLVM_TOOL_${upper_proj}_BUILD` variables to have values that; # corresponds with `LLVM_ENABLE_PROJECTS`. This prevents the user setting; # `LLVM_TOOL_${upper_proj}_BUILD` variables externally. At some point; # we should deprecate allowing users to set these variables by turning them; # into normal CMake variables rather than cache variables.; set(LLVM_TOOL_${upper_proj}_BUILD; ${SHOULD_ENABLE_PROJECT}; CACHE; BOOL ""Whether to build ${upper_proj} as part of LLVM"" FORCE; ); endforeach(); endif(); unset(SHOULD_ENABLE_PROJECT). # Build llvm with ccache if the package is present; set(LLVM_CCACHE_BUILD OFF CACHE BOOL ""Set to ON for a ccache enabled build""); if(LLVM_CCACHE_BUILD); find_program(CCACHE_PROGRAM ccache); if(CCACHE_PROGRAM); set(LLVM_CCACHE_MAXSIZE """" CACHE STRING ""Size of ccache""); set(LLVM_CCACHE_DIR """" CACHE STRING ""Directory to keep ccached data""); set(LLVM_CCACHE_PARAMS ""CCACHE_CPP2=yes CCACHE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:9894,variab,variables,9894,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['variab'],['variables']
Modifiability," severity is used for; diagnostics indicating the program is never acceptable under any circumstances.; When an error is emitted, the AST for the input code may not be fully built.; The ``EXTENSION`` and ``EXTWARN`` severities are used for extensions to the; language that Clang accepts. This means that Clang fully understands and can; represent them in the AST, but we produce diagnostics to tell the user their; code is non-portable. The difference is that the former are ignored by; default, and the later warn by default. The ``WARNING`` severity is used for; constructs that are valid in the currently selected source language but that; are dubious in some way. The ``REMARK`` severity provides generic information; about the compilation that is not necessarily related to any dubious code. The; ``NOTE`` level is used to staple more information onto previous diagnostics. These *severities* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:5225,config,configuration,5225,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['config'],['configuration']
Modifiability," simultaneous PDFs being considered) and binned likelihoods (adding further; complexity). In this example, the `RooNLLVarNew::translate()` function generates code to; compute the Negative Log likelihood (NLL). We can see that the intermediate; result variable `resName` is added to the context so that it can be accessed; and used in the generated code. This variable is made available globally; (using `addToGlobalScope()`). If a weight sum is needed, then it creates a loop, and `weightSumName` is; accumulated with the weight variable. Otherwise, if there are multiple; simultaneous PDFs, then it adds a term to the result that scales with the; logarithm of the count of simultaneous PDFs. The rest of the function body; (including the loop scope with NLL computation) has omitted from this example; to keep it brief. Helper functions:. - `makeValidVarName()` helps get a valid name from the name of the respective; RooFit class. It then helps save it to the variable that represents the result; of this class (the squashed code/ C++ function that will be created). - `addToGlobalScope()` helps declare and initialize the results variable, so; that it can be available globally (throughout the function body). For local; variables, the `addToCodeBody()` function can be used to keep the variables in; the respective scope (for example, within a loop). - `beginLoop()` helps build the start and the end of a For loop for your; class. Simply place this function in the scope and place the contents of the; `For` loop below this statement. The code squashing task will automatically; build a loop around the statements that follow it. There's no need to worry; about the index of these loops, because they get propagated. For example, if; you want to iterate over a vector of RooFit objects using a loop, you don't; have to think about indexing them properly because the `beginLoop()` function; takes care of that. Simply call this function, place your function call in a; scope and after the scope e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:17253,variab,variable,17253,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['variab'],['variable']
Modifiability," slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole proc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4434,config,configures,4434,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['configures']
Modifiability," somehow to discriminate; crashes if possible. Equivalent to ``@llvm.trap`` for targets that do not support this behaviour. '``llvm.stackprotector``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackprotector(ptr <guard>, ptr <slot>). Overview:; """""""""""""""""". The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it; onto the stack at ``slot``. The stack slot is adjusted to ensure that it; is placed on the stack before local variables. Arguments:; """""""""""""""""""". The ``llvm.stackprotector`` intrinsic requires two pointer arguments.; The first argument is the value loaded from the stack guard; ``@__stack_chk_guard``. The second variable is an ``alloca`` that has; enough space to hold the value of the guard. Semantics:; """""""""""""""""""". This intrinsic causes the prologue/epilogue inserter to force the position of; the ``AllocaInst`` stack slot to be before local variables on the stack. This is; to ensure that if a local variable on the stack is overwritten, it will destroy; the value of the guard. When the function exits, the guard on the stack is; checked against the original guard by ``llvm.stackprotectorcheck``. If they are; different, then ``llvm.stackprotectorcheck`` causes the program to abort by; calling the ``__stack_chk_fail()`` function. '``llvm.stackguard``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stackguard(). Overview:; """""""""""""""""". The ``llvm.stackguard`` intrinsic returns the system stack guard value. It should not be generated by frontends, since it is only for internal usage.; The reason why we create this intrinsic is that we still support IR form Stack; Protector in FastISel. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". On some platforms, the value returned by this intrinsic remains unchanged; between loads in the same thread. On other platforms, it returns the same; global variable value, if any, e.g. ``@__stack_chk_guard``. Currently some platform",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:930417,variab,variable,930417,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," specific histogram where you, for example,; set the range and bin number, you can define the histogram ahead of time; and use it in the Draw command. The histogram has to be in the same; directory as the tree. ``` {.cpp}; root[] TH1 *h1 = new TH1(""h1"",""h1"",50,0.,150.);; root[] T->Draw(""fNtrack>> h1"");; ```. When you project a **`TTree`** into a histogram, the histogram inherits; the **`TTree`** attributes and not the current style attributes. This; allows you to project two Trees with different attributes into the same; picture. You can call the method `TTree::UseCurrentStyle` to change the; histogram to use the current style ***`gStyle`***. See ""Graphics and the; Graphical User Interface. The binning of the newly created histogram can be specified in two ways.; You can set a default in the `.rootrc` and/or you can add the binning; information in the `TTree::Draw` command. To set number of bins default for the 1-D, 2-D, 3-D histograms can be; specified in the `.rootrc` file via the environment variables, e.g.:. ```; # default binnings Hist.Binning.1D.x: 100. Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100. Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; ```. To set the number of bins for a specific histogram when using; `TTree::Draw,` add up to nine numbers following the histogram name. The; numbers meaning is:. 1 bins in x-direction. 2 lower limit in x-direction. 3 upper limit in x-direction. 4-6 same for y-direction. 7-9 same for z-direction. When a bin number is specified, the value becomes the default. Any of; the numbers can be skipped. For example:. ``` {.cpp}; tree.Draw(""sqrt(x)>>hsqrt(500,10,20)"";; // plot sqrt(x) between 10 and 20 using 500 bins; tree.Draw(""sqrt(x):sin(y)>>hsqrt(100,10,,50,.1,.5)"";; // plot sqrt(x) against sin(y) 100 bins in x-direction;; // lower limit on x-axis is 10; no upper limit; // 50 bins in y-direction; lower limit on y-axis is .1;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:116704,variab,variables,116704,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability," specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <ReflowComments>`; If ``true``, clang-format will attempt to re-flow comments. That is it; will touch a comment and *reflow* long comments into new lines, trying to; obey the ``ColumnLimit``. .. code-block:: c++. false:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */. true:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; // information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; * information */. .. _RemoveBracesLLVM:. **RemoveBracesLLVM** (``Boolean``) :versionbadge:`clang-format 14` :ref:`¶ <RemoveBracesLLVM>`; Remove optional braces of control statements (``if``, ``else``, ``for``,; and ``while``) in C++ according to th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:100252,config,configuration,100252,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," specified location list expression E is; evaluated. The evaluation of E uses the current context, except the result; kind is a location description, the compilation unit is the one that; contains D, and the initial stack is empty. The location description; result is pushed on the stack. .. note::. This rule avoids having to define how to execute a matched location list; entry operation expression on the same stack as the call when there are; multiple matches. But it allows the call to obtain the location; description for a variable or formal parameter which may use a location; list expression. An alternative is to treat the case when D has a ``DW_AT_location``; attribute that is encoded as a ``loclist`` or ``loclistsptr``, and the; specified location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB implements ``DW_OP_call*`` by always executing E on the same stack.; If the location list has multiple matching entries, it simply picks the; first one and ignores the rest. This seems fundamentally at odds with; the desire to support multiple places for variables. So, it feels like ``DW_OP_call*`` should both support pushing a location; description on the stack for a variable or formal parameter, and also; support being able to execute an operation expression on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:76841,variab,variable,76841,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability," specify the delay between the last; image and the fist image in case of infinite loop. (Fernando Hueso González; <f.gonzalez@hzdr.de>). ### TPadPainter; - Offer 0 as line width option. Useful to make a line invisible. ### TPad. - In `TPad::ShowGuidelines` the number of guide lines is limited to 15. Above; that they become useless.; - Print a warning if one of the pad limit is a NaN.; - Fix https://sft.its.cern.ch/jira/browse/ROOT-6703. ### TCanvas. - Make sure that ""/"" and ""."" are not part of the method name when a canvas is; saved as a .C file. ### TLatex. - With the Cocoa backend the PDF and PS output produced miss-aligned exponents; because the `GetTextExtend` method behaved differently in batch mode and ""screen""; mode. This is now fixed. See http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=18883; - Improve the square-root drawing in case it is small.; - Better adjustment of the tilde accent position in case of Cocoa backend. ### TMathText. - `\mu` is now working for Postscript output.; - `\splitline` is now implemented. ### Cocoa backend. - Line width and line style were not applied on boxes. ## 3D Graphics Libraries. ### GL Viewer; - New option ""Rotate scene"" in the ""Extras"" tab of the GL Viewer. It allows to; do a real rotation instead of a wobbling when the ""Auto Rotator"" is launched.; - New methods from Jeremi Niedziela <jeremi.niedziela@cern.ch> to return the; image in memory. ## Tutorials. - New tutorial `textviewostream.C` showing how to use the TGTextViewostream widget. ## Build, Configuration and Testing Infrastructure. ### New functionalities. - Support ARM 64 bits architecture. - Partial support for PPC 64 bits Little Endian architecture. - Add ""Optimized"" CMAKE_BUILD_TYPE: allow highest level of optimisation of the GCC and Clang compilers (-Ofast). - Support ccache activation with cmake configuration switch. - Support link to jemalloc and tcmalloc allocators. - Careful suppression of known and understood warnings, e.g. coming from external packages.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:24934,config,configuration,24934,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['config'],['configuration']
Modifiability," stat drawing; - Using '_same_' identifier in item name, one can easily draw or superimpose; similar items from different files. Could be used in URL like:; `...&files=[file1.root,file2.root]&items=[file1.root/hpx, file2.root/_same_]`; `...&files=[file1.root,file2.root]&item=file1.root/hpx+file2.root/_same_`; Main limitation - file names should have similar length.; - When 'autozoom' specified in draw options, histogram zoomed into; non-empty content. Same command available via context menu.; - Item of 'Text' kind can be created. It is displayed as; lain text in the browser. If property 'mathjax' specified,; MathJax.js library will be loaded and used for rendering.; See tutorials/http/httpcontrol.C macro for example.; - When using foreignObject, provide workaround for absolute positioning; problem in Chrome/Safari, see <http://bit.ly/1wjqCQ9>; - Support usage of minimized versions of .js and .css files.; Minimized scripts used by default on web servers.; - Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; - Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; - Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; - Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE. ## TTree Libraries. ### TTree Behavior change. #### Merging. Added fast cloning support to TTree::MergeTrees and TTree::Merge(TCollection*,Option_t*). #### TTreeCache. The TTreeCache is now enabled by default. The default size of the TTreeCache; is the estimated size of a cluster size for the TTree. The TTreeCache; prefilling is also enabled by default; when in learning phase rather than; reading each requested branch individually, the TTreeCache will read all the; branches thus trading off the latencies inherent to multiple small reads for; the potential of requesting more data th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:11956,extend,extend,11956,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['extend'],['extend']
Modifiability," static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. Running the tool on some code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When you check out and build clang, clang-check is already built and available; to you in bin/clang-check inside your build directory. You can run clang-check on a file in the llvm repository by specifying all the; needed parameters after a ""``--``"" separator:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check tools/clang/tools/clang-check/ClangCheck.cpp -- \; clang++ -D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS \; -Itools/clang/include -I$BD/include -Iinclude \; -Itools/clang/lib/Headers -c. As an alternative, you can also configure cmake to output a compile command; database into its build directory:. .. code-block:: bash. # Alternatively to calling cmake, use ccmake, toggle to advanced mode and; # set the parameter CMAKE_EXPORT_COMPILE_COMMANDS from the UI.; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON . This creates a file called ``compile_commands.json`` in the build directory.; Now you can run :program:`clang-check` over files in the project by specifying; the build path as first argument and some source files as further positional; arguments:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check -p $BD tools/clang/tools/clang-check/ClangCheck.cpp. .. _libtooling_builtin_includes:. Builtin includes; ^^^^^^^^^^^^^^^^. Clang tools need their builtin headers and search for them the same way Clang; does. Thus, the default location to look for builtin headers is in a path; ``$(dirname /path/to/tool)/../lib/clang/3.3/include`` relative to the tool; binary. This works out-of-the-bo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:5998,config,configure,5998,interpreter/llvm-project/clang/docs/LibTooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst,1,['config'],['configure']
Modifiability," std::vector is exception-safe, and some implementations have pessimizations; that copy elements when SmallVector would move them. #. SmallVector understands ``std::is_trivially_copyable<Type>`` and uses realloc aggressively. #. Many LLVM APIs take a SmallVectorImpl as an out parameter (see the note; below). #. SmallVector with N equal to 0 is smaller than std::vector on 64-bit; platforms, since it uses ``unsigned`` (instead of ``void*``) for its size; and capacity. .. note::. Prefer to use ``ArrayRef<T>`` or ``SmallVectorImpl<T>`` as a parameter type. It's rarely appropriate to use ``SmallVector<T, N>`` as a parameter type.; If an API only reads from the vector, it should use :ref:`ArrayRef; <dss_arrayref>`. Even if an API updates the vector the ""small size"" is; unlikely to be relevant; such an API should use the ``SmallVectorImpl<T>``; class, which is the ""vector header"" (and methods) without the elements; allocated after it. Note that ``SmallVector<T, N>`` inherits from; ``SmallVectorImpl<T>`` so the conversion is implicit and costs nothing. E.g. .. code-block:: c++. // DISCOURAGED: Clients cannot pass e.g. raw arrays.; hardcodedContiguousStorage(const SmallVectorImpl<Foo> &In);; // ENCOURAGED: Clients can pass any contiguous storage of Foo.; allowsAnyContiguousStorage(ArrayRef<Foo> In);. void someFunc1() {; Foo Vec[] = { /* ... */ };; hardcodedContiguousStorage(Vec); // Error.; allowsAnyContiguousStorage(Vec); // Works.; }. // DISCOURAGED: Clients cannot pass e.g. SmallVector<Foo, 8>.; hardcodedSmallSize(SmallVector<Foo, 2> &Out);; // ENCOURAGED: Clients can pass any SmallVector<Foo, N>.; allowsAnySmallSize(SmallVectorImpl<Foo> &Out);. void someFunc2() {; SmallVector<Foo, 8> Vec;; hardcodedSmallSize(Vec); // Error.; allowsAnySmallSize(Vec); // Works.; }. Even though it has ""``Impl``"" in the name, SmallVectorImpl is widely used; and is no longer ""private to the implementation"". A name like; ``SmallVectorHeader`` might be more appropriate. .. _dss_pagedvector:. llv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:61971,inherit,inherits,61971,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['inherit'],['inherits']
Modifiability," step is to identify refactoring candidates through; static analysis. For example, in the following code snippet the pointer `c` is an output; parameter:. ```c++; struct Customer {; int account_id;; std::string name;; }. void GetCustomer(Customer *c) {; c->account_id = ...;; if (...) {; c->name = ...;; } else {; c->name = ...;; }; }; ```. We would like to refactor this code into:. ```c++; Customer GetCustomer() {; Customer c;; c.account_id = ...;; if (...) {; c.name = ...;; } else {; c.name = ...;; }; return c;; }; ```. However, in the function below the parameter `c` is not an output parameter; because its field `name` is not overwritten on every path through the function. ```c++; void GetCustomer(Customer *c) {; c->account_id = ...;; if (...) {; c->name = ...;; }; }; ```. The code also cannot read the value of the parameter before overwriting it:. ```c++; void GetCustomer(Customer *c) {; use(c->account_id);; c->name = ...;; c->account_id = ...;; }; ```. Functions that escape the pointer also block the refactoring:. ```c++; Customer* kGlobalCustomer;. void GetCustomer(Customer *c) {; c->name = ...;; c->account_id = ...;; kGlobalCustomer = c;; }; ```. To identify a candidate function for refactoring, we need to do the following:. * Find a function with a non-const pointer or reference parameter. * Find the definition of that function. * Prove that the function completely overwrites the pointee on all paths; before returning. * Prove that the function reads the pointee only after overwriting it. * Prove that the function does not persist the pointer in a data structure; that is live after the function returns. There are also requirements that all usage sites of the candidate function must; satisfy, for example, that function arguments do not alias, that users are not; taking the address of the function, and so on. Let's consider verifying usage; site conditions to be a separate static analysis problem. ### Lattice design. To analyze the function body we can use a latt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:15952,refactor,refactoring,15952,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactoring']
Modifiability," structure. They can be named (``%X``) or; unnamed (``%52``). :Syntax:. ::. %X = type opaque; %52 = type opaque. :Examples:. +--------------+-------------------+; | ``opaque`` | An opaque type. |; +--------------+-------------------+. .. _constants:. Constants; =========. LLVM has several different basic types of constants. This section; describes them all and their syntax. Simple Constants; ----------------. **Boolean constants**; The two strings '``true``' and '``false``' are both valid constants; of the ``i1`` type.; **Integer constants**; Standard integers (such as '4') are constants of the :ref:`integer; <t_integer>` type. They can be either decimal or; hexadecimal. Decimal integers can be prefixed with - to represent; negative integers, e.g. '``-1234``'. Hexadecimal integers must be; prefixed with either u or s to indicate whether they are unsigned; or signed respectively. e.g '``u0x8000``' gives 32768, whilst; '``s0x8000``' gives -32768. Note that hexadecimal integers are sign extended from the number; of active bits, i.e. the bit width minus the number of leading; zeros. So '``s0x0001``' of type '``i16``' will be -1, not 1.; **Floating-point constants**; Floating-point constants use standard decimal notation (e.g.; 123.421), exponential notation (e.g. 1.23421e+2), or a more precise; hexadecimal notation (see below). The assembler requires the exact; decimal value of a floating-point constant. For example, the; assembler accepts 1.25 but rejects 1.3 because 1.3 is a repeating; decimal in binary. Floating-point constants must have a; :ref:`floating-point <t_floating>` type.; **Null pointer constants**; The identifier '``null``' is recognized as a null pointer constant; and must be of :ref:`pointer type <t_pointer>`.; **Token constants**; The identifier '``none``' is recognized as an empty token constant; and must be of :ref:`token type <t_token>`. The one non-intuitive notation for constants is the hexadecimal form of; floating-point constants. For example, the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:184916,extend,extended,184916,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extended']
Modifiability," style. This can be enabled/disabled via the GUI.Style entry in $ROOTSYS/etc/system.rootrc (or in a user defined $HOME/.rootrc); Create special icons for symlinks (shortcuts) in the browser (add a small arrow on bottom left corner of the original icon). TGFileDialog. Implemented the wish #78935: Longer ""File of type:"" selector is wanted (make more combo box entries visible); Enable the new (flat) button style. This can be enabled/disabled via the GUI.Style entry in $ROOTSYS/etc/system.rootrc (or in a user defined $HOME/.rootrc). TGFSContainer. The shortcuts are now working on Windows. TGColorDialog, TGFontDialog, TGTextEditDialogs. Several improvements in the layout when increasing the font size. TGTextEditor. Added a ""Close"" menu entry; Properly ask the user to save the currently opened file (if modified) when trying to open a new file; Moved the IsSaved() part of the code in the LoadFile() method, to make sure it works also when the text editor is used as a plugin in the browser; Change the text highlighing color; Cleanup the text when quitting root (avoid potential crash on Linux). TGFrame. Allow to override CTRL+S behavior by using the TGMainFrame::BindKey() function. TVirtualDragManager. Renamed TVirtualDragManager::GetDragType() to TVirtualDragManager::GetEDragType(), to avoid potential clash between two classes (TGFrame and TVirtualDragManager) having both GetDragType method with different return types. And they are both inherited by one class (TGuiBldDragManager) which doesn't define GetDragType. TGSlider. Added mouse wheel handling. TGToolTip. Properly set the text color of the tooltip label, using the value of Gui.TooltipForegroundColor in $ROOTSYS/etc/system.rootrc (or in a user defined $HOME/.rootrc). GUIHtml; TGHtmlBrowser. Only add non-empty strings (urls) in the combo box, to avoid empty entries; Enable the new (flat) button style. This can be enabled/disabled via the GUI.Style entry in $ROOTSYS/etc/system.rootrc (or in a user defined $HOME/.rootrc). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v530/index.html:3820,inherit,inherited,3820,gui/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v530/index.html,1,['inherit'],['inherited']
Modifiability," support lego plots for TH1; - Significant (up to factor 10) performance improvement in 3D-graphics; - Implement ROOT6-like color palettes; - Support non-equidistant bins for TH1/TH2 objects.; - Improve TF1 drawing - support exp function in TFormula, fix errors with logx scale, enable zoom-in, (re)calculate function points when zooming; - Introduce many context menus for improving interactivity; - Implement col0 and col0z draw option for TH2 histograms, similar to ROOT6; - Implement box and hbox draw options for TH1 class; - Significant (factor 4) I/O performance improvement; - New 'flex' layout:; - create frames like in Multi Document Interface; - one could move/resize/minimize/maximize such frames. For more details, like the complete change log, the documentation, and very detailed examples, see the [JSROOT home page](https://root.cern.ch/js) and the [JSROOT project github page](https://github.com/linev/jsroot) . ## Tutorials; * New tutorial `treegetval.C` illustrating how to retrieve `TTree` variables in arrays.; * Add script to automatically translate tutorials into notebooks; * Embed it into the documentation generation; * Make the notebooks available in the [tutorials section of the class documentation](https://root.cern/doc/master/group__Tutorials.html). ## Build, Configuration and Testing Infrastructure; - `root-config` does not suppress deprecation warnings (-Wno-deprecated-declarations) anymore. This means compilers will now diagnose the use of deprecated interfaces in user code.; - Added new 'builtin_vc' option to bundle a version of Vc within ROOT.; The default is OFF, however if the Vc package is not found in the system the option is switched to; ON if the option 'vc' option is ON.; - Many improvements (provided by Mattias Ellert):; - Build RFIO using dpm libraries if castor libraries are not available; - Add missing glib header path in GFAL module for version > 2; - Search also for globus libraries wouthout the flavour in the name; - Add missing io/hdf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:27895,variab,variables,27895,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['variab'],['variables']
Modifiability," switch 'usefrk' has been added to; 'xpd.proofservmgr' to control that. Default is still fork(). Improvements; ; In TProof::ClearPackages, use the manager to execute the command on; all known worker machines. Improves the consistency when re-istalling; packages. In TProof::GetDataSets, add support for option ':lite:'; this allows; to fill the map with only the summary information about the datasets; (the header of TFileCollections), significantly increasing the speed; and the memory footprint when the number of datasets is very large.; Accept '.' in user names.; Add switch to control caching of the files read on MacOsX. A call to; fcntl(fd, F_NOCACHE, 1) is done after opening the file.; Add export of the envs ROOTPROOFCLIENT and ROOTPROOFLITE when; appropriate. These allow to steer building and/or enabling of PAR files; in PROOF-INF/BUILD.sh and/or PROOF-INF/SETUP.C, improving transparency; between normal ROOT and PROOF. The example PAR; 'tutorials/proof/event.par' has been modified to check the two; variables.; Fix a few issues in SQL PROOF monitoring: in; TSQLMonitoringWriter::SendParameters, drop ''' around field names in; the INSERT string; also use TString::Format(...) instead of Form(...); where relevant.  In TPerfStats: call 'proofgroup' instead of; 'group' the field with the PROOF group (interference with the 'group'; keyword in SQL); add new field 'querytag' VARCHAR(64) with the unique; query tag; in WriteQueryLog fill also the field 'totevents'; in; PacketEvent, add switch to control whether to send te information to; the monitoring system on per packet level (may be too much for SQL).; The switch is called fMonitorPerPacket and it is globally controlled by; the rootrc variable 'Proof.MonitorPerPacket' and at session level with; the parameter PROOF_MonitorPerPacket .; Improve treatment of the case when temporary files are asked to be; created on a shared file system not containing the sandboxes. This; case, which seems to be a rather common one, should be n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:3676,variab,variables,3676,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,1,['variab'],['variables']
Modifiability," syntax.Lines; in the input file starting with ""\#"" are ignored. A **`TBranch`** object; is created for each variable in the expression. The total number of rows; read from the file is returned. ## Trees in Analysis. The methods `TTree::Draw`, `TTree::MakeClass` and; `TTree::MakeSelector` are available for data analysis using trees. The; **`TTree::Draw`** method is a powerful yet simple way to look and draw the; trees contents. It enables you to plot a variable (a leaf) with just one; line of code. However, the Draw method falls short once you want to look; at each entry and design more sophisticated acceptance criteria for your; analysis. For these cases, you can use `TTree::MakeClass`. It creates a; class that loops over the trees entries one by one. You can then expand; it to do the logic of your analysis. The `TTree::MakeSelector` is the recommended method for ROOT data; analysis. It is especially important for large data set in a parallel; processing configuration where the analysis is distributed over several; processors and you can specify which entries to send to each processor.; With `MakeClass` the user has control over the event loop, with; `MakeSelector `the tree is in control of the event loop. ## Simple Analysis Using TTree::Draw. We will use the tree in `cernstaff.root` that was made by the macro in; `$ROOTSYS/tutorials/tree/staff.C`. First, open the file and lists its contents. ``` {.cpp}; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; ```. We can see the **`TTree `**""`T`"" in the file. We will use it to; experiment with the **`TTree::Draw`** method, so let's create a pointer to it:. ``` {.cpp}; root[] TTree *MyTree = T; ```. Cling allows us to get simply the object by using it. Here we define a; pointer to a **`TTree`** object and assign it the value of ""`T`"", the; **`TTree`** in the file. Cling looks for an object named ""`T`"" in the; current ROOT file and re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:68301,config,configuration,68301,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['config'],['configuration']
Modifiability," than 1 and ticks marks; set to the positive side, alignement issues seem to come up.; The following example shows four TGAxis drawn respectively with the; following options: RG-, RG+, LG-, LG+. For the RG+ and LG+ options,; the 10E-1 and 10E-2 labels were ill-aligned, showing a shift to the right; compared to the 1E2, 1E1 and 1 labels.; ; {; c1 = new TCanvas(""c1"",""Examples of Log TGaxis"",10,10,700,500);; c1->Range(-10,-1,10,1);; TGaxis *axis1 = new TGaxis(-7,-0.8,-7,0.8,0.01,100,50510,""RG-"");; axis1->SetTitle(""RG-""); axis1->Draw();; TGaxis *axis2 = new TGaxis(-2,-0.8,-2,0.8,0.01,100,50510,""RG+"");; axis2->SetLabelOffset(-0.04); axis2->SetTitleOffset(-1.5);; axis2->SetTitle(""RG+""); axis2->Draw();; TGaxis *axis3 = new TGaxis(2,-0.8,2,0.8,0.01,100,50510,""LG-"");; axis3->SetLabelOffset(-0.04);; axis3->SetTitle(""LG-""); axis3->Draw();; TGaxis *axis4 = new TGaxis(7,-0.8,7,0.8,0.01,100,50510,""LG+"");; axis4->SetTitleOffset(-1);; axis4->SetTitle(""LG+""); axis4->Draw();; }; ; gStyle.SetStripDecimals(kFALSE) did not work in cases like the; following one:; ; {; gStyle.SetStripDecimals(kFALSE);; gStyle.SetPadLeftMargin(.15);; TGraph graph_freq;; graph_freq.SetPoint(0, 933., 40078879.);; graph_freq.SetPoint(1, 934., 40078966.);; graph_freq.Draw(""A*"");; }; . TCrown. The crown picking did not work.; Improve help. TLatex. The text angle was not taken into account in case the; text was painted in low precision like in:; ; gStyle->SetTitleFont(60,""xy"");; TH1F* h=new TH1F(""foo"", ""bar;#int;#int"", 10, 0, 1);; h->Draw();; ; In that example the Y title was not rotated. TCanvas. A canvas is turned into GL mode only if the; canvas name starts with ""gl"". Before the; ""gl"" string could be anywhere in the name. QtRoot/ libGQt. The redundant Qt3-related code was removed.; The Q3_SUPPORT flag was eliminated.; The plug-in can be used with and without Q3_SUPPORT now.; The code was adjusted to work under the Qt 4.5.x.; Many platform depended (win32) sections; were replaced with the cross-platform code. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html:3529,plug-in,plug-in,3529,graf2d/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html,1,['plug-in'],['plug-in']
Modifiability," that will be scanned for tests. **test_exec_root** For out-of-dir builds, the path to the test suite root inside; the object directory. This is where tests will be run and temporary output files; placed. **environment** A dictionary representing the environment to use when executing; tests in the suite. **standalone_tests** When true, mark a directory with tests expected to be run; standalone. Test discovery is disabled for that directory. *lit.suffixes* and; *lit.excludes* must be empty when this variable is true. **suffixes** For **lit** test formats which scan directories for tests, this; variable is a list of suffixes to identify test files. Used by: *ShTest*. **substitutions** For **lit** test formats which substitute variables into a test; script, the list of substitutions to perform. Used by: *ShTest*. **unsupported** Mark an unsupported directory, all tests within it will be; reported as unsupported. Used by: *ShTest*. **parent** The parent configuration, this is the config object for the directory; containing the test suite, or None. **root** The root configuration. This is the top-most :program:`lit` configuration in; the project. **pipefail** Normally a test using a shell pipe fails if any of the commands; on the pipe fail. If this is not desired, setting this variable to false; makes the test fail only if the last command in the pipe fails. **available_features** A set of features that can be used in `XFAIL`,; `REQUIRES`, and `UNSUPPORTED` directives. TEST DISCOVERY; ~~~~~~~~~~~~~~. Once test suites are located, :program:`lit` recursively traverses the source; directory (following *test_source_root*) looking for tests. When :program:`lit`; enters a sub-directory, it first checks to see if a nested test suite is; defined in that directory. If so, it loads that test suite recursively,; otherwise it instantiates a local test config for the directory (see; :ref:`local-configuration-files`). Tests are identified by the test suite they are contained within, a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:16862,config,configuration,16862,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,2,['config'],"['config', 'configuration']"
Modifiability," the *LLVM_DISTRIBUTIONS* variable to hold a list of all distribution names; (which conventionally start with an uppercase letter, e.g. ""Development""), and; then setting the *LLVM_<distribution>_DISTRIBUTION_COMPONENTS* variable to the; list of targets for that distribution. For each distribution, the build system; generates an ``install-${distribution}-distribution`` target, where; ``${distribution}`` is the name of the distribution in lowercase, to install; that distribution. Each distribution creates its own set of CMake exports, and the target to; install the CMake exports for a particular distribution for a project is named; ``${project}-${distribution}-cmake-exports``, where ``${project}`` is the name; of the project in lowercase and ``${distribution}`` is the name of the; distribution in lowercase, unless the project is LLVM, in which case the target; is just named ``${distribution}-cmake-exports``. These targets need to be; explicitly included in the *LLVM_<distribution>_DISTRIBUTION_COMPONENTS*; variable in order to be included as part of the distribution. Unlike with the single distribution setup, when building multiple distributions,; any components specified in *LLVM_RUNTIME_DISTRIBUTION_COMPONENTS* are not; automatically added to any distribution. Instead, you must include the targets; explicitly in some *LLVM_<distribution>_DISTRIBUTION_COMPONENTS* list. By default, each target can appear in multiple distributions; a target will be; installed as part of all distributions it appears in, and it'll be exported by; the last distribution it appears in (the order of distributions is the order; they appear in *LLVM_DISTRIBUTIONS*). We also define some umbrella targets (e.g.; ``llvm-libraries`` to install all LLVM libraries); a target can appear in a; different distribution than its umbrella, in which case the target will be; exported by the distribution it appears in (and not the distribution its; umbrella appears in). Set *LLVM_STRICT_DISTRIBUTIONS* to ``On`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:5600,variab,variable,5600,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['variab'],['variable']
Modifiability," the JIT:. .. code-block:: sh. g++ `llvm-config --cxxflags` -o HowToUseJIT.o -c HowToUseJIT.cpp; g++ `llvm-config --ldflags` -o HowToUseJIT HowToUseJIT.o \; `llvm-config --libs engine bcreader scalaropts`. OPTIONS; -------. **--assertion-mode**. Print the assertion mode used when LLVM was built (ON or OFF). **--bindir**. Print the installation directory for LLVM binaries. **--build-mode**. Print the build mode used when LLVM was built (e.g. Debug or Release). **--build-system**. Print the build system used to build LLVM (e.g. `cmake` or `gn`). **--cflags**. Print the C compiler flags needed to use LLVM headers. **--cmakedir**. Print the installation directory for LLVM CMake modules. **--components**. Print all valid component names. **--cppflags**. Print the C preprocessor flags needed to use LLVM headers. **--cxxflags**. Print the C++ compiler flags needed to use LLVM headers. **--has-rtti**. Print whether or not LLVM was built with rtti (YES or NO). **--help**. Print a summary of **llvm-config** arguments. **--host-target**. Print the target triple used to configure LLVM. **--ignore-libllvm**. Ignore libLLVM and link component libraries instead. **--includedir**. Print the installation directory for LLVM headers. **--ldflags**. Print the flags needed to link against LLVM libraries. **--libdir**. Print the installation directory for LLVM libraries. **--libfiles**. Similar to **--libs**, but print the full path to each library file. This is; useful when creating makefile dependencies, to ensure that a tool is relinked if; any library it uses changes. **--libnames**. Similar to **--libs**, but prints the bare filenames of the libraries; without **-l** or pathnames. Useful for linking against a not-yet-installed; copy of LLVM. **--libs**. Print all the libraries needed to link against the specified LLVM; *components*, including any dependencies. **--link-shared**. Link the components as shared libraries. **--link-static**. Link the component libraries statically. **--",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst:1414,config,config,1414,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,1,['config'],['config']
Modifiability," the LTO link time and memory requirements over; pure ThinLTO, as all split regular LTO modules are merged and LTO linked; with regular LTO. .. option:: -fforce-emit-vtables. In order to improve devirtualization, forces emitting of vtables even in; modules where it isn't necessary. It causes more inline virtual functions; to be emitted. .. option:: -fno-assume-sane-operator-new. Don't assume that the C++'s new operator is sane. This option tells the compiler to do not assume that C++'s global; new operator will always return a pointer that does not alias any; other pointer when the function returns. .. option:: -fassume-nothrow-exception-dtor. Assume that an exception object' destructor will not throw, and generate; less code for catch handlers. A throw expression of a type with a; potentially-throwing destructor will lead to an error. By default, Clang assumes that the exception object may have a throwing; destructor. For the Itanium C++ ABI, Clang generates a landing pad to; destroy local variables and call ``_Unwind_Resume`` for the code; ``catch (...) { ... }``. This option tells Clang that an exception object's; destructor will not throw and code simplification is possible. .. option:: -ftrap-function=[name]. Instruct code generator to emit a function call to the specified; function name for ``__builtin_trap()``. LLVM code generator translates ``__builtin_trap()`` to a trap; instruction if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:82558,variab,variables,82558,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability," the PowerPC target). Note that these two naming schemes are hardcoded into ``llvm-config``. Using; any other naming scheme will confuse ``llvm-config`` and produce a lot of; (seemingly unrelated) linker errors when linking ``llc``. To make your target actually do something, you need to implement a subclass of; ``TargetMachine``. This implementation should typically be in the file; ``lib/Target/DummyTargetMachine.cpp``, but any file in the ``lib/Target``; directory will be built and should work. To use LLVM's target independent code; generator, you should do what all current machine backends do: create a; subclass of ``LLVMTargetMachine``. (To create a target from scratch, create a; subclass of ``TargetMachine``.). To get LLVM to actually build and link your target, you need to run ``cmake``; with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=Dummy``. This will build your; target without needing to add it to the list of all the targets. Once your target is stable, you can add it to the ``LLVM_ALL_TARGETS`` variable; located in the main ``CMakeLists.txt``. Target Machine; ==============. ``LLVMTargetMachine`` is designed as a base class for targets implemented with; the LLVM target-independent code generator. The ``LLVMTargetMachine`` class; should be specialized by a concrete target class that implements the various; virtual methods. ``LLVMTargetMachine`` is defined as a subclass of; ``TargetMachine`` in ``include/llvm/Target/TargetMachine.h``. The; ``TargetMachine`` class implementation (``TargetMachine.cpp``) also processes; numerous command-line options. To create a concrete target-specific subclass of ``LLVMTargetMachine``, start; by copying an existing ``TargetMachine`` class and header. You should name the; files that you create to reflect your specific target. For instance, for the; SPARC target, name the files ``SparcTargetMachine.h`` and; ``SparcTargetMachine.cpp``. For a target machine ``XXX``, the implementation of ``XXXTargetMachine`` must; have access methods t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:7879,variab,variable,7879,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['variab'],['variable']
Modifiability," the RMS and RMS error; - `u` the number of underflows; - `o` the number of overflows; - `i` the integral of bins; - `s` the skewness; - `S` the skewness and the skewness error; - `k` the kurtosis; - `K` the kurtosis and the kurtosis error. ``` {.cpp}; gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; ```. With the option `""same""`, the statistic box is not redrawn. With the; option `""sames""`, it is re-drawn. If it hides the previous statistics; box, you can change its position with the next lines (where `h` is the; histogram pointer):. ``` {.cpp}; root[] TPaveStats *s =; (TPaveStats*)h->GetListOfFunctions()->FindObject(""stats"");; root[] s->SetX1NDC (newx1); // new x start position; root[] s->SetX2NDC (newx2); // new x end position; ```. ### Setting Line, Fill, Marker, and Text Attributes. The histogram classes inherit from the attribute classes:; **`TAttLine`**, **`TAttFill`**, **`TAttMarker`** and **`TAttText`**.; See the description of these classes for the list of options. ### Setting Tick Marks on the Axis. The **`TPad`**`::SetTicks()` method specifies the type of tick; marks on the axis. Let `tx=gPad->GetTickx()` and; `ty=gPad->GetTicky()`. - `tx` = 1; tick marks on top side are drawn (inside); - `tx` = 2; tick marks and labels on top side are drawn; - `ty` = 1; tick marks on right side are drawn (inside); - `ty` = 2; tick marks and labels on right side are drawn; - `tx=ty=0` by default only the left Y axis and X bottom axis are; drawn. Use **`TPad`**`::SetTicks(tx,ty)` to set these options. See also; the methods of **`TAxis`** that set specific axis attributes. If; multiple color-filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force the axis redrawing; over all the histograms by calling:. ``` {.cpp}; gPad->RedrawAxis();; ```. ### Giving Titles to the X, Y and Z Axis. Because t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:46789,inherit,inherit,46789,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['inherit'],['inherit']
Modifiability," the TTree object. Benefits. Flushing the write baskets has several advantages:. Reduce the file size of the TTree object (it not longer contains the last basket), improving read time of the TTree object; Reduce memory footprint of the TTree object.; In a TTree which ""flushed"" buffer, there is now usually only zero or one buffer in memory.; Previously each branch always had at least one basket in memory and usually 2 (the write basket and one read basket).; Now only the basket of the branches actually read are loaded in memory. allow for the basket to be compressed and stored separated, increasing the compression factor. Note: Calling FlushBaskets too often (either directly of via AutoSave(""FlushBaskets"")) can lead to unnecessary fragmentation of the ROOT file,; since it write the baskets to disk (and a new basket will be started at the next fill) whether or not the content was close to filling the basket or not. Others. The fast tree cloning (TTreeCloner) was enhanced to support copying in-memory TTrees (that have been save as a single key on file). This issue was preventing hadd to fast clone files containing any 'in-memory' tree. Re-enabled the splitting of TVector3 and of any classes starting by TVector; that is not a TVectorT.; Fix the list of StreamerInfo stored in the TFile in the case of a slow; CloneTree, previously some of the classes whose named contained '::' and any; of the STL container names was inadvertently omitted (in case of classes; that are part of the TTree but had only a base and no member or in some; cases where it had only object data members.; Prevent storing a 2nd time an object non derived from TObject in the case; where the object is both the top level object of branch and has; some of it sub-object containing a pointer back to the object. (This was; actually activated in v5.18).; ; void TBranch::DeleteBaskets(Option_t* option); new function which loops on all branch baskets. If the file where branch buffers reside is writable, free the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v520/index.html:7450,enhance,enhanced,7450,tree/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v520/index.html,1,['enhance'],['enhanced']
Modifiability," the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow. Bin\# 1 contains the first bin with low-edge ( `xlow` INCLUDED). The second to last bin (bin\# `nbins`) contains the upper-edge; (`xup` EXCLUDED). The Last bin (bin\# `nbins+1)` contains the overflow. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram `h` with `binx`, `biny`, `binz`,; the function returns a global/linear bin number. ``` {.cpp}; Int_t bin = h->GetBin(binx, biny, binz);; ```. This global bin is useful to access the bin information independently; of the dimension. ### Re-binning; \index{histogram!rebin}. At any time, a histogram can be re-binned via the **`TH1`**`::Rebin()`; method. It returns a new histogram with the re-binned contents. If bin; errors were stored, they are recompu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:6220,variab,variable,6220,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variable']
Modifiability," the analyzer that this path is unreachable by teaching it about your custom assertion handlers. For example, you can modify the code segment as following. void customAssert() __attribute__((analyzer_noreturn));; int foo(int *b) {; if (!b); customAssert();; return *b;; }; Q: The analyzer reports a null dereference, but I know that the; pointer is never null. How can I tell the analyzer that a pointer can never be; null?. The reason the analyzer often thinks that a pointer can be null is because the preceding code checked compared it against null. So if you are absolutely sure that it cannot be null, remove the preceding check and, preferably, add an assertion as well. For example, in the code segment above, it will be sufficient to remove the if (!b) check. . void usePointer(int *b);; int foo(int *b) {; usePointer(b);; return *b;; }; Q: How do I tell the static analyzer that I don't care about a specific dead store?; When the analyzer sees that a value stored into a variable is never used, it's going to produce a message similar to this one:; Value stored to 'x' is never read; You can use the (void)x; idiom to acknowledge that there is a dead store in your code but you do not want it to be reported in the future.; Q: How do I tell the static analyzer that I don't care about a specific unused instance variable in Objective C?; When the analyzer sees that a value stored into a variable is never used, it is going to produce a message similar to this one:; Instance variable 'commonName' in class 'HappyBird' is never used by the methods in its @implementation; You can add __attribute__((unused)) to the instance variable declaration to suppress the warning.; Q: How do I tell the static analyzer that I don't care about a specific unlocalized string?; When the analyzer sees that an unlocalized string is passed to a method that will present that string to the user, it is going to produce a message similar to this one:; User-facing text should use localized string macro. If yo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html:2369,variab,variable,2369,interpreter/llvm-project/clang/www/analyzer/faq.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html,1,['variab'],['variable']
Modifiability," the build. Options are then used for querying an; instance ``llvm::opt::ArgList``, a wrapper around the command line arguments.; This is done in the Clang driver to construct individual jobs based on the; driver arguments and also in the ``CompilerInvocation::CreateFromArgs`` function; that parses the ``-cc1`` frontend arguments. Command Line Generation; -----------------------. Any valid ``CompilerInvocation`` created from a ``-cc1`` command line can be; also serialized back into semantically equivalent command line in a; deterministic manner. This enables features such as implicitly discovered,; explicitly built modules. ..; TODO: Create and link corresponding section in Modules.rst. Adding new Command Line Option; ------------------------------. When adding a new command line option, the first place of interest is the header; file declaring the corresponding options class (e.g. ``CodeGenOptions.h`` for; command line option that affects the code generation). Create new member; variable for the option value:. .. code-block:: diff. class CodeGenOptions : public CodeGenOptionsBase {. + /// List of dynamic shared object files to be loaded as pass plugins.; + std::vector<std::string> PassPlugins;. }. Next, declare the command line interface of the option in the tablegen file; ``clang/include/clang/Driver/Options.td``. This is done by instantiating the; ``Option`` class (defined in ``llvm/include/llvm/Option/OptParser.td``). The; instance is typically created through one of the helper classes that encode the; acceptable ways to specify the option value on the command line:. * ``Flag`` - the option does not accept any value,; * ``Joined`` - the value must immediately follow the option name within the same; argument,; * ``Separate`` - the value must follow the option name in the next command line; argument,; * ``JoinedOrSeparate`` - the value can be specified either as ``Joined`` or; ``Separate``,; * ``CommaJoined`` - the values are comma-separated and must immediately fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:28656,variab,variable,28656,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['variab'],['variable']
Modifiability," the bytes in a scalar. .. code-block:: none. %1:_(s32) = G_BSWAP %0:_(s32). G_BITREVERSE; ^^^^^^^^^^^^. Reverse the order of the bits in a scalar. .. code-block:: none. %1:_(s32) = G_BITREVERSE %0:_(s32). G_SBFX, G_UBFX; ^^^^^^^^^^^^^^. Extract a range of bits from a register. The source operands are registers as follows:. - Source; - The least-significant bit for the extraction; - The width of the extraction. The least-significant bit (lsb) and width operands are in the range:. ::. 0 <= lsb < lsb + width <= source bitwidth, where all values are unsigned. G_SBFX sign-extends the result, while G_UBFX zero-extends the result. .. code-block:: none. ; Extract 5 bits starting at bit 1 from %x and store them in %a.; ; Sign-extend the result.; ;; ; Example:; ; %x = 0...0000[10110]1 ---> %a = 1...111111[10110]; %lsb_one = G_CONSTANT i32 1; %width_five = G_CONSTANT i32 5; %a:_(s32) = G_SBFX %x, %lsb_one, %width_five. ; Extract 3 bits starting at bit 2 from %x and store them in %b. Zero-extend; ; the result.; ;; ; Example:; ; %x = 1...11111[100]11 ---> %b = 0...00000[100]; %lsb_two = G_CONSTANT i32 2; %width_three = G_CONSTANT i32 3; %b:_(s32) = G_UBFX %x, %lsb_two, %width_three. Integer Operations; -------------------. G_ADD, G_SUB, G_MUL, G_AND, G_OR, G_XOR, G_SDIV, G_UDIV, G_SREM, G_UREM; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These each perform their respective integer arithmetic on a scalar. .. code-block:: none. %dst:_(s32) = G_ADD %src0:_(s32), %src1:_(s32). The above example adds %src1 to %src0 and stores the result in %dst. G_SDIVREM, G_UDIVREM; ^^^^^^^^^^^^^^^^^^^^. Perform integer division and remainder thereby producing two results. .. code-block:: none. %div:_(s32), %rem:_(s32) = G_SDIVREM %0:_(s32), %1:_(s32). G_SADDSAT, G_UADDSAT, G_SSUBSAT, G_USUBSAT, G_SSHLSAT, G_USHLSAT; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Signed and unsigned addition, subtraction and left shift with saturation. .. code-block:: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst:5720,extend,extend,5720,interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,1,['extend'],['extend']
Modifiability," the callee preserves all general purpose registers, except for; R11. R11 can be used as a scratch register. Furthermore it also preserves; all floating-point registers (XMMs/YMMs). - On AArch64 the callee preserve all general purpose registers, except X0-X8; and X16-X18. Furthermore it also preserves lower 128 bits of V8-V31 SIMD -; floating point registers. The idea behind this convention is to support calls to runtime functions; that don't need to call out to any other functions. This calling convention, like the `PreserveMost` calling convention, will be; used by a future version of the ObjectiveC runtime and should be considered; experimental at this time.; ""``cxx_fast_tlscc``"" - The `CXX_FAST_TLS` calling convention for access functions; Clang generates an access function to access C++-style TLS. The access; function generally has an entry block, an exit block and an initialization; block that is run at the first time. The entry and exit blocks can access; a few TLS IR variables, each access will be lowered to a platform-specific; sequence. This calling convention aims to minimize overhead in the caller by; preserving as many registers as possible (all the registers that are; preserved on the fast path, composed of the entry and exit blocks). This calling convention behaves identical to the `C` calling convention on; how arguments and return values are passed, but it uses a different set of; caller/callee-saved registers. Given that each platform has its own lowering sequence, hence its own set; of preserved registers, we can't use the existing `PreserveMost`. - On X86-64 the callee preserves all general purpose registers, except for; RDI and RAX.; ""``tailcc``"" - Tail callable calling convention; This calling convention ensures that calls in tail position will always be; tail call optimized. This calling convention is equivalent to fastcc,; except for an additional guarantee that tail calls will be produced; whenever possible. `Tail calls can only be optimized",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:20198,variab,variables,20198,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability," the content of base class onfile that have been removed from the in-memory class layout. - The scheduling the I/O customization rules within a StreamerInfo is now as soon as possible, i.e. after all sources have been read. One significant consequence is that now when an object is stored in a split branch; the rule is associtated with the branch of the last of the rule's sources rather; than the last of the object's data member. - Properly support TStreamerInfo written by ROOT v4.00. - Fix the ordering of the keys in a TFile being written; in particular fixing the result of GetKey and FindKey which were no longer returning the lastest cycle for a TFile being written since v5.34/11. ## Networking Libraries. ### HTTP Server. ##### Command Interface; One can now register an arbitrary command to the server, which become visible in the web browser. Then, when the item is clicked by the user, the command ends-up in a gROOT->ProcessLineSync() call. ##### Custom Properties ; Custom properties can be configured for any item in the server. For example, one could configure an icon for each item visible in the browser. Or one could 'hide' any item from the user (but keep access with normal http requests). With such properties one could specify which item is drawn when web page is loaded, or configure monitoring. See tutorials/http/httpcontrol.C macro for more details. ##### Method Calls; Implement exe.json requests to be able to execute any method of registered objects. This request is used to provide remote TTree::Draw() functionality. ##### Misc; Correctly set 'Cache-Control' headers when replying to http requests.; Better support of STL containers when converting objects into json with TBufferJSON class. ## JavaScript ROOT. - Several files can now be loaded simultaneously; - Use d3.time.scale to display time scales; - Implemented drag and drop to superimpose histograms or graphs; - Allow selection of drawing option via context menu; - Better support of touch devices; - Provi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:9640,config,configured,9640,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['config'],['configured']
Modifiability," the current compilation unit for a base type of the; generic type. The operation is equivalent to performing ``DW_OP_deref_type S, DR``. 3. ``DW_OP_deref_size``. ``DW_OP_deref_size`` has a single 1-byte unsigned integral constant that; represents a byte result size S. TS is the smaller of the generic type bit size and S scaled by 8 (the byte; size). If TS is smaller than the generic type bit size then T is an unsigned; integral type of bit size TS, otherwise T is the generic type. DR is the; offset of a hypothetical debug information entry D in the current; compilation unit for a base type T. .. note::. Truncating the value when S is larger than the generic type matches what; GDB does. This allows the generic type size to not be an integral byte; size. It does allow S to be arbitrarily large. Should S be restricted to; the size of the generic type rounded up to a multiple of 8?. The operation is equivalent to performing ``DW_OP_deref_type S, DR``, except; if T is not the generic type, the value V pushed is zero-extended to the; generic type bit size and its type changed to the generic type. 4. ``DW_OP_deref_type``. ``DW_OP_deref_type`` has two operands. The first is a 1-byte unsigned; integral constant S. The second is an unsigned LEB128 integer DR that; represents the byte offset of a debugging information entry D relative to; the beginning of the current compilation unit, that provides the type T of; the result value. TS is the bit size of the type T. *While the size of the pushed value V can be inferred from the type T, it is; encoded explicitly as the operand S so that the operation can be parsed; easily without reference to the* ``.debug_info`` *section.*. .. note::. It is unclear why the operand S is needed. Unlike ``DW_OP_const_type``,; the size is not needed for parsing. Any evaluation needs to get the base; type T to push with the value to know its encoding and bit size. It pops one stack entry that must be a location description L. A value V of TS bits is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:89881,extend,extended,89881,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extended']
Modifiability," the destination context. If it happens to be equivalent then; we skip the copy. The informal definition of structural equivalency is the following:; Two nodes are **structurally equivalent** if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are; structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same; identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and; their types are structurally equivalent. In C, two types are structurally equivalent if they are *compatible types*. For; a formal definition of *compatible types*, please refer to 6.2.7/1 in the C11; standard. However, there is no definition for *compatible types* in the C++; standard. Still, we extend the definition of structural equivalency to; templates and their instantiations similarly: besides checking the previously; mentioned properties, we have to check for equivalent template; parameters/arguments, etc. The structural equivalent check can be and is used independently from the; ASTImporter, e.g. the ``clang::Sema`` class uses it also. The equivalence of nodes may depend on the equivalency of other pairs of nodes.; Thus, the check is implemented as a parallel graph traversal. We traverse; through the nodes of both graphs at the same time. The actual implementation is; similar to breadth-first-search. Let's say we start the traverse with the <A,B>; pair of nodes. Whenever the traversal reaches a pair <X,Y> then the following; statements are true:. - A and X are nodes from the same ASTContext.; - B and Y are nodes from the same ASTContext.; - A and B may or may not be from the same ASTContext.; - if A == X and B == Y (pointer equivalency) then (there is a cycle during the; traverse). - A and B are structurally equivalent if and only if. - All dependent nodes on the path fro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:92572,extend,extend,92572,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['extend'],['extend']
Modifiability," the effects of parameter limits may be found in; the last chapter. ## M strategy ##. At many places in the analysis of the $\mbox{FCN}$ (the user; provided function), M must decide whether to be ""safe"" and waste a few; function calls in order to know where it is, or to be ""fast"" and attempt; to get the requested results with the fewest possible calls at a certain; risk of not obtaining the precision desired by the user. In order to; allow the user to influence these decisions, there is a M class; MnStrategy (see [api:strategy]) which the user can use to put different; settings. In the current release, this MnStrategy can be instantiated; with three different minimization quality levels for low (0), medium (1); and high (2) quality. Default settings for iteration cycles and; tolerances are initialized then. The default setting is set for medium; quality. Value 0 (low) indicates to M that it should economize function; calls; it is intended for cases where there are many variable parameters; and/or the function takes a long time to calculate and/or the user is; not interested in very precise values for parameter errors. On the other; hand, value 2 (high) indicates that M is allowed to waste function calls; in order to be sure that all values are precise; it is intended for; cases where the function is evaluated in a relatively short time and/or; where the parameter errors must be calculated reliably. In addition all; constants set in MnStrategy can be changed individually by the user,; e.g. the number of iteration cycles in the numerical gradient. ## Parameter errors ##. M is usually used to find the ""best"" values of a set of parameters,; where ""best"" is defined as those values which minimize a given function,; $\mbox{FCN}$. The width of the function minimum, or more generally,; the shape of the function in some neighbourhood of the minimum, gives; information about the *uncertainty* in the best parameter values, often; called by physicists the *parameter errors*. An i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:11861,variab,variable,11861,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability," the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:2143,plugin,plugin,2143,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,3,"['config', 'plugin']","['configured', 'plugin', 'plugins']"
Modifiability," the features, so that buildbots that; run on different architectures (and don't even compile all back-ends),; don't fail. The first problem is to check for target-specific output, for example sizes; of structures, paths and architecture names, for example:. * Tests containing Windows paths will fail on Linux and vice-versa.; * Tests that check for ``x86_64`` somewhere in the text will fail anywhere else.; * Tests where the debug information calculates the size of types and structures. Also, if the test rely on any behaviour that is coded in any back-end, it must; go in its own directory. So, for instance, code generator tests for ARM go; into ``test/CodeGen/ARM`` and so on. Those directories contain a special; ``lit`` configuration file that ensure all tests in that directory will; only run if a specific back-end is compiled and available. For instance, on ``test/CodeGen/ARM``, the ``lit.local.cfg`` is:. .. code-block:: python. config.suffixes = ['.ll', '.c', '.cpp', '.test']; if not 'ARM' in config.root.targets:; config.unsupported = True. Other platform-specific tests are those that depend on a specific feature; of a specific sub-architecture, for example only to Intel chips that support ``AVX2``. For instance, ``test/CodeGen/X86/psubus.ll`` tests three sub-architecture; variants:. .. code-block:: llvm. ; RUN: llc -mcpu=core2 < %s | FileCheck %s -check-prefix=SSE2; ; RUN: llc -mcpu=corei7-avx < %s | FileCheck %s -check-prefix=AVX1; ; RUN: llc -mcpu=core-avx2 < %s | FileCheck %s -check-prefix=AVX2. And the checks are different:. .. code-block:: llvm. ; SSE2: @test1; ; SSE2: psubusw LCPI0_0(%rip), %xmm0; ; AVX1: @test1; ; AVX1: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0; ; AVX2: @test1; ; AVX2: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0. So, if you're testing for a behaviour that you know is platform-specific or; depends on special features of sub-architectures, you must add the specific; triple, test with the specific FileCheck and put it into the specific; directory that will",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:18463,config,config,18463,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['config']
Modifiability," the final; application is created the linker will provide the; ``__start_omp_offloading_entries`` and ``__stop_omp_offloading_entries`` symbols; which are used to create the :ref:`final image <Device Binary Wrapping>`. This information is used by the device compilation stage to determine which; symbols need to be exported from the device. We use the ``omp_offload.info``; metadata node to pass this information device compilation stage. Accessing Entries on the Device; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Accessing the entries in the device is done using the address field in the; :ref:`offload entry<table-tgt_offload_entry_structure>`. The runtime will set; the address to the pointer associated with the device image during runtime; initialization. This is used to call the corresponding kernel function when; entering a ``#pragma omp target`` region. For variables, the runtime maintains a; table mapping host pointers to device pointers. Global variables inside a; ``#pragma omp target declare`` directive are first initialized to the host's; address. Once the device address is initialized we insert it into the table to; map the host address to the device address. Debugging Information; ^^^^^^^^^^^^^^^^^^^^^. We generate structures to hold debugging information that is passed to; ``libomptarget``. This allows the front-end to generate information the runtime; library uses for more informative error messages. This is done using the; standard :ref:`identifier structure <table-ident_t_structure>` used in; ``libomp`` and ``libomptarget``. This is used to pass information and source; locations to the runtime. .. table:: ident_t Structure; :name: table-ident_t_structure. +---------+------------+-----------------------------------------------------------------------------+; | Type | Identifier | Description |; +=========+============+=============================================================================+; | int32_t | reserved | Reserved, to be used by the runtime library. |; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:7896,variab,variables,7896,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['variab'],['variables']
Modifiability," the following things:. * Set ``make`` variables. There are several variables that a ``Makefile`` needs; to set to use the LLVM build system:. * ``PROJECT_NAME`` - The name by which your project is known.; * ``LLVM_SRC_ROOT`` - The root of the LLVM source tree.; * ``LLVM_OBJ_ROOT`` - The root of the LLVM object tree.; * ``PROJ_SRC_ROOT`` - The root of the project's source tree.; * ``PROJ_OBJ_ROOT`` - The root of the project's object tree.; * ``PROJ_INSTALL_ROOT`` - The root installation directory.; * ``LEVEL`` - The relative path from the current directory to the; project's root ``($PROJ_OBJ_ROOT)``. * Include ``Makefile.config`` from ``$(LLVM_OBJ_ROOT)``. * Include ``Makefile.rules`` from ``$(LLVM_SRC_ROOT)``. There are two ways that you can set all of these variables:. * You can write your own ``Makefiles`` which hard-code these values. * You can use the pre-made LLVM sample project. This sample project includes; ``Makefiles``, a configure script that can be used to configure the location; of LLVM, and the ability to support multiple object directories from a single; source directory. If you want to devise your own build system, studying other projects and LLVM; ``Makefiles`` will probably provide enough information on how to write your own; ``Makefiles``. Source Tree Layout; ==================. In order to use the LLVM build system, you will want to organize your source; code so that it can benefit from the build system's features. Mainly, you want; your source tree layout to look similar to the LLVM source tree layout. Underneath your top level directory, you should have the following directories:. **lib**. This subdirectory should contain all of your library source code. For each; library that you build, you will have one directory in **lib** that will; contain that library's source code. Libraries can be object files, archives, or dynamic libraries. The **lib**; directory is just a convenient place for libraries as it places them all in; a directory from which ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:1276,config,configure,1276,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,2,['config'],['configure']
Modifiability," the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:8603,variab,variables,8603,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['variab'],['variables']
Modifiability," the hardware-loop, and thus; not e.g. the loop back-edge taken count. Semantics:; """""""""""""""""""". The '``llvm.set.loop.iterations.*``' intrinsics do not perform any arithmetic; on their operand. It's a hint to the backend that can use this to set up the; hardware-loop count with a target specific instruction, usually a move of this; value to a special register or a hardware-loop instruction. '``llvm.start.loop.iterations.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i32 @llvm.start.loop.iterations.i32(i32); declare i64 @llvm.start.loop.iterations.i64(i64). Overview:; """""""""""""""""". The '``llvm.start.loop.iterations.*``' intrinsics are similar to the; '``llvm.set.loop.iterations.*``' intrinsics, used to specify the; hardware-loop trip count but also produce a value identical to the input; that can be used as the input to the loop. They are placed in the loop; preheader basic block and the output is expected to be the input to the; phi for the induction variable of the loop, decremented by the; '``llvm.loop.decrement.reg.*``'. Arguments:; """""""""""""""""""". The integer operand is the loop trip count of the hardware-loop, and thus; not e.g. the loop back-edge taken count. Semantics:; """""""""""""""""""". The '``llvm.start.loop.iterations.*``' intrinsics do not perform any arithmetic; on their operand. It's a hint to the backend that can use this to set up the; hardware-loop count with a target specific instruction, usually a move of this; value to a special register or a hardware-loop instruction. '``llvm.test.set.loop.iterations.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i1 @llvm.test.set.loop.iterations.i32(i32); declare i1 @llvm.test.set.loop.iterations.i64(i64). Overview:; """""""""""""""""". The '``llvm.test.set.loop.iterations.*``' intrinsics are used to specify the; the loop trip count, and also test that the given count is not zero,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:644698,variab,variable,644698,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," the kernarg memory; visible to the kernel; code. 127:96 4 bytes Reserved, must be 0.; 191:128 8 bytes KERNEL_CODE_ENTRY_BYTE_OFFSET Byte offset (possibly; negative) from base; address of kernel; descriptor to kernel's; entry point instruction; which must be 256 byte; aligned.; 351:272 20 Reserved, must be 0.; bytes; 383:352 4 bytes COMPUTE_PGM_RSRC3 GFX6-GFX9; Reserved, must be 0.; GFX90A, GFX940; Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC3``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc3-gfx90a-table`.; GFX10-GFX11; Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC3``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc3-gfx10-gfx11-table`.; GFX12; Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC3``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc3-gfx12-table`.; 415:384 4 bytes COMPUTE_PGM_RSRC1 Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC1``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc1-gfx6-gfx12-table`.; 447:416 4 bytes COMPUTE_PGM_RSRC2 Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC2``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc2-gfx6-gfx12-table`.; 458:448 7 bits *See separate bits below.* Enable the setup of the; SGPR user data registers; (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). The total number of SGPR; user data registers; requested must not exceed; 16 and match value in; ``compute_pgm_rsrc2.user_sgpr.user_sgpr_count``.; Any requests beyond 16; will be ignored.; >448 1 bit ENABLE_SGPR_PRIVATE_SEGMENT If the *Target Properties*; _BUFFER column of; :ref:`amdgpu-processor-table`; specifies *Architected flat; scratch* then not supported; and must be 0,; >449 1 bit ENABLE_SGPR_DISPATCH_PTR; >450 1 bit ENABLE_SGPR_QUEUE_PTR; >451 1 bit ENABLE_SGPR_KERNARG_SEGMENT_PTR; >452 1 bit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:160895,config,configuration,160895,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['config'],['configuration']
Modifiability," the library or framework against which the program should be linked. For example, specifying ""clangBasic"" would instruct the linker to link with ``-lclangBasic`` for a Unix-style linker. A *link-declaration* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46594,config,config-macro-list,46594,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['config'],['config-macro-list']
Modifiability," the list or perform a complex action that doesn't have a forwarding; method. * ``BasicBlock &getEntryBlock()``. Returns the entry ``BasicBlock`` for the function. Because the entry block; for the function is always the first block, this returns the first block of; the ``Function``. * | ``Type *getReturnType()``; | ``FunctionType *getFunctionType()``. This traverses the Type_ of the ``Function`` and returns the return type of; the function, or the FunctionType_ of the actual function. * ``SymbolTable *getSymbolTable()``. Return a pointer to the SymbolTable_ for this ``Function``. .. _GlobalVariable:. The ``GlobalVariable`` class; ----------------------------. ``#include ""llvm/IR/GlobalVariable.h""``. header source: `GlobalVariable.h; <https://llvm.org/doxygen/GlobalVariable_8h_source.html>`_. doxygen info: `GlobalVariable Class; <https://llvm.org/doxygen/classllvm_1_1GlobalVariable.html>`_. Superclasses: GlobalValue_, Constant_, User_, Value_. Global variables are represented with the (surprise surprise) ``GlobalVariable``; class. Like functions, ``GlobalVariable``\ s are also subclasses of; GlobalValue_, and as such are always referenced by their address (global values; must live in memory, so their ""name"" refers to their constant address). See; GlobalValue_ for more on this. Global variables may have an initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of link",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:158668,variab,variables,158668,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variables']
Modifiability," the member ``a`` to ``3``, thus the ``InitListExpr`` ``{0}`` is not; used here and the AST node is not instantiated. However, in the case of; ``bar.cpp`` we use the constructor with number ``(2)``, which does not; explicitly initialize the ``a`` member, so the default ``InitListExpr`` is; needed and thus instantiated. When we merge the AST of ``foo.cpp`` and; ``bar.cpp`` we must create an AST node for the class template instantiation of; ``X<char>`` which has all the required nodes. Therefore, when we find an; existing ``ClassTemplateSpecializationDecl`` then we merge the fields of the; ``ClassTemplateSpecializationDecl`` in the ""from"" context in a way that the; ``InitListExpr`` is copied if not existent yet. The same merge mechanism should; be done in the cases of instantiated default arguments and exception; specifications of functions. .. _visibility:. Visibility of Declarations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. During import of a global variable with external visibility, the lookup will; find variables (with the same name) but with static visibility (linkage).; Clearly, we cannot put them into the same redeclaration chain. The same is true; the in case of functions. Also, we have to take care of other kinds of; declarations like enums, classes, etc. if they are in anonymous namespaces.; Therefore, we filter the lookup results and consider only those which have the; same visibility as the declaration we currently import. We consider two declarations in two anonymous namespaces to have the same; visibility only if they are imported from the same AST context. Strategies to Handle Conflicting Names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. During the import we lookup existing declarations with the same name. We filter; the lookup results based on their :ref:`visibility <visibility>`. If any of the; found declarations are not structurally equivalent then we bumped to a name; conflict error (ODR violation in C++). In this case, we return with an; ``Error`` and we set up th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:110026,variab,variable,110026,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['variab'],"['variable', 'variables']"
Modifiability," the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:33514,config,configuration,33514,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability," the original debug intrinsic.; * Any number of operands, from the 3rd onwards, record a sequence of variable; location operands, which may take any of the same values as the first; operand of the ``DBG_VALUE`` instruction above. These variable location; operands are inserted into the final DWARF Expression in positions indicated; by the DW_OP_LLVM_arg operator in the `DIExpression; <LangRef.html#diexpression>`_. The position at which the DBG_VALUEs are inserted should correspond to the; positions of their matching ``llvm.dbg.value`` intrinsics in the IR block. As; with optimization, LLVM aims to preserve the order in which variable; assignments occurred in the source program. However SelectionDAG performs some; instruction scheduling, which can reorder assignments (discussed below).; Function parameter locations are moved to the beginning of the function if; they're not already, to ensure they're immediately available on function entry. To demonstrate variable locations during instruction selection, consider; the following example:. .. code-block:: llvm. define i32 @foo(i32* %addr) {; entry:; call void @llvm.dbg.value(metadata i32 0, metadata !3, metadata !DIExpression()), !dbg !5; br label %bb1, !dbg !5. bb1: ; preds = %bb1, %entry; %bar.0 = phi i32 [ 0, %entry ], [ %add, %bb1 ]; call void @llvm.dbg.value(metadata i32 %bar.0, metadata !3, metadata !DIExpression()), !dbg !5; %addr1 = getelementptr i32, i32 *%addr, i32 1, !dbg !5; call void @llvm.dbg.value(metadata i32 *%addr1, metadata !3, metadata !DIExpression()), !dbg !5; %loaded1 = load i32, i32* %addr1, !dbg !5; %addr2 = getelementptr i32, i32 *%addr, i32 %bar.0, !dbg !5; call void @llvm.dbg.value(metadata i32 *%addr2, metadata !3, metadata !DIExpression()), !dbg !5; %loaded2 = load i32, i32* %addr2, !dbg !5; %add = add i32 %bar.0, 1, !dbg !5; call void @llvm.dbg.value(metadata i32 %add, metadata !3, metadata !DIExpression()), !dbg !5; %added = add i32 %loaded1, %loaded2; %cond = icmp ult i32 %added, %bar.0, !",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:29294,variab,variable,29294,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability," the patch with a `Looks good to me` or `LGTM`.; Once that is done the change can be committed. If you do not have commit; access, please let people know during the review and someone should commit it; on your behalf. If you have received no comments on your patch for a week, you can request a; review by 'ping'ing the GitHub PR with ""Ping"". The common courtesy 'ping' rate; is once a week. Please remember that you are asking for valuable time from other; professional developers. For more information on LLVM's code-review process, please see :doc:`CodeReview`. .. _commit_from_git:. For developers to commit changes from Git; -----------------------------------------. Once a patch is reviewed, you can select the ""Squash and merge"" button in the; GitHub web interface. You might need to rebase your change before pushing; it to the repo. LLVM currently has a linear-history policy, which means that merge commits are; not allowed. The `llvm-project` repo on github is configured to reject pushes; that include merges, so the `git rebase` step above is required. Please ask for help if you're having trouble with your particular git workflow. .. _git_pre_push_hook:. Git pre-push hook; ^^^^^^^^^^^^^^^^^. We include an optional pre-push hook that run some sanity checks on the revisions; you are about to push and ask confirmation if you push multiple commits at once.; You can set it up (on Unix systems) by running from the repository root:. .. code-block:: console. % ln -sf ../../llvm/utils/git/pre-push.py .git/hooks/pre-push. Helpful Information About LLVM; ==============================; :doc:`LLVM's documentation <index>` provides a wealth of information about LLVM's internals as; well as various user guides. The pages listed below should provide a good overview; of LLVM's high-level design, as well as its internals:. :doc:`GettingStarted`; Discusses how to get up and running quickly with the LLVM infrastructure.; Everything from unpacking and compilation of the distribution to ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst:5710,config,configured,5710,interpreter/llvm-project/llvm/docs/Contributing.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst,1,['config'],['configured']
Modifiability," the phi nodes when lowering; assignments to mutable variables?"". The issue here is that LLVM; *requires* that its IR be in SSA form: there is no ""non-ssa"" mode for; it. However, SSA construction requires non-trivial algorithms and data; structures, so it is inconvenient and wasteful for every front-end to; have to reproduce this logic. Memory in LLVM; ==============. The 'trick' here is that while LLVM does require all register values to; be in SSA form, it does not require (or permit) memory objects to be in; SSA form. In the example above, note that the loads from G and H are; direct accesses to G and H: they are not renamed or versioned. This; differs from some other compiler systems, which do try to version memory; objects. In LLVM, instead of encoding dataflow analysis of memory into; the LLVM IR, it is handled with `Analysis; Passes <../../WritingAnLLVMPass.html>`_ which are computed on demand. With this in mind, the high-level idea is that we want to make a stack; variable (which lives in memory, because it is on the stack) for each; mutable object in a function. To take advantage of this trick, we need; to talk about how LLVM represents stack variables. In LLVM, all memory accesses are explicit with load/store instructions,; and it is carefully designed not to have (or need) an ""address-of""; operator. Notice how the type of the @G/@H global variables is actually; ""i32\*"" even though the variable is defined as ""i32"". What this means is; that @G defines *space* for an i32 in the global data area, but its; *name* actually refers to the address for that space. Stack variables; work the same way, except that instead of being declared with global; variable definitions, they are declared with the `LLVM alloca; instruction <../../LangRef.html#alloca-instruction>`_:. .. code-block:: llvm. define i32 @example() {; entry:; %X = alloca i32 ; type of %X is i32*.; ...; %tmp = load i32, i32* %X ; load the stack value %X from the stack.; %tmp2 = add i32 %tmp, 1 ; increment ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:4133,variab,variable,4133,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability," the program or; not. Blocks using automatic (stack) memory are objects and may be; messaged, although they may not be assigned into ``__weak`` locations; if garbage collection is enabled. Within a Block literal expression within a method definition; references to instance variables are also imported into the lexical; scope of the compound statement. These variables are implicitly; qualified as references from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains all objects held in; variables of automatic storage referenced within the Block expression; (or form strong references if running under garbage collection).; Object variables of ``__block`` storage type are assumed to hold; normal pointers with no provision for retain and release messages. Foundation defines (and supplies) ``-copy`` and ``-release`` methods for; Blocks. In the Objective-C and Objective-C++ languages, we allow the; ``__weak`` specifier for ``__block`` variables of object type. If; garbage collection is not enabled, this qualifier causes these; variables to be kept without retain messages being sent. This; knowingly leads to dangling pointers if the Block (or a copy) outlives; the lifetime of this object. In garbage collected environments, the ``__weak`` variable is set to; nil when the object it references is collected, as long as the; ``__block`` variable resides in the heap (either by default or via; ``Block_copy()``). The initial Apple implementation does in fact; start ``__block`` variables on the stack and migrate them to the heap; only as a result of a ``Block_copy()`` operation. It is a runtime error to attempt to assign a reference to a; stack-based Block into any storage marked ``__weak``, including; ``__weak`` ``__block`` variables. C++ Extensions; ==============. Block literal expressions within functions are extended to allow const; use of C++ objects, pointers, or references held in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:10171,variab,variables,10171,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variables']
Modifiability," the same name to a method (remember: method = member function; of a class) in the child class (**`TArrow`**) as in the parent; (**`TLine`**) does not give any problem. This is called **overriding**; a method. Draw in **`TArrow`** overrides Draw in **`TLine`**. There is; no possible ambiguity since, when one calls the `Draw()` method; this; applies to an object whose type is known. Suppose we have an object; `l` of type **`TLine`** and an object `a` of type **`TArrow`**. When; you want to draw the line, you do:. ``` {.cpp}; l.Draw();; ```. `Draw()` from **`TLine`** is called. If you do:. ``` {.cpp}; a.Draw();; ```. `Draw()` from **`TArrow`** is called and the arrow `a` is drawn. ### Data Encapsulation. We have seen previously the keyword ""`public`"". This keyword means; that every name declared public is seen by the outside world. This is; opposed to ""`private`"" that means only the class where the name was; declared private could see this name. For example, suppose we declare; in **`TArrow`** the variable `ArrowHeadSize` private. ``` {.cpp}; private:; int ArrowHeadSize;; ```. Then, only the methods (i.e. member functions) of **`TArrow`** will be; able to access this variable. Nobody else will see it. Even the; classes that we could derive from **`TArrow`** will not see it. On the; other hand, if we declare the method `Draw()` as public, everybody will; be able to see it and use it. You see that the character public or; private does not depend of the type of argument. It can be a data; member, a member function, or even a class. For example, in the case; of **`TArrow`**, the base class **`TLine`** is declared as public:. ``` {.cpp}; class TArrow : public TLine { ...; ```. This means that all methods of **`TArrow`** will be able to access all; methods of **`TLine`**, but this will be also true for anybody in the; outside world. Of course, this is true if **`TLine`** accepts the; outside world to see its methods/data members. If something is; declared private in **`TLine",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:4183,variab,variable,4183,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['variab'],['variable']
Modifiability," their address (global values; must live in memory, so their ""name"" refers to their constant address). See; GlobalValue_ for more on this. Global variables may have an initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial value for a ``GlobalVariable``. It is not legal to call; this method if there is no initializer. .. _BasicBlock:. The ``BasicBlock`` class; ------------------------. ``#include ""llvm/IR/BasicBlock.h""``. header source: `BasicBlock.h; <https://llvm.org/doxyge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:159913,variab,variable,159913,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability," them under that assumption.; This is something we'd like to change in the future to provide better; support for freestanding environments and non-C-based languages. .. _i_va_arg:. '``va_arg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = va_arg <va_list*> <arglist>, <argty>. Overview:; """""""""""""""""". The '``va_arg``' instruction is used to access arguments passed through; the ""variable argument"" area of a function call. It is used to implement; the ``va_arg`` macro in C. Arguments:; """""""""""""""""""". This instruction takes a ``va_list*`` value and the type of the; argument. It returns a value of the specified argument type and; increments the ``va_list`` to point to the next argument. The actual; type of ``va_list`` is target specific. Semantics:; """""""""""""""""""". The '``va_arg``' instruction loads an argument of the specified type; from the specified ``va_list`` and causes the ``va_list`` to point to; the next argument. For more information, see the variable argument; handling :ref:`Intrinsic Functions <int_varargs>`. It is legal for this instruction to be called in a function which does; not take a variable number of arguments, for example, the ``vfprintf``; function. ``va_arg`` is an LLVM instruction instead of an :ref:`intrinsic; function <intrinsics>` because it takes a type as an argument. Example:; """""""""""""""". See the :ref:`variable argument processing <int_varargs>` section. Note that the code generator does not yet fully support va\_arg on many; targets. Also, it does not currently support va\_arg with aggregate; types on any target. .. _i_landingpad:. '``landingpad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = landingpad <resultty> <clause>+; <resultval> = landingpad <resultty> cleanup <clause>*. <clause> := catch <type> <value>; <clause> := filter <array constant type> <array constant>. Overview:; """""""""""""""""". The '``landingpad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:479841,variab,variable,479841,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," then use the; :ref:`mem2reg <passes-mem2reg>` functionality to construct the appropriate; SSA form for the variable. ``loop-deletion``: Delete dead loops; ------------------------------------. This file implements the Dead Loop Deletion Pass. This pass is responsible for; eliminating loops with non-infinite computable trip counts that have no side; effects or volatile instructions, and do not contribute to the computation of; the function's return value. .. _passes-loop-extract:. ``loop-extract``: Extract loops into new functions; --------------------------------------------------. A pass wrapper around the ``ExtractLoop()`` scalar transformation to extract; each top-level loop into its own new function. If the loop is the *only* loop; in a given function, it is not touched. This is a pass most useful for; debugging via bugpoint. ``loop-reduce``: Loop Strength Reduction; ----------------------------------------. This pass performs a strength reduction on array references inside loops that; have as one or more of their components the loop induction variable. This is; accomplished by creating a new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:26109,variab,variable,26109,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variable']
Modifiability," there is no ""non-ssa"" mode for; it. However, SSA construction requires non-trivial algorithms and data; structures, so it is inconvenient and wasteful for every front-end to; have to reproduce this logic. Memory in LLVM; ==============. The 'trick' here is that while LLVM does require all register values to; be in SSA form, it does not require (or permit) memory objects to be in; SSA form. In the example above, note that the loads from G and H are; direct accesses to G and H: they are not renamed or versioned. This; differs from some other compiler systems, which do try to version memory; objects. In LLVM, instead of encoding dataflow analysis of memory into; the LLVM IR, it is handled with `Analysis; Passes <../../WritingAnLLVMPass.html>`_ which are computed on demand. With this in mind, the high-level idea is that we want to make a stack; variable (which lives in memory, because it is on the stack) for each; mutable object in a function. To take advantage of this trick, we need; to talk about how LLVM represents stack variables. In LLVM, all memory accesses are explicit with load/store instructions,; and it is carefully designed not to have (or need) an ""address-of""; operator. Notice how the type of the @G/@H global variables is actually; ""i32\*"" even though the variable is defined as ""i32"". What this means is; that @G defines *space* for an i32 in the global data area, but its; *name* actually refers to the address for that space. Stack variables; work the same way, except that instead of being declared with global; variable definitions, they are declared with the `LLVM alloca; instruction <../../LangRef.html#alloca-instruction>`_:. .. code-block:: llvm. define i32 @example() {; entry:; %X = alloca i32 ; type of %X is i32*.; ...; %tmp = load i32, i32* %X ; load the stack value %X from the stack.; %tmp2 = add i32 %tmp, 1 ; increment it; store i32 %tmp2, i32* %X ; store it back; ... This code shows an example of how you can declare and manipulate a stack; variable ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:4316,variab,variables,4316,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability," they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (upper), M uses the following transformation:. $$\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}$$. so that the internal value $P_{\mathrm{int}}$ can take on any value,; while",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:7504,variab,variable,7504,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,2,['variab'],['variable']
Modifiability," they exist, but will not; cause an error if they do not exist. They are built serially in the order; in which they are listed. Variables for Building Libraries; --------------------------------. ``LIBRARYNAME``. This variable contains the base name of the library that will be built. For; example, to build a library named ``libsample.a``, ``LIBRARYNAME`` should; be set to ``sample``. ``BUILD_ARCHIVE``. By default, a library is a ``.o`` file that is linked directly into a; program. To build an archive (also known as a static library), set the; ``BUILD_ARCHIVE`` variable. ``SHARED_LIBRARY``. If ``SHARED_LIBRARY`` is defined in your Makefile, a shared (or dynamic); library will be built. Variables for Building Programs; -------------------------------. ``TOOLNAME``. This variable contains the name of the program that will be built. For; example, to build an executable named ``sample``, ``TOOLNAME`` should be set; to ``sample``. ``USEDLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be libraries that come from; your **lib** directory. The libraries must be specified without their; ``lib`` prefix. For example, to link ``libsample.a``, you would set; ``USEDLIBS`` to ``sample.a``. Note that this works only for statically linked libraries. ``LLVMLIBS``. This variable holds a space separated list of libraries that should be; linked into the program. These libraries must be LLVM libraries. The; libraries must be specified without their ``lib`` prefix. For example, to; link with a driver that performs an IR transformation you might set; ``LLVMLIBS`` to this minimal set of libraries ``LLVMSupport.a LLVMCore.a; LLVMBitReader.a LLVMAsmParser.a LLVMAnalysis.a LLVMTransformUtils.a; LLVMScalarOpts.a LLVMTarget.a``. Note that this works only for statically linked libraries. LLVM is split; into a large number of static libraries, and the list of libraries you; require may be much longer than the list above. To",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:6076,variab,variable,6076,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,1,['variab'],['variable']
Modifiability," they return.; More flexibility in the mode of execution. The new study manager can execute all study; modules inlines, as was done in RooMCStudy), but also parallelized through PROOF (at present; only PROOF-lite is support, as well as in batch. The code fragment below illustrates the use of the new study manager. // Create workspace with p.d.f; RooWorkspace* ww = new RooWorkspace(""ww"") ;; ww->factory(""Gaussian::g(x[-10,10],mean[-10,10],sigma[3,0.1,10])"") ;. RooGenFitStudy gfs ;; gfs.setGenConfig(""g"",""x"",NumEvents(1000)) ;; gfs.setFitConfig(""g"",""x"",PrintLevel(-1)) ;. RooStudyManager mgr(*ww,gfs) ;. mgr.run(1000) ; // execute 1000 toys inline; mgr.runProof(10000,"""") ; // execute 10000 toys through PROOF-lite. gfs.summaryData()->Print() ;. Workspace and factory improvements. The workspace class RooWorkspace has been augmented with several; new features. The import() method now supports a new argument RenameAllVariablesExcept(const char* suffix, const char keepList) which; will rename all variables of the imported function by extended them with a supplied suffix,; except for a given list of variables, which are not renamed.; A new utility function importFromFile() has been added, which is similar to import, except that it take a string; specifier for the object to be imported rather than a reference. The string is expected to be of the form ; fileName:workspaceName:objectName and simplifies import of objects from other workspaces on file. The importFromFile; accepts all arguments accepted by the standard import() method.; Generic objects (inheriting from TObject) can now also be stored in the workspace under an alias name, rather; under their own name, which simplifies management of objects of types like TMatrixD that do not have a settable name. ws.import(matrix,""cov_matrix"") ;. New accessors have been added that return a RooArgSet of all elements of the workspace of a given type, e.g.; allVars(), allPdfs(). The Print() method now accepts option ""t"", which prints the c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:2032,variab,variables,2032,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,3,"['extend', 'variab']","['extended', 'variables']"
Modifiability," thing to note is the difference between the ``install``; and ``install-distribution`` targets. The ``install`` target is expected to; install every part of LLVM that your build is configured to generate except the; LLVM testing tools. Alternatively the ``install-distribution`` target, which is; recommended for building distributions, only installs specific parts of LLVM as; specified at configuration time by *LLVM_DISTRIBUTION_COMPONENTS*. Additionally by default the ``install`` target will install the LLVM testing; tools as the public tools. This can be changed well by setting; *LLVM_INSTALL_TOOLCHAIN_ONLY* to ``On``. The LLVM tools are intended for; development and testing of LLVM, and should only be included in distributions; that support LLVM development. When building with *LLVM_DISTRIBUTION_COMPONENTS* the build system also; generates a ``distribution`` target which builds all the components specified in; the list. This is a convenience build target to allow building just the; distributed pieces without needing to build all configured targets. .. _Multi-distribution configurations:. Multi-distribution configurations; ---------------------------------. The ``install-distribution`` target described above is for building a single; distribution. LLVM's build system also supports building multiple distributions,; which can be used to e.g. have one distribution containing just tools and; another for libraries (to enable development). These are configured by setting; the *LLVM_DISTRIBUTIONS* variable to hold a list of all distribution names; (which conventionally start with an uppercase letter, e.g. ""Development""), and; then setting the *LLVM_<distribution>_DISTRIBUTION_COMPONENTS* variable to the; list of targets for that distribution. For each distribution, the build system; generates an ``install-${distribution}-distribution`` target, where; ``${distribution}`` is the name of the distribution in lowercase, to install; that distribution. Each distribution creates i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:4136,config,configured,4136,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['config'],['configured']
Modifiability," this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )"",; ""to.cc"");; ToUnit->enableSourceFileDiagnostics();; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i2; };; // field mismatch: ^^. class Y { void f() { X<int> xi; } };; )"",; ""from.cc"");; FromUnit->enableSourceFileDiagnostics();; auto Matcher = cxxRecordDecl(hasName(""Y""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);; auto *To = getFirstDecl<CXXRecordDecl>(Matcher, ToUnit);. This ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:16645,extend,extend,16645,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['extend'],['extend']
Modifiability," this document to implement compatible exception; handling. SEH filter expressions; -----------------------. The SEH personality functions also use funclets to implement filter expressions,; which allow executing arbitrary user code to decide which exceptions to catch.; Filter expressions should not be confused with the ``filter`` clause of the LLVM; ``landingpad`` instruction. Typically filter expressions are used to determine; if the exception came from a particular DLL or code region, or if code faulted; while accessing a particular memory address range. LLVM does not currently have; IR to represent filter expressions because it is difficult to represent their; control dependencies. Filter expressions run during the first phase of EH,; before cleanups run, making it very difficult to build a faithful control flow; graph. For now, the new EH instructions cannot represent SEH filter; expressions, and frontends must outline them ahead of time. Local variables of; the parent function can be escaped and accessed using the ``llvm.localescape``; and ``llvm.localrecover`` intrinsics. New exception handling instructions; ------------------------------------. The primary design goal of the new EH instructions is to support funclet; generation while preserving information about the CFG so that SSA formation; still works. As a secondary goal, they are designed to be generic across MSVC; and Itanium C++ exceptions. They make very few assumptions about the data; required by the personality, so long as it uses the familiar core EH actions:; catch, cleanup, and terminate. However, the new instructions are hard to modify; without knowing details of the EH personality. While they can be used to; represent Itanium EH, the landingpad model is strictly better for optimization; purposes. The following new instructions are considered ""exception handling pads"", in that; they must be the first non-phi instruction of a basic block that may be the; unwind destination of an EH flow edge:; `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:24743,variab,variables,24743,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['variab'],['variables']
Modifiability," this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging TableGen files:. * `dump` keyword to dump messages to standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is now required; to enable crypto for this core. A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:2317,variab,variables,2317,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability," this update was posted [here](https://sft.its.cern.ch/jira/browse/ROOT-7631). ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ### THttpServer. Support of POST HTTP requests. For example, ROOT objects can be send with POST request and used as arguments of; objects method execution in exe.bin and exe.json requests. Request and response HTTP headers are now directly accessible in THttpCallArg class. When command is registered with THttpServer::RegisterCommand() method,; one could configure additional arguments which should be submitted when; command is executed with cmd.json requests. Introduce restriction rules for objects access with THttpServer::Restrict() method.; Up to now general read-only flag was applied - either; everything read-only or everything is fully accessible.; Now one could restrict access to different parts of; objects hierarchy or even fully 'hide' them from the client.; Restriction based on user account name, which is applied; when htdigest authentication is configured.; One also able to allow execution of selected methods. Implement multi.bin and multi.json requests.; One could request many items with single HTTP request.; Let optimize communication between server and client. With *SNIFF* tag in ClassDef() comments one could expose different properties,; which than exposed by the TRootSniffer to the client with h.json requests.; Such possibility ease implementation of client-side code for custom classes. Allow to bind http port with loopback address.; This restrict access to http server only from localhost.; One could either specify 'loopback' option in constructor:; new THttpServer(""http:8080?loopback""); or in clear text specify IP address to which http socket should be bind:; new THttpServer(""http:127.0.0.1:8080""); If host has several network interfaces, one could select one for binding:; new THttpServer(""http:192.168.1.17:8080""). ### TNetXNGFileStager; Fixed ROOT-7703. This restores the behavior ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:19556,config,configured,19556,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['config'],['configured']
Modifiability," this, but an elegant and efficient way is; to use `Operator-Precedence; Parsing <http://en.wikipedia.org/wiki/Operator-precedence_parser>`_.; This parsing technique uses the precedence of binary operators to guide; recursion. To start with, we need a table of precedences:. .. code-block:: c++. /// BinopPrecedence - This holds the precedence for each binary operator that is; /// defined.; static std::map<char, int> BinopPrecedence;. /// GetTokPrecedence - Get the precedence of the pending binary operator token.; static int GetTokPrecedence() {; if (!isascii(CurTok)); return -1;. // Make sure it's a declared binop.; int TokPrec = BinopPrecedence[CurTok];; if (TokPrec <= 0) return -1;; return TokPrec;; }. int main() {; // Install standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;; BinopPrecedence['*'] = 40; // highest.; ...; }. For the basic form of Kaleidoscope, we will only support 4 binary; operators (this can obviously be extended by you, our brave and intrepid; reader). The ``GetTokPrecedence`` function returns the precedence for; the current token, or -1 if the token is not a binary operator. Having a; map makes it easy to add new operators and makes it clear that the; algorithm doesn't depend on the specific operators involved, but it; would be easy enough to eliminate the map and do the comparisons in the; ``GetTokPrecedence`` function. (Or just use a fixed-size array). With the helper above defined, we can now start parsing binary; expressions. The basic idea of operator precedence parsing is to break; down an expression with potentially ambiguous binary operators into; pieces. Consider, for example, the expression ""a+b+(c+d)\*e\*f+g"".; Operator precedence parsing considers this as a stream of primary; expressions separated by binary operators. As such, it will first parse; the leading primary expression ""a"", then it will see the pairs [+, b]; [+, (c+d)] [\*, e] [\*, f] an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:13509,extend,extended,13509,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['extend'],['extended']
Modifiability," throw 1; };. void test() {; // It is possible that 'new int' is called first,; // then 'h()', that throws an exception and eventually; // 'g()' is never called.; f(g(new int), h()); // warn: 'g()' may never be called.; }. memory.DstBufferTooSmall; (C, C++); Destination buffer passed to memory function is too small.; Note: security.insecureAPI.strcpy currently warns; on usage of strcpy and suggests to replace it.; Note: alpha.unix.CStringChecker contains some similar checks.; Source: CWE-120. void test() {; const char* s1 = ""abc"";; char *s2 = new char;; strcpy(s2, s1); // warn; }. void test() {; int* p1 = new int[3];; int* p2 = new int;; memcpy(p2, p1, 3); // warn; }. memory.NegativeArraySize; (C, C++); 'n' is used to specify the buffer size may be negative.; Note: possibly an enhancement to ; alpha.security.MallocOverflow.; Source: CWE-20,; Example 2. void test() {; int *p;; int n1 = -1;; p = new int[n1]; // warn; }. memory.ZeroAlloc; (C, C++); Allocation of zero bytes.; Note: an enhancement to unix.Malloc.; Note: unix.API perform C-checks for zero; allocation. This should be moved to unix.Malloc.; Source: C++03 3.7.3.1p2; C++11 3.7.4.1p2. #include <stdlib.h>. void test() {; int *p = malloc(0); // warn; free(p);; }. void test() {; int *p = new int[0]; // warn; delete[] p;; }. D6178. constructors/destructors. Name, DescriptionExampleProgress. ctordtor.ExptInsideDtor; (C++); It is dangerous to let an exception leave a destructor.; Using try..catch solves the problem.; Source: Scott Meyers ""More Effective C++"", item 11: Prevent exceptions from; leaving destructors. class A {; A() {}; ~A() { throw 1; } // warn; };. void f() throw(int);. class A {; A() {}; ~A() { f(); } // warn; };. ctordtor.PlacementSelfCopy; (C++11); For a placement copy or move, it is almost certainly an error if the; constructed object is also the object being copied from. class A {};. void test(A *dst, A *src) {; ::new (dst) A(*dst); // warn (should be 'src'); }. exceptions. Name, DescriptionExample",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:1865,enhance,enhancement,1865,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['enhance'],['enhancement']
Modifiability," to #include TBuffer.h explicitly (see [section Core Libraries](#core-libs)); * Check and flag short reads as errors in the xroot plugins. This fixes [ROOT-3341].; * Added support for AWS temporary security credentials to TS3WebFile by allowing the security token to be given.; * Resolve an issue when space is freed in a large `ROOT` file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. - ##### TBufferJSON:; + support data members with `//[fN]` comment; + preliminary support of STL containers; + JSON data can be produced with `TObject::SaveAs()` method. ## TTree Libraries. * TChains can now be histogrammed without any C++ code, using the command line tool `rootdrawtree`. It is based on the new class `TSimpleAnalysis`.; * Do not automatically setup read cache during `TTree::Fill()`. This fixes [ROOT-8031].; * Make sure the option ""PARA"" in `TTree::Draw` is used with at least tow variables [ROOT-8196].; * The with `goff` option one can use as many variables as needed. There no more; limitation, like with the options `para`and `candle`.; * Fix detection of errors that appears in nested TTreeFormula [ROOT-8218]; * Better basket size optimization by taking into account meta data and rounding up to next 512 bytes, ensuring a complete cluster fits into a single basket. ### Fast Cloning. We added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address [ROOT-5078]. It can be controlled from the `TTreeCloner`, `TTree::CopyEntries` or `hadd` interfaces. The new cache is enabled by default, to update the size of the cache or disable it from `TTreeCloner` use: `TTreeCloner::SetCacheSize`. To do the same from `TTree::CopyEntries` add to the option string ""cachesize=SIZE"". To update the size of the cache or disable it from `hadd`, use the command line option `-cachesize SIZE`. `SIZE` shouyld be given in number bytes and can be expressed in 'human ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:9141,variab,variables,9141,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['variab'],['variables']
Modifiability," to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:11349,variab,variable,11349,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variable']
Modifiability," to Numeric Differentiation and works fine, since `; gamma_cdf()` doesn't have a lot of parameters. > In such cases, Numeric Differentiation fallback is only used for that; specific function. In above example, `gamma_cdf()` falls back to Numeric; Differentiation but other functions in `MathFuncs.h` will still be; able to use AD. This is because Clad is going to assume that you have a; derivative for this `gamma_cdf()` function, and the remaining functions will; use AD as expected. In the end, the remaining functions (including; `gamma_cdf()`) will try to fall back to Numeric Differentiation. However, if you want to add pure AD support, you need to make sure that all; your external functions are supported by Clad (meaning there is a custom; derivative defined for each of them). ### How do I test my new class while adding AD support?. Please look at the test classes that test the derivatives, evaluates,; fixtures, etc. (defined in 'roofit/roofitcore/test'). You can clone and adapt; these tests to your class as needed. For example:. > [roofit/roofitcore/test/testRooFuncWrapper.cxx](https://github.com/root-project/root/blob/master/roofit/roofitcore/test/testRooFuncWrapper.cxx). > Tip: Tests like above can be referenced to see which parts of RooFit already; support AD. ### How do I control my compile time?. This is an area of research that still needs some work. In most cases, the; compile times are reasonable, but with an increase in the level of complexity,; higher compile times may be encountered. ## Appendix B - Where does AD Logic Implementation reside?. Following classes provide several Helper Functions to translate existing logic; into AD-supported logic. a - RooFit::Detail::CodeSquashContext. b - RooFuncWrapper. ### a. RooFit::Detail::CodeSquashContext. > [roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h](https://github.com/root-project/root/blob/master/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h). It handles how to create a C++ function out of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:29084,adapt,adapt,29084,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['adapt'],['adapt']
Modifiability," to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. To start ROOT you can type `root` at the system prompt. This starts up; Cling, the ROOT command line C/C++ interpreter, and it gives you the; ROOT prompt (`root[0]`). It is possible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:3326,config,config,3326,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['config'],['config']
Modifiability," to address spaces. For example,; ``DW_OP_push_object_address`` pushes the address of an object. Other contexts; implicitly push an address on the stack before evaluating an expression. For; example, the ``DW_AT_use_location`` attribute of the; ``DW_TAG_ptr_to_member_type``. The expression belongs to a source language type; which may apply to objects allocated in different kinds of storage. Therefore,; it is desirable that the expression that uses the address can do so without; regard to what kind of storage it specifies, including the address space of a; memory location description. For example, a pointer to member value may want to; be applied to an object that may reside in any address space. The DWARF ``DW_OP_xderef*`` operations allow a value to be converted into an; address of a specified address space which is then read. But it provides no; way to create a memory location description for an address in the non-default; address space. For example, AMDGPU variables can be allocated in the local; address space at a fixed address. The ``DW_OP_LLVM_form_aspace_address`` (see; :ref:`amdgpu-dwarf-memory-location-description-operations`) operation is defined; to create a memory location description from an address and address space. If; can be used to specify the location of a variable that is allocated in a; specific address space. This allows the size of addresses in an address space to; be larger than the generic type. It also allows a consumer great implementation; freedom. It allows the implicit conversion back to a value to be limited only to; the default address space to maintain compatibility with DWARF Version 5. For; other address spaces the producer can use the new operations that explicitly; specify the address space. In contrast, if the ``DW_OP_LLVM_form_aspace_address`` operation had been; defined to produce a value, and an implicit conversion to a memory location; description was defined, then it would be limited to the size of the generic; type (which m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:19425,variab,variables,19425,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variables']
Modifiability," to build it; by running CMake. CMake combines information from three sources:. - explicit choices you make (is this a debug build?). - settings detected from your system (where are libraries installed?). - project structure (which files are part of 'clang'?). First, create a directory to build in. Usually, this is; llvm-project/build. .. code:: console. $ mkdir llvm-project/build; $ cd llvm-project/build. Now, run CMake:. .. code:: console. $ cmake -G Ninja ../llvm -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=clang. If all goes well, you'll see a lot of ""performing test"" lines, and; finally:. .. code:: console. Configuring done; Generating done; Build files have been written to: /path/llvm-project/build. And you should see a build.ninja file. Let's break down that last command a little:. - **-G Ninja**: we're going to use ninja to build; please create; build.ninja. - **../llvm**: this is the path to the source of the ""main"" LLVM; project. - The two **-D** flags set CMake variables, which override; CMake/project defaults:. - **CMAKE_BUILD_TYPE=Release**: build in optimized mode, which is; (surprisingly) the fastest option. If you want to run under a debugger, you should use the default Debug; (which is totally unoptimized, and will lead to >10x slower test; runs) or RelWithDebInfo which is a halfway point.; **CMAKE_BUILD_TYPE** affects code generation only, assertions are; on by default regardless! **LLVM_ENABLE_ASSERTIONS=Off** disables; them. - **LLVM_ENABLE_PROJECTS=clang**: this lists the LLVM subprojects; you are interested in building, in addition to LLVM itself. Multiple; projects can be listed, separated by semicolons, such as ""clang;; lldb"".In this example, we'll be making a change to Clang, so we; should build it. Finally, create a symlink (or a copy) of; llvm-project/build/compile-commands.json into llvm-project/:. .. code:: console. $ ln -s build/compile_commands.json ../. (This isn't strictly necessary for building and testing, but allows; tools lik",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:3376,variab,variables,3376,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['variab'],['variables']
Modifiability," to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-initialization of class members when; default initializing a base class in a constant expression context. Fixes:; (`#69890 <https://github.com/llvm/llvm-project/issues/69890>`_). - Fix crash when t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:51653,variab,variable,51653,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variable']
Modifiability," to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global variables that never have their address; taken. If obviously true, it marks read/write globals as constant, deletes; variables only stored to, etc. ``gvn``: Global Value Numbering; -------------------------------. This pass performs global value numbering to eliminate fully and partially; redundant instructions. It also performs redundant load elimination. .. _passes-indvars:. ``indvars``: Canonicalize Induction Variables; ---------------------------------------------. This transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this pass also makes the following; changes:. * The exit condition for the loop is canonicalized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:17981,variab,variable,17981,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variable']
Modifiability," to file; /Qvec- Disable the loop vectorization passes; /Qvec Enable the loop vectorization passes; /showFilenames- Don't print the name of each compiled file (default); /showFilenames Print the name of each compiled file; /showIncludes Print info about included files to stderr; /source-charset:<value> Source encoding, supports only UTF-8; /std:<value> Language standard to compile for; /TC Treat all source files as C; /Tc <filename> Specify a C source file; /TP Treat all source files as C++; /Tp <filename> Specify a C++ source file; /utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default); /Zc:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:175803,inherit,inheritance,175803,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['inherit'],['inheritance']
Modifiability," to indicate the address space; of the called function. If it is not specified, the program address space; from the :ref:`datalayout string<langref_datalayout>` will be used.; #. '``ty``': the type of the call instruction itself which is also the; type of the return value. Functions that return no value are marked; ``void``.; #. '``fnty``': shall be the signature of the function being called. The; argument types must match the types implied by this signature. This; type can be omitted if the function is not varargs.; #. '``fnptrval``': An LLVM value containing a pointer to a function to; be called. In most cases, this is a direct function call, but; indirect ``call``'s are just as possible, calling an arbitrary pointer; to function value.; #. '``function args``': argument list whose types match the function; signature argument types and parameter attributes. All arguments must; be of :ref:`first class <t_firstclass>` type. If the function signature; indicates the function accepts a variable number of arguments, the; extra arguments can be specified.; #. The optional :ref:`function attributes <fnattrs>` list.; #. The optional :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". The '``call``' instruction is used to cause control flow to transfer to; a specified function, with its incoming arguments bound to the specified; values. Upon a '``ret``' instruction in the called function, control; flow continues with the instruction after the function call, and the; return value of the function is bound to the result argument. Example:; """""""""""""""". .. code-block:: llvm. %retval = call i32 @test(i32 %argc); call i32 (ptr, ...) @printf(ptr %msg, i32 12, i8 42) ; yields i32; %X = tail call i32 @foo() ; yields i32; %Y = tail call fastcc i32 @foo() ; yields i32; call void %foo(i8 signext 97). %struct.A = type { i32, i8 }; %r = call %struct.A @foo() ; yields { i32, i8 }; %gr = extractvalue %struct.A %r, 0 ; yields i32; %gr1 = extractvalue %struct.A %r, 1 ; yields i8; %Z ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:477533,variab,variable,477533,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability," to it like:. - <https://jsroot.gsi.de/latest/?file=https://root.cern/js/files/hsimple.root&item=hpx>. But one should be aware of [Same-origin policy](https://en.wikipedia.org/wiki/Same-origin_policy),; when the browser blocks requests to files from domains other than current web page.; To enable CORS on Apache web server, hosting ROOT files, one should add following lines to `.htaccess` file:. <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>. More details about configuring of CORS headers can be found [here](https://developer.mozilla.org/en/http_access_control). Alternative - enable CORS requests in the browser. It can be easily done with [CORS Everywhere plugin](https://addons.mozilla.org/de/firefox/addon/cors-everywhere/) for the Firefox browser or [Allow CORS plugin](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?hl=en) for the Chrome browser. Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to `modules/gui.mjs` script like:. ```javascript; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; ```. In the main `<div>` element one can specify many custom parameters like one do it in URL string:. ```html; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; ```. ## Reading local ROOT files. JSROOT can read files from local file system using HTML5 FileReader functionality.; Main",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:28520,plugin,plugin,28520,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['plugin'],['plugin']
Modifiability," to keep the objects retained during enumeration, and the collection itself; cannot be synchronously modified. It can be overridden by explicitly; qualifying the variable with ``__strong``, which will make the variable; mutable again and cause the loop to retain the objects it encounters. .. _arc.misc.blocks:. Blocks; ------. The implicit ``const`` capture variables created when evaluating a block; literal expression have the same ownership semantics as the local variables; they capture. The capture is performed by reading from the captured variable; and initializing the capture variable with that value; the capture variable is; destroyed when the block literal is, i.e. at the end of the enclosing scope. The :ref:`inference <arc.ownership.inference>` rules apply equally to; ``__block`` variables, which is a shift in semantics from non-ARC, where; ``__block`` variables did not implicitly retain during capture. ``__block`` variables of retainable object owner type are moved off the stack; by initializing the heap copy with the result of moving from the stack copy. With the exception of retains done as part of initializing a ``__strong``; parameter variable or reading a ``__weak`` variable, whenever these semantics; call for retaining a value of block-pointer type, it has the effect of a; ``Block_copy``. The optimizer may remove such copies when it sees that the; result is used only as an argument to a call. When a block pointer type is converted to a non-block pointer type (such as; ``id``), ``Block_copy`` is called. This is necessary because a block allocated; on the stack won't get copied to the heap when the non-block pointer escapes.; A block pointer is implicitly converted to ``id`` when it is passed to a; function as a variadic argument. .. _arc.misc.exceptions:. Exceptions; ----------. By default in Objective C, ARC is not exception-safe for normal releases:. * It does not end the lifetime of ``__strong`` variables when their scopes are; abnormally terminated b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:96800,variab,variables,96800,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability," to kernel's; entry point instruction; which must be 256 byte; aligned.; 351:272 20 Reserved, must be 0.; bytes; 383:352 4 bytes COMPUTE_PGM_RSRC3 GFX6-GFX9; Reserved, must be 0.; GFX90A, GFX940; Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC3``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc3-gfx90a-table`.; GFX10-GFX11; Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC3``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc3-gfx10-gfx11-table`.; GFX12; Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC3``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc3-gfx12-table`.; 415:384 4 bytes COMPUTE_PGM_RSRC1 Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC1``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc1-gfx6-gfx12-table`.; 447:416 4 bytes COMPUTE_PGM_RSRC2 Compute Shader (CS); program settings used by; CP to set up; ``COMPUTE_PGM_RSRC2``; configuration; register. See; :ref:`amdgpu-amdhsa-compute_pgm_rsrc2-gfx6-gfx12-table`.; 458:448 7 bits *See separate bits below.* Enable the setup of the; SGPR user data registers; (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). The total number of SGPR; user data registers; requested must not exceed; 16 and match value in; ``compute_pgm_rsrc2.user_sgpr.user_sgpr_count``.; Any requests beyond 16; will be ignored.; >448 1 bit ENABLE_SGPR_PRIVATE_SEGMENT If the *Target Properties*; _BUFFER column of; :ref:`amdgpu-processor-table`; specifies *Architected flat; scratch* then not supported; and must be 0,; >449 1 bit ENABLE_SGPR_DISPATCH_PTR; >450 1 bit ENABLE_SGPR_QUEUE_PTR; >451 1 bit ENABLE_SGPR_KERNARG_SEGMENT_PTR; >452 1 bit ENABLE_SGPR_DISPATCH_ID; >453 1 bit ENABLE_SGPR_FLAT_SCRATCH_INIT If the *Target Properties*; column of; :ref:`amdgpu-processor-table`; specifies *Architected flat; scratch* then not supported; and must be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:161101,config,configuration,161101,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['config'],['configuration']
Modifiability," to run, assuming the ``--num-shards=M`` option was; provided. The two options must be used together, and the value of ``N``; must be in the range ``1..M``. The environment variable; ``LIT_RUN_SHARD`` can also be used in place of this option. .. option:: --timeout=N. Spend at most ``N`` seconds (approximately) running each individual test.; ``0`` means no time limit, and ``0`` is the default. Note that this is not an; alias for :option:`--max-time`; the two are different kinds of maximums. .. option:: --filter=REGEXP. Run only those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER`` can be also used in place; of this option, which is especially useful in environments where the call; to ``lit`` is issued indirectly. .. option:: --filter-out=REGEXP. Filter out those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER_OUT`` can be also used in; place of this option, which is especially useful in environments where the; call to ``lit`` is issued indirectly. .. option:: --xfail=LIST. Treat those tests whose name is in the semicolon separated list ``LIST`` as; ``XFAIL``. This can be helpful when one does not want to modify the test; suite. The environment variable ``LIT_XFAIL`` can be also used in place of; this option, which is especially useful in environments where the call to; ``lit`` is issued indirectly. A test name can specified as a file name relative to the test suite directory.; For example:. .. code-block:: none. LIT_XFAIL=""affinity/kmp-hw-subset.c;offloading/memory_manager.cpp"". In this case, all of the following tests are treated as ``XFAIL``:. .. code-block:: none. libomp :: affinity/kmp-hw-subset.c; libomptarget :: nvptx64-nvidia-cuda :: offloading/memory_manager.cpp; libomptarget :: x86_64-pc-linux-gnu :: offloading/memory_manager.cpp. Alternatively, a test name can be specified as the full test name; reported in LIT output. For example",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:8513,variab,variable,8513,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['variab'],['variable']
Modifiability," to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently writing and reading XML files is limited to ROOT; applications. It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for real; applications. The XML format should be used only for small data volumes, typically; histogram files, pictures, geometries, calibrations. The XML file is; built in memory before being dumped to disk. Like for normal ROOT files,; XML files use the same I/O mechanism exploiting the ROOT/Cling; dictionary. Any class having a dictionary can be saved in XML format.; This first implementation does not support subdirectories or trees. The shared library `libRXML.so` may be loaded dynamically via; `gSystem->Load(""libRXML"")`. This library is also automatically loaded by; the plug-in manager as soon a XML file is created. To create an XTM; file, simply specify a filename with an .xml extension when calling; **`TFile`**`::Open`. **`TFile`**`::Open` will recognize that you are trying to; open an XML file and return a **`TXMLFile`** object. When a XML file is; open in write mode, one can use the normal `TObject::Write` to write an; object in the file. ``` {.cpp}; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; ```. The canvas can be saved as a XML file format via File menu / Save or; Save As menu entries. One can do also:. ``` {.cpp}; canvas->Print(""Example.xml"");; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:98196,plug-in,plug-in,98196,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['plug-in'],['plug-in']
Modifiability," to steer ROOT's concurrency level is still through; [`ROOT::EnableImplicitMT`](https://root.cern/doc/master/namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f); or by passing the appropriate parameter to executors' constructors, as in; [`TThreadExecutor::TThreadExecutor`](https://root.cern/doc/master/classROOT_1_1TThreadExecutor.html#ac7783d52c56cc7875d3954cf212247bb). See the discussion at [ROOT-11014](https://sft.its.cern.ch/jira/browse/ROOT-11014) for more context. ### Dynamic Path: `ROOT_LIBRARY_PATH`. A new way to set ROOT's ""Dynamic Path"" was added: the; environment variable `ROOT_LIBRARY_PATH`. On Unix it should contain a colon; separated list of paths, on Windows a semicolon separated list. It is; intended to be cross platform and to be specific to ROOT (and thus not; interfere with the system's shared linker).; The final ""Dynamic Path"" is now composed of these sources in order:; 1. `ROOT_LIBRARY_PATH` environment variable; 2. System specific shared linker environment variables like; `LD_LIBRARY_PATH`, `LIBPATH`, or `PATH`.; 3. Setting from rootrc; 4. ROOT's builtin library directory. ### Interpreter. - cling's LLVM is upgraded to version 9.0; - New interface to enable/disable optional cling features. Currently, it can be used to enable/disable support for redefinitions. See [this](https://github.com/root-project/cling/issues/360) issue for more information. ### Multithreading. - Fix an uninitialized variable in global read-write lock which could have caused deadlocks or crashes in some rare cases.; - Default global read-write lock transitioned to new implementation based on TBB thread local storage when TBB is available on supported platforms (all except Windows). This gives an O(10%) performance improvement for some typical RDataFrame scenarios with 256 threads due to reduced lock contention. ## I/O Libraries. - Exclusive use of the global lock is reduced or migrated to finer grained read and write locks in a few hotspots that occur during file opening/c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:3434,variab,variables,3434,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['variab'],['variables']
Modifiability," to the most recent revision),; you can check out a tag after cloning the repository. E.g., `git checkout; llvmorg-6.0.1` inside the ``llvm-project`` directory created by the above; command. Use `git tag -l` to list all of them. Sending patches; ^^^^^^^^^^^^^^^. See :ref:`Contributing <submit_patch>`. Bisecting commits; ^^^^^^^^^^^^^^^^^. See `Bisecting LLVM code <GitBisecting.html>`_ for how to use ``git bisect``; on LLVM. Reverting a change; ^^^^^^^^^^^^^^^^^^. When reverting changes using git, the default message will say ""This reverts; commit XYZ"". Leave this at the end of the commit message, but add some details; before it as to why the commit is being reverted. A brief explanation and/or; links to bots that demonstrate the problem are sufficient. Local LLVM Configuration; ------------------------. Once checked out repository, the LLVM suite source code must be configured; before being built. This process uses CMake. Unlinke the normal ``configure``; script, CMake generates the build files in whatever format you request as well; as various ``*.inc`` files, and ``llvm/include/llvm/Config/config.h.cmake``. Variables are passed to ``cmake`` on the command line using the format; ``-D<variable name>=<value>``. The following variables are some common options; used by people developing LLVM. +-------------------------+----------------------------------------------------+; | Variable | Purpose |; +=========================+====================================================+; | CMAKE_C_COMPILER | Tells ``cmake`` which C compiler to use. By |; | | default, this will be /usr/bin/cc. |; +-------------------------+----------------------------------------------------+; | CMAKE_CXX_COMPILER | Tells ``cmake`` which C++ compiler to use. By |; | | default, this will be /usr/bin/c++. |; +-------------------------+----------------------------------------------------+; | CMAKE_BUILD_TYPE | Tells ``cmake`` what type of build you are trying |; | | to generate files for. Valid optio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:23663,config,configure,23663,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configure']
Modifiability," to the window manager arrow when; exiting a `TCanvas`. ### `freetype` library. Updates `builtin_freetype` to 2.6.1 (current upstream version), which can detect; `PPC64LE` machine. This was compiled and tested on `SLC6 + ICC + x86_64`,; `F21 + GCC + ppc64le`, `MacOSX 10.11.1 + Xcode 7.1` and `Windows (ROOT 5.34)`.; `$ROOTSYS/graf2d/freetype/src/README` was removed, because no issues were noticed; with `ICC` compiler and `-Wall -pedantic -ansi` flags.; Additionally `--with-png=no --with-bzip2=no` flags are passed to freetype; configuration script. Default values for these options are auto.; `freetype` finds `libpng` and `libbzip2` on the system and builds extra; modules. Then attempting to link against `freetype` one would need to link; `-lpng -lbzip2` explicitly otherwise linking will returns in undefined; references. Otherwise we would need to check for `libpng` and `libbzip2` on the system; and adjust `FREETYPE_LIBRARIES` to include `-lpng` and `-lbzip2`.; The current solution goes for the minimal configuration. The original request for; this update was posted [here](https://sft.its.cern.ch/jira/browse/ROOT-7631). ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ### THttpServer. Support of POST HTTP requests. For example, ROOT objects can be send with POST request and used as arguments of; objects method execution in exe.bin and exe.json requests. Request and response HTTP headers are now directly accessible in THttpCallArg class. When command is registered with THttpServer::RegisterCommand() method,; one could configure additional arguments which should be submitted when; command is executed with cmd.json requests. Introduce restriction rules for objects access with THttpServer::Restrict() method.; Up to now general read-only flag was applied - either; everything read-only or everything is fully accessible.; Now one could restrict access to different parts of; objects hierarchy or even fully 'hide' them from the cli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:18475,config,configuration,18475,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['config'],['configuration']
Modifiability," to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34977,config,config,34977,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['config']
Modifiability," tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. Will convert; ``foo.begin()`` into ``begin(foo)`` and similarly for ``end()``, where; ``foo`` is a standard container. We could also detect similar patterns for; arrays.; * ``tr1`` removal tool. Will migrate source code from using TR1 library; features to C++11 library. For example:. .. code-block:: c++. #include <tr1/unordered_map>; int main(); {; std::tr1::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. should be rewritten to:. .. code-block:: c++. #include <unordered_map>; int main(); {; std::unordered_map <int, int> ma;; std::cout << ma.size () << std::endl;; return 0;; }. * A tool to remove ``auto``. Will ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:4372,portab,portability,4372,interpreter/llvm-project/clang/docs/ClangTools.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst,2,"['maintainab', 'portab']","['maintainability', 'portability']"
Modifiability," triple used to configure LLVM. **--ignore-libllvm**. Ignore libLLVM and link component libraries instead. **--includedir**. Print the installation directory for LLVM headers. **--ldflags**. Print the flags needed to link against LLVM libraries. **--libdir**. Print the installation directory for LLVM libraries. **--libfiles**. Similar to **--libs**, but print the full path to each library file. This is; useful when creating makefile dependencies, to ensure that a tool is relinked if; any library it uses changes. **--libnames**. Similar to **--libs**, but prints the bare filenames of the libraries; without **-l** or pathnames. Useful for linking against a not-yet-installed; copy of LLVM. **--libs**. Print all the libraries needed to link against the specified LLVM; *components*, including any dependencies. **--link-shared**. Link the components as shared libraries. **--link-static**. Link the component libraries statically. **--obj-root**. Print the object root used to build LLVM. **--prefix**. Print the installation prefix for LLVM. **--shared-mode**. Print how the provided components can be collectively linked (`shared` or `static`). **--system-libs**. Print all the system libraries needed to link against the specified LLVM; *components*, including any dependencies. **--targets-built**. Print the component names for all targets supported by this copy of LLVM. **--version**. Print the version number of LLVM. COMPONENTS; ----------. To print a list of all available components, run **llvm-config; --components**. In most cases, components correspond directly to LLVM; libraries. Useful ""virtual"" components include:. **all**. Includes all LLVM libraries. The default if no components are specified. **backend**. Includes either a native backend or the C backend. **engine**. Includes either a native JIT or the bitcode interpreter. EXIT STATUS; -----------. If **llvm-config** succeeds, it will exit with 0. Otherwise, if an error; occurs, it will exit with a non-zero value.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst:2981,config,config,2981,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,2,['config'],['config']
Modifiability," trivial copy and move constructors. Better diagnostics for loops that execute 0 times; Fixes a linking issue that prevented the checker from running on OS X v10.6 and earlier; Fixes for misc. crashes and false positives. checker-271; built: February 8, 2013; highlights:. Faster analysis for scan-build xcodebuild when using Xcode 4.6 and higher:; ; scan-build now uses Xcode's built-in interposition mechanism for the static analyzer to provide faster builds while doing static analysis (PCH files are now built).; This change also allows scan-build to have better support for iOS project analysis without having to specifying weird SDK settings to scan-build. Better diagnostics for implicitly-defined member functions in C++.; New warning for malloc/free checker when passing malloc'ed pointer with non-zero offset to free().; Fixes for misc. parser crashes.; Newer than the static analyzer version in Xcode 4.6. checker-270; built: January 4, 2013; highlights:. Major performance enhancements to speed up interprocedural analysis.; Misc. bug fixes. checker-269; built: September 25, 2012; highlights:. Significantly improves interprocedural analysis for Objective-C.; Numerous bug fixes and heuristics to reduce false positives reported; 			over checker-268. checker-268; built: September 11, 2012; highlights:. Adds initial interprocedural analysis support for C++ and Objective-C. This will greatly improve analysis coverage and find deeper bugs in Objective-C and C++ code.; Contains a static analyzer newer than Xcode 4.4. NOTE: this checker build includes a huge number of changes. It has the potential to find many more bugs, but may report new kinds of false positives. We'd like to know about; these, and any other problems you encounter. When you encounter an issue, please file a bug report.; checker-267; built: June 1, 2012; highlights:; Adds basic interprocedural analysis support for blocks.; checker-266; built: May 23, 2012; highlights:; Contains numerous stability fixes over che",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:6307,enhance,enhancements,6307,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['enhance'],['enhancements']
Modifiability," two; dimensions of the array are subscripted into, yielding an '``i32``'; type. The '``getelementptr``' instruction returns a pointer to this; element. Note that it is perfectly legal to index partially through a structure,; returning a pointer to an inner element. Because of this, the LLVM code; for the given testcase is equivalent to:. .. code-block:: llvm. define ptr @foo(ptr %s) {; %t1 = getelementptr %struct.ST, ptr %s, i32 1; %t2 = getelementptr %struct.ST, ptr %t1, i32 0, i32 2; %t3 = getelementptr %struct.RT, ptr %t2, i32 0, i32 1; %t4 = getelementptr [10 x [20 x i32]], ptr %t3, i32 0, i32 5; %t5 = getelementptr [20 x i32], ptr %t4, i32 0, i32 13; ret ptr %t5; }. The indices are first converted to offsets in the pointer's index type. If the; currently indexed type is a struct type, the struct offset corresponding to the; index is sign-extended or truncated to the pointer index type. Otherwise, the; index itself is sign-extended or truncated, and then multiplied by the type; allocation size (that is, the size rounded up to the ABI alignment) of the; currently indexed type. The offsets are then added to the low bits of the base address up to the index; type width, with silently-wrapping two's complement arithmetic. If the pointer; size is larger than the index size, this means that the bits outside the index; type width will not be affected. The result value of the ``getelementptr`` may be outside the object pointed; to by the base pointer. The result value may not necessarily be used to access; memory though, even if it happens to point into allocated storage. See the; :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more; information. If the ``inbounds`` keyword is present, the result value of a; ``getelementptr`` with any non-zero indices is a; :ref:`poison value <poisonvalues>` if one of the following rules is violated:. * The base pointer has an *in bounds* address of an allocated object, which; means that it points into an allocated object, or",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:436337,extend,extended,436337,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extended']
Modifiability," uniform with the other calculator tools, which is different from the original; HybridCalculator's interface. Users wishing to run their old macro are advised to use ModelConfig, but if that is too time consuming one can just change the; name of the class from HybridCalculator to; HybridCalculatorOriginal; Note also that with the new class no HybridResult is; returned but directly the base class HypoTestResult which; has been improved for this release.; The plot class, HybridPlot is not returned, but; the user can create an HypoTestPlot object from the; HypoTestResult.; The classes HybridResult and HybridPlot work only; with the HybridCalculatorOriginal and remain for maintaining; a backward compatibility. ; Given a ModelConfig, the tool will attempt to form the posterior pdf ; for the nuisance parameters based on the prior and the constraint terms ; in the pdf. However, this is not yet implemented. In order to keep; logical consistency with other tools, the distribution being used; to smear the nuisance parameters should NOT be considered the prior in ; the model config. Instead, one should use HybridCalculator's; ForcePriorNuisanceNull and ForcePriorNuisanceAlt. HybridCalculatorOriginal. Apply a fix for test statistic = 3 (profile likelihood); Apply a fix for using non-extended pdf. TestStatSampler and TestStatistics. Cleanup of the interfaces.; TestStatistics now have a method PValueIsRightTail to specify the sign conventions for the test statistic. This is used when making plots and calculating p-values.; make clear that TestStatistic::Evaluate should take data and values of the parameters that define the null.; Add method TestStatSampler::SetParametersForTestStat that ; allows for greater control of parameters used for generating toy data; and parameters used for evaluating the test statistic.; ProfileLikelihoodTestStatUsing the raw profile likelihood while reviewing the old algorithm used to provide robustness in situations with local minima.; New test statist",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:6194,config,config,6194,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,1,['config'],['config']
Modifiability," usage by using ``lld``, see; the :ref:`LLVM_USE_LINKER <llvm_use_linker>` option.; * Assertions are internal checks to help you find bugs. They typically slow; down LLVM and Clang when enabled, but can be useful during development.; You can manually set :ref:`LLVM_ENABLE_ASSERTIONS <llvm_enable_assertions>`; to override the default from `CMAKE_BUILD_TYPE`. If you are using an IDE such as Visual Studio or Xcode, you should use; the IDE settings to set the build type. **CMAKE_INSTALL_PREFIX**:PATH; Path where LLVM will be installed when the ""install"" target is built. **CMAKE_{C,CXX}_FLAGS**:STRING; Extra flags to use when compiling C and C++ source files respectively. **CMAKE_{C,CXX}_COMPILER**:STRING; Specify the C and C++ compilers to use. If you have multiple; compilers installed, CMake might not default to the one you wish to; use. .. _Frequently Used LLVM-related variables:. Frequently Used LLVM-related variables; --------------------------------------. The default configuration may not match your requirements. Here are; LLVM variables that are frequently used to control that. The full; description is in `LLVM-related variables`_ below. **LLVM_ENABLE_PROJECTS**:STRING; Control which projects are enabled. For example you may want to work on clang; or lldb by specifying ``-DLLVM_ENABLE_PROJECTS=""clang;lldb""``. **LLVM_ENABLE_RUNTIMES**:STRING; Control which runtimes are enabled. For example you may want to work on; libc++ or libc++abi by specifying ``-DLLVM_ENABLE_RUNTIMES=""libcxx;libcxxabi""``. **LLVM_LIBDIR_SUFFIX**:STRING; Extra suffix to append to the directory where libraries are to be; installed. On a 64-bit architecture, one could use ``-DLLVM_LIBDIR_SUFFIX=64``; to install libraries to ``/usr/lib64``. **LLVM_PARALLEL_{COMPILE,LINK}_JOBS**:STRING; Building the llvm toolchain can use a lot of resources, particularly; linking. These options, when you use the Ninja generator, allow you; to restrict the parallelism. For example, to avoid OOMs or going; into swap, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:8841,config,configuration,8841,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['config'],['configuration']
Modifiability," usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:5474,variab,variable,5474,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability," use the ""alloca trick"". Once we have that, we'll add our new; operator, then extend Kaleidoscope to support new variable definitions. Adjusting Existing Variables for Mutation; =========================================. The symbol table in Kaleidoscope is managed at code generation time by; the '``NamedValues``' map. This map currently keeps track of the LLVM; ""Value\*"" that holds the double value for the named variable. In order; to support mutation, we need to change this slightly, so that; ``NamedValues`` holds the *memory location* of the variable in question.; Note that this change is a refactoring: it changes the structure of the; code, but does not (by itself) change the behavior of the compiler. All; of these changes are isolated in the Kaleidoscope code generator. At this point in Kaleidoscope's development, it only supports variables; for two things: incoming arguments to functions and the induction; variable of 'for' loops. For consistency, we'll allow mutation of these; variables in addition to other user-defined variables. This means that; these will both need memory locations. To start our transformation of Kaleidoscope, we'll change the; ``NamedValues`` map so that it maps to AllocaInst\* instead of Value\*. Once; we do this, the C++ compiler will tell us what parts of the code we need; to update:. .. code-block:: c++. static std::map<std::string, AllocaInst*> NamedValues;. Also, since we will need to create these allocas, we'll use a helper; function that ensures that the allocas are created in the entry block of; the function:. .. code-block:: c++. /// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.; static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction,; const std::string &VarName) {; IRBuilder<> TmpB(&TheFunction->getEntryBlock(),; TheFunction->getEntryBlock().begin());; return TmpB.CreateAlloca(Type::getDoubleTy(*TheContext), nullptr,; VarName);; }. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:12341,variab,variables,12341,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,2,['variab'],['variables']
Modifiability," use the ``--coverage`` option, which; includes both of those other options.). At the time you compile the instrumented code, a ``.gcno`` data file will be; generated for each object file. These ``.gcno`` files contain half of the; coverage data. The other half of the data comes from ``.gcda`` files that are; generated when you run the instrumented program, with a separate ``.gcda``; file for each object file. Each time you run the program, the execution counts; are summed into any existing ``.gcda`` files, so be sure to remove any old; files if you do not want their contents to be included. By default, the ``.gcda`` files are written into the same directory as the; object files, but you can override that by setting the ``GCOV_PREFIX`` and; ``GCOV_PREFIX_STRIP`` environment variables. The ``GCOV_PREFIX_STRIP``; variable specifies a number of directory components to be removed from the; start of the absolute path to the object file directory. After stripping those; directories, the prefix from the ``GCOV_PREFIX`` variable is added. These; environment variables allow you to run the instrumented program on a machine; where the original object file directories are not accessible, but you will; then need to copy the ``.gcda`` files back to the object file directories; where :program:`llvm-cov gcov` expects to find them. Once you have generated the coverage data files, run :program:`llvm-cov gcov`; for each main source file where you want to examine the coverage results. This; should be run from the same directory where you previously ran the; compiler. The results for the specified source file are written to a file named; by appending a ``.gcov`` suffix. A separate output file is also created for; each file included by the main source file, also with a ``.gcov`` suffix added. The basic content of an ``.gcov`` output file is a copy of the source file with; an execution count and line number prepended to every line. The execution; count is shown as ``-`` if a line does not ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst:2467,variab,variable,2467,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,1,['variab'],['variable']
Modifiability," use this in config files, etc. Use at your own risk. .. _FixNamespaceComments:. **FixNamespaceComments** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <FixNamespaceComments>`; If ``true``, clang-format adds missing namespace end comments for; namespaces and fixes invalid existing ones. This doesn't affect short; namespaces, which are controlled by ``ShortNamespaceLines``. .. code-block:: c++. true: false:; namespace longNamespace { vs. namespace longNamespace {; void foo(); void foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. ForEachMacros: ['RANGES_FOR', 'FOREACH']. For example: BOOST_FOREACH. .. _IfMacros:. **IfMacros** (``List of Strings``) :versionbadge:`clang-format 13` :ref:`¶ <IfMacros>`; A vector of macros that should be interpreted as conditionals; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. IF(...); <conditional-body>; else IF(...); <conditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`` (in configuration: ``Preserve``); Sort each ``#include`` block separatel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:64419,config,configuration,64419,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,['config'],"['configuration', 'configured']"
Modifiability," used to process FastCGI requests. This number can be changed with ""thrds"" url parameter:. ```cpp; serv->CreateEngine(""fastcgi:9000?thrds=20"");; ```. If `thrds=0` parameter specified, the only thread will be use to received and process all requests. All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer. ### Configure fastcgi with Apache2. Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more.; One only need to enable `mod_proxy` and `mod_proxy_fcgi` modules and add following line to **Apache2** configuration file:. ```; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; ```. More information can be found in [FastCGI proxy docu](https://httpd.apache.org/docs/2.4/mod/mod_proxy_fcgi.html).; After restarting apache server one should be able to open address: `http://apache_host_name/root.app/`.; There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:. ```; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; ```. ### Configure fastcgi with lighttpd. An example of configuration file for **lighttpd** server is:. ```; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); ```. Be aware, that with *lighttpd* one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: `http://lighttpd_host_name/root.app/`. Example of authorization configuration for FastCGI connection:. auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ). ## Integration with existing applications. In many practical cases ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:11631,config,configure,11631,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configure']
Modifiability," useful for modeling pointer values,; since we don't care about specific addresses but just want to give a unique; identifier to a memory location. ```c++; void ExampleOfSymbolicPointers(bool b) {; int x = 0; // x is {0}; int* ptr = &x; // x is {0} ptr is {&x}; if (b) {; *ptr = 42; // x is {42} ptr is {&x}; }; print(x); // x is {0; 42} ptr is {&x}; }; ```. ## Example: finding output parameters. Let's explore how data flow analysis can help with a problem that is hard to; solve with other tools in Clang. ### Problem description. Output parameters are function parameters of pointer or reference type whose; pointee is completely overwritten by the function, and not read before it is; overwritten. They are common in pre-C++11 code due to the absence of move; semantics. In modern C++ output parameters are non-idiomatic, and return values; are used instead. Imagine that we would like to refactor output parameters to return values to; modernize old code. The first step is to identify refactoring candidates through; static analysis. For example, in the following code snippet the pointer `c` is an output; parameter:. ```c++; struct Customer {; int account_id;; std::string name;; }. void GetCustomer(Customer *c) {; c->account_id = ...;; if (...) {; c->name = ...;; } else {; c->name = ...;; }; }; ```. We would like to refactor this code into:. ```c++; Customer GetCustomer() {; Customer c;; c.account_id = ...;; if (...) {; c.name = ...;; } else {; c.name = ...;; }; return c;; }; ```. However, in the function below the parameter `c` is not an output parameter; because its field `name` is not overwritten on every path through the function. ```c++; void GetCustomer(Customer *c) {; c->account_id = ...;; if (...) {; c->name = ...;; }; }; ```. The code also cannot read the value of the parameter before overwriting it:. ```c++; void GetCustomer(Customer *c) {; use(c->account_id);; c->name = ...;; c->account_id = ...;; }; ```. Functions that escape the pointer also block the refactoring",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:14954,refactor,refactoring,14954,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactoring']
Modifiability," using the BatchMode on CPU (RooFit::BatchMode(""cpu"") is equivalent); model.fitTo(data, RooFit::BatchMode(""cuda"")); // using the new CUDA backend; ```. The `RooBatchCompute` backend now also supports ROOT's implicit multithreading (similar to RDataFrame), which can be enabled as follows:; ```C++; ROOT::EnableImplicitMT(nThreads);; ```. For more information, please have a look at this [contribution to the ACAT 2021 conference](https://indico.cern.ch/event/855454/contributions/4596763/) or consult the [RooBatchComupte README](https://github.com/root-project/root/tree/v6-26-00-patches/roofit/batchcompute).; The README also describes how to enable BatchMode support for your own PDFs. ### Parallel calculation of likelihood gradients during fitting; This release features two new optional RooFit libraries: `RooFit::MultiProcess` and `RooFit::TestStatistics`.; To activate both, build with `-Droofit_multiprocess=ON`. The `RooFit::TestStatistics` namespace contains a major refactoring of the `RooAbsTestStatistic`-`RooAbsOptTestStatistic`-`RooNLLVar` inheritance tree into:. 1. statistics-based classes on the one hand;; 2. calculation/evaluation/optimization based classes on the other hand. The main selling point of using `RooFit::TestStatistics` from a performance point of view is the implementation of the `RooFit::MultiProcess` based `LikelihoodGradientJob` calculator class.; To use it to perform a ""migrad"" fit (using Minuit2), one should create a `RooMinimizer` using a new constructor with a `RooAbsL` likelihood parameter as follows:. ```c++; using RooFit::TestStatistics::RooAbsL;; using RooFit::TestStatistics::buildLikelihood;. RooAbsPdf* pdf = ...; // build a pdf; RooAbsData* data = ...; // get some data. std::shared_ptr<RooAbsL> likelihood = buildLikelihood(pdf, data, [OPTIONAL ARGUMENTS]);. RooMinimizer m(likelihood);; m.migrad();; ```. The `RooMinimizer` object behaves as usual, except that behind the scenes it will now calculate each partial derivative on a separate pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:16725,refactor,refactoring,16725,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,2,"['inherit', 'refactor']","['inheritance', 'refactoring']"
Modifiability," value M. The second must be a location description; that represents the one-location description L1. The third must be a; location description that represents the zero-location description L0. A complete composite location storage LS is created with C parts P\ :sub:`N`; ordered in ascending N from 0 to C-1 inclusive. Each P\ :sub:`N` specifies; location description PL\ :sub:`N` and has a bit size of S. PL\ :sub:`N` is as if the ``DW_OP_LLVM_bit_offset N*S`` operation was; applied to PLX\ :sub:`N`\ . PLX\ :sub:`N` is the same as L0 if the N\ :sup:`th` least significant bit of; M is a zero, otherwise it is the same as L1. A location description L comprised of one complete composite location; description SL is pushed on the stack. SL specifies LS with a bit offset of; 0. The DWARF expression is ill-formed if S or C are 0, or if the bit size of M; is less than C. .. note::. Should the count operand for DW_OP_extend and DW_OP_select_bit_piece be; changed to get the count value off the stack? This would allow support for; architectures that have variable length vector instructions such as ARM; and RISC-V. 6. ``DW_OP_LLVM_overlay`` *New*. ``DW_OP_LLVM_overlay`` pops four stack entries. The first must be an; integral type value that represents the overlay byte size value S. The; second must be an integral type value that represents the overlay byte; offset value O. The third must be a location description that represents the; overlay location description OL. The fourth must be a location description; that represents the base location description BL. The action is the same as for ``DW_OP_LLVM_bit_overlay``, except that the; overlay bit size BS and overlay bit offset BO used are S and O respectively; scaled by 8 (the byte size). 7. ``DW_OP_LLVM_bit_overlay`` *New*. ``DW_OP_LLVM_bit_overlay`` pops four stack entries. The first must be an; integral type value that represents the overlay bit size value BS. The; second must be an integral type value that represents the overlay b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:139842,variab,variable,139842,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability," value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: objc. ObjCBlockIndentWidth: 4. [operation setCompletionBlock:^{; [self onOperationDone];; }];. .. _ObjCBreakBeforeNestedBlockParam:. **ObjCBreakBeforeNestedBlockParam** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <ObjCBreakBeforeNestedBlockParam>`; Break parameters list into lines when there is nested block; parameters in a function call. .. code-block:: c++. false:; - (void)_aMethod; {; [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber; *u, NSNumber *v) {; u = c;; }]; }; true:; - (void)_aMethod; {; [self.test1 t:self; w:self; callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {; u = c;; }]; }. .. _ObjCPropertyAttributeOrder:. **ObjCPropertyAttributeOrder** (``List of Strings``) :versionbadge:`clang-format 18`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:89249,config,configuration,89249,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," values are evaluated from left to right. The :token:`RecordBody` is defined below. It can include a list of; parent classes from which the current class inherits, along with field; definitions and other statements. When a class ``C`` inherits from another; class ``D``, the fields of ``D`` are effectively merged into the fields of; ``C``. A given class can only be defined once. A ``class`` statement is; considered to define the class if *any* of the following are true (the; :token:`RecordBody` elements are described below). * The :token:`TemplateArgList` is present, or; * The :token:`ParentClassList` in the :token:`RecordBody` is present, or; * The :token:`Body` in the :token:`RecordBody` is present and not empty. You can declare an empty class by specifying an empty :token:`TemplateArgList`; and an empty :token:`RecordBody`. This can serve as a restricted form of; forward declaration. Note that records derived from a forward-declared; class will inherit no fields from it, because those records are built when; their declarations are parsed, and thus before the class is finally defined. .. _NAME:. Every class has an implicit template argument named ``NAME`` (uppercase),; which is bound to the name of the :token:`Def` or :token:`Defm` inheriting; from the class. If the class is inherited by an anonymous record, the name; is unspecified but globally unique. See `Examples: classes and records`_ for examples. Record Bodies; `````````````. Record bodies appear in both class and record definitions. A record body can; include a parent class list, which specifies the classes from which the; current class or record inherits fields. Such classes are called the; parent classes of the class or record. The record body also; includes the main body of the definition, which contains the specification; of the fields of the class or record. .. productionlist::; RecordBody: `ParentClassList` `Body`; ParentClassList: ["":"" `ParentClassListNE`]; ParentClassListNE: `ClassRef` ("","" `ClassRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:23664,inherit,inherit,23664,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherit']
Modifiability," variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<VarDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. AST Traversal Matchers. Traversal matchers specify the relationship to other nodes that are; reachable from the current node.; Note that there are special traversal matchers (has, hasDescendant, forEach and; forE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:128826,variab,variable,128826,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability," variable names that begin with a lower case; letter: ``camelBack`` and ``lower_case``. (These are also known by other names; but here we use the terminology from clang-tidy). ``camelBack`` is consistent with [WebKit]_, [Qt]_ and [Swift]_ while; ``lower_case`` is consistent with [LLDB]_, [Google]_, [Rust]_ and [Python]_. ``camelBack`` is already used for function names, which may be considered an; advantage [LattnerFunction]_ or a disadvantage [CarruthFunction]_. Approval for ``camelBack`` was expressed by [DenisovCamelBack]_; [LattnerFunction]_ [IvanovicDistinguish]_.; Opposition to ``camelBack`` was expressed by [CarruthCamelBack]_; [TurnerCamelBack]_.; Approval for ``lower_case`` was expressed by [CarruthLower]_; [CarruthCamelBack]_ [TurnerLLDB]_.; Opposition to ``lower_case`` was expressed by [LattnerLower]_. Differentiating variable kinds; ------------------------------. An additional requested change is to distinguish between different kinds of; variables [RobinsonDistinguish]_ [RobinsonDistinguish2]_ [JonesDistinguish]_; [IvanovicDistinguish]_ [CarruthDistinguish]_ [MalyutinDistinguish]_. Others oppose this idea [HähnleDistinguish]_ [GreeneDistinguish]_; [HendersonPrefix]_. A possibility is for member variables to be prefixed with ``m_`` and for global; variables to be prefixed with ``g_`` to distinguish them from local variables.; This is consistent with [LLDB]_. The ``m_`` prefix is consistent with [WebKit]_. A variation is for member variables to be prefixed with ``m``; [IvanovicDistinguish]_ [BeylsDistinguish]_. This is consistent with [Mozilla]_. Another option is for member variables to be suffixed with ``_`` which is; consistent with [Google]_ and similar to [Python]_. Opposed by; [ParzyszekDistinguish]_. Reducing the number of acronyms; ===============================. While switching coding standard will make it easier to use non-acronym names for; new code, it doesn't improve the existing large body of code that uses acronyms; extensively to the det",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:3811,variab,variables,3811,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variables']
Modifiability," variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34657,config,configuration,34657,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability," vector of the source spectrum; - **`sizex`**: x length of the source spectrum; - **`sizey`**: y length of the source spectrum; - **`sigma`**: sigma of searched peaks. An example of the two-dimensional spectrum with the identified peaks is; shown in Figure 3.8. ![Two-dimensional spectrum with the identified peaks](figures/image072.png). We have also generalized the peak searching function similarly to one-dimensional data. The generalized peak searching function for two-dimensional spectra has the form of. ```{.cpp}; Int_t Search2General(float **source,; int sizex,; int sizey,; double sigma,; int threshold,; bool markov,; int aver_window);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into the structure pointed by; `two_dim_peak` structure pointer. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`sizex`**: x length of the source spectrum; - **`sizey`**: y length of the source spectrum; - **`sigma`**: sigma of searched peaks; - **`threshold`**: threshold value for peaks selection; - **`markov`**: logical variable. If it is set to `true`, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; - **`aver_window`** averaging window of searched peaks (applies only for the Markov method). An example of experimental 2-dimensional spectrum is given in Figure 3.9.; The number of peaks identified by the function now is 295. ![Experimental 2-dimensional spectrum](figures/image074.png). The function works even for very noisy data. In Figure 3.10 we present; synthetic 2-dimensional spectrum with 5 peaks. The method should; recognize what is the real 2-dimensional peak and what is the crossing of; two 1-dimensional ridges. The Markov spectrum with averaging window=3 is; given in Figure 3.11. One can observe that this spectrum is smoother than; the original one. After applying the general peak searching function to; the M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:23121,variab,variable,23121,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['variab'],['variable']
Modifiability," vectorized code. The diagram below shows; the CFG for a typical epilogue vectorized loop with runtime checks. As; illustrated the control flow is structured in a way that avoids duplicating the; runtime pointer checks and optimizes the path length for loops that have very; small trip counts. .. image:: epilogue-vectorization-cfg.png. Performance; -----------. This section shows the execution time of Clang on a simple benchmark:; `gcc-loops <https://github.com/llvm/llvm-test-suite/tree/main/SingleSource/UnitTests/Vectorizer>`_.; This benchmarks is a collection of loops from the GCC autovectorization; `page <http://gcc.gnu.org/projects/tree-ssa/vectorization.html>`_ by Dorit Nuzman. The chart below compares GCC-4.7, ICC-13, and Clang-SVN with and without loop vectorization at -O3, tuned for ""corei7-avx"", running on a Sandybridge iMac.; The Y-axis shows the time in msec. Lower is better. The last column shows the geomean of all the kernels. .. image:: gcc-loops.png. And Linpack-pc with the same configuration. Result is Mflops, higher is better. .. image:: linpack-pc.png. Ongoing Development Directions; ------------------------------. .. toctree::; :hidden:. VectorizationPlan. :doc:`VectorizationPlan`; Modeling the process and upgrading the infrastructure of LLVM's Loop Vectorizer. .. _slp-vectorizer:. The SLP Vectorizer; ==================. Details; -------. The goal of SLP vectorization (a.k.a. superword-level parallelism) is; to combine similar independent instructions; into vector instructions. Memory accesses, arithmetic operations, comparison; operations, PHI-nodes, can all be vectorized using this technique. For example, the following function performs very similar operations on its; inputs (a1, b1) and (a2, b2). The basic-block vectorizer may combine these; into vector operations. .. code-block:: c++. void foo(int a1, int a2, int b1, int b2, int *A) {; A[0] = a1*(a1 + b1);; A[1] = a2*(a2 + b2);; A[2] = a1*(a1 + b1);; A[3] = a2*(a2 + b2);; }. The SLP-vectorizer ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:12929,config,configuration,12929,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['config'],['configuration']
Modifiability," very similar to; XML in some ways. Like XML, bitstream files contain tags, and nested; structures, and you can parse the file without having to understand the tags.; Unlike XML, the bitstream format is a binary encoding, and unlike XML it; provides a mechanism for the file to self-describe ""abbreviations"", which are; effectively size optimizations for the content. LLVM IR files may be optionally embedded into a `wrapper`_ structure, or in a; `native object file`_. Both of these mechanisms make it easy to embed extra; data along with LLVM IR files. This document first describes the LLVM bitstream format, describes the wrapper; format, then describes the record structure used by LLVM IR files. .. _bitstream container format:. Bitstream Format; ================. The bitstream format is literally a stream of bits, with a very simple; structure. This structure consists of the following concepts:. * A ""`magic number`_"" that identifies the contents of the stream. * Encoding `primitives`_ like variable bit-rate integers. * `Blocks`_, which define nested content. * `Data Records`_, which describe entities within the file. * Abbreviations, which specify compression optimizations for the file. Note that the :doc:`llvm-bcanalyzer <CommandGuide/llvm-bcanalyzer>` tool can be; used to dump and inspect arbitrary bitstreams, which is very useful for; understanding the encoding. .. _magic number:. Magic Numbers; -------------. The first four bytes of a bitstream are used as an application-specific magic; number. Generic bitcode tools may look at the first four bytes to determine; whether the stream is a known stream type. However, these tools should *not*; determine whether a bitstream is valid based on its magic number alone. New; application-specific bitstream formats are being developed all the time; tools; should not reject them just because they have a hitherto unseen magic number. .. _primitives:. Primitives; ----------. A bitstream literally consists of a stream of bits, whic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:1569,variab,variable,1569,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability," via context menu; 13. Basic latex support when drawing axes labels and titles in 3D; 14. Handle ""dark mode"" in geom painter - automatically adjust background; 15. Let configure material and scene properties in geom control gui; 16. Reset pad enlarge state when pressing ""Escape"" key #265; 17. Scale special fill patterns like 3244 to pad size; 18. Add ""Superimpose"" menu command in hierarchy - let select draw option when append item to pad; 19. Support `inspectN` draw option, allows automatically expand object content to specified level; 20. Implement `allfunc` draw option for histograms, force drawing disregard of TF1::kNotDraw bit; 21. Use `eslint` for static code checking, add testing of interactive features; 22. Upgrade three.js r151 -> r155; 23. Use https://github.com/georgealways/lil-gui/ instead of dat.GUI in geom painter; 24. Put `gl` in ""devDependencies"" of package.json; one can skip it installation with `npm i --production`; 25. Fix - correct scaling of axis labels when tilt them by 25 degree, make this angle configurable; 26. Fix - legend multi-columns drawing and labels scaling; 27. Fix - graph ""B"" bar widths as in native ROOT; 28. Fix - use pad and not frame size for `TText` / `TLatex` scaling; 29. Fix - properly handle ""NB"" (no border) draw option for `TPave` classes; 30. Fix - do not draw histogram title with AXIS draw option; 31. Fix - correct scaling of custom axis labels; 32. Fix - shrink axis labels like 0.20 -> 0.2 or 10^0 -> 1; 33. Fix - copy axis attributes from histogram z scale to palette; 34. Fix - let handle derived from TH1/TH2 classes as histograms #269. ## Changes in 7.4.3; 1. Fix - correctly use GMT specifier in time format; 2. Fix - logical error in `decodeUrl`; 3. Fix - member-wise streaming of std::map #262. ## Changes in 7.4.2; 1. Fix - unzoom z on lego2 plots; 2. Fix - browsing TLists with nullptr inside; 3. Fix - check NaN values when performing TTree::Draw(); 4. Fix - support standard log function in TF1/TF2. ## Changes in 7.4.1; 1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:10796,config,configurable,10796,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configurable']
Modifiability," via refactoring of the; (:doc:`IR standard<LangRef>`) **before** the merge of the new target changes,; following the :ref:`IR backwards compatibility`. * The code conforms to all of the policies laid out in this developer policy; document, including license, patent, and coding standards. * The target should have either reasonable documentation on how it; works (ISA, ABI, etc.) or a publicly available simulator/hardware; (either free or cheap enough) - preferably both. This allows; developers to validate assumptions, understand constraints and review code; that can affect the target. In addition, the rules for a back-end to be promoted to **official** are:. * The target must have addressed every other minimum requirement and; have been stable in tree for at least 3 months. This cool down; period is to make sure that the back-end and the target community can; endure continuous upstream development for the foreseeable future. * The target's code must have been completely adapted to this policy; as well as the :doc:`coding standards<CodingStandards>`. Any exceptions that; were made to move into experimental mode must have been fixed **before**; becoming official. * The test coverage needs to be broad and well written (small tests,; well documented). The build target ``check-all`` must pass with the; new target built, and where applicable, the ``test-suite`` must also; pass without errors, in at least one configuration (publicly; demonstrated, for example, via buildbots). * Public buildbots need to be created and actively maintained, unless; the target requires no additional buildbots (ex. ``check-all`` covers; all tests). The more relevant and public the new target's CI infrastructure; is, the more the LLVM community will embrace it. To **continue** as a supported and official target:. * The maintainer(s) must continue following these rules throughout the lifetime; of the target. Continuous violations of aforementioned rules and policies; could lead to complete removal ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:41558,adapt,adapted,41558,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['adapt'],['adapted']
Modifiability," void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed description. .. _debug-AnalysisOrder:. debug.AnalysisOrder; """"""""""""""""""""""""""""""""""""""; Print callbacks that are called during analysis in order. .. _debug-ConfigDumper:. debug.ConfigDumper; """"""""""""""""""""""""""""""""""""; Dump config table. .. _debug-DumpCFG Display:. debug.DumpCFG Display; """"""""""""""""""""""""""""""""""""""""""; Control-Flow Graphs. .. _debug-DumpCallGraph:. debug.DumpCallGraph; """"""""""""""""""""""""""""""""""""""; Display Call Graph. .. _debug-DumpCalls:. debug.DumpCalls; """"""""""""""""""""""""""""""; Print calls as they are traversed by the engine. .. _debug-DumpDominators:. debug.DumpDominators; """"""""""""""""""""""""""""""""""""""""; Print the dominance tree for a given CFG. .. _debug-DumpLiveVars:. debug.DumpLiveVars; """"""""""""""""""""""""""""""""""""; Print results of live variable analysis. .. _debug-DumpTraversal:. debug.DumpTraversal; """"""""""""""""""""""""""""""""""""""; Print branch conditions as they are traversed by the engine. .. _debug-ExprInspection:. debug.ExprInspection; """"""""""""""""""""""""""""""""""""""""; Check the analyzer's understanding of expressions. .. _debug-Stats:. debug.Stats; """"""""""""""""""""""; Emit warnings with analyzer statistics. .. _debug-TaintTest:. debug.TaintTest; """"""""""""""""""""""""""""""; Mark tainted symbols as such. .. _debug-ViewCFG:. debug.ViewCFG; """"""""""""""""""""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:86320,config,config,86320,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['config']
Modifiability," warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """"""""""""""""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:64529,variab,variables,64529,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variables']
Modifiability," warn; }. different.ObjectUnused; (C++); The object was created but is not being used. struct S {; int x, y;; S(int xx, int yy) : x(xx), y(yy) {}; S(int xx) {; S(xx, 0); // warn; }; };. #include <exception>. void test() {; std::exception();; // warn (did you mean 'throw std::exception()'?); }. different.StaticArrayPtrCompare; (C); Pointer to static array is being compared to NULL. May the subscripting is; missing. void test() {; int a[1][1];; if (a[0] == 0) {}; // warn; }. different.ConversionToBool; (C, C++); Odd implicit conversion to boolean.; Note: possibly merge with ; alpha.core.BoolAssignment. bool test() {; return 1.; // warn; }. bool test() {; return """"; // warn; }. different.ArrayBound; (C++); Out-of-bound dynamic array access.; Note: possibly an enhancement to ; alpha.security.ArrayBoundV2. void test() {; int *p = new int[1];; int i = 1;; if(p[i]) {}; // warn; delete[] p;; }. different.StrcpyInputSize; (C); Buffer copy without checking the size of input.; Note: possibly an enhancement to ; alpha.unix.cstring.OutOfBounds. void test(char* string) {; char buf[24];; strcpy(buf, string); // warn; }. different.IntegerOverflow; (C); Integer overflow.; Note: partially handled by Clang core; (search for 'overflow in expression' warning in Clang tests).; Source: ; CWE-190. #include <limits.h>. int f(int x);. void test() {; f(INT_MAX + 1); // warn; }. #include <limits.h>. int test() {; int x = INT_MAX / 2 + 1;; return x * 2; // warn; }. different.SignExtension; (C); Unexpected sign extension might take place.; Source: ; CWE-194. unsigned long long test(long long sll) {; unsigned long long ull = sll; // warn; return ull;; }. void f(unsigned int i);. void test(int si) {; f(si); // warn; }. unsigned int test(int i) {; return i;; }. different.NumericTruncation; (C); Numeric truncation might take place.; Source: ; CWE-197. unsigned long test(unsigned long long ull) {; unsigned long ul = ull; // warn; return ul;; }. void f(int i);. void test(long long sll) {; f(sll); // wa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:24394,enhance,enhancement,24394,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['enhance'],['enhancement']
Modifiability," was expressed by [DenisovCamelBack]_; [LattnerFunction]_ [IvanovicDistinguish]_.; Opposition to ``camelBack`` was expressed by [CarruthCamelBack]_; [TurnerCamelBack]_.; Approval for ``lower_case`` was expressed by [CarruthLower]_; [CarruthCamelBack]_ [TurnerLLDB]_.; Opposition to ``lower_case`` was expressed by [LattnerLower]_. Differentiating variable kinds; ------------------------------. An additional requested change is to distinguish between different kinds of; variables [RobinsonDistinguish]_ [RobinsonDistinguish2]_ [JonesDistinguish]_; [IvanovicDistinguish]_ [CarruthDistinguish]_ [MalyutinDistinguish]_. Others oppose this idea [HähnleDistinguish]_ [GreeneDistinguish]_; [HendersonPrefix]_. A possibility is for member variables to be prefixed with ``m_`` and for global; variables to be prefixed with ``g_`` to distinguish them from local variables.; This is consistent with [LLDB]_. The ``m_`` prefix is consistent with [WebKit]_. A variation is for member variables to be prefixed with ``m``; [IvanovicDistinguish]_ [BeylsDistinguish]_. This is consistent with [Mozilla]_. Another option is for member variables to be suffixed with ``_`` which is; consistent with [Google]_ and similar to [Python]_. Opposed by; [ParzyszekDistinguish]_. Reducing the number of acronyms; ===============================. While switching coding standard will make it easier to use non-acronym names for; new code, it doesn't improve the existing large body of code that uses acronyms; extensively to the detriment of its readability. Further, it is natural and; generally encouraged that new code be written in the style of the surrounding; code. Therefore it is likely that much newly written code will also use; acronyms despite what the coding standard says, much as it is today. As well as changing the case of variable names, they could also be expanded to; their non-acronym form e.g. ``Triple T`` → ``Triple triple``. There is support for expanding many acronyms [CarruthAcronym]_ [PicusAcronym]",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:4313,variab,variables,4313,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variables']
Modifiability," web browser.; Just apply --web option when starting root like: `root --web tutorials/geom/rootgeom.C`; Not all features of TGeoPainter are supported - only plain drawing of selected TGeoVolume. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. By default, ROOT now falls back to the built-in version of xrootd if it can't find it in the system.; This means that passing `-Dbuiltin_xrootd=ON` is not necessary anymore to build ROOT with xrootd support.; Note that built-in xrootd requires a working network connection. ### Experimental address sanitizer build configuration; Added a build flag `asan` that switches on address sanitizer. It's experimental, so expect problems. For example, when building with gcc,; manipulations in global variables in llvm will abort the build. Such checks can be disabled using environment variables. Check the address; sanitizer documentation or the link below for details. In clang, which allows to blacklist functions, the build will continue. See [core/sanitizer](https://github.com/root-project/root/tree/master/core/sanitizer) for information. ### Optimization of ROOT header files. Many (but intentionally not all) unused includes were removed from ROOT header files. For instance, `#include ""TObjString.h""` and; `#include ""ThreadLocalStorage.h""` were removed from `TClass.h`. Or `#include ""TDatime.h""` was removed from; `TDirectory.h` header file . Or `#include ""TDatime.h""` was removed from `TFile.h`.; This change may cause errors during compilation of ROOT-based code. To fix it, provide missing the includes; where they are really required.; This improves compile times and reduces code inter-dependency; see https://github.com/include-what-you-use/include-what-you-use/blob/master/docs/WhyIWYU.md for a good overview of the motivation. Even more includes will",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:7921,variab,variables,7921,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['variab'],['variables']
Modifiability," welcome and appreciate such contributions!; This short guide tries to make contributing as quick and painless as possible. > [!NOTE]; > These guidelines should be applicable to most contributes. At the same time, these are not 'one-size-fits-all' rules,; > and there might be cases where diverging from these guidelines is warranted. If you are unsure about how to structure; > your contribution, don't hesitate to reach out! We are always happy to provide help and feedback. ## Your Code Contribution. The source code for ROOT is kept in [GitHub](https://github.com/root-project/root).; Changes go through pull requests (""PRs"").; The primary branch for development is `master`. > [!IMPORTANT]; > We require PRs to cleanly apply to master without a merge commit, i.e. through ""fast-forward"".; > Please follow the [coding conventions](https://root.cern.ch/coding-conventions), as this is a simple item for; > reviewers to otherwise get stuck on.; > To make your (and our own) life easier, we provide a; > [`clang-format` configuration file](https://github.com/root-project/root/blob/master/.clang-format). By providing code, you agree to transfer your copyright on the code to the ""ROOT project"".; Of course you will be duly credited: for sizable contributions your name will appear in the; [CREDITS](https://raw.githubusercontent.com/root-project/root/master/README/CREDITS); file shipped with every binary and source distribution.; The copyright transfer helps us with effectively defending the project in case of litigation. ## Your Commit. Each commit is a self-contained, _atomic_ change. This means that:; 1. **Each commit should be able to successfully build ROOT.**; Doing so makes traveling through the git history, for example during a `git bisect` much easier.; Ideally, the commit also should not depend on other commits to _run_ ROOT.; 2. **Each commit does not contain more than one independent change.**; This allows us to revert changes when needed, without affecting anything else. > ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:1119,config,configuration,1119,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['config'],['configuration']
Modifiability," well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemalloc). Library; -------; The allocator static library can be built from the LLVM tree thanks to the; ``scudo_standalone`` CMake rule. The associated tests can be exercised thanks to; the ``check-scudo_standalone`` CMake rule. Linking the static library to your project can require the use of the; ``whole-archive`` linker flag (or equivalent), depending on your linker.; Additional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/lib; clang++ -fPIC -std=c++17 -msse4.2 -O2 -pthread -shared \; -I scudo/standalone/include \; scudo/standalone/*.cpp \; -o $HOME/libscudo.so. and then use it with existing binaries as follows:. .. code:: console. LD_PRELOAD=$HOME/libscudo.so ./a.out. Clang; -----; With a recent version of Clang (post rL317337), the ""old"" versi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:5692,config,configurations,5692,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['config'],['configurations']
Modifiability," when there are; multiple matches. But it allows the call to obtain the location; description for a variable or formal parameter which may use a location; list expression. An alternative is to treat the case when D has a ``DW_AT_location``; attribute that is encoded as a ``loclist`` or ``loclistsptr``, and the; specified location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB implements ``DW_OP_call*`` by always executing E on the same stack.; If the location list has multiple matching entries, it simply picks the; first one and ignores the rest. This seems fundamentally at odds with; the desire to support multiple places for variables. So, it feels like ``DW_OP_call*`` should both support pushing a location; description on the stack for a variable or formal parameter, and also; support being able to execute an operation expression on the same stack.; Being able to specify a different operation expression for different; program locations seems a desirable feature to retain. A solution to that is to have a distinct ``DW_AT_LLVM_proc`` attribute; for the ``DW_TAG_dwarf_procedure`` debugging information entry. Then the; ``DW_AT_location`` attribute expression is always executed separately; and pushes a location description (that may have multiple single; loca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:77280,variab,variable,77280,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability," when we; have a condition it is. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; continue;; }. * ``SBS_Empty`` (in configuration: ``Empty``); Only merge empty blocks. .. code-block:: c++. while (true) {}; while (true) {; continue;; }. * ``SBS_Always`` (in configuration: ``Always``); Always merge short blocks into a single line. .. code-block:: c++. while (true) {}; while (true) { continue; }. .. _AllowShortCaseLabelsOnASingleLine:. **AllowShortCaseLabelsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.6` :ref:`¶ <AllowShortCaseLabelsOnASingleLine>`; If ``true``, short case labels will be contracted to a single line. .. code-block:: c++. true: false:; switch (a) { vs. switch (a) {; case 1: x = 1; break; case 1:; case 2: return; x = 1;; } break;; case 2:; return;; }. .. _AllowShortCompoundRequirementOnASingleLine:. **AllowShortCompoundRequirementOnASingleLine** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <AllowShortCompoundRequirementOnASingleLine>`; Allow short compound requirement on a single line. .. code-block:: c++. true:; template <typename T>; concept c = requires(T x) {; { x + 1 } -> st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:27195,config,configuration,27195,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," which contains; debug information that can be consumed by debuggers and other tools. Since; officially supported APIs exist on Windows for querying debug information from; PDBs even without the user understanding the internals of the file format, a; large ecosystem of tools has been built for Windows to consume this format. In; order for Clang to be able to generate programs that can interoperate with these; tools, it is necessary for us to generate PDB files ourselves. At the same time, LLVM has a long history of being able to cross-compile from; any platform to any platform, and we wish for the same to be true here. So it; is necessary for us to understand the PDB file format at the byte-level so that; we can generate PDB files entirely on our own. This manual describes what we know about the PDB file format today. The layout; of the file, the various streams contained within, the format of individual; records within, and more. We would like to extend our heartfelt gratitude to Microsoft, without whom we; would not be where we are today. Much of the knowledge contained within this; manual was learned through reading code published by Microsoft on their `GitHub; repo <https://github.com/Microsoft/microsoft-pdb>`__. .. _pdb_layout:. File Layout; ===========. .. important::; Unless otherwise specified, all numeric values are encoded in little endian.; If you see a type such as ``uint16_t`` or ``uint64_t`` going forward, always; assume it is little endian!. .. toctree::; :hidden:. MsfFile; PdbStream; TpiStream; DbiStream; ModiStream; PublicStream; GlobalStream; HashTable; CodeViewSymbols; CodeViewTypes. .. _msf:. The MSF Container; -----------------; A PDB file is an MSF (Multi-Stream Format) file. An MSF file is a ""file system; within a file"". It contains multiple streams (aka files) which can represent; arbitrary data, and these streams are divided into blocks which may not; necessarily be contiguously laid out within the MSF container file.; Additionally, the MSF ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/index.rst:1194,extend,extend,1194,interpreter/llvm-project/llvm/docs/PDB/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/index.rst,1,['extend'],['extend']
Modifiability," will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved identifiers to ensuring that code adheres to lifecycle; protocols for certain LibreOffice-specific classes. They may serve as; examples for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:3302,plugin,plugin,3302,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,1,['plugin'],['plugin']
Modifiability," will be of element types of that ``struct`` in order;. - otherwise, it is just the return value of the continuation function. .. code-block:: llvm. define {ptr, ptr} @g(ptr %buffer, ptr %ptr, i8 %val) presplitcoroutine {; entry:; %id = call token @llvm.coro.id.retcon.once(i32 8, i32 8, ptr %buffer,; ptr @prototype,; ptr @allocate, ptr @deallocate); %hdl = call ptr @llvm.coro.begin(token %id, ptr null). ... cleanup:; %tok = call token (...) @llvm.coro.end.results(i8 %val); call i1 @llvm.coro.end(ptr %hdl, i1 0, token %tok); unreachable. ... declare i8 @prototype(ptr, i1 zeroext); . 'llvm.coro.end.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i1 @llvm.coro.end.async(ptr <handle>, i1 <unwind>, ...). Overview:; """""""""""""""""". The '``llvm.coro.end.async``' marks the point where execution of the resume part; of the coroutine should end and control should return to the caller. As part of; its variable tail arguments this instruction allows to specify a function and; the function's arguments that are to be tail called as the last action before; returning. Arguments:; """""""""""""""""""". The first argument should refer to the coroutine handle of the enclosing; coroutine. A frontend is allowed to supply null as the first parameter, in this; case `coro-early` pass will replace the null with an appropriate coroutine; handle value. The second argument should be `true` if this coro.end is in the block that is; part of the unwind sequence leaving the coroutine body due to an exception and; `false` otherwise. The third argument if present should specify a function to be called. If the third argument is present, the remaining arguments are the arguments to; the function call. .. code-block:: llvm. call i1 (ptr, i1, ...) @llvm.coro.end.async(; ptr %hdl, i1 0,; ptr @must_tail_call_return,; ptr %ctxt, ptr %task, ptr %actor); unreachable. .. _coro.suspend:; .. _suspend points:. 'llvm.coro.suspend' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i8 @",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:48650,variab,variable,48650,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['variab'],['variable']
Modifiability," will have one line each. .. code-block:: c++. true:; void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. false:; void f(int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. .. _BitFieldColonSpacing:. **BitFieldColonSpacing** (``BitFieldColonSpacingStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BitFieldColonSpacing>`; The BitFieldColonSpacingStyle to use for bitfields. Possible values:. * ``BFCS_Both`` (in configuration: ``Both``); Add one space on each side of the ``:``. .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:38115,config,configuration,38115,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plugin`` option to; ``ld``. It will not look for an alternate linker without ``-fuse-ld=gold``,; which is why you otherwise need gold to be the installed system linker in; your path. ``ar`` and ``nm`` also accept the ``-plugin`` option and it's possible to; to install ``LLVMgold.so`` to ``/usr/lib/bfd-plugins`` for a seamless setup.; If you built your own gold, be sure to install the ``ar`` and ``nm-new`` you; built to ``/usr/bin``. Example of link time optimization; ---------------------------------. The following example shows a worked example of the gold plugin mixing LLVM; bitcode and native code. .. code-block:: c. --- a.c ---; #include <stdio.h>. extern void foo1(void);; extern void foo4(void);. void foo2(void) {; printf(""Foo2\n"");; }.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:3043,plugin,plugin-api,3043,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin-api']
Modifiability," with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimization options (print level, tolerance, max iterations, etc...); - setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:38252,config,configuration,38252,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['config'],['configuration']
Modifiability," with special; behaviors. In terms of the object-oriented programming we can define a; widget in ROOT as an object of a class deriving from **`TGObject`**. This section presents all currently supported widgets in ROOT and their; most useful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TGNumberEntry`**, **`TGScrollBar`**,; **`TGShutterItem`**, **`TGTextEntry`**, **`TGSlider`**, **`TGListBox`**,; **`TGView.`**. This class has four data members keeping information about the widget id; - important for event processing, the window which handles the wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:21020,inherit,inherits,21020,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inherits']
Modifiability," with the; runtime. These are used to crawl the heap for object references. In general, LLVM's support for GC does not include features which can be; adequately addressed with other features of the IR and does not specify a; particular binary interface. On the plus side, this means that you should be; able to integrate LLVM with an existing runtime. On the other hand, it can; have the effect of leaving a lot of work for the developer of a novel; language. We try to mitigate this by providing built in collector strategy; descriptions that can work with many common collector designs and easy; extension points. If you don't already have a specific binary interface; you need to support, we recommend trying to use one of these built in collector; strategies. .. _gc_intrinsics:. LLVM IR Features; ================. This section describes the garbage collection facilities provided by the; :doc:`LLVM intermediate representation <LangRef>`. The exact behavior of these; IR features is specified by the selected :ref:`GC strategy description; <plugin>`. Specifying GC code generation: ``gc ""...""``; -------------------------------------------. .. code-block:: text. define <returntype> @name(...) gc ""name"" { ... }. The ``gc`` function attribute is used to specify the desired GC strategy to the; compiler. Its programmatic equivalent is the ``setGC`` method of ``Function``. Setting ``gc ""name""`` on a function triggers a search for a matching subclass; of GCStrategy. Some collector strategies are built in. You can add others; using either the loadable plugin mechanism, or by patching your copy of LLVM.; It is the selected GC strategy which defines the exact nature of the code; generated to support GC. If none is found, the compiler will raise an error. Specifying the GC style on a per-function basis allows LLVM to link together; programs that use different garbage collection algorithms (or none at all). .. _gcroot:. Identifying GC roots on the stack; ----------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:8439,plugin,plugin,8439,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability," wpdRes: (kind: branchFunnel); wpdRes: (kind: singleImpl, singleImplName: ""_ZN1A1nEi""); wpdRes: (kind: indir). Additionally, each wpdRes has an optional ``resByArg`` field, which; describes the resolutions for calls with all constant integer arguments:. .. code-block:: text. resByArg: (ResByArg[, ResByArg]*). where ResByArg is:. .. code-block:: text. args: (Arg[, Arg]*), byArg: (kind: UniformRetVal[, info: 0][, byte: 0][, bit: 0]). Where the ``kind`` can be ``Indir``, ``UniformRetVal``, ``UniqueRetVal``; or ``VirtualConstProp``. The ``info`` field is only used if the kind; is ``UniformRetVal`` (indicates the uniform return value), or; ``UniqueRetVal`` (holds the return value associated with the unique vtable; (0 or 1)). The ``byte`` and ``bit`` fields are only used if the target does; not support the use of absolute symbols to store constants. .. _intrinsicglobalvariables:. Intrinsic Global Variables; ==========================. LLVM has a number of ""magic"" global variables that contain data that; affect code generation or other IR semantics. These are documented here.; All globals of this sort should have a section specified as; ""``llvm.metadata``"". This section and all globals that start with; ""``llvm.``"" are reserved for use by LLVM. .. _gv_llvmused:. The '``llvm.used``' Global Variable; -----------------------------------. The ``@llvm.used`` global is an array which has; :ref:`appending linkage <linkage_appending>`. This array contains a list of; pointers to named global variables, functions and aliases which may optionally; have a pointer cast formed of bitcast or getelementptr. For example, a legal; use of it is:. .. code-block:: llvm. @X = global i8 4; @Y = global i32 123. @llvm.used = appending global [2 x ptr] [; ptr @X,; ptr @Y; ], section ""llvm.metadata"". If a symbol appears in the ``@llvm.used`` list, then the compiler, assembler,; and linker are required to treat the symbol as if there is a reference to the; symbol that it cannot see (which is why they ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:350492,variab,variables,350492,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability," x O(10000) times new/delete):. ``` {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; ```. You better use a **`TClonesArray`** which reduces the number of; new/delete calls to only O(10000):. ``` {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; ```. Considering that a pair of new/delete calls on average cost about 70 ms,; O(109) new/deletes will save about 19 hours. For the other collections,; see the class reference guide on the web and the test program; `$ROOTSYS/test/tcollex.cxx.`. ## Template Containers and STL. Some people dislike polymorphic containers because they are not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that effectively does just this. For example:. ``` {.cpp}; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; ```. This is an array container with a 10-element array of pointers to T, it; could hold up to 10 T objects. This array is flawed because it is static; and hard-coded, it should be dynamic. However, the important point is; that the template stat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:17993,polymorphi,polymorphic,17993,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['polymorphi'],['polymorphic']
Modifiability," you can also get objects with names that don't qualify as a Python variable. Here is a short demo:; ```python; import ROOT. with ROOT.TFile.Open(""my_file.root"", ""RECREATE"") as my_file:. # Populate the TFile with simple objects.; my_file.WriteObject(ROOT.std.string(""hello world""), ""my_string""); my_file.WriteObject(ROOT.vector[""int""]([1, 2, 3]), ""my vector""). print(my_file[""my_string""]) # new syntax; print(my_file.my_string) # old deprecated syntax. # With the dictionary syntax, you can also use names that don't qualify as; # a Python variable:; print(my_file[""my vector""]); # print(my_file.my vector) # the old syntax would not work here!; ```. The old pythonization with the `__getattr__` syntax still works, but emits a deprecation warning and will be removed from ROOT 6.34. ### Removal of Python 2 support. ROOT does no longer support Python 2. The minimum Python version necessary to use ROOT in a Python application is 3.8.; As a consequence, any reference to Python 2 in ROOT code was removed and certain configuration options are no longer; usable, e.g. * `root-config --python2-version`; * cmake -Dpyroot-python2. The cmake build system now looks for the standard `Python3` package and previously custom Python-related cmake variables; are now just the ones automatically produced by cmake (see https://cmake.org/cmake/help/latest/module/FindPython.html). ### More usage of the public cppyy API. Many implementation details of the ROOT pythonizations were moved from C++ functions to pure Python bindings using the; public cppyy API. This helps in the integration with the tool but also improves code efficiency and memory usage. ## Class Reference Guide. - Define missing doxygen groups.; - Fix a few typos in the `THStack` documentation.; - Small fixes in the `THistPainter` documentation.; - Improve the `TColor` documentation: use modern C++ in the examples.; - Make sure the python examples do not generate wrong namespaces in the documentation.; - The dataframe tutorials json sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:22645,config,configuration,22645,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['config'],['configuration']
Modifiability," you have LLVM configured, you can build it by entering the *OBJ_ROOT*; directory and issuing the following command:. .. code-block:: console. % make. If the build fails, please `check here`_ to see if you are using a version of; GCC that is known not to compile LLVM. If you have multiple processors in your machine, you may wish to use some of the; parallel build options provided by GNU Make. For example, you could use the; command:. .. code-block:: console. % make -j2. There are several special targets which are useful when working with the LLVM; source code:. ``make clean``. Removes all files generated by the build. This includes object files,; generated C/C++ files, libraries, and executables. ``make install``. Installs LLVM header files, libraries, tools, and documentation in a hierarchy; under ``$PREFIX``, specified with ``CMAKE_INSTALL_PREFIX``, which; defaults to ``/usr/local``. ``make docs-llvm-html``. If configured with ``-DLLVM_ENABLE_SPHINX=On``, this will generate a directory; at ``OBJ_ROOT/docs/html`` which contains the HTML formatted documentation. Cross-Compiling LLVM; --------------------. It is possible to cross-compile LLVM itself. That is, you can create LLVM; executables and libraries to be hosted on a platform different from the platform; where they are built (a Canadian Cross build). To generate build files for; cross-compiling CMake provides a variable ``CMAKE_TOOLCHAIN_FILE`` which can; define compiler flags and variables used during the CMake test operations. The result of such a build is executables that are not runnable on the build; host but can be executed on the target. As an example the following CMake; invocation can generate build files targeting iOS. This will work on macOS; with the latest Xcode:. .. code-block:: console. % cmake -G ""Ninja"" -DCMAKE_OSX_ARCHITECTURES=""armv7;armv7s;arm64""; -DCMAKE_TOOLCHAIN_FILE=<PATH_TO_LLVM>/cmake/platforms/iOS.cmake; -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_RUNTIME=Off -DLLVM_INCLUDE_TESTS=Off; -DLL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:30505,config,configured,30505,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configured']
Modifiability," you set these options to should be stored in a cookie,; so you will have the same setting next time you look at the class documentation. The two links in the bottom of the box get you to the top of the page and to this help; page. You can hide the info box by clicking on the little ""-"" in the top right corner; of the box, and show it again by clicking on the ""+"". List of Data and Function Members; The central part of a class are its members. Some are available to you; some; are hidden from you, because they are only meant to be used internally.; As an example, a class might allow you to set, access, and print its values, or store; them into a file.; Because methods should have reasonable names, often the method name itself is already; a hint on what it does.; If you want to get a TNamed's; name, you will immediately see TNamed::GetName() in its list of functions.; A click on this name will send you to the documentation for the method.; If you enabled the display of inherited members you will see; some members with a class name prefix. It tells you where this method has been defined.; Display Options; The info box contains options that influence how; the list of members is displayed: you can e.g. show or hide non-public methods. If you; just want to use ROOT you should hide them - you cannot access protected or private; members anyway. And you can select whether member that are inherited from a base class; should be shown. Again, if you just want to use ROOT you should probably show them,; as you often want to use them whether they are defined in the current class or in one; of its base classes. Whatever you set these options to should be stored in a cookie,; so you will have the same setting next time you look at the class documentation. Access (public / protected / private); Not all members are available to everyone (check any C++ introduction to learn why).; Public members have a green bar on their left, protected ones have a yellow one, and; private members are ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:5280,inherit,inherited,5280,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,1,['inherit'],['inherited']
Modifiability," you that `inf != inf` if you define `inf` as `std::numeric_limits<double>::infinity()`, which is inconsistent with the regular `==` operator. This is unexpected, because one would expect that if two numbers are considered exactly equal, they would also be considered equal within any range.; Therefore, the behavior of `TMath::AreEqualAbs()` was changed to return always `true` if the `==` comparison would return `true`. ## RooFit Libraries. ### Changes in RooFormulaVar and RooGenericPdf. The TFormula-based RooFit classes `RooFormulaVar` and `RooGenericPdf` change a bit their behavior to be more consistent:. 1. No matter which variables you pass to the constructor, only the variables that the formula depends on are registered as value servers.; 2. Similarly, the `dependents()` method of RooFormulaVar and RooGenericPdf will only return the list of actual value servers. ### Removal of the RooGenFunction and RooMultiGenFunction classes. The `RooGenFunction` was only a lightweight adaptor that exports a RooAbsReal as a `ROOT::Math::IGenFunction`.; The same can be easily achieved with the generic `ROOT::Math::Functor1D`, so in the spirit of not duplicating interfaces, the `RooGenFunction` is removed in this release. Here is an example that shows how to replace it in the unlikely case you were using it:. ```C++; RooArgSet normSet{x}; // normalization set. // Old way 1: create a RooGenFunction:; RooGenFunction func1{pdf, x, {}, normSet};. // Old way 2: use `RooAbsReal::iGenFunction()`:; std::unique_ptr<ROOT::Math::IGenFunction> func2{; pdf.iGenFunction(x, normSet); };. // How to do it now:; RooFunctor functor{pdf, x, {}, normSet};; ROOT::Math::Functor1D func3{functor};; // Functor1D takes by reference, so the RooFunctor also needs to stay alive.; ```. For the same reason, the `RooMultiGenFunction` class that implements a multidimensional `ROOT::Math::IMultiGenFunction` is removed too.; It can easily be replaced by a `ROOT::Math::Functor`:. ```C++; RooFunctor functor{pdf, obse",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:11704,adapt,adaptor,11704,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['adapt'],['adaptor']
Modifiability," you will need. Hardware; --------. LLVM is known to work on the following host platforms:. ================== ===================== =============; OS Arch Compilers; ================== ===================== =============; Linux x86\ :sup:`1` GCC, Clang; Linux amd64 GCC, Clang; Linux ARM GCC, Clang; Linux Mips GCC, Clang; Linux PowerPC GCC, Clang; Linux SystemZ GCC, Clang; Solaris V9 (Ultrasparc) GCC; DragonFlyBSD amd64 GCC, Clang; FreeBSD x86\ :sup:`1` GCC, Clang; FreeBSD amd64 GCC, Clang; NetBSD x86\ :sup:`1` GCC, Clang; NetBSD amd64 GCC, Clang; OpenBSD x86\ :sup:`1` GCC, Clang; OpenBSD amd64 GCC, Clang; macOS\ :sup:`2` PowerPC GCC; macOS x86 GCC, Clang; Cygwin/Win32 x86\ :sup:`1, 3` GCC; Windows x86\ :sup:`1` Visual Studio; Windows x64 x86-64 Visual Studio; ================== ===================== =============. .. note::. #. Code generation supported for Pentium processors and up; #. Code generation supported for 32-bit ABI only; #. To use LLVM modules on Win32-based system, you may configure LLVM; with ``-DBUILD_SHARED_LIBS=On``. Note that Debug builds require a lot of time and disk space. An LLVM-only build; will need about 1-3 GB of space. A full build of LLVM and Clang will need around; 15-20 GB of disk space. The exact space requirements will vary by system. (It; is so large because of all the debugging information and the fact that the; libraries are statically linked into multiple tools). If you are space-constrained, you can build only selected tools or only; selected targets. The Release build requires considerably less space. The LLVM suite *may* compile on other platforms, but it is not guaranteed to do; so. If compilation is successful, the LLVM utilities should be able to; assemble, disassemble, analyze, and optimize LLVM bitcode. Code generation; should work as well, although the generated native code may not work on your; platform. Software; --------. Compiling LLVM requires that you have several software packages installed. The; table below lists",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:9167,config,configure,9167,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configure']
Modifiability," { if (shouldProcessAttr(A)); handleAttr(A); handleAttr(A);; } }; }; }. if (isa<FunctionDecl>(D)) { vs. if (isa<FunctionDecl>(D)); for (auto *A : D.attrs()) { for (auto *A : D.attrs()); handleAttr(A); handleAttr(A);; }; }. if (auto *D = (T)(D)) { vs. if (auto *D = (T)(D)) {; if (shouldProcess(D)) { if (shouldProcess(D)); handleVarDecl(D); handleVarDecl(D);; } else { else; markAsIgnored(D); markAsIgnored(D);; } }; }. if (a) { vs. if (a); b(); b();; } else { else if (c); if (c) { d();; d(); else; } else { e();; e();; }; }. .. _RemoveParentheses:. **RemoveParentheses** (``RemoveParenthesesStyle``) :versionbadge:`clang-format 17` :ref:`¶ <RemoveParentheses>`; Remove redundant parentheses. .. warning::. Setting this option to any value other than ``Leave`` could lead to; incorrect code formatting due to clang-format's lack of complete semantic; information. As such, extra care should be taken to review code changes; made by this option. Possible values:. * ``RPS_Leave`` (in configuration: ``Leave``); Do not remove parentheses. .. code-block:: c++. class __declspec((dllimport)) X {};; co_return (((0)));; return ((a + b) - ((c + d)));. * ``RPS_MultipleParentheses`` (in configuration: ``MultipleParentheses``); Replace multiple parentheses with single parentheses. .. code-block:: c++. class __declspec(dllimport) X {};; co_return (0);; return ((a + b) - (c + d));. * ``RPS_ReturnStatement`` (in configuration: ``ReturnStatement``); Also remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - (c + d);. .. _RemoveSemicolon:. **RemoveSemicolon** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <RemoveSemicolon>`; Remove semicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:102953,config,configuration,102953,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability," | vertical frame - it will fit the whole width. If it is |; | | a horizontal frame - after the positioning of all |; | | frames the available ""free"" width space is shared |; | | between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsExpandY` | specifies the frame to be expanded up to the height of |; | | the container frame. If the container frame is a |; | | horizontal frame - it will fit the whole height. If the |; | | container frame is a vertical frame - after the |; | | arrangement of all frames the available ""free"" height |; | | space is shared between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsNormal` | = `kLHintsLeft | kLHintsTop` - default hints |; +------------------+---------------------------------------------------------+. Layout policy:. Child frames never modify their container frame. The container frame can; (or cannot) adapt its size in the layout process. It can show all or a; part of its frames. Every **`TGFrame`** object has a default minimum; size (1, 1) assured by **`TGWindow`**. ## Event Processing: Signals and Slots. Event handling covers the interaction between different objects and; between the user and the objects in an application. There are two; general ways for the user to interact with an application: the keyboard; and the mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window system. The; window system reports interaction events to the application. The; application in turn forwards them to the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mech",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:39721,adapt,adapt,39721,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['adapt'],['adapt']
Modifiability," |. The ""split encoding"" columns apply a byte transformation encoding to all pages of that column; and in addition, depending on the column type, delta or zigzag encoding:. Split (only); : Rearranges the bytes of elements: All the first bytes first, then all the second bytes, etc. Delta + split; : The first element is stored unmodified, all other elements store the delta to the previous element.; Followed by split encoding. Zigzag + split; : Used on signed integers only; it maps $x$ to $2x$ if $x$ is positive and to $-(2x+1)$ if $x$ is negative.; Followed by split encoding. **Note**: these encodings always happen within each page, thus decoding should be done page-wise,; not cluster-wise. The `Real32Trunc` type column is a variable-sized floating point column; with lower precision than `Real32` and `SplitReal32`.; It is an IEEE-754 single precision float with some of the mantissa's least significant bits truncated. The `Real32Quant` type column is a variable-sized real column that is internally represented as an integer within; a specified range of values. For this column type, flag 0x10 (column with range) is always set (see paragraphs below). Future versions of the file format may introduce additional column types; without changing the minimum version of the header or introducing a feature flag.; Old readers need to ignore these columns and fields constructed from such columns.; Old readers can, however, figure out the number of elements stored in such unknown columns. The ""flags"" field can have one of the following bits set. | Bit | Meaning |; |----------|-------------------------------------------------------------------|; | 0x08 | Deferred column: index of first element in the column is not zero |; | 0x10 | Column with a range of possible values |. If flag 0x08 (deferred column) is set, the index of the first element in this column is not zero,; which happens if the column is added at a later point during write.; In this case, an additional 64bit integer contai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:23538,variab,variable-sized,23538,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['variab'],['variable-sized']
Modifiability," }. and:. .. code-block:: c. ^ int ((*)(float x))(char) { return functionPointer; }. are equivalent expressions, as is:. .. code-block:: c. ^(float x) { return functionPointer; }. [returnfunctionptr.c]. The compound statement body establishes a new lexical scope within; that of its parent. Variables used within the scope of the compound; statement are bound to the Block in the normal manner with the; exception of those in automatic (stack) storage. Thus one may access; functions and global variables as one would expect, as well as static; local variables. [testme]. Local automatic (stack) variables referenced within the compound; statement of a Block are imported and captured by the Block as const; copies. The capture (binding) is performed at the time of the Block; literal expression evaluation. The compiler is not required to capture a variable if it can prove; that no references to the variable will actually be evaluated.; Programmers can force a variable to be captured by referencing it in a; statement at the beginning of the Block, like so:. .. code-block:: c. (void) foo;. This matters when capturing the variable has side-effects, as it can; in Objective-C or C++. The lifetime of variables declared in a Block is that of a function;; each activation frame contains a new copy of variables declared within; the local scope of the Block. Such variable declarations should be; allowed anywhere [testme] rather than only when C99 parsing is; requested, including for statements. [testme]. Block literal expressions may occur within Block literal expressions; (nest) and all variables captured by any nested blocks are implicitly; also captured in the scopes of their enclosing Blocks. A Block literal expression may be used as the initialization value for; Block variables at global or local static scope. The Invoke Operator; ===================. Blocks are :block-term:`invoked` using function call syntax with a; list of expression parameters of types corresponding to the; dec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:4918,variab,variable,4918,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variable']
Modifiability," }; ```. Let's look at an example where the raw pointer owns two different memory blocks:. ```c++; void UniqueOwnership2() {; int *pi = new int; // pi is Defined; Borrow(pi);; delete pi; // pi is Compatible; if (smth) {; pi = new int; // pi is Defined; Borrow(pi);; delete pi; // pi is Compatible; }; // pi is Compatible; }; ```. It can be refactored to use `unique_ptr` like this:. ```c++; void UniqueOwnership2() {; auto pi = make_unique<int>();; Borrow(pi);; if (smth) {; pi = make_unique<int>();; Borrow(pi);; }; }; ```. In the following example, the raw pointer is used to access the heap object; after the ownership has been transferred. ```c++; void UniqueOwnership3() {; int *pi = new int; // pi is Defined; if (...) {; Borrow(pi);; delete pi; // pi is Compatible; } else {; vector<unique_ptr<int>> v = {std::unique_ptr(pi)}; // pi is Compatible; print(*pi);; use(v);; }; // pi is Compatible; }; ```. We can refactor this code to use `unique_ptr`, however we would have to; introduce a non-owning pointer variable, since we can't use the moved-from; `unique_ptr` to access the object:. ```c++; void UniqueOwnership3() {; std::unique_ptr<int> pi = std::make_unique<int>();; if (...) {; Borrow(pi);; } else {; int *pi_non_owning = pi.get();; vector<unique_ptr<int>> v = {std::move(pi)};; print(*pi_non_owning);; use(v);; }; }; ```. If the original code didn't call `delete` at the very end of the function, then; our refactoring may change the point at which we run the destructor and release; memory. Specifically, if there is some user code after `delete`, then extending; the lifetime of the object until the end of the function may hold locks for; longer than necessary, introduce memory overhead etc. One solution is to always replace `delete` with a call to `reset()`, and then; perform another analysis that removes unnecessary `reset()` calls. ```c++; void AddedMemoryOverhead() {; HugeObject *ho = new HugeObject();; use(ho);; delete ho; // Release the large amount of memory quickly.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:23693,refactor,refactor,23693,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,2,"['refactor', 'variab']","['refactor', 'variable']"
Modifiability," }``). C++14 relaxed constexpr; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_relaxed_constexpr)`` or; ``__has_extension(cxx_relaxed_constexpr)`` to determine if variable; declarations, local variable modification, and control flow constructs; are permitted in ``constexpr`` functions. C++14 return type deduction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_return_type_deduction)`` or; ``__has_extension(cxx_return_type_deduction)`` to determine if support; for return type deduction for functions (using ``auto`` as a return type); is enabled. C++14 runtime-sized arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_runtime_array)`` or; ``__has_extension(cxx_runtime_array)`` to determine if support; for arrays of runtime bound (a restricted form of variable-length arrays); is enabled.; Clang's implementation of this feature is incomplete. C++14 variable templates; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_variable_templates)`` or; ``__has_extension(cxx_variable_templates)`` to determine if support for; templated variable declarations is enabled. C11; ---. The features listed below are part of the C11 standard. As a result, all these; features are enabled with the ``-std=c11`` or ``-std=gnu11`` option when; compiling C code. Additionally, because these features are all; backward-compatible, they are available as extensions in all language modes. C11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_alignas)`` or ``__has_extension(c_alignas)`` to determine; if support for alignment specifiers using ``_Alignas`` is enabled. Use ``__has_feature(c_alignof)`` or ``__has_extension(c_alignof)`` to determine; if support for the ``_Alignof`` keyword is enabled. C11 atomic operations; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_atomic)`` or ``__has_extension(c_atomic)`` to determine; if support for atomic types using ``_Atomic`` is enabled. Clang also provides; :ref:`a set of builtins <langext-__c11_atomic>` which can be used to imple",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:51249,variab,variable,51249,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variable']
Modifiability,"!21 = !DIExpression(DW_OP_LLVM_implicit_pointer,; DW_OP_LLVM_implicit_pointer)). DWARF specifies three kinds of simple location descriptions: Register, memory,; and implicit location descriptions. Note that a location description is; defined over certain ranges of a program, i.e the location of a variable may; change over the course of the program. Register and memory location; descriptions describe the *concrete location* of a source variable (in the; sense that a debugger might modify its value), whereas *implicit locations*; describe merely the actual *value* of a source variable which might not exist; in registers or in memory (see ``DW_OP_stack_value``). A ``llvm.dbg.declare`` intrinsic describes an indirect value (the address) of a; source variable. The first operand of the intrinsic must be an address of some; kind. A DIExpression attached to the intrinsic refines this address to produce a; concrete location for the source variable. A ``llvm.dbg.value`` intrinsic describes the direct value of a source variable.; The first operand of the intrinsic may be a direct or indirect value. A; DIExpression attached to the intrinsic refines the first operand to produce a; direct value. For example, if the first operand is an indirect value, it may be; necessary to insert ``DW_OP_deref`` into the DIExpression in order to produce a; valid debug intrinsic. .. note::. A DIExpression is interpreted in the same way regardless of which kind of; debug intrinsic it's attached to. .. code-block:: text. !0 = !DIExpression(DW_OP_deref); !1 = !DIExpression(DW_OP_plus_uconst, 3); !1 = !DIExpression(DW_OP_constu, 3, DW_OP_plus); !2 = !DIExpression(DW_OP_bit_piece, 3, 7); !3 = !DIExpression(DW_OP_deref, DW_OP_constu, 3, DW_OP_plus, DW_OP_LLVM_fragment, 3, 7); !4 = !DIExpression(DW_OP_constu, 2, DW_OP_swap, DW_OP_xderef); !5 = !DIExpression(DW_OP_constu, 42, DW_OP_stack_value). DIAssignID; """""""""""""""""""""""". ``DIAssignID`` nodes have no operands and are always distinct. They are used to; lin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:268212,variab,variable,268212,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"""!!x""). Note that; unary operators can't have ambiguous parses like binary operators can,; so there is no need for precedence information. The problem with this function, is that we need to call ParseUnary from; somewhere. To do this, we change previous callers of ParsePrimary to; call ParseUnary instead:. .. code-block:: c++. /// binoprhs; /// ::= ('+' unary)*; static std::unique_ptr<ExprAST> ParseBinOpRHS(int ExprPrec,; std::unique_ptr<ExprAST> LHS) {; ...; // Parse the unary expression after the binary operator.; auto RHS = ParseUnary();; if (!RHS); return nullptr;; ...; }; /// expression; /// ::= unary binoprhs; ///; static std::unique_ptr<ExprAST> ParseExpression() {; auto LHS = ParseUnary();; if (!LHS); return nullptr;. return ParseBinOpRHS(0, std::move(LHS));; }. With these two simple changes, we are now able to parse unary operators; and build the AST for them. Next up, we need to add parser support for; prototypes, to parse the unary operator prototype. We extend the binary; operator code above with:. .. code-block:: c++. /// prototype; /// ::= id '(' id* ')'; /// ::= binary LETTER number? (id, id); /// ::= unary LETTER (id); static std::unique_ptr<PrototypeAST> ParsePrototype() {; std::string FnName;. unsigned Kind = 0; // 0 = identifier, 1 = unary, 2 = binary.; unsigned BinaryPrecedence = 30;. switch (CurTok) {; default:; return LogErrorP(""Expected function name in prototype"");; case tok_identifier:; FnName = IdentifierStr;; Kind = 0;; getNextToken();; break;; case tok_unary:; getNextToken();; if (!isascii(CurTok)); return LogErrorP(""Expected unary operator"");; FnName = ""unary"";; FnName += (char)CurTok;; Kind = 1;; getNextToken();; break;; case tok_binary:; ... As with binary operators, we name unary operators with a name that; includes the operator character. This assists us at code generation; time. Speaking of, the final piece we need to add is codegen support for; unary operators. It looks like this:. .. code-block:: c++. Value *UnaryExprAST::codegen()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:12908,extend,extend,12908,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['extend'],['extend']
Modifiability,"""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}""); if(NOT EXISTS ""${PROJ_DIR}"" OR NOT IS_DIRECTORY ""${PROJ_DIR}""); message(FATAL_ERROR ""LLVM_ENABLE_PROJECTS requests ${proj} but directory not found: ${PROJ_DIR}""); endif(); if( LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR STREQUAL """" ); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """" FORCE); else(); set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../${proj}"" CACHE PATH """"); endif(); elseif (""${proj}"" IN_LIST LLVM_EXTERNAL_PROJECTS); message(STATUS ""${proj} project is enabled""); set(SHOULD_ENABLE_PROJECT TRUE); else(); message(STATUS ""${proj} project is disabled""); set(SHOULD_ENABLE_PROJECT FALSE); endif(); # Force `LLVM_TOOL_${upper_proj}_BUILD` variables to have values that; # corresponds with `LLVM_ENABLE_PROJECTS`. This prevents the user setting; # `LLVM_TOOL_${upper_proj}_BUILD` variables externally. At some point; # we should deprecate allowing users to set these variables by turning them; # into normal CMake variables rather than cache variables.; set(LLVM_TOOL_${upper_proj}_BUILD; ${SHOULD_ENABLE_PROJECT}; CACHE; BOOL ""Whether to build ${upper_proj} as part of LLVM"" FORCE; ); endforeach(); endif(); unset(SHOULD_ENABLE_PROJECT). # Build llvm with ccache if the package is present; set(LLVM_CCACHE_BUILD OFF CACHE BOOL ""Set to ON for a ccache enabled build""); if(LLVM_CCACHE_BUILD); find_program(CCACHE_PROGRAM ccache); if(CCACHE_PROGRAM); set(LLVM_CCACHE_MAXSIZE """" CACHE STRING ""Size of ccache""); set(LLVM_CCACHE_DIR """" CACHE STRING ""Directory to keep ccached data""); set(LLVM_CCACHE_PARAMS ""CCACHE_CPP2=yes CCACHE_HASHDIR=yes""; CACHE STRING ""Parameters to pass through to ccache""). if(NOT CMAKE_SYSTEM_NAME MATCHES ""Windows""); set(CCACHE_PROGRAM ""${LLVM_CCACHE_PARAMS} ${CCACHE_PROGRAM}""); if (LLVM_CCACHE_MAXSIZE); set(CCACHE_PROGRAM ""CCACHE_MAXSIZE=${LLVM_CCACHE_MAXSIZE} ${CCACHE_PROGRAM}""); endif(); if (LLVM_CCACHE_DIR); set(CCACHE_PROGRAM ""CCACHE_DIR=${LLVM_C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:10121,variab,variables,10121,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,3,['variab'],['variables']
Modifiability,""", which is the entry point; into an executable program. Matcher<FunctionDecl>isNoReturn; Matches FunctionDecls that have a noreturn attribute. Given; void nope();; [[noreturn]] void a();; __attribute__((noreturn)) void b();; struct c { [[noreturn]] c(); };; functionDecl(isNoReturn()); matches all of those except; void nope();. Matcher<FunctionDecl>isNoThrow; Matches functions that have a non-throwing exception specification. Given:; void f();; void g() noexcept;; void h() throw();; void i() throw(int);; void j() noexcept(false);; functionDecl(isNoThrow()) and functionProtoType(isNoThrow()); match the declarations of g, and h, but not f, i or j. Matcher<FunctionDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<FunctionDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<FunctionDecl>isVariadic; Matches if a function declaration is variadic. Example matches f, but not g or h. The function i will not match, even when; compiled in C mode.; void f(...);; void g(int);; t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:94447,variab,variable,94447,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"""--cmakedir""; ""--build-mode""; ""--version""); execute_process(; COMMAND ${CONFIG_COMMAND}; RESULT_VARIABLE HAD_ERROR; OUTPUT_VARIABLE CONFIG_OUTPUT; ); if(NOT HAD_ERROR); string(REGEX REPLACE; ""[ \t]*[\r\n]+[ \t]*"" "";""; CONFIG_OUTPUT ${CONFIG_OUTPUT}); else(); string(REPLACE "";"" "" "" CONFIG_COMMAND_STR ""${CONFIG_COMMAND}""); message(STATUS ""${CONFIG_COMMAND_STR}""); message(FATAL_ERROR ""llvm-config failed with status ${HAD_ERROR}""); endif(); else(); message(FATAL_ERROR ""llvm-config not found -- ${LLVM_CONFIG}""); endif(). list(GET CONFIG_OUTPUT 0 ENABLE_ASSERTIONS); list(GET CONFIG_OUTPUT 1 TOOLS_BINARY_DIR); list(GET CONFIG_OUTPUT 2 LIBRARY_DIR); list(GET CONFIG_OUTPUT 3 INCLUDE_DIR); list(GET CONFIG_OUTPUT 4 LLVM_OBJ_ROOT); list(GET CONFIG_OUTPUT 5 LLVM_CONFIG_CMAKE_PATH); list(GET CONFIG_OUTPUT 6 LLVM_BUILD_MODE); list(GET CONFIG_OUTPUT 7 LLVM_VERSION). message(STATUS ""External llvm built in ${LLVM_BUILD_MODE} mode.""). if(NOT MSVC_IDE); set(LLVM_ENABLE_ASSERTIONS ${ENABLE_ASSERTIONS}; CACHE BOOL ""Enable assertions""); # Assertions should follow llvm-config's.; mark_as_advanced(LLVM_ENABLE_ASSERTIONS); endif(). set(LLVM_TOOLS_BINARY_DIR ${TOOLS_BINARY_DIR} CACHE PATH ""Path to llvm/bin""); set(LLVM_LIBRARY_DIR ${LIBRARY_DIR} CACHE PATH ""Path to llvm/lib""); set(LLVM_MAIN_INCLUDE_DIR ${INCLUDE_DIR} CACHE PATH ""Path to llvm/include""); set(LLVM_BINARY_DIR ${LLVM_OBJ_ROOT} CACHE PATH ""Path to LLVM build tree""). set(LLVM_DIR ""${LLVM_BINARY_DIR}""). # Normalize LLVM_CMAKE_PATH. --cmakedir might contain backslashes.; # CMake assumes slashes as PATH.; file(TO_CMAKE_PATH ${LLVM_CONFIG_CMAKE_PATH} LLVM_CMAKE_PATH). find_program(LLVM_TABLEGEN_EXE ""llvm-tblgen"" ${LLVM_TOOLS_BINARY_DIR}; NO_DEFAULT_PATH). set(LLVMCONFIG_FILE ""${LLVM_CMAKE_PATH}/LLVMConfig.cmake""); if(EXISTS ${LLVMCONFIG_FILE}); list(APPEND CMAKE_MODULE_PATH ""${LLVM_CMAKE_PATH}""); include(${LLVMCONFIG_FILE}); else(); message(FATAL_ERROR ""Not found: ${LLVMCONFIG_FILE}""); endif(); # We already FORCE-d the CACHE value to OFF",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:13878,config,config,13878,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['config'],['config']
Modifiability,""". This intrinsic is lowered to code which is intended to cause an execution trap,; embedding the argument into encoding of that trap somehow to discriminate; crashes if possible. Equivalent to ``@llvm.trap`` for targets that do not support this behaviour. '``llvm.stackprotector``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackprotector(ptr <guard>, ptr <slot>). Overview:; """""""""""""""""". The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it; onto the stack at ``slot``. The stack slot is adjusted to ensure that it; is placed on the stack before local variables. Arguments:; """""""""""""""""""". The ``llvm.stackprotector`` intrinsic requires two pointer arguments.; The first argument is the value loaded from the stack guard; ``@__stack_chk_guard``. The second variable is an ``alloca`` that has; enough space to hold the value of the guard. Semantics:; """""""""""""""""""". This intrinsic causes the prologue/epilogue inserter to force the position of; the ``AllocaInst`` stack slot to be before local variables on the stack. This is; to ensure that if a local variable on the stack is overwritten, it will destroy; the value of the guard. When the function exits, the guard on the stack is; checked against the original guard by ``llvm.stackprotectorcheck``. If they are; different, then ``llvm.stackprotectorcheck`` causes the program to abort by; calling the ``__stack_chk_fail()`` function. '``llvm.stackguard``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stackguard(). Overview:; """""""""""""""""". The ``llvm.stackguard`` intrinsic returns the system stack guard value. It should not be generated by frontends, since it is only for internal usage.; The reason why we create this intrinsic is that we still support IR form Stack; Protector in FastISel. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". On some platforms, the value returned by this intrinsic remains unchanged; between loads in the same",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:930358,variab,variables,930358,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"""::. Triple T;. The proliferation of acronyms leads to hard-to-read code such as `this; <https://github.com/llvm/llvm-project/blob/0a8bc14ad7f3209fe702d18e250194cd90188596/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L7445>`_::. InnerLoopVectorizer LB(L, PSE, LI, DT, TLI, TTI, AC, ORE, VF.Width, IC,; &LVL, &CM);. Many other coding guidelines [LLDB]_ [Google]_ [WebKit]_ [Qt]_ [Rust]_ [Swift]_; [Python]_ require that variable names begin with a lower case letter in contrast; to class names which begin with a capital letter. This convention means that the; most readable variable name also requires the least thought::. Triple triple;. There is some agreement that the current rule is broken [LattnerAgree]_; [ArsenaultAgree]_ [RobinsonAgree]_ and that acronyms are an obstacle to reading; new code [MalyutinDistinguish]_ [CarruthAcronym]_ [PicusAcronym]_. There are; some opposing views [ParzyszekAcronym2]_ [RicciAcronyms]_. This work-in-progress proposal is to change the coding standard for variable; names to require that they start with a lower case letter. .. [*] In `some cases; <https://github.com/llvm/llvm-project/blob/8b72080d4d7b13072f371712eed333f987b7a18e/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp#L2727>`_; the type name *is* reused as a variable name, but this shadows the type name; and confuses many debuggers [DenisovCamelBack]_. Variable Names Coding Standard Options; ======================================. There are two main options for variable names that begin with a lower case; letter: ``camelBack`` and ``lower_case``. (These are also known by other names; but here we use the terminology from clang-tidy). ``camelBack`` is consistent with [WebKit]_, [Qt]_ and [Swift]_ while; ``lower_case`` is consistent with [LLDB]_, [Google]_, [Rust]_ and [Python]_. ``camelBack`` is already used for function names, which may be considered an; advantage [LattnerFunction]_ or a disadvantage [CarruthFunction]_. Approval for ``camelBack`` was expressed by [DenisovCamelBack]",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:2375,variab,variable,2375,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability,"""RooFit::Detail::MathFuncs::poissonEvaluate"", xName, mean));; }; ```. Here we can see that the name of the variable `x` (remember that ""x"" is a; member of RooPoisson) is retrieved and stored in the `xName` variable. Next,; there's an `if` condition that does an operation on `x` (may or may not round; it to the nearest integer, depending on the condition). The important part is where the `RooPoisson::addResult()` function helps add; the result of evaluating the Poisson function to the context (`ctx`). It uses; the `RooPoisson::buildCall()` method to construct a function call to the fully; qualified name of `MathFuncs::poissonEvaluate` (which now resides in the; `MathFuncs` file), with arguments `xName` and `mean`. Essentially, the `RooPoisson::translate()` function constructs a function call; to evaluate the Poisson function using 'x' and 'mean' variables, and adds the; result to the context. Helper Functions:. - `getResult()` helps lookup the result of a child node (the string that the; child node previously saved in a variable using the `addResult()` function). - `addResult()` It may include a function call, an expression, or something; more complicated. For a specific class, it will add whatever is represented on; the right-hand side to the result of that class, which can then be propagated; in the rest of the compute graph. \note For each `translate()` function, it is important to call `addResult()` since this is what enables the squashing to happen. **translate() Example 2:** Following is a code snippet from `RooGaussian.cxx`; *after* it has AD support. ``` {.cpp}; void RooGaussian::translate(RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const; {; ctx.addResult(this, ctx.buildCall(""RooFit::Detail::MathFuncs::gaussianEvaluate"", x, mean, sigma));; }; ```. Here we can see that the `RooGaussian::translate()` function constructs a; function call using the `buildCall()` method. It specifies the fully qualified; name of the `gaussianEvaluate` function (which i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:13482,variab,variable,13482,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['variab'],['variable']
Modifiability,"""[12345,123456]"" \; targetClass=""ClassB"" \; target=""m_x"" \; embed=""true"" \; include=""iostream,cstdlib"" \; code=""{m_x = onfile.m_a * onfile.m_b * onfile.m_c; }"" \. #pragma readraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }""; ```. - For REFLEX dictionaries:. ``` {.cpp}; <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; ```. The variables in the rules have the following meaning:. * sourceClass; - The field defines the on-disk class that is the input for the rule.; * source; - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version; - A list of versions of the source class that can be an input for this rule.; The list has to be enclosed in a square bracket and be a comma-separated; list of versions or version ranges. The version is an integer number, whereas; the version range is one of the following:; - ""a-b"": a and b are integers and the expression means all the numbers between; and including a and b; - ""-a"": a is an integer and the expression means all the version numbers smaller; than or equal to a; - ""a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:79406,variab,variables,79406,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variables']
Modifiability,"""c23"" labels to track known bugs with Clang's language; conformance.; C89 implementation status; Clang implements all of the ISO 9899:1990 (C89) standard.; You can use Clang in C89 mode with the -std=c89 or -std=c90 options.; C99 implementation status; Clang implements a significant portion of the ISO 9899:1999 (C99) standard, but the status of individual proposals is still under investigation.; Note, the list of C99 features comes from the C99 committee draft. Not all C99 documents are publicly available, so the documents referenced in this section may be inaccurate, unknown, or not linked. You can use Clang in C99 mode with the -std=c99 option. List of features and minimum Clang version with support. Language Feature; C99 Proposal; Available in Clang?. restricted character set support via digraphs and <iso646.h>; Unknown; Unknown. more precise aliasing rules via effective type; Unknown; Unknown. restricted pointers; N448; Unknown. variable length arrays; N683; Yes. flexible array members; Unknown; Yes. static and type qualifiers in parameter array declarators; Unknown; Yes. more precise aliasing rules via effective type; Unknown; Unknown. complex and imaginary support in <complex.h>. N620; Unknown. N638; Unknown. N657; Unknown. N694; Unknown. N809; Unknown. type-generic math macros in <tgmath.h>; N693; Yes. the long long int type; N601; Yes. increase minimum translation limits; N590; Unknown. additional floating-point characteristics in <float.h>; Unknown; Unknown. remove implicit int. N635; Yes. N692; Yes. N722; Yes. reliable integer division; N617; Yes. universal character names (\u and \U); Unknown; Yes. extended identifiers; N717; Unknown. hexadecimal floating-point constants; N308. Yes. compound literals; N716; Yes. designated initializers; N494; Yes. // comments; N644; Yes. extended integer types and library functions in <inttypes.h> and <stdint.h>; Unknown. Yes. remove implicit function declaration; N636; Yes. preprocessor arithmetic done in intmax_t/uintma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:1719,flexible,flexible,1719,interpreter/llvm-project/clang/www/c_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html,1,['flexible'],['flexible']
Modifiability,"""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); ```. The first parameter is the branch name. The second parameter is the; address from which to read the value. The third parameter is the leaf; list with the name and type of each leaf. In this example, each branch; has only one leaf. In the box below, the branch is named `px` and has; one floating point type leaf also called `px`. ``` {.cpp}; t1.Branch(""px"",&px,""px/F"");; ```. #### Filling the Tree. First we find some random values for the variables. We assign `px` and; `py` a Gaussian with mean = 0 and sigma = 1 by calling; `gRandom->Rannor(px,py)`, and calculate` pz`. Then we call the; `TTree::Fill()` method. The call `t1.Fill()` fills all branches in the; tree because we have already organized the tree into branches and told; each branch where to get the value from. After this script is executed; we have a ROOT file called `tree1.root` with a tree called `t1`. There; is a possibility to fill branches one by one using the method; `TBranch::Fill()`. In this case you do not need to call `TTree::Fill()`; method. The entries can be set by `TTree::SetEntries(Double_t n)`.; Calling this method makes sense only if the number of existing entries; is null. ### Viewing the Tree. ![The tree1.root file and its tree in the browser and a leaf histogram](pictures/030000FC.png). In the right panel of the ROOT object browse are the branches: `ev`,; `px`, `py`, `pz`, and `random`. Note that these are shown as leaves; bec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:36580,variab,variables,36580,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"# A Little C++; \index{C++}. This chapter introduces you to some useful insights into C++, to allow; you to use some of the most advanced features in ROOT. It is in no case a; full course in C++. ## Classes, Methods and Constructors. C++ extends C with the notion of a class. If you're used to structures; in C, a class is a `struct` that is a group of related variables,; which is extended with functions and routines specific to this; structure (class). What is the interest? Consider a `struct` that is defined this way:. ``` {.cpp}; struct Line {; float x1;; float y1;; float x2;; float y2;; }; ```. This structure represents a line to be drawn in a graphical window.; `(x1,y1)` are the coordinates of the first point, `(x2,y2)` the; coordinates of the second point. In the standard C, if you want to; draw effectively such a line, you first have to define a structure and; initialize the points (you can try this):. ``` {.cpp}; Line firstline;; firstline.x1 = 0.2;; firstline.y1 = 0.2;; firstline.x2 = 0.8;; firstline.y2 = 0.9;; ```. This defines a line going from the point `(0.2,0.2)` to the point; `(0.8,0.9)`. To draw this line, you will have to write a function, say; `LineDraw(Line l)` and call it with your object as argument:. ``` {.cpp}; LineDraw(firstline);; ```. In C++, we would not do that. We would instead define a class like this:. ``` {.cpp}; class TLine {; Double_t x1;; Double_t y1;; Double_t x2;; Double_t y2;; TLine(int x1, int y1, int x2, int y2);; void Draw();; }; ```. Here we added two functions, that we will call methods or member; functions, to the **`TLine`** class. The first method is used for; initializing the line objects we would build. It is called a; constructor. The second one is the `Draw` method itself. Therefore, to; build and draw a line, we have to do:. ``` {.cpp}; TLine l(0.2,0.2,0.8,0.9);; l.Draw();; ```. The first line builds the object `l` by calling its constructor. The; second line calls the **`TLine`**`::Draw()` method of this object. You; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:238,extend,extends,238,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,3,"['extend', 'variab']","['extended', 'extends', 'variables']"
Modifiability,"# Appendix A: Install and Build ROOT; \index{install ROOT}. ## License. ROOT is made available under the LGPL v2.1 license. For full details see; the file LICENSE in the ROOT distribution. ## Installing ROOT. To install ROOT you will need to go to the ROOT website at:; <https://root.cern/install/>. You have a choice to download the binaries or the source. The source is; quicker to transfer since it is only 31 MB, but you will need to compile; and link it. The binaries range from 50 MB to 100 MB depending on the; target platform. ## Choosing a Version. The ROOT developers follow the principle of ""release early and release; often"", however a very large portion of a user base requires a stable; product therefore generally three versions of the system is available; for download - new, old and pro:. - The *new* version evolves quickly, with weekly or bi-weekly; releases. Use this to get access to the latest and greatest, but it; may not be stable. By trying out the new version you can help us; converge quickly to a stable version that can then become the new; pro version. If you are a new user we would advice you to try the; new version. - The *pro* (production) version is a version we feel comfortable with; to exposing to a large audience for serious work. The change rate of; this version is much lower than for the new version, it is about 3; to 6 months. - The *old* version is the previous pro version that people might need; for some time before switching the new pro version. The old change; rate is the same as for pro. ## Installing Precompiled Binaries. The binaries are available for downloading from; <https://root.cern/install/>. Once downloaded; you need to unzip and de-tar the file. For example, if you have; downloaded ROOT v5.30 for Linux-SLC5:. ``` {.cpp}; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; ```. This will create the directory root. Before getting started read the; file README/README. Also, read the Intr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:826,evolve,evolves,826,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['evolve'],['evolves']
Modifiability,"# C++ Modules in ROOT. Technology Overview. *Vassil Vassilev, Oksana Shadura, Yuka Takahashi and Raphael Isemann*. ## Overview. ROOT has several features which interact with libraries and require implicit; header inclusion. This can be triggered by reading or writing data on disk,; or user actions at the prompt. Often, the headers are immutable and reparsing is; redundant. C++ Modules are designed to minimize the reparsing of the same; header content by providing an efficient on-disk representation of C++ Code. The ROOT v6.16 release came with a preview of the module technology;; dedicated binaries have been built and can be reproduced by passing; `-Druntime_cxxmodules=On` as configure flag. The goals of this technology are:; * Gain feedback from early adoption -- the technology is being long anticipated; by some of the users of ROOT. It improves correctness of ROOT and improves; performance when carefully adopted.; * Study performance bottlenecks -- the feature is designed with performance; considerations in mind. In this document we describe the current performance; bottlenecks and trade-offs.; * Understand if the gradual migration policy is sufficient -- C++ Modules in; ROOT support gradual migration. In particular, ROOT can enable C++ Modules for; itself and still run in legacy mode for the third-party code (generating; rootmap files and other scaffolding). C++ Modules are here and we would like to give a brief introduction of how the; feature works, what are its pros and cons, what's the current state of the; implementation and how third-party code can use it. Read more [[1]]. C++ Modules in ROOT are default since v6.20 (Unix) and v6.22 (OSX). ## Design Goals. * Coherence with standard C++ -- C++ Modules TS is advancing and will be; likely part the upcoming C++20 standard;; * Performance -- provide performance that is competitive to ROOT with PCH and; advance further the implementation of the C++ Modules in clang to optimize; memory footprint and execution time;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:685,config,configure,685,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['config'],['configure']
Modifiability,"# Collection Classes. Collections are a key feature of the ROOT system. Many, if not most, of; the applications you write will use collections. If you have used; parameterized C++ collections or polymorphic collections before, some of; this material will be review. However, much of this chapter covers; aspects of collections specific to the ROOT system. When you have read; this chapter, you will know. - How to create instances of collections. - The difference between lists, arrays, hash tables, maps, etc. - How to add and remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:162,parameteriz,parameterized,162,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,2,"['parameteriz', 'polymorphi']","['parameterized', 'polymorphic']"
Modifiability,"# Conditionally update predicate state.; addl (%rsi), %edi # Load and accumulate 32 bits of data.; shrxq %rax, %rdi, %rdi # Shift out all 32 bits loaded.; ```. Because on x86 the zero-extend is free, this can efficiently harden the loaded; value. ##### Hardening the address of the load. When hardening the loaded value is inapplicable, most often because the; instruction directly leaks information (like `cmp` or `jmpq`), we switch to; hardening the _address_ of the load instead of the loaded value. This avoids; increasing register pressure by unfolding the load or paying some other high; cost. To understand how this works in practice, we need to examine the exact; semantics of the x86 addressing modes which, in its fully general form, looks; like `(%base,%index,scale)offset`. Here `%base` and `%index` are 64-bit; registers that can potentially be any value, and may be attacker controlled,; and `scale` and `offset` are fixed immediate values. `scale` must be `1`, `2`,; `4`, or `8`, and `offset` can be any 32-bit sign extended value. The exact; computation performed to find the address is then: `%base + (scale * %index) +; offset` under 64-bit 2's complement modular arithmetic. One issue with this approach is that, after hardening, the `%base + (scale *; %index)` subexpression will compute a value near zero (`-1 + (scale * -1)`) and; then a large, positive `offset` will index into memory within the first two; gigabytes of address space. While these offsets are not attacker controlled,; the attacker could chose to attack a load which happens to have the desired; offset and then successfully read memory in that region. This significantly; raises the burden on the attacker and limits the scope of attack but does not; eliminate it. To fully close the attack we must work with the operating system; to preclude mapping memory in the low two gigabytes of address space. ###### 64-bit load checking instructions. We can use the following instruction sequences to check loads. We s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:28275,extend,extended,28275,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['extend'],['extended']
Modifiability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # CMakeLists.txt for the ROOT tutorials programs.; # Author: Pere Mato, 25/10/2010; cmake_minimum_required(VERSION 3.10 FATAL_ERROR). project(tutorials). # Sergey: make no sence while CMakeLists.txt file cannot be used separately from ROOT; # but variables like ROOT_asimage_FOUND used here and produced in ROOTConfig.cmake; find_package(ROOT REQUIRED). if(DEFINED ROOT_SOURCE_DIR) # Testing using the binary tree; set(ROOT_root_CMD root.exe); if(NOT MSVC) # Ignore environment on Windows; set(ROOT_environ PATH=${CMAKE_BINARY_DIR}/bin:$ENV{PATH}; ${ld_library_path}=${CMAKE_BINARY_DIR}/lib:$ENV{${ld_library_path}}; ROOTSYS=${CMAKE_BINARY_DIR}; PYTHONPATH=${CMAKE_BINARY_DIR}/lib:$ENV{PYTHONPATH}); else(); set(ROOT_environ ROOTSYS=${CMAKE_BINARY_DIR}; PYTHONPATH=${CMAKE_BINARY_DIR}/bin;$ENV{PYTHONPATH}); endif(); else() # testing using an installation; include(${ROOT_USE_FILE}); if(DEFINED ROOT_CONFIG_EXECUTABLE) #---If ROOT was built with the classic configure/make---; set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/../cmake/modules); include(RootMacros); set(ROOT_root_CMD root.exe); endif(); enable_testing(); endif(). # Set the environment for the tutorials, which is the eventual ROOT_environ; # plus some environment variables related to limiting the number of threads; # used by NumPy.; # See: https://stackoverflow.com/questions/30791550/limit-number-of-threads-in-numpy; set(TUTORIAL_ENV ${ROOT_environ} OMP_NUM_THREADS=1 OPENBLAS_NUM_THREADS=1 MKL_NUM_THREADS=1). #---Copy the CTestCustom.cmake file into the build directory--------; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/CTestCustom.cmake ${CMAKE_CURRENT_BINARY_DIR} COPYONLY). #---Provide a rootlogon.C file in the current build directory that; # will affect the way we run all tutorials.; # This overwrites ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:442,variab,variables,442,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,2,"['config', 'variab']","['configure', 'variables']"
Modifiability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT math/rtools package; # @author Pere Mato, CERN; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(Rtools; HEADERS; Math/RMinimizer.h; SOURCES; src/RMinimizer.cxx; DEPENDENCIES; Core; MathCore; RInterface; NO_CXXMODULE; ). target_include_directories(Rtools PRIVATE ${R_INCLUDE_DIRS}). file(COPY ""${CMAKE_SOURCE_DIR}/etc/plugins/ROOT@@Math@@Minimizer/P090_RMinimizer.C""; DESTINATION ""${CMAKE_BINARY_DIR}/etc/plugins/ROOT@@Math@@Minimizer/""); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/rtools/CMakeLists.txt:690,plugin,plugins,690,math/rtools/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/rtools/CMakeLists.txt,2,['plugin'],['plugins']
Modifiability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT math/unurun package; ############################################################################. #---Define package related variables-----------------------------------------------------------------. if(builtin_unuran). set(UNR_SRCDIR ${CMAKE_CURRENT_SOURCE_DIR}/src); set(UNR_VERSION ""1.8.0-root""); set(UNR_TARNAME ""unuran-${UNR_VERSION}""); set(UNR_TARGZFILE ${UNR_SRCDIR}/${UNR_TARNAME}.tar.gz); set(UNR_TARFILE ${UNR_SRCDIR}/${UNR_TARNAME}.tar); set(UNR_UNTARDIR ${CMAKE_CURRENT_BINARY_DIR}/${UNR_TARNAME}). #---Untar sources at configuration/generation time (needed for listing sources); if(NOT EXISTS ${UNR_UNTARDIR}); execute_process( COMMAND ${CMAKE_COMMAND} -E tar xzf ${UNR_TARGZFILE}; WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR} ); # This is necessary to replace the config.guess of unuran 1.8.0 as it does not allow to compile the ; # package on arm64.; execute_process( COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/config.guess_patch1 ${UNR_UNTARDIR}/autoconf/config.guess; WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR} ); endif(). if(WIN32); configure_file(${CMAKE_CURRENT_SOURCE_DIR}/config.h.win.in ${UNR_UNTARDIR}/config.h); else(); #---Define special compiler settings for unurun-----------------------------------------------------; set(UNR_CC ${CMAKE_C_COMPILER}); if(ROOT_ARCHITECTURE MATCHES hpuxia64acc); set(UNR_CC ""${UNR_CC} +DD64 -Ae""); elseif(ROOT_ARCHITECTURE MATCHES linuxppc64gcc); set(UNR_CC ""${UNR_CC} -m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664gcc); set(UNR_CFLAGS ""-m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxicc); set(UNR_CFLAGS ""-m32""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664icc); set(UNR_CFLAGS ""-m64""); e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt:439,variab,variables,439,math/unuran/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt,3,"['config', 'variab']","['config', 'configuration', 'variables']"
Modifiability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. include(ExternalProject). # Clear cache variables set by find_package(PCRE); # to ensure that we use the builtin version; foreach(var PCRE_FOUND PCRE_VERSION PCRE_INCLUDE_DIR PCRE_PCRE_LIBRARY PCRE_LIBRARIES); unset(${var} CACHE); endforeach(). if(WIN32); if(CMAKE_GENERATOR MATCHES Ninja); if (CMAKE_BUILD_TYPE MATCHES Debug); set(PCRE_POSTFIX d); endif(); else(); if(winrtdebug); set(PCRE_POSTFIX $<$<CONFIG:Debug>:d>); set(pcre_config_kind ""Debug""); else(); set(pcre_config_kind ""Release""); endif(); set(pcre_config ""--config ${pcre_config_kind}""); endif(); endif(). set(PCRE_VERSION ""8.43"" CACHE INTERNAL """" FORCE); set(PCRE_LIBNAME ${CMAKE_STATIC_LIBRARY_PREFIX}pcre${PCRE_POSTFIX}${CMAKE_STATIC_LIBRARY_SUFFIX}). # build byproducts only needed by Ninja; if(""${CMAKE_GENERATOR}"" STREQUAL ""Ninja""); set(PCRE_BYPRODUCTS; <BINARY_DIR>/pcre.h; <BINARY_DIR>/${PCRE_LIBNAME}; ); endif(). ExternalProject_Add(PCRE; URL ${CMAKE_CURRENT_SOURCE_DIR}/pcre-${PCRE_VERSION}.tar.bz2; URL_HASH SHA256=91e762520003013834ac1adb4a938d53b22a216341c061b0cf05603b290faf6b. LOG_DOWNLOAD TRUE; LOG_CONFIGURE TRUE; LOG_BUILD TRUE; LOG_INSTALL TRUE. CMAKE_CACHE_ARGS; -DCMAKE_INSTALL_PREFIX:PATH=<INSTALL_DIR>; -DCMAKE_GENERATOR:STRING=${CMAKE_GENERATOR}; -DCMAKE_BUILD_TYPE:STRING=${CMAKE_BUILD_TYPE}; -DCMAKE_C_COMPILER:STRING=${CMAKE_C_COMPILER}; -DCMAKE_CXX_COMPILER:STRING=${CMAKE_CXX_COMPILER}; -DCMAKE_BUILD_SHARED_LIBS:BOOL=FALSE; -DCMAKE_POSITION_INDEPENDENT_CODE:BOOL=TRUE. BUILD_COMMAND; ${CMAKE_COMMAND} --build <BINARY_DIR> ${pcre_config} --target pcre. BUILD_BYPRODUCTS; ${PCRE_BYPRODUCTS}. INSTALL_COMMAND """"; TIMEOUT 600; ). ExternalProject_Get_Property(PCRE BINARY_DIR). set(PCRE_FOUND TRUE CACHE INTERNAL """" FORCE); set(PCRE_INCLUDE_DIR ""${BINARY_DIR}"" CACHE INTERNAL """" FORCE); if(WIN32); set(PCRE_PCRE_LIBR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/pcre/CMakeLists.txt:235,variab,variables,235,builtins/pcre/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/pcre/CMakeLists.txt,2,"['config', 'variab']","['config', 'variables']"
Modifiability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. include(ExternalProject); include(FindPackageHandleStandardArgs). # find_package(OpenSSL) may not have found it,; # clear parent scope variables set to NOTFOUND; foreach(suffix FOUND INCLUDE_DIR INCLUDE_DIRS CRYPTO_LIBRARY SSL_LIBRARY LIBRARY LIBRARIES VERSION); unset(OPENSSL_${suffix} PARENT_SCOPE); endforeach(). set(OPENSSL_VERSION ""3.0.13""); set(OPENSSL_URL ""http://lcgpackages.web.cern.ch/lcgpackages/tarFiles/sources/openssl-${OPENSSL_VERSION}.tar.gz""); set(OPENSSL_URLHASH ""SHA256=88525753f79d3bec27d2fa7c66aa0b92b3aa9498dafd93d7cfa4b3780cdae313""); set(OPENSSL_PREFIX ${CMAKE_CURRENT_BINARY_DIR}/OPENSSL-prefix). foreach(lib ssl crypto); string(TOUPPER ${lib} libupper); set(libname ${CMAKE_STATIC_LIBRARY_PREFIX}${lib}${CMAKE_STATIC_LIBRARY_SUFFIX}); set(OPENSSL_${libupper}_LIBRARY ${OPENSSL_PREFIX}/lib/${libname}); endforeach(). if(APPLE); if(${ROOT_ARCHITECTURE} MATCHES ""macosxarm64""); set(OPENSSL_CONFIG_CMD ./Configure darwin64-arm64-cc); else(); set(OPENSSL_CONFIG_CMD ./Configure darwin64-x86_64-cc); endif(); if (CMAKE_OSX_SYSROOT); set(OSX_SYSROOT ""-isysroot ${CMAKE_OSX_SYSROOT}""); endif(); else(); set(OPENSSL_CONFIG_CMD ./config); endif(). ExternalProject_Add(OPENSSL; URL ${OPENSSL_URL} URL_HASH ${OPENSSL_URLHASH}; CONFIGURE_COMMAND ${OPENSSL_CONFIG_CMD} no-shared --prefix=<INSTALL_DIR>; BUILD_COMMAND make -j1 CC=${CMAKE_C_COMPILER}\ -fPIC\ ${OSX_SYSROOT}; INSTALL_COMMAND make install_sw; BUILD_IN_SOURCE 1; LOG_BUILD 1 LOG_CONFIGURE 1 LOG_DOWNLOAD 1 LOG_INSTALL 1; BUILD_BYPRODUCTS ${OPENSSL_CRYPTO_LIBRARY} ${OPENSSL_SSL_LIBRARY}; TIMEOUT 600). set(OPENSSL_FOUND TRUE CACHE BOOL """" FORCE); set(OPENSSL_VERSION ${OPENSSL_VERSION} CACHE INTERNAL """" FORCE); set(OPENSSL_VERSION_STRING ""${OPENSSL_VERSION}"" CACHE INTERNAL """" FORCE); set(OPENSSL_PREFIX ${OPENSSL_PREFIX} CACHE INTE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/openssl/CMakeLists.txt:330,variab,variables,330,builtins/openssl/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/openssl/CMakeLists.txt,1,['variab'],['variables']
Modifiability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. set(CFITSIO_VERSION 4.4.0). set(CFITSIO_PREFIX ${CMAKE_BINARY_DIR}/CFITSIO-prefix); set(CFITSIO_LIBRARIES ${CFITSIO_PREFIX}/lib/${CMAKE_STATIC_LIBRARY_PREFIX}cfitsio${CMAKE_STATIC_LIBRARY_SUFFIX}). if(NOT WIN32); set(CFITSIO_C_FLAGS -fPIC); endif(). if(WIN32 AND NOT CMAKE_GENERATOR MATCHES Ninja); if(winrtdebug); set(CFITSIO_BUILD_COMMAND_FLAGS ""--config Debug""); else(); set(CFITSIO_BUILD_COMMAND_FLAGS ""--config Release""); endif(); endif(). ExternalProject_Add(; BUILTIN_CFITSIO; PREFIX ${CFITSIO_PREFIX}; URL https://heasarc.gsfc.nasa.gov/FTP/software/fitsio/c/cfitsio-${CFITSIO_VERSION}.tar.gz; URL_HASH SHA256=95900cf95ae760839e7cb9678a7b2fad0858d6ac12234f934bd1cb6bfc246ba9; CMAKE_ARGS -G ${CMAKE_GENERATOR}; -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}; -DCMAKE_C_FLAGS=${CFITSIO_C_FLAGS}; -DCMAKE_INSTALL_PREFIX=<INSTALL_DIR>; -DCMAKE_INSTALL_LIBDIR=<INSTALL_DIR>/lib; -DBUILD_SHARED_LIBS=OFF; -DUSE_CURL=OFF; -DZLIB_FOUND=TRUE; -DZLIB_INCLUDE_DIR=${ZLIB_INCLUDE_DIRS}; -DZLIB_LIBRARIES=$<TARGET_FILE:ZLIB::ZLIB>; # Skip the find_package(ZLIB REQUIRED), because we feed CFITSIO our own ZLIB flags.; PATCH_COMMAND git apply --ignore-space-change --ignore-whitespace; ${CMAKE_CURRENT_SOURCE_DIR}/cfitsio-no-find-zlib.diff; ${CMAKE_CURRENT_SOURCE_DIR}/no-fortran-wrapper.diff; BUILD_COMMAND ${CMAKE_COMMAND} --build . ${CFITSIO_BUILD_COMMAND_FLAGS}; INSTALL_COMMAND ${CMAKE_COMMAND} --build . ${CFITSIO_BUILD_COMMAND_FLAGS} --target install; LOG_DOWNLOAD 1 LOG_CONFIGURE 1 LOG_BUILD 1 LOG_INSTALL 1 LOG_OUTPUT_ON_FAILURE 1; BUILD_BYPRODUCTS ${CFITSIO_LIBRARIES}; TIMEOUT 600; ). add_dependencies(BUILTIN_CFITSIO ZLIB::ZLIB). add_dependencies(CFITSIO::CFITSIO BUILTIN_CFITSIO); set(CFITSIO_INCLUDE_DIRS ${CFITSIO_PREFIX}/include); file(MAKE_DIRECTORY ${CFITSIO_INCLUDE_DIRS}); set_target_properties(CFITSIO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/cfitsio/CMakeLists.txt:545,config,config,545,builtins/cfitsio/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/cfitsio/CMakeLists.txt,2,['config'],['config']
Modifiability,"# Copyright (C) 1995-2022, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # CMakeLists.txt for the ROOT test programs.; # This shows nicely how to compile and link applications; # using the ROOT libraries on all supported platforms.; #; # Author: Pere Mato, 25/10/2010; cmake_minimum_required(VERSION 3.10 FATAL_ERROR). project(test). # Sergey: make no sence while CMakeLists.txt file cannot be used separately from ROOT; # but variables like ROOT_asimage_FOUND used here and produced in ROOTConfig.cmake; find_package(ROOT REQUIRED). #---Copy the CTestCustom.cmake file into the build directory---------------------------------; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/CTestCustom.cmake ${CMAKE_CURRENT_BINARY_DIR} COPYONLY); enable_testing(). if(CMAKE_SYSTEM_NAME MATCHES Darwin); # To avoid to set ld_Library_path to locate the test libraries; set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -Wl,-rpath,@loader_path/.""); endif(). if(DEFINED ROOT_SOURCE_DIR); # Testing using the binary tree; set(ROOT_root_CMD ${ROOT_BINDIR}/root.exe); include_directories(${ROOT_SOURCE_DIR}/tutorials); else(); # Testing using an installation (assuming access to ROOT CMake modules); include_directories(${ROOT_INCLUDE_DIRS}); include_directories(${ROOT_INCLUDE_DIRS}/../tutorials); add_definitions(${ROOT_DEFINITIONS}); include(RootMacros); endif(). #---environment-------------------------------------------------------------------------------; ROOT_ADD_TEST(show-environment COMMAND ${CMAKE_COMMAND} -E environment). #---hworld------------------------------------------------------------------------------------; ROOT_EXECUTABLE(hworld hworld.cxx LIBRARIES Gpad). #---event-------------------------------------------------------------------------------------; ROOT_STANDARD_LIBRARY_PACKAGE(Event; NO_INSTALL_HEADERS; HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/Event.h; SOURCES Event.cxx L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt:549,variab,variables,549,test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt,1,['variab'],['variables']
Modifiability,"# Copyright (C) 1995-2023, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. #####################################################################################################################. # Details about integrating ROOT into CMake projects:; # https://root.cern/manual/integrate_root_into_my_cmake_project/. #####################################################################################################################. # CMakeLists.txt that creates a library with dictionary and a main program; cmake_minimum_required(VERSION 3.10 FATAL_ERROR). project(treeUsingCustomClass). #---Locate the ROOT package and defines a number of variables (e.g. ROOT_INCLUDE_DIRS); find_package(ROOT REQUIRED COMPONENTS Tree TreePlayer ROOTDataFrame). #---Include a CMake module which makes use of the previous variables and loads modules ; # with useful macros or functions such as ROOT_GENERATE_DICTIONARY; # For further details: https://root-forum.cern.ch/t/how-to-integrate-root-into-my-project-with-cmake/37175; include(${ROOT_USE_FILE}). #---Add include directory of ROOT to the build; include_directories(${CMAKE_SOURCE_DIR}). # CMake function provided by ROOT, used to generate the dictionary file, G__data2Tree.cxx; # See this link for further details:; # https://root.cern/manual/io_custom_classes/#using-cmake; ROOT_GENERATE_DICTIONARY(G__data2Tree data2Tree.hxx LINKDEF data2TreeLinkDef.hxx). #---Create a shared library from; # * the previously generated dictionary, G__data2Tree.cxx; # * the class implementation; add_library(data2TreeLib SHARED data2Tree.cxx G__data2Tree.cxx); target_link_libraries(data2TreeLib ${ROOT_LIBRARIES} ) ; add_dependencies(data2TreeLib G__data2Tree ). #--- This is needed on Windows in order to export the symbols and create the data2TreeLib.lib file; if(MSVC); set_target_properties(data2TreeLib PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS TRUE)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/dictionary/CMakeLists.txt:763,variab,variables,763,tutorials/tree/dictionary/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/dictionary/CMakeLists.txt,2,['variab'],['variables']
Modifiability,"# Data flow analysis: an informal introduction. ## Abstract. This document introduces data flow analysis in an informal way. The goal is to; give the reader an intuitive understanding of how it works, and show how it; applies to a range of refactoring and bug finding problems. Data flow analysis is a well-established technique; it is described in many; papers, books, and videos. If you would like a more formal, or a more thorough; explanation of the concepts mentioned in this document, please refer to the; following resources:. * [The Lattice article in Wikipedia](https://en.wikipedia.org/wiki/Lattice_\(order\)).; * Videos on the PacketPrep YouTube channel that introduce lattices and the; necessary background information:; [#20](https://www.youtube.com/watch?v=73j_FXBXGm8),; [#21](https://www.youtube.com/watch?v=b5sDjo9tfE8),; [#22](https://www.youtube.com/watch?v=saOG7Uooeho),; [#23](https://www.youtube.com/watch?v=3EAYX-wZH0g),; [#24](https://www.youtube.com/watch?v=KRkHwQtW6Cc),; [#25](https://www.youtube.com/watch?v=7Gwzsc4rAgw).; * [Introduction to Dataflow Analysis](https://www.youtube.com/watch?v=OROXJ9-wUQE); * [Introduction to abstract interpretation](http://www.cs.tau.ac.il/~msagiv/courses/asv/absint-1.pdf).; * [Introduction to symbolic execution](https://www.cs.umd.edu/~mwh/se-tutorial/symbolic-exec.pdf).; * [Static Program Analysis by Anders Møller and Michael I. Schwartzbach](https://cs.au.dk/~amoeller/spa/).; * [EXE: automatically generating inputs of death](https://css.csail.mit.edu/6.858/2020/readings/exe.pdf); (a paper that successfully applies symbolic execution to real-world; software). ## Data flow analysis. ### The purpose of data flow analysis. Data flow analysis is a static analysis technique that proves facts about a; program or its fragment. It can make conclusions about all paths through the; program, while taking control flow into account and scaling to large programs.; The basic idea is propagating facts about the program through the edges",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:240,refactor,refactoring,240,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactoring']
Modifiability,"# Debug Info Assignment Tracking. Assignment Tracking is an alternative technique for tracking variable location; debug info through optimisations in LLVM. It provides accurate variable; locations for assignments where a local variable (or a field of one) is the; LHS. In rare and complicated circumstances indirect assignments might be; optimized away without being tracked, but otherwise we make our best effort to; track all variable locations. The core idea is to track more information about source assignments in order; and preserve enough information to be able to defer decisions about whether to; use non-memory locations (register, constant) or memory locations until after; middle end optimisations have run. This is in opposition to using; `llvm.dbg.declare` and `llvm.dbg.value`, which is to make the decision for most; variables early on, which can result in suboptimal variable locations that may; be either incorrect or incomplete. A secondary goal of assignment tracking is to cause minimal additional work for; LLVM pass writers, and minimal disruption to LLVM in general. ## Status and usage. **Status**: Experimental work in progress. Enabling is strongly advised against; except for development and testing. **Enable in Clang**: `-Xclang -fexperimental-assignment-tracking`. That causes Clang to get LLVM to run the pass `declare-to-assign`. The pass; converts conventional debug intrinsics to assignment tracking metadata and sets; the module flag `debug-info-assignment-tracking` to the value `i1 true`. To; check whether assignment tracking is enabled for a module call; `isAssignmentTrackingEnabled(const Module &M)` (from `llvm/IR/DebugInfo.h`). ## Design and implementation. ### Assignment markers: `llvm.dbg.assign`. `llvm.dbg.value`, a conventional debug intrinsic, marks out a position in the; IR where a variable takes a particular value. Similarly, Assignment Tracking; marks out the position of assignments with a new intrinsic called; `llvm.dbg.assign`. In order to k",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:95,variab,variable,95,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,6,['variab'],"['variable', 'variables']"
Modifiability,"# Example analysis illustrating the use of rootdrawtree / TSimpleAnalysis.; # Run as:; # $ rootdrawtree tutorials/tree/simpleAnalysis.txt. file_output.root #the output file in which histograms are stored. # The next line has the name of the tree of the input data. It is; # optional if there is exactly one tree in the first input file.; ntuple #name of the input tree. # The lines of the next block correspond to .root input files that; # contain the tree. In this case we use only one input file.; tutorials/hsimple.root # this is the input file. # The next block is composed by lines that allow to configure the; # histograms. They have the following syntax:; # NAME = EXPRESSION if CUT; # which corresponds to chain->Draw(""EXPRESSION >> NAME"", ""CUT""); # i.e. it will create a histogram called NAME and store it in; # file_output.root.; # ""if CUT"" is optional; hpx=px if px<-3 #first histogram; hpxpy=px:py #second histogram. # End of the configuration file; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/simpleAnalysis.txt:601,config,configure,601,tutorials/tree/simpleAnalysis.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/simpleAnalysis.txt,2,['config'],"['configuration', 'configure']"
Modifiability,"# Getting Started. We begin by showing you how to use ROOT interactively. There are two; examples to click through and learn how to use the GUI. We continue by; using the command line, and explaining the coding conventions, global; variables and the environment setup. If you have not installed ROOT,; you can do so by following the instructions in the appendix, or on the; ROOT web site: <http://root.cern.ch/root/Availability.html>. ## Setting the Environment Variables. Before you can run ROOT you need to set the environment variable; `ROOTSYS` and change your path to include `root/bin` and library path; variables to include `root/lib`. Please note: the syntax is for; `bash`, if you are running `tcsh` you will have to use `setenv`; instead of `export`. 1. Define the variable \$ROOTSYS to the directory where you unpacked; the ROOT:. ```; $ export ROOTSYS=$HOME/root; ```. 2. Add ROOTSYS/bin to your PATH:. ```; $ export PATH=$PATH:$ROOTSYS/bin; ```. 3. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the; library path:. ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/this",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:232,variab,variables,232,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,4,['variab'],"['variable', 'variables']"
Modifiability,"# Graphs. A graph is a graphics object made of two arrays X and Y, holding the; x,y coordinates of `n` points. There are several graph classes; they; are **`TGraph`**, **`TGraphErrors`**, **`TGraphAsymmErrors`**, and; **`TMultiGraph`**. ## TGraph. The **`TGraph`** class supports the general case with non-equidistant; points, and the special case with equidistant points. Graphs are; created with the **`TGraph`** constructor. First, we define the arrays; of coordinates and then create the graph. The coordinates can be; arrays of doubles or floats. ``` {.cpp}; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0; i<n; i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; TGraph *gr1 = new TGraph (n, x, y);; ```. An alternative constructor takes only the number of points `n`. It is; expected that the coordinates will be set later. ``` {.cpp}; TGraph *gr2 = new TGraph(n);; ```. The default constructor can also be used. Further calls to; `SetPoint()` will extend the internal vectors. ``` {.cpp}; TGraph *gr3 = new TGraph();; ```. ### Graph Draw Options. The various drawing options for a graph are explained in; `TGraph::PaintGraph`. They are:. - ""`L`"" A simple poly-line between every points is drawn. - ""`F`"" A fill area is drawn. - ""`F1`"" Idem as ""`F`"" but fill area is no more repartee around; X=0 or Y=0. - ""`F2`"" draw a fill area poly line connecting the center of bins. - ""`A`"" Axis are drawn around the graph. - ""`C`"" A smooth curve is drawn. - ""`*`"" A star is plotted at each point. - ""`P`"" The current marker of the graph is plotted at each point. - ""`B`"" A bar chart is drawn at each point. - ""`[]` "" Only the end vertical/horizontal lines of the error bars; are drawn. This option only applies to the; **`TGraphAsymmErrors`**. - ""`1`"" `ylow` `=` `rwymin`. The options are not case sensitive and they can be concatenated in; most cases. Let us look at some examples. #### Continuous Line, Axis and Stars (AC\*). ![A graph drawn with axis, \* markers and continuous line (option AC\*)]",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:961,extend,extend,961,documentation/users-guide/Graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md,1,['extend'],['extend']
Modifiability,"# Histograms #. Histograms play a fundamental role in any type of physics analysis, not; only to visualise measurements but being a powerful form of data; reduction. ROOT offers many classes that represent histograms, all; inheriting from the `TH1` class. We will focus in this chapter on uni-; and bi- dimensional histograms the bin contents of which are represented by; floating point numbers [^4], the `TH1F` and `TH2F` classes respectively. ## Your First Histogram ##. Let's suppose you want to measure the counts of a Geiger detector located in; proximity of a radioactive source in a given time interval. This would; give you an idea of the activity of your source. The count distribution; in this case is a Poisson distribution. Let's see how operatively you; can fill and draw a histogram with the following example macro. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro5.C; ```. Which gives you the following plot (Figure [5.1](#f51)):. [f51]: figures/poisson.png ""f51""; <a name=""f51""></a>. ![The result of a counting (pseudo) experiment. Only bins corresponding; to integer values are filled given the discrete nature of the poissonian; distribution. \label{f51}][f51]. Using histograms is rather simple. The main differences with respect to; graphs that emerge from the example are:. - line *5*: The histograms have a name and a title right from the; start, no predefined number of entries but a number of bins and a; lower-upper range. - line *15*: An entry is stored in the histogram through the; `TH1F::Fill` method. - line *18* and *21*: The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:223,inherit,inheriting,223,documentation/primer/histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md,1,['inherit'],['inheriting']
Modifiability,"# If we don't need RTTI or EH, there's no reason to export anything; # from the hello plugin.; if( NOT LLVM_REQUIRES_RTTI ); if( NOT LLVM_REQUIRES_EH ); set(LLVM_EXPORTED_SYMBOL_FILE ${CMAKE_CURRENT_SOURCE_DIR}/Hello.exports); endif(); endif(). if(WIN32 OR CYGWIN OR ZOS); set(LLVM_LINK_COMPONENTS Core Support); endif(). add_llvm_library( LLVMHello MODULE BUILDTREE_ONLY; Hello.cpp. DEPENDS; intrinsics_gen; PLUGIN_TOOL; opt; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Hello/CMakeLists.txt:86,plugin,plugin,86,interpreter/llvm-project/llvm/lib/Transforms/Hello/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Hello/CMakeLists.txt,1,['plugin'],['plugin']
Modifiability,"# If we don't need RTTI or EH, there's no reason to export anything; # from the plugin.; if( NOT MSVC ) # MSVC mangles symbols differently, and; # PrintFunctionNames.export contains C++ symbols.; if( NOT LLVM_REQUIRES_RTTI ); if( NOT LLVM_REQUIRES_EH ); set(LLVM_EXPORTED_SYMBOL_FILE ${CMAKE_CURRENT_SOURCE_DIR}/PrintFunctionNames.exports); endif(); endif(); endif(). add_llvm_library(PrintFunctionNames MODULE PrintFunctionNames.cpp PLUGIN_TOOL clang). if(WIN32 OR CYGWIN); set(LLVM_LINK_COMPONENTS; Support; ); clang_target_link_libraries(PrintFunctionNames PRIVATE; clangAST; clangBasic; clangFrontend; ); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/PrintFunctionNames/CMakeLists.txt:80,plugin,plugin,80,interpreter/llvm-project/clang/examples/PrintFunctionNames/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/PrintFunctionNames/CMakeLists.txt,1,['plugin'],['plugin']
Modifiability,"# If we don't need RTTI or EH, there's no reason to export anything; # from the plugin.; if(NOT MSVC) # MSVC mangles symbols differently, and; # PrintLLVMFunctionNames.export contains C++ symbols.; if(NOT LLVM_REQUIRES_RTTI); if(NOT LLVM_REQUIRES_EH); set(LLVM_EXPORTED_SYMBOL_FILE ${CMAKE_CURRENT_SOURCE_DIR}/LLVMPrintFunctionNames.exports); endif(); endif(); endif(). add_llvm_library(LLVMPrintFunctionNames MODULE LLVMPrintFunctionNames.cpp PLUGIN_TOOL clang). if(WIN32 OR CYGWIN); set(LLVM_LINK_COMPONENTS; Support; ); clang_target_link_libraries(LLVMPrintFunctionNames PRIVATE; clangAST; clangBasic; clangFrontend; ); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/LLVMPrintFunctionNames/CMakeLists.txt:80,plugin,plugin,80,interpreter/llvm-project/clang/examples/LLVMPrintFunctionNames/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/LLVMPrintFunctionNames/CMakeLists.txt,1,['plugin'],['plugin']
Modifiability,"# Instruction referencing for debug info. This document explains how LLVM uses value tracking, or instruction; referencing, to determine variable locations for debug info in the code; generation stage of compilation. This content is aimed at those working on code; generation targets and optimisation passes. It may also be of interest to anyone; curious about low-level debug info handling. # Problem statement. At the end of compilation, LLVM must produce a DWARF location list (or similar); describing what register or stack location a variable can be found in, for each; instruction in that variable's lexical scope. We could track the virtual; register that the variable resides in through compilation, however this is; vulnerable to register optimisations during regalloc, and instruction; movements. # Solution: instruction referencing. Rather than identify the virtual register that a variable value resides in,; instead in instruction referencing mode, LLVM refers to the machine instruction; and operand position that the value is defined in. Consider the LLVM IR way of; referring to instruction values:. ```llvm; %2 = add i32 %0, %1; call void @llvm.dbg.value(metadata i32 %2,; ```. In LLVM IR, the IR Value is synonymous with the instruction that computes the; value, to the extent that in memory a Value is a pointer to the computing; instruction. Instruction referencing implements this relationship in the; codegen backend of LLVM, after instruction selection. Consider the X86 assembly; below and instruction referencing debug info, corresponding to the earlier; LLVM IR:. ```text; %2:gr32 = ADD32rr %0, %1, implicit-def $eflags, debug-instr-number 1; DBG_INSTR_REF 1, 0, !123, !456, debug-location !789; ```. While the function remains in SSA form, virtual register `%2` is sufficient to; identify the value computed by the instruction -- however the function; eventually leaves SSA form, and register optimisations will obscure which; register the desired value is in. Instead, a mo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:137,variab,variable,137,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,5,['variab'],['variable']
Modifiability,"# Jupyter Tools for TableGen. This folder contains notebooks relating to TableGen and a Jupyter kernel for; TableGen. ## Notebooks. [LLVM_TableGen.ipynb](LLVM_TableGen.ipynb) - A demo of the kernel's capabilities. [tablegen_tutorial_part_1.ipynb](tablegen_tutorial_part_1.ipynb) - A tutorial on the TableGen language. [sql_query_backend.ipynb](sql_query_backend.ipynb) - How to write a backend using; JSON output and Python. Notebooks can be viewed in browser on Github or downloaded and run locally. If; that is not possible, there are Markdown versions next to the notebook files. ## TableGen Kernel. To use the kernel, first install it into jupyter. If you have installed Jupyter into a virtual environment, adjust `python3` to; be the interpreter for that environment. This will ensure that tools run the; kernel in the correct context. ```shell; python3 -m tablegen_kernel.install; ```. If you are going to open the notebook in an IDE like Visual Studio Code,; you should restart it now so that it will find the newly installed kernel. Then run one of:. ```shell; jupyter notebook; # Then in the notebook interface, select 'LLVM TableGen' from the 'New' menu. # To run the example notebook in this folder.; jupyter notebook LLVM_TableGen.ipynb. # To use the kernel from the command line.; jupyter console --kernel tablegen; ```. Or open the notebook in a tool with built in Jupyter support. `llvm-tblgen` is expected to be either in the `PATH` or you can set; the environment variable `LLVM_TBLGEN_EXECUTABLE` to point to it directly. If you see an error like this:; ```shell; Cell In[8], line 2; // This is some tablegen; ^; SyntaxError: invalid syntax; ```. You are probably running the notebook using the iPython kernel. Make sure you; have selected the tablegen kernel. To run the kernel's doctests do:. ```shell; python3 tablegen_kernel/kernel.py; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/README.md:1481,variab,variable,1481,interpreter/llvm-project/llvm/utils/TableGen/jupyter/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/README.md,1,['variab'],['variable']
Modifiability,"# OS X 10.11 El Capitan has just been released. One of the new features, System; # Integrity Protection, prevents modifying the base OS install, even with sudo.; # This prevents LLVM developers on OS X from being able to easily install new; # system compilers. The feature can be disabled, but to make it easier for; # developers to work without disabling SIP, this file can generate an Xcode; # toolchain. Xcode toolchains are a mostly-undocumented feature that allows; # multiple copies of low level tools to be installed to different locations, and; # users can easily switch between them. # Setting an environment variable TOOLCHAINS to the toolchain's identifier will; # result in /usr/bin/<tool> or xcrun <tool> to find the tool in the toolchain. # To make this work with Xcode 7.1 and later you can install the toolchain this; # file generates anywhere on your system and set EXTERNAL_TOOLCHAINS_DIR to the; # path specified by $CMAKE_INSTALL_PREFIX/Toolchains. # This file generates a custom install-xcode-toolchain target which constructs; # and installs a toolchain with the identifier in the pattern:; # org.llvm.${PACKAGE_VERSION}. This toolchain can then be used to override the; # system compiler by setting TOOLCHAINS=org.llvm.${PACKAGE_VERSION} in the; # in the environment. # Example usage:; # cmake -G Ninja -DLLVM_CREATE_XCODE_TOOLCHAIN=On; # -DCMAKE_INSTALL_PREFIX=$PWD/install; # ninja install-xcode-toolchain; # export EXTERNAL_TOOLCHAINS_DIR=$PWD/install/Toolchains; # export TOOLCHAINS=org.llvm.3.8.0svn. # `xcrun -find clang` should return the installed clang, and `clang --version`; # should show 3.8.0svn. if(NOT APPLE); return(); endif(). option(LLVM_CREATE_XCODE_TOOLCHAIN ""Create a target to install LLVM into an Xcode toolchain"" Off). if(NOT LLVM_CREATE_XCODE_TOOLCHAIN); return(); endif(). # XCODE_VERSION is set by CMake when using the Xcode generator, otherwise we need; # to detect it manually here.; if(NOT XCODE_VERSION); execute_process(; COMMAND xcodebuild -vers",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt:618,variab,variable,618,interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,1,['variab'],['variable']
Modifiability,"# OpenStack API: nova. Example of a CernVM instantiation using `nova`:. ``` {.bash}; nova boot \; --flavor m1.xlarge \; --image cernvm-batch-node-2.6.0-4-1-x86_64 \; --key-name my_default_keyparir \; --user-data my_vaf_context.txt \; Name-Of-My-New-VM; ```. The `--user-data` option requires the context file we've just; downloaded. ### EC2 API: euca-tools. Example of a CernVM instantiation using `euca-tools`:. ``` {.bash}; euca-run-instances \; --instance-type m1.xlarge \; --key my_default_keyparir \; --user-data-file my_vaf_context.txt \; cernvm-batch-node-2.6.0-4-1-x86_64; ```. The `--user-data-file` option is the context file we've just downloaded. ### OpenNebula. An example VM definition follows:. ``` {.ruby}; CONTEXT=[; EC2_USER_DATA=""<base64_encoded_string>"",; ]; CPU=""6""; VCPU=""6""; DISK=[; IMAGE=""cernvm-batch-node-2.6.0-4-1-x86_64"",; TARGET=""vda"" ]; MEMORY=""16000""; NAME=""CernVM-VAF-Node""; NIC=[; NETWORK=""My-OpenNebula-VNet"" ]; OS=[; ARCH=""x86_64"" ]; ```. The `<base64_encoded_string>` requires the base64 version of the whole; downloaded context definition. You can obtain it by running:. cat my_vaf_context.txt | base64 | tr -d '\n'. Network security groups; -----------------------. In order to make the Virtual Analysis Facility work properly, the; firewall of your infrastructure must be configured to allow some; connections. Some ports need to allow ""external"" connections while other ports might; be safely opened to allow only connections from other nodes of the; Virtual Analysis Facility. ### Ports to open on all nodes. HTCondor ports; : Allow **TCP and UDP range 9600-9700** only between nodes of the Virtual; Analysis Facility. Only HTCondor and PoD communication is needed between the nodes. No HTCondor; ports need to be opened to the world. ### Additional ports to open on the front end node. HTTPS; : Allow **TCP 443** from all. SSH; : Allow **TCP 22** from all. No other ports need to be opened from the outside. Your definition of; *allow from all* might vary.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:6259,config,configured,6259,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['config'],['configured']
Modifiability,"# PROOF: Parallel Processing; \index{PROOF}; \index{parallel processing}. The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing; transparent analysis of large sets of ROOT files in parallel on remote; computer clusters or multi-core computers. The main design goals for the; PROOF system are:. *Transparency* : there should be as little difference as possible; between a local ROOT based analysis session and a remote parallel PROOF; session, both being interactive and giving the same results. *Scalability* : the basic architecture should not put any implicit; limitations on the number of computers that can be used in parallel. *Adaptability* : the system should be able to adapt itself to variations; in the remote environment (changing load on the cluster nodes, network; interruptions, etc.). Being an extension of the ROOT system, PROOF is designed to work on; objects in ROOT data stores, though, for the time being, it mainly; addresses the case of **`TTree`** based object collections. PROOF is primarily meant as an interactive alternative to batch systems; for Central Analysis Facilities and departmental workgroups (Tier-2's).; However, thanks to a multi-tier architecture allowing multiple levels of; masters, it can be easily adapted to wide range virtual clusters; distributed over geographically separated domains and heterogeneous; machines (GRIDs). While pure interactivity might not always be possible when performing a; complicated analysis on a very large data set, PROOF still tries to give; the user the interactive experience with something we call ""interactive; batch"". With ""interactive batch"" the user can start very long running; queries, disconnect the client and at any time, any location and from; any computer reconnect to the query to monitor its progress or retrieve; the results. This feature gives it a distinct advantage over purely; batch based solutions, that only provide an answer once all sub-jobs; have been finished. ![The Multi-tier struct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md:692,adapt,adapt,692,documentation/users-guide/PROOF.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PROOF.md,1,['adapt'],['adapt']
Modifiability,"# Preface {.unnumbered}. In late 1994, we decided to learn; and investigate Object Oriented programming and C++ to better judge; the suitability of these relatively new techniques for scientific; programming. We knew that there is no better way to learn a new; programming environment than to use it to write a program that can; solve a real problem. After a few weeks, we had our first; histogramming package in C++. A few weeks later we had a rewrite of; the same package using the, at that time, very new template features; of C++. Again, a few weeks later we had another rewrite of the package; without templates since we could only compile the version with; templates on one single platform using a specific compiler. Finally,; after about four months we had a histogramming package that was faster; and more efficient than the well-known FORTRAN based HBOOK; histogramming package. This gave us enough confidence in the new; technologies to decide to continue the development. Thus was born; ROOT. Since its first public release at the end of 1995, ROOT has; enjoyed an ever-increasing popularity. Currently it is being used in; all major High Energy and Nuclear Physics laboratories around the; world to monitor, to store and to analyse data. In the other sciences; as well as the medical and financial industries, many people are using; ROOT. We estimate the current user base to be around several thousand; people. In 1997, Eric Raymond analysed in his paper ""The Cathedral and; the Bazaar"" the development method that makes Linux such a success.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feelin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:445,rewrite,rewrite,445,documentation/users-guide/Preface.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md,2,['rewrite'],['rewrite']
Modifiability,"# Python Interface; \index{Python}. Python is a popular, open-source, dynamic programming language with an; interactive interpreter. Its interoperability with other programming; languages, both for extending Python as well as embedding it, is; excellent and many existing third-party applications and libraries have; therefore so-called ""Python bindings."" PyROOT provides Python bindings; for ROOT: it enables cross-calls from ROOT/Cling into Python and vice; versa, the intermingling of the two interpreters, and the transport of; user-level objects from one interpreter to the other. PyROOT enables; access from ROOT to any application or library that itself has Python; bindings, and it makes all ROOT functionality directly available from; the python interpreter. ## PyROOT Overview. The Python scripting language is widely used for scientific programming,; including high performance and distributed parallel code (see; <http://www.scipy.org>). It is the second most popular scripting; language (after Perl) and enjoys a wide-spread use as a ""glue language"":; practically every library and application these days comes with Python; bindings (and if not, they can be easily written or generated). `PyROOT`, a Python extension module, provides the bindings for the ROOT; class library in a generic way using the Cling dictionary. This way, it; allows the use of any ROOT classes from the Python interpreter, and thus; the ""glue-ing"" of ROOT libraries with any non-ROOT library or; applications that provide Python bindings. Further, `PyROOT` can be; loaded into the Cling interpreter to allow (as of now still rudimentary); access to Python classes. The best way to understand the benefits of; `PyROOT` is through a few examples. ### Glue-ing Applications. The `PyQt` library, see <http://www.riverbankcomputing.co.uk/pyqt>,; provides Python bindings for the Qt cross-platform GUI framework (; <http://www.trolltech.com>). With `PyROOT` and `PyQt`, adding ROOT; application layer code to a Qt GUI, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:198,extend,extending,198,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['extend'],['extending']
Modifiability,"# Since these do not specify a specific PLUGIN_TOOL (which could be clang or; # clang-tidy), we cannot compile this unless the platform supports plugins with; # undefined symbols, and cannot use it unless the user has opted for clang plugins).; if(CLANG_ENABLE_STATIC_ANALYZER AND CLANG_PLUGIN_SUPPORT AND LLVM_ENABLE_PLUGINS); add_subdirectory(SampleAnalyzer); add_subdirectory(CheckerDependencyHandling); add_subdirectory(CheckerOptionHandling); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/plugins/CMakeLists.txt:145,plugin,plugins,145,interpreter/llvm-project/clang/lib/Analysis/plugins/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/plugins/CMakeLists.txt,2,['plugin'],['plugins']
Modifiability,"# TODO: Set the install directory. include(ExternalProject). set(known_subdirs; ""libcxx""; ). foreach (dir ${known_subdirs}); if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${dir}/CMakeLists.txt); add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/${dir}); endif(); endforeach(). function(get_ext_project_build_command out_var target); if (CMAKE_GENERATOR MATCHES ""Make""); # Use special command for Makefiles to support parallelism.; set(${out_var} ""$(MAKE)"" ""${target}"" PARENT_SCOPE); else(); set(${out_var} ${CMAKE_COMMAND} --build . --target ${target}; --config $<CONFIG> PARENT_SCOPE); endif(); endfunction(). set(COMPILER_RT_SRC_ROOT ${LLVM_MAIN_SRC_DIR}/projects/compiler-rt); # Fallback to the external path, if the other one isn't available.; # This is the same behavior (try ""internal"", then check the LLVM_EXTERNAL_...; # variable) as in add_llvm_external_project; if(NOT EXISTS ${COMPILER_RT_SRC_ROOT}); # We don't want to set it if LLVM_EXTERNAL_COMPILER_RT_SOURCE_DIR is """"; if(LLVM_EXTERNAL_COMPILER_RT_SOURCE_DIR); set(COMPILER_RT_SRC_ROOT ${LLVM_EXTERNAL_COMPILER_RT_SOURCE_DIR}); endif(); endif(). if(LLVM_BUILD_EXTERNAL_COMPILER_RT AND EXISTS ${COMPILER_RT_SRC_ROOT}/). # Add compiler-rt as an external project.; set(COMPILER_RT_PREFIX ${CMAKE_BINARY_DIR}/projects/compiler-rt). set(STAMP_DIR ${CMAKE_CURRENT_BINARY_DIR}/compiler-rt-stamps/); set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/compiler-rt-bins/). add_custom_target(compiler-rt-clear; COMMAND ${CMAKE_COMMAND} -E remove_directory ${BINARY_DIR}; COMMAND ${CMAKE_COMMAND} -E remove_directory ${STAMP_DIR}; COMMENT ""Clobberring compiler-rt build and stamp directories""; ). # Find all variables that start with COMPILER_RT and populate a variable with; # them.; get_cmake_property(variableNames VARIABLES); foreach(variableName ${variableNames}); if(variableName MATCHES ""^COMPILER_RT""); string(REPLACE "";"" ""\;"" value ""${${variableName}}""); list(APPEND COMPILER_RT_PASSTHROUGH_VARIABLES; -D${variableName}=${value}); endif(); endforeach(). set(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt:543,config,config,543,interpreter/llvm-project/clang/runtime/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt,2,"['config', 'variab']","['config', 'variable']"
Modifiability,"# The C++ Interpreter Cling; \index{cling}. ROOT has a C++ interpreter called *cling* built in. It is used for the prompt, both C++ and; Python. It also serves as a source of information to store C++ objects, and; provides the back-end for ROOT's signal/slot and plug-in mechanisms. This chapter focuses on the parts of *cling* that you will encounter while; interacting with ROOT. ## The ROOT Prompt. Start up a ROOT session by typing `root` at the system prompt. ``` {.cpp}; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. Now we create a `TLine` object:. ``` {.cpp}; root [1] TLine l;; root [2] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; root [3] l.SetX1(10); root [4] l.SetY1(11); root [5] l.Print(); TLine X1=10.000000 Y1=11.000000 X2=0.000000 Y2=0.000000; root [6] .g l; .g l; ROOT_prompt_0 1 (address: NA) class TLine l, size = 72; root [7] l.GetX1();; root [8] l.GetX1(); (Double_t) 1.000000e+01; ```. Note some of the features of the ROOT prompt:; - Terminating with ‘`;`‘ is not required, see ""C++ Extensions To Ease; Scripting"" below.; - `Emacs` style command line editing.; - Raw interpreter commands start with a dot; `.g l` for instance shows the; interpreter information on the global called `l`.; - To show the result of an expression just do not type the trailing `;`. For the further examples we will ""abbreviate"" `root [0]` etc by `root []`. ``` {.cpp}; root [] .class TLine; ===========================================================================; class TLine; SIZE: 72 FILE: TLine.h LINE: 39; Base classes: --------------------------------------------------------; 0x20 public TAt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:263,plug-in,plug-in,263,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['plug-in'],['plug-in']
Modifiability,"# The configured file is not placed in the correct location; # until the tests are run as we need to copy it into; # a copy of the tests folder; configure_lit_site_cfg(; ""${CMAKE_CURRENT_SOURCE_DIR}/tests/lit.site.cfg.in""; ""${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg""; ). # Lit's test suite creates output files next to the sources which makes the; # source tree dirty. This is undesirable because we do out of source builds.; # To work around this the tests and the configuration file are copied into the; # build directory just before running them. The tests are not copied over at; # configure time (i.e. `file(COPY ...)`) because this could lead to stale; # tests being run.; add_custom_target(prepare-check-lit; COMMAND ${CMAKE_COMMAND} -E remove_directory ""${CMAKE_CURRENT_BINARY_DIR}/tests""; COMMAND ${CMAKE_COMMAND} -E copy_directory ""${CMAKE_CURRENT_SOURCE_DIR}/tests"" ""${CMAKE_CURRENT_BINARY_DIR}/tests""; COMMAND ${CMAKE_COMMAND} -E copy ""${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg"" ""${CMAKE_CURRENT_BINARY_DIR}/tests""; COMMENT ""Preparing lit tests""; ). # Add rules for lit's own test suite; add_lit_testsuite(check-lit ""Running lit's tests""; ${CMAKE_CURRENT_BINARY_DIR}; DEPENDS ""FileCheck"" ""not"" ""prepare-check-lit""; ). # For IDEs; set_target_properties(check-lit PROPERTIES FOLDER ""Tests""); set_target_properties(prepare-check-lit PROPERTIES FOLDER ""Tests""); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/CMakeLists.txt:6,config,configured,6,interpreter/llvm-project/llvm/utils/lit/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/CMakeLists.txt,3,['config'],"['configuration', 'configure', 'configured']"
Modifiability,"# This file will recurse into all subdirectories that contain CMakeLists.txt; # Setting variables that match the pattern LLVM_TOOL_{NAME}_BUILD to Off will; # prevent traversing into a directory.; #; # The only tools that need to be explicitly added are ones that have explicit; # ordering requirements. # Iterates all the subdirectories to create CMake options to enable/disable; # traversing each directory.; create_llvm_tool_options(). if(NOT LLVM_BUILD_LLVM_DYLIB AND NOT LLVM_BUILD_LLVM_C_DYLIB); set(LLVM_TOOL_LLVM_SHLIB_BUILD Off); endif(). if(NOT LLVM_USE_INTEL_JITEVENTS ); set(LLVM_TOOL_LLVM_JITLISTENER_BUILD Off); endif(). if(CYGWIN OR NOT LLVM_ENABLE_PIC); set(LLVM_TOOL_LTO_BUILD Off); endif(). if (LLVM_TOOL_LLVM_DRIVER_BUILD); add_llvm_tool(llvm-driver); endif(). # Add LTO, llvm-ar, llvm-config, and llvm-profdata before clang, ExternalProject; # requires targets specified in DEPENDS to exist before the call to; # ExternalProject_Add.; add_llvm_tool_subdirectory(lto); add_llvm_tool_subdirectory(gold); add_llvm_tool_subdirectory(llvm-ar); add_llvm_tool_subdirectory(llvm-config); add_llvm_tool_subdirectory(llvm-lto); add_llvm_tool_subdirectory(llvm-profdata). # Projects supported via LLVM_EXTERNAL_*_SOURCE_DIR need to be explicitly; # specified.; add_llvm_external_project(clang); add_llvm_external_project(lld); add_llvm_external_project(lldb); add_llvm_external_project(mlir); # Flang depends on mlir, so place it afterward; add_llvm_external_project(flang); add_llvm_external_project(bolt). # Automatically add remaining sub-directories containing a 'CMakeLists.txt'; # file as external projects.; add_llvm_implicit_projects(). add_llvm_external_project(polly). # Add subprojects specified using LLVM_EXTERNAL_PROJECTS; foreach(p ${LLVM_EXTERNAL_PROJECTS}); add_llvm_external_project(${p}); endforeach(p). set(LLVM_COMMON_DEPENDS ${LLVM_COMMON_DEPENDS} PARENT_SCOPE). if (LLVM_TOOL_LLVM_DRIVER_BUILD); # This is explicitly added at the end _after_ all tool projects so that i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/CMakeLists.txt:88,variab,variables,88,interpreter/llvm-project/llvm/tools/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/CMakeLists.txt,2,"['config', 'variab']","['config', 'variables']"
Modifiability,"# Threads. A thread is an independent flow of control that operates within the same; address space as other independent flows of controls within a process.; In most UNIX systems, thread and process characteristics are grouped; into a single entity called a process. Sometimes, threads are called; ""lightweight processes''. Note: This introduction is adapted from the AIX 4.3 Programmer's Manual. ## Threads and Processes. In traditional single-threaded process systems, a process has a set of; properties. In multi-threaded systems, these properties are divided; between processes and threads. ### Process Properties. A process in a multi-threaded system is the changeable entity. It must; be considered as an execution frame. It has all traditional process; attributes, such as:. - Process ID, process group ID, user ID, and group ID. - Environment. - Working directory. A process also provides a common address space and common system; resources:. - File descriptors. - Signal actions. - Shared libraries. - Inter-process communication tools (such as message queues, pipes,; semaphores, or shared memory). ### Thread Properties. A thread is the schedulable entity. It has only those properties that; are required to ensure its independent flow of control. These include; the following properties:. - Stack. - Scheduling properties (such as policy or priority). - Set of pending and blocked signals. - Some thread-specific data (TSD). An example of thread-specific data is the error indicator, `errno`. In; multi-threaded systems, `errno` is no longer a global variable, but; usually a subroutine returning a thread-specific `errno` value. Some; other systems may provide other implementations of `errno`. With respect; to ROOT, a thread specific data is for example the ***`gPad`*** pointer,; which is treated in a different way, whether it is accessed from any; thread or the main thread. Threads within a process must not be considered as a group of processes; (even though in Linux each thread re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:350,adapt,adapted,350,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['adapt'],['adapted']
Modifiability,"# Trees. ## Why Should You Use a Tree?. In the ""Input/Output"" chapter, we saw how objects can be saved in ROOT; files. In case you want to store large quantities of same-class objects,; ROOT has designed the **`TTree`** and **`TNtuple`** classes specifically; for that purpose. The **`TTree`** class is optimized to reduce disk; space and enhance access speed. A **`TNtuple`** is a **`TTree`** that is; limited to only hold floating-point numbers; a **`TTree`** on the other; hand can hold all kind of data, such as objects or arrays in addition to; all the simple types. When using a **`TTree`**, we fill its branch buffers with leaf data and; the buffers are written to disk when it is full. Branches, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:339,enhance,enhance,339,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['enhance'],['enhance']
Modifiability,"# Web-based display. In this chapter discussed how web-based display can be created in the ROOT. ## Basics. Idea of web displays is implementation of user interface, which can run remotely; or locally in the web-browsers, fully decoupled from the application code.; For the communication between application and browser websockets are used. ## Creating web-window. **`ROOT::RWebWindow`** class is represent window instance, which can be displayed in the browser. ```{.cpp}. auto win = ROOT::RWebWindow::Create();. // set HTML page which is showed when window displayed; win->SetDefaultPage(""file:page.html""); // set. // allow unlimitted user connections to the window (default only 1); win->SetConnLimit(0);. // configure predefined geometry; win->SetGeometry(300, 300);. ```. ## Communication. To receive data from the browser, data callback should be assigned.; Callback is invoked when data received from the client or when connection is established.; Normally lambda function is used:. ```{.cpp}. win->SetDataCallBack([](unsigned connid, const std::string &msg) {. printf(""Msg:%s from connection:%u\n"", msg.c_str(), connid);. });. ```. Here **connid** is unique identifier, which assign to each connection when it is established.; There are several predefined messages kinds: **""CONN_READY""** when new connection established and; **""CONN_CLOSED""** when connection is closed by client.; The connection identifier should be used when sending message to the client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:712,config,configure,712,documentation/users-guide/WebDisplay.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md,1,['config'],['configure']
Modifiability,"# into normal CMake variables rather than cache variables.; set(LLVM_TOOL_${upper_proj}_BUILD; ${SHOULD_ENABLE_PROJECT}; CACHE; BOOL ""Whether to build ${upper_proj} as part of LLVM"" FORCE; ); endforeach(); endif(); unset(SHOULD_ENABLE_PROJECT). # Build llvm with ccache if the package is present; set(LLVM_CCACHE_BUILD OFF CACHE BOOL ""Set to ON for a ccache enabled build""); if(LLVM_CCACHE_BUILD); find_program(CCACHE_PROGRAM ccache); if(CCACHE_PROGRAM); set(LLVM_CCACHE_MAXSIZE """" CACHE STRING ""Size of ccache""); set(LLVM_CCACHE_DIR """" CACHE STRING ""Directory to keep ccached data""); set(LLVM_CCACHE_PARAMS ""CCACHE_CPP2=yes CCACHE_HASHDIR=yes""; CACHE STRING ""Parameters to pass through to ccache""). if(NOT CMAKE_SYSTEM_NAME MATCHES ""Windows""); set(CCACHE_PROGRAM ""${LLVM_CCACHE_PARAMS} ${CCACHE_PROGRAM}""); if (LLVM_CCACHE_MAXSIZE); set(CCACHE_PROGRAM ""CCACHE_MAXSIZE=${LLVM_CCACHE_MAXSIZE} ${CCACHE_PROGRAM}""); endif(); if (LLVM_CCACHE_DIR); set(CCACHE_PROGRAM ""CCACHE_DIR=${LLVM_CCACHE_DIR} ${CCACHE_PROGRAM}""); endif(); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_PROGRAM}); else(); if(LLVM_CCACHE_MAXSIZE OR LLVM_CCACHE_DIR OR; NOT LLVM_CCACHE_PARAMS MATCHES ""CCACHE_CPP2=yes CCACHE_HASHDIR=yes""); message(FATAL_ERROR ""Ccache configuration through CMake is not supported on Windows. Please use environment variables.""); endif(); # RULE_LAUNCH_COMPILE should work with Ninja but currently has issues; # with cmd.exe and some MSVC tools other than cl.exe; set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); endif(); else(); message(FATAL_ERROR ""Unable to find the program ccache. Set LLVM_CCACHE_BUILD to OFF""); endif(); endif(). set(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS """" CACHE STRING; ""Optional arguments for the native tool used in CMake --build invocations for external projects.""); mark_as_advanced(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS). option(LLVM_DEPENDENCY_DEBUGGING ""Dependency debugging mode to verify correctly expres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:11393,config,configuration,11393,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"# llvm-exegesis. `llvm-exegesis` is a benchmarking tool that accepts or assembles a snippet and; can measure characteristics of that snippet by executing it while keeping track; of performance counters. ### Currently Supported Platforms. `llvm-exegesis` is quite platform-dependent and currently only supports a couple; platform configurations for benchmarking. The limitations are listed below.; Analysis mode in `llvm-exegesis` is supported on all platforms on which LLVM is. #### Currently Supported Operating Systems for Benchmarking. Currently, `llvm-exegesis` only supports benchmarking on Linux. This is mainly; due to a dependency on the Linux perf subsystem for reading performance; counters. The subprocess execution mode and memory annotations currently only supports; Linux due to a heavy reliance on many Linux specific syscalls/syscall; implementations. #### Currently Supported Architectures for Benchmarking. Currently, using `llvm-exegesis` for benchmarking is supported on the following; architectures:; * x86; * 64-bit only due to this being the only implemented calling convention; in `llvm-exegesis` currently.; * ARM; * AArch64 only; * MIPS; * PowerPC (PowerPC64LE only). Note that not benchmarking functionality is guaranteed to work on all platforms. Memory annotations are currently only supported on 64-bit X86. There is no; inherent limitations for porting memory annotations to other architectures, but; parts of the test harness are implemented as MCJITed assembly that is generated; in `./lib/X86/Target.cpp` that would need to be implemented on other architectures; to bring up support.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/README.md:329,config,configurations,329,interpreter/llvm-project/llvm/tools/llvm-exegesis/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/README.md,1,['config'],['configurations']
Modifiability,"# qtweb example. Demonstration how different ROOT web-based widgets can be embed into qt application. ## Compile on Linux. Create build directory and call:. cmake $ROOTSYS/tutorials/webgui/qtweb; make -j. ROOT should be compiled with configured `-Dqt5web=ON` or `-Dqt6web=ON`.; If both are present, one can use selector `-Dwithqt=5` or `-Dwithqt=6`; As a result, `qtweb` application should be created. ## Compile on Windows. Run x86 native tools shell from MS VC. Configure Qt5 pathes:. set PATH=%PATH%;C:\Qt5\5.15.2\msvc2019\bin. Compile ROOT with qt5web support in Release mode:. cd C:\; mkdir root; cd C:\root; cmake -G""Visual Studio 16 2019"" -A Win32 -Thost=x64 c:\git\root -Droot7=ON -DCMAKE_CXX_STANDARD=17 -Dwebgui=ON -Dqt5web=ON; cmake --build . --config Release -- /maxcpucount. Configure ROOT, create build directory and build qt5web tutorial:. call C:\root\bin\thisroot.bat; cd C:\; mkdir qt5web; cd C:\qt5web; cmake -G""Visual Studio 16 2019"" -A Win32 -Thost=x64 c:\root\tutorials\webgui\qtweb; cmake --build . --config Release -- /maxcpucount. As a result, `Release\qtweb.exe` executable should be created. ## Demo application. Application based on `QTabWidget` with four tabs - standard Qt widget,; TCanvas, RCanvas and geometry drawing. Both canvas variants include different histograms drawing. ## How to include RCanvas/TCanvas into other Qt-based project. Most easy way - just include `RCanvasWidget.h` and `RCanvasWidget.cpp` files; in the project and let compile, linking with ROOT basic libraries `root-config --libs` plus `-lROOTWebDisplay -lROOTGpadv7`.; `RCanvasWidget` is just `QWidget` which internally embed `RCanvas` drawing.; See `ExampleWidget.ui` file how to embed such custom widget in normal qt ui file. To let ROOT work inside Qt event loop, one should instantiate `TApplication` object and; regularly call `gSystem->ProcessEvents()` - see how it is done in `ExampleMain.cpp`. Author: Sergey Linev; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/qtweb/Readme.md:234,config,configured,234,tutorials/webgui/qtweb/Readme.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/qtweb/Readme.md,4,['config'],"['config', 'configured']"
Modifiability,"# rootreadspeed. `rootreadspeed` is a tool used to help identify bottlenecks in root analysis programs; by providing an idea of what throughput you can expect when reading ROOT files in; certain configurations. It does this by providing information about the number of bytes read from your files,; how long this takes, and the different throughputs in MB/s, both in total and per thread. ## Compressed vs Uncompressed Throughput:. Throughput speeds are provided as compressed and uncompressed - ROOT files are usually; saved in compressed format, so these will often differ. Compressed bytes is the total; number of bytes read from TFiles during the readspeed test (possibly including meta-data).; Uncompressed bytes is the number of bytes processed by reading the branch values in the TTree.; Throughput is calculated as the total number of bytes over the total runtime (including; decompression time) in the uncompressed and compressed cases. ## Interpreting results:. ### There are three possible scenarios when using rootreadspeed, namely:. - The 'Real Time' is significantly lower than your own analysis runtime.; This would imply your actual application code is dominating the runtime of your analysis,; ie. your analysis logic or framework is taking up the time.; The best way to decrease the runtime would be to optimize your code (or the framework's),; parallelize it onto multiple threads if possible (for example with; [RDataFrame](https://root.cern/doc/master/classROOT_1_1RDataFrame.html); and [EnableImplicitMT](https://root.cern/doc/master/namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f)); or switch to a machine with a more performant CPU.; - The 'Real Time' is significantly higher than 'CPU Time / number of threads'*.; If the real time is higher than the CPU time per core it implies the reading of data is the; bottleneck, as the CPU cores are wasting time waiting for data to arrive from your disk/drive; or network connection in order to decompress it.; The best way to dec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/README.md:195,config,configurations,195,tree/readspeed/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/README.md,1,['config'],['configurations']
Modifiability,"## 2D Graphics Libraries. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## PyROOT. ### Typesafe `TTree::SetBranchAddress()` for array inputs. If you call `TTree::SetBranchAddress` with NumPy array or `array.array` inputs, ROOT will now check if the array type matches with the column type.; If it doesn't, `SetBranchAddress()` will return a negative status code and print an error.; Take for example this code snippet:; ```python; arr = array.array(typecode, ""d""); status = t.SetBranchAddress(""name"", arr); print(""Status = %s"" % (status, )); ```; If the branch type is also `double` (like the type of the array indicated by `""d""`), the call to `SetBranchAddress()` would succeed with status code zero.; If the type doesn't match, you now get a clear error instead of garbage values.; ```txt; Error in <TTree::SetBranchAddress>: The pointer type given ""Double_t"" (8) does not correspond to the type needed ""Float_t"" (5) by the branch: a; Status = -2; ```. ### Deprecation of `TPython::Eval()`. The `TPython::Eval()` method is deprecated and scheduled for removal in ROOT 6.36.; Its implementation was fragile, and the same functionality can be achieved with `TPython::Exec()`, using a C++ variable that is known to the ROOT interpreter for crossing over from Python to C++. Example:; ```c++; // Before, with TPython::Eval(); std::string stringVal = static_cast<const char*>(TPython::Eval(""'done'""));; std::cout << stringVal << std::endl;. // Now, with TPython::Exec(). You can set `_anyresult` to whatever std::any you want.; // It will be swapped into the return variable in the end. std::any result;; TPython::Exec(""_anyresult = ROOT.std.make_any['std::string']('done')"", &result);; std::cout << std::any_cast<std::string>(result) << std::endl;; ```. ## Language Bindings. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:8051,variab,variable,8051,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,2,['variab'],['variable']
Modifiability,"## Configuration for the address sanitizer.; When built with `-Dasan=ON`, build flags for address sanitizer are added to ROOT's build setup. In this directory, an additional library is created; that holds default sanitizer configs for ROOT executables. It e.g. contains suppressions for leak sanitizer, which automatically runs with address; sanitizer. When asan starts up, it checks if somebody defined the symbols in `SanitizerConfig.cxx`. In the standard asan runtime, these; functions are weak symbols, i.e. one can just override them with the desired configuration. That's what's happening here. This can be achieved in two ways:; 1. `LD_PRELOAD`: A micro library `libROOTSanitizerConfig.<dylib|so>` is created with the setup in this folder, and can be found in `<builddir>/lib/`.; Loading it with `LD_PRELOAD` will bring ROOT's default sanitiser config into any non-sanitised executable, e.g. python.; 2. ROOT executables will get the config automatically, using a static version of the config library, `libROOTStaticSanitizerConfig.a`.; All ROOT executables statically link against it, so they start up without reporting lots of unfixable memory leaks (e.g. llvm). #### Small linker magic to get the config symbols into ROOT's executables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:223,config,configs,223,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,5,['config'],"['config', 'configs', 'configuration']"
Modifiability,"## GUI Libraries. ### Attributes editors. - The transparency sliders change the transparency only for the currently edited object. ### Object editing on canvas. - The ""move opaque"" way to edit object on canvas, has been extended to all kind of objects.; - When in move opaque mode, a canvas can show guide lines to place object relatively to each other. A new resource in `etc/system.rootrc` allows to turn the feature on or off: `Canvas.ShowGuideLines`.; - For a fine adjustment at the pixel level, the arrow keys can be used to move object on pad.; - The zoom on axis and on 2D histogram has been improved. A shaded area is shown instead of simple lines. Also it is possible to zoom a 2D histogram with a shaded rectangle. ### Saving Files; - When saving files from a canvas, the default file type is now .pdf instead of .ps, since pdf is probably becoming more popular than ps.; - In the ""File Save Dialog"", there is now a default file name and its extension (if a specific one is selected), and the name is highlighted, so when the user types something, only the file name is changed.; - The default file type can be changed with a new `Canvas.SaveAsDefaultType` option in `etc/system.rootrc` (default being pdf). ### ROOT browser and pad editor; - The Pad Editor is now embedded in the left tab of the browser instead of inside the canvas itself, so the layout of the canvas remains untouched when opening the editor. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v600/index.md:220,extend,extended,220,gui/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v600/index.md,1,['extend'],['extended']
Modifiability,## I/O Libraries. ### hadd. We extended the `hadd` options to allow more control on the compression settings use for the; output file. In particular the new option -fk allows for a copy of the input; files with no decompressions/recompression of the TTree baskets even if they; do not match the requested compression setting. New options:. - `-ff` allows to force the compression setting to match the one from the first input; - `-fk[0-209]` allows to keep all the basket compressed as is and to compress the meta data with the given compression setting or the compression setting of the first input file.; - `-a` option append to existing file; - The verbosity level is now optional after -v. ### I/O New functionalities. ### I/O Behavior change.; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v606/index.md:31,extend,extended,31,io/doc/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v606/index.md,1,['extend'],['extended']
Modifiability,"## Introduction to TableGen Part 1: Classes, Defs, Basic Types and Let. **Note:** The content in this notebook is adapted from [this document](https://llvm.org/docs/TableGen/index.html). Refer to it if you want more details. This tutorial will cover:; * Classes; * Defs; * Basic types; * `let` in various forms; * Class template arguments. ## What is TableGen?. TableGen is a language used in LLVM to automate the generation of certain types of code. Usually repetitive code that has a common structure. TableGen is used to generate ""records"" that are then processed by a ""backend"" into domain specific code. The compiler for TableGen is the binary `llvm-tblgen`. This contains the logic to convert TableGen source into records that can then be passed to a TableGen backend. TableGen allows you to define Classes and Defs (which are instances of classes) but it doesn't encode what to do with that structure. That's what the backend does. The backend converts this structure into something useful, for example C++ code. These backends are included in the `llvm-tblgen` binary and you can choose which one to run using a command line option. If you don't choose a backend you get a dump of the structure, and that is what this notebook will be showing. This tutorial will focus on the language itself only. The only thing you need to know now is that in addition to `llvm-tblgen` you will see other `*-tblgen` like `clang-tblgen`. The difference between them is the backends they include. The default output from `llvm-tblgen` looks like this:. ```tablegen; %config cellreset on. // Empty source file; ```. ------------- Classes -----------------; ------------- Defs -----------------. **Note:** `%config` is not a TableGen command but a ""magic"" command to the Jupyter kernel for this notebook. By default new cells include the content of previously run cells, but for this notebook we mostly want each to be isolated. On occasion we will use the `%noreset` magic to override this. No source means no c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:114,adapt,adapted,114,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['adapt'],['adapted']
Modifiability,"## Networking Libraries. A new class TS3WebFile has been introduced. The new class TS3WebFile is; an extension of TWebFile and belongs to the net module. The name; TS3WebFile reflects better the fact that this solution is intended to be; generic to several S3 servers and not limited to Amazon's, in addition; to the fact that it actually extends the capabilities of TWebFile. Compared to the current support of S3 in ROOT (basically the class; TAS3File), the modifications include the improvements below:. - add support for using HTTPS : you can use different schemas for; specifying the underlying transport protocol to use ""s3:"",; ""s3http:"", ""s3https:"" [""s3"" uses HTTPS]. The current schema, namely; ""as3:"", is supported for backwards compatibility.; - extend support for other S3 service providers that do not offer the; virtual hosting functionality (currently only Amazon offers this).; - support the possibility of specifying user credentials on a per-file; basis or for all S3 files via environment variables.; - honor the ""NOPROXY"" option when specified in the constructor.; - exploit the capability of the S3 file server to provide partial; content responses to multi-range HTTP requests. Here are some examples of usages from the end user perspective:. ``` {.cpp}; TFile* f = TFile::Open(""s3://s3.amazonaws.com/mybucket/path/to/my/file"", ""AUTH=<accessKey>:<secretKey> NOPROXY""); TFile* f = TFile::Open(""s3://s3.amazonaws.com/mybucket/path/to/my/file"") // Uses environmental variables for retrieving credentials; ```. Limitations:. - we cannot efficiently detect that a S3 server is able to respond to; multi-range HTTP GET requests. Some servers, such as Amazon's,; respond to such kind of requests with the whole file contents. Other; servers, such as Huawei's, respond with the exact partial content; requested. Therefore, I added the possibility of configuring the; behavior via the ROOT configuration file: the identity of the; servers known to correctly support multi-range requests is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md:339,extend,extends,339,net/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md,3,"['extend', 'variab']","['extend', 'extends', 'variables']"
Modifiability,"## OPENUI5 Panel example. This is simplest way to use openui5 widget with RWebWindow. It is normal xml::View, but controller should be derived from rootui5/panel/Controller.; This class provides methods, which simplify handling of communication between server and client. First of all, when creating RWebWindow, one should configure panel name. Like:. auto win = ROOT::RWebWindow::Create();. win->SetPanelName(""localapp.view.TestPanel"");. Namespace ""localapp"" in this case corresponds to openui5 files, which will be loaded from current directory.; Therefore `""localapp.view.TestPanel""` means view, which will be loaded from `./view/TestPanel.view.xml` file. Controller is configured in the XML file and called `""localapp.controller.TestPanel""`.; Means it will be loaded from `./controller/TestPanel.controller.js` file. In the controller one use `onPanelInit` and `onPanelExit` methods to handle initialization and close of widget.; Method `panelSend` should be used to send string data to the server. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/panel/Readme.md:323,config,configure,323,tutorials/webgui/panel/Readme.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/panel/Readme.md,2,['config'],"['configure', 'configured']"
Modifiability,"## Tree Libraries. ### TTreePlayer and TSelectorDraw. - The option `colz` in a command like `nt->Draw(""b:a:c>>h"", """", ""colz"");`; erased the histogram `h`. (Jira report ROOT-4508).; - Make sure the number of bins for 2D histograms generated when drawing; 3 variables with option COL is the same as drawing 2 variables.; - In case of a 2D scatter plot drawing (with or without option COL) the automatically; computed lower limits of the histogram's axis might be 0. In that case it is better to set them; to the minimum of the data set (if it is >0) to avoid data cut when plotting in log scale. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v602/index.md:256,variab,variables,256,tree/doc/v602/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v602/index.md,2,['variab'],['variables']
Modifiability,"### Example project using cling as library. This example project uses cling as an external library.; It compiles code and calls it, moving values from the compiled part to the; interpreted part and back. It showcases how to use cling as a library, and shows how to set up a simple; CMake configuration that uses cling. ### How to build. After installing cling (say into /where/cling/is/installed), configure this; project using CMake like this:; ```bash; cmake -Dcling_DIR=/cling-install-dir/lib/cmake/cling /cling-source-dir/tools/cling/tools/demo; make && ./cling-demo; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/demo/README.md:288,config,configuration,288,interpreter/cling/tools/demo/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/demo/README.md,2,['config'],"['configuration', 'configure']"
Modifiability,"################################################; # CMakeLists.txt file for building ROOT math/unurun package; ############################################################################. #---Define package related variables-----------------------------------------------------------------. if(builtin_unuran). set(UNR_SRCDIR ${CMAKE_CURRENT_SOURCE_DIR}/src); set(UNR_VERSION ""1.8.0-root""); set(UNR_TARNAME ""unuran-${UNR_VERSION}""); set(UNR_TARGZFILE ${UNR_SRCDIR}/${UNR_TARNAME}.tar.gz); set(UNR_TARFILE ${UNR_SRCDIR}/${UNR_TARNAME}.tar); set(UNR_UNTARDIR ${CMAKE_CURRENT_BINARY_DIR}/${UNR_TARNAME}). #---Untar sources at configuration/generation time (needed for listing sources); if(NOT EXISTS ${UNR_UNTARDIR}); execute_process( COMMAND ${CMAKE_COMMAND} -E tar xzf ${UNR_TARGZFILE}; WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR} ); # This is necessary to replace the config.guess of unuran 1.8.0 as it does not allow to compile the ; # package on arm64.; execute_process( COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/config.guess_patch1 ${UNR_UNTARDIR}/autoconf/config.guess; WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR} ); endif(). if(WIN32); configure_file(${CMAKE_CURRENT_SOURCE_DIR}/config.h.win.in ${UNR_UNTARDIR}/config.h); else(); #---Define special compiler settings for unurun-----------------------------------------------------; set(UNR_CC ${CMAKE_C_COMPILER}); if(ROOT_ARCHITECTURE MATCHES hpuxia64acc); set(UNR_CC ""${UNR_CC} +DD64 -Ae""); elseif(ROOT_ARCHITECTURE MATCHES linuxppc64gcc); set(UNR_CC ""${UNR_CC} -m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664gcc); set(UNR_CFLAGS ""-m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxicc); set(UNR_CFLAGS ""-m32""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664icc); set(UNR_CFLAGS ""-m64""); elseif(ROOT_ARCHITECTURE MATCHES win32 OR ROOT_ARCHITECTURE MATCHES win64); set(UNR_CFLAGS ""-MD -G5 -GX""); endif(); if(CMAKE_OSX_SYSROOT); set(UNR_CFLAGS ""${UNR_CFLAGS} -isysroot ${CMAKE_OSX_SYSROOT}""); endif(). #---configur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt:1260,config,config,1260,math/unuran/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt,1,['config'],['config']
Modifiability,"###. #---Define package related variables-----------------------------------------------------------------. if(builtin_unuran). set(UNR_SRCDIR ${CMAKE_CURRENT_SOURCE_DIR}/src); set(UNR_VERSION ""1.8.0-root""); set(UNR_TARNAME ""unuran-${UNR_VERSION}""); set(UNR_TARGZFILE ${UNR_SRCDIR}/${UNR_TARNAME}.tar.gz); set(UNR_TARFILE ${UNR_SRCDIR}/${UNR_TARNAME}.tar); set(UNR_UNTARDIR ${CMAKE_CURRENT_BINARY_DIR}/${UNR_TARNAME}). #---Untar sources at configuration/generation time (needed for listing sources); if(NOT EXISTS ${UNR_UNTARDIR}); execute_process( COMMAND ${CMAKE_COMMAND} -E tar xzf ${UNR_TARGZFILE}; WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR} ); # This is necessary to replace the config.guess of unuran 1.8.0 as it does not allow to compile the ; # package on arm64.; execute_process( COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/config.guess_patch1 ${UNR_UNTARDIR}/autoconf/config.guess; WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR} ); endif(). if(WIN32); configure_file(${CMAKE_CURRENT_SOURCE_DIR}/config.h.win.in ${UNR_UNTARDIR}/config.h); else(); #---Define special compiler settings for unurun-----------------------------------------------------; set(UNR_CC ${CMAKE_C_COMPILER}); if(ROOT_ARCHITECTURE MATCHES hpuxia64acc); set(UNR_CC ""${UNR_CC} +DD64 -Ae""); elseif(ROOT_ARCHITECTURE MATCHES linuxppc64gcc); set(UNR_CC ""${UNR_CC} -m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664gcc); set(UNR_CFLAGS ""-m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxicc); set(UNR_CFLAGS ""-m32""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664icc); set(UNR_CFLAGS ""-m64""); elseif(ROOT_ARCHITECTURE MATCHES win32 OR ROOT_ARCHITECTURE MATCHES win64); set(UNR_CFLAGS ""-MD -G5 -GX""); endif(); if(CMAKE_OSX_SYSROOT); set(UNR_CFLAGS ""${UNR_CFLAGS} -isysroot ${CMAKE_OSX_SYSROOT}""); endif(). #---configure unuran (required for creating the config.h used by unuran source files)----------------; add_custom_command(OUTPUT ${UNR_UNTARDIR}/config.h; COMMAND GNUMAKE=make ./configure CC=${UN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt:1431,config,config,1431,math/unuran/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt,1,['config'],['config']
Modifiability,"#-------------------------------------------------------------------------------; # CLING - the C++ LLVM-based InterpreterG :); #; # This file is dual-licensed: you can choose to license it under the University; # of Illinois Open Source License or the GNU Lesser General Public License. See; # LICENSE.TXT for details.; #-------------------------------------------------------------------------------. include(ExternalProject). set(clad_install_dir ${CMAKE_BINARY_DIR}/etc/cling/); # Specify include dirs for clad; set(CLAD_INCLUDE_DIRS ${clad_install_dir}); # Clad Libraries; set(CLAD_CXX_FLAGS ${CMAKE_CXX_FLAGS}); set(_clad_build_type ${CMAKE_CFG_INTDIR}); if(MSVC AND NOT CMAKE_GENERATOR MATCHES Ninja); if (winrtdebug); set(_clad_build_type Debug); else(); set(_clad_build_type Release); endif(); if(asan); set(CLAD_CXX_FLAGS ""${CMAKE_CXX_FLAGS} ${ASAN_EXTRA_CXX_FLAGS}""); endif(); set(EXTRA_BUILD_ARGS --config ${_clad_build_type}); endif(); if(NOT _clad_build_type STREQUAL """" AND NOT _clad_build_type STREQUAL "".""); set(EXTRA_BUILD_ARGS --config ${_clad_build_type}); endif(); set(_CLAD_LIBRARY_PATH ${CMAKE_CURRENT_BINARY_DIR}/clad-prefix/src/clad-build/${_clad_build_type}/lib${LLVM_LIBDIR_SUFFIX}). # build byproducts only needed by Ninja; if(CMAKE_GENERATOR MATCHES Ninja); set(CLAD_BYPRODUCTS; ${_CLAD_LIBRARY_PATH}/${CMAKE_STATIC_LIBRARY_PREFIX}cladPlugin${CMAKE_STATIC_LIBRARY_SUFFIX}; ${_CLAD_LIBRARY_PATH}/${CMAKE_STATIC_LIBRARY_PREFIX}cladDifferentiator${CMAKE_STATIC_LIBRARY_SUFFIX}; ); endif(). if(APPLE); set(_clad_extra_cmake_args -DCMAKE_OSX_SYSROOT=${CMAKE_OSX_SYSROOT}); endif(). if (CMAKE_CXX_STANDARD); list(APPEND _clad_extra_cmake_args -DCMAKE_CXX_STANDARD=${CMAKE_CXX_STANDARD}); endif(CMAKE_CXX_STANDARD). if (Clang_DIR); list(APPEND _clad_extra_cmake_args -DClang_DIR=${Clang_DIR} -DClang_CONFIG_EXTRA_PATH_HINTS=${Clang_Config_ExtraPathHints}); endif(Clang_DIR). if (LLVM_FORCE_USE_OLD_TOOLCHAIN); list(APPEND _clad_extra_cmake_args -DLLVM_FORCE_USE_OLD_TOOLCHAIN=${L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/plugins/clad/CMakeLists.txt:911,config,config,911,interpreter/cling/tools/plugins/clad/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/plugins/clad/CMakeLists.txt,1,['config'],['config']
Modifiability,"#-------------------------------------------------------------------------------; # CLING - the C++ LLVM-based InterpreterG :); #; # This file is dual-licensed: you can choose to license it under the University; # of Illinois Open Source License or the GNU Lesser General Public License. See; # LICENSE.TXT for details.; #-------------------------------------------------------------------------------; if ((CLING_INCLUDE_TESTS OR CLING_BUILD_PLUGINS) AND NOT MSVC); add_subdirectory(example); endif(). if (CLING_BUILD_PLUGINS); # # If we drop a compatible cmake project in this folder we should automatically; # # pick it up and build it.; # function(LISTSUBDIRS result curdir); # file(GLOB children RELATIVE ${curdir} ${curdir}/*); # set(dirlist """"); # foreach(child ${children}); # if(IS_DIRECTORY ${curdir}/${child}); # list(APPEND dirlist ${child}); # endif(); # endforeach(); # set(${result} ${dirlist} PARENT_SCOPE); # endfunction(); #; # LISTSUBDIRS(subdirs ${CMAKE_CURRENT_SOURCE_DIR}/plugins/); # foreach(subdir ${SUBDIRS}); # add_subdirectory(${subdir}); # endforeach(); if(clad); add_subdirectory(clad); endif(); endif(CLING_BUILD_PLUGINS); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/plugins/CMakeLists.txt:994,plugin,plugins,994,interpreter/cling/tools/plugins/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/plugins/CMakeLists.txt,1,['plugin'],['plugins']
Modifiability,"#------------------------------------------------------------------------------; # CLING - the C++ LLVM-based InterpreterG :); #; # This file is dual-licensed: you can choose to license it under the University; # of Illinois Open Source License or the GNU Lesser General Public License. See; # LICENSE.TXT for details.; #------------------------------------------------------------------------------. cmake_minimum_required(VERSION 3.5). # Keep symbols for JIT resolution; set(LLVM_NO_DEAD_STRIP 1). # Cling needs at least C++17; so does this demo.; set(CMAKE_CXX_STANDARD 17); set(CMAKE_CXX_STANDARD_REQUIRED ON). if (CMAKE_PROJECT_NAME); # Building as part of cling; all CMake variables are set.; else(); # Building as separate project.; project(cling-demo). # This project needs cling.; find_package(cling REQUIRED); endif(). # The project has one binary:; add_executable(cling-demo cling-demo.cpp). # ...which links against clingInterpreter (and its dependencies).; target_link_libraries(cling-demo clingInterpreter). # Provide LLVMDIR to cling-demp.cpp:; target_compile_options(cling-demo PUBLIC -DLLVMDIR=""${LLVM_INSTALL_PREFIX}"" -I${LLVM_INSTALL_PREFIX}/include). set_target_properties(cling-demo; PROPERTIES ENABLE_EXPORTS 1). if(MSVC); set_target_properties(cling-demo PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS 1); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/demo/CMakeLists.txt:679,variab,variables,679,interpreter/cling/tools/demo/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/demo/CMakeLists.txt,1,['variab'],['variables']
Modifiability,"#------------------------------------------------------------------------------; # CLING - the C++ LLVM-based InterpreterG :); #; # This file is dual-licensed: you can choose to license it under the University; # of Illinois Open Source License or the GNU Lesser General Public License. See; # LICENSE.TXT for details.; #------------------------------------------------------------------------------. if (CMAKE_CFG_INTDIR STREQUAL "".""); set(LLVM_BUILD_MODE "".""); else (); set(LLVM_BUILD_MODE ""%(build_mode)s""); endif (). # Needed for '%shlibext'; set(TARGET_SHLIBEXT ""${CMAKE_SHARED_LIBRARY_SUFFIX}""). configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg; ). option(CLING_TEST_USE_VG ""Run Cling tests under Valgrind"" OFF); if(CLING_TEST_USE_VG); set(CLING_TEST_EXTRA_ARGS ${CLING_TEST_EXTRA_ARGS} ""--vg""); endif (). list(APPEND CLING_TEST_DEPS cling); if (TARGET llvm-config); list(APPEND CLING_TEST_DEPS llvm-config); endif(); if (TARGET FileCheck); list(APPEND CLING_TEST_DEPS FileCheck); endif(); if (TARGET opt); list(APPEND CLING_TEST_DEPS opt); endif(); if (TARGET not); list(APPEND CLING_TEST_DEPS not); endif(); if (TARGET count); list(APPEND CLING_TEST_DEPS count); endif(); if (TARGET clang); list(APPEND CLING_TEST_DEPS clang); endif(). set(CLING_TEST_PARAMS; cling_site_config=${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg; ). add_custom_target(cling-test-depends DEPENDS clingDemoPlugin ${CLING_TEST_DEPS}). set(LLVM_LIT_OUTPUT_DIR ""${LLVM_BINARY_DIR}/bin""); add_lit_testsuite(check-cling ""Running the Cling regression tests""; ${CMAKE_CURRENT_BINARY_DIR}; PARAMS ${CLING_TEST_PARAMS}; DEPENDS ${CLING_TEST_DEPS}; ARGS ${CLING_TEST_EXTRA_ARGS}; ); set_target_properties(check-cling PROPERTIES FOLDER ""Cling tests""). # Add a legacy target spelling: cling-test; add_custom_target(cling-test); add_dependencies(cling-test check-cling); set_target_properties(cling-test PROPERTIES FOLDER ""Cling tests""); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/test/CMakeLists.txt:926,config,config,926,interpreter/cling/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/test/CMakeLists.txt,2,['config'],['config']
Modifiability,#------------------------------------------------------------------------------; # CLING - the C++ LLVM-based InterpreterG :); #; # This file is dual-licensed: you can choose to license it under the University; # of Illinois Open Source License or the GNU Lesser General Public License. See; # LICENSE.TXT for details.; #------------------------------------------------------------------------------. if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/../lib/UserInterface/textinput; OR CLING_INCLUDE_TESTS); add_subdirectory(driver); add_subdirectory(Jupyter); add_subdirectory(libcling); add_subdirectory(demo); endif(). add_subdirectory(plugins); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/CMakeLists.txt:627,plugin,plugins,627,interpreter/cling/tools/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/CMakeLists.txt,1,['plugin'],['plugins']
Modifiability,"$131072, %edx #108.2; jb ..B1.70 # Prob 99% #108.2. It would be better to count down to zero, but this is a lot better than what we; do. //===---------------------------------------------------------------------===//. Consider:. typedef unsigned U32;; typedef unsigned long long U64;; int test (U32 *inst, U64 *regs) {; U64 effective_addr2;; U32 temp = *inst;; int r1 = (temp >> 20) & 0xf;; int b2 = (temp >> 16) & 0xf;; effective_addr2 = temp & 0xfff;; if (b2) effective_addr2 += regs[b2];; b2 = (temp >> 12) & 0xf;; if (b2) effective_addr2 += regs[b2];; effective_addr2 &= regs[4];; if ((effective_addr2 & 3) == 0); return 1;; return 0;; }. Note that only the low 2 bits of effective_addr2 are used. On 32-bit systems,; we don't eliminate the computation of the top half of effective_addr2 because; we don't have whole-function selection dags. On x86, this means we use one; extra register for the function when effective_addr2 is declared as U64 than; when it is declared U32. PHI Slicing could be extended to do this. //===---------------------------------------------------------------------===//. Tail call elim should be more aggressive, checking to see if the call is; followed by an uncond branch to an exit block. ; This testcase is due to tail-duplication not wanting to copy the return; ; instruction into the terminating blocks because there was other code; ; optimized out of the function after the taildup happened.; ; RUN: llvm-as < %s | opt -tailcallelim | llvm-dis | not grep call. define i32 @t4(i32 %a) {; entry:; 	%tmp.1 = and i32 %a, 1		; <i32> [#uses=1]; 	%tmp.2 = icmp ne i32 %tmp.1, 0		; <i1> [#uses=1]; 	br i1 %tmp.2, label %then.0, label %else.0. then.0:		; preds = %entry; 	%tmp.5 = add i32 %a, -1		; <i32> [#uses=1]; 	%tmp.3 = call i32 @t4( i32 %tmp.5 )		; <i32> [#uses=1]; 	br label %return. else.0:		; preds = %entry; 	%tmp.7 = icmp ne i32 %a, 0		; <i1> [#uses=1]; 	br i1 %tmp.7, label %then.1, label %return. then.1:		; preds = %else.0; 	%tmp.11 = add i32 %a, -2		; <i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:9790,extend,extended,9790,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['extend'],['extended']
Modifiability,"$noreg, or immediate value zero if an extra level of indirection is to be added to the first operand,. 3. Identifies a ``DILocalVariable`` metadata node,. 4. Specifies an expression qualifying the variable location, either inline or as a metadata node reference,. While the source location identifies the ``DILocation`` for the scope of the; variable. The second operand (``IsIndirect``) is deprecated and to be deleted.; All additional qualifiers for the variable location should be made through the; expression metadata. .. _instruction-referencing-locations:. Instruction referencing locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This experimental feature aims to separate the specification of variable; *values* from the program point where a variable takes on that value. Changes; in variable value occur in the same manner as ``DBG_VALUE`` meta instructions; but using ``DBG_INSTR_REF``. Variable values are identified by a pair of; instruction number and operand number. Consider the example below:. .. code-block:: text. $rbp = MOV64ri 0, debug-instr-number 1, debug-location !12; DBG_INSTR_REF !123, !DIExpression(DW_OP_LLVM_arg, 0), dbg-instr-ref(1, 0), debug-location !456. Instruction numbers are directly attached to machine instructions with an; optional ``debug-instr-number`` attachment, before the optional; ``debug-location`` attachment. The value defined in ``$rbp`` in the code; above would be identified by the pair ``<1, 0>``. The 3rd operand of the ``DBG_INSTR_REF`` above records the instruction; and operand number ``<1, 0>``, identifying the value defined by the ``MOV64ri``.; The first two operands to ``DBG_INSTR_REF`` are identical to ``DBG_VALUE_LIST``,; and the ``DBG_INSTR_REF`` s position records where the variable takes on the; designated value in the same way. More information about how these constructs are used is available in; :doc:`InstrRefDebugInfo`. The related documents :doc:`SourceLevelDebugging` and; :doc:`HowToUpdateDebugInfo` may be useful as well.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:27634,variab,variable,27634,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability,"% cat example_UseAfterFree.cc; int main(int argc, char **argv) {; int *array = new int[100];; delete [] array;; return array[argc]; // BOOM; }. # Compile and link; % clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer example_UseAfterFree.cc. or:. .. code-block:: console. # Compile; % clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer -c example_UseAfterFree.cc; # Link; % clang++ -g -fsanitize=address example_UseAfterFree.o. If a bug is detected, the program will print an error message to stderr and; exit with a non-zero exit code. AddressSanitizer exits on the first detected error.; This is by design:. * This approach allows AddressSanitizer to produce faster and smaller generated code; (both by ~5%).; * Fixing bugs becomes unavoidable. AddressSanitizer does not produce; false alarms. Once a memory corruption occurs, the program is in an inconsistent; state, which could lead to confusing results and potentially misleading; subsequent reports. If your process is sandboxed and you are running on OS X 10.10 or earlier, you; will need to set ``DYLD_INSERT_LIBRARIES`` environment variable and point it to; the ASan library that is packaged with the compiler used to build the; executable. (You can find the library by searching for dynamic libraries with; ``asan`` in their name.) If the environment variable is not set, the process will; try to re-exec. Also keep in mind that when moving the executable to another machine,; the ASan library will also need to be copied over. Symbolizing the Reports; =========================. To make AddressSanitizer symbolize its output; you need to set the ``ASAN_SYMBOLIZER_PATH`` environment variable to point to; the ``llvm-symbolizer`` binary (or make sure ``llvm-symbolizer`` is in your; ``$PATH``):. .. code-block:: console. % ASAN_SYMBOLIZER_PATH=/usr/local/bin/llvm-symbolizer ./a.out; ==9442== ERROR: AddressSanitizer heap-use-after-free on address 0x7f7ddab8c084 at pc 0x403c8c bp 0x7fff87fb82d0 sp 0x7fff87fb82c8; READ of siz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:2878,sandbox,sandboxed,2878,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['sandbox'],['sandboxed']
Modifiability,"%this to %struct.A*; %call = tail call %struct.A* @A_ctor_base(%struct.A* %0); %1 = bitcast %struct.C* %this to %struct.B*; %call2 = tail call %struct.B* @B_ctor_base(%struct.B* %1, i32 %x); ret %struct.C* %this; }. define %struct.D* @D_ctor_base(%struct.D* %this, i32 %x) {; entry:; ; CHECK-LABEL: D_ctor_base:. The use of ``CHECK-LABEL:`` directives in this case ensures that the three; ``CHECK:`` directives only accept lines corresponding to the body of the; ``@C_ctor_base`` function, even if the patterns match lines found later in; the file. Furthermore, if one of these three ``CHECK:`` directives fail,; FileCheck will recover by continuing to the next block, allowing multiple test; failures to be detected in a single invocation. There is no requirement that ``CHECK-LABEL:`` directives contain strings that; correspond to actual syntactic labels in a source or output language: they must; simply uniquely match a single line in the file being verified. ``CHECK-LABEL:`` directives cannot contain variable definitions or uses. Directive modifiers; ~~~~~~~~~~~~~~~~~~~. A directive modifier can be append to a directive by following the directive; with ``{<modifier>}`` where the only supported value for ``<modifier>`` is; ``LITERAL``. The ``LITERAL`` directive modifier can be used to perform a literal match. The; modifier results in the directive not recognizing any syntax to perform regex; matching, variable capture or any substitutions. This is useful when the text; to match would require excessive escaping otherwise. For example, the; following will perform literal matches rather than considering these as; regular expressions:. .. code-block:: text. Input: [[[10, 20]], [[30, 40]]]; Output %r10: [[10, 20]]; Output %r10: [[30, 40]]. ; CHECK{LITERAL}: [[[10, 20]], [[30, 40]]]; ; CHECK-DAG{LITERAL}: [[30, 40]]; ; CHECK-DAG{LITERAL}: [[10, 20]]. FileCheck Regex Matching Syntax; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. All FileCheck directives take a pattern to match.; For most uses of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:23687,variab,variable,23687,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability,"' bytes of nops with a; calling sequence specific to their runtime before executing the; generated machine code. There are no guarantees with respect to the; alignment of the nop sequence. Unlike :doc:`StackMaps` statepoints do; not have a concept of shadow bytes. Note that semantically the; statepoint still represents a call or invoke to 'target', and the nop; sequence after patching is expected to represent an operation; equivalent to a call or invoke to 'target'. The 'target' operand is the function actually being called. The operand; must have an :ref:`elementtype <attr_elementtype>` attribute specifying; the function type of the target. The target can be specified as either; a symbolic LLVM function, or as an arbitrary Value of pointer type. Note; that the function type must match the signature of the callee and the; types of the 'call parameters' arguments. The '#call args' operand is the number of arguments to the actual; call. It must exactly match the number of arguments passed in the; 'call parameters' variable length section. The 'flags' operand is used to specify extra information about the; statepoint. This is currently only used to mark certain statepoints; as GC transitions. This operand is a 64-bit integer with the following; layout, where bit 0 is the least significant bit:. +-------+---------------------------------------------------+; | Bit # | Usage |; +=======+===================================================+; | 0 | Set if the statepoint is a GC transition, cleared |; | | otherwise. |; +-------+---------------------------------------------------+; | 1-63 | Reserved for future use; must be cleared. |; +-------+---------------------------------------------------+. The 'call parameters' arguments are simply the arguments which need to; be passed to the call target. They will be lowered according to the; specified calling convention and otherwise handled like a normal call; instruction. The number of arguments must exactly match what is; specifie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:501822,variab,variable,501822,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"' is called first,; // then 'h()', that is (or calls) noreturn and eventually; // 'g()' is never called.; f(g(malloc(1)), h()); // warn: 'g()' may never be called.; }. void f(int, int);; int g(int *);; int h() { throw 1; };. void test() {; // It is possible that 'new int' is called first,; // then 'h()', that throws an exception and eventually; // 'g()' is never called.; f(g(new int), h()); // warn: 'g()' may never be called.; }. memory.DstBufferTooSmall; (C, C++); Destination buffer passed to memory function is too small.; Note: security.insecureAPI.strcpy currently warns; on usage of strcpy and suggests to replace it.; Note: alpha.unix.CStringChecker contains some similar checks.; Source: CWE-120. void test() {; const char* s1 = ""abc"";; char *s2 = new char;; strcpy(s2, s1); // warn; }. void test() {; int* p1 = new int[3];; int* p2 = new int;; memcpy(p2, p1, 3); // warn; }. memory.NegativeArraySize; (C, C++); 'n' is used to specify the buffer size may be negative.; Note: possibly an enhancement to ; alpha.security.MallocOverflow.; Source: CWE-20,; Example 2. void test() {; int *p;; int n1 = -1;; p = new int[n1]; // warn; }. memory.ZeroAlloc; (C, C++); Allocation of zero bytes.; Note: an enhancement to unix.Malloc.; Note: unix.API perform C-checks for zero; allocation. This should be moved to unix.Malloc.; Source: C++03 3.7.3.1p2; C++11 3.7.4.1p2. #include <stdlib.h>. void test() {; int *p = malloc(0); // warn; free(p);; }. void test() {; int *p = new int[0]; // warn; delete[] p;; }. D6178. constructors/destructors. Name, DescriptionExampleProgress. ctordtor.ExptInsideDtor; (C++); It is dangerous to let an exception leave a destructor.; Using try..catch solves the problem.; Source: Scott Meyers ""More Effective C++"", item 11: Prevent exceptions from; leaving destructors. class A {; A() {}; ~A() { throw 1; } // warn; };. void f() throw(int);. class A {; A() {}; ~A() { f(); } // warn; };. ctordtor.PlacementSelfCopy; (C++11); For a placement copy or move, it is almost ce",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:1657,enhance,enhancement,1657,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['enhance'],['enhancement']
Modifiability,"'; [004] {Variable} 'Var_1' -> 'int'; [003] 11 {Parameter} 'Param_1' -> 'int'; [003] 11 {Parameter} 'Param_2' -> 'int'. DWARF - GCC (Linux); ^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [002] {Producer} 'GNU C++14 9.3.0'; [002] 2 {Function} extern declared_inlined 'InlineFunction' -> 'int'; [003] {Block}; [004] 5 {Variable} 'Var_2' -> 'int'; [003] 2 {Parameter} 'Param' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [002] 11 {Function} extern not_inlined 'test' -> 'int'; [003] 12 {Variable} 'A' -> 'int'; [003] 13 {InlinedFunction} declared_inlined 'InlineFunction' -> 'int'; [004] {Block}; [005] {Variable} 'Var_2' -> 'int'; [004] {Parameter} 'Param' -> 'int'; [004] {Variable} 'Var_1' -> 'int'; [003] 11 {Parameter} 'Param_1' -> 'int'; [003] 11 {Parameter} 'Param_2' -> 'int'. From the previous logical views, we can see that the CodeView debug; information generated by the Clang compiler shows the variables **Var_1**; and **Var_2** are at the same lexical scope (**4**) in the function; **InlineFuction**. The DWARF generated by GCC/Clang and CodeView; generated by MSVC, show those variables at the correct lexical scope:; **3** and **4** respectively. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output showing just the logical elements; that have in their name the *var* pattern. The logical view is sorted; by the variables name. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=name; --select-regex --select-nocase --select=Var; --report=list; --print=symbols; pr-43860-*.o. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-43860.cpp'; [003] {Vari",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:53073,variab,variables,53073,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['variab'],['variables']
Modifiability,"'<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;. Now that the parser knows the precedence of the binary operator, it; takes care of all the parsing and AST generation. We just need to; implement codegen for the assignment operator. This looks like:. .. code-block:: c++. Value *BinaryExprAST::codegen() {; // Special case '=' because we don't want to emit the LHS as an expression.; if (Op == '=') {; // This assume we're building without RTTI because LLVM builds that way by; // default. If you build LLVM with RTTI this can be changed to a; // dynamic_cast for automatic error checking.; VariableExprAST *LHSE = static_cast<VariableExprAST*>(LHS.get());; if (!LHSE); return LogErrorV(""destination of '=' must be a variable"");. Unlike the rest of the binary operators, our assignment operator doesn't; follow the ""emit LHS, emit RHS, do computation"" model. As such, it is; handled as a special case before the other binary operators are handled.; The other strange thing is that it requires the LHS to be a variable. It; is invalid to have ""(x+1) = expr"" - only things like ""x = expr"" are; allowed. .. code-block:: c++. // Codegen the RHS.; Value *Val = RHS->codegen();; if (!Val); return nullptr;. // Look up the name.; Value *Variable = NamedValues[LHSE->getName()];; if (!Variable); return LogErrorV(""Unknown variable name"");. Builder->CreateStore(Val, Variable);; return Val;; }; ... Once we have the variable, codegen'ing the assignment is; straightforward: we emit the RHS of the assignment, create a store, and; return the computed value. Returning a value allows for chained; assignments like ""X = (Y = Z)"". Now that we have an assignment operator, we can mutate loop variables; and arguments. For example, we can now run code like this:. ::. # Function to print a double.; extern printd(x);. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. def test(x); printd(x) :; x = 4 :; printd(x);",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:21540,variab,variable,21540,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"'``--``' marker. When the user specifies '``--``' on the; command line, it is telling the program that all options after the '``--``'; should be treated as positional arguments, not options. Thus, we can use it; like this:. ::. $ spiffygrep -- -foo test.txt; ...output... Determining absolute position with getPosition(); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Sometimes an option can affect or modify the meaning of another option. For; example, consider ``gcc``'s ``-x LANG`` option. This tells ``gcc`` to ignore the; suffix of subsequent positional arguments and force the file to be interpreted; as if it contained source code in language ``LANG``. In order to handle this; properly, you need to know the absolute position of each argument, especially; those in lists, so their interaction(s) can be applied correctly. This is also; useful for options like ``-llibname`` which is actually a positional argument; that starts with a dash. So, generally, the problem is that you have two ``cl::list`` variables that; interact in some way. To ensure the correct interaction, you can use the; ``cl::list::getPosition(optnum)`` method. This method returns the absolute; position (as found on the command line) of the ``optnum`` item in the; ``cl::list``. The idiom for usage is like this:. .. code-block:: c++. static cl::list<std::string> Files(cl::Positional, cl::OneOrMore);; static cl::list<std::string> Libraries(""l"");. int main(int argc, char**argv) {; // ...; std::vector<std::string>::iterator fileIt = Files.begin();; std::vector<std::string>::iterator libIt = Libraries.begin();; unsigned libPos = 0, filePos = 0;; while ( 1 ) {; if ( libIt != Libraries.end() ); libPos = Libraries.getPosition( libIt - Libraries.begin() );; else; libPos = 0;; if ( fileIt != Files.end() ); filePos = Files.getPosition( fileIt - Files.begin() );; else; filePos = 0;. if ( filePos != 0 && (libPos == 0 || filePos < libPos) ) {; // Source File Is next; ++fileIt;; }; else if ( libPos != 0 && (filePos ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:29374,variab,variables,29374,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variables']
Modifiability,"'`profs'` option. The `prof` option is; automatically selected when the output is redirected into a; **`TProfile`**. For example `y:x>>pf` where `pf `is an existing; **`TProfile`** histogram. #### Tree Information. Once we have drawn a tree, we can get information about the tree. These; are the methods used to get information from a drawn tree **`TTree`**:. - `GetSelectedRows`: Returns the number of entries accepted by the; selection expression. In case where no selection was specified, it; returns the number of entries processed. - `GetV1`: Returns a pointer to the float array of the first variable. - `GetV2`: Returns a pointer to the float array of second variable. - `GetV3`: Returns a pointer to the float array of third variable. - `GetW`: Returns a pointer to the float array of Weights where the; weight equals the result of the selection expression. To read the drawn values of `fNtrack` into an array, and loop through; the entries follow the lines below. First, open the file and draw the; `fNtrack` variable:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); ```. Then declare a pointer to a float and use the GetV1 method to retrieve; the first dimension of the tree. In this example we only drew one; dimension (`fNtrack`) if we had drawn two, we could use GetV2 to get the; second one. ``` {.cpp}; root[] Float_t *a; root[] a = T->GetV1(); ```. Loop through the first 10 entries and print the values of `fNtrack`:. ``` {.cpp}; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to see the values; 594 597 606 595 604 610 604 602 603 596; ```. By default, `TTree::Draw` creates these arrays with `fEstimate` words; where `fEstimate` can be set via `TTree::SetEstimate`. If you have more; entries than `fEstimate` only the first `fEstimate` selected entries; will be stored in the arrays. The arrays are used as buffers. When; `fEstimate` entries have been processed, ROOT scans the buffers to; compute the min",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:119385,variab,variable,119385,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"'ll start; with ``ForExprAST::codegen()`` (see the `full code listing <#id1>`_ for; the unabridged code):. .. code-block:: c++. Function *TheFunction = Builder->GetInsertBlock()->getParent();. // Create an alloca for the variable in the entry block.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);. // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. // Store the value into the alloca.; Builder->CreateStore(StartVal, Alloca);; ... // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.; Value *CurVar = Builder->CreateLoad(Alloca->getAllocatedType(), Alloca,; VarName.c_str());; Value *NextVar = Builder->CreateFAdd(CurVar, StepVal, ""nextvar"");; Builder->CreateStore(NextVar, Alloca);; ... This code is virtually identical to the code `before we allowed mutable; variables <LangImpl05.html#code-generation-for-the-for-loop>`_. The big difference is that we; no longer have to construct a PHI node, and we use load/store to access; the variable as needed. To support mutable argument variables, we need to also make allocas for; them. The code for this is also pretty simple:. .. code-block:: c++. Function *FunctionAST::codegen() {; ...; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. if (Value *RetVal = Body->codegen()) {; ... For each argument, we make an alloca, store the input value to the; function into the alloca, and register the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:15311,variab,variables,15311,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"'re building GWP-ASan outside of compiler-rt, simply ensure that you; specify ``-DGWP_ASAN_DEFAULT_OPTIONS=""...""`` when building; ``optional/options_parser.cpp``). - By defining a ``__gwp_asan_default_options`` function in one's program that; returns the options string to be parsed. Said function must have the following; prototype: ``extern ""C"" const char* __gwp_asan_default_options(void)``, with a; default visibility. This will override the compile time define;. - Depending on allocator support (Scudo has support for this mechanism): Through; an environment variable, containing the options string to be parsed. In Scudo,; this is through `SCUDO_OPTIONS=GWP_ASAN_${OPTION_NAME}=${VALUE}` (e.g.; `SCUDO_OPTIONS=GWP_ASAN_SampleRate=100`). Options defined this way will; override any definition made through ``__gwp_asan_default_options``. The options string follows a syntax similar to ASan, where distinct options; can be assigned in the same string, separated by colons. For example, using the environment variable:. .. code:: console. GWP_ASAN_OPTIONS=""MaxSimultaneousAllocations=16:SampleRate=5000"" ./a.out. Or using the function:. .. code:: cpp. extern ""C"" const char *__gwp_asan_default_options() {; return ""MaxSimultaneousAllocations=16:SampleRate=5000"";; }. The following options are available:. +----------------------------+---------+--------------------------------------------------------------------------------+; | Option | Default | Description |; +----------------------------+---------+--------------------------------------------------------------------------------+; | Enabled | true | Is GWP-ASan enabled? |; +----------------------------+---------+--------------------------------------------------------------------------------+; | PerfectlyRightAlign | false | When allocations are right-aligned, should we perfectly align them up to the |; | | | page boundary? By default (false), we round up allocation size to the nearest |; | | | power of two (2, 4, 8, 16) up to a max",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:6554,variab,variable,6554,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['variab'],['variable']
Modifiability,"'s builtin directory for include files. .. option:: -fkeep-system-includes. Usable only with :option:`-E`. Do not copy the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If this environment variable is present, it is treated as a delimited list of; paths to be added to the default system include path list. The delimiter is; the platform dependent delimiter, as used in the PATH environment variable. Empty components in the environment variable are ignored. .. envvar:: C_INCLUDE_PATH, OBJC_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJCPLUS_INCLUDE_PATH. These environment variables specify additional paths, as for :envvar:`CPATH`, which are; only used when processing the appropriate language. .. envvar:: MACOSX_DEPLOYMENT_TARGET. If :option:`-mmacosx-version-min` is unspecified, the default deployment; target is read from this environment variable. This option only affects; Darwin targets. BUGS; ----. To report bugs, please visit <https://github.com/llvm/llvm-project/issues/>. Most bug reports should; include preprocessed source files (use the :option:`-E` option) and the full; o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:20800,variab,variables,20800,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['variab'],['variables']
Modifiability,"'t detect your toolset, or if it thinks that the; environment is not sane enough. In this case, make sure that the toolset that; you intend to use is the only one reachable from the shell, and that the shell; itself is the correct one for your development environment. CMake will refuse; to build MinGW makefiles if you have a POSIX shell reachable through the PATH; environment variable, for instance. You can force CMake to use a given build; tool; for instructions, see the `Usage`_ section, below. You may; also wish to control which targets LLVM enables, or which LLVM; components are built; see the `Frequently Used LLVM-related; variables`_ below. #. After CMake has finished running, proceed to use IDE project files, or start; the build from the build directory:. .. code-block:: console. $ cmake --build . The ``--build`` option tells ``cmake`` to invoke the underlying build; tool (``make``, ``ninja``, ``xcodebuild``, ``msbuild``, etc.). The underlying build tool can be invoked directly, of course, but; the ``--build`` option is portable. #. After LLVM has finished building, install it from the build directory:. .. code-block:: console. $ cmake --build . --target install. The ``--target`` option with ``install`` parameter in addition to; the ``--build`` option tells ``cmake`` to build the ``install`` target. It is possible to set a different install prefix at installation time; by invoking the ``cmake_install.cmake`` script generated in the; build directory:. .. code-block:: console. $ cmake -DCMAKE_INSTALL_PREFIX=/tmp/llvm -P cmake_install.cmake. .. _Basic CMake usage:; .. _Usage:. Basic CMake usage; =================. This section explains basic aspects of CMake; which you may need in your day-to-day usage. CMake comes with extensive documentation, in the form of html files, and as; online help accessible via the ``cmake`` executable itself. Execute ``cmake; --help`` for further help options. CMake allows you to specify a build tool (e.g., GNU make, Visual Studio,; o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:3214,portab,portable,3214,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['portab'],['portable']
Modifiability,() to underlying trees; * [[#8639](https://github.com/root-project/root/issues/8639)] - (RDataFrame) AsNumpy returns Boolean branches as 'object' dtype numpy arrays; * [[#8582](https://github.com/root-project/root/issues/8582)] - TThreadTimer behavior; * [[#8581](https://github.com/root-project/root/issues/8581)] - [ntuple] RNTupleModel columns ownership issue; * [[#8517](https://github.com/root-project/root/issues/8517)] - Add integer support to TVectorT; * [[#8494](https://github.com/root-project/root/issues/8494)] - cling crashes on conditional parameter in template; * [[#8260](https://github.com/root-project/root/issues/8260)] - Build system cannot detect version of oneTBB; * [[#8148](https://github.com/root-project/root/issues/8148)] - Document TMethodCall class limitations; * [[#7950](https://github.com/root-project/root/issues/7950)] - Assertion exception including header file with GaudiPython module; * [[#7900](https://github.com/root-project/root/issues/7900)] - Support spectator variables in RReader; * [[#7872](https://github.com/root-project/root/issues/7872)] - TExecutorCRTP::Map() should support void; * [[#7871](https://github.com/root-project/root/issues/7871)] - Usability of TExecutor::MapReduce; * [[#7845](https://github.com/root-project/root/issues/7845)] - Improve TMatrix reference documentation; * [[#7805](https://github.com/root-project/root/issues/7805)] - Inconsistent and unintuitive behaviour of TFormula::SetParNames and TFormula::SetParameters; * [[#7774](https://github.com/root-project/root/issues/7774)] - Unreasonably slow behaviour of CompileMacro; * [[#7699](https://github.com/root-project/root/issues/7699)] - [VecOps] Make free functions in VecOps better visible; * [[#7686](https://github.com/root-project/root/issues/7686)] - [PyROOT] Segfault when creating proxy to derived class with multiple overloads; * [[#7669](https://github.com/root-project/root/issues/7669)] - Inconsistent behaviour in wildcard import; * [[#7644](https://github.co,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:47868,variab,variables,47868,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['variab'],['variables']
Modifiability,"() {; bool b = true;; if (b & f()) {} // warn; }. different.LabelInsideSwitch; (C); Possibly a misprint: label found inside a switch(); statement. void test(int c) {; switch(c){; case 1:; c += 1; break;; defalt: // warn (did you mean 'default'?); c -= 1; break;; }; }. different.IdenticalCondIfIf; (C); The conditions of two subsequent if statements are; identical. int test(int c) {; if (c > 5); c += 1;; if (c > 5) // warn; c -= 1;; return c;; }. different.LogicalOpUselessArg; (C); The second operand of a && operator has no impact on; expression result. void test(unsigned a) {; if (a<7 && a<10) {}; // warn; }. different.SameResLogicalExpr; (C); An expression is always evaluated to true/false. void test() {; int i = 0;; if (i != 0) {}; // warn; }. void test(int i) {; if (i == 0 && i == 1) {}; // warn; }. void test(int i) {; if (i < 0 || i >= 0) {}; // warn; }. different.OpPrecedenceAssignCmp; (C, C++); Comparison operation has higher precedence then assignment. Boolean value is; assigned to a variable of other type. Parenthesis may bee required around an; assignment. int f();. void test(int x, int y) {; bool b;; if((b = x != y)) {} // ok; if((x = f() != y)) {} // warn; }. different.OpPrecedenceIifShift; (C, C++); ?: has lower precedence then <<.; Source: Stephen C. Dewhurst ""C++ Gotchas: Avoiding Common Problems in Coding; and Design"", advise 15. #include <iostream>. void test(int a) {; std::cout << a ? ""a"" : ""b""; // warn; }. void test(int a) {; a << a > 7 ? 1 : 2; // warn; }. different.ObjectUnused; (C++); The object was created but is not being used. struct S {; int x, y;; S(int xx, int yy) : x(xx), y(yy) {}; S(int xx) {; S(xx, 0); // warn; }; };. #include <exception>. void test() {; std::exception();; // warn (did you mean 'throw std::exception()'?); }. different.StaticArrayPtrCompare; (C); Pointer to static array is being compared to NULL. May the subscripting is; missing. void test() {; int a[1][1];; if (a[0] == 0) {}; // warn; }. different.ConversionToBool; (C, C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:22911,variab,variable,22911,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['variab'],['variable']
Modifiability,"(); add_dependencies(clang-bootstrap-deps lld); endif(). if (WIN32); # Build llvm-rc and llvm-mt which are needed by the Windows build.; add_dependencies(clang-bootstrap-deps llvm-rc); if(LLVM_ENABLE_LIBXML2); add_dependencies(clang-bootstrap-deps llvm-mt); endif(); endif(). # If the next stage is LTO we need to depend on LTO and possibly lld or LLVMgold; if(BOOTSTRAP_LLVM_ENABLE_LTO OR LLVM_ENABLE_LTO AND NOT LLVM_BUILD_INSTRUMENTED); if(APPLE); add_dependencies(clang-bootstrap-deps LTO); # on Darwin we need to set DARWIN_LTO_LIBRARY so that -flto will work; # using the just-built compiler, and we need to override DYLD_LIBRARY_PATH; # so that the host object file tools will use the just-built libLTO.; # However if System Integrity Protection is enabled the DYLD variables; # will be scrubbed from the environment of any base system commands. This; # includes /bin/sh, which ninja uses when executing build commands. To; # work around the envar being filtered away we pass it in as a CMake; # variable, and have LLVM's CMake append the envar to the archiver calls.; set(LTO_LIBRARY -DDARWIN_LTO_LIBRARY=${LLVM_SHLIB_OUTPUT_INTDIR}/libLTO.dylib; -DDYLD_LIBRARY_PATH=${LLVM_LIBRARY_OUTPUT_INTDIR}); elseif(MSVC); add_dependencies(clang-bootstrap-deps llvm-lib); set(${CLANG_STAGE}_AR -DCMAKE_AR=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-lib); elseif(NOT WIN32); add_dependencies(clang-bootstrap-deps llvm-ar llvm-ranlib); if(NOT BOOTSTRAP_LLVM_ENABLE_LLD AND LLVM_BINUTILS_INCDIR); add_dependencies(clang-bootstrap-deps LLVMgold); endif(); set(${CLANG_STAGE}_AR -DCMAKE_AR=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-ar); set(${CLANG_STAGE}_RANLIB -DCMAKE_RANLIB=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-ranlib); endif(); endif(). if(CLANG_BOOTSTRAP_EXTRA_DEPS); add_dependencies(clang-bootstrap-deps ${CLANG_BOOTSTRAP_EXTRA_DEPS}); endif(). add_custom_target(${NEXT_CLANG_STAGE}-clear; DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-cleared; ); add_custom_command(; OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:22164,variab,variable,22164,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['variab'],['variable']
Modifiability,"();; ```. If you pipe the result of the `TTree::Draw` into a histogram, the; histogram is also available in the current directory. You can do:. ``` {.cpp}; // Draw the histogram and fill hnew with it; nt->Draw(""x>>hnew"",""cuts"");; // get hnew from the current directory; TH1F *hnew = (TH1F*)gDirectory->Get(""hnew"");; // or get hnew from the current Pad; TH1F *hnew = (TH1F*)gPad->GetPrimitive(""hnew"");; ```. ### Using Draw Options in TTree::Draw. The next parameter is the draw option for the histogram:. ``` {.cpp}; root[] MyTree->Draw(""Cost:Age"",""Nation == \""FR\"""",""surf2"");; ```. ![Using draw options in trees](pictures/03000104.png). The draw options are the same as for `TH1::Draw`. See ""Draw Options""; where they are listed. In addition to the draw options defined in; **`TH1`**, there are three more. The `'prof'` and `'profs'` draw a; profile histogram (**`TProfile`**) rather than a regular 2D histogram; (**`TH2D`**) from an expression with two variables. If the expression; has three variables, a **`TProfile2D`** is generated. The '`profs`' generates a **`TProfile`** with error on the spread. The; '`prof`' option generates a **`TProfile`** with error on the mean. The; ""`goff`"" option suppresses generating the graphics. You can combine the; draw options in a list separated by commas. After typing the lines; above, you should now have a canvas that looks this. ### Superimposing Two Histograms. When superimposing two 2-D histograms inside a script with `TTree::Draw`; and using the ""`same`"" option, you will need to update the pad between; `Draw` commands. ``` {.cpp}; {; // superimpose two 2D scatter plots; // Create a 2D histogram and fill it with random numbers; TH2 *h2 = new TH2D (""h2"",""2D histo"",100,0,70,100,0,20000);; for (Int_t i = 0; i < 10000; i++); h2->Fill(gRandom->Gaus(40,10),gRandom->Gaus(10000,3000));; // set the color to differentiate it visually; h2->SetMarkerColor(kGreen);; h2->Draw();; // Open the example file and get the tree; TFile f(""cernstaff.root"");; TTre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:74786,variab,variables,74786,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"(C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61972,variab,variable,61972,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variable']
Modifiability,"(IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ compiler, KAI/KCC)`. - `Compaq Alpha (GCC, KAI/KCC, DEC/CXX)`. - `SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler) `. - `Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC) `. - `MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl)`. - `PowerPC with GNU/Linux and GCC, Debian v2`. - `PowerPC64 with GNU/Linux and GCC`. - `ARM with GNU/Linux and GCC`. - `LynxOS`. ## The Organization of the ROOT Framework. Now after we know in abstract terms what the ROOT framework is, let us; look at the physical directories and files that come with the ROOT; installation. You may work on a platform where your system; administrator has already installed ROOT. You will need to follow the; specific development environment for your setup and you may not have; write access to the directories. In any case, you will need an; environment variable called `ROOTSYS`, which holds the path of the top; ROOT directory. ``` {.cpp}; > echo $ROOTSYS; /opt/root; ```. In the `ROOTSYS` directory are examples, executables, tutorials,; header tutorials files, and, if you opted to download it, the source; is here. The directories of special interest to us are `bin`,; `tutorials`, `lib`, `test`, and` include`. The next figure shows the; contents of these directories. ![ROOT framework directories](pictures/02000004.jpg). ### \$ROOTSYS/bin. The `bin` directory contains several executables. +---------------+------------------------------------------------------------+; | `root` | shows the ROOT splash screen and calls `root.exe` |; +---------------+------------------------------------------------------------+; | `root.exe` | the executable that `root` calls, if you use a debugger |; | | such as `gdb`, you will need to run `root.exe` directly |; +---------------+------------------------------------------------------------+; | `rootcling` | is the utility ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:10863,variab,variable,10863,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['variab'],['variable']
Modifiability,"(LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT ""${LLVM_HOST_TRIPLE}""); endif(); endif(). set(LLVM_DEFAULT_TARGET_TRIPLE ""${LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT}"" CACHE STRING; ""Default target for which LLVM will generate code."" ); message(STATUS ""LLVM default target triple: ${LLVM_DEFAULT_TARGET_TRIPLE}""). set(LLVM_TARGET_TRIPLE ""${LLVM_DEFAULT_TARGET_TRIPLE}""). if(WIN32 OR CYGWIN); if(BUILD_SHARED_LIBS OR LLVM_BUILD_LLVM_DYLIB); set(LLVM_ENABLE_PLUGINS_default ON); else(); set(LLVM_ENABLE_PLUGINS_default OFF); endif(); else(); set(LLVM_ENABLE_PLUGINS_default ${LLVM_ENABLE_PIC}); endif(); option(LLVM_ENABLE_PLUGINS ""Enable plugin support"" ${LLVM_ENABLE_PLUGINS_default}). set(LLVM_ENABLE_NEW_PASS_MANAGER TRUE CACHE BOOL; ""Enable the new pass manager by default.""); if(NOT LLVM_ENABLE_NEW_PASS_MANAGER); message(FATAL_ERROR ""Enabling the legacy pass manager on the cmake level is""; "" no longer supported.""); endif(). include(HandleLLVMOptions). ######. # Configure all of the various header file fragments LLVM uses which depend on; # configuration variables.; set(LLVM_ENUM_TARGETS """"); set(LLVM_ENUM_ASM_PRINTERS """"); set(LLVM_ENUM_ASM_PARSERS """"); set(LLVM_ENUM_DISASSEMBLERS """"); set(LLVM_ENUM_TARGETMCAS """"); set(LLVM_ENUM_EXEGESIS """"); foreach(t ${LLVM_TARGETS_TO_BUILD}); set( td ${LLVM_MAIN_SRC_DIR}/lib/Target/${t} ). # Make sure that any experimental targets were passed via; # LLVM_EXPERIMENTAL_TARGETS_TO_BUILD, not LLVM_TARGETS_TO_BUILD.; # We allow experimental targets that are not in LLVM_ALL_EXPERIMENTAL_TARGETS,; # as long as they are passed via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.; if ( NOT ""${t}"" IN_LIST LLVM_ALL_TARGETS AND NOT ""${t}"" IN_LIST LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ); if( ""${t}"" IN_LIST LLVM_ALL_EXPERIMENTAL_TARGETS ); message(FATAL_ERROR ""The target `${t}' is experimental and must be passed ""; ""via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.""); else(); message(FATAL_ERROR ""The target `${t}' is not a core tier target. It may be ""; ""experimental, if so it must be passed via",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:39380,config,configuration,39380,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"(LLVM_ENABLE_DOXYGEN ""Use doxygen to generate llvm API documentation."" OFF); option (LLVM_ENABLE_SPHINX ""Use Sphinx to generate llvm documentation."" OFF); option (LLVM_ENABLE_OCAMLDOC ""Build OCaml bindings documentation."" ON); option (LLVM_ENABLE_BINDINGS ""Build bindings."" ON). set(LLVM_INSTALL_DOXYGEN_HTML_DIR ""${CMAKE_INSTALL_DOCDIR}/llvm/doxygen-html""; CACHE STRING ""Doxygen-generated HTML documentation install directory""); set(LLVM_INSTALL_OCAMLDOC_HTML_DIR ""${CMAKE_INSTALL_DOCDIR}/llvm/ocaml-html""; CACHE STRING ""OCamldoc-generated HTML documentation install directory""). option (LLVM_BUILD_EXTERNAL_COMPILER_RT; ""Build compiler-rt as an external project."" OFF). option (LLVM_VERSION_PRINTER_SHOW_HOST_TARGET_INFO; ""Show target and host info when tools are invoked with --version."" ON). # You can configure which libraries from LLVM you want to include in the; # shared library by setting LLVM_DYLIB_COMPONENTS to a semi-colon delimited; # list of LLVM components. All component names handled by llvm-config are valid.; if(NOT DEFINED LLVM_DYLIB_COMPONENTS); set(LLVM_DYLIB_COMPONENTS ""all"" CACHE STRING; ""Semicolon-separated list of components to include in libLLVM, or \""all\"".""); endif(). if(MSVC); option(LLVM_BUILD_LLVM_C_DYLIB ""Build LLVM-C.dll (Windows only)"" ON); # Set this variable to OFF here so it can't be set with a command-line; # argument.; set (LLVM_LINK_LLVM_DYLIB OFF); if (BUILD_SHARED_LIBS); message(FATAL_ERROR ""BUILD_SHARED_LIBS options is not supported on Windows.""); endif(); else(); option(LLVM_LINK_LLVM_DYLIB ""Link tools against the libllvm dynamic library"" OFF); option(LLVM_BUILD_LLVM_C_DYLIB ""Build libllvm-c re-export library (Darwin only)"" OFF); set(LLVM_BUILD_LLVM_DYLIB_default OFF); if(LLVM_LINK_LLVM_DYLIB OR LLVM_BUILD_LLVM_C_DYLIB); set(LLVM_BUILD_LLVM_DYLIB_default ON); endif(); option(LLVM_BUILD_LLVM_DYLIB ""Build libllvm dynamic library"" ${LLVM_BUILD_LLVM_DYLIB_default}); endif(). if (LLVM_LINK_LLVM_DYLIB AND BUILD_SHARED_LIBS); message(FATAL_ERR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:33389,config,config,33389,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config']
Modifiability,"(address_sanitizer)``. The same attribute used on a global variable prevents AddressSanitizer; from adding redzones around it and detecting out of bounds accesses. AddressSanitizer also supports; ``__attribute__((disable_sanitizer_instrumentation))``. This attribute; works similar to ``__attribute__((no_sanitize(""address"")))``, but it also; prevents instrumentation performed by other sanitizers. Suppressing Errors in Recompiled Code (Ignorelist); --------------------------------------------------. AddressSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress error reports; in the specified source files or functions. Additionally, AddressSanitizer; introduces ``global`` and ``type`` entity types that can be used to; suppress error reports for out-of-bound access to globals with certain; names and types (you may only specify class or struct types). You may use an ``init`` category to suppress reports about initialization-order; problems happening in certain source files or with certain global variables. .. code-block:: bash. # Suppress error reports for code in a file or in a function:; src:bad_file.cpp; # Ignore all functions with names containing MyFooBar:; fun:*MyFooBar*; # Disable out-of-bound checks for global:; global:bad_array; # Disable out-of-bound checks for global instances of a given class ...; type:Namespace::BadClassName; # ... or a given struct. Use wildcard to deal with anonymous namespace.; type:Namespace2::*::BadStructName; # Disable initialization-order checks for globals:; global:bad_init_global=init; type:*BadInitClassSubstring*=init; src:bad/init/files/*=init. Suppressing memory leaks; ------------------------. Memory leak reports produced by :doc:`LeakSanitizer` (if it is run as a part; of AddressSanitizer) can be suppressed by a separate file passed as. .. code-block:: bash. LSAN_OPTIONS=suppressions=MyLSan.supp. which contains lines of the form `leak:<pattern>`. Memory leak will be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:10516,variab,variables,10516,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['variab'],['variables']
Modifiability,"(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }; ~~~. Validation code `$ROOTSYS/test/vmatrix.cxx` and `vvector.cxx` contain; a few more examples of that kind. #### 6. Lazy matrices:. instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:. ~~~ {.cpp}; TMatrixD haar = THaarMatrixD(5);; ~~~. THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. ### Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md:19288,adapt,adapted,19288,math/matrix/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md,2,['adapt'],['adapted']
Modifiability,"(ffastmath). Misc/mandel will like this. :) This isn't; safe in general, even on darwin. See the libm implementation of hypot for; examples (which special case when x/y are exactly zero to get signed zeros etc; right). //===---------------------------------------------------------------------===//. On targets with expensive 64-bit multiply, we could LSR this:. for (i = ...; ++i) {; x = 1ULL << i;. into:; long long tmp = 1;; for (i = ...; ++i, tmp+=tmp); x = tmp;. This would be a win on ppc32, but not x86 or ppc64. //===---------------------------------------------------------------------===//. Shrink: (setlt (loadi32 P), 0) -> (setlt (loadi8 Phi), 0). //===---------------------------------------------------------------------===//. Reassociate should turn things like:. int factorial(int X) {; return X*X*X*X*X*X*X*X;; }. into llvm.powi calls, allowing the code generator to produce balanced; multiplication trees. First, the intrinsic needs to be extended to support integers, and second the; code generator needs to be enhanced to lower these to multiplication trees. //===---------------------------------------------------------------------===//. Interesting? testcase for add/shift/mul reassoc:. int bar(int x, int y) {; return x*x*x+y+x*x*x*x*x*y*y*y*y;; }; int foo(int z, int n) {; return bar(z, n) + bar(2*z, 2*n);; }. This is blocked on not handling X*X*X -> powi(X, 3) (see note above). The issue; is that we end up getting t = 2*X s = t*t and don't turn this into 4*X*X,; which is the same number of multiplies and is canonical, because the 2*X has; multiple uses. Here's a simple example:. define i32 @test15(i32 %X1) {; %B = mul i32 %X1, 47 ; X1*47; %C = mul i32 %B, %B; ret i32 %C; }. //===---------------------------------------------------------------------===//. Reassociate should handle the example in GCC PR16157:. extern int a0, a1, a2, a3, a4; extern int b0, b1, b2, b3, b4; ; void f () { /* this can be optimized to four additions... */ ; b4 = a4 + a3 + a2 + a1 + a0; ;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:1644,extend,extended,1644,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,2,"['enhance', 'extend']","['enhanced', 'extended']"
Modifiability,"(hasTargetDecl(functionDecl()))); matches using X::b but not using X::a ; Matcher<UsingType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<UsingType>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;; typeLoc(loc(usingType(throughUsingDecl(anything())))); matches X. Usable as: Matcher<DeclRefExpr>, Matcher<UsingType>. Matcher<ValueDecl>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<ValueDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:252163,variab,variable,252163,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"(n1,n4);; gs->AddEdge(n1,n6);; gs->AddEdge(n2,n5);; gs->AddEdge(n3,n6);; gs->AddEdge(n4,n5);. TCanvas *c = new TCanvas(""c"",""c"",800,600);; c->SetFillColor(38);; gs->Draw();; return c;; }; . This new funtionnality relies on the graphivz package.; This package can be downloaded from; http://www.graphviz.org/. At installation time, to find graphviz, the ROOT's configure file looks in; standard locations. It is possible to define a specific location using the; configure flags:. --with-gviz-incdir=""the directory where gvc.h is""; --with-gviz-libdir=""the directory where the libgvc library is"". To install graphviz (if needed) it is recommended to use the following configure flags:. --enable-static=yes --enable-shared=no --with-pic --prefix=""graphviz installed here"". On 64 bits machines, the ROOT sources are compiled with the option -m64. In; that case graphviz should be also compiled in 64 bits mode. It might be the; default option, but on some machine it is not. In that case the environment; variable CC should be defined as:. CC=""gcc -m64"". before doing configure. On Windows machines it recommended to not install graphviz but to download the; pre-installed version from http://www.graphviz.org/. The ROOT configure command; remains the same.; Graphics Primitives; New class TGraphTime; TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax.; each time step has a new list of objects. This list can be identical to; the list of objects in the previous steps, but with different attributes.; see example of use in $ROOTSYS/tutorials/graphs/gtime.C. TLatex. In the following macro the #int and #sum symbols had; wrong limits placement if the character just before started with ""#"".; ; {; TCanvas *c1 = new TCanvas(""c1"",""c1"",500,500);; TLatex l;; l.SetTextSize(0.1);. l.DrawLatex(0.1,0.6,""#nu#int^{1-x}_{2#pi}"");; l.DrawLatex(0.1,0.2,""a#int^{1-x}_{2#pi}"");. l.DrawLatex(0.5,0.6,""#nu#sum^{1-x}_{2#pi}"");; l.DrawLatex(0.5,0.2,""a#sum^{1-x}_{2#pi}"");; }; . T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html:4122,variab,variable,4122,graf2d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html,1,['variab'],['variable']
Modifiability,"(normally ~10000 nodes and ~200000 elementary faces are shown); - all - try to display all geometry volumes (may lead to browser hanging); - maxnodesN - configure maximal number of rendered nodes (like maxnodes100K); - maxfacesN - configure maximal number of rendered faces (like maxfaces3M); - highlight - force highlighting of selected volume, normally activated for moderate-size geometries; - nohighlight - disable volumes highlighting (can be activated via context menu); - hscene - enable highlight of extra objects like tracks or hits; - hsceneonly - enable only highlight of extra objects like tracks or hits; - nohscene - disable highlight of extra objects like tracks or hits; - macro:name.C - invoke ROOT configuration macro; - dflt - set default volumes colors as TGeoManager::DefaultColors() does; - transpXY - set global transparency value (XY is number between 1 and 99); - zoomFACTOR - set initial zoom factor (FACTOR is integer value from 1 to 10000, default is 100); - rotyANGLE - set Y rotation angle in degrees (like roty10); - rotzANGLE - set Z rotation angle in degrees (like rotz20); - rotate - enable automatic rotation of the geometry; - trzVALUE - set transformation along Z axis (like trz50); - trrVALUE - set radial transformation (like trr100); - ortho_camera - use THREE.OrthographicCamera without possibility to rotate it; - ortho_camera_rotate - use THREE.OrthographicCamera and enable it rotation; - ctrl - show control UI from the beginning; - tracks - show tracks from TGeoManager; - showtop - show top-level volume of TGeoManager (default off); - no_screen - let ignore kVisOnScreen bits for nodes visibility; - dray - calculate rendering order using raytracing (extensive calculations); - dbox - use distance to nearest point from bounding box for rendering order (default); - dpnt - use distance to shape center as rendering order; - dsize - use volume size as rendering order; - ddflt - let three.js to calculate rendering order; - comp - show left and right com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:20903,config,configuration,20903,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configuration']
Modifiability,"(pointerType()))))); void f(int i[]) {; i[1] = 0;; }. Matcher<Type>decltypeTypeMatcher<DecltypeType>...; Matches types nodes representing C++11 decltype(<expr>) types. Given:; short i = 1;; int j = 42;; decltype(i + j) result = i + j;; decltypeType(); matches ""decltype(i + j)"". Matcher<Type>deducedTemplateSpecializationTypeMatcher<DeducedTemplateSpecializationType>...; Matches C++17 deduced template specialization types, e.g. deduced class; template types. Given; template <typename T>; class C { public: C(T); };. C c(123);; deducedTemplateSpecializationType() matches the type in the declaration; of the variable c. Matcher<Type>dependentSizedArrayTypeMatcher<DependentSizedArrayType>...; Matches C++ arrays whose size is a value-dependent expression. Given; template<typename T, int Size>; class array {; T data[Size];; };; dependentSizedArrayType(); matches ""T data[Size]"". Matcher<Type>dependentSizedExtVectorTypeMatcher<DependentSizedExtVectorType>...; Matches C++ extended vector type where either the type or size is; dependent. Given; template<typename T, int Size>; class vector {; typedef T __attribute__((ext_vector_type(Size))) type;; };; dependentSizedExtVectorType(); matches ""T __attribute__((ext_vector_type(Size)))"". Matcher<Type>elaboratedTypeMatcher<ElaboratedType>...; Matches types specified with an elaborated type keyword or with a; qualified name. Given; namespace N {; namespace M {; class D {};; }; }; class C {};. class C c;; N::M::D d;. elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it doe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:47253,extend,extended,47253,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['extend'],['extended']
Modifiability,"(void); {; spin_lock(&mtx1);; spin_lock(&mtx1);	// warn: This lock has already been acquired; }. alpha.llvm; ^^^^^^^^^^. .. _alpha-llvm-Conventions:. alpha.llvm.Conventions; """""""""""""""""""""""""""""""""""""""""""". Check code for LLVM codebase conventions:. * A StringRef should not be bound to a temporary std::string whose lifetime is shorter than the StringRef's.; * Clang AST nodes should not have fields that can allocate memory. alpha.osx; ^^^^^^^^^. .. _alpha-osx-cocoa-DirectIvarAssignment:. alpha.osx.cocoa.DirectIvarAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. .. _alpha-osx-cocoa-DirectIvarAssignmentForAnnotatedFunctions:. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:57655,variab,variables,57655,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variables']
Modifiability,") ;; w->factory(""Gaussian::g(x[-10,10],m[-10,10],s[3,0.1,10])""); w->factory(""Uniform::u(x)""); w->factory(""index[S,B]""); RooDataSet* d1 = w::g.generate(w::x,1000); RooDataSet* d2 = w::u.generate(w::x,1000). // Make monolithic composite dataset (copies input data); RooDataSet d12(""d12"",""d12"",w::x,Index(w::index),Import(""S"",*d1),Import(""B"",*d2)). //-----------------------------------------------------------------------------; // NEW: make virtual composite dataset (input data is linked, no data is copied); RooDataSet d12a(""d12a"",""d12a"",w::x,Index(w::index),Link(""S"",*d1),Link(""B"",*d2)); //-----------------------------------------------------------------------------. // Fit composite dataset to dummy model; w->factory(""SUM::model(fsig[0,1]*g,u)""); w::model.fitTo(d12a). For virtual composite dataset it is also possible to join a mix of binned and unbinned datasets; (representation as a RooDataSet with weights). The setWeightVar() method has been deprecated as it is very difficult to support on-the-fly redefinition; of the event weight variable in the new data store scheme. To declare a data set weighed,; use the WeightVar() modifier of the constructor instead,e.g.:. RooDataSet wdata(""wdata"",""wdata"",RooArgSet(x,y,wgt),WeightVar(wgt)) ;. The RooHist class that represents data as a histogram in a RooPlot has been modified; so that it can show approximate Poisson errors for non-integer data. These approximate; errors are calculated from interpolation of the error bars of the nearest integers. NB: A weighted dataset; plotted with RooAbsData::plotOn() will be default show sum-of-weights-squared errors. Only; when Poisson error are forced through a DataError(RooAbsData::Poisson) argument these; approximate Poisson error bars are shown. Miscellaneous improvements other. The RooFit messagee service class RooMsgService has been augmented with a stack that; can store its configurate state information. A call to saveState() will save the; present configuration, which can be restored t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:9935,variab,variable,9935,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['variab'],['variable']
Modifiability,") are drawn. In some cases one wants to not draw empty bins; (containing 0) of histograms having a negative minimum. The option `1`, used with; the option `COL`, allows to do that. Implement the Log option for `CANDLE` plots as requested; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20225&p=87006#p87006). ### TTeXDump. From Dmitry Kalinkin (via github): Fix file corruption in `TTeXDump::DrawPolyMarker`; The current implementation of `TTeXDump` uses `TVirtualPS::PrintFast` based methods; to output TeX markup with automatic line-wraps. Yet these methods are optimized for; PostScript format where there are a lot of space characters that are used for newline; placement. Current `TTeXDump::DrawPolyMarker` would often produce a long contiguous lines; that trigger a forceful linewrap that can happen in the middle of real number constant; (ignored by latex) or even in the middle of latex command (producing incorrect file).; One solution would be to rewrite TTeXDump using only `PrintRaw` (that you can't mix; with `PrintStr/PrintFast/WriteReal`). The other would be to fix `PrintFast` to not; introduce forced newline. The third option is less intrusive and just adds additional; spaces to provide clues for the proper line wrapping (this is the one implemented in; this change). ### TLatex. Make sure the line width used to draw `#sqrt` is always >= 1. When a global text alignment was set the `TLatex`characters `#minus`, `#plus`,; `#mp`, `#hbar`, and `#backslash` were mis-aligned. The following macro demonstrate; the problem:. ``` {.cpp}; {; gStyle->SetTextAlign(22);; TLatex t(.5,.5,""#minus100 #mp100 #plus100 #hbar #backslash"");; t.Draw();; }; ```. The angle of a `TLatex` object was set to 0 if the `GetYsize` method was called. ### TColor. New palette `kViridis`. It was presented at SciPy2015 by Stéfan van der Walt and; Nathaniel Smith. It is now matplotlib's current default color map. ![Viridis](palette_112.png). ### TMultiGraph. Ignore empty graphs when computing the m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:15732,rewrite,rewrite,15732,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['rewrite'],['rewrite']
Modifiability,") const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``create",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:2859,refactor,refactoring,2859,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactoring']
Modifiability,") h->Fill(85);; ```; results in `GetMean` and `GetStdDev` returning 67.5 and 17.5, respectively;; you must call `TH1::ResetStats` again to get consistent binned statistics. ## Alphanumeric Bin Labels. By default, a histogram axis is drawn with its numeric bin labels. One; can specify alphanumeric labels instead. ### Option 1: SetBinLabel. To set an alphanumeric bin label call:. ``` {.cpp}; TAxis::SetBinLabel(bin,label);; ```. This can always be done before or after filling. Bin labels will be; automatically drawn with the histogram. ![Histograms with alphanumeric bin labels](pictures/0600003B.png). See example in `$ROOTSYS/tutorials/hist/hlabels1.C` , `hlabels2.C`. ### Option 2: Fill. You can also call a `Fill()` function with one of the arguments being; a string:. ``` {.cpp}; hist1->Fill(somename,weigth);; hist2->Fill(x,somename,weight);; hist2->Fill(somename,y,weight);; hist2->Fill(somenamex,somenamey,weight);; ```. ### Option 3: TTree::Draw. You can use a char\* variable type to histogram strings with; **`TTree`**`::Draw()`. ``` {.cpp}; // here ""Nation"" and ""Division"" are two char* branches of a Tree; tree.Draw(""Nation::Division"", """", ""text"");; ```. ![Using a \*char variable type in TTree::Draw](pictures/0200003C.png). There is an example in `$ROOTSYS/tutorials/tree/cernstaff.C.`. If a variable is defined as `char*` it is drawn as a string by default.; You change that and draw the value of `char[0]` as an integer by; adding an arithmetic operation to the expression as shown below. ``` {.cpp}; // draw the integer value of MyChar[0] where ""MyChar"" is char[5]; tree.Draw(""MyChar + 0"");; ```. ### Sort Options. When using the options 2 or 3 above, the labels are automatically; added to the list (**`THashList`**) of labels for a given axis. By; default, an axis is drawn with the order of bins corresponding to the; filling sequence. It is possible to reorder the axis alphabetically or; by increasing or decreasing values. The reordering can be triggered; via the **`TAxis`*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:56886,variab,variable,56886,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variable']
Modifiability,") is presented in the following table:. | # of iterations | Chi awmi | Chi-Stiefel |; | ---------------- | ---------| ------------ |; | 1 | 24.989 | 10.415 |; | 5 | 20.546 | 1.0553 |; | 10 | 6.256 | 0.84383 |; | 50 | 1.0985 | 0.64297 |; | 100 | 0.6571 | 0.64297 |; | 500 | 0.65194 | 0.64297 |. Again, Stiefel-Hestens method converges faster. However, its calculation; is for this number of parameters takes approximately 3 times longer. For; larger number of parameters the time needed to calculate the inversion; grows with the cube of the number of fitted parameters. For example, the; fit of large number of parameters (2068) for data in Figure 5.8 using awmi; algorithm took about 12 hours (using 450 MHz PC). The calculation; using matrix inversion method is not realizable in any reasonable time. # TRANSFORMS. ## 1-DIMENSIONAL SPECTRA. Orthogonal transforms can be successfully used for the; processing of nuclear spectra. They can be used to remove high; frequency noise, to increase signal-to-background ratio as well as to; enhance low intensity components [14]. We have implemented also the; function for the calculation of the commonly used orthogonal transforms:. - Haar; - Walsh; - Cos; - Sin; - Fourier; - Hartley. Between these transform one can define so called generalized mixed; transforms that are also implemented in the transform function:. - Fourier-Haar; - Fourier-Walsh; - Walsh-Haar; - Cos-Walsh; - Cos-Haar; - Sin-Walsh; - Sin-Haar. The suitability of the application of appropriate transform depends on; the character of the data, i.e., on the shape of dominant components; contained in the data. The form of the transform function is as follows:. ```{.cpp}; char *Transform1(const float *source,; float *dest,; int size,; int type,; int direction,; int degree);; ```. This function transforms the source spectrum. The calling program; should fill in the input parameters. Transformed data are written into the dest spectrum. Function parameters:. - **`source`**: pointer t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:58027,enhance,enhance,58027,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['enhance'],['enhance']
Modifiability,") looking for tests. When :program:`lit`; enters a sub-directory, it first checks to see if a nested test suite is; defined in that directory. If so, it loads that test suite recursively,; otherwise it instantiates a local test config for the directory (see; :ref:`local-configuration-files`). Tests are identified by the test suite they are contained within, and the; relative path inside that suite. Note that the relative path may not refer to; an actual file on disk; some test formats (such as *GoogleTest*) define; ""virtual tests"" which have a path that contains both the path to the actual; test file and a subpath to identify the virtual test. .. _local-configuration-files:. LOCAL CONFIGURATION FILES; ~~~~~~~~~~~~~~~~~~~~~~~~~. When :program:`lit` loads a subdirectory in a test suite, it instantiates a; local test configuration by cloning the configuration for the parent directory; --- the root of this configuration chain will always be a test suite. Once the; test configuration is cloned :program:`lit` checks for a *lit.local.cfg* file; in the subdirectory. If present, this file will be loaded and can be used to; specialize the configuration for each individual directory. This facility can; be used to define subdirectories of optional tests, or to change other; configuration parameters --- for example, to change the test format, or the; suffixes which identify test files. SUBSTITUTIONS; ~~~~~~~~~~~~~. :program:`lit` allows patterns to be substituted inside RUN commands. It also; provides the following base set of substitutions, which are defined in; TestRunner.py:. ======================= ==============; Macro Substitution; ======================= ==============; %s source path (path to the file currently being run); %S source dir (directory of the file currently being run); %p same as %S; %{pathsep} path separator; %{fs-src-root} root component of file system paths pointing to the LLVM checkout; %{fs-tmp-root} root component of file system paths pointing to the tes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:18517,config,configuration,18517,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['configuration']
Modifiability,") macro. ## Customize user interface. JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - [see example](https://root.cern/js/latest/httpserver.C/). JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items [item=Files/job1.root/hpxpy&opt=colz&monitoring=1000](https://root.cern/js/latest/httpserver.C/?item=Files/job1.root/hpxpy&opt=colz&monitoring=1000). Some of such parameters can be configured already on the server:. ```cpp; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; ```. In such case URL parameters are not required - specified item will be displayed automatically when web page is opened.; One also can configure to display several items at once. For that one also can configure layout of the drawing area:. ```cpp; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; ```. One also can change appearance of hierarchy browser on the left side of the web page:. ```cpp; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; ```. If necessary, one also can automatically open ROOT file when web page is opened:. ```cpp; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; ```. ## Configuring user access. By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the **htdigest** utilit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:7327,config,configure,7327,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configure']
Modifiability,") or a publicly available simulator/hardware; (either free or cheap enough) - preferably both. This allows; developers to validate assumptions, understand constraints and review code; that can affect the target. In addition, the rules for a back-end to be promoted to **official** are:. * The target must have addressed every other minimum requirement and; have been stable in tree for at least 3 months. This cool down; period is to make sure that the back-end and the target community can; endure continuous upstream development for the foreseeable future. * The target's code must have been completely adapted to this policy; as well as the :doc:`coding standards<CodingStandards>`. Any exceptions that; were made to move into experimental mode must have been fixed **before**; becoming official. * The test coverage needs to be broad and well written (small tests,; well documented). The build target ``check-all`` must pass with the; new target built, and where applicable, the ``test-suite`` must also; pass without errors, in at least one configuration (publicly; demonstrated, for example, via buildbots). * Public buildbots need to be created and actively maintained, unless; the target requires no additional buildbots (ex. ``check-all`` covers; all tests). The more relevant and public the new target's CI infrastructure; is, the more the LLVM community will embrace it. To **continue** as a supported and official target:. * The maintainer(s) must continue following these rules throughout the lifetime; of the target. Continuous violations of aforementioned rules and policies; could lead to complete removal of the target from the code base. * Degradation in support, documentation or test coverage will make the target as; nuisance to other targets and be considered a candidate for deprecation and; ultimately removed. In essence, these rules are necessary for targets to gain and retain their; status, but also markers to define bit-rot, and will be used to clean up the; tree from u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:41999,config,configuration,41999,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['config'],['configuration']
Modifiability,") {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it do",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61732,variab,variable,61732,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variable']
Modifiability,"),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable; ""`var`"" in the **`TTree`** `tree` versus variable `v1 in `TTree ft1`; versus variable `v2` in **`TTree`** `ft2`. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; ```. ![](pictures/02000102.jpg)The picture illustrates the access of the tree; and its friends with a `Draw` command. When `AddFriend` is called, the ROOT file is automatically opened and; the friend tree (`ft1)` header is read into memory. The new friend; (`ft1`) is added to the list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:53842,variab,variables,53842,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,")->getParent();. // Register all variables and emit their initializer.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i) {; const std::string &VarName = VarNames[i].first;; ExprAST *Init = VarNames[i].second.get();. Basically it loops over all the variables, installing them one at a; time. For each variable we put into the symbol table, we remember the; previous value that we replace in OldBindings. .. code-block:: c++. // Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.; Value *InitVal;; if (Init) {; InitVal = Init->codegen();; if (!InitVal); return nullptr;; } else { // If not specified, use 0.0.; InitVal = ConstantFP::get(*TheContext, APFloat(0.0));; }. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);; Builder->CreateStore(InitVal, Alloca);. // Remember the old variable binding so that we can restore the binding when; // we unrecurse.; OldBindings.push_back(NamedValues[VarName]);. // Remember this binding.; NamedValues[VarName] = Alloca;; }. There are more comments here than code. The basic idea is that we emit; the initializer, create the alloca, then update the symbol table to; point to it. Once all the variables are installed in the symbol table,; we evaluate the body of the var/in expression:. .. code-block:: c++. // Codegen the body, now that all vars are in scope.; Value *BodyVal = Body->codegen();; if (!BodyVal); return nullptr;. Finally, before returning, we restore the previous variable bindings:. .. code-block:: c++. // Pop all our variables from scope.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i); NamedValues[VarNames[i].first] = OldBindings[i];. // Return the body computation.; return BodyVal;; }. The end result of all of this is that we get properly scoped variable; definitions, and we even (trivially) allow mutation of them :). With this, we co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:27686,variab,variable,27686,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. # Recursive fib, we could do this before.; def fib(x); if (x < 3) then; 1; else; fib(x-1)+fib(x-2);. # Iterative fib.; def fibi(x); var a = 1, b = 1, c in; (for i = 3, i < x in; c = a + b :; a = b :; b = c) :; b;. # Call it.; fibi(10);. In order to mutate variables, we have to change our existing variables; to use the ""alloca trick"". Once we have that, we'll add our new; operator, then extend Kaleidoscope to support new variable definitions. Adjusting Existing Variables for Mutation; =========================================. The symbol table in Kaleidoscope is managed at code generation time by; the '``NamedValues``' map. This map currently keeps track of the LLVM; ""Value\*"" that holds the double value for the named variable. In order; to support mutation, we need to change this slightly, so that; ``NamedValues`` holds the *memory location* of the variable in question.; Note that this change is a refactoring: it changes the structure of the; code, but does not (by itself) change the behavior of the compiler. All; of these changes are isolated in the Kaleidoscope code generator. At this point in Kaleidoscope's development, it only supports variables; for two things: incoming arguments to functions and the induction; variable of 'for' loops. For consistency, we'll allow mutation of these; variables in addition to other user-defined variables. This means that; these will both need memory locations. To start our transformation of Kaleidoscope, we'll change the; ``NamedValues`` map so that it maps to AllocaInst\* instead of Value\*. Once; we do this, the C++ compiler will tell us what parts of the code we need; to update:. .. code-block:: c++. static std::map",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:11759,variab,variable,11759,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"). Command line; options default to being optional, so if we would like to require that the user; always specify an input filename, we would add the `cl::Required`_ flag, and we; could eliminate the `cl::init`_ modifier, like this:. .. code-block:: c++. cl::opt<string> InputFilename(cl::Positional, cl::desc(""<input file>""), cl::Required);. Again, the CommandLine library does not require the options to be specified in; any particular order, so the above declaration is equivalent to:. .. code-block:: c++. cl::opt<string> InputFilename(cl::Positional, cl::Required, cl::desc(""<input file>""));. By simply adding the `cl::Required`_ flag, the CommandLine library will; automatically issue an error if the argument is not specified, which shifts all; of the command line option verification code out of your application into the; library. This is just one example of how using flags can alter the default; behaviour of the library, on a per-option basis. By adding one of the; declarations above, the ``-help`` option synopsis is now extended to:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. ... indicating that an input filename is expected. Boolean Arguments; -----------------. In addition to input and output filenames, we would like the compiler example to; support three boolean flags: ""``-f``"" to force writing binary output to a; terminal, ""``--quiet``"" to enable quiet mode, and ""``-q``"" for backwards; compatibility with some of our users. We can support these by declaring options; of boolean type like this:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Enable binary output on terminals""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::opt<bool> Quiet2(""q"", cl::desc(""Don't print informational messages""), cl::Hidden);. This does what you would expect: it declares three boolean variables; (""``Force``"", ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:8549,extend,extended,8549,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['extend'],['extended']
Modifiability,"). The first argument is the name of the; pass, which is to be used for the :option:`-help` output of programs, as well; as for debug output generated by the `--debug-pass` option. If you want your pass to be easily dumpable, you should implement the virtual; print method:. The ``print`` method; ^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual void print(llvm::raw_ostream &O, const Module *M) const;. The ``print`` method must be implemented by ""analyses"" in order to print a; human readable version of the analysis results. This is useful for debugging; an analysis itself, as well as for other people to figure out how an analysis; works. Use the opt ``-analyze`` argument to invoke this method. The ``llvm::raw_ostream`` parameter specifies the stream to write the results; on, and the ``Module`` parameter gives a pointer to the top level module of the; program that has been analyzed. Note however that this pointer may be ``NULL``; in certain circumstances (such as calling the ``Pass::dump()`` from a; debugger), so it should only be used to enhance debug output, it should not be; depended on. .. _writing-an-llvm-pass-interaction:. Specifying interactions between passes; --------------------------------------. One of the main responsibilities of the ``PassManager`` is to make sure that; passes interact with each other correctly. Because ``PassManager`` tries to; :ref:`optimize the execution of passes <writing-an-llvm-pass-passmanager>` it; must know how the passes interact with each other and what dependencies exist; between the various passes. To track this, each pass can declare the set of; passes that are required to be executed before the current pass, and the passes; which are invalidated by the current pass. Typically this functionality is used to require that analysis results are; computed before your pass is run. Running arbitrary transformation passes can; invalidate the computed analysis results, which is what the invalidation set; specifies. If a pass does no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:28324,enhance,enhance,28324,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['enhance'],['enhance']
Modifiability,"). This code basically just creates; and returns a ``ConstantFP``. Note that in the LLVM IR that constants; are all uniqued together and shared. For this reason, the API uses the; ""foo::get(...)"" idiom instead of ""new foo(..)"" or ""foo::Create(..)"". .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; Value *V = NamedValues[Name];; if (!V); LogErrorV(""Unknown variable name"");; return V;; }. References to variables are also quite simple using LLVM. In the simple; version of Kaleidoscope, we assume that the variable has already been; emitted somewhere and its value is available. In practice, the only; values that can be in the ``NamedValues`` map are function arguments.; This code simply checks to see that the specified name is in the map (if; not, an unknown variable is being referenced) and returns the value for; it. In future chapters, we'll add support for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(TheContext),; ""booltmp"");; default:; return LogErrorV(""invalid binary operator"");; }; }. Binary operators start to get more interesting. The basic idea here is; that we recursively emit code for the left-hand side of the expression,; then the right-hand side, then we compute the result of the binary; expression. In this code, we do a simple switch on the opcode to create; the right LLVM instruction. In the example above, the LLVM builder cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:6313,variab,variables,6313,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variables']
Modifiability,").; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162469,variab,variable,162469,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['variab'],['variable']
Modifiability,").getReg()));. if (CurOp != NumOps) {; const MachineOperand &MO1 = MI.getOperand(CurOp++);; unsigned Size = X86InstrInfo::sizeOfImm(Desc);; if (MO1.isImmediate()); emitConstant(MO1.getImm(), Size);; else {; unsigned rt = Is64BitMode ? X86::reloc_pcrel_word; : (IsPIC ? X86::reloc_picrel_word : X86::reloc_absolute_word);; if (Opcode == X86::MOV64ri); rt = X86::reloc_absolute_dword; // FIXME: add X86II flag?; if (MO1.isGlobalAddress()) {; bool NeedStub = isa<Function>(MO1.getGlobal());; bool isLazy = gvNeedsLazyPtr(MO1.getGlobal());; emitGlobalAddress(MO1.getGlobal(), rt, MO1.getOffset(), 0,; NeedStub, isLazy);; } else if (MO1.isExternalSymbol()); emitExternalSymbolAddress(MO1.getSymbolName(), rt);; else if (MO1.isConstantPoolIndex()); emitConstPoolAddress(MO1.getIndex(), rt);; else if (MO1.isJumpTableIndex()); emitJumpTableAddress(MO1.getIndex(), rt);; }; }; break;. In the previous example, ``XXXCodeEmitter.cpp`` uses the variable ``rt``, which; is a ``RelocationType`` enum that may be used to relocate addresses (for; example, a global address with a PIC base offset). The ``RelocationType`` enum; for that target is defined in the short target-specific ``XXXRelocations.h``; file. The ``RelocationType`` is used by the ``relocate`` method defined in; ``XXXJITInfo.cpp`` to rewrite addresses for referenced global symbols. For example, ``X86Relocations.h`` specifies the following relocation types for; the X86 addresses. In all four cases, the relocated value is added to the; value already in memory. For ``reloc_pcrel_word`` and ``reloc_picrel_word``,; there is an additional initial adjustment. .. code-block:: c++. enum RelocationType {; reloc_pcrel_word = 0, // add reloc value after adjusting for the PC loc; reloc_picrel_word = 1, // add reloc value after adjusting for the PIC base; reloc_absolute_word = 2, // absolute relocation; no additional adjustment; reloc_absolute_dword = 3 // absolute relocation; no additional adjustment; };. Target JIT Info; ---------------. ``XXXJI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:81008,variab,variable,81008,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['variab'],['variable']
Modifiability,")/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseTTFonts: true; Unix.*.Root.TTFontPath:; ...; # Activate memory statistics; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; ```. The various options are explained in `$ROOTSYS/etc/system.rootrc`. The; `.rootrc` file contents are combined. For example, if the flag to use; true type fonts is set to true in the `system.rootrc` file, you have; to set explicitly it false in your local `.rootrc` file if you do not; want to use true type fonts. Removing the `UseTTFonts `statement in; the local `.rootrc` file will not disable true fonts. The value of the; environment variable `ROOTDEBUG` overrides the value in the `.rootrc`; file at startup. Its value is used to set ***`gDebug`*** and helps for; quick turn on debug mode in **`TROOT`** startup. ROOT looks for scripts in the path specified in the `.rootrc` file in; the `Root.Macro.Path` variable. You can expand this path to hold your; own directories. ### Logon and Logoff Scripts. The `rootlogon.C` and `rootlogoff.C` files are scripts loaded and; executed at start-up and shutdown. The `rootalias.C` file is loaded; but not executed. It typically contains small utility functions. For; example, the `rootalias.C` script that comes with the ROOT; distributions (located in `$ROOTSYS/tutorials)` defines the function; `edit(char *file)`. This allows the user to call the editor from the; command line. This particular function will start the VI editor if the; environment variable `EDITOR` is not set. ``` {.cpp}; root[0] edit(""c1.C""); ```. For more details, see `$ROOTSYS/tutorials/rootalias.C`. ### History File. You can use the up and down arrow at the command line, to access the; previous and next command. The commands are recorded in the history; file `$HOME/.root_hist`. It is a text file, and you can edit, cut, and; paste from it. You can specify the history file in the `system",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:37689,variab,variable,37689,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['variab'],['variable']
Modifiability,"); ==============================================. .. contents::; :local:. .. _arc.meta:. About this document; ===================. .. _arc.meta.purpose:. Purpose; -------. The first and primary purpose of this document is to serve as a complete; technical specification of Automatic Reference Counting. Given a core; Objective-C compiler and runtime, it should be possible to write a compiler and; runtime which implements these new semantics. The secondary purpose is to act as a rationale for why ARC was designed in this; way. This should remain tightly focused on the technical design and should not; stray into marketing speculation. .. _arc.meta.background:. Background; ----------. This document assumes a basic familiarity with C. :arc-term:`Blocks` are a C language extension for creating anonymous functions.; Users interact with and transfer block objects using :arc-term:`block; pointers`, which are represented like a normal pointer. A block may capture; values from local variables; when this occurs, memory must be dynamically; allocated. The initial allocation is done on the stack, but the runtime; provides a ``Block_copy`` function which, given a block pointer, either copies; the underlying block object to the heap, setting its reference count to 1 and; returning the new block pointer, or (if the block object is already on the; heap) increases its reference count by 1. The paired function is; ``Block_release``, which decreases the reference count by 1 and destroys the; object if the count reaches zero and is on the heap. Objective-C is a set of language extensions, significant enough to be; considered a different language. It is a strict superset of C. The extensions; can also be imposed on C++, producing a language called Objective-C++. The; primary feature is a single-inheritance object system; we briefly describe the; modern dialect. Objective-C defines a new type kind, collectively called the :arc-term:`object; pointer types`. This kind has two notable builtin ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:2575,variab,variables,2575,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"); >; > - [CernVM 2.7.1 batch 64-bit for; > **Xen**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.ext3.gz); >; > Images are gzipped. In most cases you'll need to gunzip them before; > registering to your image repository. ### Create VM configuration profiles. CernVM images are base images supporting boot-time customization via; configuration profiles called ""contexts"". Context creation can be; performed through the [CernVM Online](https://cernvm-online.cern.ch/); website. The site is immediately accessible if you have a CERN account. Go to your [CernVM Online; Dashboard](https://cernvm-online.cern.ch/dashboard), click on the; **Create new context...** dropdown and select **Virtual Analysis Facility; node**. There's only a few parameters to configure. Context name; : A name for your context (such as *VAF Master for ATLAS*). Any name; will work. Role; : Use this to configure either a *master* or a *slave*. VAF master (only available when configuring a slave); : IP address or FQDN of the Virtual Analysis Facility master. Auth method; : Choose between *ALICE LDAP* (useful only for ALICE users) or *Pool; accounts* (good for authenticating all the other Grid users). Num. pool accounts (only available when using pool accounts auth); : Number of pool accounts to create. Proxy for CVMFS; : An URL specifying the proxy server for CernVM-FS, such as; `http://ca-proxy.cern.ch:3128/`. If you leave it empty, proxy will; be automatically discovered. HTCondor shared secret; : VMs part of the same cluster should have the same value of this; field. It is used to mutually authenticate VMs and it is used like a; password. Context password; : Current profile will be saved on the [CernVM Online; repository](http://cernvm-online.cern.ch/). If you don't want the; information there to be publicly available to other users, type in; a value for protecting the context with an encryption password. You will have to create a profile for the **master** and the **slave**. Si",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:2345,config,configuring,2345,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['config'],['configuring']
Modifiability,"); ~~~. Example:. ~~~{.cpp}; // Writing to a file geometry definition ending with:; root[] gGeoManager->CloseGeometry();; // geometry is ready; root[] gGeoManager->Export(""MyGeom.root"");; // file MyGeom.root produced; root[] gGeoManager->Export(""MyGeom.C"");; // C++ macro MyGeom.C produced; root[] gGeoManager->Export(""MyGeom.gdml"");; // GDML file MyGeom.gdml produced; root[] myVolume->SaveAs(""MyVolume.C"");; // C++ macro for the branch starting; // with MyVolume; // Reading from a file; root[] gSystem->Load(""libGeom"");; root[] TGeoManager::Import(""MyGeom.root""); // geometry is ready; ~~~. Note that not all-current information held by the modeller is written on; the file. For instance, the painter and checker objects are not written,; as well as the temporary current navigation properties: current node; path, point or direction. On the other hand, all objects belonging to; the geometrical hierarchy will always be written. The idea is to be able; to retrieve the geometry in a ready state, ignoring what the state; variables that can be always re-initialized. When the code is generated; for a given TGeoVolume in the geometry, just the branch starting; with that volume will be saved in the file. Executing the generated code; will create a geometry that has `MyVolume` as top volume. In this case,; only the materials/media/matrices used effectively in the `MyVolume`; branch are exported to file. Volumes can be made persistent in the same way the full geometry is.; Exporting is straightforward (module1, 2 are pointers to; TGeoVolume objects):. ~~~{.cpp}; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; ~~~. Importing will append the volume to the current TGeoManager or will; create one:. ~~~{.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:113263,variab,variables,113263,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['variab'],['variables']
Modifiability,")`.; See the documentation of the particular minimizer to use for the list of possible additional options available. ### Performing the Fit. Here we have now all the required input ingredients for the fit, the data and the function to fit.; Depending on these we have now several different way to perform the fit, using the corresponding methods of the; `ROOT::Fit::Fitter` class and depending on the type of input data. #### Available fit methods. * **Least-square fit**: `Fitter::LeastSquare(const BinData & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional; *extended* boolean flag as *false*. This method is implemented by the class `ROOT::Fit:::PoissonLikelihoodFCN`.; * **Un-Binned likelihood fit**: `Fitter::LikelihoodFit(const UnBindata &)`. The user needs to pass an `UnBinData` object. By default the fit is not extended (i.e. the normalization is not fitted to the; data). As above the user can select an extended likelihood fit by passing the optional; *extended* boolean flag as *true*. This method is implemented using the class `LogLikelihoodFCN`; * **Linear Fit**: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the *Matrix* library), if the model function is linear in the; parameters. #### Customised Fit methods. Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:46133,extend,extended,46133,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['extend'],['extended']
Modifiability,")``. ``!div(``\ *a*\ ``,`` *b*\ ``)``; This operator performs signed division of *a* by *b*, and produces the quotient.; Division by 0 produces an error. Division of INT64_MIN by -1 produces an error. ``!empty(``\ *a*\ ``)``; This operator produces 1 if the string, list, or DAG *a* is empty; 0 otherwise.; A dag is empty if it has no arguments; the operator does not count. ``!eq(`` *a*\ `,` *b*\ ``)``; This operator produces 1 if *a* is equal to *b*; 0 otherwise.; The arguments must be ``bit``, ``bits``, ``int``, ``string``, or; record values. Use ``!cast<string>`` to compare other types of objects. ``!exists<``\ *type*\ ``>(``\ *name*\ ``)``; This operator produces 1 if a record of the given *type* whose name is *name*; exists; 0 otherwise. *name* should be of type *string*. ``!filter(``\ *var*\ ``,`` *list*\ ``,`` *predicate*\ ``)``. This operator creates a new ``list`` by filtering the elements in; *list*. To perform the filtering, TableGen binds the variable *var* to each; element and then evaluates the *predicate* expression, which presumably; refers to *var*. The predicate must; produce a boolean value (``bit``, ``bits``, or ``int``). The value is; interpreted as with ``!if``:; if the value is 0, the element is not included in the new list. If the value; is anything else, the element is included. ``!find(``\ *string1*\ ``,`` *string2*\ [``,`` *start*]\ ``)``; This operator searches for *string2* in *string1* and produces its; position. The starting position of the search may be specified by *start*,; which can range between 0 and the length of *string1*; the default is 0.; If the string is not found, the result is -1. ``!foldl(``\ *init*\ ``,`` *list*\ ``,`` *acc*\ ``,`` *var*\ ``,`` *expr*\ ``)``; This operator performs a left-fold over the items in *list*. The; variable *acc* acts as the accumulator and is initialized to *init*.; The variable *var* is bound to each element in the *list*. The; expression is evaluated for each element and presumably uses *acc* a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:63154,variab,variable,63154,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability,"* (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _StatementMacros:. **StatementMacros** (``List of Strings``) :versionbadge:`cla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129487,config,configuration,129487,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"* **i386-unknown-freebsd5.3** --- FreeBSD 5.3. * **i686-pc-cygwin** --- Cygwin on Win32. * **i686-pc-mingw32** --- MingW on Win32. * **i386-pc-mingw32msvc** --- MingW crosscompiler on Linux. * **i686-apple-darwin*** --- Apple Darwin on X86. * **x86_64-unknown-linux-gnu** --- Linux. X86 Calling Conventions supported; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The following target-specific calling conventions are known to backend:. * **x86_StdCall** --- stdcall calling convention seen on Microsoft Windows; platform (CC ID = 64). * **x86_FastCall** --- fastcall calling convention seen on Microsoft Windows; platform (CC ID = 65). * **x86_ThisCall** --- Similar to X86_StdCall. Passes first argument in ECX,; others via stack. Callee is responsible for stack cleaning. This convention is; used by MSVC by default for methods in its ABI (CC ID = 70). .. _X86 addressing mode:. Representing X86 addressing modes in MachineInstrs; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The x86 has a very flexible way of accessing memory. It is capable of forming; memory addresses of the following expression directly in integer instructions; (which use ModR/M addressing):. ::. SegmentReg: Base + [1,2,4,8] * IndexReg + Disp32. In order to represent this, LLVM tracks no less than 5 operands for each memory; operand of this form. This means that the ""load"" form of '``mov``' has the; following ``MachineOperand``\s in this order:. ::. Index: 0 | 1 2 3 4 5; Meaning: DestReg, | BaseReg, Scale, IndexReg, Displacement Segment; OperandTy: VirtReg, | VirtReg, UnsImm, VirtReg, SignExtImm PhysReg. Stores, and all other instructions, treat the four memory operands in the same; way and in the same order. If the segment register is unspecified (regno = 0),; then no segment override is generated. ""Lea"" operations do not have a segment; register specified, so they only have 4 operands for their memory reference. X86 address spaces supported; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. x86 has a feature which provides the abi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:90762,flexible,flexible,90762,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['flexible'],['flexible']
Modifiability,* Support ``__restrict`` and ``__restrict__`` in interfaces; * Allow passing sequence of strings through ``const char*[]`` argument. 2020-04-27: 1.7.0; -----------------. * Upgrade to cppyy-cling 6.20.4; * Pre-empt upstream's propensity of making ``std`` classes etc. global; * Allow initialization of ``std::map`` from dict with the correct types; * Allow initialization of ``std::set`` from set with the correct types; * Add optional nonst/non-const selection to ``__overload__``; * Automatic smartification of normal object passed as smartptr by value; * Fix crash when handing a by-value object to make_shared; * Fixed a few shared/unique_ptr corner cases; * Fixed conversion of ``std::function`` taking an STL class parameter; * No longer attempt auto-cast on classes without RTTI; * Fix for ``iter()`` iteration on generic STL container. 2020-03-15: 1.6.2; -----------------. * Respect ``__len__`` when using bound C++ objects in boolean expressions; * Support UTF-8 encoded ``unicode`` through ``std::string``; * Support for ``std::byte``; * Enable assignment to function pointer variable; * Allow passing cppyy.nullptr where a function pointer is expected; * Disable copy construction into constructed object (use ``__assign__`` instead); * Cover more cases when to set a lifeline; * Lower priority of implicit conversion to temporary with initializer_list ctor; * Add type reduction pythonization for trimming expression template type trees; * Allow mixing ``std::string`` and ``str`` as dictionary keys; * Support C-style pointer-to-struct as array; * Support C-style enum variable declarations; * Fixed const_iterator by-ref return type regression; * Resolve enums into the actual underlying type instead of int; * Remove '-isystem' from makepch flags; * Extended documentation. 2020-01-04: 1.6.1; -----------------. * Mapped C++ exception reporting detailing; * Mapped C++ exception cleanup bug fix; * STL vector constructor passes the CPython sequence construction; * STL vector slicing ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:14072,variab,variable,14072,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['variab'],['variable']
Modifiability,"* XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old variable name rule from the policy page. #. Repeat many of the steps in the sequence, using a script to expand acronyms. References; ==========. .. [LLDB] LLDB Coding Conventions https://llvm.org/svn/llvm-project/lldb/branches/release_39/www/lldb-coding-conventions.html; .. [Google] Google C++ Style Guide https://google.github.io/styleguide/cppguide.html#Variable_Names; .. [WebKit] WebKit Code Style Guidelines https://webkit.org/code-style-guidelines/#names; .. [Qt] Qt Coding Style https://wiki.qt.io/Qt_Coding_Style#Declaring_variables; .. [Rust] Rust naming conventions https://doc.rust-lang.org/1.0.0/style/style/naming/README.html; .. [Swift] Swift API Design Guidelines https://swift.org/documentation/api-design-guidelines/#general-conventions; .. [Python] Style Guide for Python Code https://www.python.org/dev/peps/pep-0008/#function-and-variable-names; .. [Mozilla] Mozilla Coding style: Prefixes https://firefox-source-docs.mozilla.org/tools/lint/coding-style/coding_style_cpp.html#prefixes; .. [SVE] LLVM with support for SVE https://github.com/ARM-software/LLVM-SVE; .. [AminiInconsistent] Mehdi Amini, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130329.html; .. [ArsenaultAgree] Matt Arsenault, http://lists.llvm.org/pipermail/llvm-dev/2019-February/129934.html; .. [BeylsDistinguish] Kristof Beyls, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130292.html; .. [BradburyConcern] Alex Bradbury, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130266.html; .. [BradburyTransition] Alex Bradbury, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130388.html; .. [CarruthAcronym] Chandler Carruth, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130313.html; .. [CarruthCamelBack] Chandler Carruth, http://lists.llvm.org/pipermail/llvm-dev/2019-February/130214.html; .. [CarruthDistingui",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:14009,variab,variable-names,14009,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable-names']
Modifiability,"* ``int8_t Hex`` Format separators in hexadecimal literals. .. code-block:: text. /* -1: */ h = 0xDEADBEEFDEADBEEFuz;; /* 0: */ h = 0xDEAD'BEEF'DE'AD'BEE'Fuz;; /* 2: */ h = 0xDE'AD'BE'EF'DE'AD'BE'EFuz;. * ``int8_t HexMinDigits`` Format separators in hexadecimal literals with a minimum number of; digits. .. code-block:: text. // Hex: 2; // HexMinDigits: 6; h1 = 0xABCDE;; h2 = 0xAB'CD'EF;. .. _JavaImportGroups:. **JavaImportGroups** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <JavaImportGroups>`; A vector of prefixes ordered by the desired groups for Java imports. One group's prefix can be a subset of another - the longest prefix is; always matched. Within a group, the imports are ordered lexicographically.; Static imports are grouped separately and follow the same group rules.; By default, static imports are placed before non-static imports,; but this behavior is changed by another option,; ``SortJavaStaticImport``. In the .clang-format configuration file, this can be configured like; in the following yaml example. This will result in imports being; formatted as in the Java example below. .. code-block:: yaml. JavaImportGroups: ['com.example', 'com', 'org']. .. code-block:: java. import static com.example.function1;. import static com.test.function2;. import static org.example.function3;. import com.example.ClassA;; import com.example.Test;; import com.example.a.ClassB;. import com.test.ClassC;. import org.example.ClassD;. .. _JavaScriptQuotes:. **JavaScriptQuotes** (``JavaScriptQuoteStyle``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptQuotes>`; The JavaScriptQuoteStyle to use for JavaScript strings. Possible values:. * ``JSQS_Leave`` (in configuration: ``Leave``); Leave string quotes as they are. .. code-block:: js. string1 = ""foo"";; string2 = 'bar';. * ``JSQS_Single`` (in configuration: ``Single``); Always use single quotes. .. code-block:: js. string1 = 'foo';; string2 = 'bar';. * ``JSQS_Double`` (in configuration: ``Double``); Always use ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:79925,config,configuration,79925,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,['config'],"['configuration', 'configured']"
Modifiability,"* executed inside of the LLVM source tree. This is because; the test suite creates temporary files during execution. To run the test suite, you need to use the following steps:. #. Check out the ``test-suite`` module with:. .. code-block:: bash. % git clone https://github.com/llvm/llvm-test-suite.git test-suite. #. FIXME: these directions are outdated and won't work. Figure out; what the correct thing to do is, and write it down here. #. Configure and build ``llvm``. #. Configure and build ``llvm-gcc``. #. Install ``llvm-gcc`` somewhere. #. *Re-configure* ``llvm`` from the top level of each build tree (LLVM; object directory tree) in which you want to run the test suite, just; as you do before building LLVM. During the *re-configuration*, you must either: (1) have ``llvm-gcc``; you just built in your path, or (2) specify the directory where your; just-built ``llvm-gcc`` is installed using; ``--with-llvmgccdir=$LLVM_GCC_DIR``. You must also tell the configure machinery that the test suite is; available so it can be configured for your build tree:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT ; $LLVM_SRC_ROOT/configure [--with-llvmgccdir=$LLVM_GCC_DIR]. [Remember that ``$LLVM_GCC_DIR`` is the directory where you; *installed* llvm-gcc, not its src or obj directory.]. #. You can now run the test suite from your build tree as follows:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT/projects/test-suite; % make. Note that the second and third steps only need to be done once. After; you have the suite checked out and configured, you don't need to do it; again (unless the test code or configure script changes). Configuring External Tests; ==========================. In order to run the External tests in the ``test-suite`` module, you; must specify *--with-externals*. This must be done during the; *re-configuration* step (see above), and the ``llvm`` re-configuration; must recognize the previously-built ``llvm-gcc``. If any of these is; missing or neglected, the External tests won't w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:1210,config,configure,1210,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,2,['config'],"['configure', 'configured']"
Modifiability,"* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46777,config,config-macros-declaration,46777,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['config'],['config-macros-declaration']
Modifiability,"*(boolean expression)""; ```. If the Boolean expression evaluates to true, the histogram is filled; with a weight. If the weight is not explicitly specified it is assumed; to be 1. For example, this selection will add 1 to the histogram if x is less; than y and the square root of z is less than 3.2. ``` {.cpp}; ""x<y && sqrt(z)>3.2""; ```. On the other hand, this selection will add `x+y` to the histogram if the; square root of z is larger than 3.2. ``` {.cpp}; ""(x+y)*(sqrt(z)>3.2)""; ```. The `Draw` method has its own parser, and it only looks in the current; tree for variables. This means that any variable used in the selection; must be defined in the tree. You cannot use an arbitrary global variable; in the `TTree::Draw` method. ### Using TCut Objects in TTree::Draw. The `TTree::Draw` method also accepts **`TCutG`** objects. A; **`TCut`** is a specialized string object used for **`TTree`**; selections. A **`TCut`** object has a name and a title. It does not have; any data members in addition to what it inherits from **`TNamed`**. It; only adds a set of operators to do logical string concatenation. For; example, assume:. ``` {.cpp}; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; ```. then. ``` {.cpp}; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; ```. Operators =, +=, +, \*, !, &&, || are overloaded, here are some; examples:. ``` {.cpp}; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); ```. ### Accessing the Histogram in Batch Mode. The `TTree::Draw` method creates a histogram called `htemp` and puts it; on the active pad. In a batch program, the histogram `htemp` created by; default, is reachable from the current pad. ``` {.cpp}; // draw the histogram; nt->Draw(""x"", ""cuts"");; // get the histogram from the current pad; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp"");; // now we have full use ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:72773,inherit,inherits,72773,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['inherit'],['inherits']
Modifiability,"** - Unknown. - **MFCTypeServerIndex** - The index of the MFC type server in the; :ref:`dbi_type_server_map_substream`. - **Flags** - A bitfield with the following layout, containing various; information about how the program was built:. .. code-block:: c++. uint16_t WasIncrementallyLinked : 1;; uint16_t ArePrivateSymbolsStripped : 1;; uint16_t HasConflictingTypes : 1;; uint16_t Reserved : 13;. The only one of these that is not self-explanatory is ``HasConflictingTypes``.; Although undocumented, ``link.exe`` contains a hidden flag ``/DEBUG:CTYPES``.; If it is passed to ``link.exe``, this field will be set. Otherwise it will; not be set. It is unclear what this flag does, although it seems to have; subtle implications on the algorithm used to look up type records. - **Machine** - A value from the `CV_CPU_TYPE_e <https://msdn.microsoft.com/en-us/library/b2fc64ek.aspx>`__; enumeration. Common values are ``0x8664`` (x86-64) and ``0x14C`` (x86). Immediately after the fixed-size DBI Stream header are ``7`` variable-length; `substreams`. The following ``7`` fields of the DBI Stream header specify the; number of bytes of the corresponding substream. Each substream's contents will; be described in detail :ref:`below <dbi_substreams>`. The length of the entire; DBI Stream should equal ``64`` (the length of the header above) plus the value; of each of the following ``7`` fields. - **ModInfoSize** - The length of the :ref:`dbi_mod_info_substream`. - **SectionContributionSize** - The length of the :ref:`dbi_sec_contr_substream`. - **SectionMapSize** - The length of the :ref:`dbi_section_map_substream`. - **SourceInfoSize** - The length of the :ref:`dbi_file_info_substream`. - **TypeServerMapSize** - The length of the :ref:`dbi_type_server_map_substream`. - **OptionalDbgHeaderSize** - The length of the :ref:`dbi_optional_dbg_stream`. - **ECSubstreamSize** - The length of the :ref:`dbi_ec_substream`. .. _dbi_substreams:. Substreams; ==========. .. _dbi_mod_info_substream:. Module ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst:4514,variab,variable-length,4514,interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/DbiStream.rst,1,['variab'],['variable-length']
Modifiability,"** reside; inside the first basic block. The first argument **must** be a value referring to an alloca instruction or a; bitcast of an alloca. The second contains a pointer to metadata that should be; associated with the pointer, and **must** be a constant or global value; address. If your target collector uses tags, use a null pointer for metadata. A compiler which performs manual SSA construction **must** ensure that SSA; values representing GC references are stored in to the alloca passed to the; respective ``gcroot`` before every call site and reloaded after every call.; A compiler which uses mem2reg to raise imperative code using ``alloca`` into; SSA form need only add a call to ``@llvm.gcroot`` for those variables which; are pointers into the GC heap. It is also important to mark intermediate values with ``llvm.gcroot``. For; example, consider ``h(f(), g())``. Beware leaking the result of ``f()`` in the; case that ``g()`` triggers a collection. Note, that stack variables must be; initialized and marked with ``llvm.gcroot`` in function's prologue. The ``%metadata`` argument can be used to avoid requiring heap objects to have; 'isa' pointers or tag bits. [Appel89_, Goldberg91_, Tolmach94_] If specified,; its value will be tracked along with the location of the pointer in the stack; frame. Consider the following fragment of Java code:. .. code-block:: java. {; Object X; // A null-initialized reference to an object; ...; }. This block (which may be located in the middle of a function or in a loop nest),; could be compiled to this LLVM code:. .. code-block:: llvm. Entry:; ;; In the entry block for the function, allocate the; ;; stack space for X, which is an LLVM pointer.; %X = alloca %Object*. ;; Tell LLVM that the stack space is a stack root.; ;; Java has type-tags on objects, so we pass null as metadata.; %tmp = bitcast %Object** %X to i8**; call void @llvm.gcroot(i8** %tmp, i8* null); ... ;; ""CodeBlock"" is the block corresponding to the start; ;; of the scope a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:11431,variab,variables,11431,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['variab'],['variables']
Modifiability,"*** Once you have set a convenient global visualization option; and level, what you need is just call the `Draw()` method of your; interesting volume. You can do this either by interacting with the; expanded tree of volumes in a ROOT browser (where the context menu of; any volume is available), either by getting a pointer to it (e.g. by; name): `gGeoManager->GetVolume(""vol_name"")->Draw();`. ### Visualization Settings and Attributes. Supposing you now understand the basic things to do for drawing the; geometry or parts of it, you still might be not happy and wishing to; have more control on it. We will describe below how you can fine-tune some; settings. Since the corresponding attributes are flags belonging to; volume and node objects, you can change them at any time (even when the; picture is already drawn) and see immediately the result. #### Colors and Line Styles. We have already described how to change the line colors for volumes. In; fact, volume objects inherit from TAttLine class so the line style or; width can also be changed:. ``` {.cpp}; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ```. When drawing in solid mode, the color of the drawn volume corresponds to; the line color. #### Visibility Settings. The way geometry is build forces the definition of several volumes that; does not represent real objects, but just virtual containers used for; grouping and positioning volumes together. One would not want to see; them in the picture. Since every volume is by default visible, one has; to do this sort of tuning by its own:. ``` {.cpp}; myVolumeContainer->SetVisibility(kFALSE);; ```. As described before, the drawing package supports two main global; options: 1 (default) - only final volume leaves; 0 - all volumes down; the drawn one appear on the screen. The global visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:141627,inherit,inherit,141627,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['inherit'],['inherit']
Modifiability,"**pages** that contain all the data belonging to an entry range.; The data set is partitioned in clusters.; A typical cluster size is tens to hundreds of megabytes. ### Column. A column is a storage backed vector of a number of **elements** of a simple type.; Column elements have a fixed bit-length that depends on the column type.; Some column types allow setting the bit lengths within specific limits (e.g. for floats with truncated mantissa). ### Envelope. An envelope is a data block with RNTuple meta-data, such as the header and the footer. ### Field. A field describes a serialized C++ type.; A field can have a hierarchy of subfields representing a composed C++ type (e.g., a vector of integers).; A field has zero, one, or multiple **columns** attached to it.; The columns contain the data related to the field but not to its subfields, which have their own columns. ### Frame. A frame is a byte range with metadata information in an **envelope**.; A frame starts with its size and thus can be extended in a forward-compatible way. ### Locator. A locator is a generalized way to identify a byte range in the RNTuple container.; For a file container, for instance, a locator consists of an offset and a size. ### Page. A page is segment of a column.; Columns are partitioned in pages.; A page is a unit of compression.; Typical page sizes are of the order of tens to hundreds of kilobytes. ### Indications of size. In this document, the `length` of something (e.g., a page) refers to its size in bytes in memory, uncompressed.; The `size` of something refers to the size in bytes on disk, possibly compressed. ## Notes on Backward and Forward Compatibility. Note that this section covers the backward and forward compatibility of the binary format itself.; It does not discuss schema evolution of the written types. Readers supporting a certain version of the specification should support reading files; that were written according to previous versions of the same epoch. Readers should sup",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:51292,extend,extended,51292,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['extend'],['extended']
Modifiability,"*--with-externals*. This must be done during the; *re-configuration* step (see above), and the ``llvm`` re-configuration; must recognize the previously-built ``llvm-gcc``. If any of these is; missing or neglected, the External tests won't work. * *--with-externals*. * *--with-externals=<directory>*. This tells LLVM where to find any external tests. They are expected to; be in specifically named subdirectories of <``directory``>. If; ``directory`` is left unspecified, ``configure`` uses the default value; ``/home/vadve/shared/benchmarks/speccpu2000/benchspec``. Subdirectory; names known to LLVM include:. * spec95. * speccpu2000. * speccpu2006. * povray31. Others are added from time to time, and can be determined from; ``configure``. Running Different Tests; =======================. In addition to the regular ""whole program"" tests, the ``test-suite``; module also provides a mechanism for compiling the programs in different; ways. If the variable TEST is defined on the ``gmake`` command line, the; test system will include a Makefile named; ``TEST.<value of TEST variable>.Makefile``. This Makefile can modify; build rules to yield different results. For example, the LLVM nightly tester uses ``TEST.nightly.Makefile`` to; create the nightly test reports. To run the nightly tests, run; ``gmake TEST=nightly``. There are several TEST Makefiles available in the tree. Some of them are; designed for internal LLVM research and will not work outside of the; LLVM research group. They may still be valuable, however, as a guide to; writing your own TEST Makefile for any optimization or analysis passes; that you develop with LLVM. Generating Test Output; ======================. There are a number of ways to run the tests and generate output. The; most simple one is simply running ``gmake`` with no arguments. This will; compile and run all programs in the tree using a number of different; methods and compare results. Any failures are reported in the output,; but are likely drowned in th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:2957,variab,variable,2957,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['variab'],['variable']
Modifiability,"*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4304,config,configuration,4304,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['configuration']
Modifiability,"*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''; ' == 127757'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~. *AFTER*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''\n' (0x0A, 10) == U'🌍' (0x1F30D, 127757)'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~; - Clang now always diagnoses when using non-standard layout types in ``offsetof`` .; (`#64619 <https://github.com/llvm/llvm-project/issues/64619>`_); - Clang now diagnoses redefined defaulted constructor when redefined; defaulted constructor with different exception specs.; (`#69094 <https://github.com/llvm/llvm-project/issues/69094>`_); - Clang now diagnoses use of variable-length arrays in C++ by default (and; under ``-Wall`` in GNU++ mode). This is an extension supported by Clang and; GCC, but is very easy to accidentally use without realizing it's a; nonportable construct that has different semantics from a constant-sized; array. (`#62836 <https://github.com/llvm/llvm-project/issues/62836>`_). - Clang changed the order in which it displays candidate functions on overloading failures.; Previously, Clang used definition of ordering from the C++ Standard. The order defined in; the Standard is partial and is not suited for sorting. Instead, Clang now uses a strict; order that still attempts to push more relevant functions to the top by comparing their; corresponding conversions. In some cases, this results in better order. E.g., for the; following code. .. code-block:: cpp. struct Foo {; operator int();; operator const char*();; };. void test() { Foo() - Foo(); }. Clang now produces a list with two most relevant builtin operators at the top,; i.e. ``op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:27184,variab,variable-length,27184,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variable-length']
Modifiability,"*`dest`**: pointer to the matrix of destination data, its size should; be `sizex`*`sizey` except for direct FOURIER, FOUR-WALSh, FOUR-HAAR.; These need `sizex`\*2\*`sizey` length to store real and imaginary; coefficients; - **`sizex,sizey`**: basic dimensions of the source and dest spectra; - **`type`**: type of transform; - `TRANSFORM2_HAAR`; - `TRANSFORM2_WALSH`; - `TRANSFORM2_COS`; - `TRANSFORM2_SIN`; - `TRANSFORM2_FOURIER`; - `TRANSFORM2_HARTLEY`; - `TRANSFORM2_FOURIER_WALSH`; - `TRANSFORM2_FOURIER_HAAR`; - `TRANSFORM2_WALSH_HAAR`; - `TRANSFORM2_COS_WALSH`; - `TRANSFORM2_COS_HAAR`; - `TRANSFORM2_SIN_WALSH`; - `TRANSFORM2_SIN_HAAR`; - **`direction`**: transform direction (forward, inverse); - **`degree`**: applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is; given in Figure 6.7. One can notice that the data are concentrated again; around the beginning of the coordinate system. This allows to apply; filtration, enhancement and compression techniques in the transform; domain. ![2-dimensional Cosine transform of data from Figure 5.6](figures/image208.png). In some cases, when the spectrum is smooth, the cosine transforms are very; efficient. In Figures 6.8, 6.9 we show original spectrum and transformed; coefficients using Cosine transform, respectively. ![Original spectrum](figures/image210.png). ![Transformed coefficients using Cosine transform](figures/image212.png). Similarly to 1-dimensional case we have also implemented the functions for zonal filtration, Gauss filtration and enhancement.; The zonal filtration function using classic transforms has the form of. ```{.cpp}; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter_coeff);; ```. This function transforms the source spectrum. The calling program should; fill in the input parameters. Then it sets transformed coefficients in the; given region ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:67217,enhance,enhancement,67217,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['enhance'],['enhancement']
Modifiability,"*provisional*. It is not agreed upon. It is written with the; intention of capturing the desires and concerns of the LLVM community, and; forming them into a plan that can be agreed upon.; The original author is somewhat naïve in the ways of LLVM so there will; inevitably be some details that are flawed. You can help - you can edit this; page (preferably with a Phabricator review for larger changes) or reply to the; `Request For Comments thread; <http://lists.llvm.org/pipermail/llvm-dev/2019-February/130083.html>`_. Too Long; Didn't Read; =====================. Improve the readability of LLVM code. Introduction; ============. The current `variable naming rule; <../CodingStandards.html#name-types-functions-variables-and-enumerators-properly>`_; states:. Variable names should be nouns (as they represent state). The name should be; camel case, and start with an upper case letter (e.g. Leader or Boats). This rule is the same as that for type names. This is a problem because the; type name cannot be reused for a variable name [*]_. LLVM developers tend to; work around this by either prepending ``The`` to the type name::. Triple TheTriple;. ... or more commonly use an acronym, despite the coding standard stating ""Avoid; abbreviations unless they are well known""::. Triple T;. The proliferation of acronyms leads to hard-to-read code such as `this; <https://github.com/llvm/llvm-project/blob/0a8bc14ad7f3209fe702d18e250194cd90188596/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L7445>`_::. InnerLoopVectorizer LB(L, PSE, LI, DT, TLI, TTI, AC, ORE, VF.Width, IC,; &LVL, &CM);. Many other coding guidelines [LLDB]_ [Google]_ [WebKit]_ [Qt]_ [Rust]_ [Swift]_; [Python]_ require that variable names begin with a lower case letter in contrast; to class names which begin with a capital letter. This convention means that the; most readable variable name also requires the least thought::. Triple triple;. There is some agreement that the current rule is broken [LattnerAgree]_; [ArsenaultA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:1123,variab,variable,1123,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability,"+ and Objective-C exceptions.; (Difficulty: Hard). Core Analyzer Infrastructure; ; Handle unions.; Currently in the analyzer the value of a union is always regarded as; an unknown.; This problem was; previously discussed; on the mailing list, but no solution was implemented.; (Difficulty: Medium) . Floating-point support.; Currently, the analyzer treats all floating-point values as unknown.; This project would involve adding a new SVal kind; for constant floats, generalizing the constraint manager to handle floats,; and auditing existing code to make sure it doesn't; make incorrect assumptions (most notably, that X == X; is always true, since it does not hold for NaN).; (Difficulty: Medium). Improved loop execution modeling.; The analyzer simply unrolls each loop N times before; dropping the path, for a fixed constant N.; However, that results in lost coverage in cases where the loop always; executes more than N times.; A Google Summer Of Code; project; was completed to make the loop bound parameterizable,; but the widening; problem still remains open. (Difficulty: Hard). Basic function summarization support; The analyzer performs inter-procedural analysis using; either inlining or ""conservative evaluation"" (invalidating all data; passed to the function).; Often, a very simple summary; (e.g. ""this function is pure"") would be; enough to be a large improvement over conservative evaluation.; Such summaries could be obtained either syntactically,; or using a dataflow framework.; (Difficulty: Hard). Implement a dataflow flamework.; The analyzer core; implements a symbolic execution; engine, which performs checks; (use-after-free, uninitialized value read, etc.); over a single program path.; However, many useful properties; (dead code, check-after-use, etc.) require; reasoning over all possible in a program.; Such reasoning requires a; dataflow analysis framework.; Clang already implements; a few dataflow analyses (most notably, liveness),; but they implemented in an ad-h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:7220,parameteriz,parameterizable,7220,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['parameteriz'],['parameterizable']
Modifiability,"+ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors for types with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=none or -analyzer-config ipa=basic-inlining,; regardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:1714,config,configuration,1714,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['config'],['configuration']
Modifiability,"++++++++++................. ...............++++++++++++++++; ++++++++++++.................. .................++++++++++++++; +++++++++.................. .................+++++++++++++; ++++++........ . ......... ..++++++++++++; ++............ ...... ....++++++++++; .............. ...++++++++++; .............. ....+++++++++; .............. .....++++++++; ............. ......++++++++; ........... .......++++++++; ......... ........+++++++; ......... ........+++++++; ......... ....+++++++; ........ ...+++++++; ....... ...+++++++; ....+++++++; .....+++++++; ....+++++++; ....+++++++; ....+++++++; Evaluated to 0.000000; ready> ^D. At this point, you may be starting to realize that Kaleidoscope is a; real and powerful language. It may not be self-similar :), but it can be; used to plot things that are!. With this, we conclude the ""adding user-defined operators"" chapter of; the tutorial. We have successfully augmented our language, adding the; ability to extend the language in the library, and we have shown how; this can be used to build a simple but interesting end-user application; in Kaleidoscope. At this point, Kaleidoscope can build a variety of; applications that are functional and can call functions with; side-effects, but it can't actually define and mutate a variable itself. Strikingly, variable mutation is an important feature of some languages,; and it is not at all obvious how to `add support for mutable; variables <LangImpl07.html>`_ without having to add an ""SSA construction""; phase to your front-end. In the next chapter, we will describe how you; can add variable mutation without building SSA in your front-end. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; the support for user-defined operators. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. On some platforms, yo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:26043,extend,extend,26043,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['extend'],['extend']
Modifiability,"++; DEFINE_FLAG(std::string, example_flag, """", ""A sample flag."");. void Example() {; bool x = GetFlag(FLAGS_example_flag).empty();; f();; if (x) {; g();; } else {; h();; }; }; ```. The tool would simplify the code to:. ```c++; void Example() {; f();; g();; }; ```. We can solve this problem with a classic constant propagation lattice combined; with symbolic evaluation. ## Example: finding inefficient usages of associative containers. Real-world code often accidentally performs repeated lookups in associative; containers:. ```c++; map<int, Employee> xs;; xs[42]->name = ""..."";; xs[42]->title = ""..."";; ```. To find the above inefficiency we can use the available expressions analysis to; understand that `m[42]` is evaluated twice. ```c++; map<int, Employee> xs;; Employee &e = xs[42];; e->name = ""..."";; e->title = ""..."";; ```. We can also track the `m.contains()` check in the flow condition to find; redundant checks, like in the example below. ```c++; std::map<int, Employee> xs;; if (!xs.contains(42)) {; xs.insert({42, someEmployee});; }; ```. ## Example: refactoring types that implicitly convert to each other. Refactoring one strong type to another is difficult, but the compiler can help:; once you refactor one reference to the type, the compiler will flag other places; where this information flows with type mismatch errors. Unfortunately this; strategy does not work when you are refactoring types that implicitly convert to; each other, for example, replacing `int32_t` with `int64_t`. Imagine that we want to change user IDs from 32 to 64-bit integers. In other; words, we need to find all integers tainted with user IDs. We can use data flow; analysis to implement taint analysis. ```c++; void UseUser(int32_t user_id) {; int32_t id = user_id;; // Variable `id` is tainted with a user ID.; ...; }; ```. Taint analysis is very well suited to this problem because the program rarely; branches on user IDs, and almost certainly does not perform any computation; (like arithmetic).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:29452,refactor,refactoring,29452,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,3,['refactor'],"['refactor', 'refactoring']"
Modifiability,"+; member functions, static functions, operators, and constructors/destructors. - ``function(is_member)``: Can be used to apply attributes to C++ member; functions. This includes members like static functions, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:183703,variab,variable,183703,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,5,['variab'],"['variable', 'variables']"
Modifiability,", ...) ; int i; !4 = !DILocation(...). A frontend should generate exactly one call to ``llvm.dbg.declare`` at the point; of declaration of a source variable. Optimization passes that fully promote the; variable from memory to SSA values will replace this call with possibly multiple; calls to `llvm.dbg.value`. Passes that delete stores are effectively partial; promotion, and they will insert a mix of calls to ``llvm.dbg.value`` to track; the source variable value when it is available. After optimization, there may be; multiple calls to ``llvm.dbg.declare`` describing the program points where the; variables lives in memory. All calls for the same concrete source variable must; agree on the memory location. ``llvm.dbg.value``; ^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.value(metadata, metadata, metadata). This intrinsic provides information when a user source variable is set to a new; value. The first argument is the new value (wrapped as metadata). The second; argument is a `local variable <LangRef.html#dilocalvariable>`_ containing a; description of the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a source variable; directly, not its address. Note that the value operand of this intrinsic may; be indirect (i.e, a pointer to the source variable), provided that interpreting; the complex expression derives the direct value. ``llvm.dbg.assign``; ^^^^^^^^^^^^^^^^^^^; .. toctree::; :hidden:. AssignmentTracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression). This intrinsic marks the position in IR where a source assignment occurred. It; encodes the value of the variable. It references the store, if any, that; performs the assignment, and the destination address. The first three arguments are the same as for an ``llvm.dbg.value``.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:10446,variab,variable,10446,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,", Arm and Internal LLVM),; the remaining tokens can have the following values:::. <mask>:= M | N -> mask | no mask. <vlen>:= number -> number of lanes; | x -> VLA (Vector Length Agnostic). <parameters>:= v -> vector; | l | l <number> -> linear; | R | R <number> -> linear with ref modifier; | L | L <number> -> linear with val modifier; | U | U <number> -> linear with uval modifier; | ls <pos> -> runtime linear; | Rs <pos> -> runtime linear with ref modifier; | Ls <pos> -> runtime linear with val modifier; | Us <pos> -> runtime linear with uval modifier; | u -> uniform. <scalar_name>:= name of the scalar function. <vector_redirection>:= optional, custom name of the vector function. ``preallocated(<ty>)``; This attribute is required on calls to ``llvm.call.preallocated.arg``; and cannot be used on any other call. See; :ref:`llvm.call.preallocated.arg<int_call_preallocated_arg>` for more; details. .. _glattrs:. Global Attributes; -----------------. Attributes may be set to communicate additional information about a global variable.; Unlike :ref:`function attributes <fnattrs>`, attributes on a global variable; are grouped into a single :ref:`attribute group <attrgrp>`. ``no_sanitize_address``; This attribute indicates that the global variable should not have; AddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""address"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``no_sanitize_hwaddress``; This attribute indicates that the global variable should not have; HWAddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""hwaddress"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``sanitize_memtag``; This attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; supp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:114992,variab,variable,114992,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,", CERN/SFT,\; Alja Mrak-Tadel, UCSD/CMS,\; Jan Musinsky, SAS Kosice,\; Axel Naumann, CERN/SFT,\; Vincenzo Eduardo Padulano, CERN/SFT and UPV,\; Danilo Piparo, CERN/SFT,\; Timur Pocheptsoff, Qt Company,\; Renato Quagliani, LPNHE, CNRS/IN2P3, Sorbonne Université,\; Fons Rademakers, CERN/SFT,\; Oksana Shadura, Nebraska,\; Enric Tejedor Saavedra, CERN/SFT,\; Matevz Tadel, UCSD/CMS,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/Atlas,\; Stefan Wunsch, CERN/SFT. ## Deprecation and Removal. - `ROOT::GetImplicitMTPoolSize` has been deprecated in favor of the newly added `ROOT::GetThreadPoolSize` and; will be removed in v6.24.; - Manually setting `TThreadedObject::fgMaxSlots` is deprecated: TThreadedObject now increases the number of slots; on-demand rather than running out and throwing an exception. ## Core Libraries. - ROOT comes with C++ Modules enabled. More details about the technology found [here](../../README.CXXMODULES.md).; - The `ACLiC` can be configured to pass options to the `rootcling` invocation by enabling in the `.rootrc` the `ACLiC.ExtraRootclingFlags [-opts]` line.; - A call to `ROOT::EnableThreadSafety` is not required before using `TThreadExecutor` or `TTreeProcessorMT` anymore; - `TTreeProcessorMT` does not silently activate implicit multi-threading features anymore. An explicit call to; `ROOT::EnableImplicitMT` is required instead; - `TTreeProcessorMT` now has a constructor argument to set the number of threads for its thread-pool. ## I/O Libraries. ## TTree Libraries. - A new status bit was added to `TTree`: `kEntriesReshuffled`, which indicates a `TTree` that is the output of the; processing of another tree during which its entry order has been changed (this can happen, for instance, when; processing a tree in a multi-thread application). To avoid silent entry number mismatches, trees with this bit set; cannot add friend trees nor can be added as friends, unless the friend `TTree` has an appropriate `TTreeIndex`. ## Histogram Libraries. #",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:1556,config,configured,1556,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['config'],['configured']
Modifiability,", RIP, RSI, RSP, SI, SIL, SP, SPL, ST0, ST1, ST2, ST3, ST4, ST5, ST6, ST7,; XMM0, XMM1, XMM10, XMM11, XMM12, XMM13, XMM14, XMM15, XMM2, XMM3, XMM4, XMM5,; XMM6, XMM7, XMM8, XMM9,. $ llvm-tblgen X86.td -print-enums -class=Instruction; ABS_F, ABS_Fp32, ABS_Fp64, ABS_Fp80, ADC32mi, ADC32mi8, ADC32mr, ADC32ri,; ADC32ri8, ADC32rm, ADC32rr, ADC64mi32, ADC64mi8, ADC64mr, ADC64ri32, ADC64ri8,; ADC64rm, ADC64rr, ADD16mi, ADD16mi8, ADD16mr, ADD16ri, ADD16ri8, ADD16rm,; ADD16rr, ADD32mi, ADD32mi8, ADD32mr, ADD32ri, ADD32ri8, ADD32rm, ADD32rr,; ADD64mi32, ADD64mi8, ADD64mr, ADD64ri32, ... The default backend prints out all of the records. There is also a general; backend which outputs all the records as a JSON data structure, enabled using; the `-dump-json` option. If you plan to use TableGen, you will most likely have to write a `backend`_; that extracts the information specific to what you need and formats it in the; appropriate way. You can do this by extending TableGen itself in C++, or by; writing a script in any language that can consume the JSON output. Example; -------. With no other arguments, `llvm-tblgen` parses the specified file and prints out all; of the classes, then all of the definitions. This is a good way to see what the; various definitions expand to fully. Running this on the ``X86.td`` file prints; this (at the time of this writing):. .. code-block:: text. ...; def ADD32rr { // Instruction X86Inst I; string Namespace = ""X86"";; dag OutOperandList = (outs GR32:$dst);; dag InOperandList = (ins GR32:$src1, GR32:$src2);; string AsmString = ""add{l}\t{$src2, $dst|$dst, $src2}"";; list<dag> Pattern = [(set GR32:$dst, (add GR32:$src1, GR32:$src2))];; list<Register> Uses = [];; list<Register> Defs = [EFLAGS];; list<Predicate> Predicates = [];; int CodeSize = 3;; int AddedComplexity = 0;; bit isReturn = 0;; bit isBranch = 0;; bit isIndirectBranch = 0;; bit isBarrier = 0;; bit isCall = 0;; bit canFoldAsLoad = 0;; bit mayLoad = 0;; bit mayStore = 0;; bit isImplicitDef = ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst:3753,extend,extending,3753,interpreter/llvm-project/llvm/docs/TableGen/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst,1,['extend'],['extending']
Modifiability,", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no arguments and returning a ``bool``. Attributes that do not require custom semantic handling should set the; ``SemaHandler`` field to ``0``. Note that anything inheriting from; ``IgnoredAttr`` automatically do not get a semantic handler. All other; attributes are assumed to use a semantic handler by default. Attributes; without a semantic handler are not given a parsed attribute ``Kind`` enumerator. ""Simple"" attributes, that require no custom semantic processing aside from what; is automatically provided, should set the ``SimpleHandler`` field to ``1``. Target-specific attributes may share a spelling with other attributes in; different targets. For instance, the ARM and MSP430 targets both have an; attribute spelled ``GNU<""interrupt"">``, but with different parsing and semantic; requirements. To support this feature, an attribute inheriting from; ``TargetSpecificAttribute`` may specify a ``ParseKind`` field. This field; should be the same value between all arguments sharing a spelling, and; corresponds to the parsed attribute's ``Kind`` enumerator. This allows; attributes to share a parsed attribute kind, but have distinct semantic; attribute classes. For instance, ``ParsedAttr`` is the shared; parsed attribute kind, but ARMInterruptAttr and MSP430InterruptAttr are the; semantic attributes generated. By default, attribute arguments are parsed in an evaluated context. If the; arguments for an attribute should be parsed in an unevaluated context (akin to; the way the argument to a ``sizeof`` expression is parsed), set; ``ParseArgumentsAsUnevaluated`` to ``1``. If additional functionality is desired for the semantic form of the attribute,; the ``AdditionalMembers`` field specifies code to be copied verbatim into the; semantic attribute class object, with ``public`` access. If two or more attributes cannot be used in combination on th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:140657,inherit,inheriting,140657,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['inherit'],['inheriting']
Modifiability,", `git checkout; llvmorg-6.0.1` inside the ``llvm-project`` directory created by the above; command. Use `git tag -l` to list all of them. Sending patches; ^^^^^^^^^^^^^^^. See :ref:`Contributing <submit_patch>`. Bisecting commits; ^^^^^^^^^^^^^^^^^. See `Bisecting LLVM code <GitBisecting.html>`_ for how to use ``git bisect``; on LLVM. Reverting a change; ^^^^^^^^^^^^^^^^^^. When reverting changes using git, the default message will say ""This reverts; commit XYZ"". Leave this at the end of the commit message, but add some details; before it as to why the commit is being reverted. A brief explanation and/or; links to bots that demonstrate the problem are sufficient. Local LLVM Configuration; ------------------------. Once checked out repository, the LLVM suite source code must be configured; before being built. This process uses CMake. Unlinke the normal ``configure``; script, CMake generates the build files in whatever format you request as well; as various ``*.inc`` files, and ``llvm/include/llvm/Config/config.h.cmake``. Variables are passed to ``cmake`` on the command line using the format; ``-D<variable name>=<value>``. The following variables are some common options; used by people developing LLVM. +-------------------------+----------------------------------------------------+; | Variable | Purpose |; +=========================+====================================================+; | CMAKE_C_COMPILER | Tells ``cmake`` which C compiler to use. By |; | | default, this will be /usr/bin/cc. |; +-------------------------+----------------------------------------------------+; | CMAKE_CXX_COMPILER | Tells ``cmake`` which C++ compiler to use. By |; | | default, this will be /usr/bin/c++. |; +-------------------------+----------------------------------------------------+; | CMAKE_BUILD_TYPE | Tells ``cmake`` what type of build you are trying |; | | to generate files for. Valid options are Debug, |; | | Release, RelWithDebInfo, and MinSizeRel. Default |; | | is Debug. |; +",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:23815,config,config,23815,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['config']
Modifiability,", and several books on; the subject that you can get, so it will not be discussed in this document. Here are some useful links:. #. `cppreference.com; <https://en.cppreference.com/w/>`_ - an excellent; reference for the STL and other parts of the standard C++ library. #. `cplusplus.com; <https://cplusplus.com/reference/>`_ - another excellent; reference like the one above. #. `C++ In a Nutshell <http://www.tempest-sw.com/cpp/>`_ - This is an O'Reilly; book in the making. It has a decent Standard Library Reference that rivals; Dinkumware's, and is unfortunately no longer free since the book has been; published. #. `C++ Frequently Asked Questions <https://www.parashift.com/c++-faq-lite/>`_. #. `Bjarne Stroustrup's C++ Page; <https://www.stroustrup.com/C++.html>`_. #. `Bruce Eckel's Thinking in C++, 2nd ed. Volume 2.; (even better, get the book); <https://archive.org/details/TICPP2ndEdVolTwo>`_. You are also encouraged to take a look at the :doc:`LLVM Coding Standards; <CodingStandards>` guide which focuses on how to write maintainable code more; than where to put your curly braces. .. _resources:. Other useful references; -----------------------. #. `Using static and shared libraries across platforms; <http://www.fortran-2000.com/ArnaudRecipes/sharedlib.html>`_. .. _apis:. Important and useful LLVM APIs; ==============================. Here we highlight some LLVM APIs that are generally useful and good to know; about when writing transformations. .. _isa:. The ``isa<>``, ``cast<>`` and ``dyn_cast<>`` templates; ------------------------------------------------------. The LLVM source-base makes extensive use of a custom form of RTTI. These; templates have many similarities to the C++ ``dynamic_cast<>`` operator, but; they don't have some drawbacks (primarily stemming from the fact that; ``dynamic_cast<>`` only works on classes that have a v-table). Because they are; used so often, you must know what they do and how they work. All of these; templates are defined in the ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:3112,maintainab,maintainable,3112,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['maintainab'],['maintainable']
Modifiability,", and start with an upper case letter (e.g. Leader or Boats). This rule is the same as that for type names. This is a problem because the; type name cannot be reused for a variable name [*]_. LLVM developers tend to; work around this by either prepending ``The`` to the type name::. Triple TheTriple;. ... or more commonly use an acronym, despite the coding standard stating ""Avoid; abbreviations unless they are well known""::. Triple T;. The proliferation of acronyms leads to hard-to-read code such as `this; <https://github.com/llvm/llvm-project/blob/0a8bc14ad7f3209fe702d18e250194cd90188596/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L7445>`_::. InnerLoopVectorizer LB(L, PSE, LI, DT, TLI, TTI, AC, ORE, VF.Width, IC,; &LVL, &CM);. Many other coding guidelines [LLDB]_ [Google]_ [WebKit]_ [Qt]_ [Rust]_ [Swift]_; [Python]_ require that variable names begin with a lower case letter in contrast; to class names which begin with a capital letter. This convention means that the; most readable variable name also requires the least thought::. Triple triple;. There is some agreement that the current rule is broken [LattnerAgree]_; [ArsenaultAgree]_ [RobinsonAgree]_ and that acronyms are an obstacle to reading; new code [MalyutinDistinguish]_ [CarruthAcronym]_ [PicusAcronym]_. There are; some opposing views [ParzyszekAcronym2]_ [RicciAcronyms]_. This work-in-progress proposal is to change the coding standard for variable; names to require that they start with a lower case letter. .. [*] In `some cases; <https://github.com/llvm/llvm-project/blob/8b72080d4d7b13072f371712eed333f987b7a18e/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp#L2727>`_; the type name *is* reused as a variable name, but this shadows the type name; and confuses many debuggers [DenisovCamelBack]_. Variable Names Coding Standard Options; ======================================. There are two main options for variable names that begin with a lower case; letter: ``camelBack`` and ``lower_case``. (These are also kno",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:1951,variab,variable,1951,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability,", and; each result may be what an analysis wants (IE; TBAA may say no-alias, and something else may say must-alias), it is; not possible to partition the memory the way every optimization wants.; Second, some alias analysis results are not transitive (IE A noalias B,; and B noalias C, does not mean A noalias C), so it is not possible to; come up with a precise partitioning in all cases without variables to; represent every pair of possible aliases. Thus, partitioning; precisely may require introducing at least N^2 new virtual variables,; phi nodes, etc. Each of these variables may be clobbered at multiple def sites. To give an example, if you were to split up struct fields into; individual variables, all aliasing operations that may-def multiple struct; fields, will may-def more than one of them. This is pretty common (calls,; copies, field stores, etc). Experience with SSA forms for memory in other compilers has shown that; it is simply not possible to do this precisely, and in fact, doing it; precisely is not worth it, because now all the optimizations have to; walk tons and tons of virtual variables and phi nodes. So we partition. At the point at which you partition, again,; experience has shown us there is no point in partitioning to more than; one variable. It simply generates more IR, and optimizations still; have to query something to disambiguate further anyway. As a result, LLVM partitions to one variable. Precision in practice; ^^^^^^^^^^^^^^^^^^^^^. In practice, there are implementation details in LLVM that also affect the; results' precision provided by ``MemorySSA``. For example, AliasAnalysis has various; caps, or restrictions on looking through phis which can affect what ``MemorySSA``; can infer. Changes made by different passes may make MemorySSA either ""overly; optimized"" (it can provide a more accurate result than if it were recomputed; from scratch), or ""under optimized"" (it could infer more if it were recomputed).; This can lead to challenges to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:18126,variab,variables,18126,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['variab'],['variables']
Modifiability,", const char *argv[], const char *envp[]) {; if (setenv(""MY_NEW_VAR"", ""new_value"", 1) != 0) {; // setenv call may invalidate 'envp'; /* Handle error */; }; if (envp != NULL) {; for (size_t i = 0; envp[i] != NULL; ++i) {; puts(envp[i]);; // envp may no longer point to the current environment; // this program has unanticipated behavior, since envp; // does not reflect changes made by setenv function.; }; }; return 0;; }. void previous_call_invalidation() {; char *p, *pp;. p = getenv(""VAR"");; setenv(""SOMEVAR"", ""VALUE"", /*overwrite = */1);; // call to 'setenv' may invalidate p. *p;; // dereferencing invalid pointer; }. The ``InvalidatingGetEnv`` option is available for treating ``getenv`` calls as; invalidating. When enabled, the checker issues a warning if ``getenv`` is called; multiple times and their results are used without first creating a copy.; This level of strictness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:21900,config,config,21900,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['config']
Modifiability,", convert your RooArgList to a RooArgSet. * The function `RooFit::bindFunction()` now supports arbitrary many input variables when binding a Python function. * The `ExportOnly()` attribute of the `RooStats::HistFactory::Measurement` object is now switched on by default, and the associated getter and setter functions are deprecated. They will be removed in ROOT 6.36. If you want to fit the model as well instead of just exporting it to a RooWorkspace, please do so with your own code as demonstrated in the `hf001` tutorial. ### Deprecations. * The `RooStats::MarkovChain::GetAsDataSet` and `RooStats::MarkovChain::GetAsDataHist` functions are deprecated and will be removed in ROOT 6.36. The same functionality can be implemented by calling `RooAbsData::reduce` on the Markov Chain's `RooDataSet*` (obtained using `MarkovChain::GetAsConstDataSet`) and then obtaining its binned clone(for `RooDataHist`). An example in Python would be:. ```py; mcInt = mc.GetInterval() # Obtain the MCMCInterval from a configured MCMCCalculator; mkc = mcInt.GetChain() # Obtain the MarkovChain; mkcData = mkc.GetAsConstDataSet(); mcIntParams = mcInt.GetParameters(). chainDataset = mkcData.reduce(SelectVars=mcIntParams, EventRange=(mcInt.GetNumBurnInSteps(), mkc.Size())); chainDataHist = chainDataset.binnedClone(); ```. * The following methods related to the RooAbsArg interface are deprecated and will be removed in ROOT 6.36.; They should be replaced with the suitable alternatives interfaces:. - `RooAbsArg::getDependents()`: use `getObservables()`; - `RooAbsArg::dependentOverlaps()`: use `observableOverlaps()`; - `RooAbsArg::checkDependents()`: use `checkObservables()`; - `RooAbsArg::recursiveCheckDependents()`: use `recursiveCheckObservables()`. ## Graphics Backends. ## 2D Graphics Libraries. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## PyROOT. ### Typesafe `TTree::SetBranchAddress(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:5988,config,configured,5988,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['config'],['configured']
Modifiability,", either; ``posix`` or ``windows``. The default when on Windows is ``windows``, otherwise the; default is ``posix``. .. option:: --thin. When creating or modifying an archive, this option specifies that the; ``archive`` will be thin. By default, archives are not created as thin archives; and when modifying a thin archive, it will be converted to a regular archive. .. option:: --version. Display the version of the :program:`llvm-ar` executable. .. option:: -X mode. Specifies the type of object file :program:`llvm-ar` will recognise. The mode must be; one of the following:. 32; Process only 32-bit object files.; 64; Process only 64-bit object files.; 32_64; Process both 32-bit and 64-bit object files.; any; Process all object files. The default is to process 32-bit object files (ignore 64-bit objects). The mode can also; be set with the OBJECT_MODE environment variable. For example, OBJECT_MODE=64 causes ar to; process any 64-bit objects and ignore 32-bit objects. The -X flag overrides the OBJECT_MODE; variable. .. option:: @<FILE>. Read command-line options and commands from response file ``<FILE>``. MRI SCRIPTS; -----------. :program:`llvm-ar` understands a subset of the MRI scripting interface commonly; supported by archivers following in the ar tradition. An MRI script contains a; sequence of commands to be executed by the archiver. The :option:`-M` option; allows for an MRI script to be passed to :program:`llvm-ar` through the; standard input stream. Note that :program:`llvm-ar` has known limitations regarding the use of MRI; scripts:. * Each script can only create one archive.; * Existing archives can not be modified. MRI Script Commands; ~~~~~~~~~~~~~~~~~~~. Each command begins with the command's name and must appear on its own line.; Some commands have arguments, which must be separated from the name by; whitespace. An MRI script should begin with either a :option:`CREATE` or; :option:`CREATETHIN` command and will typically end with a :option:`SAVE`; command. A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst:11356,variab,variable,11356,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,1,['variab'],['variable']
Modifiability,", identifier hash table, pragma; handling, tokens, and macro expansion.; libparse - Parsing. This library invokes coarse-grained 'Actions'; provided by the client (e.g. libsema builds ASTs) but knows nothing about; ASTs or other client-specific data structures.; libsema - Semantic Analysis. This provides a set of parser actions; to build a standardized AST for programs.; libcodegen - Lower the AST to LLVM IR for optimization & code; generation.; librewrite - Editing of text buffers (important for code rewriting; transformation, like refactoring).; libanalysis - Static analysis support.; clang - A driver program, client of the libraries at various; levels. As an example of the power of this library based design.... If you wanted to; build a preprocessor, you would take the Basic and Lexer libraries. If you want; an indexer, you would take the previous two and add the Parser library and; some actions for indexing. If you want a refactoring, static analysis, or; source-to-source compiler tool, you would then add the AST building and; semantic analyzer libraries.; For more information about the low-level implementation details of the; various clang libraries, please see the ; clang Internals Manual. Support Diverse Clients. Clang is designed and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different clients have very different; requirements. Consider code generation, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:6130,refactor,refactoring,6130,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['refactor'],['refactoring']
Modifiability,", leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6638,variab,variables,6638,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variables']
Modifiability,", one to show the use of; `DrawClonePad` and the other to show the use of `DrawClone`. ### Using the GUI. In this example we will copy an entire canvas to a new one with; `DrawClonePad`. Run the script `draw2dopt.C`. ``` {.cpp}; root[] .x tutorials/hist/draw2dopt.C; ```. This creates a canvas with 2D histograms. To make a copy of the canvas; follow the steps:. - Right-click on it to bring up the context menu. - Select `DrawClonePad`. This copies the entire canvas and all its sub-pads to a new canvas. The; copied canvas is a deep clone, and all the objects on it are copies and; independent of the original objects. For instance, change the fill on; one of the original histograms, and the cloned histogram retains its; attributes. `DrawClonePad` will copy the canvas to the active pad; the; target does not have to be a canvas. It can also be a pad on a canvas. ![Different draw options](pictures/030000D7.png). If you want to copy and paste a graphic object from one canvas or pad to; another canvas or pad, you can do so with `DrawClone` method inherited; from **`TObject`**. All graphics objects inherit the; `TObject::DrawClone` method. In this example, we create a new canvas; with one histogram from each of the canvases from the script; `draw2dopt.C`. - Start a new ROOT session and execute the script `draw2dopt.C`. - Select a canvas displayed by the script, and create a new canvas; `c1` from the File menu. - Make sure that the target canvas (`c1`) is the active one by middle; clicking on it. If you do this step right after step 2, c1 will be; active. - Select the pad with the first histogram you want to copy and paste. - Right click on it to show the context menu, and select `DrawClone`. - Leave the option blank and hit OK. Repeat these steps for one histogram on each of the canvases created by; the script, until you have one pad from each type. If you wanted to put; the same annotation on each of the sub pads in the new canvas, you could; use `DrawClone` to do so. Here we",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:87081,inherit,inherited,87081,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inherited']
Modifiability,", or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:126396,variab,variable,126396,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,", several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors for types with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=none or -analyzer-config ipa=basic-inlining,; regardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option controls whether C++ templated functions may be inlined. ``-analyzer-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this option is that very generic code can be a source; of false positives, either by considering paths that the caller considers; impossible (by some unstated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:2560,config,config,2560,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,2,['config'],['config']
Modifiability,", size: 32, encoding: DW_ATE_signed); !20 = !DIExpression(DW_OP_LLVM_implicit_pointer)). IR for ""**ptr = 4;""; --------------; call void @llvm.dbg.value(metadata i32 4, metadata !17, metadata !21); !17 = !DILocalVariable(name: ""ptr1"", scope: !12, file: !3, line: 5,; type: !18); !18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64); !19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64); !20 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !21 = !DIExpression(DW_OP_LLVM_implicit_pointer,; DW_OP_LLVM_implicit_pointer)). DWARF specifies three kinds of simple location descriptions: Register, memory,; and implicit location descriptions. Note that a location description is; defined over certain ranges of a program, i.e the location of a variable may; change over the course of the program. Register and memory location; descriptions describe the *concrete location* of a source variable (in the; sense that a debugger might modify its value), whereas *implicit locations*; describe merely the actual *value* of a source variable which might not exist; in registers or in memory (see ``DW_OP_stack_value``). A ``llvm.dbg.declare`` intrinsic describes an indirect value (the address) of a; source variable. The first operand of the intrinsic must be an address of some; kind. A DIExpression attached to the intrinsic refines this address to produce a; concrete location for the source variable. A ``llvm.dbg.value`` intrinsic describes the direct value of a source variable.; The first operand of the intrinsic may be a direct or indirect value. A; DIExpression attached to the intrinsic refines the first operand to produce a; direct value. For example, if the first operand is an indirect value, it may be; necessary to insert ``DW_OP_deref`` into the DIExpression in order to produce a; valid debug intrinsic. .. note::. A DIExpression is interpreted in the same way regardless of which kind of; debug intrinsic it's attached to. .. code-block:: t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:267627,variab,variable,267627,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['variab'],['variable']
Modifiability,", the TTreeCache will read all the; branches thus trading off the latencies inherent to multiple small reads for; the potential of requesting more data than needed by read from the disk or; server the baskets for too many branches. The default behavior can be changed by either updating one of the rootrc files; or by setting environment variables. The rootrc files, both the global and the; local ones, now support the following the resource variable TTreeCache.Size; which set the default size factor for auto sizing TTreeCache for TTrees. The; estimated cluster size for the TTree and this factor is used to give the cache; size. If option is set to zero auto cache creation is disabled and the default; cache size is the historical one (equivalent to factor 1.0). If set to; non zero auto cache creation is enabled and both auto created and; default sized caches will use the configured factor: 0.0 no automatic cache; and greater than 0.0 to enable cache. This value can be overridden by the; environment variable ROOT_TTREECACHE_SIZE. The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling; type. The prefill type may be: 0 for no prefilling and 1 to prefill all; the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL. In particular the default can be set back to the same as in version 5 by; setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill; (or ROOT_TTREECACHE_PREFILL) both to zero. TTree methods which are expected to modify a cache, like AddBranchToCache, will; attempt to setup a cache of default size if one does not exist, irrespective of; whether the auto cache creation is enabled. Additionally several methods giving; control of the cache have changed return type from void to Int_t, to be able to; return a code to indicate if there was an error. Usually TTree::SetCacheSize will no longer reset the list of branches to be; cached (either set or previously learnt) nor restart the learning phase.; Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:13825,variab,variable,13825,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['variab'],['variable']
Modifiability,", the variable; location is safely dropped and marked ""optimised out"". The exception is; instructions that are mutated rather than replaced, which always need debug info; maintenance. # Register allocator considerations. When the register allocator runs, debugging instructions do not directly refer; to any virtual registers, and thus there is no need for expensive location; maintenance during regalloc (i.e. `LiveDebugVariables`). Debug instructions are; unlinked from the function, then linked back in after register allocation; completes. The exception is `PHI` instructions: these become implicit definitions at; control flow merges once regalloc finishes, and any debug numbers attached to; `PHI` instructions are lost. To circumvent this, debug numbers of `PHI`s are; recorded at the start of register allocation (`phi-node-elimination`), then; `DBG_PHI` instructions are inserted after regalloc finishes. This requires some; maintenance of which register a variable is located in during regalloc, but at; single positions (block entry points) rather than ranges of instructions. An example, before regalloc:. ```text; bb.2:; %2 = PHI %1, %bb.0, %2, %bb.1, debug-instr-number 1; ```. After:. ```text; bb.2:; DBG_PHI $rax, 1; ```. # `LiveDebugValues`. After optimisations and code layout complete, information about variable; values must be translated into variable locations, i.e. registers and stack; slots. This is performed in the [`LiveDebugValues` pass][LiveDebugValues], where; the debug instructions and machine code are separated out into two independent; functions:; * One that assigns values to variable names,; * One that assigns values to machine registers and stack slots. LLVM's existing SSA tools are used to place `PHI`s for each function, between; variable values and the values contained in machine locations, with value; propagation eliminating any unnecessary `PHI`s. The two can then be joined up; to map variables to values, then values to locations, for each instructio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:3970,variab,variable,3970,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['variab'],['variable']
Modifiability,", there is no way to distinguish in the LLVM IR whether an; SSA-value came from a C ""int"" or a C ""long"" on an ILP32 machine (other; than debug info). Both get compiled down to an 'i32' value and the; information about what it came from is lost. The more general issue; here, is that the LLVM type system uses ""structural equivalence"" instead; of ""name equivalence"". Another place this surprises people is if you; have two types in a high-level language that have the same structure; (e.g. two different structs that have a single int field): these types; will compile down into a single LLVM type and it will be impossible to; tell what it came from. Second, while LLVM does lose information, LLVM is not a fixed target: we; continue to enhance and improve it in many different ways. In addition; to adding new features (LLVM did not always support exceptions or debug; info), we also extend the IR to capture important information for; optimization (e.g. whether an argument is sign or zero extended,; information about pointers aliasing, etc). Many of the enhancements are; user-driven: people want LLVM to include some specific feature, so they; go ahead and extend it. Third, it is *possible and easy* to add language-specific optimizations,; and you have a number of choices in how to do it. As one trivial; example, it is easy to add language-specific optimization passes that; ""know"" things about code compiled for a language. In the case of the C; family, there is an optimization pass that ""knows"" about the standard C; library functions. If you call ""exit(0)"" in main(), it knows that it is; safe to optimize that into ""return 0;"" because C specifies what the; 'exit' function does. In addition to simple library knowledge, it is possible to embed a; variety of other language-specific information into the LLVM IR. If you; have a specific need and run into a wall, please bring the topic up on; the llvm-dev list. At the very worst, you can always treat LLVM as if it; were a ""dumb code ge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:10111,extend,extended,10111,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['extend'],['extended']
Modifiability,", which CMake refers to using the following variable expansions:; CMAKE_${LANGUAGE}_FLAGS and CMAKE_${LANGUAGE}_FLAGS_${CMAKE_BUILD_TYPE}. Other Types; -----------. Variables that are cached or specified on the command line can have types; associated with them. The variable's type is used by CMake's UI tool to display; the right input field. A variable's type generally doesn't impact evaluation,; however CMake does have special handling for some variables such as PATH.; You can read more about the special handling in `CMake's set documentation; <https://cmake.org/cmake/help/v3.5/command/set.html#set-cache-entry>`_. Scope; -----. CMake inherently has a directory-based scoping. Setting a variable in a; CMakeLists file, will set the variable for that file, and all subdirectories.; Variables set in a CMake module that is included in a CMakeLists file will be; set in the scope they are included from, and all subdirectories. When a variable that is already set is set again in a subdirectory it overrides; the value in that scope and any deeper subdirectories. The CMake set command provides two scope-related options. PARENT_SCOPE sets a; variable into the parent scope, and not the current scope. The CACHE option sets; the variable in the CMakeCache, which results in it being set in all scopes. The; CACHE option will not set a variable that already exists in the CACHE unless the; FORCE option is specified. In addition to directory-based scope, CMake functions also have their own scope.; This means variables set inside functions do not bleed into the parent scope.; This is not true of macros, and it is for this reason LLVM prefers functions; over macros whenever reasonable. .. note::; Unlike C-based languages, CMake's loop and control flow blocks do not have; their own scopes. Control Flow; ============. CMake features the same basic control flow constructs you would expect in any; scripting language, but there are a few quirks because, as with everything in; CMake, control f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:6487,variab,variable,6487,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variable']
Modifiability,", with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); ```. The first parameter is the branch name. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:35162,variab,variables,35162,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,2,['variab'],"['variable', 'variables']"
Modifiability,", you; would need to add parentheses like this ``{{([[:xdigit:]]{8})}}`` to avoid; confusion with FileCheck's closing double-brace. FileCheck String Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. It is often useful to match a pattern and then verify that it occurs again; later in the file. For codegen tests, this can be useful to allow any; register, but verify that that register is used consistently later. To do; this, :program:`FileCheck` supports string substitution blocks that allow; string variables to be defined and substituted into patterns. Here is a simple; example:. .. code-block:: llvm. ; CHECK: test5:; ; CHECK: notw	[[REGISTER:%[a-z]+]]; ; CHECK: andw	{{.*}}[[REGISTER]]. The first check line matches a regex ``%[a-z]+`` and captures it into the; string variable ``REGISTER``. The second line verifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operands of ``op`` to be the same register,; and don't care exactly which register it is. If ``--enable-var-scope`` is in effect, variables with names that; start with ``$`` are considered to be global. All others variables are; local. All local variables get undefined at the beginning of each; CHECK-LABEL block. Global variables are not affected by CHECK-LABEL.; This makes it easier to ensure that individual tests are not affected; by variables set in preceding tests. FileCheck Numeric Substitution Blocks; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:26912,variab,variable,26912,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability,",""Flag/i"");; tree->Branch(""Age"",&Age,""Age/I"");; tree->Branch(""Service"",&Service,""Service/I"");; tree->Branch(""Children"",&Children,""Children/I"");; tree->Branch(""Grade"",&Grade,""Grade/I"");; tree->Branch(""Step"",&Step,""Step/I"");; tree->Branch(""Hrweek"",&Hrweek,""Hrweek/I"");; tree->Branch(""Cost"",&Cost,""Cost/I"");; tree->Branch(""Division"",Division,""Division/C"");; tree->Branch(""Nation"",Nation,""Nation/C"");; char line[80];; while (fgets(line,80,fp)) {; sscanf(&line[0],""%d %d %d %d %d %d %d %d %d %s %s"",; &Category,&Flag,&Age,&Service,&Children,&Grade,&Step,&Hrweek,&Cost,Division,Nation);; tree->Fill();; }; tree->Print();; tree->Write();. fclose(fp);; delete hfile;; }; ```. The script opens the; ASCII file, creates a ROOT file and a **`TTree`**. Then it creates; branches with the `TTree::Branch` method. The first parameter of the; `Branch` method is the branch name. The second parameter is the address; from which the first leaf is to be read. Once the branches are defined, the script; reads the data from the ASCII file into C variables and; fills the `tree`. The ASCII file is closed, and the ROOT file is written; to disk saving the `tree`. Remember, trees (and histograms) are created in; the current directory, which is the file in our example. Hence a; `f->Write() `saves the tree. ## Show an Entry with TTree::Show. An easy way to access one entry of a tree is the use the `TTree::Show`; method. For example to look at the 10th entry in the `cernstaff.root` tree:. ``` {.cpp}; root[] TFile f(""cernstaff.root""); root[] T->Show(10); ======> EVENT:10; Category = 361; Flag = 15; Age = 51; Service = 29; Children = 0; Grade = 7; Step = 13; Hrweek = 40; Cost = 7599; Division = PS; Nation = FR; ```. ## Print the Tree Structure with TTree::Print. A helpful command to see the tree structure meaning the number of; entries, the branches and the leaves, is `TTree::Print`. ``` {.cpp}; root[] T->Print(); **********************************************************************; *Tree :T : staff data fro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:4435,variab,variables,4435,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,",100);; for (i = 0; i < 10; i++) {; sprintf(tmp, ""Entry%i"", i+1);; fCombo->AddEntry(tmp, i+1);; }; fCombo->Resize(150, 20);; // Entry3 is selected as current; fCombo->Select(2);; parent->AddFrame(fCombo, fLcombo);; ```. You have the same flexibility to add, insert or remove entries. As with; list boxes you can retrieve the information for currently selected item; via `GetSelected` or `GetSelectedEntry` methods. The first one returns; the entry ID, the second - the current entry pointer; (**`TGLBEntry *`**). ### Sliders. A slider is a scale with an indicator (slider) that you can drag to; choose a value from a predefined range. It may be oriented horizontally; or vertically. In both cases it provides an excellent indication of; where a value exists within a range of values. ![](pictures/0200021B.jpg). The class **`TGHSlider`** represents the horizontal slider;; **`TGVSlider`** - the vertical one. Both inherit from the base class; **`TGSlider`** that creates the main slider parameters: the range of; values within a value can be selected; the indicator type; the tick mark; scale. Using its methods `SetRange`, `SetPosition` and `SetScale` you; can set these parameters. To retrieve the set slider value you can call; `GetPosition` method. Next sample code creates a horizontal slider `hslider` with a tick mark; of type `kSlider1`. Its width is 150 pixels, and its scale is placed; down (`kScaleDownRight`). The last parameter in the **`TGHSlider`**; constructor is the slider ID. It will be used for event processing. The; methods `SetRange` and `SetPosition` set the range and the current tick; mark position of the slider. ``` {.cpp}; hslider = new TGHSlider(parent,150,kSlider1|kScaleDownRight,sID);; hslider->SetRange(0,50);; hslider->SetPosition(39);; ```. Slider values can be set by using the mouse to drag the slider across; the scale until the desired value is reached. Another way is to click in; the slider trough instead of dragging. #### Double Slider. Double slider widget",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:84538,inherit,inherit,84538,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inherit']
Modifiability,",; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax instead, i.e. [I class]. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:23112,extend,extend,23112,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['extend'],['extend']
Modifiability,",; you should adjust the buffer size accordingly. A recommended buffer size; is 32000 bytes if you have less than 50 branches. Around 16000 bytes if; you have less than 100 branches and 4000 bytes if you have more than 500; branches. These numbers are recommended for computers with memory size; ranging from 32MB to 256MB. If you have more memory, you should specify; larger buffer sizes. However, in this case, do not forget that your file; might be used on another machine with a smaller memory configuration. #### Performance Considerations when Splitting a Branch. A split branch is faster to read, but slightly slower to write. The; reading is quicker because variables of the same type are stored; consecutively and the type does not have to be read each time. It is; slower to write because of the large number of buffers as described; above. See "". Performance Benchmarks"" for performance impact of split and non-split; mode. #### Rules for Splitting. When splitting a branch, variables of different types are handled; differently. Here are the rules that apply when splitting a branch. - If a data member is a basic type, it becomes one branch of class; **`TBranchElement`**. - A data member can be an array of basic types. In this case, one; single branch is created for the array. - A data member can be a pointer to an array of basic types. The; length can vary, and must be specified in the comment field of the; data member in the class definition. See ""Input/Output"". - Pointer data member are not split, except for pointers to a; **`TClonesArray`**. The **`TClonesArray`** (pointed to) is split if; the split level is greater than two. When the split level is one,; the **`TClonesArray`** is not split. - If a data member is a pointer to an object, a special branch is; created. The branch will be filled by calling the class `Streamer`; function to serialize the object into the branch buffer. - If a data member is an object, the data members of this object are; split into branche",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:26877,variab,variables,26877,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,",RooConst(0.8),RooConst(0.1)) ;. // Multiply constraint with p.d.f; RooProdPdf pdfc(""pdfc"",""p.d.f with constraint"",RooArgSet(p.d.f,fconstraint)) ;. If your top level p.d.f is already a RooProdPdf it also fine to multiply all terms together in one go.; Constraints do not need to be specified a the top-level RooProdPdf, constraint p.d.f.s in any component; RooProdPdf lower in the expression tree are used as well. Constraints are not used by default in fitting; if present in a p.d.f. To activate the use of a constraint in fitting, use the Constrain() argument in fitTo(). // Fit with internal constraint; RooFitResult* r2 = pdfc.fitTo(*d,Constrain(f)) ;; ; This will instruct RooAbsPdf::fitTo() to included any constraint p.d.f on parameter f in the; definition of the likelihood. It is possible to add multiple constraints on the same parameter; to the 'master' p.d.f. If so, all constraints on a given parameter will be added to the likelihood. The RooMCStudy class has been extended to accept the Constrain() argument as well in its constructor.; If specified it will do two things: 1) it will pass the constrain argument to the fitting pass of; the toy study and 2) it will modify the generation step into a two-step procedure: for each toy; in the study it will first sample a value of each constrained parameter from the joint constraints; p.d.f and it will then generate the observables for that experiment with the thus obtained parameter values.; In this mode of operation the parameter values for each toy may thus be different. The actual parameter; for each toy can be obtained with the newly added RooMCStudy::genParDataSet() member function. The calculation; of the pull values for each parameter has been modified accordingly. Alternatively, it is possible to specify constraints to both RooAbsPdf::fitTo() and the RooMCStudy constructor; using the ExternalConstraint() named argument to supply constraint p.d.f.s that are not part of the 'master'; p.d.f but rather an ad-hoc suppli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:8478,extend,extended,8478,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['extend'],['extended']
Modifiability,",m,s one can now do. RooWorkspace w(""w"",true) ; // workspace with CINT interface activated; // ... fill workspace with RooGaussian gauss(x,m,s) ...; RooPlot* frame = w::x.frame() ;; w::gauss.plotOn(frame) ;. to access the workspace contents. Each reference has the correct type, e.g. w::gauss is; a RooGaussian&. If a workspace is deleted from memory, the corresponding CINT namespace; is removed as well. Note that this feature is strictly available in interpreted C++ only; A new tutorial macro has been added to illustrate this functionality in more detail: rf509_wsinteractive.C.; writeToFile -- A new utility method RooWorkspace::writeToFile() has been added; to simplify the process of saving a workspace to file; Named sets and parameter snapshots -- It is now possible to define and retrieve; named RooArgSets of objects that live in the workspace through methods; defineSet() and set(). While named sets merely group objects logically, methods loadSnapshot and; saveSnapshot allow to make copies of the values, errors and 'constant' status of; sets of variable objects that live in the workspace. A newly added tutorial macro rf510_namedsets.C illustrates the functionality of both; of these features.; Improved printing of contents -- Many operator p.d.f. and function components now show; a more intuitive natural representation of their contents (these changes are mostly in the; respective p.d.f.s, but are most relevant in the context of a workspace). New object factory interface to workspace to facilitate script driven model definition; A object factory has been added to RooFit to simplify the process of creating p.d.f.; and function expressions consisting of multiple objects. The factory has two goals:; the first is to provide a back-end for higher level factories and tools to process; the creation of objects. The second is to provide a simple end-user language to; populate a RooWorkspace with function and p.d.f. objects. For the latter purpose the object creation language ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:17656,variab,variable,17656,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['variab'],['variable']
Modifiability,- :part:`40%`; * - clang-tools-extra/clang-tidy/fuchsia; - `15`; - `10`; - `5`; - :part:`66%`; * - clang-tools-extra/clang-tidy/google; - `33`; - `22`; - `11`; - :part:`66%`; * - clang-tools-extra/clang-tidy/hicpp; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clang-tidy/linuxkernel; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/llvm; - `11`; - `10`; - `1`; - :part:`90%`; * - clang-tools-extra/clang-tidy/llvmlibc; - `7`; - `7`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/misc; - `33`; - `30`; - `3`; - :part:`90%`; * - clang-tools-extra/clang-tidy/modernize; - `67`; - `48`; - `19`; - :part:`71%`; * - clang-tools-extra/clang-tidy/mpi; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/objc; - `17`; - `12`; - `5`; - :part:`70%`; * - clang-tools-extra/clang-tidy/openmp; - `5`; - `5`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/performance; - `31`; - `24`; - `7`; - :part:`77%`; * - clang-tools-extra/clang-tidy/plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy/portability; - `5`; - `3`; - `2`; - :part:`60%`; * - clang-tools-extra/clang-tidy/readability; - `88`; - `76`; - `12`; - :part:`86%`; * - clang-tools-extra/clang-tidy/tool; - `3`; - `2`; - `1`; - :part:`66%`; * - clang-tools-extra/clang-tidy/utils; - `35`; - `31`; - `4`; - :part:`88%`; * - clang-tools-extra/clang-tidy/zircon; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd; - `97`; - `81`; - `16`; - :part:`83%`; * - clang-tools-extra/clangd/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/benchmarks/CompletionModel; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clangd/fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index; - `39`; - `36`; - `3`; - :part:`92%`; * - clang-tools-extra/clangd/index/dex; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clangd/index/dex/dexp; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:18238,plugin,plugin,18238,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugin']
Modifiability,"- Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementwise_log2`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp2`` builtin for floating point types only.; - Add ``__builtin_set_flt_rounds`` builtin for X86, x86_64, Arm and AArch64 only.; - Add ``__builtin_elementwise_pow`` builtin for floating point types only.; - Add ``__builtin_elementwise_bitreverse`` builtin for integer types only.; - Add ``__builtin_elementwise_sqrt`` builtin for floating point types only.; - ``__builtin_isfpclass`` builtin now supports vector types.; - ``#pragm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65905,variab,variables,65905,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,- `0`; - :good:`100%`; * - mlir/unittests/Pass; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/Rewrite; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Support; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`;,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122168,plugin,plugins,122168,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"- ``debug-info-expression`` adds qualifiers to the variable location,. - ``debug-info-location`` identifies a DILocation metadata node. These metadata attributes correspond to the operands of a ``llvm.dbg.declare``; IR intrinsic, see the :ref:`source level debugging<format_common_intrinsics>`; documentation. Varying variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Variables that are not always on the stack or change location are specified; with the ``DBG_VALUE`` meta machine instruction. It is synonymous with the; ``llvm.dbg.value`` IR intrinsic, and is written:. .. code-block:: text. DBG_VALUE $rax, $noreg, !123, !DIExpression(), debug-location !456. The operands to which respectively:. 1. Identifies a machine location such as a register, immediate, or frame index,. 2. Is either $noreg, or immediate value zero if an extra level of indirection is to be added to the first operand,. 3. Identifies a ``DILocalVariable`` metadata node,. 4. Specifies an expression qualifying the variable location, either inline or as a metadata node reference,. While the source location identifies the ``DILocation`` for the scope of the; variable. The second operand (``IsIndirect``) is deprecated and to be deleted.; All additional qualifiers for the variable location should be made through the; expression metadata. .. _instruction-referencing-locations:. Instruction referencing locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This experimental feature aims to separate the specification of variable; *values* from the program point where a variable takes on that value. Changes; in variable value occur in the same manner as ``DBG_VALUE`` meta instructions; but using ``DBG_INSTR_REF``. Variable values are identified by a pair of; instruction number and operand number. Consider the example below:. .. code-block:: text. $rbp = MOV64ri 0, debug-instr-number 1, debug-location !12; DBG_INSTR_REF !123, !DIExpression(DW_OP_LLVM_arg, 0), dbg-instr-ref(1, 0), debug-location !456. Instruction numbers are d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:26091,variab,variable,26091,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability,"- draw TH2Poly bins outline when no content specified; 2. Fix - always set axis interactive handlers (#170); 3. Fix - take into account zaxis properties when drawing color palette (#171). ## Changes in 5.5.1; 1. Fix - adjust v7 part to new class naming convention, started with R; 2. Fix - show RCanvas title; 3. New - implement 'nocache' option for JSROOT scripts loading. When specified in URL with; JSRootCore.js script, tries to avoid scripts caching problem by adding stamp parameter to all URLs; 4. New - provide simple drawing for TObjString (#164). ## Changes in 5.5.0; 1. Introduce JSROOT.StoreJSON() function. It creates JSON code for the; TCanvas with all drawn objects inside. Allows to store current canvas state; 2. Support ""item=img:file.png"" parameter to insert images in existing layout (#151); 3. Support TTree drawing into TGraph (#153), thanks @cozzyd; 4. Let configure ""&toolbar=right"" in URL to change position of tool buttons; 5. Let configure ""&divsize=500x400"" in URL of size of main div element (default - full browser); 6. Implement ""optstat1001"" and ""optfit101"" draw options for histograms; 7. Remove ""autocol"" options - standard ""plc"" should be used instead; 8. Provide drawing of artificial ""$legend"" item - it creates TLegend for all primitives in pad; Can be used when several histograms or several graphs superimposed; 9. Let configure ""&toolbar=vert"" in URL to change orientation of tool buttons; 10. Improve markers and error bars drawing for TH1/TProfile. ## Changes in 5.4.3; 1. Fix - draw functions also when histogram ""same"" option used (#159); 2. Fix - when draw histogram as markers improve optimization algorithm; 3. Fix - correct histogram Y-axis range selection in logarithmic scale; 4. Fix - for TH2 draw options allow combination ""colztext"" (#162); 5. Fix - PNG file generation with 3D drawings inside. ## Changes in 5.4.2; 1. Fix - take into account extra quotes in multipart http reply (#157); 2. Fix - display of labels on X axis with TProfile; 3. Fix ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:33842,config,configure,33842,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configure']
Modifiability,"--+; | Type | Identifier | Description |; +==========+==============+=======================================================+; | uint64_t | key offset | Absolute byte offset of the key in the string table |; +----------+--------------+-------------------------------------------------------+; | uint64_t | value offset | Absolute byte offset of the value in the string table |; +----------+--------------+-------------------------------------------------------+. The string entries simply provide offsets to a key and value pair in the; binary images string table. The string table is simply a collection of null; terminated strings with defined offsets in the image. The string entry allows us; to create a key-value pair from this string table. This is used for passing; arbitrary arguments to the image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output binary can then be embedded into the host section table; to create a fatbinary containing offloading code. USAGE: clang-offload-packager [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-packa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:7326,extend,extend,7326,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,1,['extend'],['extend']
Modifiability,"----------'. Current testing with real world C++ binaries has shown that there is around 1; 32 bit hash collision per 100,000 name entries. Contents; ^^^^^^^^. As we said, we want to strictly define exactly what is included in the; different tables. For DWARF, we have 3 tables: ""``.apple_names``"",; ""``.apple_types``"", and ""``.apple_namespaces``"". ""``.apple_names``"" sections should contain an entry for each DWARF DIE whose; ``DW_TAG`` is a ``DW_TAG_label``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_subprogram`` that has address attributes: ``DW_AT_low_pc``,; ``DW_AT_high_pc``, ``DW_AT_ranges`` or ``DW_AT_entry_pc``. It also contains; ``DW_TAG_variable`` DIEs that have a ``DW_OP_addr`` in the location (global and; static variables). All global and static variables should be included,; including those scoped within functions and classes. For example using the; following code:. .. code-block:: c. static int var = 0;. void f (); {; static int var = 0;; }. Both of the static ``var`` variables would be included in the table. All; functions should emit both their full names and their basenames. For C or C++,; the full name is the mangled name (if available) which is usually in the; ``DW_AT_MIPS_linkage_name`` attribute, and the ``DW_AT_name`` contains the; function basename. If global or static variables have a mangled name in a; ``DW_AT_MIPS_linkage_name`` attribute, this should be emitted along with the; simple name found in the ``DW_AT_name`` attribute. ""``.apple_types``"" sections should contain an entry for each DWARF DIE whose; tag is one of:. * DW_TAG_array_type; * DW_TAG_class_type; * DW_TAG_enumeration_type; * DW_TAG_pointer_type; * DW_TAG_reference_type; * DW_TAG_string_type; * DW_TAG_structure_type; * DW_TAG_subroutine_type; * DW_TAG_typedef; * DW_TAG_union_type; * DW_TAG_ptr_to_member_type; * DW_TAG_set_type; * DW_TAG_subrange_type; * DW_TAG_base_type; * DW_TAG_const_type; * DW_TAG_immutable_type; * DW_TAG_file_type; * DW_TAG_namelist; * DW_TAG_packed_type; * DW",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:77970,variab,variables,77970,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"--------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. If you do not have write permission in the `$ROOTSYS/test` directory,; copy the entire `$ROOTSYS/test` directory to your area. The `Makefile`; is a useful example of how ROOT applications are linked and built. Edit; the `Makefile` to specify your architecture by changing the `ARCH`; variable, for example, on an SGI machine type:` ARCH` = `sgikcc`. Now compile all programs:. % **`gmake`**. This will build several applications and shared libraries. We are; especially interested in Event, stress, and `guitest`. ### Event - An Example of a ROOT Application. Event is created by compiling `MainEvent.cxx`, and `Event.cxx`. It; creates a ROOT file with a tree and two histograms. When running `Event`; we have four optional arguments with defaults:. +-----+---------------------------------------------------------+--------------+; | | Argument | Default |; +-----+---------------------------------------------------------+--------------+; | 1 | Number of Events (1 ... n) | 400 |; +-----+---------------------------------------------------------+--------------+; | 2 | Compression level: | 1 |; | | | |; | | 0: no compression at all. | |; | | | |; | | 1: If the split level is set to zero, everything is | |; | | compressed according to the `gzip` level 1. If split | |; | | lev",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:6131,variab,variable,6131,documentation/users-guide/TutorialsandTests.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md,1,['variab'],['variable']
Modifiability,"--------------------+; | 46 `->` 63 | `fCompress` | Universal Unique ID |; | [58-\>75] | | |; +-------------------+------------------+---------------------------------------+. The first four bytes of the file header contain the string ""root"" which; identifies a file as a ROOT file. Because of this identifier, ROOT is; not dependent on the ""`.root`"" extension. It is still a good idea to use; the extension, just for us to recognize them easier. The `nfree` and; value is the number of free records. This variable along with; `FNBytesFree` keeps track of the free space in terms of records and; bytes. This count also includes the deleted records, which are available; again. ### The Top Directory Description. The 84 bytes after the file header contain the top directory; description, including the name, the date and time it was created, and; the date and time of the last modification. ``` {.cpp}; 20010404/092347 At:64 N=84 TFile; ```. ### The Histogram Records. What follows are the 15 histograms, in records of variable length. ``` {.cpp}; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; ```. The first 4 bytes of each record is an integer holding the number of; bytes in this record. A negative number flags the record as deleted, and; makes the space available for recycling in the next writing. The rest of; bytes in the header contain all the information to identify uniquely a; data block on the file. It is followed by the object data. The next table explains the values in each individual record. If the key; is located past the 32 bit file limit (\> 2 GB) then some fields will be; 8 bytes instead of 4 bytes (values between the brackets):. +--------------------+-------------------+--------------------------------------+; | Byte | Value Name | Description |; +--------------------+-------------------+--------------------------------------+; | 1 `->` 4 | `Nbytes` | Length of compressed object (in |; | | | bytes) |; +--------------------+---",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:7096,variab,variable,7096,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability,----------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | SIMD | atomic and simd constructs inside SIMD code | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | SIMD | SIMD nontemporal | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | infer target functions from initializers | :part:`worked on` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | infer target variables from initializers | :good:`done` | D146418 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | OMP_TARGET_OFFLOAD environment variable | :good:`done` | D50522 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | support full 'defaultmap' functionality | :good:`done` | D69204 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device specific functions | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+--------------------------,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:10570,variab,variables,10570,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['variab'],['variables']
Modifiability,"---------------------------------+; | LLVM_ENABLE_SPHINX | Build sphinx-based documentation from the source |; | | code. This is disabled by default because it is |; | | slow and generates a lot of output. Sphinx version |; | | 1.5 or later recommended. |; +-------------------------+----------------------------------------------------+; | LLVM_BUILD_LLVM_DYLIB | Generate libLLVM.so. This library contains a |; | | default set of LLVM components that can be |; | | overridden with ``LLVM_DYLIB_COMPONENTS``. The |; | | default contains most of LLVM and is defined in |; | | ``tools/llvm-shlib/CMakelists.txt``. This option is|; | | not available on Windows. |; +-------------------------+----------------------------------------------------+; | LLVM_OPTIMIZED_TABLEGEN | Builds a release tablegen that gets used during |; | | the LLVM build. This can dramatically speed up |; | | debug builds. |; +-------------------------+----------------------------------------------------+. To configure LLVM, follow these steps:. #. Change directory into the object root directory:. .. code-block:: console. % cd OBJ_ROOT. #. Run the ``cmake``:. .. code-block:: console. % cmake -G ""Unix Makefiles"" -DCMAKE_BUILD_TYPE=<type> -DCMAKE_INSTALL_PREFIX=/install/path; [other options] SRC_ROOT. Compiling the LLVM Suite Source Code; ------------------------------------. Unlike with autotools, with CMake your build type is defined at configuration.; If you want to change your build type, you can re-run cmake with the following; invocation:. .. code-block:: console. % cmake -G ""Unix Makefiles"" -DCMAKE_BUILD_TYPE=<type> SRC_ROOT. Between runs, CMake preserves the values set for all options. CMake has the; following build types defined:. Debug. These builds are the default. The build system will compile the tools and; libraries unoptimized, with debugging information, and asserts enabled. Release. For these builds, the build system will compile the tools and libraries; with optimizations enabled and not ge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:28126,config,configure,28126,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configure']
Modifiability,"-----------------------------------+; | int32_t | flags | Flags used to indicate some features, mostly unused. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | char* | psource | Program source information, stored as "";filename;function;line;column;;\\0"" |; +---------+------------+-----------------------------------------------------------------------------+. If debugging information is enabled, we will also create strings to indicate the; names and declarations of variables mapped in target regions. These have the; same format as the source location in the :ref:`identifier structure; <table-ident_t_structure>`, but the function name is replaced with the variable; name. .. _Device Compilation:. Offload Device Compilation; --------------------------. The input file is compiled for each active device toolchain. The device; compilation stage is performed differently from the host stage. Namely, we do; not generate any offloading entries. This is set by passing the; ``-fopenmp-is-target-device`` flag to the front-end. We use the host bitcode to; determine which symbols to export from the device. The bitcode file is passed in; from the previous stage using the ``-fopenmp-host-ir-file-path`` flag.; Compilation is otherwise performed as it would be for any other target triple. When compiling for the OpenMP device, we set the visibility of all device; symbols to be ``protected`` by default. This improves performance and prevents a; class of errors where a symbol in the target device could preempt a host; library. The OpenMP runtime library is linked in during compilation to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:10083,variab,variable,10083,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['variab'],['variable']
Modifiability,"---------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | 'present' motion modifier | :good:`done` | D84711, D84712 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | 'present' in defaultmap clause | :good:`done` | D92427 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | map clause reordering based on 'present' modifier | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device-specific environment variables | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_target_is_accessible routine | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_get_mapped_ptr routine | :good:`done` | D141545 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | new async target memory copy routines | :good:`done` | D136103 |; +------------------------------+--------------------------------------------------------------+--------------------------+------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:23982,variab,variables,23982,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['variab'],['variables']
Modifiability,"--------------------------------------------+; | ``0x02`` | The ending line of the first mapping region in this function. |; +----------+-------------------------------------------------------------------------------------------------------------------------+; | ``0x02`` | The ending column of the first mapping region in this function. |; +----------+-------------------------------------------------------------------------------------------------------------------------+. * The length of the substring that contains the encoded coverage mapping data; for the second function record is also 9. It's structured like the mapping data; for the first function record. * The two trailing bytes are zeroes and are used to pad the coverage mapping; data to give it the 8 byte alignment. Encoding; ========. The per-function coverage mapping data is encoded as a stream of bytes,; with a simple structure. The structure consists of the encoding; `types <cvmtypes_>`_ like variable-length unsigned integers, that; are used to encode `File ID Mapping`_, `Counter Expressions`_ and; the `Mapping Regions`_. The format of the structure follows:. ``[file id mapping, counter expressions, mapping regions]``. The translation unit filenames are encoded using the same encoding; `types <cvmtypes_>`_ as the per-function coverage mapping data, with the; following structure:. ``[numFilenames : LEB128, filename0 : string, filename1 : string, ...]``. .. _cvmtypes:. Types; -----. This section describes the basic types that are used by the encoding format; and can appear after ``:`` in the ``[foo : type]`` description. .. _LEB128:. LEB128; ^^^^^^. LEB128 is an unsigned integer value that is encoded using DWARF's LEB128; encoding, optimizing for the case where values are small; (1 byte for values less than 128). .. _CoverageStrings:. Strings; ^^^^^^^. ``[length : LEB128, characters...]``. String values are encoded with a `LEB value <LEB128_>`_ for the length; of the string and a sequence of bytes for its c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst:22312,variab,variable-length,22312,interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,1,['variab'],['variable-length']
Modifiability,"----------------------------------------------+. The method `ChangeOpton(UInt_t options)` allows you to change frame; options. Next example shows you how to change `kVerticalFrame` option to; `kHorizontalFrame`:. ``` {.cpp}; frame->ChangeOptions((frame->GetOptions()& ~kVerticalFrame) |; kHorizontalFrame);; ```. The class **`TGCompositeFrame`** is the base class of all composite; widgets as a menu bar, a list box, a combo box, etc. It subclasses; **`TGFrame`** and has in addition a layout manager and a list of child; frames/widgets. There are two steps to do the design using a composite; frame widget. First you put all widgets you need within this frame and; assign them desired properties using `AddFrame(),` then you lay them out; by the `Layout()` method according to the assigned layout manager. The; method `AddFrame()` creates an instance of **`TGFrameElement`** class; for every child widget of a composite frame. This class has three public; data members: the child pointer, its layout hints, and a status variable; showing if the child is visible or hidden. If no hints are specified,; the default layout hints are used. Because the layout is very important; part of any design we include a special section about layout management; and layout hints. You can set a layout manager for the composite frame via:. ``` {.cpp}; compFrame->SetLayoutManager(TGLayoutManager *l);; ```. The child widgets cannot be added to different composite frames. Any child frame can be removed from the parent list by:. ``` {.cpp}; compFrame->RemoveFrame(TGFrame *f);; ```. You can hide or show a child frame of a composite frame using the; methods: `HideFrame(TGFrame *f)` or `ShowFrame(TGFrame *f).` You should; call, for example `HideFrame(TGFrame *f),` only after the frames have; been laid out and the sub windows of the composite frame have been; mapped via method `MapSubwindows(),` i.e. ``` {.cpp}; frame->AddFrame(hFrame1,fLayout1);; frame->AddFrame(hFrame2,fLayout2);; frame->Resize(frame->GetDef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:29430,variab,variable,29430,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['variab'],['variable']
Modifiability,-------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | SIMD | SIMD nontemporal | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | infer target functions from initializers | :part:`worked on` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | infer target variables from initializers | :good:`done` | D146418 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | OMP_TARGET_OFFLOAD environment variable | :good:`done` | D50522 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | support full 'defaultmap' functionality | :good:`done` | D69204 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device specific functions | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: device_type | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+;,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:10864,variab,variable,10864,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['variab'],['variable']
Modifiability,-------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | routines for controlling and querying team regions | :part:`partial` | D95003 (libomp only) |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | changes to ompt_scope_endpoint_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | omp_display_env routine | :good:`done` | D74956 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | extended OMP_PLACES syntax | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | OMP_NUM_TEAMS and OMP_TEAMS_THREAD_LIMIT env vars | :good:`done` | D138769 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | 'target_device' selector in context specifier | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | begin/end declare variant | :good:`done` | D71179 |; +------------------------------+--------------------------------------------------------------+--------------------------+--------------,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:30587,extend,extended,30587,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['extend'],['extended']
Modifiability,"------------------------------------------------------------------------. The number of registers and the cost of memory operations is much higher for; AMDGPU than a typical CPU. The compiler attempts to optimize whole variables and; arrays into registers. Currently DWARF only allows ``DW_OP_push_object_address`` and related operations; to work with a global memory location. To support AMDGPU optimized code it is; required to generalize DWARF to allow any location description to be used. This; allows registers, or composite location descriptions that may be a mixture of; memory, registers, or even implicit values. See ``DW_OP_push_object_address`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.8 General Support for Address Spaces; --------------------------------------. AMDGPU needs to be able to describe addresses that are in different kinds of; memory. Optimized code may need to describe a variable that resides in pieces; that are in different kinds of storage which may include parts of registers,; memory that is in a mixture of memory kinds, implicit values, or be undefined. DWARF has the concept of segment addresses. However, the segment cannot be; specified within a DWARF expression, which is only able to specify the offset; portion of a segment address. The segment index is only provided by the entity; that specifies the DWARF expression. Therefore, the segment index is a property; that can only be put on complete objects, such as a variable. That makes it only; suitable for describing an entity (such as variable or subprogram code) that is; in a single kind of memory. AMDGPU uses multiple address spaces. For example, a variable may be allocated in; a register that is partially spilled to the call stack which is in the private; address space, and partially spilled to the local address space. DWARF mentions; address spaces, for example as an argument to the ``DW_OP_xderef*`` operations.; A new section that defines address spaces is added (se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:16983,variab,variable,16983,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability,"----------------------------------------------------------------===//. We should materialize vector constants like ""all ones"" and ""signbit"" with ; code like:. cmpeqps xmm1, xmm1 ; xmm1 = all-ones. and:; cmpeqps xmm1, xmm1 ; xmm1 = all-ones; psrlq xmm1, 31 ; xmm1 = all 100000000000... instead of using a load from the constant pool. The later is important for; ABS/NEG/copysign etc. //===---------------------------------------------------------------------===//. These functions:. #include <xmmintrin.h>; __m128i a;; void x(unsigned short n) {; a = _mm_slli_epi32 (a, n);; }; void y(unsigned n) {; a = _mm_slli_epi32 (a, n);; }. compile to ( -O3 -static -fomit-frame-pointer):; _x:; movzwl 4(%esp), %eax; movd %eax, %xmm0; movaps _a, %xmm1; pslld %xmm0, %xmm1; movaps %xmm1, _a; ret; _y:; movd 4(%esp), %xmm0; movaps _a, %xmm1; pslld %xmm0, %xmm1; movaps %xmm1, _a; ret. ""y"" looks good, but ""x"" does silly movzwl stuff around into a GPR. It seems; like movd would be sufficient in both cases as the value is already zero ; extended in the 32-bit stack slot IIRC. For signed short, it should also be; save, as a really-signed value would be undefined for pslld. //===---------------------------------------------------------------------===//. #include <math.h>; int t1(double d) { return signbit(d); }. This currently compiles to:; 	subl	$12, %esp; 	movsd	16(%esp), %xmm0; 	movsd	%xmm0, (%esp); 	movl	4(%esp), %eax; 	shrl	$31, %eax; 	addl	$12, %esp; 	ret. We should use movmskp{s|d} instead. //===---------------------------------------------------------------------===//. CodeGen/X86/vec_align.ll tests whether we can turn 4 scalar loads into a single; (aligned) vector load. This functionality has a couple of problems. 1. The code to infer alignment from loads of globals is in the X86 backend,; not the dag combiner. This is because dagcombine2 needs to be able to see; through the X86ISD::Wrapper node, which DAGCombine can't really do.; 2. The code for turning 4 x load into a single vector load",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:10834,extend,extended,10834,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,1,['extend'],['extended']
Modifiability,"----------------------------------------------------------------===//. WebAssemblyRegStackify could use AliasAnalysis to reorder loads and stores more; aggressively. //===---------------------------------------------------------------------===//. WebAssemblyRegStackify is currently a greedy algorithm. This means that, for; example, a binary operator will stackify with its user before its operands.; However, if moving the binary operator to its user moves it to a place where; its operands can't be moved to, it would be better to leave it in place, or; perhaps move it up, so that it can stackify its operands. A binary operator; has two operands and one result, so in such cases there could be a net win by; preferring the operands. //===---------------------------------------------------------------------===//. Instruction ordering has a significant influence on register stackification and; coloring. Consider experimenting with the MachineScheduler (enable via; enableMachineScheduler) and determine if it can be configured to schedule; instructions advantageously for this purpose. //===---------------------------------------------------------------------===//. WebAssemblyRegStackify currently assumes that the stack must be empty after; an instruction with no return values, however wasm doesn't actually require; this. WebAssemblyRegStackify could be extended, or possibly rewritten, to take; full advantage of what WebAssembly permits. //===---------------------------------------------------------------------===//. Add support for mergeable sections in the Wasm writer, such as for strings and; floating-point constants. //===---------------------------------------------------------------------===//. The function @dynamic_alloca_redzone in test/CodeGen/WebAssembly/userstack.ll; ends up with a local.tee in its prolog which has an unused result, requiring; an extra drop:. global.get $push8=, 0; local.tee $push9=, 1, $pop8; drop $pop9; [...]. The prologue code initially thinks it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt:6078,config,configured,6078,interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,1,['config'],['configured']
Modifiability,"--------------------------------------------------------. if(builtin_unuran). set(UNR_SRCDIR ${CMAKE_CURRENT_SOURCE_DIR}/src); set(UNR_VERSION ""1.8.0-root""); set(UNR_TARNAME ""unuran-${UNR_VERSION}""); set(UNR_TARGZFILE ${UNR_SRCDIR}/${UNR_TARNAME}.tar.gz); set(UNR_TARFILE ${UNR_SRCDIR}/${UNR_TARNAME}.tar); set(UNR_UNTARDIR ${CMAKE_CURRENT_BINARY_DIR}/${UNR_TARNAME}). #---Untar sources at configuration/generation time (needed for listing sources); if(NOT EXISTS ${UNR_UNTARDIR}); execute_process( COMMAND ${CMAKE_COMMAND} -E tar xzf ${UNR_TARGZFILE}; WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR} ); # This is necessary to replace the config.guess of unuran 1.8.0 as it does not allow to compile the ; # package on arm64.; execute_process( COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/config.guess_patch1 ${UNR_UNTARDIR}/autoconf/config.guess; WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR} ); endif(). if(WIN32); configure_file(${CMAKE_CURRENT_SOURCE_DIR}/config.h.win.in ${UNR_UNTARDIR}/config.h); else(); #---Define special compiler settings for unurun-----------------------------------------------------; set(UNR_CC ${CMAKE_C_COMPILER}); if(ROOT_ARCHITECTURE MATCHES hpuxia64acc); set(UNR_CC ""${UNR_CC} +DD64 -Ae""); elseif(ROOT_ARCHITECTURE MATCHES linuxppc64gcc); set(UNR_CC ""${UNR_CC} -m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664gcc); set(UNR_CFLAGS ""-m64 -fPIC""); elseif(ROOT_ARCHITECTURE MATCHES linuxicc); set(UNR_CFLAGS ""-m32""); elseif(ROOT_ARCHITECTURE MATCHES linuxx8664icc); set(UNR_CFLAGS ""-m64""); elseif(ROOT_ARCHITECTURE MATCHES win32 OR ROOT_ARCHITECTURE MATCHES win64); set(UNR_CFLAGS ""-MD -G5 -GX""); endif(); if(CMAKE_OSX_SYSROOT); set(UNR_CFLAGS ""${UNR_CFLAGS} -isysroot ${CMAKE_OSX_SYSROOT}""); endif(). #---configure unuran (required for creating the config.h used by unuran source files)----------------; add_custom_command(OUTPUT ${UNR_UNTARDIR}/config.h; COMMAND GNUMAKE=make ./configure CC=${UNR_CC} CFLAGS=${UNR_CFLAGS} > /dev/null 2>& 1; WORK",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt:1463,config,config,1463,math/unuran/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/CMakeLists.txt,1,['config'],['config']
Modifiability,"----------------------------------------------------===//; // Random ideas for the ARM backend.; //===---------------------------------------------------------------------===//. Reimplement 'select' in terms of 'SEL'. * We would really like to support UXTAB16, but we need to prove that the; add doesn't need to overflow between the two 16-bit chunks. * Implement pre/post increment support. (e.g. PR935); * Implement smarter constant generation for binops with large immediates. A few ARMv6T2 ops should be pattern matched: BFI, SBFX, and UBFX. Interesting optimization for PIC codegen on arm-linux:; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43129. //===---------------------------------------------------------------------===//. Crazy idea: Consider code that uses lots of 8-bit or 16-bit values. By the; time regalloc happens, these values are now in a 32-bit register, usually with; the top-bits known to be sign or zero extended. If spilled, we should be able; to spill these to a 8-bit or 16-bit stack slot, zero or sign extending as part; of the reload. Doing this reduces the size of the stack frame (important for thumb etc), and; also increases the likelihood that we will be able to reload multiple values; from the stack with a single load. //===---------------------------------------------------------------------===//. The constant island pass is in good shape. Some cleanups might be desirable,; but there is unlikely to be much improvement in the generated code. 1. There may be some advantage to trying to be smarter about the initial; placement, rather than putting everything at the end. 2. There might be some compile-time efficiency to be had by representing; consecutive islands as a single block rather than multiple blocks. 3. Use a priority queue to sort constant pool users in inverse order of; position so we always process the one closed to the end of functions; first. This may simply CreateNewWater. //===-------------------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:1052,extend,extending,1052,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['extend'],['extending']
Modifiability,"--------------------------------------------------===//. Currently, these sorts of things are modelled by compiling a function to return; the small type and a signext/zeroext marker is used. For example, we compile; Z into:. define i32 @z() nounwind {; entry:; 	%0 = tail call signext i16 (...)* @y() nounwind; 	%1 = sext i16 %0 to i32; 	ret i32 %1; }. and b into:. define signext i16 @b() nounwind {; entry:; 	%0 = tail call i32 (...)* @a() nounwind		; <i32> [#uses=1]; 	%retval12 = trunc i32 %0 to i16		; <i16> [#uses=1]; 	ret i16 %retval12; }. This has some problems: 1) the actual precise semantics are really poorly; defined (see PR3779). 2) some targets might want the caller to extend, some; might want the callee to extend 3) the mid-level optimizer doesn't know the; size of the GPR, so it doesn't know that %0 is sign extended up to 32-bits ; here, and even if it did, it could not eliminate the sext. 4) the code; generator has historically assumed that the result is extended to i32, which is; a problem on PIC16 (and is also probably wrong on alpha and other 64-bit; targets). //===----------------------------------------------------------------------===//; // The proposal; //===----------------------------------------------------------------------===//. I suggest that we have the front-end fully lower out the ABI issues here to; LLVM IR. This makes it 100% explicit what is going on and means that there is; no cause for confusion. For example, the cases above should compile into:. define i32 @z() nounwind {; entry:; %0 = tail call i32 (...)* @y() nounwind; 	%1 = trunc i32 %0 to i16; %2 = sext i16 %1 to i32; ret i32 %2; }; define i32 @b() nounwind {; entry:; 	%0 = tail call i32 (...)* @a() nounwind; 	%retval12 = trunc i32 %0 to i16; 	%tmp = sext i16 %retval12 to i32; 	ret i32 %tmp; }. In this model, no functions will return an i1/i8/i16 (and on a x86-64 target; that extends results to i64, no i32). This solves the ambiguity issue, allows us ; to fully describe all possib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt:2826,extend,extended,2826,interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,1,['extend'],['extended']
Modifiability,"-------------------------------------------------. This pass, only available in ``opt``, prints the post dominator tree into a; ``.dot`` graph, omitting the function bodies. This graph can then be processed; with the :program:`dot` tool to convert it to postscript or some other suitable; format. ``globals-aa``: Simple mod/ref analysis for globals; ---------------------------------------------------. This simple pass provides alias and mod/ref information for global values that; do not have their address taken, and keeps track of whether functions read or; write memory (are ""pure""). For this simple (but very common) case, we can; provide pretty accurate and useful information. ``instcount``: Counts the various types of ``Instruction``\ s; -------------------------------------------------------------. This pass collects the count of all instructions and reports them. ``iv-users``: Induction Variable Users; --------------------------------------. Bookkeeping for ""interesting"" users of expressions computed from induction; variables. ``lazy-value-info``: Lazy Value Information Analysis; ----------------------------------------------------. Interface for lazy computation of value constraint information. ``lint``: Statically lint-checks LLVM IR; ----------------------------------------. This pass statically checks for common and easily-identified constructs which; produce undefined or likely unintended behavior in LLVM IR. It is not a guarantee of correctness, in two ways. First, it isn't; comprehensive. There are checks which could be done statically which are not; yet implemented. Some of these are indicated by TODO comments, but those; aren't comprehensive either. Second, many conditions cannot be checked; statically. This pass does no dynamic instrumentation, so it can't check for; all possible problems. Another limitation is that it assumes all code will be executed. A store; through a null pointer in a basic block which is never reached is harmless, but; this pass wil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:6151,variab,variables,6151,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variables']
Modifiability,"----------------------------------------------. You disable UBSan checks for particular functions with; ``__attribute__((no_sanitize(""undefined"")))``. You can use all values of; ``-fsanitize=`` flag in this attribute, e.g. if your function deliberately; contains possible signed integer overflow, you can use; ``__attribute__((no_sanitize(""signed-integer-overflow"")))``. This attribute may not be; supported by other compilers, so consider using it together with; ``#if defined(__clang__)``. Suppressing Errors in Recompiled Code (Ignorelist); --------------------------------------------------. UndefinedBehaviorSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is su",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:14543,variab,variable,14543,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['variab'],['variable']
Modifiability,"---------------------------------------------===//; The save/restore sequence for CR in prolog/epilog is terrible:; - Each CR subreg is saved individually, rather than doing one save as a unit.; - On Darwin, the save is done after the decrement of SP, which means the offset; from SP of the save slot can be too big for a store instruction, which means we; need an additional register (currently hacked in 96015+96020; the solution there; is correct, but poor).; - On SVR4 the same thing can happen, and I don't think saving before the SP; decrement is safe on that target, as there is no red zone. This is currently; broken AFAIK, although it's not a target I can exercise.; The following demonstrates the problem:; extern void bar(char *p);; void foo() {; char x[100000];; bar(x);; __asm__("""" ::: ""cr2"");; }. //===-------------------------------------------------------------------------===; Naming convention for instruction formats is very haphazard.; We have agreed on a naming scheme as follows:. <INST_form>{_<OP_type><OP_len>}+. Where:; INST_form is the instruction format (X-form, etc.); OP_type is the operand type - one of OPC (opcode), RD (register destination),; RS (register source),; RDp (destination register pair),; RSp (source register pair), IM (immediate),; XO (extended opcode); OP_len is the length of the operand in bits. VSX register operands would be of length 6 (split across two fields),; condition register fields of length 3.; We would not need denote reserved fields in names of instruction formats. //===----------------------------------------------------------------------===//. Instruction fusion was introduced in ISA 2.06 and more opportunities added in; ISA 2.07. LLVM needs to add infrastructure to recognize fusion opportunities; and force instruction pairs to be scheduled together. -----------------------------------------------------------------------------. More general handling of any_extend and zero_extend:. See https://reviews.llvm.org/D24924#555306; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:14335,extend,extended,14335,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,1,['extend'],['extended']
Modifiability,"----------------------------------------. This pass transforms simple global variables that never have their address; taken. If obviously true, it marks read/write globals as constant, deletes; variables only stored to, etc. ``gvn``: Global Value Numbering; -------------------------------. This pass performs global value numbering to eliminate fully and partially; redundant instructions. It also performs redundant load elimination. .. _passes-indvars:. ``indvars``: Canonicalize Induction Variables; ---------------------------------------------. This transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this pass also makes the following; changes:. * The exit condition for the loop is canonicalized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transformations have been performed. Additionally, on targets; where it is profitable, the loop could be transforme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:18057,variab,variable,18057,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variable']
Modifiability,"--------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``clang++`` when linking C++ programs in order; to ensure the C++ runtimes are provided. .. note::. There may exist other implementations for these components not described; below. Please let us know how well those other implementations work with; Clang so they can be added to this list!. .. FIXME: Describe Objective-C runtime libraries; .. FIXME: Des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:4513,plugin,plugin,4513,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['plugin'],['plugin']
Modifiability,"--------------------------------------===//. Optimize copysign(x, *y) to use an integer load from y. //===---------------------------------------------------------------------===//. The following tests perform worse with LSR:. lambda, siod, optimizer-eval, ackermann, hash2, nestedloop, strcat, and Treesor. //===---------------------------------------------------------------------===//. Adding to the list of cmp / test poor codegen issues:. int test(__m128 *A, __m128 *B) {; if (_mm_comige_ss(*A, *B)); return 3;; else; return 4;; }. _test:; 	movl 8(%esp), %eax; 	movaps (%eax), %xmm0; 	movl 4(%esp), %eax; 	movaps (%eax), %xmm1; 	comiss %xmm0, %xmm1; 	setae %al; 	movzbl %al, %ecx; 	movl $3, %eax; 	movl $4, %edx; 	cmpl $0, %ecx; 	cmove %edx, %eax; 	ret. Note the setae, movzbl, cmpl, cmove can be replaced with a single cmovae. There; are a number of issues. 1) We are introducing a setcc between the result of the; intrisic call and select. 2) The intrinsic is expected to produce a i32 value; so a any extend (which becomes a zero extend) is added. We probably need some kind of target DAG combine hook to fix this. //===---------------------------------------------------------------------===//. We generate significantly worse code for this than GCC:; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=21150; http://gcc.gnu.org/bugzilla/attachment.cgi?id=8701. There is also one case we do worse on PPC. //===---------------------------------------------------------------------===//. For this:. int test(int a); {; return a * 3;; }. We currently emits; 	imull $3, 4(%esp), %eax. Perhaps this is what we really should generate is? Is imull three or four; cycles? Note: ICC generates this:; 	movl	4(%esp), %eax; 	leal	(%eax,%eax,2), %eax. The current instruction priority is based on pattern complexity. The former is; more ""complex"" because it folds a load so the latter will not be emitted. Perhaps we should use AddedComplexity to give LEA32r a higher priority? We; should always try to match LEA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:6267,extend,extend,6267,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,2,['extend'],['extend']
Modifiability,"--------------------------------. LLVM currently supports two different mechanisms for describing references in; compiled code at safepoints. ``llvm.gcroot`` is the older mechanism;; ``gc.statepoint`` has been added more recently. At the moment, you can choose; either implementation (on a per :ref:`GC strategy <plugin>` basis). Longer; term, we will probably either migrate away from ``llvm.gcroot`` entirely, or; substantially merge their implementations. Note that most new development; work is focused on ``gc.statepoint``. Using ``gc.statepoint``; ^^^^^^^^^^^^^^^^^^^^^^^^; :doc:`This page <Statepoints>` contains detailed documentation for; ``gc.statepoint``. Using ``llvm.gcwrite``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.gcroot(i8** %ptrloc, i8* %metadata). The ``llvm.gcroot`` intrinsic is used to inform LLVM that a stack variable; references an object on the heap and is to be tracked for garbage collection.; The exact impact on generated code is specified by the Function's selected; :ref:`GC strategy <plugin>`. All calls to ``llvm.gcroot`` **must** reside; inside the first basic block. The first argument **must** be a value referring to an alloca instruction or a; bitcast of an alloca. The second contains a pointer to metadata that should be; associated with the pointer, and **must** be a constant or global value; address. If your target collector uses tags, use a null pointer for metadata. A compiler which performs manual SSA construction **must** ensure that SSA; values representing GC references are stored in to the alloca passed to the; respective ``gcroot`` before every call site and reloaded after every call.; A compiler which uses mem2reg to raise imperative code using ``alloca`` into; SSA form need only add a call to ``@llvm.gcroot`` for those variables which; are pointers into the GC heap. It is also important to mark intermediate values with ``llvm.gcroot``. For; example, consider ``h(f(), g())``. Beware leaking the result of ``f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:10404,plugin,plugin,10404,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"-------------------------------===//. Eliminate one instruction from:. define i32 @_Z6slow4bii(i32 %x, i32 %y) {; %tmp = icmp sgt i32 %x, %y; %retval = select i1 %tmp, i32 %x, i32 %y; ret i32 %retval; }. __Z6slow4bii:; cmp r0, r1; movgt r1, r0; mov r0, r1; bx lr; =>. __Z6slow4bii:; cmp r0, r1; movle r0, r1; bx lr. //===---------------------------------------------------------------------===//. Implement long long ""X-3"" with instructions that fold the immediate in. These; were disabled due to badness with the ARM carry flag on subtracts. //===---------------------------------------------------------------------===//. More load / store optimizations:; 1) Better representation for block transfer? This is from Olden/power:. 	fldd d0, [r4]; 	fstd d0, [r4, #+32]; 	fldd d0, [r4, #+8]; 	fstd d0, [r4, #+40]; 	fldd d0, [r4, #+16]; 	fstd d0, [r4, #+48]; 	fldd d0, [r4, #+24]; 	fstd d0, [r4, #+56]. If we can spare the registers, it would be better to use fldm and fstm here.; Need major register allocator enhancement though. 2) Can we recognize the relative position of constantpool entries? i.e. Treat. 	ldr r0, LCPI17_3; 	ldr r1, LCPI17_4; 	ldr r2, LCPI17_5. as; 	ldr r0, LCPI17; 	ldr r1, LCPI17+4; 	ldr r2, LCPI17+8. Then the ldr's can be combined into a single ldm. See Olden/power. Note for ARM v4 gcc uses ldmia to load a pair of 32-bit values to represent a; double 64-bit FP constant:. 	adr	r0, L6; 	ldmia	r0, {r0-r1}. 	.align 2; L6:; 	.long	-858993459; 	.long	1074318540. 3) struct copies appear to be done field by field; instead of by words, at least sometimes:. struct foo { int x; short s; char c1; char c2; };; void cpy(struct foo*a, struct foo*b) { *a = *b; }. llvm code (-O2); ldrb r3, [r1, #+6]; ldr r2, [r1]; ldrb r12, [r1, #+7]; ldrh r1, [r1, #+4]; str r2, [r0]; strh r1, [r0, #+4]; strb r3, [r0, #+6]; strb r12, [r0, #+7]; gcc code (-O2); ldmia r1, {r1-r2}; stmia r0, {r1-r2}. In this benchmark poor handling of aggregate copies has shown up as; having a large effect on size, an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:3201,enhance,enhancement,3201,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['enhance'],['enhancement']
Modifiability,"----------------------------===//. Mar 25, 2009 - Initial Revision. Most ABIs specify that functions which return small integers do so in a; specific integer GPR. This is an efficient way to go, but raises the question:; if the returned value is smaller than the register, what do the high bits hold?. There are three (interesting) possible answers: undefined, zero extended, or; sign extended. The number of bits in question depends on the data-type that; the front-end is referencing (typically i1/i8/i16/i32). Knowing the answer to this is important for two reasons: 1) we want to be able; to implement the ABI correctly. If we need to sign extend the result according; to the ABI, we really really do need to do this to preserve correctness. 2); this information is often useful for optimization purposes, and we want the; mid-level optimizers to be able to process this (e.g. eliminate redundant; extensions). For example, lets pretend that X86 requires the caller to properly extend the; result of a return (I'm not sure this is the case, but the argument doesn't; depend on this). Given this, we should compile this:. int a();; short b() { return a(); }. into:. _b:; 	subl	$12, %esp; 	call	L_a$stub; 	addl	$12, %esp; 	cwtl; 	ret. An optimization example is that we should be able to eliminate the explicit; sign extension in this example:. short y();; int z() {; return ((int)y() << 16) >> 16;; }. _z:; 	subl	$12, %esp; 	call	_y; 	;; movswl %ax, %eax -> not needed because eax is already sext'd; 	addl	$12, %esp; 	ret. //===----------------------------------------------------------------------===//; // What we have right now.; //===----------------------------------------------------------------------===//. Currently, these sorts of things are modelled by compiling a function to return; the small type and a signext/zeroext marker is used. For example, we compile; Z into:. define i32 @z() nounwind {; entry:; 	%0 = tail call signext i16 (...)* @y() nounwind; 	%1 = sext i16 %0 to i32; 	re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt:1168,extend,extend,1168,interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,1,['extend'],['extend']
Modifiability,"--------------------------. The Virtual Analysis Facility client is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; configuration. How to do so depends on your experiment, but usually you; should essentially specify the version of the experiment's software you; need. For instance, in the CMS use case, only one file is needed:; `~/.vaf/common.before`, which contains something like:. ``` {.bash}; # Version of CMSSW (as reported by ""scram list""); export VafCmsswVersion='CMSSW_5_3_9_sherpa2beta2'; ```. ### Entering the VAF environment. Open a terminal on your client machine (can be either your local; computer or a remote user interface) and type:. vaf-enter <username>@cloud-gw-213.to.infn.it. You'll substitute `<username>` with the username that either your system; administrator or the web authentication (if you used it) provided you. You'll be presented with a neat shell which looks like the following:. Entering VAF environment: dberzano@cloud-gw-213.to.infn.it; Remember: you are still in a shell on your local com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:9185,config,configuration,9185,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['config'],['configuration']
Modifiability,"--------------------------===//. These instructions describe how to build and install Clang. //===----------------------------------------------------------------------===//; // Step 1: Organization; //===----------------------------------------------------------------------===//. Clang is designed to be built as part of an LLVM build. Assuming that the LLVM; source code is located at $LLVM_SRC_ROOT, then the clang source code should be; installed as:. $LLVM_SRC_ROOT/tools/clang. The directory is not required to be called clang, but doing so will allow the; LLVM build system to automatically recognize it and build it along with LLVM. //===----------------------------------------------------------------------===//; // Step 2: Configure and Build LLVM; //===----------------------------------------------------------------------===//. Configure and build your copy of LLVM (see $LLVM_SRC_ROOT/GettingStarted.html; for more information). Assuming you installed clang at $LLVM_SRC_ROOT/tools/clang then Clang will; automatically be built with LLVM. Otherwise, run 'make' in the Clang source; directory to build Clang. //===----------------------------------------------------------------------===//; // Step 3: (Optional) Verify Your Build; //===----------------------------------------------------------------------===//. It is a good idea to run the Clang tests to make sure your build works; correctly. From inside the Clang build directory, run 'make test' to run the; tests. //===----------------------------------------------------------------------===//; // Step 4: Install Clang; //===----------------------------------------------------------------------===//. From inside the Clang build directory, run 'make install' to install the Clang; compiler and header files into the prefix directory selected when LLVM was; configured. The Clang compiler is available as 'clang' and 'clang++'. It supports a gcc like; command line interface. See the man page for clang for more information.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/INSTALL.txt:1999,config,configured,1999,interpreter/llvm-project/clang/INSTALL.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/INSTALL.txt,1,['config'],['configured']
Modifiability,"----------------------. The ``defset`` statement is used to collect a set of records into a global; list of records. .. productionlist::; Defset: ""defset"" `Type` `TokIdentifier` ""="" ""{"" `Statement`* ""}"". All records defined inside the braces via ``def`` and ``defm`` are defined; as usual, and they are also collected in a global list of the given name; (:token:`TokIdentifier`). The specified type must be ``list<``\ *class*\ ``>``, where *class* is some; record class. The ``defset`` statement establishes a scope for its; statements. It is an error to define a record in the scope of the; ``defset`` that is not of type *class*. The ``defset`` statement can be nested. The inner ``defset`` adds the; records to its own set, and all those records are also added to the outer; set. Anonymous records created inside initialization expressions using the; ``ClassID<...>`` syntax are not collected in the set. ``defvar`` --- define a variable; --------------------------------. A ``defvar`` statement defines a global variable. Its value can be used; throughout the statements that follow the definition. .. productionlist::; Defvar: ""defvar"" `TokIdentifier` ""="" `Value` "";"". The identifier on the left of the ``=`` is defined to be a global variable; whose value is given by the value expression on the right of the ``=``. The; type of the variable is automatically inferred. Once a variable has been defined, it cannot be set to another value. Variables defined in a top-level ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1);. Variables can also be defined with ``defvar`` in a record body. See; `Defvar in a Record Body`_ for more details. ``foreach`` --- iterate over a sequence of statements; -----------------------------------------------------. The ``foreach`` statement iterates over a series of statements, varying a; variable over a seque",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:44808,variab,variable,44808,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability,"---------------------. Instruction selection creates a MIR function from an IR function, and just as; it transforms ``intermediate`` instructions into machine instructions, so must; ``intermediate`` variable locations become machine variable locations.; Within IR, variable locations are always identified by a Value, but in MIR; there can be different types of variable locations. In addition, some IR; locations become unavailable, for example if the operation of multiple IR; instructions are combined into one machine instruction (such as; multiply-and-accumulate) then intermediate Values are lost. To track variable; locations through instruction selection, they are first separated into; locations that do not depend on code generation (constants, stack locations,; allocated virtual registers) and those that do. For those that do, debug; metadata is attached to SDNodes in SelectionDAGs. After instruction selection; has occurred and a MIR function is created, if the SDNode associated with debug; metadata is allocated a virtual register, that virtual register is used as the; variable location. If the SDNode is folded into a machine instruction or; otherwise transformed into a non-register, the variable location becomes; unavailable. Locations that are unavailable are treated as if they have been optimized out:; in IR the location would be assigned ``undef`` by a debug intrinsic, and in MIR; the equivalent location is used. After MIR locations are assigned to each variable, machine pseudo-instructions; corresponding to each ``llvm.dbg.value`` intrinsic are inserted. There are two; forms of this type of instruction. The first form, ``DBG_VALUE``, appears thus:. .. code-block:: text. DBG_VALUE %1, $noreg, !123, !DIExpression(). And has the following operands:; * The first operand can record the variable location as a register,; a frame index, an immediate, or the base address register if the original; debug intrinsic referred to memory. ``$noreg`` indicates the variable; loc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:26656,variab,variable,26656,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"-------------------. In some cases one may need to execute different code depending on whether; AddressSanitizer is enabled.; :ref:`\_\_has\_feature <langext-__has_feature-__has_extension>` can be used for; this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(address_sanitizer); // code that builds only under AddressSanitizer; # endif; #endif. Disabling Instrumentation with ``__attribute__((no_sanitize(""address"")))``; --------------------------------------------------------------------------. Some code should not be instrumented by AddressSanitizer. One may use; the attribute ``__attribute__((no_sanitize(""address"")))`` (which has; deprecated synonyms `no_sanitize_address` and; `no_address_safety_analysis`) to disable instrumentation of a; particular function. This attribute may not be supported by other; compilers, so we suggest to use it together with; ``__has_feature(address_sanitizer)``. The same attribute used on a global variable prevents AddressSanitizer; from adding redzones around it and detecting out of bounds accesses. AddressSanitizer also supports; ``__attribute__((disable_sanitizer_instrumentation))``. This attribute; works similar to ``__attribute__((no_sanitize(""address"")))``, but it also; prevents instrumentation performed by other sanitizers. Suppressing Errors in Recompiled Code (Ignorelist); --------------------------------------------------. AddressSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress error reports; in the specified source files or functions. Additionally, AddressSanitizer; introduces ``global`` and ``type`` entity types that can be used to; suppress error reports for out-of-bound access to globals with certain; names and types (you may only specify class or struct types). You may use an ``init`` category to suppress reports about initialization-order; problems happening in certain source files or with certain global variables. .. code-block",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:9506,variab,variable,9506,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['variab'],['variable']
Modifiability,"------------------. Quick answer: there are no superfluous indices. This question arises most often when the GEP instruction is applied to a global; variable which is always a pointer type. For example, consider this:. .. code-block:: text. %MyStruct = external global { ptr, i32 }; ...; %idx = getelementptr { ptr, i32 }, ptr %MyStruct, i64 0, i32 1. The GEP above yields a ``ptr`` by indexing the ``i32`` typed field of the; structure ``%MyStruct``. When people first look at it, they wonder why the ``i64; 0`` index is needed. However, a closer inspection of how globals and GEPs work; reveals the need. Becoming aware of the following facts will dispel the; confusion:. #. The type of ``%MyStruct`` is *not* ``{ ptr, i32 }`` but rather ``ptr``.; That is, ``%MyStruct`` is a pointer (to a structure), not a structure itself. #. Point #1 is evidenced by noticing the type of the second operand of the GEP; instruction (``%MyStruct``) which is ``ptr``. #. The first index, ``i64 0`` is required to step over the global variable; ``%MyStruct``. Since the second argument to the GEP instruction must always; be a value of pointer type, the first index steps through that pointer. A; value of 0 means 0 elements offset from that pointer. #. The second index, ``i32 1`` selects the second field of the structure (the; ``i32``). What is dereferenced by GEP?; ----------------------------. Quick answer: nothing. The GetElementPtr instruction dereferences nothing. That is, it doesn't access; memory in any way. That's what the Load and Store instructions are for. GEP is; only involved in the computation of addresses. For example, consider this:. .. code-block:: text. @MyVar = external global { i32, ptr }; ...; %idx = getelementptr { i32, ptr }, ptr @MyVar, i64 0, i32 1; %arr = load ptr, ptr %idx; %idx = getelementptr [40 x i32], ptr %arr, i64 0, i64 17. In this example, we have a global variable, ``@MyVar``, which is a pointer to; a structure containing a pointer. Let's assume that this inner po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:5945,variab,variable,5945,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['variab'],['variable']
Modifiability,"------------------===//. The clang supports ""-triple"" and ""-arch"" options. At most one -triple and one; -arch option may be specified. Both are optional. The ""selection of target"" behavior is defined as follows:. (1) If the user does not specify -triple, we default to the host triple.; (2) If the user specifies a -arch, that overrides the arch in the host or; specified triple. //===---------------------------------------------------------------------===//. verifyInputConstraint and verifyOutputConstraint should not return bool. Instead we should return something like:. enum VerifyConstraintResult {; Valid,. // Output only; OutputOperandConstraintLacksEqualsCharacter,; MatchingConstraintNotValidInOutputOperand,. // Input only; InputOperandConstraintContainsEqualsCharacter,; MatchingConstraintReferencesInvalidOperandNumber,. // Both; PercentConstraintUsedWithLastOperand; };. //===---------------------------------------------------------------------===//. Blocks should not capture variables that are only used in dead code. The rule that we came up with is that blocks are required to capture; variables if they're referenced in evaluated code, even if that code; doesn't actually rely on the value of the captured variable. For example, this requires a capture:; (void) var;; But this does not:; if (false) puts(var);. Summary of <rdar://problem/9851835>: if we implement this, we should; warn about non-POD variables that are referenced but not captured, but; only if the non-reachability is not due to macro or template; metaprogramming. //===---------------------------------------------------------------------===//. We can still apply a modified version of the constructor/destructor; delegation optimization in cases of virtual inheritance where:; - there is no function-try-block,; - the constructor signature is not variadic, and; - the parameter variables can safely be copied and repassed; to the base constructor because either; - they have not had their addresses taken by the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/NOTES.txt:2855,variab,variables,2855,interpreter/llvm-project/clang/NOTES.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/NOTES.txt,1,['variab'],['variables']
Modifiability,"----------------. A ``defvar`` statement defines a global variable. Its value can be used; throughout the statements that follow the definition. .. productionlist::; Defvar: ""defvar"" `TokIdentifier` ""="" `Value` "";"". The identifier on the left of the ``=`` is defined to be a global variable; whose value is given by the value expression on the right of the ``=``. The; type of the variable is automatically inferred. Once a variable has been defined, it cannot be set to another value. Variables defined in a top-level ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1);. Variables can also be defined with ``defvar`` in a record body. See; `Defvar in a Record Body`_ for more details. ``foreach`` --- iterate over a sequence of statements; -----------------------------------------------------. The ``foreach`` statement iterates over a series of statements, varying a; variable over a sequence of values. .. productionlist::; Foreach: ""foreach"" `ForeachIterator` ""in"" ""{"" `Statement`* ""}""; :| ""foreach"" `ForeachIterator` ""in"" `Statement`; ForeachIterator: `TokIdentifier` ""="" (""{"" `RangeList` ""}"" | `RangePiece` | `Value`). The body of the ``foreach`` is a series of statements in braces or a; single statement with no braces. The statements are re-evaluated once for; each value in the range list, range piece, or single value. On each; iteration, the :token:`TokIdentifier` variable is set to the value and can; be used in the statements. The statement list establishes an inner scope. Variables local to a; ``foreach`` go out of scope at the end of each loop iteration, so their; values do not carry over from one iteration to the next. Foreach loops may; be nested. .. Note that the productions involving RangeList and RangePiece have precedence; over the more generic value parsing based on the first token. .. code-block:: text. foreach i = [0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:45771,variab,variable,45771,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability,"------------. ``llvm::Instruction`` provides easy access to metadata attached with an; instruction. One can extract line number information encoded in LLVM IR using; ``Instruction::getDebugLoc()`` and ``DILocation::getLine()``. .. code-block:: c++. if (DILocation *Loc = I->getDebugLoc()) { // Here I is an LLVM instruction; unsigned Line = Loc->getLine();; StringRef File = Loc->getFilename();; StringRef Dir = Loc->getDirectory();; bool ImplicitCode = Loc->isImplicitCode();; }. When the flag ImplicitCode is true then it means that the Instruction has been; added by the front-end but doesn't correspond to source code written by the user. For example. .. code-block:: c++. if (MyBoolean) {; MyObject MO;; ...; }. At the end of the scope the MyObject's destructor is called but it isn't written; explicitly. This information is useful to avoid to have counters on brackets when; making code coverage. C/C++ global variable information; ---------------------------------. Given an integer global variable declared as follows:. .. code-block:: c. _Alignas(8) int MyGlobal = 100;. a C/C++ front-end would generate the following descriptors:. .. code-block:: text. ;;; ;; Define the global itself.; ;;; @MyGlobal = global i32 100, align 8, !dbg !0. ;;; ;; List of debug info of globals; ;;; !llvm.dbg.cu = !{!1}. ;; Some unrelated metadata.; !llvm.module.flags = !{!6, !7}; !llvm.ident = !{!8}. ;; Define the global variable itself; !0 = distinct !DIGlobalVariable(name: ""MyGlobal"", scope: !1, file: !2, line: 1, type: !5, isLocal: false, isDefinition: true, align: 64). ;; Define the compile unit.; !1 = distinct !DICompileUnit(language: DW_LANG_C99, file: !2,; producer: ""clang version 4.0.0"",; isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug,; enums: !3, globals: !4). ;;; ;; Define the file; ;;; !2 = !DIFile(filename: ""/dev/stdin"",; directory: ""/Users/dexonsmith/data/llvm/debug-info""). ;; An empty array.; !3 = !{}. ;; The Array of Global Variables; !4 = !{!0}. ;;; ;; Define the t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:42610,variab,variable,42610,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"---------. Functions and Macros look very similar in how they are used, but there is one; fundamental difference between the two. Functions have their own scope, and; macros don't. This means variables set in macros will bleed out into the calling; scope. That makes macros suitable for defining very small bits of functionality; only. The other difference between CMake functions and macros is how arguments are; passed. Arguments to macros are not set as variables, instead dereferences to; the parameters are resolved across the macro before executing it. This can; result in some unexpected behavior if using unreferenced variables. For example:. .. code-block:: cmake. macro(print_list my_list); foreach(var IN LISTS my_list); message(""${var}""); endforeach(); endmacro(). set(my_list a b c d); set(my_list_of_numbers 1 2 3 4); print_list(my_list_of_numbers); # prints:; # a; # b; # c; # d. Generally speaking this issue is uncommon because it requires using; non-dereferenced variables with names that overlap in the parent scope, but it; is important to be aware of because it can lead to subtle bugs. LLVM Project Wrappers; =====================. LLVM projects provide lots of wrappers around critical CMake built-in commands.; We use these wrappers to provide consistent behaviors across LLVM components; and to reduce code duplication. We generally (but not always) follow the convention that commands prefaced with; ``llvm_`` are intended to be used only as building blocks for other commands.; Wrapper commands that are intended for direct use are generally named following; with the project in the middle of the command name (i.e. ``add_llvm_executable``; is the wrapper for ``add_executable``). The LLVM ``add_*`` wrapper functions are; all defined in ``AddLLVM.cmake`` which is installed as part of the LLVM; distribution. It can be included and used by any LLVM sub-project that requires; LLVM. .. note::. Not all LLVM projects require LLVM for all use cases. For example compiler-rt; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:12958,variab,variables,12958,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variables']
Modifiability,"---------. Sometimes, when writing new passes, or trying to track down bugs, it; is useful to be able to control whether certain things in your pass; happen or not. For example, there are times the minimization tooling; can only easily give you large testcases. You would like to narrow; your bug down to a specific transformation happening or not happening,; automatically, using bisection. This is where debug counters help.; They provide a framework for making parts of your code only execute a; certain number of times. The ``llvm/Support/DebugCounter.h`` (`doxygen; <https://llvm.org/doxygen/DebugCounter_8h_source.html>`__) file; provides a class named ``DebugCounter`` that can be used to create; command line counter options that control execution of parts of your code. Define your DebugCounter like this:. .. code-block:: c++. DEBUG_COUNTER(DeleteAnInstruction, ""passname-delete-instruction"",; 		""Controls which instructions get delete"");. The ``DEBUG_COUNTER`` macro defines a static variable, whose name; is specified by the first argument. The name of the counter; (which is used on the command line) is specified by the second; argument, and the description used in the help is specified by the; third argument. Whatever code you want that control, use ``DebugCounter::shouldExecute`` to control it. .. code-block:: c++. if (DebugCounter::shouldExecute(DeleteAnInstruction)); I->eraseFromParent();. That's all you have to do. Now, using opt, you can control when this code triggers using; the '``--debug-counter``' option. There are two counters provided, ``skip`` and ``count``.; ``skip`` is the number of times to skip execution of the codepath. ``count`` is the number; of times, once we are done skipping, to execute the codepath. .. code-block:: none. $ opt --debug-counter=passname-delete-instruction-skip=1,passname-delete-instruction-count=2 -passname. This will skip the above code the first time we hit it, then execute it twice, then skip the rest of the executions. So if exe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:50768,variab,variable,50768,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"---------===//. AArch64 runs SeparateConstOffsetFromGEPPass, followed by EarlyCSE and LICM.; Would these be useful to run for WebAssembly too? Also, it has an option to; run SimplifyCFG after running the AtomicExpand pass. Would this be useful for; us too?. //===---------------------------------------------------------------------===//. Register stackification uses the VALUE_STACK physical register to impose; ordering dependencies on instructions with stack operands. This is pessimistic;; we should consider alternate ways to model stack dependencies. //===---------------------------------------------------------------------===//. Lots of things could be done in WebAssemblyTargetTransformInfo.cpp. Similarly,; there are numerous optimization-related hooks that can be overridden in; WebAssemblyTargetLowering. //===---------------------------------------------------------------------===//. Instead of the OptimizeReturned pass, which should consider preserving the; ""returned"" attribute through to MachineInstrs and extending the; MemIntrinsicResults pass to do this optimization on calls too. That would also; let the WebAssemblyPeephole pass clean up dead defs for such calls, as it does; for stores. //===---------------------------------------------------------------------===//. Consider implementing optimizeSelect, optimizeCompareInstr, optimizeCondBranch,; optimizeLoadInstr, and/or getMachineCombinerPatterns. //===---------------------------------------------------------------------===//. Find a clean way to fix the problem which leads to the Shrink Wrapping pass; being run after the WebAssembly PEI pass. //===---------------------------------------------------------------------===//. When setting multiple local variables to the same constant, we currently get; code like this:. i32.const $4=, 0; i32.const $3=, 0. It could be done with a smaller encoding like this:. i32.const $push5=, 0; local.tee $push6=, $4=, $pop5; local.copy $3=, $pop6. //===--------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt:3195,extend,extending,3195,interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,1,['extend'],['extending']
Modifiability,"--------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:72521,variab,variable,72521,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variable']
Modifiability,"--------. The Apple stage1 cache configures a two stage build similar to how Apple builds; the clang shipped with Xcode. The build files generated from this invocation has; a target named ""stage2"" which performs an LTO build of clang. The Apple-stage2 cache can be used directly to match the build settings Apple; uses in shipping builds without doing a full bootstrap build. PGO; ---. The PGO CMake cache can be used to generate a multi-stage instrumented compiler.; You can configure your build directory with the following invocation of CMake:. cmake -G <generator> -C <path_to_clang>/cmake/caches/PGO.cmake <source dir>. After configuration the following additional targets will be generated:. stage2-instrumented:; Builds a stage1 x86 compiler, runtime, and required tools (llvm-config,; llvm-profdata) then uses that compiler to build an instrumented stage2 compiler. stage2-instrumented-generate-profdata:; Depends on ""stage2-instrumented"" and will use the instrumented compiler to; generate profdata based on the training files in <clang>/utils/perf-training. stage2:; Depends on ""stage2-instrumented-generate-profdata"" and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. stage2-check-llvm:; Depends on stage2 and runs check-llvm using the stage3 compiler. stage2-check-clang:; Depends on stage2 and runs check-clang using the stage3 compiler. stage2-check-all:; Depends on stage2 and runs check-all using the stage3 compiler. stage2-test-suite:; Depends on stage2 and runs the test-suite using the stage3 compiler (requires; in-tree test-suite). 3-stage; -------. This cache file can be used to generate a 3-stage clang build. You can configure; using the following CMake command:. cmake -C <path to clang>/cmake/caches/3-stage.cmake -G Ninja <path to llvm>. You can then run ""ninja stage3-clang"" to build stage1, stage2 and stage3 clangs. This is useful for finding non-determinism the compiler by verifying that stage2; and stage3 are identical.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/cmake/caches/README.txt:2179,config,configure,2179,interpreter/llvm-project/clang/cmake/caches/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/cmake/caches/README.txt,1,['config'],['configure']
Modifiability,"--------; class Thing {; }; ------------- Defs -----------------. ```tablegen; // The cache is reset here so this is an error.; def AThing: Thing {}; ```. <stdin>:2:13: error: Couldn't find class 'Thing'; def AThing: Thing {}; ^. The default value is `off`, meaning cells are connected. If you want to override the default for one cell only, use the `%reset` or `%noreset` magic. These always override the default. ```tablegen; class Thing {}; ```. ------------- Classes -----------------; class Thing {; }; ------------- Defs -----------------. ```tablegen; %noreset; // This works because of the noreset above.; def AThing: Thing {}; ```. ------------- Classes -----------------; class Thing {; }; ------------- Defs -----------------; def AThing {	// Thing; }. ```tablegen; // This does not because we're not changing the default.; def AnotherThing: Thing {}; ```. <stdin>:2:19: error: Couldn't find class 'Thing'; def AnotherThing: Thing {}; ^. ```tablegen; %config cellreset off; %reset; // Here we have an empty cache and default reset behaviour.; ```. ------------- Classes -----------------; ------------- Defs -----------------. It is not valid to have `%reset` and `%noreset` in the same cell. ```tablegen; %reset; %noreset; ```. %reset and %noreset in the same cell is not allowed. Use only one, or neither. Consider setting `cellreset` to the majority usecase for your notebook. For example a tutorial building a large example across many cells will likely want it `off`. One with many standalone examples, `on`. There is a ""magic"" directive `%args` that you can use to send command line arguments to `llvm-tblgen`. For example, here we have some code that shows a warning. ```tablegen; %reset; class Thing <int A, int B> {; int num = A;; }; ```. <stdin>:1:25: warning: unused template argument: Thing:B; class Thing <int A, int B> {; ^. We can pass an argument to ignore that warning. ```tablegen; %args --no-warn-on-unused-template-args; ```. ------------- Classes -----------------; cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/LLVM_TableGen.md:2315,config,config,2315,interpreter/llvm-project/llvm/utils/TableGen/jupyter/LLVM_TableGen.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/LLVM_TableGen.md,1,['config'],['config']
Modifiability,"-----. JITLink passes are ``std::function<Error(LinkGraph&)>`` instances. They are free; to inspect and modify the given ``LinkGraph`` subject to the constraints of; whatever phase they are running in (see :ref:`generic_link_algorithm`). If a; pass returns ``Error::success()`` then linking continues. If a pass returns; a failure value then linking is stopped and the ``JITLinkContext`` is notified; that the link failed. Passes may be used by both JITLink backends (e.g. MachO/x86-64 implements GOT; and PLT construction as a pass), and external clients like; ``ObjectLinkingLayer::Plugin``. In combination with the open ``LinkGraph`` API, JITLink passes enable the; implementation of powerful new features. For example:. * Relaxation optimizations -- A pre-fixup pass can inspect GOT accesses and PLT; calls and identify situations where the addresses of the entry target and the; access are close enough to be accessed directly. In this case the pass can; rewrite the instruction stream of the containing block and update the fixup; edges to make the access direct. Code for this looks like:. .. code-block:: c++. Error relaxGOTEdges(LinkGraph &G) {; for (auto *B : G.blocks()); for (auto &E : B->edges()); if (E.getKind() == x86_64::GOTLoad) {; auto &GOTTarget = getGOTEntryTarget(E.getTarget());; if (isInRange(B.getFixupAddress(E), GOTTarget)) {; // Rewrite B.getContent() at fixup address from; // MOVQ to LEAQ. // Update edge target and kind.; E.setTarget(GOTTarget);; E.setKind(x86_64::PCRel32);; }; }. return Error::success();; }. * Metadata registration -- Post allocation passes can be used to record the; address range of sections in the target. This can be used to register the; metadata (e.g exception handling frames, language metadata) in the target; once memory has been finalized. .. code-block:: c++. Error registerEHFrameSection(LinkGraph &G) {; if (auto *Sec = G.findSectionByName(""__eh_frame"")) {; SectionRange SR(*Sec);; registerEHFrameSection(SR.getStart(), SR.getEnd());; }.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:23753,rewrite,rewrite,23753,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['rewrite'],['rewrite']
Modifiability,"-----. TableGen source files contain two primary items: *abstract records* and; *concrete records*. In this and other TableGen documents, abstract records; are called *classes.* (These classes are different from C++ classes and do; not map onto them.) In addition, concrete records are usually just called; records, although sometimes the term *record* refers to both classes and; concrete records. The distinction should be clear in context. Classes and concrete records have a unique *name*, either chosen by; the programmer or generated by TableGen. Associated with that name; is a list of *fields* with values and an optional list of *parent classes*; (sometimes called base or super classes). The fields are the primary data that; backends will process. Note that TableGen assigns no meanings to fields; the; meanings are entirely up to the backends and the programs that incorporate; the output of those backends. .. note::. The term ""parent class"" can refer to a class that is a parent of another; class, and also to a class from which a concrete record inherits. This; nonstandard use of the term arises because TableGen treats classes and; concrete records similarly. A backend processes some subset of the concrete records built by the; TableGen parser and emits the output files. These files are usually C++; ``.inc`` files that are included by the programs that require the data in; those records. However, a backend can produce any type of output files. For; example, it could produce a data file containing messages tagged with; identifiers and substitution parameters. In a complex use case such as the; LLVM code generator, there can be many concrete records and some of them can; have an unexpectedly large number of fields, resulting in large output files. In order to reduce the complexity of TableGen files, classes are used to; abstract out groups of record fields. For example, a few classes may; abstract the concept of a machine register file, while other classes may; abstrac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:3100,inherit,inherits,3100,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherits']
Modifiability,"----. * Upgrade cppyy-cling to 6.18.2; * Various patches to upstream's pre-compiled header generation and use; * Instantiate templates with larger integer types if argument values require; * Improve cppyy.interactive and partially enable it on PyPy, IPython, etc.; * Let ``__overload__`` be more flexible in signature matching; * Make list filtering of dir(cppyy.gbl) on Windows same as Linux/Mac; * Extended documentation. 2019-08-18: 1.5.0; -----------------. * Upgrade cppyy-cling to 6.18.0; * Allow python-derived classes to be used in templates; * Stricter template resolution and better caching/performance; * Detailed memory management for make_shared and shared_ptr; * Two-way memory management for cross-inherited objects; * Reduced memory footprint of proxy objects in most common cases; * Allow implicit conversion from a tuple of arguments; * Data set on namespaces reflected on C++ even if data not yet bound; * Generalized resolution of binary operators in wrapper generation; * Proper naming of arguments in namespaces for ``std::function<>``; * Cover more cases of STL-liker iterators; * Allow ``std::vector`` initialization with a list of constructor arguments; * Consistent naming of ``__cppname__`` to ``__cpp_name__``; * Added ``__set_lifeline__`` attribute to overloads; * Fixes to the cmake fragments for Ubuntu; * Fixes linker errors on Windows in some configurations; * Support C++ naming of typedef of bool types; * Basic views of 2D arrays of builtin types; * Extended documentation. 2019-07-01 : 1.4.12; -------------------. * Automatic conversion of python functions to ``std::function`` arguments; * Fix for templated operators that can map to different python names; * Fix on p3 crash when setting a detailed exception during exception handling; * Fix lookup of ``std::nullopt``; * Fix bug that prevented certain templated constructors from being considered; * Support for enum values as data members on ""enum class"" enums; * Support for implicit conversion when passing ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:17852,inherit,inherited,17852,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,2,"['config', 'inherit']","['configurations', 'inherited']"
Modifiability,"----. The return type and each parameter of a function type may have a set of; *parameter attributes* associated with them. Parameter attributes are; used to communicate additional information about the result or; parameters of a function. Parameter attributes are considered to be part; of the function, not of the function type, so functions with different; parameter attributes can have the same function type. Parameter attributes are simple keywords that follow the type specified.; If multiple parameter attributes are needed, they are space separated.; For example:. .. code-block:: llvm. declare i32 @printf(ptr noalias nocapture, ...); declare i32 @atoi(i8 zeroext); declare signext i8 @returns_signed_char(). Note that any attributes for the function result (``nonnull``,; ``signext``) come before the result type. Currently, only the following parameter attributes are defined:. ``zeroext``; This indicates to the code generator that the parameter or return; value should be zero-extended to the extent required by the target's; ABI by the caller (for a parameter) or the callee (for a return value).; ``signext``; This indicates to the code generator that the parameter or return; value should be sign-extended to the extent required by the target's; ABI (which is usually 32-bits) by the caller (for a parameter) or; the callee (for a return value).; ``inreg``; This indicates that this parameter or return value should be treated; in a special target-dependent fashion while emitting code for; a function call or return (usually, by putting it in a register as; opposed to memory, though some targets use it to distinguish between; two different kinds of registers). Use of this attribute is; target-specific.; ``byval(<ty>)``; This indicates that the pointer parameter should really be passed by; value to the function. The attribute implies that a hidden copy of; the pointee is made between the caller and the callee, so the callee; is unable to modify the value in the caller. This ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:50659,extend,extended,50659,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extended']
Modifiability,"-. There are a variety of sequential containers available for you, based on your; needs. Pick the first in this section that will do what you want. .. _dss_arrayref:. llvm/ADT/ArrayRef.h; ^^^^^^^^^^^^^^^^^^^. The ``llvm::ArrayRef`` class is the preferred class to use in an interface that; accepts a sequential list of elements in memory and just reads from them. By; taking an ``ArrayRef``, the API can be passed a fixed size array, an; ``std::vector``, an ``llvm::SmallVector`` and anything else that is contiguous; in memory. .. _dss_fixedarrays:. Fixed Size Arrays; ^^^^^^^^^^^^^^^^^. Fixed size arrays are very simple and very fast. They are good if you know; exactly how many elements you have, or you have a (low) upper bound on how many; you have. .. _dss_heaparrays:. Heap Allocated Arrays; ^^^^^^^^^^^^^^^^^^^^^. Heap allocated arrays (``new[]`` + ``delete[]``) are also simple. They are good; if the number of elements is variable, if you know how many elements you will; need before the array is allocated, and if the array is usually large (if not,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it suppo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:58455,variab,variable,58455,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"-02 : 1.4.6; ------------------. * More transparent use of smart pointers such as shared_ptr; * Expose versioned std namespace through using on Mac; * Improved error handling and interface checking in cross-inheritance; * Argument of (const/non-const) ref types support in callbacks/cross-inheritance; * Do template argument resolution in order: reference, pointer, value; * Fix for return type deduction of resolved but uninstantiated templates; * Fix wrapper generation for defaulted arguments of private types; * Several linker fixes on 64b Windows. 2019-03-25 : 1.4.5; ------------------. * Allow templated free functions to be attached as methods to classes; * Allow cross-derivation from templated classes; * More support for 'using' declarations (methods and inner namespaces); * Fix overload resolution for ``std::set::rbegin()``/``rend()`` ``operator==``; * Fixes for bugs #61, #67; * Several pointer truncation fixes for 64b Windows; * Linker and lookup fixes for Windows. 2019-03-20 : 1.4.4; ------------------. * Support for 'using' of namespaces; * Improved support for alias templates; * Faster template lookup; * Have rootcling/genreflex respect compile-time flags (except for --std if; overridden by CLING_EXTRA_ARGS); * Utility to build dictionarys on Windows (32/64); * Name mangling fixes in Cling for JITed global/static variables on Windows; * Several pointer truncation fixes for 64b Windows. 2019-03-10 : 1.4.3; ------------------. * Cross-inheritance from abstract C++ base classes; * Preserve 'const' when overriding virtual functions; * Support for by-ref (using ctypes) for function callbacks; * Identity of nested typedef'd classes matches actual; * Expose function pointer variables as ``std::function``'s; * More descriptive printout of global functions; * Ensure that standard pch is up-to-date and that it is removed on; uninstall; * Remove standard pch from wheels on all platforms; * Add -cxxflags option to rootcling; * Install clang resource directory on Windows; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:22304,variab,variables,22304,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,3,"['inherit', 'variab']","['inheritance', 'variables']"
Modifiability,"-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. To start ROOT you can type `root` at the system prompt. This starts up; Cling, the ROOT command line C/C++ interpreter, and it gives you the; ROOT prompt (`root[0]`). It is possible to launch ROOT with some command line options, as shown; below:. ```; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; ```. - -b ROOT session runs in batch mode, without graphics display. This; mode is useful in case one does not want to set the DISPLAY or; cannot do it for some reason. - -n usually, launching a ROOT session will execute a logon script; and quitting will execute a logoff script. This option prevents; the execution of these two scripts. - it is also possible to execute a script without entering a ROOT; session. One simply adds the name of the script(s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:3343,config,configure,3343,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['config'],['configure']
Modifiability,"-> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [002] 11 {Function} extern not_inlined 'test' -> 'int'; [003] 12 {Variable} 'A' -> 'int'; [003] 13 {InlinedFunction} declared_inlined 'InlineFunction' -> 'int'; [004] {Block}; [005] {Variable} 'Var_2' -> 'int'; [004] {Parameter} 'Param' -> 'int'; [004] {Variable} 'Var_1' -> 'int'; [003] 11 {Parameter} 'Param_1' -> 'int'; [003] 11 {Parameter} 'Param_2' -> 'int'. From the previous logical views, we can see that the CodeView debug; information generated by the Clang compiler shows the variables **Var_1**; and **Var_2** are at the same lexical scope (**4**) in the function; **InlineFuction**. The DWARF generated by GCC/Clang and CodeView; generated by MSVC, show those variables at the correct lexical scope:; **3** and **4** respectively. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output showing just the logical elements; that have in their name the *var* pattern. The logical view is sorted; by the variables name. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=name; --select-regex --select-nocase --select=Var; --report=list; --print=symbols; pr-43860-*.o. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-43860.cpp'; [003] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [005] {Variable} 'Var_2' -> 'int'; [004] 5 {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [003] 3 {Variable} 'Var_1' ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:53550,variab,variables,53550,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['variab'],['variables']
Modifiability,"-DLLVM_LIBDIR_SUFFIX=64``; to install libraries to ``/usr/lib64``. **LLVM_PARALLEL_{COMPILE,LINK}_JOBS**:STRING; Building the llvm toolchain can use a lot of resources, particularly; linking. These options, when you use the Ninja generator, allow you; to restrict the parallelism. For example, to avoid OOMs or going; into swap, permit only one link job per 15GB of RAM available on a; 32GB machine, specify ``-G Ninja -DLLVM_PARALLEL_LINK_JOBS=2``. **LLVM_TARGETS_TO_BUILD**:STRING; Control which targets are enabled. For example you may only need to enable; your native target with, for example, ``-DLLVM_TARGETS_TO_BUILD=X86``. .. _llvm_use_linker:. **LLVM_USE_LINKER**:STRING; Override the system's default linker. For instance use ``lld`` with; ``-DLLVM_USE_LINKER=lld``. Rarely-used CMake variables; ---------------------------. Here are some of the CMake variables that are rarely used, along with a brief; explanation and LLVM-related notes. For full documentation, consult the CMake; manual, or execute ``cmake --help-variable VARIABLE_NAME``. **CMAKE_CXX_STANDARD**:STRING; Sets the C++ standard to conform to when building LLVM. Possible values are; 17 and 20. LLVM Requires C++ 17 or higher. This defaults to 17. **CMAKE_INSTALL_BINDIR**:PATH; The path to install executables, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""bin"". **CMAKE_INSTALL_INCLUDEDIR**:PATH; The path to install header files, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""include"". **CMAKE_INSTALL_DOCDIR**:PATH; The path to install documentation, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""share/doc"". **CMAKE_INSTALL_MANDIR**:PATH; The path to install manpage files, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""share/man"". .. _LLVM-related variables:. LLVM-related variables; -----------------------. These variables provide fine control over the build of LLVM and; enabled sub-projects. Nearly all of these variable names begin with; ``LLVM_``. **BUILD_SHARED_LIBS**:BOOL; Flag",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:10556,variab,variable,10556,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"-Goals; ---------. ``MemorySSA`` is meant to reason about the relation between memory; operations, and enable quicker querying.; It isn't meant to be the single source of truth for all potential memory-related; optimizations. Specifically, care must be taken when trying to use ``MemorySSA``; to reason about atomic or volatile operations, as in:. .. code-block:: llvm. define i8 @foo(ptr %a) {; entry:; br i1 undef, label %if.then, label %if.end. if.then:; ; 1 = MemoryDef(liveOnEntry); %0 = load volatile i8, ptr %a; br label %if.end. if.end:; %av = phi i8 [0, %entry], [%0, %if.then]; ret i8 %av; }. Going solely by ``MemorySSA``'s analysis, hoisting the ``load`` to ``entry`` may; seem legal. Because it's a volatile load, though, it's not. Design tradeoffs; ----------------. Precision; ^^^^^^^^^. ``MemorySSA`` in LLVM deliberately trades off precision for speed.; Let us think about memory variables as if they were disjoint partitions of the; memory (that is, if you have one variable, as above, it represents the entire; memory, and if you have multiple variables, each one represents some; disjoint portion of the memory). First, because alias analysis results conflict with each other, and; each result may be what an analysis wants (IE; TBAA may say no-alias, and something else may say must-alias), it is; not possible to partition the memory the way every optimization wants.; Second, some alias analysis results are not transitive (IE A noalias B,; and B noalias C, does not mean A noalias C), so it is not possible to; come up with a precise partitioning in all cases without variables to; represent every pair of possible aliases. Thus, partitioning; precisely may require introducing at least N^2 new virtual variables,; phi nodes, etc. Each of these variables may be clobbered at multiple def sites. To give an example, if you were to split up struct fields into; individual variables, all aliasing operations that may-def multiple struct; fields, will may-def more than one of them",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:16718,variab,variables,16718,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,3,['variab'],"['variable', 'variables']"
Modifiability,"-architecture, for example only to Intel chips that support ``AVX2``. For instance, ``test/CodeGen/X86/psubus.ll`` tests three sub-architecture; variants:. .. code-block:: llvm. ; RUN: llc -mcpu=core2 < %s | FileCheck %s -check-prefix=SSE2; ; RUN: llc -mcpu=corei7-avx < %s | FileCheck %s -check-prefix=AVX1; ; RUN: llc -mcpu=core-avx2 < %s | FileCheck %s -check-prefix=AVX2. And the checks are different:. .. code-block:: llvm. ; SSE2: @test1; ; SSE2: psubusw LCPI0_0(%rip), %xmm0; ; AVX1: @test1; ; AVX1: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0; ; AVX2: @test1; ; AVX2: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0. So, if you're testing for a behaviour that you know is platform-specific or; depends on special features of sub-architectures, you must add the specific; triple, test with the specific FileCheck and put it into the specific; directory that will filter out all other architectures. Constraining test execution; ---------------------------. Some tests can be run only in specific configurations, such as; with debug builds or on particular platforms. Use ``REQUIRES``; and ``UNSUPPORTED`` to control when the test is enabled. Some tests are expected to fail. For example, there may be a known bug; that the test detect. Use ``XFAIL`` to mark a test as an expected failure.; An ``XFAIL`` test will be successful if its execution fails, and; will be a failure if its execution succeeds. .. code-block:: llvm. ; This test will be only enabled in the build with asserts.; ; REQUIRES: asserts; ; This test is disabled when running on Linux.; ; UNSUPPORTED: system-linux; ; This test is expected to fail when targeting PowerPC.; ; XFAIL: target=powerpc{{.*}}. ``REQUIRES`` and ``UNSUPPORTED`` and ``XFAIL`` all accept a comma-separated; list of boolean expressions. The values in each expression may be:. - Features added to ``config.available_features`` by configuration files such as ``lit.cfg``.; String comparison of features is case-sensitive. Furthermore, a boolean expression can; contain any P",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:19589,config,configurations,19589,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configurations']
Modifiability,"-assume-filename).; If no .clang-format file is found, falls back to; --fallback-style.; --style=file is the default.; 3. 'file:<format_file_path>' to explicitly specify; the configuration file.; 4. ""{key: value, ...}"" to set specific parameters, e.g.:; --style=""{BasedOnStyle: llvm, IndentWidth: 8}""; --verbose - If set, shows the list of processed files. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. .. END_FORMAT_HELP. When the desired code formatting style is different from the available options,; the style can be customized using the ``-style=""{key: value, ...}""`` option or; by putting your style configuration in the ``.clang-format`` or ``_clang-format``; file in your project's directory and using ``clang-format -style=file``. An easy way to create the ``.clang-format`` file is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. Available style options are described in :doc:`ClangFormatStyleOptions`. .clang-format-ignore; ====================. You can create ``.clang-format-ignore`` files to make ``clang-format`` ignore; certain files. A ``.clang-format-ignore`` file consists of patterns of file path; names. It has the following format:. * A blank line is skipped.; * Leading and trailing spaces of a line are trimmed.; * A line starting with a hash (``#``) is a comment.; * A non-comment line is a single pattern.; * The slash (``/``) is used as the directory separator.; * A pattern is relative to the directory of the ``.clang-format-ignore`` file; (or the root directory if the pattern starts with a slash). Patterns; containing drive names (e.g. ``C:``) are not supported.; * Patterns follow the rules specified in `POSIX 2.13.1, 2.13.2, and Rule 1 of; 2.13.3 <https://pubs.opengroup.org/onlinepubs/9699919799/utilities/; V3_chap02.html#tag_18_13>`_.; * A pattern is negated if it st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:4992,config,config,4992,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['config'],['config']
Modifiability,"-block:: bash. % cd llvm/projects/test-suite/MultiSource/Benchmarks # or some other level; % make TEST=dbgopt. This will test impact of debugging information on optimization passes. If; debugging information influences optimization passes then it will be reported; as a failure. See :doc:`TestingGuide` for more information on LLVM test; infrastructure and how to run various tests. .. _format:. Debugging information format; ============================. LLVM debugging information has been carefully designed to make it possible for; the optimizer to optimize the program and debugging information without; necessarily having to know anything about debugging information. In; particular, the use of metadata avoids duplicated debugging information from; the beginning, and the global dead code elimination pass automatically deletes; debugging information for a function if it decides to delete the function. To do this, most of the debugging information (descriptors for types,; variables, functions, source files, etc) is inserted by the language front-end; in the form of LLVM metadata. Debug information is designed to be agnostic about the target debugger and; debugging information representation (e.g. DWARF/Stabs/etc). It uses a generic; pass to decode the information that represents variables, types, functions,; namespaces, etc: this allows for arbitrary source-language semantics and; type-systems to be used, as long as there is a module written for the target; debugger to interpret the information. To provide basic functionality, the LLVM debugger does have to make some; assumptions about the source-level language being debugged, though it keeps; these to a minimum. The only common features that the LLVM debugger assumes; exist are `source files <LangRef.html#difile>`_, and `program objects; <LangRef.html#diglobalvariable>`_. These abstract objects are used by a; debugger to form stack traces, show information about local variables, etc. This section of the documentation fir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:6827,variab,variables,6827,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"-debug-types. By default, Clang does not emit type information for types that are defined; but not used in a program. To retain the debug info for these unused types,; the negation **-fno-eliminate-unused-debug-types** can be used. .. option:: -fexceptions. Allow exceptions to be thrown through Clang compiled stack frames (on many; targets, this will enable unwind information for functions that might have; an exception thrown through them). For most targets, this is enabled by; default for C++. .. option:: -ftrapv. Generate code to catch integer overflow errors. Signed integer overflow is; undefined in C. With this flag, extra code is generated to detect this and; abort when it happens. .. option:: -fvisibility. This flag sets the default visibility level. .. option:: -fcommon, -fno-common. This flag specifies that variables without initializers get common linkage.; It can be disabled with :option:`-fno-common`. .. option:: -ftls-model=<model>. Set the default thread-local storage (TLS) model to use for thread-local; variables. Valid values are: ""global-dynamic"", ""local-dynamic"",; ""initial-exec"" and ""local-exec"". The default is ""global-dynamic"". The default; model can be overridden with the tls_model attribute. The compiler will try; to choose a more efficient model if possible. .. option:: -flto, -flto=full, -flto=thin, -emit-llvm. Generate output files in LLVM formats, suitable for link time optimization.; When used with :option:`-S` this generates LLVM intermediate language; assembly files, otherwise this generates LLVM bitcode format object files; (which may be passed to the linker depending on the stage selection options). The default for :option:`-flto` is ""full"", in which the; LLVM bitcode is suitable for monolithic Link Time Optimization (LTO), where; the linker merges all such modules into a single combined module for; optimization. With ""thin"", :doc:`ThinLTO <../ThinLTO>`; compilation is invoked instead. .. note::. On Darwin, when using :option:`-flto` alon",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:14705,variab,variables,14705,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['variab'],['variables']
Modifiability,"-exporting symbols from several other JITDylibs. .. _Laziness:. Laziness; ========. Laziness in ORC is provided by a utility called ""lazy reexports"". A lazy; reexport is similar to a regular reexport or alias: It provides a new name for; an existing symbol. Unlike regular reexports however, lookups of lazy reexports; do not trigger immediate materialization of the reexported symbol. Instead, they; only trigger materialization of a function stub. This function stub is; initialized to point at a *lazy call-through*, which provides reentry into the; JIT. If the stub is called at runtime then the lazy call-through will look up; the reexported symbol (triggering materialization for it if necessary), update; the stub (to call directly to the reexported symbol on subsequent calls), and; then return via the reexported symbol. By re-using the existing symbol lookup; mechanism, lazy reexports inherit the same concurrency guarantees: calls to lazy; reexports can be made from multiple threads concurrently, and the reexported; symbol can be any state of compilation (uncompiled, already in the process of; being compiled, or already compiled) and the call will succeed. This allows; laziness to be safely mixed with features like remote compilation, concurrent; compilation, concurrent JIT'd code, and speculative compilation. There is one other key difference between regular reexports and lazy reexports; that some clients must be aware of: The address of a lazy reexport will be; *different* from the address of the reexported symbol (whereas a regular; reexport is guaranteed to have the same address as the reexported symbol).; Clients who care about pointer equality will generally want to use the address; of the reexport as the canonical address of the reexported symbol. This will; allow the address to be taken without forcing materialization of the reexport. Usage example:. If JITDylib ``JD`` contains definitions for symbols ``foo_body`` and; ``bar_body``, we can create lazy entry poi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:17397,inherit,inherit,17397,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['inherit'],['inherit']
Modifiability,"-facility):. ``` {.bash}; git clone git://github.com/dberzano/virtual-analysis-facility.git /dest/dir; ```. The client will be found in `/dest/dir/client/bin/vaf-enter`: it is; convenient to add it to the `$PATH` so that the users might simply start; it by typing `vaf-enter`. ### Install the experiment's configuration files system-wide. A system administrator might find convenient to install the experiment; environment scripts system-wide. Configuration scripts for LHC experiments are shipped with the VAF; client and can be found in; `/dest/dir/client/config-samples/<experiment_name>`. To make them used; by default by the VAF client, place them in the `/dest/dir/etc`; directory like this:. ``` {.bash}; rsync -a /dest/dir/client/config-samples/<experiment_name>/ /dest/dir/etc/; ```. Remember that the trailing slash in the source directory name has a; meaning in `rsync` and must not be omitted. > Remember that system-wide configuration files will always have; > precedence over user's configuration files, so *don't place there; > files that are supposed to be provided by the user!*. Entering the Virtual Analysis Facility environment; --------------------------------------------------. The Virtual Analysis Facility client is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:7941,config,configuration,7941,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,2,['config'],['configuration']
Modifiability,"-format will always break after a Json array ``[``; otherwise it will scan until the closing ``]`` to determine if it should; add newlines between elements (prettier compatible). .. note::. This is currently only for formatting JSON. .. code-block:: c++. true: false:; [ vs. [1, 2, 3, 4]; 1,; 2,; 3,; 4; ]. .. _BreakBeforeBinaryOperators:. **BreakBeforeBinaryOperators** (``BinaryOperatorStyle``) :versionbadge:`clang-format 3.6` :ref:`¶ <BreakBeforeBinaryOperators>`; The way to wrap binary operators. Possible values:. * ``BOS_None`` (in configuration: ``None``); Break after operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >; ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_NonAssignment`` (in configuration: ``NonAssignment``); Break before operators that aren't assignments. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_All`` (in configuration: ``All``); Break before operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable; = someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. .. _BreakBeforeBraces:. **BreakBeforeBraces** (``BraceBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeBraces>`; The brace breaking style to u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:46664,config,configuration,46664,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"-format` formats a file, it auto-detects the language using; the file name. When formatting standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. When specifying configuration in the ``-style=`` option, the same configuration; is applied for all input files. The format of the configuration is:. .. code-block:: console. -style='{key1: value1, key2: value2, ...}'. Disabling Formatting on a Piece of Code; =======================================. Clang-format understands also special comments that switch formatting in a; delimited range. The code between a comment ``// clang-format off`` or; ``/* clang-format off */`` up to a comment ``// clang-format on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; ============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:3483,config,config,3483,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['config']
Modifiability,"-indentation for GCC: Some LLVM source files; # are too large.; set(cxx_flags_prev ${CMAKE_CXX_FLAGS}); if(CMAKE_CXX_COMPILER_ID STREQUAL ""GNU""); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -Wno-misleading-indentation""); endif(). if(builtin_llvm); # Since debug builds of LLVM are quite large, we want to be able; # to control the build types of ROOT and LLVM independently. The; # logic below is to make that possible. LLVM is built in Release; # mode unless a different build type is chosen via LLVM_BUILD_TYPE. if(NOT DEFINED LLVM_BUILD_TYPE); set(LLVM_BUILD_TYPE Release CACHE STRING ""Build type used for LLVM""); endif(). message(STATUS ""Building LLVM in '${LLVM_BUILD_TYPE}' mode.""). if(NOT DEFINED LLVM_ENABLE_ASSERTIONS); if(CMAKE_BUILD_TYPE MATCHES ""Debug""; OR LLVM_BUILD_TYPE MATCHES ""(Debug|RelWithDebInfo)""); set(LLVM_ENABLE_ASSERTIONS TRUE); else(); set(LLVM_ENABLE_ASSERTIONS FALSE); endif(); endif(). # Multi-configuration generators ignore CMAKE_BUILD_TYPE, so; # in that case we set the flags for all configurations to the; # flags of the build type assigned to LLVM_BUILD_TYPE. if(MSVC OR XCODE); string(TOUPPER ${LLVM_BUILD_TYPE} LLVM_BUILD_TYPE); set(LLVM_C_FLAGS ${CMAKE_C_FLAGS_${LLVM_BUILD_TYPE}}); set(LLVM_CXX_FLAGS ${CMAKE_CXX_FLAGS_${LLVM_BUILD_TYPE}}); # On Windows, use the same compiler flags than ROOT and not; # the other way around; if(NOT MSVC); foreach(CONFIG ${CMAKE_CONFIGURATION_TYPES}); string(TOUPPER ${CONFIG} CONFIG); set(CMAKE_C_FLAGS_${CONFIG} ${LLVM_C_FLAGS}); set(CMAKE_CXX_FLAGS_${CONFIG} ${LLVM_CXX_FLAGS}); endforeach(); endif(); elseif(NOT LLVM_BUILD_TYPE STREQUAL CMAKE_BUILD_TYPE); set(CMAKE_BUILD_TYPE ${LLVM_BUILD_TYPE}); endif(). set(BUILD_SHARED_LIBS FALSE). #---Remove the inherited include_directories(); set_directory_properties(PROPERTIES INCLUDE_DIRECTORIES """"). set(LLVM_ENABLE_PROJECTS ""clang"" CACHE STRING """"). #---Add the sub-directory excluding all the targets from all-----------------------------------------; if(CMAKE_GENERATOR MATCHES ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:10045,config,configuration,10045,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,2,['config'],"['configuration', 'configurations']"
Modifiability,"-independent input DAG into another DAG of target instructions. #. `SelectionDAG Scheduling and Formation`_ --- The last phase assigns a linear; order to the instructions in the target-instruction DAG and emits them into; the MachineFunction being compiled. This step uses traditional prepass; scheduling techniques. After all of these steps are complete, the SelectionDAG is destroyed and the; rest of the code generation passes are run. One of the most common ways to debug these steps is using ``-debug-only=isel``,; which prints out the DAG, along with other information like debug info,; after each of these steps. Alternatively, ``-debug-only=isel-dump`` shows only; the DAG dumps, but the results can be filtered by function names using; ``-filter-print-funcs=<function names>``. One great way to visualize what is going on here is to take advantage of a few; LLC command line options. The following options pop up a window displaying the; SelectionDAG at specific times (if you only get errors printed to the console; while using this, you probably `need to configure your; system <ProgrammersManual.html#viewing-graphs-while-debugging-code>`_ to add support for it). * ``-view-dag-combine1-dags`` displays the DAG after being built, before the; first optimization pass. * ``-view-legalize-dags`` displays the DAG before Legalization. * ``-view-dag-combine2-dags`` displays the DAG before the second optimization; pass. * ``-view-isel-dags`` displays the DAG before the Select phase. * ``-view-sched-dags`` displays the DAG before Scheduling. The ``-view-sunit-dags`` displays the Scheduler's dependency graph. This graph; is based on the final SelectionDAG, with nodes that must be scheduled together; bundled into a single scheduling-unit node, and with immediate operands and; other nodes that aren't relevant for scheduling omitted. The option ``-filter-view-dags`` allows to select the name of the basic block; that you are interested to visualize and filters all the previous; ``view-*-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:39169,config,configure,39169,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['config'],['configure']
Modifiability,"-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors for types with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=none or -analyzer-config ipa=basic-inlining,; regardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option controls whether C++ templated functions may be inlined. ``-analyzer-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this option is that very generic code can be a source; of false positives, either by considering paths that the caller considers; impossible (by some unstated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions and the STL in particular are used ubiquitously; enough that our tolerance for false positives is even lower here. A false; positive due to poor modeling of the STL leads to a poor user experience, since; most users would not be comfo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:2796,config,config,2796,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['config'],['config']
Modifiability,-to-rvalue conversions of uninitialized char objects; Unknown. 618; CD2; Casts in preprocessor conditional expressions; Yes. 619; C++11; Completeness of array types; Yes. 620; CD1; Declaration order in layout-compatible POD structs; Duplicate of 568. 621; C++11; Template argument deduction from function return types; Yes. 622; NAD; Relational comparisons of arbitrary pointers; Unknown. 623; CD3; Use of pointers to deallocated storage; N/A. 624; CD1; Overflow in calculating size of allocation; Unknown. 625; CD2; Use of auto as a template-argument; Yes. 626; CD2; Preprocessor string literals; Yes. 627; NAD; Values behaving as types; Yes. 628; CD2; The values of an enumeration with no enumerator; N/A. 629; CD1; auto parsing ambiguity; Clang 2.9. 630; CD2; Equality of narrow and wide character values in the basic character set; Yes. 631; CD3; Jumping into a “then” clause; N/A. 632; CD1; Brace-enclosed initializer for scalar member of aggregate; Yes. 633; CD2; Specifications for variables that should also apply to references; N/A. 634; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis redux; Yes. 635; NAD; Names of constructors and destructors of templates; Yes. 636; CD4; Dynamic type of objects and aliasing; Unknown. 637; CD1; Sequencing rules and example disagree; Yes. 638; CD2; Explicit specialization and friendship; No. 639; CD1; What makes side effects “different” from one another?; Clang 3.3. 640; NAD; Accessing destroyed local objects of static storage duration; Unknown. 641; CD2; Overload resolution and conversion-to-same-type operators; Yes. 642; CD2; Definition and use of “block scope” and “local scope”; Yes. 643; NAD; Use of decltype in a class member-specification; Clang 3.2. 644; CD1; Should a trivial class type be a literal type?; Partial. 645; CD2; Are bit-field and non-bit-field members layout compatible?; N/A. 646; NAD; Can a class with a constexpr copy constructor be a literal type?; Superseded by 981. 647; CD1; Non-constexpr ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:43197,variab,variables,43197,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"-url WITH_CLANG_URL; Specify an alternate URL of Clang repo; --with-cling-url WITH_CLING_URL; Specify an alternate URL of Cling repo; --no-test Do not run test suite of Cling; --create-dev-env CREATE_DEV_ENV; Set up a release/debug environment; --with-workdir WITH_WORKDIR; Specify an alternate working directory for CPT; --make-proper MAKE_PROPER; Internal option to support calls from build system. ```; If you want CPT to build a package by detecting your platform automatically,; use the value 'pkg'.; ```sh; ./cpt.py --current-dev=pkg; ```; or; ```sh; ./cpt.py --last-stable=pkg; ```; ### Overriding Default Variables; There are a select number of variables which can be set to make CPT work; differently. This eliminates the need to manually edit the script.; You can overrride variables by using the following syntax:; ```$ ./cpt.py --with-cling-url=""http://github.com/ani07nov/cling"" --current-dev=tar```. List of variables in CPT which can be overridden:; - **CLING_GIT_URL**; * Specify the URL of the Git repository of Cling to be used by CPT; * **Default value:** ""http://root.cern.ch/git/cling.git""; * **Usage:** ```./cpt.py --with-cling-url=""http://github.com/ani07nov/cling"" --last-stable=deb```. - **CLANG_GIT_URL**; * Specify the URL of the Git repository of Clang to be used by CPT; * **Default value:** ""http://root.cern.ch/git/clang.git""; * **Usage:** ```./cpt.py --with-clang-url=""http://github.com/ani07nov/clang"" --last-stable=tar```. - **LLVM_GIT_URL**; * Specify the URL of the Git repository of LLVM to be used by CPT; * **Default value:** ""http://root.cern.ch/git/llvm.git""; * **Usage:** ```./cpt.py --with-llvm-url=""http://github.com/ani07nov/llvm"" --current-dev=tar```. - **workdir**; * Specify the working directory of CPT. All sources will be cloned, built; and installed here. The produced packages will also be found here.; * **Default value:** ""~/ec/build""; * **Usage:** ```./cpt.py --with-workdir=""/ec/build"" --current-dev=deb```. Authors; =======; Cling Packaging To",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:8546,variab,variables,8546,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['variab'],['variables']
Modifiability,". ## Changes in 6.3.1; 1. Fix bug with col draw option in TH2/RH2. ## Changes in 6.3.0; 1. Fully rewrite TLatex parsing, use svg elements instead of plain text/tspan; 2. Make TLatex reliably working in node.js, does not depend from availability of canvas component; 3. Many optimizations to produce smaller (and faster) SVG output; 4. Provide x3dscNNN and y3dscNNN draw option for histogram to resize x/y axis in 3D plots; 5. Provide ""Find label"" command in TAxis context menu to zoom into bin region; 6. Allows to use JSROOT.define() in external scripts; 7. Provide JSROOT.Painter.setDefaultDrawOpt() to change class default draw option; 8. Provide example of custom entries in histogram context menu; 9. Provide alternative external location for zstd-codec, let use zstd even when not found locally; 10. Let skip HEAD requests when reading files, adding ""^"" symbol to file name (#223); 11. Show long histogram names in stats box when possible; 12. Fix logic how ""ndiv"" parameter of TAxis is handled, showing really the configured number of ticks; 13. Fix problem with curved TGraph drawings (#218); 14. Fix problems with TGraph drawing updates; 15. Base version for ROOT 6.26 release. ## Changes in 6.2.2; 1. Fix - proper fill TH1 which drawn with line option; 2. Fix - object drawing from inspector; 3. Fix - error with filling data of TGeoTrack in ""extract tracks"" example; 4. Fix - error in pad items context menu; 5. Fix - assigned dropped item name only when new painter created. ## Changes in 6.2.1; 1. Fix logy and logz handling on lego plots; 2. Fix error in statistic calculations for projections; 3. Fix zstd-codec loading with minified jsroot scripts. ## Changes in 6.2.0; 1. Support fully interactive second X/Y axis for histograms, graphs, functions and spline; 2. Support X+, Y+, RX, RY draw options for TF1; 3. Remove deprecated JSRootCore.js script, one have to use JSRoot.core.js; 4. Upgrade three.js to r127; 5. Upgrade d3.js to 6.7.0; 6. Implement ""nozoomx"" and ""nozoomy"" draw opt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:21935,config,configured,21935,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configured']
Modifiability,". #---Here we add tcmalloc to the linker flags if needed------------------------------------------; if (TCMALLOC_FOUND); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -ltcmalloc -L${TCMALLOC_LIBRARY_PATH}""); set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHARED_LINKER_FLAGS} -ltcmalloc -L${TCMALLOC_LIBRARY_PATH}""); endif(). #---Here we add jemalloc to the linker flags if needed------------------------------------------; if (JEMALLOC_FOUND); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -ljemalloc -L${JEMALLOC_LIBRARY_PATH}""); set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHARED_LINKER_FLAGS} -ljemalloc -L${JEMALLOC_LIBRARY_PATH}""); endif(). #---Populate the configure arguments returned by 'root-config --config'-------------------------; get_cmake_property(variables CACHE_VARIABLES); foreach(var ${variables}); if((var MATCHES ""_(LIBRARIES|LIBRARY|INCLUDE|VERSION)"") AND; (NOT ${${var}} STREQUAL """") AND; (NOT ${var} MATCHES ""NOTFOUND"")); if (var MATCHES ""^QT_""); # filter out the very long list of Qt libraries and include dirs; if (var MATCHES ""(QT_LIBRARY_DIR|QT_QTCORE_INCLUDE_DIR)""); set(ROOT_CONFIGARGS ""${ROOT_CONFIGARGS}${var}=${${var}} ""); endif(); else(); if ((NOT var MATCHES ""_(DOCS|TESTS|INSTALL)"") AND (NOT var MATCHES ""^_"")); set(ROOT_CONFIGARGS ""${ROOT_CONFIGARGS}${var}=${${var}} ""); endif(); endif(); endif(); endforeach(). #---Move (copy) directories to binary tree------------------------------------------------------; set(stamp_file ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/move_artifacts.stamp); add_custom_command(OUTPUT ${stamp_file}; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/LICENSE ${CMAKE_BINARY_DIR}/LICENSE; COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_SOURCE_DIR}/README ${CMAKE_BINARY_DIR}/README; COMMAND ${CMAKE_COMMAND} -E touch ${stamp_file}; COMMENT ""Copying directories such as etc, icons, fonts, js, ui5, etc. to build area""). if(http); set(jsroot_files js/*); endif(); if(webgui); set(openui5_files ui5/*); endif(). #---C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:13050,config,configure,13050,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,5,"['config', 'variab']","['config', 'configure', 'variables']"
Modifiability,". #. Run the ``cmake``:. .. code-block:: console. % cmake -G ""Unix Makefiles"" -DCMAKE_BUILD_TYPE=<type> -DCMAKE_INSTALL_PREFIX=/install/path; [other options] SRC_ROOT. Compiling the LLVM Suite Source Code; ------------------------------------. Unlike with autotools, with CMake your build type is defined at configuration.; If you want to change your build type, you can re-run cmake with the following; invocation:. .. code-block:: console. % cmake -G ""Unix Makefiles"" -DCMAKE_BUILD_TYPE=<type> SRC_ROOT. Between runs, CMake preserves the values set for all options. CMake has the; following build types defined:. Debug. These builds are the default. The build system will compile the tools and; libraries unoptimized, with debugging information, and asserts enabled. Release. For these builds, the build system will compile the tools and libraries; with optimizations enabled and not generate debug info. CMakes default; optimization level is -O3. This can be configured by setting the; ``CMAKE_CXX_FLAGS_RELEASE`` variable on the CMake command line. RelWithDebInfo. These builds are useful when debugging. They generate optimized binaries with; debug information. CMakes default optimization level is -O2. This can be; configured by setting the ``CMAKE_CXX_FLAGS_RELWITHDEBINFO`` variable on the; CMake command line. Once you have LLVM configured, you can build it by entering the *OBJ_ROOT*; directory and issuing the following command:. .. code-block:: console. % make. If the build fails, please `check here`_ to see if you are using a version of; GCC that is known not to compile LLVM. If you have multiple processors in your machine, you may wish to use some of the; parallel build options provided by GNU Make. For example, you could use the; command:. .. code-block:: console. % make -j2. There are several special targets which are useful when working with the LLVM; source code:. ``make clean``. Removes all files generated by the build. This includes object files,; generated C/C++ files,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:29216,config,configured,29216,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,2,"['config', 'variab']","['configured', 'variable']"
Modifiability,". .. _SpacesInParens:. **SpacesInParens** (``SpacesInParensStyle``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParens>`; Defines in which cases spaces will be inserted after ``(`` and before; ``)``. Possible values:. * ``SIPO_Never`` (in configuration: ``Never``); Never put a space in parentheses. .. code-block:: c++. void f() {; if(true) {; f();; }; }. * ``SIPO_Custom`` (in configuration: ``Custom``); Configure each individual space in parentheses in; `SpacesInParensOptions`. .. _SpacesInParensOptions:. **SpacesInParensOptions** (``SpacesInParensCustom``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParensOptions>`; Control of individual spaces in parentheses. If ``SpacesInParens`` is set to ``Custom``, use this to specify; how each individual space in parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; InEmptyParentheses: true. Nested configuration flags:. Precise control over the spacing in parentheses. .. code-block:: c++. # Should be declared this way:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; Other: true. * ``bool InConditionalStatements`` Put a space in parentheses only inside conditional statements; (``for/if/while/switch...``). .. code-block:: c++. true: false:; if ( a ) { ... } vs. if (a) { ... }; while ( i < 5 ) { ... } while (i < 5) { ... }. * ``bool InCStyleCasts`` Put a space in C style casts. .. code-block:: c++. true: false:; x = ( int32 )y vs. x = (int32)y. * ``bool InEmptyParentheses`` Put a space in parentheses only if the parentheses are empty i.e. '()'. .. code-block:: c++. true: false:; void f( ) { vs. void f() {; int x[] = {foo( ), bar( )}; int x[] = {foo(), bar()};; if (true) { if (true) {; f( ); f();; } }; } }. * ``bool Other`` Put a space in parentheses not covered by preceding options. .. code-block:: c++. true: false:; t f( Deleted & ) & = delete; vs. t f(Dele",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:126998,config,configuration,126998,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,". .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical registers, virtual registers, or numbered basic blocks. SparseMultiSet is useful for algorithms that need very fast; clear/find/insert/erase of the entire collection, and iteration over sets of; elements sharing a key. It is often a more efficient choice than using composite; data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polymorphic objects. It is a combination of a chained; hash table with intrusive links (uniqued objects are required to inherit from; FoldingSetNode) that uses :ref:`SmallVector <dss_smallvector>` as part of its ID; process. Consider a case where you want to implement a ""getOrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which point we would have to delete it; and return the node that already exists. To support this style of client, FoldingSet perform a query with a; FoldingSetNodeID (which wraps SmallVector) that can be used to describe the; element that we want to query for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take place. Construction of the ID usually does not require heap traffic. Because FoldingSet uses intrusive links, it can support polymorphic objects in; the set (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:81947,inherit,inherit,81947,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['inherit'],['inherit']
Modifiability,". .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _StatementMacros:. **StatementMacros** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <StatementMacros>`; A vector of macros that should be interpreted as complete; statements. Typical macros are expressions, and require a semi-colon to be; added; sometimes this is not the case, and this allows to mak",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129718,config,configuration,129718,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,". .. code-block:: console. $ clang -fproc-stat-report=abc foo.c; $ cat abc; clang-11,""/tmp/foo-123456.o"",92000,84000,87536; ld,""a.out"",900,8000,53568. The data on each row represent:. * file name of the tool executable,; * output file name in quotes,; * total execution time in microseconds,; * execution time in user mode in microseconds,; * peak memory usage in Kb. It is possible to specify this option without any value. In this case statistics; are printed on standard output in human readable format:. .. code-block:: console. $ clang -fproc-stat-report foo.c; clang-11: output=/tmp/foo-855a8e.o, total=68.000 ms, user=60.000 ms, mem=86920 Kb; ld: output=a.out, total=8.000 ms, user=4.000 ms, mem=52320 Kb. The report file specified in the option is locked for write, so this option; can be used to collect statistics in parallel builds. The report file is not; cleared, new data is appended to it, thus making possible to accumulate build; statistics. You can also use environment variables to control the process statistics reporting.; Setting ``CC_PRINT_PROC_STAT`` to ``1`` enables the feature, the report goes to; stdout in human readable format.; Setting ``CC_PRINT_PROC_STAT_FILE`` to a fully qualified file path makes it report; process statistics to the given file in the CSV format. Specifying a relative; path will likely lead to multiple files with the same name created in different; directories, since the path is relative to a changing working directory. These environment variables are handy when you need to request the statistics; report without changing your build scripts or alter the existing set of compiler; options. Note that ``-fproc-stat-report`` take precedence over ``CC_PRINT_PROC_STAT``; and ``CC_PRINT_PROC_STAT_FILE``. .. code-block:: console. $ export CC_PRINT_PROC_STAT=1; $ export CC_PRINT_PROC_STAT_FILE=~/project-build-proc-stat.csv; $ make. Other Options; -------------; Clang options that don't fit neatly into other categories. .. option:: -fgnuc-version",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:27794,variab,variables,27794,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,". .. productionlist::; SimpleValue7: `TokIdentifier`. The resulting value is the value of the entity named by the identifier. The; possible identifiers are described here, but the descriptions will make more; sense after reading the remainder of this guide. .. The code for this is exceptionally abstruse. These examples are a; best-effort attempt. * A template argument of a ``class``, such as the use of ``Bar`` in::. class Foo <int Bar> {; int Baz = Bar;; }. * The implicit template argument ``NAME`` in a ``class`` or ``multiclass``; definition (see `NAME`_). * A field local to a ``class``, such as the use of ``Bar`` in::. class Foo {; int Bar = 5;; int Baz = Bar;; }. * The name of a record definition, such as the use of ``Bar`` in the; definition of ``Foo``::. def Bar : SomeClass {; int X = 5;; }. def Foo {; SomeClass Baz = Bar;; }. * A field local to a record definition, such as the use of ``Bar`` in::. def Foo {; int Bar = 5;; int Baz = Bar;; }. Fields inherited from the record's parent classes can be accessed the same way. * A template argument of a ``multiclass``, such as the use of ``Bar`` in::. multiclass Foo <int Bar> {; def : SomeClass<Bar>;; }. * A variable defined with the ``defvar`` or ``defset`` statements. * The iteration variable of a ``foreach``, such as the use of ``i`` in::. foreach i = 0...5 in; def Foo#i;. .. productionlist::; SimpleValue8: `ClassID` ""<"" `ArgValueList` "">"". This form creates a new anonymous record definition (as would be created by an; unnamed ``def`` inheriting from the given class with the given template; arguments; see `def`_) and the value is that record. A field of the record can be; obtained using a suffix; see `Suffixed Values`_. Invoking a class in this manner can provide a simple subroutine facility.; See `Using Classes as Subroutines`_ for more information. .. productionlist::; SimpleValue9: `BangOperator` [""<"" `Type` "">""] ""("" `ValueListNE` "")""; :| `CondOperator` ""("" `CondClause` ("","" `CondClause`)* "")""; CondClause: `Valu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:17164,inherit,inherited,17164,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherited']
Modifiability,". // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Below is the list of the `Event` data members. It contains a character; array, several integers, a floating-point number, and an `EventHeader`; object. The `EventHeader` class is described in the following paragraph.; `Event` also has two pointers, one to a **`TClonesArray`** of tracks and; one to a histogram. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58861,inherit,inheriting,58861,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['inherit'],['inheriting']
Modifiability,". 42. **`tree->Draw(""fClosestDistance:Iteration$"")`**. This example draws a 2D plot with, for all entries,; `fClosestDistance[i]:i` for each value of `i` between 0 and the size of; `fClosestDistance`. `Iterations$` is one of four special variables; giving some indications of the state of the loops implied by the; formula:. `Entry$ :` return the current entry number (`TTree::GetReadEntry()`). `Entries$ :` return the total number of entries (`TTree::GetEntries()`). `Length$ :` return the total number of element of this formula for; this entry. `Iteration$:` return the current iteration over this formula for this; entry (i.e. varies from 0 to `Length$`). 43. **`tree->Draw(""fLastTrack.GetPx():fLastTrack.fPx"");`**. **`TRef`** and **`TRefArray`** are automatically deferenced and this; shows the value of the `fPx` of the track referenced by `fLastTrack`. To; access the **`TRef`** object itself use the '`@`' notation (see next; example). This auto dereferencing can be extended (via an implementation; of **`TVirtualRefProxy`**) to any reference type. 44. **`tree->Scan(""((Track*)(fLastTrack@.GetObject())).GetPx()"","""","""");`**. Will cast the return value of `GetObject()` (which happens to be; **`TObject*`** in this case) before requesting the `GetPx()` member; functions. 45. **`tree->Draw(""This->GetReadEntry()"");`**. You can refer to the tree (or chain) containing the data by using the; string '`This`'. You can also call any **`TTree`** methods. Next example; will display the name of the first '`user info`' object:. `tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");`. 46. **`tree->Draw(""mybr.mystring"");`**. **`TString`** and `std::string` object are plotted directly. The example; 45 draws the same results - i.e. an histogram whose labels are the; string value of '`mystring`':. `tree->Draw(""mybr.mystring.c_str()"");`. or. `tree->Draw(""mybr.mytstring.Data()"");`. 47. **`tree->Draw(""myTimeStamp"");`**. You can plot plot objects of any class which has either `AsDouble` or; `AsStrin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:92697,extend,extended,92697,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['extend'],['extended']
Modifiability,". ; Networking. NET; ; TWebFile. Several pptimizations in TWebFile improving performance especially for TTree::Map() by about 35%. This has been achieved with a better caching strategy for request strings (especially avoiding to recalculate the auth base64 encoding), and with a drastic optimization in reading the response headers.; Fixes in the counting of the bytes read. TWebSystem. New implementation of TSystem allowing to use TSystem::AccessPathName() and GetPathInfo() to check if a web file exists and to get its size. Directory browsing is not available yet. NETX; ; TXNetFile. Several fixes and optimisations, mainly in the use of the cache; Fix an offset issue affecting the use of the cache with files in archives. TXNetSystem. A few optimizations in the use of retry mechanism, path locality checks, file online checks. XROOTD. Import a new version of XROOTD (20091202-0509); ; Fixes in bulk prepare and sync readv operations; Add support for 'make install' / 'make uninstall' and; other improvements in configure.classic; Several improvements / fixes:; ; reduced memory and CPU consumption;; extreme cp optimizations;; windows porting; new cache policies on the client side; new listing features implemented recently in the 'cns' module.; optimizations in cmsd and cnsd (performance improvements); support for openssl 1.0.0 (required by Fedora 12). Support for if/else if/else/fi constructs; Several portability fixes; ; Support 32-bit builds with icc on 64-bit platforms; Improved detection of libreadline and lib(n)curses. Increase the flexibility for configuring with an external xrootd; ; Add standard switches to disentangle lib and inc dirs;       --with-xrootd-incdir=<path_to dir_containing_XrdVersion.hh>;       --with-xrootd-libdir=<path_to_dir_containing_xrootd_plugins_and_libs>; ; When; passing a global xrootd dir with --with-xrootd, check both; src/XrdVersion.hh and include/xrootd/XrdVersion.hh so that both build; and install distributions are supported. Fix a problem ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v526/index.html:1018,config,configure,1018,net/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v526/index.html,1,['config'],['configure']
Modifiability,". ; Proof. New functionality. TProofMgr. Add support for the following functionality:. sandbox file listing and browsing; sandbox file removal; file upload, download. TProofDraw. Allow to set a color, size, size, width for lines,; area, markers; the attributes are transmitted via the input list and; automatically derived from the ones of the chain. Support automatic creation of a dataset out of files; created on the worker nodes by worker processes. The implementation is; an extension of the functionality of the class TProofOutputFile used; for merging via file.; Add the possibility to enable/disable the tree cache and; to change its size on per-query base; two new parameters are available:. PROOF_UseTreeCache   ; Int_t       ; Enable (0) or Disable (1) the tree cache (default 1); PROOF_CacheSize      ; Long64_t     Cache size in bytes; (default 10000000). Examples:;        ; a) to disable the cache for the next run enter:;                                 ; proof->SetParameter(""PROOF_UseTreeCache"", 0);        ; b) to set the cache size to 20M;                                 ; proof->SetParameter(""PROOF_CacheSize"", 20000000);  Add the parameter; PROOF_UseParallelUnzip to toggle the use of the parallel unzip; (default off for now); to enable it add the following call;            ;            ;        ;  proof->SetParameter(""PROOF_UseParallelUnzip"", 1).  Add the possibility to give indications about; the number of workers at startup.;  E.g.;        1. To; start max 5 workers;             ; TProof::Open(""<master>"",""workers=5"");        2. To; start max 2 workers per physical machine;             ; TProof::Open(""<master>"",""workers=2x"");      This is useful in general when; running tests (equivalent but quicker then full startup;      followed by; TProof::SetParallel(n) or TProof::DeactivateWorker(...)).; Add support for the worker SysInfo_t in TSlaveInfo; (obtained via TProof::GetListOfSlaveInfos()); Add new submerger functionality to speed up the merging; phase. At the e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:87,sandbox,sandbox,87,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,2,['sandbox'],['sandbox']
Modifiability,". All GDB tests have; passed, except one that turned out to be an invalid test case by DWARF Version 5; rules. The code in GDB actually became simpler as all evaluation is done on a; single stack and there was no longer a need to maintain a separate structure for; the location description results. This gives confidence in backwards; compatibility. See :ref:`amdgpu-dwarf-expressions` and nested sections. This extension is separately described at *Allow Location Descriptions on the; DWARF Expression Stack* [:ref:`AMDGPU-DWARF-LOC; <amdgpu-dwarf-AMDGPU-DWARF-LOC>`]. 2.2 Generalize CFI to Allow Any Location Description Kind; ---------------------------------------------------------. CFI describes restoring callee saved registers that are spilled. Currently CFI; only allows a location description that is a register, memory address, or; implicit location description. AMDGPU optimized code may spill scalar registers; into portions of vector registers. This requires extending CFI to allow any; location description kind to be supported. See :ref:`amdgpu-dwarf-call-frame-information`. 2.3 Generalize DWARF Operation Expressions to Support Multiple Places; ---------------------------------------------------------------------. In DWARF Version 5 a location description is defined as a single location; description or a location list. A location list is defined as either; effectively an undefined location description or as one or more single; location descriptions to describe an object with multiple places. With; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack`,; the ``DW_OP_push_object_address`` and ``DW_OP_call*`` operations can put a; location description on the stack. Furthermore, debugger information entry; attributes such as ``DW_AT_data_member_location``, ``DW_AT_use_location``, and; ``DW_AT_vtable_elem_location`` are defined as pushing a location description on; the expression stack before evaluating the expression. DWARF Version 5 only allows the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:8538,extend,extending,8538,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extending']
Modifiability,". All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which are much harder to track down and fix.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8659,config,configuration,8659,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,3,['config'],"['configuration', 'configure']"
Modifiability,". Alpha Checks. Alpha Checkers; Experimental checkers in addition to the ; Default Checkers. These are checkers with known issues or limitations that; keep them from being on by default. They are likely to have false positives.; Bug reports are welcome but will likely not be investigated for some time.; Patches welcome!. Clone Alpha Checkers; Core Alpha Checkers; C++ Alpha Checkers; LLVM Checkers; Variable Argument Alpha Checkers; Dead Code Alpha Checkers; OS X Alpha Checkers; Security Alpha Checkers; Unix Alpha Checkers; Non-determinism Alpha Checkers. Clone Alpha Checkers. Name, DescriptionExample. alpha.clone.CloneChecker; (C, C++, ObjC); Reports similar pieces of code. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1000,variab,variables,1000,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['variab'],['variables']
Modifiability,". An optimal (i.e. giving the; highest speed-up) number can be calculated analytically under simple; assumptions.; Merging via submergers is by default disabled. To enable it, with the; optimal number of sub-mergers, one should set the integer parameter; 'PROOF_UseMergers' to 0, i.e.                     ; proof->SetParameter(""PROOF_UseMergers"", 0). To force S sub-mergers (regardless of the optimal number) do.                     ; proof->SetParameter(""PROOF_UseMergers"", S). The new functionality can be tested in tutorials by adding the argument; 'submergers' to runProof, e.g. .        ;        ;      root [0] .L; tutorials/proof/runProof.C+ ;        ;        ;      root [1]; runProof(""simple(nhist=10000,submergers)"") . (see the top of tutorials/proof/runProof.C for additional options). A test for the submerger functionality has also been added to; test/stressProof.cxx .; In PROOF-Lite, add the possibility for the administrator; to control the number of workers. This is done using; the rootrc variable ProofLite.MaxWorkers, which is read out of; /etc/system.rootrc and cannot be overwritten by users. Setting the; value to 0 disables PROOF-Lite. Improvements. TFileMerger. A few improvements on the way to make TFileMerger and; hadd totally equivalent:. import from hadd an optimization of key hashing; import from hadd a better way to invoke Merge for; generic objects; add option to merge histograms in one go, instead of; one-by-one as for generic objects (this option is not yet supported by; hadd). TProofOutputFile. Add support for the placeholder <file>; the definition of the outputfile. This allows to have complete URL and; to pass options to TFile::Open. XrdProofd plugin. Add automatically the line 'Path.ForceRemote 1' to the; session rootrc file if the ROOT version is < 5.24/00 ; this acts; as a workaround for the wrong TTreeCache initialization at the; transition between local and remote files fixed in 5.24/00 . Enable mass storage domain settings when working with; T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:3378,variab,variable,3378,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,1,['variab'],['variable']
Modifiability,". Atomic Memory Ordering Constraints; ----------------------------------. Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`,; :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`,; :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take; ordering parameters that determine which other atomic instructions on; the same address they *synchronize with*. These semantics implement; the Java or C++ memory models; if these descriptions aren't precise; enough, check those specs (see spec references in the; :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions; treat these orderings somewhat differently since they don't take an; address. See that instruction's documentation for details. For a simpler introduction to the ordering constraints, see the; :doc:`Atomics`. ``unordered``; The set of values that can be read is governed by the happens-before; partial order. A value cannot be read unless some operation wrote; it. This is intended to provide a guarantee strong enough to model; Java's non-volatile shared variables. This ordering cannot be; specified for read-modify-write operations; it is not strong enough; to make them atomic in any interesting way.; ``monotonic``; In addition to the guarantees of ``unordered``, there is a single; total order for modifications by ``monotonic`` operations on each; address. All modification orders must be compatible with the; happens-before order. There is no guarantee that the modification; orders can be combined to a global total order for the whole program; (and this often will not be possible). The read in an atomic; read-modify-write operation (:ref:`cmpxchg <i_cmpxchg>` and; :ref:`atomicrmw <i_atomicrmw>`) reads the value in the modification; order immediately before the value it writes. If one atomic read; happens before another atomic read of the same address, the later; read must see the same value or a later value in the address's; modification order. This disallows reordering of ``monotonic`` (or; stro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:153247,variab,variables,153247,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,". Build System; MacOS X. On MacOS X move to a more secure way of building. We will now always use; the --enable-explicitlink ./configure option which will cause a shared lib; or executable to be linked with all its dependent libraries. The OSX linker; is quite good and processing this extended set of libraries for each link; does cost only 3s extra time for all 100+ shared libs (13s instead of 10s).; Not much for the extra security. In addition we went back to the default; linker option ""-undefined error"", so you will get an error if symbols; are unresolved. Shared libs are also linked with the option; ""-Wl,-dead_strip_dylibs"" which tells the linker to remove any shared lib; which is not used to resolve any symbols (this should; solve the long standing issue of ACliC linking all previously created; shared libs even when not needed). Linux. Make --enable-explictlink the default on linux too (was already the case for:; macosx, freebsd, openbsd, aix and win32). This adds some extra time to; the link stage, which can be recuperated by using the newer, much faster,; gold linker. In addition we added the linker option ""-Wl,--no-undefined"",; so you will get an error if symbols are unresolved.; Explicit linking is required by newer distributions, like Ubuntu 11.10,; that require all dependent shared libs to be specified when linking. They; also have default options set to dead strip shared libs that don't resolve; any symbols (equivalent to the MacOS X build changes described above). Core Libraries; TClonesArray. Introduce TClonesArray::ConstructedAt which; always returns an already constructed object. If the slot is being used for the; first time, it calls the default constructor otherwise it returns the object as; is (unless a string is passed as the 2nd argument to the function in which case,; it also calls Clear(second_argument) on the object).; This allows to replace code like:. for (int i = 0; i < ev->Ntracks; i++) {; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:127,config,configure,127,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,2,"['config', 'extend']","['configure', 'extended']"
Modifiability,". Clang C Language Family Frontend for LLVM. Clang: a C language family frontend for LLVM. The Clang project provides a language front-end and tooling infrastructure; for languages in the C language family (C, C++, Objective C/C++, OpenCL,; CUDA, and RenderScript) for the LLVM; project. Both a GCC-compatible compiler driver (clang) and an; MSVC-compatible compiler driver (clang-cl.exe) are provided. You; can get and build the source today. Features and Goals. Some of the goals for the project include the following:; End-User Features:. Fast compiles and low memory use; Expressive diagnostics (examples); GCC & MSVC compatibility. Utility and; Applications:. Modular library based architecture; Support diverse clients (refactoring, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:726,refactor,refactoring,726,interpreter/llvm-project/clang/www/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html,1,['refactor'],['refactoring']
Modifiability,". Cling. Build Instructions; This page is shows how to download and build the project cling as a standalone C++ interpreter in few steps..; Build script . You can download and run this build script. Building with CMake ; Prerequisites; See Getting Started with the LLVM System - Requirements. Note also that Python is needed for running the test suite.; . And extra for Windows; cmake - http://www.cmake.org/cmake/resources/software.html; Python - http://www.python.org/download/; GnuWin32 Tools - http://getgnuwin32.sourceforge.net/; Visual Studio - VS Express should work as well. Start by checking out llvm, clang and cling: . git clone http://root.cern.ch/git/llvm.git src; cd src; git checkout cling-patches; cd tools; git clone http://root.cern.ch/git/cling.git; git clone http://root.cern.ch/git/clang.git; cd clang; git checkout cling-patches. Now follow the procedure described at the clang web page for ./configure --enable-cxx11; make- or CMake-based build instructions. ; Don't forget to make install. You will get a binary called cling: that's your interactive C++ interpreter!. Then use CMake to configure & build cling: . mkdir obj; cd obj; cmake -DCMAKE_INSTALL_PREFIX=[Install Path] ..\src; cmake --build . --config [Release/Debug] --target cling. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html:915,config,configure,915,interpreter/cling/www/build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/build.html,3,['config'],"['config', 'configure']"
Modifiability,". Cling. Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html:295,extend,extend,295,interpreter/cling/www/use.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/use.html,1,['extend'],['extend']
Modifiability,". CodeChecker: running the analyzer from the command line. CodeChecker: running the analyzer from the command line; Basic Usage. Install CodeChecker as described here: CodeChecker Install Guide. Create a compilation database. If you use cmake then pass the -DCMAKE_EXPORT_COMPILE_COMMANDS=1 parameter to cmake. Cmake will create a compile_commands.json file.; If you have a Makefile based or similar build system then you can log the build commands with the help of CodeChecker:. make clean; CodeChecker log -b ""make"" -o compile_commands.json. Analyze your project. CodeChecker analyze compile_commands.json -o ./reports. View the analysis results.; Print the detailed results in the command line:. CodeChecker parse --print-steps ./reports. Or view the detailed results in a browser:. CodeChecker parse ./reports -e html -o ./reports_html; firefox ./reports_html/index.html. Optional: store the analysis results in a DB. mkdir ./ws; CodeChecker server -w ./ws -v 8555 &; CodeChecker store ./reports --name my-project --url http://localhost:8555/Default. Optional: manage (categorize, suppress) the results in your web browser:. firefox http://localhost:8555/Default. Detailed Usage. For extended documentation please refer to the official site of CodeChecker!. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/codechecker.html:1188,extend,extended,1188,interpreter/llvm-project/clang/www/analyzer/codechecker.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/codechecker.html,1,['extend'],['extended']
Modifiability,". Core Libraries; ROOT Error Handlers; There is a new rootrc variable which allows to control the; installation of the ROOT error handlers. By default the handlers; are activated:. Root.ErrorHandlers: 1. but setting the value to 0 result in no error handlers being installed; and the originals remaining in place. This can be useful if ROOT is used in; conjunction with other frameworks that already installed their own handlers. TString; TString::Hash() and thus also TMath::Hash() now use MurmurHash3_x64_128; from http://code.google.com/p/smhasher/ which is public domain.; To accelerate the hash in the case of pointers even further, pointers (and same-sized texts) are hashed using a simple bitwise xor.; This dramatically increases the hash performance for long texts, and still by a factor 5 for pointers.; The pointer case is most visible for certain I/O operations (TExMap).; TColor; Add the method SetAlpha() to set the alpha value (transparency; level) for an existing color. TStyle. The default font set by gStyle->SetLegendFont() was ignored. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v534/index.html:61,variab,variable,61,core/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v534/index.html,1,['variab'],['variable']
Modifiability,". Core. New class TBase64 providing Base64 encoding and decoding. Base64 encoded; messages are typically used in authentication protocols and to pack binary; data in HTTP or mail messages. New method in TSystem:. TString TSystem::GetFromPipe(const char *command). which executes ""command"" in the shell and returns the output in the TString.; Multi-line output is separated by \n's. Add proper support for Microsoft Visual C++ 9.0; Add support for 'unix' sockets on Windows.; New method TString::Clear() to reset the string but not to resize it to the default; (small) size. Useful when the string was pre-allocated to a large size and; has to be re-used.; Insure that ROOT's autoloader is always enabled whenever loading rootmap files.; Add function void TAttAxis::SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim); ; Enable autoloading of typedef.; The statically linked roota executable and libRoot.a are currently; only supported on Linux platforms. We hope to extend this to MacOS X; soon. Meta. Add new macro ClassDefNV (ClassDef Non Virtual) which does not define any virtual function. ClassDef does define IsA, Streamer and ShowMember as virtual. This should be used only in classes that are never inherited from!; Improve performance of TClass::GetMethod (and friends). ACLiC. Implement TClassEdit::InsertStd() which puts ""std::"" in front of all STL classes.; The generated library now always checks with which version of ROOT the library was build and rebuilt the library if the running version of ROOT is different.; Add support for '+' character embedded in the script's name or directory name.; The dependency tracking file (script_C.d) is now always created when the library is built.; The dependency tracking file now records with which version of ROOT the library was built and the library is now rebuilt if it is loaded in a different version of ROOT. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v524/index.html:972,extend,extend,972,core/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v524/index.html,2,"['extend', 'inherit']","['extend', 'inherited']"
Modifiability,". Core. The ROOT source directory has been drastically reorganized and simplified.; Each source directory containing the code for a single library or plugin,; were all in the same top level directory, without logical grouping.; This made it difficult to see which libraries were related and belonged; together. In the new structure we've added a set of meta directories; that are used to group the sources of related libraries, and that also; reflects the ROOT team work package structure.; Note, the name and number of libraries has not been changed.; This new structure also facilitates the maintaining of the release notes; and other documentation items per meta package. On Linux, MacOS X and Windows, there is no need anymore to define the; environment variable ROOTSYS. Internally ROOTSYS is set depending on the; location of the ROOT libraries. ROOTSYS was never needed when ROOT was; configured using --prefix. On MacOS X when configure'ing with --enable-rpath (and not specifying; --prefix) the installation does not need (DY)LD_LIBRARY_PATH to be set; anymore. The installation is completely relocatable. The (DY)LD_LIBRARY_PATH; is determined relative to the location of the root executable. On Windows .root files are now associated with the most recently executed; ROOT installation, i.e. run ROOT once and .root files open with ROOT. Class TMessageHandler derives now from TQObject and does emit signals.; This allows for easier usage of this class. In this release xrootd and libAfterImage are managed in Subversion; via so called ""vendor branches"". This is completely transparent; except for people who do directly use svn. You will get the message:. $ svn up; svn: Failed to add directory 'xrootd/src/xrootd': object of the same name already exists; $ rm -rf xrootd/src/xrootd; $ svn up; svn: Failed to add directory 'asimage/src/libAfterImage': object of the same name already exists; $ rm -rf asimage/src/libAfterImage; $ svn up. Port to gcc 4.3.1. This version of gcc is much stric",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html:150,plugin,plugin,150,core/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html,4,"['config', 'plugin', 'variab']","['configure', 'configured', 'plugin', 'variable']"
Modifiability,". Core; Build system and Platform support. The build system has been extended to support out-of-source builds.; This means you can build different sets of binaries from one source tree, like:. mkdir root-debug; cd root-debug; ../root/configure --build=debug. The build system now supports cross compilation, where typically you need tools; like rootcint, rootmap, etc, to be compiled on the build platform to be able; to generate dictionaries for the target platform. ROOT has been ported to iOS. This port required the above mentioned; changes in the build system. To build ROOT for the iPhone/iPad sumilator do:. ./configure iossim; make. To build a native iOS armv7 version do:. ./configure ios; make. Both builds create a libRoot.a that can be used to create ROOT based iOS apps; (iOS does not allow apps to load non-system dynamic libraries at run time).; Some sample Xcode projects using ROOT will soon be made available. Base. Change TTime data member from Long_t to Long64_t. On 32-bit systems the; Long_t is 32-bits and too small to keep the time in milliseconds since the ROOT EPOCH (1-1-1995). Added new operators:. operator long long(); operator unsigned long long(). The existing operators long and unsigned long on 32-bit machines return; an error in case the stored time is larger then 32-bit and truncation; occurs (like was always the case till now, but silently). New method ExitOnException() which allows to set the behaviour of; TApplication in case of an exception (sigsegv, sigbus, sigill, sigfpe).; The default is to trap the signal and continue with the event loop,; using this method one can specify to exit with the signal number to the; shell, or to abort() which in addition generates a core dump. New command line argument -x which forces ROOT to exit on an exception.; Add TSystem::AddDynamicPath. Build. New option '-t' for rmkdepend to allow the caller to fully specify the name to be used as a target; This supersedes the name calculated from the input file name and t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html:69,extend,extended,69,core/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html,4,"['config', 'extend']","['configure', 'extended']"
Modifiability,". Currently, clang is divided into the following libraries and tool:. libsupport - Basic support library, from LLVM.; libsystem - System abstraction library, from LLVM.; libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction,; file system caching for input source files.; libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and manipulating the; AST (visitors, pretty printers, etc).; liblex - Lexing and preprocessing, identifier hash table, pragma; handling, tokens, and macro expansion.; libparse - Parsing. This library invokes coarse-grained 'Actions'; provided by the client (e.g. libsema builds ASTs) but knows nothing about; ASTs or other client-specific data structures.; libsema - Semantic Analysis. This provides a set of parser actions; to build a standardized AST for programs.; libcodegen - Lower the AST to LLVM IR for optimization & code; generation.; librewrite - Editing of text buffers (important for code rewriting; transformation, like refactoring).; libanalysis - Static analysis support.; clang - A driver program, client of the libraries at various; levels. As an example of the power of this library based design.... If you wanted to; build a preprocessor, you would take the Basic and Lexer libraries. If you want; an indexer, you would take the previous two and add the Parser library and; some actions for indexing. If you want a refactoring, static analysis, or; source-to-source compiler tool, you would then add the AST building and; semantic analyzer libraries.; For more information about the low-level implementation details of the; various clang libraries, please see the ; clang Internals Manual. Support Diverse Clients. Clang is designed and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been signi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:5729,refactor,refactoring,5729,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['refactor'],['refactoring']
Modifiability,". FAQ and How to Deal with Common False Positives. FAQ and How to Deal with Common False Positives. How do I tell the analyzer that I do not want the bug being; reported here since my custom error handler will safely end the execution before; the bug is reached?; The analyzer reports a null dereference, but I know that the; pointer is never null. How can I tell the analyzer that a pointer can never be; null?; How do I tell the static analyzer that I don't care about a specific dead store?; How do I tell the static analyzer that I don't care about a specific unused instance variable in Objective C?; How do I tell the static analyzer that I don't care about a specific unlocalized string?; How do I tell the analyzer that my instance variable does not need to be released in -dealloc under Manual Retain/Release?; How do I decide whether a method's return type should be _Nullable or _Nonnull?; How do I tell the analyzer that I am intentionally violating nullability?; The analyzer assumes that a loop body is never entered. How can I tell it that the loop body will be entered at least once?; How can I suppress a specific analyzer warning?; How can I selectively exclude code the analyzer examines?. Q: How do I tell the analyzer that I do not want the bug being; reported here since my custom error handler will safely end the execution before; the bug is reached?. You can tell the analyzer that this path is unreachable by teaching it about your custom assertion handlers. For example, you can modify the code segment as following. void customAssert() __attribute__((analyzer_noreturn));; int foo(int *b) {; if (!b); customAssert();; return *b;; }; Q: The analyzer reports a null dereference, but I know that the; pointer is never null. How can I tell the analyzer that a pointer can never be; null?. The reason the analyzer often thinks that a pointer can be null is because the preceding code checked compared it against null. So if you are absolutely sure that it cannot be null, remove",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html:580,variab,variable,580,interpreter/llvm-project/clang/www/analyzer/faq.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html,2,['variab'],['variable']
Modifiability,". For example,. .. code-block:: c++. PassBuilder PB;; PB.registerPipelineStartEPCallback([&](ModulePassManager &MPM,; PassBuilder::OptimizationLevel Level) {; MPM.addPass(FooPass());; };. will add ``FooPass`` near the very beginning of the pipeline for pass; managers created by that ``PassBuilder``. See the documentation for; ``PassBuilder`` for the various places that passes can be added. If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it; will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the; backend to inject passes into the pipeline. Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly; sanitizer) passes to various parts of the pipeline.; ``AMDGPUTargetMachine::registerPassBuilderCallbacks()`` is an example of a; backend adding passes to various parts of the pipeline. Pass plugins can also add passes into default pipelines. Different tools have; different ways of loading dynamic pass plugins. For example, ``opt; -load-pass-plugin=path/to/plugin.so`` loads a pass plugin into ``opt``. For; information on writing a pass plugin, see :doc:`WritingAnLLVMNewPMPass`. Using Analyses; ==============. LLVM provides many analyses that passes can use, such as a dominator tree.; Calculating these can be expensive, so the new pass manager has; infrastructure to cache analyses and reuse them when possible. When a pass runs on some IR, it also receives an analysis manager which it can; query for analyses. Querying for an analysis will cause the manager to check if; it has already computed the result for the requested IR. If it already has and; the result is still valid, it will return that. Otherwise it will construct a; new result by calling the analysis's ``run()`` method, cache it, and return it.; You can also ask the analysis manager to only return an analysis if it's; already cached. The analysis manager only provides analysis results for the same IR type as; what the pass runs on. For example, a function pass ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:6628,plugin,plugin,6628,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,2,['plugin'],['plugin']
Modifiability,". Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12071,config,configuration,12071,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['config'],['configuration']
Modifiability,". GUI; New Classes: TGSplitFrame, TGShapedFrame, TGEventHandler; These three classes have been primarily developed to be used in EVE.; For an example of how to use them, see tutorials/eve/SplitGLView.C (this macro is used as a plugin by tutorials/eve/alice_esd_split.C). TGSplitFrame is a horizontally or vertically splittable composite frame. Once split, each part will contain a new TGSplitFrame, separated by a TGSplitter.; TGShapedFrame is a TGCompositeFrame on which a custom shape is applied, starting from a picture file, by taking its transparency mask, and then applying the picture as background.; TGEventHandler is a Base Event Handler class allowing to delegate event handling (a base class for GL event handlers). TGListTree. TGListTreeItem is now a base class and TGListTreeItemStd is the standard implementation (modification required by EVE).; Switched the icon and checkbox position in TGListTreeItem.; Added custom user control flags, with their getters and setters and three new signal methods (required by EVE). All these were implemented for better control of the TGListTree behavior.; ; fUserControlled is a flag to take over the control; fEventHandled is a flag to tell TGListTree that the current event has been processed by user.; ; MouseOver(TGListTreeItem *entry); MouseOver(TGListTreeItem *entry, UInt_t mask); Clicked(TGListTreeItem *entry, Int_t btn, UInt_t mask, Int_t x, Int_t y). The new DrawOutline() method draws a colored outline around a list tree item following the mouse position.; Implemented correct keyboard navigation.; Improvements for list trees containing a large number of items (i.e. one million). TGTab. Added a new signal method Removed(Int_t id) to notify when a tab was removed. TGListBox. Fixed flickering problem on Windows. TGDockableFrame. Introduced the fFixedSize option, to let user choose if the undocked frame may; be resized or not. Keep the (fixed) original docked frame size when undocked; (i.e. for menus and toolbars). TGShutter. Two h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v520/index.html:227,plugin,plugin,227,gui/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v520/index.html,1,['plugin'],['plugin']
Modifiability,". GUI; New Classes: TRecorder TGRecorder; TRecorder classes provide interface for recording and replaying events in ROOT.; Recorded events are:; Commands typed by user in command line (e.g. 'new TCanvas'); GUI events (mouse movement, button clicks, ...); All the recorded events from one session are stored in one TFile and can be replayed again anytime.; Modifications in TRootCanvas menu:; Renamed 'Inspect' menu title to 'Tools'; Added 'Event Recorder' menu entry. Here is a screenshot of TGRecorder (GUI interface of the recorder):. New Class: TGPack; New Container class for vertical and horizontal grouping of frames.; It enforces a predictable resizing behaviour on children.; For an example of how to use it, see tutorials/eve/pack.C. TRootBrowser. Make the default url for the HTML plugin of TRootBrowser configurable via rootrc. TGTab. Added a 'Close Tab' icon in TGTabElement, allowing to close a tab element, and emitting a CloseTab(Int_t id) signal. The icon is active only on the actually activated tab.; Implement CloseTab slot usage in TRootBrowser and in TGRootIDE. TGTextEditor. Allow to execute a macro without having to save it first. TGSplitFrame. Added a new signal method Docked(TGFrame*) to notify when a embedded frame has been docked.; Added a new signal method Undocked(TGFrame*) to notify when a embedded frame has been undocked.; Added a new getter method GetUndocked() returning a pointer on undocked frame, if any. TGToolTip. Added new constructor with global x, y position.; If neither fWindow nor fPad are set use global fX, fY that was passed from outside. TGSplitter. Added option to handle frame resizing externally. TGView. Added a protection against possible negative scroll values. TGTextView. Fix bottom line not being properly updated while scrolling.; Solve a problem with vertical slider (avoid negative value when scrolling). TGTextEdit. Fix blinking cursor on some platforms/compilers. TGTextEntry. Added optional parameter 'Bool_t emit' to TGTextEntry::Se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html:791,plugin,plugin,791,gui/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html,2,"['config', 'plugin']","['configurable', 'plugin']"
Modifiability,". Geometry; Improvement of the standard overlap checker. The previous method was checking points on the visual mesh of volume shape against all possible overlapping partners.; The new method checks more points (currently 1000, in future configurable) on the volume outline or surface. This minimizes the number of non-detectable overlap; configurations.; The interface to activate the new checking method is the same as before:; gGeoManager->CheckOverlaps(ovlp);; where ovlp is the overlap tolerance (default 0.01 cm); An example of overlap that was not detected before but is now:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/doc/v522/index.html:237,config,configurable,237,geom/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/doc/v522/index.html,2,['config'],"['configurable', 'configurations']"
Modifiability,". Graphical Output; TASImage / libAfterImage. In TImageDump the way the markers 6 and 7 are drawn; (medium dot and big dot) has been changed to make sure they have; the same size as the one on screen.; Changes in libAfterImage (draw.c & draw.h), TASImage.cxx; and TImageDump.cxx in order to produce nice looking; circular (hollow and solid) markers. Previously the line; used to draw hollow circular markers looked very thick and; the solid ones did not look circular.; Remove the global variable named ""dpy"" in libAfterImage. It produced; an error if a user program used that simple variable name. ""dpy""; was a pointer to a ""Display"". PostScript and PDF. Now, a text with size 0 is not drawn in PDF files. An invalid; PDF file is created if a text with size 0 is produced.; The landscape orientation is now correct in pdf files. gv recognizes; the files as ""Landscape"" and the orientation is not upside down; as it was before (seascape).; In PostScript and PDF files the method DrawPS is used to write; a single (x,y) position.; This case was not treated correctly and, because of that, the PS and PDF; files might contain useless attributes settings. That was only a few; bytes more in the file but they were useless. TLegend. When a object is added ""by name"" in a legend, the; TMultiGraph and THStack present in the current pad; are scanned if an object with this name has not been; found in the pad. Previously the graphs and histograms; were hidden in multi-graphs and histogram-stacks when one; tried to add them by name.; New reference guide. TGaxis. In PaintAxis The option ""U"", for unlabeled axis, was not; implemented in case of alphanumeric axis' labels.; On log-scale TGAxis, with labels having lower values than 1 and ticks marks; set to the positive side, alignement issues seem to come up.; The following example shows four TGAxis drawn respectively with the; following options: RG-, RG+, LG-, LG+. For the RG+ and LG+ options,; the 10E-1 and 10E-2 labels were ill-aligned, showing a sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html:488,variab,variable,488,graf2d/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html,2,['variab'],['variable']
Modifiability,". Histogram Libraries; TH1. Improve performances of TH1::Merge in case of histograms with same bin limits. Now an copy of the; initial histogram is not done. These improvements have been applied also in the TH2, TH3 and TProfile's classes.; . TH2. Add a new option ""S"" in FitSlice which performs a sliding merge: merge n consecutive bins along Y accordingly to what value in option Gn is given.; . TProfile2D and TProfile3D. Implement SetBins for variable bin sizes; ; Add support for variable bins in TProjectionXY. TH2Poly. The values set by SetMaximum() and SetMinimum() were not; taken into account by GetMaximum() and GetMinimum().; The Palette and the statistics box were not pickable when TH2Poly was drawn; with option COLZ.; TH2Poly was wrongly picked in the canvas area after a zoom along axis. TEfficiency. list holding the associated functions is created only on demand; default constructor creates two dummy histograms; can now be filled with weights (only Bayesian methods and the normal; approximation are supported) ; update TEfficiency::SavePrimitive to store also the set bits. TGraphAsymmErrors. add option to TGraphAsymmErrors::Divide for interpreting the given; histograms as ratio of Poisson means. TMultiGraph. The following macro did not show the x-axis in TimeDisplay mode. The; mg->GetYaxis()->UnZoom(); command erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:447,variab,variable,447,hist/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html,2,['variab'],['variable']
Modifiability,". However, it; would be an unusual collector that violated it. The use of these intrinsics is naturally optional if the target GC does not; require the corresponding barrier. The GC strategy used with such a collector; should replace the intrinsic calls with the corresponding ``load`` or; ``store`` instruction if they are used. One known deficiency with the current design is that the barrier intrinsics do; not include the size or alignment of the underlying operation performed. It is; currently assumed that the operation is of pointer size and the alignment is; assumed to be the target machine's default alignment. Write barrier: ``llvm.gcwrite``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.gcwrite(i8* %value, i8* %object, i8** %derived). For write barriers, LLVM provides the ``llvm.gcwrite`` intrinsic function. It; has exactly the same semantics as a non-volatile ``store`` to the derived; pointer (the third argument). The exact code generated is specified by the; Function's selected :ref:`GC strategy <plugin>`. Many important algorithms require write barriers, including generational and; concurrent collectors. Additionally, write barriers could be used to implement; reference counting. Read barrier: ``llvm.gcread``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. i8* @llvm.gcread(i8* %object, i8** %derived). For read barriers, LLVM provides the ``llvm.gcread`` intrinsic function. It has; exactly the same semantics as a non-volatile ``load`` from the derived pointer; (the second argument). The exact code generated is specified by the Function's; selected :ref:`GC strategy <plugin>`. Read barriers are needed by fewer algorithms than write barriers, and may have a; greater performance impact since pointer reads are more frequent than writes. .. _plugin:. .. _builtin-gc-strategies:. Built In GC Strategies; ======================. LLVM includes built in support for several varieties of garbage collectors. The Shadow Stack GC; -------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:15050,plugin,plugin,15050,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,". I/O Libraries; LZMA Compression and compression Level setting. ROOT I/O now support the LZMA compression algorithm to compress data in; addition to the ZLIB compression algorithm.; LZMA compression typically results in smaller files, but takes more; CPU time to compress data. To use the new feature, the external XZ; package must be installed when ROOT is configured and built:. Download 5.0.3 from here tukaani.org; and make sure to configure with fPIC:; ./configure CFLAGS='-fPIC'. Then the client C++ code must call routines to explicitly request LZMA; compression. ZLIB compression is still the default. Setting the Compression Level and Algorithm. There are three equivalent ways to set the compression level and; algorithm. For example, to set the compression to the LZMA algorithm; and compression level 5. TFile f(filename, option, title);; f.SetCompressionSettings(ROOT::CompressionSettings(ROOT::kLZMA, 5));. TFile f(filename, option, title, ROOT::CompressionSettings(ROOT::kLZMA, 5));. TFile f(filename, option, title);; f.SetCompressionAlgorithm(ROOT::kLZMA);; f.SetCompressionLevel(5);. These methods work for TFile, TBranch, TMessage, TSocket, and TBufferXML.; The compression algorithm and level settings only affect compression of; data after they have been set. TFile passes its settings to a TTree's branches; only at the time the branches are created. This can be overidden by; explicitly setting the level and algorithm for the branch. These classes; also have the following methods to access the algorithm and level for; compression. Int_t GetCompressionAlgorithm() const;; Int_t GetCompressionLevel() const;; Int_t GetCompressionSettings() const;. If the compression level is set to 0, then no compression will be; done. All of the currently supported algorithms allow the level to be; set to any value from 1 to 9. The higher the level, the larger the; compression factors will be (smaller compressed data size). The; tradeoff is that for higher levels more CPU time is used ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:359,config,configured,359,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,3,['config'],"['configure', 'configured']"
Modifiability,". I/O. Add support for the Chirp filesystem. To configure and build, chirp 3.2.2 must be installed.; When a TFile object is deleted, make sure that CINT also 'removes' any global variables that might point to it.; Fix support for the automatic addition to the current directory (for TTree and TH1 for example) in TKey::Read(TObject*).; In TKey, properly handle error in the I/O routines.; Explicitly check the validity of the zipped buffer before calling R__unzip, this allow for better error recovery.; When double checking whether a checksum difference is sustantial, ignore the std namespace. Use CompareContent also in the case of where; the class is versioned but the 'current' streamerInfo has not yet been built.; Prevent the I/O engine from mistakenly applying schema evolution to the TObject::fBits.; Make sure that when a streamer info of a base class is used to stream memberwise that is always not-optimized. If the StreamerInfo on file; has the same version as the StreamerInfo in memory but the one on file need to be 'not optimized' while the one in memory is not yet built, make; sure it will not be optimized.; Fix the reading of empty collection of object when reading without the library.; If the sequence of actions for streaming member-wise is not created correctly (i.e. where fReadMemberWise was null previously),; we now explicitly issue a Fatal error:. Fatal in <ReadSequence>: The sequence of actions to read AliESDVertex:7 member-wise was not initialized.; aborting. Add new optional parameter maxbuf to TXMLEngine::ParseFile() allowing the specification of the XML file size to be parsed. This fixes issue #78864.; Add function TBuffer::AutoExpand to centralize the automatic buffer extension policy. This enable the ability to tweak it later (for example instead of always doubling the size, increasing by only at most 2Mb or take hints from the number of entries already; in a TBasket).; Migrate the class TFileMerger from the proofplayer library to ROOT I/O library and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html:48,config,configure,48,io/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html,2,"['config', 'variab']","['configure', 'variables']"
Modifiability,". I/O. Fix the order of creation of the TStreamerInfo during the opening of a ROOT file to insure that the CollectionProxy are properly setup.; Fix problem: ""recover warning when opening an empty file; created with TXNetFile"" which was due to a bad check in TFile::Recover; (line TFile.cxx:1561) where the inheritance from TFile should be checked; instead of requiring the name to be TFile.; In TBranch::File, in the case of importing the data directly from; an external TBuffer, remove 80 char limit on reading the class name; Re-enable support for the; rootrc configuration Root.ZipMode. Data Model Evolution. First step in the implemantation of the infrastructure for the new Data Model Evolution Scheme.; This Data Model Evolution is brought to your courtesy of BNL/STAR/ATLAS/Fermi/Cern; Current Capabilities. Assign values to transient data members; Rename classes; Rename data members; Change the shape of the data structures or convert one class; structure to another; Change the meaning of data members; Ability to access the TBuffer directly when needed; Ensure that the objects in collections are handled in the same; way as the ones stored separately; Supported in object-wise, member-wise and split modes. Coming soon. Make things operational also in bare ROOT mode; Ability to transform data before writing; Support for changing the class type of nested object in a split; branch; Support for access to onfile version of nested objects from; within the parent rule. LinkDef rule syntax; Setting a transient member:; #pragma read sourceClass=""ACache"" targetClass=""ACache"" source=""""; version=""[1-]"" target=""zcalc"" \; code=""{ zcalc = false; }"". Setting a new member from 2 removed members:. #pragma read sourceClass=""ACache"" targetClass=""ACache""; source=""int x; int y; char c"" version=""[8]"" target=""z"" \; code=""{ z = onfile.x*1000 + onfile.y*10; }"". Renaming a class:. #pragma read sourceClass=""ACache"" version=""[8]""; targetClass=""Axis"" \; source=""int x; int y;"" target=""z"" \; code=""{ z = o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v522/index.html:306,inherit,inheritance,306,io/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v522/index.html,2,"['config', 'inherit']","['configuration', 'inheritance']"
Modifiability,". I/O. Implement proxy support in TWebFile. The proxy URL can be sprcified either; via TWebFile::SetProxy() or via the shell variable http_proxy, as is being; used by wget, e.g.:; export http_proxy=http://pcsalo.cern.ch:3128; To bypass the proxy, the TWebFile ctor (or via TFile::Open()) supports the; option ""NOPROXY"".; Add support for streaming std::bitset STL containers; Extend the checks done in case of a StreamerInfo checksum mismatch to; avoid spurrious failures (for example because of the various possible; type names for STL containers) and to report details on the nature of; the mismatch: explicit list missing base classese, missing data members; or the actual differences in type or comments.; For example:. Warning in : The following data member of the on-file layout version 2 of class 'Tdata' differs from the in-memory layout version 2:; double mydouble; //; vs; double mydouble_two; //; Warning in : The following data member of the in-memory layout version 2 of class 'Tdata' is missing from the on-file layout version 2:; int more; //; Warning in : The following data member of the in-memory layout version 2 of class 'Tdata' is missing from the on-file layout version 2:; int three; //. Upgrade MakeProject to be able to handle ROOT files created by for ATLAS.; Allow user to provide a custom reallocator when the TBuffer is being passed; memory. If the TBuffer does not own the memory __and__ no custom memory; reallocator has been set, a Fatal error will be issued:; Fatal in : Failed to expand the data buffer because TBuffer does not own it and no custom memory reallocator was provided.; Re-allow reading empty vector< long double >, however long double is still not supported.; Upgrade TSQLFile to properly work with MySQL on MacOS.; Update to the CollectionProxyInfo interface to insure the proper creation of iterator over std containers on all platforms.; In XML and SQL output, use %e format to write float and double:; ; Conversion from float/double to string per def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v524/index.html:125,variab,variable,125,io/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v524/index.html,1,['variab'],['variable']
Modifiability,". I/O. Unset the kIsReferenced bit before cloning an object in order to avoid the (incorrect/unwanted) registration of the clone. Repaired writing Foreign class in XML files. Extend TDirectoryFile so it can now be derived from. In MakeProject; properly test whether a StreamerElement describe a base class (stl container were not handled correctly).; Remove requirement to have '.' in the PATH to execute the build. Add a new optional parameter to TDirectory::Append: replace.; If replace is true (the default is false), the Append will; first remove from the directory any existing object and; print the message:. Replacing existing OldClass: thename (Potential memory leak). Add a new option parameter to TDirectory::CloneObject: 'autoadd'; If autoadd is true (the default), CloneObject will call the; object 'DirectoryAutoAdd' function (if any). In TDirectory::CloneObject add support for multiple inheritance; from TObject where TObject is not the left most base class. Schema Evolution. Fix schema evolution problem in TTree::Draw by extending support in; TStreamerInfo::ReadValueAux to 'converted' numerical types, (; see issue in ROOT forum). When reading more than one TStreamerInfo for the same versioned; class, we now use the highest possible class version as the current; version of the class. Practically, we update the class version; when reading new (higher versioned) StreamerInfo until the Class; is actually used (i.e. TClass::GetClassVersion is call directly; or indirectly). In particular, if a file has several StreamerInfos for the same; versioned class, we will use the highest version number as the; 'current' class version (as opposed to the lowest until now). For backward compatibility TStreamerInfo::BuildCheck compares the checksum of; the on-file StreamerInfo not only to the current value of the class checksum; but also to the checksum calculated using the older algorithms. This patch extends this test to also be done when comparing 2 on-file StreamerInfos. This remo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v520/index.html:901,inherit,inheritance,901,io/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v520/index.html,1,['inherit'],['inheritance']
Modifiability,". I/O; Schema Evolution. Change TExMap hash, key and values from (U)Long_t to (U)Long64_t. This makes TExMap streamable in a portable way. On 64-bit platforms there is; no difference, but on 32-bit platforms all values will now be 64-bit. This fixes a big portability issue with THnSparse which uses TExMap internally; where the versions created on a 32-bit platform could not be read on a 64-bit platform and vice versa.; Avoid reporting I/O error for members of a class that is used only for a transient member; Concrete implementation of TClassGenerator needs to be updated to also avoid the warnings.; Fix the rule lookup based on checksum; Extend support of the schema evolution rules to fixed length array.; Prevent a process abort (due to a call to Fatal) when we are missing the dictionary for (one of) the; content of an STL collection when this collection is 'only' use has a transient member.; Fix the case where the source and target of a rule have the same name.; Avoid using the 'current' StreamerInfo to read an older streamerInfo that is missing (in case of corrupted files). Misc. New TFile plugin for the Hadoop Distributed File System (protocol hdfs:); Unregister stack objects from their TDirectory when the TList tries to delete them.; When streaming a base class without StreamerNVirtual() use an external streamer if it was set.; Many improvement to the I/O run-time performance.; DCache:; Increase readahead size from 8k to 128k and make it settable via DCACHE_RA_BUFFER env var.; dCap client does not ignore ?filetpye=raw and other options, so remove it. The function TFile::GetRelOffset is now public instead of protected.; Corrected the reading of the TFile record of large files.; MakeProject: several updates to improve support for CMS and Atlas data files (add support for auto_ptr, bitset, class name longer than 255 characters, etc.). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v526/index.html:125,portab,portable,125,io/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v526/index.html,3,"['plugin', 'portab']","['plugin', 'portability', 'portable']"
Modifiability,". In addition, any instruction that writes to a stack spill; should have a `MachineMemoryOperand` attached, so that `LiveDebugValues` can; recognise that a slot has been clobbered. ## Target-specific optimisation instrumentation. Optimisations come in two flavours: those that mutate a `MachineInstr` to make; it do something different, and those that create a new instruction to replace; the operation of the old. The former _must_ be instrumented -- the relevant question is whether any; register def in any operand will produce a different value, as a result of the; mutation. If the answer is yes, then there is a risk that a `DBG_INSTR_REF`; instruction referring to that operand will end up assigning the different; value to a variable, presenting the debugging developer with an unexpected; variable value. In such scenarios, call `MachineInstr::dropDebugNumber()` on the; mutated instruction to erase its instruction number. Any `DBG_INSTR_REF`; referring to it will produce an empty variable location instead, that appears; as ""optimised out"" in the debugger. For the latter flavour of optimisation, to increase coverage you should record; an instruction number substitution: a mapping from the old instruction number /; operand pair to new instruction number / operand pair. Consider if we replace; a three-address add instruction with a two-address add:. ```text; %2:gr32 = ADD32rr %0, %1, debug-instr-number 1; ```. becomes. ```text; %2:gr32 = ADD32rr %0(tied-def 0), %1, debug-instr-number 2; ```. With a substitution from ""instruction number 1 operand 0"" to ""instruction number; 2 operand 0"" recorded in the `MachineFunction`. In `LiveDebugValues`,; `DBG_INSTR_REF`s will be mapped through the substitution table to find the most; recent instruction number / operand number of the value it refers to. Use `MachineFunction::substituteDebugValuesForInst` to automatically produce; substitutions between an old and new instruction. It assumes that any operand; that is a def in the old ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:7096,variab,variable,7096,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['variab'],['variable']
Modifiability,". It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:196431,variab,variable,196431,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variable']
Modifiability,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:450,portab,portability,450,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,4,"['portab', 'variab']","['portability', 'variable', 'variables']"
Modifiability,". Math Libraries. MathCore. Various fixes have been applied in the fitting classes:. Fix issue #46006 for normalization of error resulting from fitting a TGraph; Fix a problem in Chi2 calculation in case of overflow; Fix issue #46601 for avoiding crashes when a linear fit fails.; Fix in the FitData classes the bug #45909 occurring when setting a function range outside histogram range; Fix default integration method to be Gauss algorithm of MathCore instead of the GSL method, when libMathmore is not built or when the plug-in manager fails to load it.; Add a protection against negative log when fitting using the Poisson log likelihood function; Improve calculation of derivative in x for fitted function. This fixes some problem observed when fitting using the error on the coordinates.; Fitter class: add new methods for calculating the error matrix after minimization, Fitter::CalculateHessErrors() and for calculating the Minos errors Fitter::CalculateMinosErrors; FitConfig: add in the configuration the possibility to select a sub-set of the parameters for calculating the Minos errors by using the method FitConfig::SetMinosErrors( listOfParameters ). If no list is passed, by default the Minos error will be computed on all parameters.; UnBinData class: add new constructor for creating a unbin data set passing a range to select the data and copy in the internal array; FitResult: the class now stores a map of the Minos error using as key the parameter index. If the Minos error has not been calculated for the parameter, FitResult::LowerError(i) and FitResult::UpperError(i) returns the parabolic error; ; Add a new class, MinimTransformFunction to perform a transformation of the function object to deal with limited and fixed variables.; This class uses the same transformation which are also used inside Minuit, a sin transformation for double bounded variables and a sqrt transformation for single bound variable defined in the class MinimizerVariableTransformation.; These classes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:522,plug-in,plug-in,522,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,2,"['config', 'plug-in']","['configuration', 'plug-in']"
Modifiability,". Math Libraries. MathCore; MathCore includes now classes which were previously contained in libCore, like TMath, TComplex and the TRandom classes. Furthermore, some of the algorithms implemented in the TF1 class have been moved to MathCore. This implies that all other ROOT library using one of these classes, such as libHist, have a direct dependency on the Mathcore library.; Linking with libMathCore is therefore required for running any major ROOT application. It has been added to the list of libraries obtained when doing root-config --libs. N.B.: users building ROOT applications and not using root-config MUST add libMathCore to their list of linking libraries. Together with the libraries merge, many changes have been applied to both TMath and the other mathcore classes.; TMath; A major clean-up and re-structuring has been done for the functions present in TMath. Some functions have been implemented using the STL algorithms, which have better performances in term of CPU time and a template interface has been also added.; Some of the basic special mathematical functions of TMath, like the error function or the gamma and beta functions use now the Cephes implementation from Stephen L. Moshier, which is used as well by the ROOT::Math functions. This implementation has been found to be more accurate and in some cases more efficient in term of CPU time. More detailed information on the new mathematical functions can be found in this presentation from M. Slawinska at a ROOT team meeting. define the functions as template functions instead of having the same re-definition for all the various basic types. This is done for TMath::Mean,TMath::GeomMean, TMath::Median, TMath::KOrdStat; Use STL to implement the following algorithms:; ; TMath::Sort is re-implemented using std::sort.; TMath::BinarySearch is re-implemented using the STL algorithm std::lower_bound. The STL algorithms have been found for these cases to be perform better in term of CPU time. For some other algorithms l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:534,config,config,534,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['config'],['config']
Modifiability,". Math Libraries; MathCore; TMath. Add a new function TMath::Power(double, int) impelmented using std::pow(double,int) which is 100% faster than the; double version. KDTree. New KDTree class from C. Gumpert. which has different splitting rules using the data population. The splitting can; is based on the basket population, but any function of the data can be used. For example, in case of weighted data one can split according to; the basket total weight or the effective entries in the basket. In this way the class can support weighted data; sets. The splitting of the TKDTree class is instead fixed and based on the basket number of entries.; The tree can also be frozen to fix the splitting and behaving like a multi-dim histograms with bins with variables; hyper-volumes.; Auxiliary classes are provided like the node classes or the data point class, which can exists also with a compile timed fixed dimension; for better performances. . Fitter classes. Provide support for weighted likelihood unbinned fits; Provide support for extended likelihood unbinned fits; Provide support for not-extended binned likelihood fits (i.e. multinomial distribution instead of Poisson for bin; contents); In case of binned likelihood fit build a Poisson or (Multinomial) likelihood ratio with the saturated model. So a; constant term is subtracted to the likelihood. The formulae described in the Baker and Cousins; paper (N.I.M. 221 (1984) 437) are now used. The obtained negative likelihood ratio value from the fit and multiplied; by a factor 2 is now asymptotically distributed as a chi square. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v532/index.html:753,variab,variables,753,math/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v532/index.html,3,"['extend', 'variab']","['extended', 'variables']"
Modifiability,". Math Libraries; Mathcore. New interface class ROOT::Math::DistSampler for; generating random number according to a given distribution.; ; The class defines the methods to generate a single number; DistSampler::Sample()or a data sets; DistSampler::Generate(n, data). The data set; generation can be unbinned or binned in the; given range (only equidistant bins are currently supported); Sampling of 1D or multi-dim distributions is supported via; the same interface; Derived classes; implementing this interface are not provided by MathCore but by; other libraries and they can be instantiated using the plugin; manager. Implementations based on Unuran and Foam exist.; The tutorial math/multidimSampling.C is an example on; how to use this class. New class ROOT::Math::GoFTest for goodness of fit; tests of unbinned data; ; The class implements the Kolmogorov-Smirnov and; Anderson-Darling tests for two samples (data vs data ) and; one sample (data vs distribution); For the data vs distribution test, the user can compare using a; predefined distributions (Gaussian, LogNormal or Exponential) or; by passing a user defined PDF or CDF.; Example 1: perform a 2 sample GoF test from two arrays,; sample1[n1] and sample2[n2] containing the data; ; ROOT::Math::GoFTest goftest(n1, sample1, n2, sample2);; double pValueAD = goftest.AndersonDarling2SamplesTest();; double pValueKS = goftest.KolmogorovSmirnov2SamplesTest();; ; The class can return optionally also the test statistics instead of; the p value.; Example 2: perform a 1 sample test with a pre-defined; distribution starting from a data set sample[n]. ROOT::Math::GoFTest goftest(n, sample, ROOT::Math::GoFTest::kGaussian);; double pValueAD = goftest.AndersonDarlingTest();; double pValueKS = goftest.KolmogorovSmirnovTest();; . Example 3: perform a 1 sample test with a user-defined; distribution provided as cdf; ; ROOT::Math::Functor1D cdf_func(&ROOT::Math::landau_cdf);; ROOT::Math::GofTest goftest(n, sample, cdf_func, ROOT::Math::GoFTes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html:605,plugin,plugin,605,math/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html,1,['plugin'],['plugin']
Modifiability,. Misc; A new directory minicern has been introduced. This directory contains; the zebra and hbook files required to build the h2root and g2root utilities.; These small files remove dependencies on the old CERNLIB files.; h2root and g2root as well as the library libHbook are; automatically built when configuring ROOT and a Fortran compiler found in the system.; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/doc/v520/index.html:302,config,configuring,302,misc/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/doc/v520/index.html,1,['config'],['configuring']
Modifiability,". Misc; Quick Look plugin for MacOS X. New Quick Look plugin that allows quick inspection of the content; of a ROOT file. Quick Look is available on MacOS X since version 10.5 (Leopard). To use QL; select an file icon in the Finder and hit the space bar. For all file types; supported by QL you will get a window showing the file content, for file types; not supported you will get a generic window showing some basic file info. The idea of QL is that file content can be shown without the heavy application; startup process. Generating a QL view of a ROOT file depends on the size of the; file, but generally it is a quick operation. Get the binary for the ROOTQL plugin from:. ftp://root.cern.ch/root/ROOTQL.tgz. To install the plugin, after untarring the above file, just drag the bundle; ROOTQL.qlgenerator to /Library/QuickLook (global, i.e. for all users on a; system) or to ~/Library/QuickLook (local, this user only) directory.; You may need to create that folder if it doesn't already exist. To build from source, get it from svn using:. svn co http://root.cern.ch/svn/root/trunk/misc/rootql rootql. Open the ROOTQL project in Xcode and click on ""Build"" (make sure the Active; Build Configuration is set the ""Release""). Copy the resulting; plugin from build/Release to the desired QuickLook directory. SpotLight plugin for MacOS X. This is a Spotlight plugin that allows ROOT files to be indexed by SL.; Once indexed SL can find ROOT files based on the names and titles of the; objects in the files. Spotlight is available on MacOS X since version 10.4 (Tiger). To use SL; select the SL icon on the top right of the menubar and type in a search text. Get the binary for the ROOTSL plugin from:. ftp://root.cern.ch/root/ROOTSL.tgz. To install the plugin, after untarring the above file, just drag the bundle; ROOTSL.mdimporter to /Library/Spotlight (global, i.e. for all users on a; system) or to ~/Library/Spotlight (local, this user only) directory.; You may need to create that folder if it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/doc/v524/index.html:19,plugin,plugin,19,misc/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/doc/v524/index.html,4,['plugin'],['plugin']
Modifiability,". MonteCarlo; TDatabasePDG; The method ReadPDGTable of TDatabasePDG was setting the stable flags for; all particles regardless of their width. TParticlePDG; The value reported in the fLifetime variable of TParticlePDG is in seconds; while in the documentation is was indicated in nanoseconds. pdg_table.txt; Particles with a width greater than 1e-10 have now the stable flag set to 1. TVirtualMC; New functions added in the interface:. For activation of collecting TGeo tracks:; virtual void SetCollectTracks(Bool_t collectTracks);; virtual Bool_t IsCollectTracks() const;. For accessing the normal vector of the crossing volume surface; on the geometry boundary:; virtual Bool_t CurrentBoundaryNormal(Double_t &x, Double_t &y, Double_t &z) const;. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/doc/v528/index.html:193,variab,variable,193,montecarlo/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/doc/v528/index.html,1,['variab'],['variable']
Modifiability,. N657; Unknown. N694; Unknown. N809; Unknown. type-generic math macros in <tgmath.h>; N693; Yes. the long long int type; N601; Yes. increase minimum translation limits; N590; Unknown. additional floating-point characteristics in <float.h>; Unknown; Unknown. remove implicit int. N635; Yes. N692; Yes. N722; Yes. reliable integer division; N617; Yes. universal character names (\u and \U); Unknown; Yes. extended identifiers; N717; Unknown. hexadecimal floating-point constants; N308. Yes. compound literals; N716; Yes. designated initializers; N494; Yes. // comments; N644; Yes. extended integer types and library functions in <inttypes.h> and <stdint.h>; Unknown. Yes. remove implicit function declaration; N636; Yes. preprocessor arithmetic done in intmax_t/uintmax_t; N736; Yes. mixed declarations and code; N740; Yes. new block scopes for selection and iteration statements; Unknown; Unknown. integer constant type rules; N629; Yes. integer promotion rules; N725; Yes. macros with a variable number of arguments; N707; Yes. IEC 60559 support; Unknown; Unknown. trailing comma allowed in enum declaration; Unknown; Yes. inline functions; N741; Yes. boolean type in <stdbool.h>; N815; Yes. idempotent type qualifiers; N505; Yes. empty macro arguments; N570; Unknown. new structure type compatibility (tag compatibility); N522; Unknown. additional predefined macro names; Unknown; Unknown. _Pragma preprocessing operator; N634. Yes. standard pragmas. N631; Unknown. N696; Unknown. __func__ predefined identifier; N611; Yes. va_copy macro; N671; Yes. LIA compatibility annex; N792; No. remove deprecation of aliased array parameters; Unknown; Unknown. conversion of array to pointer not limited to lvalues; Unknown; Unknown. relaxed constraints on aggregate and union initialization; Unknown; Unknown. relaxed restrictions on portable header names; N772; Unknown. return without an expression not permitted in function that returns a value; Unknown; Yes. C11 implementation status; Clang implements a,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:2958,variab,variable,2958,interpreter/llvm-project/clang/www/c_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html,1,['variab'],['variable']
Modifiability,". Networking. Class TWebFile now supports proxies. Set the proxy URL either via; static method:; TWebFile::SetProxy(const char *url);; or via the shell variable http_proxy, like is used for e.g. wget. Class TWebFile now supports the basic authentication (AuthType Basic) scheme.; The user name and password can be specified in the URL like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root. XROOTDNew version 20090610-0430ImprovementsAdd the possibility of using the xrd command line from; batch scriptsAdd support for Adler32 checksum calculation of; a local unix file (including stdin) and file on a remote xrootd data; server.Add support for the so-called Xtreme copy, allowing xrdcp; to read multiple chunks from several servers, in parallel.Add possibility to use a different version of a given C++; compiler or linker (--with-cxx=..., etc)Increase flexibility in configuring openssl and openafs; supportIn GSI authentication, automatize the loading of CRL; the; information; about the URI is looked for either in the dedicated extension on the CA; certificate or from the file ""<CA hash>.crl_url"" and the; file; automatically downloaded and transformed in PEM formatFixesServer sideFix wrong reporting of the refresh option for LocateFix incorrect propagation of selected nodesPrevent potential long duration loop (15 mins) after client disconnectionsAvoid potential deadlocks when trying to remove a node from a clusterCorrect matching of incoming connection with previously dropped connectionCorrect export of cluster identificationCorrectly propagate information about files that could not be stagedPrevent endsess deadlock when parallel streams stall due to large WAN RTTFix infinite wait for primary login that will never; happen if you are a manager without a meta-managerPrevent annoying (but not deadly) infinite loop should a; server go offline that is subject to a locate request display.Client sideBetter handling of errno, especially for parallel streamsAllow the client ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html:152,variab,variable,152,net/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html,2,"['config', 'variab']","['configuring', 'variable']"
Modifiability,". OpenGL; Major changes. GLEW - The OpenGL Extension Wrangler Library - has been added to; facilitate detection of OpenGL version and available extensions at; run-time. This will allow usage of advanced visualization techniques; while still allowing fall-back solutions to be used on systems not; supporting the required functionality. If GLEW and GLEW-devel packages; are detected during configure, the ROOT provided GLEW is not; built. See also:; http://glew.sourceforge.net/. Latest (1.3.3) version of gl2ps has been imported (we had 1.2.6; before). See http://www.geuz.org/gl2ps/; for detailed change-log. New implementation of GL-in-TPad - instead of mixture of GL and; non-GL graphics in a pixmap all pad graphics (2D/3D) is now; done by OpenGL. To make this possible new TVirtualPadPainter,; TPadPainter, TGLPadPainter classes were introduced; and painting operations inside TPad class were modified to; use TVirtualPadPainter instead of TVirtualX.; TVirtualPadPainter is an abstract base class, interface for; drawing 2D primitives and pixmap management. TPadPainter is; a default, non-GL implementation, based on TVirtualX; (gVirtualX). TGLPadPainter is a GL; implementation. Currently, TGLPadPainter does not support; off-screen rendering (support for frame-buffer objects is planned). Current limitations:. The glpad can be saved only as PS now.; Several sub-pads with complex 3d geometry can be slow due to lack; of off-screen rendering which would allow for caching of resulting images. Future directions:. Use frame-buffer objects for off-screen rendering.; Support ""Save as"" png, jpg, pdf, etc.; With GLEW and GL-shading-language, use of hardware anti-aliasing and; shaders is possible. Prototype visualization of 5-dimensional distributions:. New option for TTree::Draw - ""gl5d"", for the case you have 5 and; more dimensional dataset.; Set of iso-surfaces created, 4-th dimension is used to select iso-level.; ""gl5d"" is now very similar to ""gliso"" option, but instead of; filling TH3 o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v524/index.html:389,config,configure,389,graf3d/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v524/index.html,1,['config'],['configure']
Modifiability,". PROOF release notes. PROOF. New functionality. PROOF-Lite2-tier; realization of PROOF intended for multi-core machines; the client; starts directly the workers; no daemon is required. To start a session; just use TProof::Open("""") or TProof::Open(""lite""). From there on; everything should be as in normal PROOF, though some functionality may; not have been ported yet. To start a standard PROOF; session (i.e. via daemons) on the localhost use; TProof::Open(""localhost"").XrdProofd plug-in. Possibility to define the list worker directly in the; xrootd config file (new directive xpd.worker, see Wiki reference pages); Support for automatic reconnections in the case xrootd; is restarted; Dedicated admin area (under <xrd.admin>/.xproofd.<port>) to; keep information about active and terminated sessions, and active; clients. This is used to reguraly check the client and session; activity, to cleanup orphalin sessions and to shutdown inactive client; connections. ; domain + level control of printout message. Dynamic ""per-query"" scheduling. Dynamic worker startup. It can be enabled by the cluster; administrator with the 'xpd.putrc Proof.DynamicStartup 1' directive; in the config file. The effect is that a session starts only on; the master. When a query is submitted (call to TProof::Process),; the session master contacts the scheduler.; In response it receives a list of workers and starts the worker; processes. The environment is copied from the master to the workers.; It consist of: the include and library paths, the set of enabled; packages as well as the macros loaded by the user. . Flexible and fault-tolerant workers. A packet resubmitting mechanism. When a worker dies all the; packets that it processed are resubmitted.; Added the possibility to handle dynamically removed workers and partly processed; packets (when a worker is stopped while processing a packet it finishes; the current event and the rest of the packet is reassigned to another workers).; It's done by a new meth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:482,plug-in,plug-in,482,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,2,"['config', 'plug-in']","['config', 'plug-in']"
Modifiability,". PROOF. New functionality. ; Dataset management. ; New class TProofDataSetManager definining the interface; of PROOF to dataset metainfo database; New class TProofDataSetManagerFile implementating; TProofDataSetManager using the file system as back-end;  the; separation is needed to load dataset menagers using different backends;; for example ATLAS foresees to have a MySQL-based implementation.; The instance of the appropriate TProofDataSetManager is; instantiated via the plugin manager; by default an instance; of TProofDataSetManagerFile; managing the <sandbox>/datasets; area is created. The directive 'Proof.DataSetManager' can be used to; modify the settings for TProofDataSetManagerFile or to load a; different dataset manager; for example, to '/pool/datasets' as area for; the dataset information, the following directive can be added to the; xrootd config file; xpd.putrc Proof.DataSetManager file dir:/pool/datasets. Interface to TProofMgr::GetSessionLogs() in the dialog; box. The graphics layout of the logbox has been re-designed, with new; buttons to grep the logs and to save them to a file. It is also; possible to choose the range of lines to be displayed and the subset of; nodes.; ; Support for connection control base on the UNIX group; (new directive 'xpd.allowedgroups; <grp1>,<grp2>, ...'). Improvements:. ; In the case of mismatch between the expected and actual; number of processed events, send back to the client the list of failed; packets.; Implement the classic strategy of the TPacketizer in; TPacketizerAdaptive; the strategy can be changed from adaptive; (default) to TPacketizer with: ""PROOF_PacketizerStrategy"" parameter to; PROOF; The max workers per node can now be also set in the; xrootd config file with.        xpd.putrc ; Packetizer.MaxWorkersPerNode: <desired number>. Make fCacheDir and fPackageDir controllable via directive; . Fixes. ; Two memory leaks in TProofServ affecting repeated runs; withing the same session. Fix a problem cleaning-up the in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v520/index.html:478,plugin,plugin,478,proof/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v520/index.html,3,"['config', 'plugin', 'sandbox']","['config', 'plugin', 'sandbox']"
Modifiability,". Proof. New functionality; ; In TProof::Load, add the possibility to define a list of files to be; sent because needed by the main macro file. The list is comma-separated; and the first file is considered as the main one. For example.        ; proof->Load(""<macropath>/mymacro.C+,<thispath>/thisheader.h,<thatpath>/thatheader.h""). will make sure that the files 'thisheader.h' and 'thatheader.h', needed; by 'mymacro.C' are available in the sandbox on the worker machines.; Note that 'thisheader.h' and 'thatheader.h' will be available remotely; in the sandbox, as 'mymacro.C'; so they should be included directly by; 'mymacro.C', e.g. '#include ""thisheader.h""' .; Import the dataset stager daemon 'afdsmgrd' into ROOT; this is used; to manage data staging based on the dataset information (see; http://code.google.com/p/afdsmgrd/ for more info). The daemon is; located under $ROOTSYS/proof/afdsmgrd .; New PROOF bench suite, a framework to run CPU and IO benchmarks with; default selectors/data or with user-provided ones. The code is located; under proof/proofbench.; Add the possibility to access the files on the workers via the same; port used by PROOF. This is useful for cases when it is not possible to; start a file server daemon on a different port (because, for eample, of; a firewall or just inconvenience) and workers do not share a file; system. Internally this works by forking a 'rootd' after identifying a; file request and trasferring the connection to it. The client side is a; TNetFile and it is triggered by the protocol ""rootd://"" (the just; implemented etc/plugins/TFile/P120_TNetFile.C includes this; protocol).; Add support for log file truncation. Truncation is disabled by; default. Enabling is controlled by the rootrc variable.           ; ProofServ.LogFileMaxSize  ; {<bytes>|<kilobytes>K|<megabytes>M|<gigabytes>G}.  indicating the max number of bytes. The number can be followed by; a {K,M,G} to indicate KBytes, MBytes or GBytes, respectively.; Add new derivation of T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:441,sandbox,sandbox,441,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,2,['sandbox'],['sandbox']
Modifiability,". Release notes for checker-XXX builds. Release notes for checker-XXX builds; checker-279; built: November 14, 2016; download: checker-279.tar.bz2; highlights:. The analyzer includes new checks for:; ; Improper instance cleanup up in Objective-C -dealloc methods under manual retain/release.; Inadvertent comparisons of NSNumber, CFNumberRef, and other number object pointers against scalar values.; Unsafe usage of dispatch_once_t predicates stored in Objective-C instance variables and other heap-allocated memory.; Issues resulting from self-assignment in C++.; Incorrect usage of MPI APIs in C and C++. This check can be enabled by passing the following command to scan-build: ;   -enable-checker optin.mpi.MPI-Checker. The scan-build tool now supports a --force-analyze-debug-code flag that forces projects to analyze in debug mode. This flag leaves in assertions and so typically results in fewer false positives.; Additional miscellaneous improvements.; Now requires macOS 10.8 or later. checker-278; built: February 5, 2016; download: checker-278.tar.bz2; highlights:. Greatly improves analysis of C++ lambdas, including interprocedural analysis of lambda applications and reduced 'dead store'; false positives for variables captured by reference.; The analyzer now checks for misuse of 'vfork()'. This check is enabled by default.; The analyzer can now detect excessively-padded structs. This check can be enabled by passing the following; command to scan-build:;   -enable-checker optin.performance.Padding ; The checks to detect misuse of _Nonnull are now enabled by default.; The checks to detect misuse of Objective-C generics are now enabled by default.; Many miscellaneous improvements. checker-277; built: October 28, 2015; download: checker-277.tar.bz2; highlights:. Includes about 20 months of change to Clang itself.; New checker for C++ leaks is turned on by default.; Added various small checks and bug fixes.; Added experimental checkers for Objective-C:. New localizability chec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:474,variab,variables,474,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['variab'],['variables']
Modifiability,". RooFit Package. RooFit 3.50 has undergone a substantial amount of core engineering to improve computational efficiency; and improve algorithmic likelihood optimizations. The expected increases in execution speed range from; roughly 20% (for problems that were already implemented in a close-to optimal form) to more than 2000%; for certain type of problems. Below is a summary of the changes made. All of these changes are; transparent to end-use cases ; ; ; New implementation of RooFit data types. The implementation of data stored in RooDataSet and RooDataHist; was historically handled by ROOT TTrees (though class RooTreeDataStore). The default storage type; has now been changed to class RooVectorDataStore which stores the information in STL arrays. Existing; datasets based on trees can be read in transparently, and are converted to vector form in the ; persistent-to-transient conversion (the datafile is not modified in this operation); ; The vector store has two important advantages: 1) faster data access (raw data access times are 70 times ; faster than for TTrees), 2) ability to rewrite columns on the fly. The first advantage is important; for the existing constant-term precalculation optimization in roofit likelihoods as these are now; also stored in vectors rather than trees. The faster access speed of vectors make that the constant; term optimization inside likelihoods results in a larger speed increase. This is particulatly noticeable in pdfs with; many constant expressions from pdfs that were moderately fast to begin with (e.g. RooHistPdf).; The second advantages allows new types of algorithmic likelihood optimization in RooFit detailed below. New algorithmic optimization in the caching of pdfs. So far - in the likelihood - two classes of; objects are identified: those that change with every event (i.e. the pdf) and those that change; only with the parameters (typically pdf normalization integrals). Pdfs are always recalculated; for every event, whereas integr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:1098,rewrite,rewrite,1098,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,1,['rewrite'],['rewrite']
Modifiability,". RooFit. Assorted small bug fixes have been applied. No major new features have been introduced since 5.26; Normalization of RooRealSumPdf changed from sum of coefficients to sum of coefficients*integrals of input functions.; New PDF RooNonCentralChiSquare which is useful for asymptotic analysis of likelihood ratio tests -- like expected significance and error bands.; Ability to ""seal"" data in RooNLLVar, so that an experiment can publish likleihood functions without exposing the data necessary to evaluate the likelihood function. HistFactory. The ROOT release ships with a script prepareHistFactory and a binary hist2workspace in the $ROOTSYS/bin directories.; prepareHistFactory prepares a working area. It creates a results/, data/, and config/ directory. It also copies the HistFactorySchema.dtd and example XML files into the config/ directory. Additionally, it copies a root file into the data/ directory for use with the examples. Usage: hist2workspace input.xml; HistFactorySchema.dtd: This file is located in $ROOTSYS/etc/ specifies the XML schema. It is typically placed in the config/ direc-tory of a working area together with the top-level XML file and the individual channel XML files. The user should not modify this file. The HistFactorySchema.dtd is commented to specify exactly the meaning of the various options. Top-Level XML File. see for example $ROOTSYS/tutorials/histfactory/example.xml; This file is edited by the user. It specifies; ; A top level 'Combination' that is composed of:; 	; several 'Channels', which are described in separate XML files.; 	 several 'Measurements' (corresponding to a full fit of the model) each of which specifies; 	 ; a name for this measurement to be used in tables and files; what is the luminosity associated to the measurement in picobarns; which bins of the histogram should be used; what is the relative uncertainty on the luminosity; what is (are) the parameter(s) of interest that will be measured; which parameters should be fixed/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:746,config,config,746,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,2,['config'],['config']
Modifiability,". RooFit; New infrastructure for toy MC studies. A new class RooStudyManager has been added that is intended; to replace the present RooMCStudy framework for toy MC; studies on the time scale of ROOT release 5.26. The present RooMCStudy is a small monolithic driver to; execute 'generate-and-fit' style MC studies for a given pdf. It; provides some room for customization, through modules inheriting from; RooAbsMCStudyModule that can modify the standard behavior, but its; design limits the amount of flexibility.; In the new RooStudyManager design, the functionality of; RooMCStudy has been split into two classes: class; RooStudyManager which manages the logistics of running; repetitive studies and class RooGenFitStudy which implements; the functionality of the 'generate-and-fit'-style study of RooMCStudy.; The new design has two big advantages:. Complete freedom in the design of studies, either by tailoring the behavior of RooGenFitStudy or; by using another study module that inherits from RooAbsStudy, and the data that they return.; More flexibility in the mode of execution. The new study manager can execute all study; modules inlines, as was done in RooMCStudy), but also parallelized through PROOF (at present; only PROOF-lite is support, as well as in batch. The code fragment below illustrates the use of the new study manager. // Create workspace with p.d.f; RooWorkspace* ww = new RooWorkspace(""ww"") ;; ww->factory(""Gaussian::g(x[-10,10],mean[-10,10],sigma[3,0.1,10])"") ;. RooGenFitStudy gfs ;; gfs.setGenConfig(""g"",""x"",NumEvents(1000)) ;; gfs.setFitConfig(""g"",""x"",PrintLevel(-1)) ;. RooStudyManager mgr(*ww,gfs) ;. mgr.run(1000) ; // execute 1000 toys inline; mgr.runProof(10000,"""") ; // execute 10000 toys through PROOF-lite. gfs.summaryData()->Print() ;. Workspace and factory improvements. The workspace class RooWorkspace has been augmented with several; new features. The import() method now supports a new argument RenameAllVariablesExcept(const char* suffix, const char ke",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:389,inherit,inheriting,389,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,2,['inherit'],"['inheriting', 'inherits']"
Modifiability,". Sets the limit for recursively nested template instantiations to N. The; default is 1024. .. option:: -foperator-arrow-depth=N. Sets the limit for iterative calls to 'operator->' functions to N. The; default is 256. .. _objc:. Objective-C Language Features; =============================. .. _objcxx:. Objective-C++ Language Features; ===============================. .. _openmp:. OpenMP Features; ===============. Clang supports all OpenMP 4.5 directives and clauses. See :doc:`OpenMPSupport`; for additional details. Use `-fopenmp` to enable OpenMP. Support for OpenMP can be disabled with; `-fno-openmp`. Use `-fopenmp-simd` to enable OpenMP simd features only, without linking; the runtime library; for combined constructs; (e.g. ``#pragma omp parallel for simd``) the non-simd directives and clauses; will be ignored. This can be disabled with `-fno-openmp-simd`. Controlling implementation limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140064,variab,variables,140064,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,". Source Annotations. Source Annotations; The Clang frontend supports several source-level annotations in the form of; GCC-style; attributes and pragmas that can help make using the Clang Static Analyzer; more useful. These annotations can both help suppress false positives as well as; enhance the analyzer's ability to find bugs.; This page gives a practical overview of such annotations. For more technical; specifics regarding Clang-specific annotations please see the Clang's list of language; extensions. Details of ""standard"" GCC attributes (that Clang also; supports) can be found in the GCC; manual, with the majority of the relevant attributes being in the section on; function; attributes.; Note that attributes that are labeled Clang-specific are not; recognized by GCC. Their use can be conditioned using preprocessor macros; (examples included on this page).; Specific Topics. Annotations to Enhance Generic Checks. Null Pointer Checking. Attribute 'nonnull'. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management Annotations. Attribute 'ns_returns_retained'; Attribute 'ns_returns_not_retained'; Attribute 'cf_returns_retained'; Attribute 'cf_returns_not_retained'; Attribute 'ns_consumed'; Attribute 'cf_consumed'; Attribute 'ns_consumes_self'. Libkern Memory Management Annotations. Attribute 'os_returns_retained'; Attribute 'os_returns_not_retained'; Attribute 'os_consumed'; Attribute 'os_consumes_this'; Out Parameters. Custom Assertion Handlers. Attribute 'noreturn'; Attribute 'analyzer_noreturn'. Annotations to Enhance Generic Checks. Null Pointer Checking; Attribute 'nonnull'; The analyzer recognizes the GCC attribute 'nonnull', which indicates that a; function expects that a given function parameter is not a null pointer. Specific; details of the syntax of using the 'nonnull' attribute can be found in GCC's; documentation.; Both the Clang compiler and GCC will flag warnings for simple cases where a; null pointer is directly being passed to a function w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:287,enhance,enhance,287,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['enhance'],['enhance']
Modifiability,". Specify the name of a macro to be defined. The name is defined, but it; has no particular value. .. option:: -d=filename. Specify the name of the dependency filename. .. option:: -debug. Enable debug output. .. option:: -dump-json. Print a JSON representation of all records, suitable for further; automated processing. .. option:: -I directory. Specify where to find other target description files for inclusion. The; ``directory`` value should be a full or partial path to a directory that; contains target description files. .. option:: -null-backend. Parse the source files and build the records, but do not run any; backend. This is useful for timing the frontend. .. option:: -o filename. Specify the output file name. If ``filename`` is ``-``, then; :program:`*-tblgen` sends its output to standard output. .. option:: -print-records. Print all classes and records to standard output (default backend option). .. option:: -print-detailed-records. Print a detailed report of all global variables, classes, and records; to standard output. .. option:: -stats. Print a report with any statistics collected by the backend. .. option:: -time-phases. Time the parser and backend phases and print a report. .. option:: -version. Show the version number of the program. .. option:: -write-if-changed. Write the output file only if it is new or has changed. clang-tblgen Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -gen-clang-attr-classes. Generate Clang attribute classes. .. option:: -gen-clang-attr-parser-string-switches. Generate all parser-related attribute string switches. .. option:: -gen-clang-attr-subject-match-rules-parser-string-switches. Generate all parser-related attribute subject match rule string switches. .. option:: -gen-clang-attr-impl. Generate Clang attribute implementations. .. option:: -gen-clang-attr-list"". Generate a Clang attribute list. .. option:: -gen-clang-attr-subject-match-rule-list. Generate a Clang attribute subject match rule list. .. option:: -gen-clang-att",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst:2212,variab,variables,2212,interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,1,['variab'],['variables']
Modifiability,". TMVA Options Reference. TMVA Configuration Options Reference; Reference version: TMVA-v-unknown. TMVA-version @ ROOT. Reference for configuration options defined in the option string of each MVA method booking, and for the definition of data sets used for training and testing (Factory). Table fields:. Option:; The option identifier in the option string (given, e.g., in ""factory->BookMethod(...)"" call). Array:; Can the option be set individually for each input variable via the ""[i]"" tag, where ""i"" is the ith variable?. Default value:; Value used if option is not explicitly set in the configuration option string. Predefined values:; Options can be categories of predefined values among which the user must choose. Description:; Info about the option. Colour codes:. Greenish rows:; Options shared by all MVA methods (through common base class). Bluish rows:; Specific MVA options. Yellowish rows:; Configuration options for minimiser (fitter) classes. Redish rows:; Options for other configurable classes. Available MVA methods (1st row), minimisation tools (2nd row), and other configurables (3rd row):. [MVA::HMatrix] [MVA::Fisher] [MVA::PDERS] [MVA::FDA] [MVA::LD] [MVA::SVM] [MVA::CFMlpANN] [MVA::KNN] [MVA::BDT] [MVA::Boost] [MVA::RuleFit] [MVA::Likelihood] [MVA::MLP] [MVA::Cuts] [MVA::PDEFoam] [MVA::TMlpANN]. [Fitter_SA] [Fitter_MC] [Fitter_Minuit] [Fitter_GA]. [DataSetFactory] [PDF] [Factory]. Configuration options for MVA method :. Configuration options reference for MVA method: HMatrix. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:134,config,configuration,134,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,5,"['config', 'variab']","['configurable', 'configuration', 'variable']"
Modifiability,". TMVA. TMVA version 4.0.1 is included in this root release:. Main changes and new features introduced with TMVA 4. Reorganisation of internal data handling and constructors; of methods to allow to build arbitrary composite MVA methods,; and to deal with multi-class classification and multi-target; regression; ; Extended TMVA to multivariate multi-target regression; ; Any TMVA method can now be boosted (linearly or; non-linearly); ; Transformation of input variables can be chained as wished; ; Weight files are now in XML format; ; New MVA methods ""PDE-Foam"" and ""LD"", both featuring; classification and regression; ; ; Comments. On XML format:; ; The old text format is obsolete though still readable in the; application. Backward compatibility is NOT guaranteed. Please; contact the authors if you require the reading of old text weight; files in TMVA 4.; ; ; Standard macros:; ; The structure of the standard macros has changed: macros are; still in the ""$ROOTSYS/tmva/test"" directory, but distinguished for; classification and regression examples:; ; TMVAClassification.C, TMVAClassificationApplication.C TMVARegression.C, TMVARegressionApplication.C; ; Classification and regression analysis (training) is analysed as; usual via standard macros that can be called from dedicated; GUIs.; ; ; Regression:. Not yet available for all MVA methods. It exists for:; PDE-RS, PDE-Foam, K-NN, LD, FDA, MLP, BDT for single targets; (1D), and MLP for multiple targets (nD).; ; Not all transformation of input variables are available; (only ""Norm"" so far). Regression requires specific evaluation tools:. ; During the training we provide a ranking of input; variables, using various criteria: correlations, transposed; correlation, correlation ratio, and ""mutual information"" between; input variables and regression target. (Correlation ratio and; mutual information implmentations provided by Moritz Backes,; Geneva U); ; After the training, the trained MVA methods are ranked wrt.; the deviations betwe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html:461,variab,variables,461,tmva/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html,1,['variab'],['variables']
Modifiability,". TMVA. TMVA version 4.0.4 is included in this root release. Methods. A new Category method allowing the user to; separate the training data (and accordingly the application; data) into disjoint sub-populations exhibiting significantly; different properties. The separation into phase space regions is; done by applying requirements on the input and/or spectator; variables. In each of these disjoint regions (each event must; belong to one and only one region), an independent training is; performed using the most appropriate MVA method, training; options and set of training variables in that zone. The division; into categories in presence of distinct sub-populations reduces; the correlations between the training variables, improves the; modelling, and hence increases the classification and regression; performance. Presently, the Category method works for; classification only, but regression will follow soon. Please; contact us if urgently needed. An example scripts and data files illustrating how the new; Category method is configured and used. Please check the macros; test/TMVAClassificationCategory.C and; test/TMVAClassificationCategoryApplication.C or the; corresponding executables.; Regression functionality for gradient boosted trees using a Huber loss function. Comments. On Input Data: . New TMVA event vector building. The code for splitting the input; data into training and test samples for all classes and the; mixing of those samples to one training and one test sample has; been rewritten completely. The new code is more performant and; has a clearer structure. This fixes several bugs which have been; reported by the TMVA users. On Minimization: . Variables, targets and spectators are now checked if they are; constant. (The execution of TMVA is stopped for variables and; targets, a warning is given for spectators.). On Regression:; ; The analysis type is no longer defined by calling a dedicated; TestAllMethods-member-function of the Factory, but with the; option ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html:364,variab,variables,364,tmva/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html,3,['variab'],['variables']
Modifiability,". TMVA. TMVA version 4.1.2 is included in this root release. The changes with respect; to ROOT 5.28 / TMVA 4.1.0 are in detail:. Variable transformations. Variable transformations can now be applied to a user-defined subset; of variables (and regression targets).; Enable variable transformations for general boosting; Extended PDEFoam functionality:. Multiclass classification by training of one discriminator foam for each; variable.; The cell tree can now be plotted from the macro test/PlotFoams. This makes; it easyer to compare the PDEFoam structure to a decision tree.; Variable importance ranking by counting the number of cuts made in each; dimension. The variable, for which the most cuts were done is ranked highest. Fixed the size of the sampling box in PDEFoam:; In TMVA 4.1.0 the size of the PDEFoam sampling box in each dimension was; 2*VolFrac times the foam size. This was contrary to the intention and the; documentation in the UserGuide and is now corrected: In TMVA 4.1.1 the size; of the PDEFoam sampling box in each dimension is now VolFrac times the foam; size. This implies that in TMVA 4.1.1 the VolFrac value for training a PDEFoam; must be doubled in order to give the same results as in TMVA 4.1.0. The default; VolFrac value was also changed from 0.0333 to 0.0666.; New configuration variable ""NbinsMVAoutput"" defining the bins of the MVA output; variables in the TMVA training plots produced via the GUI. As always, Config; settings can be modified in the training script via, eg, the command. (TMVA::gConfig().GetVariablePlotting()).fNbinsMVAoutput = 50;. to be called AFTER initialising the TMVA Factory object. Bug fixes. Requested number of training and testing events was not; correct when pre-selection cuts were applied. Now the number of; requested events scales with the preselection efficiency and hence; does not need to be adjusted with the pre-selection. This also; corrects the problems seen in the Category classifierm, where; pre-selection is used to buil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v530/index.html:228,variab,variables,228,tmva/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v530/index.html,4,['variab'],"['variable', 'variables']"
Modifiability,". TPDF. The following macro produced a wrong PDF file. The second page had a black; background.; ; {; gROOT->SetStyle(""Plain"");; TCanvas* canvas = new TCanvas(""canvas"", ""canvas"", 600, 700);; TH1F* h = new TH1F(""h"",""ht"", 100, -5, 5);; h->FillRandom(""gaus"",10000);; canvas->Divide(2,1);; canvas->cd(1); h->Draw();; canvas->Update();; canvas->Print(""test.pdf("");; canvas->Print(""test.pdf"");; canvas->Print(""test.pdf)"");; }; . TPostscript. Fix a precision problem in the text positionning. When the pad limits along; X or Y were very close the text position might be wrong. This was found; thanks to the test #15 in stressGraphics. The text position is now computed; using double precision variables only. TASImage. Horizontal dashed lines having a width greater than 1, were not correct. TLatex. Improve the sqrt drawing to avoid the overlapping; problem mentionned here https://savannah.cern.ch/bugs/index.php?82436. TGaxis. The following macro produced two different labelling. Label ""3"" was missing; on the axis ""b"".; ; {; TGaxis *a = new TGaxis(0.2,0.5,0.8,0.5,0.2,3.5,510,""G"");; a->SetMoreLogLabels(1); a->Draw();; TGaxis *b = new TGaxis(0.8,0.7,0.2,0.7,0.2,3.5,510,""G"");; b->SetMoreLogLabels(1); b->Draw();; }; . TPad. Add a protection in TPad:Clear() to fix the; bug report #78382. An histogram redrawing in a cloned; pad produced a segmentation fault. GX11Gui. Only call XFreeColors if we are on a <= 8 plane machine (to match calls; to XAllocColor). This solves the bug #77329: X11 error clicking; on '?' in context menus. TGWin32. Unmap the window before to destroy it, in order to properly receive; kUnmapNotify needed by gClient->WaitForUnmap(). This fixes the problem; reported on; the forum. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v530/index.html:686,variab,variables,686,graf2d/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v530/index.html,1,['variab'],['variables']
Modifiability,". The ``flags`` field is set to either 0 if no helper functions are needed; or (1<<25) if they are. d. The helper functions are initialized (if present). e. The variable itself is set to its initial value. f. The ``isa`` field is set to ``NULL``. Access to ``__block`` variables from within its lexical scope; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In order to ""move"" the variable to the heap upon a ``copy_helper`` operation the; compiler must rewrite access to such a variable to be indirect through the; structures ``forwarding`` pointer. For example:. .. code-block:: c. int __block i = 10;; i = 11;. would be rewritten to be:. .. code-block:: c. struct _block_byref_i {; void *isa;; struct _block_byref_i *forwarding;; int flags; //refcount;; int size;; int captured_i;; } i = { NULL, &i, 0, sizeof(struct _block_byref_i), 10 };. i.forwarding->captured_i = 11;. In the case of a ``Block`` reference variable being marked ``__block`` the; helper code generated must use the ``_Block_object_assign`` and; ``_Block_object_dispose`` routines supplied by the runtime to make the; copies. For example:. .. code-block:: c. __block void (voidBlock)(void) = blockA;; voidBlock = blockB;. would translate into:. .. code-block:: c. struct _block_byref_voidBlock {; void *isa;; struct _block_byref_voidBlock *forwarding;; int flags; //refcount;; int size;; void (*byref_keep)(struct _block_byref_voidBlock *dst, struct _block_byref_voidBlock *src);; void (*byref_dispose)(struct _block_byref_voidBlock *);; void (^captured_voidBlock)(void);; };. void _block_byref_keep_helper(struct _block_byref_voidBlock *dst, struct _block_byref_voidBlock *src) {; //_Block_copy_assign(&dst->captured_voidBlock, src->captured_voidBlock, 0);; _Block_object_assign(&dst->captured_voidBlock, src->captured_voidBlock, BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER);; }. void _block_byref_dispose_helper(struct _block_byref_voidBlock *param) {; //_Block_destroy(param->captured_voidBlock, 0);; _Block_object",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:13677,variab,variable,13677,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variable']
Modifiability,". The book begins with the elementary functionality and progresses; in complexity reaching the specialized topics at the end. The; experienced user looking for special topics may find these chapters; useful: see ""Networking"", ""Writing a Graphical User Interface"",; ""Threads"", and ""PROOF: Parallel Processing"". ## Conventions Used in This Book. We tried to follow a style convention for the sake of clarity. The; styles in used are described below. To show source code in scripts or source files:. ``` {.cpp}; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; ```. To show the ROOT command line, we show the ROOT prompt without numbers.; In the interactive system, the ROOT prompt has a line number; (`root[12]`); for the sake of simplicity, the line numbers are left; off. ``` {.cpp}; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; ```. Italic bold monotype font indicates a global variable, for example; ***`gDirectory`***. When a variable term is used, it is shown between angled brackets. In; the example below the variable term \<library\> can be replaced with; any library in the `$ROOTSYS` directory: `$ROOTSYS/<library>/inc.`. ## The Framework. ROOT is an object-oriented framework aimed at solving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; services such as light switches, electrical outlets, and telephones.; The details, for example, the routing algorithm of the phone switching; system, are transparent to you as the user. You do not care; you are; only inter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:4281,variab,variable,4281,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['variab'],['variable']
Modifiability,". The default in TFileMerger is to call Merge for every object; in the series (i.e the collection has exactly one element) in; order to save memory (by not having all the object in memory; at the same time). However for histograms, the default is to first load all the; objects and then merge them in one go ; this is customizable; when creating the TFileMerger object. Asynchronous Prefetching; The prefetching mechanism uses two new classes (TFilePrefetch; and TFPBlock) to prefetch in advance a block of tree entries. There; is a thread which takes care of actually transferring the blocks and; making them available to the main requesting thread. Therefore, the time; spent by the main thread waiting for the data before processing considerably; decreases. Besides the prefetching mechanisms there is also a local; caching option which can be enabled by the user. Both capabilities are; disabled by default and must be explicitly enabled by the user. In order to enable the prefetching the user must set the rootrc environment; variable TFile.AsyncPrefetching as follows:; gEnv->SetValue(""TFile.AsyncPrefetching"", 1). Only when the; prefetching is enabled can the user set the local cache directory in; which the file transferred will be saved. For subsequent reads of the; same file the system will use the local copy of the file from cache.; To set up a local cache directory, the client can use the following commands:. TString cachedir=""file:/tmp/xcache/"";; // or using xrootd on port 2000; // TString cachedir=""root://localhost:2000//tmp/xrdcache1/"";; gEnv->SetValue(""Cache.Directory"", cachedir.Data());. The TFilePrefetch class is responsible for actually reading; and storing the requests received from the main thread. It also creates; the working thread which will transfer all the information. Apart from; managing the block requests, it also deals with caching the blocks on; the local machine and retrieving them when necessary. The TFPBlock class represents the encapsulation of a blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html:5499,variab,variable,5499,io/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html,1,['variab'],['variable']
Modifiability,". The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of the optimizer recognizing; that it can eliminate most of the load/store operations. The above code gets; optimized to the equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:8871,variab,variable,8871,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['variab'],['variable']
Modifiability,". The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11162,config,configuration,11162,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,2,['config'],['configuration']
Modifiability,". There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatica",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6548,plugin,plugin,6548,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,1,['plugin'],['plugin']
Modifiability,". These can; be an effective way to represent collections of small packed fields. Prefer zext over sext when legal; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On some architectures (X86_64 is one), sign extension can involve an extra; instruction whereas zero extension can be folded into a load. LLVM will try to; replace a sext with a zext when it can be proven safe, but if you have; information in your source language about the range of an integer value, it can; be profitable to use a zext rather than a sext. Alternatively, you can :ref:`specify the range of the value using metadata; <range-metadata>` and LLVM can do the sext to zext conversion for you. Zext GEP indices to machine register width; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Internally, LLVM often promotes the width of GEP indices to machine register; width. When it does so, it will default to using sign extension (sext); operations for safety. If your source language provides information about; the range of the index, you may wish to manually extend indices to machine; register width using a zext instruction. When to specify alignment; ^^^^^^^^^^^^^^^^^^^^^^^^^^; LLVM will always generate correct code if you don’t specify alignment, but may; generate inefficient code. For example, if you are targeting MIPS (or older; ARM ISAs) then the hardware does not handle unaligned loads and stores, and; so you will enter a trap-and-emulate path if you do a load or store with; lower-than-natural alignment. To avoid this, LLVM will emit a slower; sequence of loads, shifts and masks (or load-right + load-left on MIPS) for; all cases where the load / store does not have a sufficiently high alignment; in the IR. The alignment is used to guarantee the alignment on allocas and globals,; though in most cases this is unnecessary (most targets have a sufficiently; high default alignment that they’ll be fine). It is also used to provide a; contract to the back end saying ‘either this load/store has this alignment, or; it is unde",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:4443,extend,extend,4443,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['extend'],['extend']
Modifiability,". These originate mainly from methods present previously in the implementation of the TF1 class. Now they can be used also outside this class. In addition, in order to have a common entry point, interfaces classes for these numerical algorithms have been; included.; These interfaces are as well implemented by classes using the GSL library and located in the MathMore library. The library can be loaded automatically using the ROOT plug-in manager.; In detail, the new classes containing implementations present previously in TF1 are:. ; GaussIntegrator and GaussLegendreIntegrator for numerical integration of one-dimensional functions. The first class uses Gaussian 8 and 16 point quadrature approximation, it provides the translation of the CERNLIB algorithm; DGAUSS by Sigfried Kolbig, and it is used by the TF1::Integral method. The second one uses the Gauss Legendre quadrature formula. It is used by the TF1::IntegralFast method.; These classes implement both the same virtual interface as the adaptive integration methods provided by the MathMore library. They can all be created and used easily via the common class ROOT::Math::IntegratorOneDim providing the interfaces for numerical integration.; New template methods have been also included in the common Integration class in order to be able to integrate automatically any C++ callable object. ROOT::Math::RichardsonDerivator implementing numerical derivation using the Richardson's extrapolation formula (use 2 derivative estimates to compute a third, more accurate estimation). This is used by the TD1::Derivative method. ; BrentRootFinder for finding the root of one-dimensional function using the Brent algorithm. The class inherits from a virtual interface, which is also implemented by the MathMore root finder methods. The user can instantiate, via the common ROOT::Math::RootFinder class, all the various root finder algorithms. The BrentRootFinder class is used by TF1::GetX . ; A similar class, BrentMinimizer1D, provides the po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:7108,adapt,adaptive,7108,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['adapt'],['adaptive']
Modifiability,". This; gives strong security guarantees in that these pointers cannot be incremented or; decremented unless they have an explicit, overriding bounds annotation that can; be used to verify the safety of the operation. The compiler issues an error when; a ``__single`` pointer is utilized for pointer arithmetic or array access, as; these operations would immediately cause the pointer to exceed its bounds.; Consequently, this prompts programmers to provide sufficient bounds information; to pointers. In the following example, the pointer on parameter p is; single-by-default, and is employed for array access. As a result, the compiler; generates an error suggesting to add ``__counted_by`` to the pointer. .. code-block:: c. void fill_array_with_indices(int *p, unsigned count) {; for (unsigned i = 0; i < count; ++i) {; p[i] = i; // error; }; }. External bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. ""External"" bounds annotations provide a way to express a relationship between a; pointer variable and another variable (or expression) containing the bounds; information of the pointer. In the following example, ``__counted_by(count)``; annotation expresses the bounds of parameter p using another parameter count.; This model works naturally with many C interfaces and structs because the bounds; of a pointer is often available adjacent to the pointer itself, e.g., at another; parameter of the same function prototype, or at another field of the same struct; declaration. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; // off-by-one error; for (size_t i = 0; i <= count; ++i); p[i] = i;; }. External bounds annotations include ``__counted_by``, ``__sized_by``, and; ``__ended_by``. These annotations do not change the pointer representation,; meaning they do not have ABI implications. * ``__counted_by(N)`` : The pointer points to memory that contains ``N``; elements of pointee type. ``N`` is an expression of integer type which can be; a si",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:9077,variab,variable,9077,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,['variab'],['variable']
Modifiability,". Tree. Branch creation enhancement and clarifications. Make the leaflist optional if the address points to a single numerical variable:; Int_t value;; tree->Branch(branchname, &value);. Introduce a way to create branch using directly; an object:; MyClass object;; TBranch *branch = tree->Branch(branchname, &object, bufsize, splitlevel); Clarify the ownership rules of user objects in a TTree. This clarification (and the improved auto-add-to-directory behavior; of the TH1*) allows for the TTree to now delete the memory that; its has allocated and whose ownsership was _not_ transfer back; to the user (this is happens any time the user give the TTree; the address of a pointer):. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v520/index.html:24,enhance,enhancement,24,tree/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v520/index.html,2,"['enhance', 'variab']","['enhancement', 'variable']"
Modifiability,". Tree; Performance. Introduce support for TTree with variable cluster size (i.e. value of fAutoFlush).; Iterating through the cluster should be done via the new class TTree::TClusterIterator (i.e. this replaces += fAutoFlush):. TTree::TClusterIterator clusterIter = tree->GetClusterIterator(which_entry_to_start_from);; Long64_t clusterStart;; while( (clusterStart = clusterIter()) < tree-<GetEntries()) {; printf(""The cluster starts at %lld and ends at %lld\n"",clusterStart,clusterIter.GetNextEntry()-1);; }; See TTreeCache::FillBuffer for a concrete usage example. Significant improvement of the performance of SetBranchAddress/SetAddress (by a factor 3 to 10 depending on the length/complexity of the classname).; Prevent the unlimited growth of the TBasket's buffer even if the basket is reused.; When the basket is Reset (this happens when it is written and will be reused),; if the TBuffer size is greater than. - twice the data in the current basket; and - twice the average data in each basket (of this branch); and - twice the requeste basket size (TBranch::GetBasketSize).; the size of the buffer is reduced to the max of; 'the data in the current basket' and 'the average' and the requested; buffer size and aligned to next highest multiple of 512.; In TBranchRef distinguish between the entry we need (now called RequestedEntry) and the; entry we have read (fReadEntry) so that we can avoid re-reading the same entry too many; times when executing TRef::GetObject.; Reduce by 40% the time taken GetEntry for a branch created using a leaflist (exclusive of the decompression time).; Introduce TVirtualPerfStats::FileUnzipEvent to be able to keep track of the cost of unzipping and use this in TTreePerfStats and TBasket ... This give a good picture of where the time in unzip or in unstreaming; Add more clusters to the TTreeCache buffer until fBufferMinSize is hit to avoid severely underfilled buffer when; a low number of branches is selected/used.; When reading backwards, make sure to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v530/index.html:54,variab,variable,54,tree/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v530/index.html,1,['variab'],['variable']
