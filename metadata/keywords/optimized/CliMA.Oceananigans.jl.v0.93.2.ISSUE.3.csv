quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Testability,Benchmarking scripts for immersed boundaries and immersed boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2452:0,Benchmark,Benchmarking,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2452,1,['Benchmark'],['Benchmarking']
Testability,Benchmarking turbulence closures,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/289:0,Benchmark,Benchmarking,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/289,1,['Benchmark'],['Benchmarking']
Testability,Benchmarks in Docs & README,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3166:0,Benchmark,Benchmarks,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3166,1,['Benchmark'],['Benchmarks']
Testability,Better validation for `LatitudeLongitudeGrid` + add test for `sum(Azᶜᶜᵃ) ≈ 4πr²`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3240:52,test,test,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3240,1,['test'],['test']
Testability,Brings back ShallowWater regression test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2937:36,test,test,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2937,1,['test'],['test']
Testability,Bugfix and tests for RegularCartesianGrid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/4:11,test,tests,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/4,1,['test'],['tests']
Testability,Build and test but do not deploy docs on Buildkite,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1018:10,test,test,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1018,1,['test'],['test']
Testability,"Builds off @vchuravy's work in #261. Preliminary design of user API for concrete models. Probably most of the time the user will have to specify boundary conditions prior to building the model. We'll have to come up with good syntax for that. What we have is ok, but can be improved. The checkpointing tests currently fail, I think because they attempt to change the types of the some of the model fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/263:302,test,tests,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/263,1,['test'],['tests']
Testability,CI testing for GPU code.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/53:3,test,testing,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/53,1,['test'],['testing']
Testability,CPU status in README banner does not print results of tests on master,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/712:54,test,tests,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/712,1,['test'],['tests']
Testability,"CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 256 │ 23.927 ms │ 24.030 ms │ 24.651 ms │ 28.232 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 512 │ 91.065 ms │ 93.878 ms │ 93.733 ms │ 97.092 ms │ 1.36 MiB │ 2315 │ 10 │; │ CPU │ Float64 │ 1024 │ 388.387 ms │ 389.332 ms │ 390.035 ms │ 392.166 ms │ 1.36 MiB │ 2315 │ 10 │; │ CPU │ Float64 │ 2048 │ 1.584 s │ 1.584 s │ 1.584 s │ 1.585 s │ 1.36 MiB │ 2315 │ 4 │; │ CPU │ Float64 │ 4096 │ 6.337 s │ 6.337 s │ 6.337 s │ 6.337 s │ 1.36 MiB │ 2315 │ 1 │; │ CPU │ Float64 │ 8192 │ 25.696 s │ 25.696 s │ 25.696 s │ 25.696 s │ 1.36 MiB │ 2313",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:1366,benchmark,benchmarks,1366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['benchmark'],['benchmarks']
Testability,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140:17,test,tests,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140,12,"['Test', 'test']","['Tests', 'test', 'testing', 'tests']"
Testability,Change log level for doctesting with warnings,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3707:7,log,log,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3707,1,['log'],['log']
Testability,Change log level for doctesting with warnings take #2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3711:7,log,log,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3711,1,['log'],['log']
Testability,Changed `->` to `to` in the benchmark scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1678:28,benchmark,benchmark,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1678,1,['benchmark'],['benchmark']
Testability,Changes in PR #2740 made the global simulation crash. These changes will be reverted for the moment. They will be reintroduced after more testing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2778:138,test,testing,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2778,1,['test'],['testing']
Testability,Checking to see if making scalar diffusivity mutable broke CI tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3407:62,test,tests,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3407,1,['test'],['tests']
Testability,"Checkpointing, NetCDF, and golden master tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140:41,test,tests,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140,1,['test'],['tests']
Testability,"Cherry picked some commits from PR #381 to fix the example test. One thing that's going to be annoying about testing example scripts is that they evaluate in global scope when including them, so it's going to be easy to get variable name conflicts... Not sure how to get around this as we agreed not to use functions for examples.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/424:59,test,test,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/424,2,['test'],"['test', 'testing']"
Testability,Clean up benchmark scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/380:9,benchmark,benchmark,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/380,1,['benchmark'],['benchmark']
Testability,Clean up convergence test scripts and plots,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/881:21,test,test,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881,1,['test'],['test']
Testability,Cleaning up tests for efficiency,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990:12,test,tests,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990,1,['test'],['tests']
Testability,"Cleans up the file organization, test, import statements, and some formatting irregularities. Resolves #1521 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1525:33,test,test,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1525,1,['test'],['test']
Testability,Cleanup in the implicit free surface tests + add `matrix_implicit_free_surface_solver_tests`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2181:37,test,tests,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2181,1,['test'],['tests']
Testability,"CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_serial.jl; Besides the benchmark scripts themselves, everything else was up to date with the latest version of master. Here are the results:; ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ┌───────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────────┬─────────┬─────────┐; │ size │ threads │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.453 s │ 1.454 s │ 1.454 s │ 1.456 s │ 1.37 MiB │ 2318 │ 4 │; │ (8192, 1024) │ 2 │ 2.909 s │ 2.933 s │ 2.933 s │ 2.956 s │ 21.52 MiB │ 1303192 │ 2 │; │ (8192, 2048) │ 4 │ 2.096 s │ 2.115 s │ 2.125 s │ 2.165 s │ 16.38 MiB │ 942343 │ 3 │; │ (8192, 4096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴───────────┴─────────┴─────────┘. Shallow water model weak multithreading scaling speedup; ┌───────────────┬─────────┬──────────┬────────────┬─────────┬─────────┐; │ size │ threads │ slowdown │ efficiency │ memory │ allocs │; ├───────────────┼───────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861:1145,benchmark,benchmark,1145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861,1,['benchmark'],['benchmark']
Testability,"Closes #1878. I ran the most relevant tests locally and they all passed for me (didn't have time/resources to run all), but I'd appreciate some thorough reviews in this case since ""diffusivities"" is a word that happens a lot in the repo so it's easy to miss something when making such a change.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1884:38,test,tests,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1884,1,['test'],['tests']
Testability,Closes #2931 . We could add a test...,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2933:30,test,test,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2933,1,['test'],['test']
Testability,"Closes #3226 . It'd make sense to test this, let's see first if it does the trick.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228:34,test,test,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228,1,['test'],['test']
Testability,"Closes https://github.com/CliMA/Oceananigans.jl/issues/1392. CC: @glwagner @ali-ramadhan . Sorry that the issue I create went so long! I was doing a bunch of wrong things but in the end it was pretty straightforward. At this point all I have is a working example of `WindowedSpatialAverage` in the sandbox and I'm creating this PR for two reasons:. - Getting feedback on possible edge cases, and maybe figuring out how the `NetCDFOutput` can infer the dimensions correctly; - Figuring out where to include this; - This isn't necessarily attached to an `OutputWriter`, so it feels odd to add it there; - Everywhere else in Oceananigans also feels inappropriate ; - Maybe add it to Oceanostics?; . Anyway, feedback is appreciated. . Also, big thanks to @ali-ramadhan for helping me out with this one.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397:298,sandbox,sandbox,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397,1,['sandbox'],['sandbox']
Testability,"Closes https://github.com/CliMA/Oceananigans.jl/issues/3051. Following up on #3394, this PR tries to do the first two tasks, fix the tendencies in the shallow water model and bring back the regression tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486:201,test,tests,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486,1,['test'],['tests']
Testability,Cnh/full cube implicit solver test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1593:30,test,test,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1593,1,['test'],['test']
Testability,"Co-authored-by: Francis J. Poulin <fpoulin@uwaterloo.ca>. I've added back the threaded benchmark written by @francispoulin in an older branch. I also added plots to it.; There is actually already a threaded benchmark script:; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading.jl; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading_single.jl; They differ in that the one I'm adding is essentially weak scaling shallow water model, while the one that's already there is strong scaling nonhydrostatic model.; If everyone thinks that it's appropriate, then I'll likely change the name of the extant benchmarking scripts to more accurately reflect their content. ; I would likely also do some more minor changes such as changing the default grid size down from 512^3, adding in plots, and configuring the output tables a bit more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881:87,benchmark,benchmark,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881,5,['benchmark'],"['benchmark', 'benchmarking']"
Testability,Codecov and Coveralls coverage statistics do not account for GPU tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/138:65,test,tests,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/138,1,['test'],['tests']
Testability,Collaboration with @francispoulin. Todo:. - [x] Add time-stepping test with `advection=nothing` in `IncompressibleModel`; - [x] Add time-stepping test with `advection=nothing` in `ShallowWaterModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1270:66,test,test,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1270,2,['test'],['test']
Testability,Comments or docstrings for cubed sphere test functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3242:40,test,test,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3242,1,['test'],['test']
Testability,"CompatHelper: add new compat entry for BenchmarkTools at version 1, (keep existing compat)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2517:39,Benchmark,BenchmarkTools,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517,2,['Benchmark'],['BenchmarkTools']
Testability,Complete implementation of `HydrostaticFreeSurfaceModel` regression test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2036:68,test,test,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2036,1,['test'],['test']
Testability,Continuous CPU + GPU benchmarks,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/67:21,benchmark,benchmarks,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/67,1,['benchmark'],['benchmarks']
Testability,Convergence test and validation experiment Buildkite pipeline,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223:12,test,test,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223,1,['test'],['test']
Testability,Convergence test for advection schemes in shallow water,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1648:12,test,test,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648,1,['test'],['test']
Testability,Convergence tests pipeline takes several hours to finish,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1420:12,test,tests,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1420,1,['test'],['tests']
Testability,"Converted `benchmark_static_ocean.jl` to do a strong scaling test on a 256³ simulation when `Threads.nthreads() > 1`. Results are pretty sweet for multithreading that we basically got for free from KernelAbstractions.jl. Not sure what kind of speedups to expect for multithreading though. Maybe @leios, @christophernhill, or @vchuravy have a better idea. Some results on number of threads and wall clock time per time step:. # Tartarus. ```zsh; #!/bin/zsh; for threads in 1 4 8 16 24 32 40; ~/julia-1.5.0/bin/julia --project -t $threads benchmark_static_ocean.jl; ```. ```; Julia 1.5.0 + Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. 1 thread: 3.78 s; 4 threads: 1.35 s (2.8x); 8 threads: 839 ms (4.5x); 16 threads: 585 ms (6.5x); 24 threads: 551 ms (6.9x); 32 threads: 539 ms (7.0x); 40 threads: 483 ms (10.6x); 48 threads: 479 ms (10.7x); ```. # Satori. ```bash; #!/bin/bash; for threads in 1 4 8 16 32 64 128 160; do JULIA_NUM_THREADS=$threads julia --project benchmark_static_ocean.jl; done; ```. ```; Julia 1.4.1 + IBM Power System AC922 (8335-GTH). 1 thread: 5.13 s; 4 threads: 2.44 s (2.1x); 8 threads: 1.35 s (3.8x); 16 threads: 796 ms (6.4x); 32 threads: 637 ms (8.0x); 64 threads: 503 ms (10.2x); 128 threads: 501 ms (10.2x); 160 threads: 511 ms (10.0x); ```. A beautiful scene from Satori:. ![image](https://user-images.githubusercontent.com/20099589/91370150-96ad1100-e7db-11ea-9bf2-12e40de5ff93.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/869:61,test,test,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/869,1,['test'],['test']
Testability,"Copy pasting from @glwagner's fork. Adaptive time stepping with a `TimeStepWizard` that computes time steps for you. I just need to modify `time_step!` with a flag like `first_step_Euler=true` to take forward Euler steps at first iteration and when changing the time step, but with the ability to turn it off for tests where we actually don't want to do this. . I'll add some more docstrings and a couple of tests. cc @sandreza . Resolves #189",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297:313,test,tests,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297,2,['test'],['tests']
Testability,Correct logic for `AveragedTimeInterval`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3720:8,log,logic,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3720,1,['log'],['logic']
Testability,Correct logic in `AveragedTimeInterval`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3719:8,log,logic,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3719,1,['log'],['logic']
Testability,Could also change some of the examples and some tests to use flat dimensions now. Resolves #1023 ; Resolves #1026,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1024:48,test,tests,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1024,1,['test'],['tests']
Testability,"Could lead to confusion, e.g. in #579. Thanks for helping locate this issue @masonrogers14. Easy PR but might involve refactoring some tests?. https://github.com/climate-machine/Oceananigans.jl/blob/588890004e69cfc7db10472b12a9840b8a9ad7b6/src/boundary_conditions.jl#L339",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/582:135,test,tests,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/582,1,['test'],['tests']
Testability,Create a wiki with information / notes on how to setup buildkite for local testing?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1046:75,test,testing,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1046,1,['test'],['testing']
Testability,"CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:76543,Test,Test,76543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,CubedSphere grid construction + tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2871:32,test,tests,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2871,1,['test'],['tests']
Testability,"Currently I think Travis and GitLab upload them but since GPU tests are moving to Buildkite, coverage artifacts should be uploaded from there.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1052:62,test,tests,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1052,1,['test'],['tests']
Testability,"Currently a work in progress, but it has one validation experiment (Rossby-Haurwitz) and one ""for fun"" dynamics test (Bickley Jet)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1570:112,test,test,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570,1,['test'],['test']
Testability,"Currently only four closures are being tested. ```; Testing that time stepping works [CPU(), Float32, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float32, VerstappenAnisotropicMinimumDissipation]...; Testing that time stepping works [CPU(), Float64, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float64, VerstappenAnisotropicMinimumDissipation]...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/539:39,test,tested,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/539,9,"['Test', 'test']","['Testing', 'tested']"
Testability,"Currently the example tests are ""broken"", i.e. not run because having PyPlot as a dependency caused the Travis CI pipeline to frequently fail for different reasons. I still really like matplotlib and PyPlot but after playing around with Plots.jl I think it'll be worth switching over. As it doesn't get installed through conda it should be more stable on Travis. Would be really cool if Documenter.jl works with Plots.jl [animations](http://docs.juliaplots.org/latest/animations/). I'll give it a try.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/536:22,test,tests,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/536,1,['test'],['tests']
Testability,"Cut cells use piecewise linear representations of bathymetry (as opposed to full or partial cells which use piecewise constant ones). Here’s a tentative work plan for implementing cut cells:. 1. Develop the following test cases: . (a) Tracer advection with no momentum on a seamount ([Adcroft](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml) or [Schär](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml) configuration); ; (b) Internal wave or overflow with momentum;; ; Run these test cases for full and partial cells. As suggested by @jm-c, compare a simulation using low vertical resolution (~10 vertical layers) and partial cells with one using high vertical resolution (~500 vertical layers) and full cells at the same horizontal resolution (to verify the effectiveness of partial cells). To ensure that a stratified ocean remains at rest, implement the technique in [Lin](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs) for partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Cons",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123:217,test,test,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123,2,['test'],['test']
Testability,Cut down the examples. Moved stuff into a sandbox.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/230:42,sandbox,sandbox,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/230,1,['sandbox'],['sandbox']
Testability,"Dear Oceananigans team,. We are trying to use Oceananigans to create reference LES solutions for multiple canonical flows. We use a cubical domain and random perturbations to trigger the flow. During our validation tests, we noticed that we could not reproduce the results, i.e., running the same .jl script (same initial flow conditions) leads to different averaged solutions (see attached picture). We ran more than 16 simulations and never obtained the same solution. We tried to set the seed of the random perturbations constant, but this did not solve the problem. Do you observe this problem, and could you help us run reproducible simulations so other users can obtain the same solutions? We attached the .jl file we are using to define the simulations. Best regards,; Filipe Pereira; Luke van Roekel ; Amrapalli Garanaik; Brodie Pearson . ![tec_ww_time_c1](https://user-images.githubusercontent.com/80914369/193599386-11eccb58-2a3f-4a1c-83d6-cde2ea429d00.png). [c16_128_128m(1).jl.zip](https://github.com/CliMA/Oceananigans.jl/files/9698212/c16_128_128m.1.jl.zip)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766:215,test,tests,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766,1,['test'],['tests']
Testability,Deep convection example and golden master test should switch to BCs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/220:42,test,test,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/220,1,['test'],['test']
Testability,Delete some benchmarks that were done on archaic Oceananigans v0.34.0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2803:12,benchmark,benchmarks,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2803,1,['benchmark'],['benchmarks']
Testability,Depends on functionality in #744 . Needs:. - [x] tests; - [x] possibly more examples in docstrings. Hopefully `Relaxation` will be helpful.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/745:49,test,tests,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/745,1,['test'],['tests']
Testability,"Deps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAni",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:1291,test,test,1291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,Do we allow scalar indexing in all our tests?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3039:39,test,tests,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3039,1,['test'],['tests']
Testability,Docker file for easy installation and CI testing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/151:41,test,testing,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/151,1,['test'],['testing']
Testability,Document and test numerical convergence validation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/777:13,test,test,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777,1,['test'],['test']
Testability,"Does it make sense to aim for 100% code coverage (by some metric)? Maybe not until v1.0.0 as it would increase the testing burden and tests need to be maintained. 100% line coverage shouldn't be too hard to achieve. 100% [MC/DC coverage](https://en.wikipedia.org/wiki/Modified_condition/decision_coverage) would be much harder, and I'm not sure whether it would benefit a package like Oceananigans.jl. Presumably 100% physics coverage is what we want. Although not sure how to quantify % here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1100:115,test,testing,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1100,2,['test'],"['testing', 'tests']"
Testability,Don't do time-stepping tests on Travis,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1071:23,test,tests,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1071,1,['test'],['tests']
Testability,Don't need JLD or HDF5 since PR #329 removed the last use of a JLD output writer. This should speed up CI testing by quite a bit.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/340:106,test,testing,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/340,1,['test'],['testing']
Testability,Drop direct dependency to GPUArrays and BenchmarkTools,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2518:40,Benchmark,BenchmarkTools,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2518,1,['Benchmark'],['BenchmarkTools']
Testability,"E.g., in addition of this:; https://github.com/CliMA/Oceananigans.jl/blob/057e25cea75a0da5e2e0f2328d39205ebaf2b0dc/test/test_time_stepping.jl#L25-L40; we also have tests using, e.g., `closure = (AnisotropicDiffusivity(FT), Closure(FT))` and also some tests using, e.g., `HydrostaticFreeSurfaceModel`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2047:115,test,test,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2047,3,['test'],"['test', 'tests']"
Testability,Each Appveyor build takes 30-50 minutes to run (and they run sequentially) so Appveyor takes forever to finish testing. Compare with ~10 minutes per build on Travis and JuliaGPU's CI on GitLab. It also builds CUDA packages unsuccessfully so maybe defining a CPU testing env and using it on Travis and Appveyor can help? See https://github.com/ali-ramadhan/Oceananigans.jl/issues/79. Problem might go away on its own but otherwise this might help: https://www.appveyor.com/docs/build-cache/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/89:111,test,testing,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/89,2,['test'],['testing']
Testability,Eliminate dichotomy between GPU and CPU tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/242:40,test,tests,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/242,1,['test'],['tests']
Testability,"Encourage, document, test using `Field` for boundary conditions rather than `Array`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3298:21,test,test,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3298,1,['test'],['test']
Testability,EnzymeCore v0.6.5; [460bff9d] ExceptionUnwrapping v0.1.10; [e2ba6199] ExprTools v0.1.10; [c87230d0] FFMPEG v0.4.1; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.2; [53c48c17] FixedPointNumbers v0.8.4; [1fa38f19] Format v1.3.6; [0c68f7d7] GPUArrays v10.0.2; [46192b85] GPUArraysCore v0.1.6; ⌅ [61eb1bfa] GPUCompiler v0.25.0; [28b8d3ca] GR v0.73.3; [c27321d9] Glob v1.3.1; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.10.3; [615f187c] IfElse v0.1.1; [40713840] IncompleteLU v0.2.1; [842dd82b] InlineStrings v1.4.0; [41ab1584] InvertedIndices v1.3.0; [92d709cd] IrrationalConstants v0.2.2; [42fd0dbc] IterativeSolvers v0.9.4; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.46; [1019f520] JLFzf v0.1.7; [692b3bcd] JLLWrappers v1.5.0; [682c06a0] JSON v0.21.4; [0f8b85d8] JSON3 v1.14.0; [63c18a36] KernelAbstractions v0.9.18; [929cbde3] LLVM v6.6.0; [8b046642] LLVMLoopInfo v1.0.0; [8ac3fa9e] LRUCache v1.6.1; [b964fa9f] LaTeXStrings v1.3.1; [23fbe1c1] Latexify v0.16.2; [2ab3a3ac] LogExpFunctions v0.3.27; [e6f89c97] LoggingExtras v1.0.3; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [1914dd2f] MacroTools v0.5.13; [739be429] MbedTLS v1.1.9; [442fdcdd] Measures v0.3.2; [e1d29d7a] Missings v1.1.0; [78c3b35d] Mocking v0.7.7; [85f8d34a] NCDatasets v0.14.3; [5da4648a] NVTX v0.3.4; [77ba4419] NaNMath v1.0.2; [d8793406] ObjectFile v0.4.1; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [4d8831e6] OpenSSL v1.4.2; [bac558e1] OrderedCollections v1.6.3; [65ce6f38] PackageExtensionCompat v1.0.2; [69de0a69] Parsers v2.8.1; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [b98c9c47] Pipe v1.3.0; [eebad327] PkgVersion v0.3.3; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.4.1; [91a5bcdd] Plots v1.40.2; [2dfb63ee] PooledArrays v1.4.3; ⌃ [aea7be01] PrecompileTools v1.2.0; [21216c6a] Preferences v1.4.3; [08abe8d2] PrettyTables v2.3.1; [49802e3a] ProgressBars v1.5.1; [94ee1d12] Quaternions v0.7.6; [74087812] R,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:4161,Log,LogExpFunctions,4161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Log'],['LogExpFunctions']
Testability,Error from benchmark/test distributed nonhydrostatic model scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:11,benchmark,benchmark,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,2,"['benchmark', 'test']","['benchmark', 'test']"
Testability,Even a quick benchmark at the end of the test suite would be nice to uncover issues like #675 and #397 and keep the benchmark scripts up to date.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/684:13,benchmark,benchmark,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/684,3,"['benchmark', 'test']","['benchmark', 'test']"
Testability,Example or test: advection of a square or Gaussian,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/481:11,test,test,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/481,1,['test'],['test']
Testability,"Examples: more, better, tested",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/425:24,test,tested,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/425,1,['test'],['tested']
Testability,"Extended the type WENO5 to allow the execution of the WENO scheme on stretched and uniform grids alike. . In practice:. - `WENO5()` will default to the uniform 5th order coefficients (""uniform"" setting) in all directions with a JS-WENO formulation; - `WENO5(grid = grid)` will default to uniform interpolation coefficient if the direction is uniform (`typeof(Δc) <: Number`) and will precompute the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060:493,test,tested,493,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060,1,['test'],['tested']
Testability,"FFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:76944,Test,Test,76944,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Test'],['Test']
Testability,"FTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:38076,Test,Test,38076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Test'],['Test']
Testability,"Figures in ""Convergence test"" section of the docs are missing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1212:24,test,test,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1212,1,['test'],['test']
Testability,Fix and test `RoquetIdealizedNonlinearEquationOfState`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/574:8,test,test,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/574,1,['test'],['test']
Testability,Fix diagnostics test problem size,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/379:16,test,test,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/379,1,['test'],['test']
Testability,Fix example test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/424:12,test,test,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/424,1,['test'],['test']
Testability,Fix field `norm` tests for `p=Inf`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1559:17,test,tests,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1559,1,['test'],['tests']
Testability,Fix matrix solver test take 2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2572:18,test,test,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2572,1,['test'],['test']
Testability,Fix performance benchmarks dead link in README,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/822:16,benchmark,benchmarks,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/822,1,['benchmark'],['benchmarks']
Testability,Fix shallow water model time step benchmark,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1511:34,benchmark,benchmark,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1511,1,['benchmark'],['benchmark']
Testability,Fix test for implicit free surface with `ImmersedBoundary` and indexed `ReducedField`s,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723:4,test,test,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723,1,['test'],['test']
Testability,Fix triply periodic pressure solver and add/cleanup some tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/834:57,test,tests,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/834,1,['test'],['tests']
Testability,Fixes CATKE-in-a-tuple implementation and adds tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2225:47,test,tests,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225,1,['test'],['tests']
Testability,Fixes `FreeSurface` constructor for `SingleColumnGrid` and adds a test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2196:66,test,test,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2196,1,['test'],['test']
Testability,Fixes and tests `Field(u::Field; indices)` and `Field(u::AbstractOperation; indices)`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2392:10,test,tests,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2392,1,['test'],['tests']
Testability,Fixes implicit free surface solver comparison test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2131:46,test,test,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131,1,['test'],['test']
Testability,Fixes tests with AveragedField and BuoyancyField,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1020:6,test,tests,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1020,1,['test'],['tests']
Testability,Fixing tendencies in shallow water model and bringing back regression tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486:70,test,tests,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486,1,['test'],['tests']
Testability,Flat VerticallyStretchedRectilinearGrid plus new hydrostatic and flat internal wave tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1865:84,test,tests,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865,1,['test'],['tests']
Testability,"Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryCondi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:76888,test,test,76888,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,Follow up from https://github.com/CliMA/Oceananigans.jl/pull/3173. `update_biogeochemical_state!` was being tested but only failing on a grid type that previously wasn't being tested so added tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3179:108,test,tested,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179,3,['test'],"['tested', 'tests']"
Testability,Following the discussion on testing infrastructure from a long time ago (PR #139) it would be good to convert any verification tests that result from #346 into an actual end-to-end test of the model. Not sure how the comparison with MITgcm would be implemented but maybe the others are good enough. `test/verification/` might be a good directory for them?. They can be run separately (separate pipeline) so they don't have to run quickly and can take a while so they can be comprehensive.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/347:28,test,testing,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/347,4,['test'],"['test', 'testing', 'tests']"
Testability,Following the reversal of the k index (PR #462) we need to regenerate all regression test data to correspond to the new convention. This PR does that. Had to update some of the tests as the output data format has changed (e.g. now has halos) and was originally generated a long time ago. I also increased code reuse among the regression tests for summarizing the result of each regression test. This PR is part of #471,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/526:85,test,test,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/526,4,['test'],"['test', 'tests']"
Testability,"Following up on @glwagner 's suggestion in #1532, here is a slight modification to `VerticallyStretchedGrid`, which is consistent with what I'm proposing in that other PR. I actually made a few changes here than I needed to, but these changes are cosmetic and have no impact on functionality. . There are two significant differences. . 1. Like the other grids, we now specify `x,y,z` when defining the grid. We can also add `extent` if people wanted, but it's not in place now.; 2. What is called `zF_generator` in `master`, is now passed as a separate argument. I also changed the name to `z_stetch` since this is what @tomchor used in his example and stretch seems more appropriate than generator. Again, this is easily changed. The grid tests all pass and not sure why other tests seem to fail. What do people think about this difference?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544:740,test,tests,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544,2,['test'],['tests']
Testability,"Following what seems to be the convention, e.g. `test/test_grids.jl` should probably just be called `test/grids.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/871:49,test,test,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/871,2,['test'],['test']
Testability,"For complicated models and examples, user-defined forcing functions can impose significant penalties on simulation performance. In addition to that, models with extensive and complicated diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:342,benchmark,benchmarking,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,2,['benchmark'],"['benchmarking', 'benchmarks']"
Testability,"For example for the tripolar grid it looks like this. ```julia; 2160×1080×60 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on GPU with 7×7×7 halo and with precomputed metrics; ├── centered at (λ, φ) = (75.0, 1.8005); ├── longitude: Periodic extent 360.167 degrees variably spaced with min(Δλ)=0.000208433, max(Δλ)=0.175625; ├── latitude: RightConnected extent 170.157 degrees variably spaced with min(Δφ)=0.000312453, max(Δφ)=0.157553; └── z: Bounded z ∈ [-6000.0, 0.0] variably spaced with min(Δz)=5.24961, max(Δz)=438.409; ```. This claims that whatever grid I've constructed is ""RightConnected"" in latitude. This doesn't really make sense to me... but let's set that aside (it's a separate issue with the tripolar grid). The bigger issue is that the y-topology is NOT the ""latitude topology"" --- on an orthogonal spherical shell grid, ""y"" and ""latitude"" are different (that's the whole point, when they do coincide we are on a LatitudeLongitudeGrid). We should design a good show method for this grid type. My impression is that the show method was copied from LatitudeLongitudeGrid. But we need to work a bit harder for OrthogonalSphericalShellGrid because it is more general. I think we should give information both about the coordinate system (lat, lon, z), and in addition to that and separately, give information about the logical arrangement of the grid (x, y, z), including the topology. The former is important for understanding the geography of the grid and the latter is important for understanding the discretization, and the two are distinct from one another. So the show method for this grid is going to be more involved than the others. I don't think we need to indicate whether the x, y directions are ""variably spaced"". That is useful for rectilinear and lat-lon grids, but not for general grids. . cc @navidcy @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3808:1358,log,logical,1358,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3808,1,['log'],['logical']
Testability,"For example:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(3, 3, 3), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2424:333,test,test,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424,2,['test'],['test']
Testability,For example:; https://buildkite.com/clima/oceananigans/builds/17468#0191fc2c-b421-4cf7-80b5-0429336b1d7f; https://buildkite.com/clima/oceananigans/builds/17473#0191fd88-d8b9-48d5-9c7f-18efc6747ea7; I believe this is because we are launching the docs from many different branches on a relatively small GPU. I think it would be best to move this test on the caltech cluster. Since the caltech cluster works with a slurm scheduler this error would never happen (I can open a PR to fix this),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779:344,test,test,344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779,1,['test'],['test']
Testability,"For now the 10 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". Maybe we just have to define `convert` for Fields with OffsetArrays?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/177:15,test,tests,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177,2,"['Test', 'test']","['Testing', 'tests']"
Testability,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1342:718,test,test,718,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342,3,['test'],['test']
Testability,"For some reason when I tested the code after merging https://github.com/CliMA/Oceananigans.jl/pull/2028 it didn't really work on my main code for GPUs. . It worked for a MWE when I tested it [here](https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-952089949) but I guess I must have done something wrong? In any case, I apologize!. I also expanded the test to test grids on GPUs (which would have caught this error) so I think this'll help. Given that we _just_ released a new version, I didn't bump this to 0.63.4 here. But let me know if I should do that. CC: @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030:23,test,tested,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030,4,['test'],"['test', 'tested']"
Testability,Found out int PR #336 that we can explicitly time-step w which will be nice as it'll work for simulations without a rigid lid. All tests passed when I made the change so should be a quick change.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/338:131,test,tests,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/338,1,['test'],['tests']
Testability,Free convection test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/123:16,test,test,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/123,1,['test'],['test']
Testability,"From a MWE similar to the one in #3899 (adding some more reduced directions):; ```julia; using Oceananigans; using GLMakie. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10)); bottom(x, y) = - rand() * 5 # Between -5 and 0; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). f1 = Field{Center, Center, Nothing}(grid); f2 = Field{Center, Nothing, Center}(grid); f3 = Field{Nothing, Center, Center}(grid); set!(f1, (x, y) -> rand()); set!(f2, (x, y) -> rand()); set!(f3, (x, y) -> rand()). fig = Figure(); ax1 = Axis(fig[1, 1]); ax2 = Axis(fig[1, 2]); ax3 = Axis(fig[1, 3]); heatmap!(ax1, f1); heatmap!(ax2, f2); heatmap!(ax3, f3); ```; <img width=""1174"" alt=""Screenshot 2024-11-05 at 12 26 38 PM"" src=""https://github.com/user-attachments/assets/fc22559f-2615-4e3e-b687-52f40ac5cd4e"">. Should we add some tests?. closes #3899",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3900:829,test,tests,829,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3900,1,['test'],['tests']
Testability,"From call with @glwagner: We should properly test that the pressure projection step produces an incompressible flow field (without computing w from continuity). Right now the `incompressible_in_time` test found in `test_time_stepping.jl` tests for incompressibility after `time_step!` is done and w has been recomputed from w. Interestingly, the sum accumulated in time while the sum of the absolute values does not:. ```; [04/03/2020 13:57:51] Velocity divergence after 1 time steps [CPU, Float64]: min=-6.037244272213971e-19, max=-6.037244272213971e-19, sum=-1.9275293505266353e-22, abs_sum=1.284399769586337e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:57:52] Velocity divergence after 10 time steps [CPU, Float64]: min=-7.735240399597831e-19, max=-7.735240399597831e-19, sum=1.666113807244092e-21, abs_sum=1.5625275138570133e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:58:06] Velocity divergence after 100 time steps [CPU, Float64]: min=-6.005395833397209e-19, max=-6.005395833397209e-19, sum=8.58925289833789e-20, abs_sum=2.661629631159426e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/673:45,test,test,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/673,6,['test'],"['test', 'tests']"
Testability,"From https://github.com/CliMA/Oceananigans.jl/blob/glw/computed-field-diffusivities/test/test_turbulence_closures.jl, it would be nice to have this feature in the main branch. In particular, it would allow for users to implement their own turbulence closures or mimic the effect of no flux boundary conditions on an immersed boundary",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1327:84,test,test,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1327,1,['test'],['test']
Testability,From the test log; ```; WARNING: using CUDAdrv.device in module TimeSteppers conflicts with an existing identifier.; ```. Was also responsible for test failures on PR #559. Another reason to prefer `import` over `using`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/563:9,test,test,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/563,3,"['log', 'test']","['log', 'test']"
Testability,Further increase tolerance in implicit free surface solver tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1689:59,test,tests,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1689,1,['test'],['tests']
Testability,Further system testing and checking for float precision issues.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/168:15,test,testing,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/168,1,['test'],['testing']
Testability,"Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] ver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:76312,test,test,76312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,GPU CI is actually running tests on the CPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1794:27,test,tests,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1794,1,['test'],['tests']
Testability,GPU Poisson solver tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/200:19,test,tests,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/200,1,['test'],['tests']
Testability,GPU simulations tests fail?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1992:16,test,tests,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1992,1,['test'],['tests']
Testability,GPU tests take way too long,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2139:4,test,tests,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139,1,['test'],['tests']
Testability,GPU timestep tests are taking too long,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2325:13,test,tests,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2325,1,['test'],['tests']
Testability,"GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:102763,test,test,102763,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:113170,test,test,113170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,Generalizes budget tests for Flux boundary conditions to every topology and boundary,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1486:19,test,tests,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1486,1,['test'],['tests']
Testability,Good logging should be a high priority item. Python's logging is great... Some options:; * [Base logging](https://docs.julialang.org/en/v1/stdlib/Logging/index.html); * [Memento.jl](https://github.com/invenia/Memento.jl); * [MicroLogging.jl](https://github.com/c42f/MicroLogging.jl),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71:5,log,logging,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71,4,"['Log', 'log']","['Logging', 'logging']"
Testability,Good thing to test as it exposed a typo. Resolves #539,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/549:14,test,test,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/549,1,['test'],['test']
Testability,"Had some time to burn while waiting for stuff to train so I benchmarked some abstract operations:. Some outliers in there like `α * β - γ * δ / ζ` and `(u^2 + v^2 + w^2) / 2` so there should be some useful info. Tried to run on GPU but it wouldn't compile `α + β` even though it worked for me in the REPL :shrug: Worth trying again after #860. ```; Oceananigans v0.34.1 (DEVELOPMENT BRANCH); Julia Version 1.5.0; Commit 96786e22cc (2020-08-01 23:44 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, skylake); ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────; Abstract operations benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 7.66s / 69.8% 6.85GiB / 89.5% ; Section ncalls time %tot avg alloc %tot avg; ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [01] -α [CPU] 10 526μs 0.01% 52.6μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [02] √ζ [CPU] 10 987μs 0.02% 98.7μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [03] sin(β) [CPU] 10 6.97ms 0.13% 697μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [04] cos(γ) [CPU] 10 8.24ms 0.15% 824μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [05] exp(δ) [CPU] 10 7.06ms 0.13% 706μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [06] tanh(ζ) [CPU] 10 13.9ms 0.26% 1.39ms 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [07] α + β [CPU] 10 737μs 0.01% 73.7μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [08] α + β - γ [CPU] 10 191ms 3.58% 19.1ms 370MiB 5.90% 37.0MiB; 32× 32× 32 [09] α * β * γ * δ [CPU] 10 857μs 0.02% 85.7μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [10] α * β - γ * δ / ζ [CPU] 10 299ms 5.59% 29.9ms 340MiB 5.42% 34.0MiB; 32× 32× 32 [11] u^2 + v^2 [CPU] 10 1.30ms 0.02% 130μs 29.2KiB 0.00% 2.92KiB; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/870:60,benchmark,benchmarked,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/870,2,['benchmark'],"['benchmarked', 'benchmarks']"
Testability,Haine & Marshall (1998) channel validation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771:43,test,test,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771,1,['test'],['test']
Testability,"Hello everyone, I have tested ```VerticallyStretchedRectilinearGrid( )``` and found a hard time in setting up the time step for a stable solution. ; I will going to post the whole issue but before that I just want to know weather is there any adaptive time stepping method like we did have ```TimeStepWizard``` . I have searched and failed may be I might have missed it that's why I first ask this question.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741:23,test,tested,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741,1,['test'],['tested']
Testability,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1635:819,log,log,819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635,1,['log'],['log']
Testability,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:368,log,log,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['log'],['log']
Testability,"Hello,. I've been working with @johnryantaylor, and we've been using Lagrangian Particles but have come across an issue. To preface, the issue be my miss understanding of how to use tracked fields but I can't find an obvious solution. Essentially the problem seems to be that to define an tracked field for a tracer you have to already have the model defined, but to do that you have to have the particles defined. A work around for this was to make the model, then define the particles, then redefine the model. This would run and not error, but would result in the tracked field property of the particles not actually being updated. Running it yet again appears to fix it and make it; work. In order to fix this I've modified the `update_particle_properties!` function to explicitly use the models tracer fields when it is a tracer field being tracked. I've also updated the tests which seem to run. If you run the tests on the previous version of the code then the property t does not get updated (but will run with this set up). I hope this is the best place for me to make this pull request since you're updating particle tracking anyway!. Jago",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2662:877,test,tests,877,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2662,2,['test'],['tests']
Testability,"Hello,; My [fork](https://github.com/matinraayai/Oceananigans.jl) of Oceananigans.jl is in the process of adding AMDGPU support for the code base. I've added a new architecture called ROCMGPU, and changed the name of the GPU architecture to CUDAGPU. ; Some of the operations are ported, and the tests are updated to use ROCMGPU as well. @christophernhill and I are in the process of running each test suite to see what other operations need to be tweaked for AMDGPU.; 1. I would like to push this work on a branch on the main codebase, called amdgpu for it to get more attention.; 2. Any help on getting the tests working would be much appreciated.; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2493:295,test,tests,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493,3,['test'],"['test', 'tests']"
Testability,"Hello,; This branch contains my group's efforts to make Oceananigans.jl work with AMDGPU.jl as well as preliminary ports of PencilFFTs.jl for distributed FFTs on both CUDA and AMD GPUs. It uses a fork of AMDGPU.jl with ROCSparse support. It was working fine until today, when I rebased my fork to master. Now the distributed tests doesn't work on my end. The tests don't work on the master branch either. The rest of the tests should work fine. I need help from the developers to review this code and discuss any CUDA-specific features still remaining, as well as testing the distributed CUDA/ROCM support for FFTs. Thanks. Closes #1546",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949:325,test,tests,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949,4,['test'],"['testing', 'tests']"
Testability,"Here I've removed the over-specification that `DiscreteForcing` must have a `Function` in the second parameter so that an object can be put there instead, and a method on that object be the forcing function (don't think I'm describing this very well). This is useful if you want to pass information to a forcing by defining a struct like:; ```julia; struct StructForcing{D}; data :: D; end. (forcing::StructForcing)(i, j, k, grid, clock, model_fields) = forcing.data[i, j, k]; ```. Then this would fail with this error:; <details>; <summary>; MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; </summary>; Struct method forcing [CPU]: Error During Test at /Users/jago/Documents/Projects/Oceananigans.jl/test/test_forcings.jl:204; Test threw exception; Expression: struct_method_forcing(arch); MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; Stacktrace:; [1] u_velocity_tendency; @ ~/Documents/Projects/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:71 [inlined]; [2] cpu_calculate_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; [3] cpu_calculate_Gu!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{3}, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, Gu::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3237:703,Test,Test,703,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237,3,"['Test', 'test']","['Test', 'test']"
Testability,"Here are some profiling results that were done on Satori with nvprof. This is a GPU profile of the nonhydrostatic model.; ```; ==104758== NVPROF is profiling process 104758, command: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl. Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/07/30 10:27:44.108] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/07/30 10:28:25.970] INFO warming up; [2021/07/30 10:29:55.456] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/lwSps/lib/cudadrv/profile.jl:71; [2021/07/30 10:29:58.016] INFO done profiling (GPU, Float64, 128); ==104758== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl; ==104758== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 12.29% 502.36u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912:223,test,test,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912,1,['test'],['test']
Testability,"Here's what we currently do:; https://github.com/CliMA/Oceananigans.jl/blob/b6dd1fa9b1d740f7d8cb4be116a24cbba0042f86/src/Fields/field.jl#L500. Here's a test script:. ```Julia; using Oceananigans; using BenchmarkTools; using LinearAlgebra. Nx, Ny, Nz = 128, 128, 16. grid = RectilinearGrid(size=(Nx, Ny, Nz), x=(-4, 4), y=(-4, 4), z=(-4, 0), topology=(Bounded, Bounded, Bounded)). a = CenterField(grid); b = CenterField(grid). ε(x, y, z) = randn(). set!(a, ε); set!(b, ε). true_dot(a, b) = sum(interior(a) .* interior(b)). dot_current(a::Field, b::Field) = mapreduce((x, y) -> x * y, +, interior(a), interior(b)). function dot_faster(a, b); s = zero(eltype(a.grid)). @inbounds @simd for I ∈ CartesianIndices(a); s += a[I] * b[I]; end. return s; end; ```. I get. ```julia. julia> isapprox(dot_current(a, b), true_dot(a, b)); true. julia> isapprox(dot_faster(a, b), true_dot(a, b)); true. julia> @btime true_dot($a, $b);; 149.667 μs (29 allocations: 2.00 MiB). julia> @btime dot_current($a, $b);; 1.289 ms (34 allocations: 2.00 MiB). julia> @btime dot_faster($a, $b);; 74.041 μs (0 allocations: 0 bytes); ```. So we can get a ~15x speedup with zero allocations. With only this change, running a `HydrostaticFreeSurfaceModel` simulation with a PGC free surface solver gave a ~20% speedup on the CPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2725:152,test,test,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2725,2,"['Benchmark', 'test']","['BenchmarkTools', 'test']"
Testability,"Hey! I just tried out the vertically stretched grid and I'm finding a few issues:. 1. The `OutputWriter` is complaining that there is no field `zC`; 2. It didn't work with the `FT=Float64` argument, so I am using the following. ```; grid = VerticallyStretchedRectilinearGrid(; architecture = GPU(),; size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF,; halo = (3, 3, 3),; topology = (Periodic, Bounded, Bounded)); ```. 3. It asks me to use: `halo = (3, 3, 3)` and not `halo = (1, 1, 1)` . 4. For testing purposes, I tried using a linear grid with `zF = collect(-160:2.5:0)`. I ran for 1 short timestep and it produces NaN's in the `u` field. However, using the same linear grid with `RegularRectilinearGrid(size=(Nx, Ny, Nz), extent=(Δx*Nx, Δy*Ny, Δz*Nz), topology = (Periodic, Bounded, Bounded))` works fine. Any ideas?. Many thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1429:492,test,testing,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429,1,['test'],['testing']
Testability,"Hi Oceananigans,. Thank you very much for making your code open!; @olmozavala and I are currently testing out to see if we can run realistic simulations of the Gulf of Mexico but the documentation (https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Oceananigans.Grids.LatitudeLongitudeGrid) seems to only have examples with a flat bottom. Could you advise how one would prescribe a realistic ocean bathymetry?. Thank you.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3389:98,test,testing,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389,1,['test'],['testing']
Testability,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:18,test,testing,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,4,['test'],"['tested', 'testing']"
Testability,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:891,log,log,891,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['log'],['log']
Testability,"Hi all,. I think there's been a mistake in the open boundary filling that's only becoming a problem now that we're trying to fill non-zero value. https://github.com/CliMA/Oceananigans.jl/blob/3ea2545331d9910d8b467dd8eb31074fb426af5b/src/BoundaryConditions/fill_halo_regions_open.jl#L86-L91. The open fill has always set point at index `1` on the right hand side and `grid.N+1` on the right hand side, but `1` is part of the prognostic domain and halo points we need are just for computing gradients at the face point, which should be at `0`. I came across this because I've only been testing open boundaries on the right side, but was checking it worked in the other directions and realised it always failed when I just switched the direction and sides for a simple case. Am I missing something here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810:584,test,testing,584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810,1,['test'],['testing']
Testability,"Hi all,. Thanks, @glwagner for creating the [PR](https://github.com/CliMA/Oceananigans.jl/pull/3660) for solving the issue of `TimeInterval`. After merging it, I noticed a potential problem related to `AveragedTimeInterval`. Specifically, when resuming from a checkpoint, discontinuity seems to occur. For instance, in the figure below, the tidally averaged velocity is saved for each tidal period. The first run covers days 0-20, and the second run covers days 20-40. A noticeable discontinuity appears at the checkpoint transition from the first run.; <img width=""301"" alt=""image"" src=""https://github.com/user-attachments/assets/ffe04dc8-d829-49a7-8052-0b5a58c2b9a3"">. Here is a MWE for this issue:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670:865,test,test,865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670,1,['test'],['test']
Testability,"Hi all,; I have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference?; ![u_profile (2)](https://github.com/CliMA/Oceananigans.jl/assets/117068415/14e2c865-ec3b-4065-a13a-213a99257d31); ![uw_flux (1)](https://github.com/CliMA/Oceananigans.jl/assets/117068415/1cd16836-6f59-465b-8d02-0577052b52ba). ```julia; const H=15 #/m; grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); const u★=0.01 #friction velocity; Fx(x,y,z,t)=u★^2/H #forcing. const z₀ = H*1e-4 # m (roughness length); const κ = 0.4 # von Karman constant; const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient. @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v). drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)). u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); v_bcs = FieldBoundaryConditions(bottom = drag_bc_v). model = NonhydrostaticModel(; grid, coriolis,; advection = WENO(),; timestepper = :RungeKutta3,; tracers =(:T,:S),; buoyancy = SeawaterBuoyancy(),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; forcing=(u=Fx,)); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195:111,log,log-low,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195,2,['log'],"['log', 'log-low']"
Testability,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/788:45,test,test,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788,4,['test'],"['test', 'testing']"
Testability,"Hi,; I have been working with a shallow water model simulation that consists simply of a stochastic height field as the initial condition. It's been working well on a 2pi by 2pi domain without using the Units module. . However, once I tried to scale this same simulation to a 2000km by 2000km domain, I encountered some issues. Specifically, it seems the simulation becomes static. The output I'm viewing is just the height field animation. I also apologize if the initial condition code is confusing and added an image of the initial height function. I scaled the initial height function to match the domain so that should not be a source of bugs, theoretically. I've been testing and trying to fix this issue but am not sure what to do. . Thanks for any help or advice!. **Code:**; ```; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; using Oceananigans.Units. #Parameters; Nx, Ny = 128, 128; Lx = 1000kilometer; Ly = 1000kilometer. grid = RectilinearGrid(size = (Nx, Ny),; x=(-Lx, Lx), y=(-Lx, Ly),; topology = (Periodic, Periodic, Flat)). model = ShallowWaterModel(; grid=grid,; gravitational_acceleration=9.81,; coriolis=FPlane(f=1),; ). #SMOOTH RANDOM FUNCTION; using Random; Random.seed!(17). n = 16; m = 16; len = n * m * 4. global alea; alea = rand(-1:1, (n, m, 4)). function rand_smth(x::Float64, y::Float64); X = x / 1000000; Y = y / 1000000; val = 0; for i in 1:n; for j in 1:m; ar = alea[i,j,1]; br = alea[i,j,2]; cr = alea[i,j,3]; dr = alea[i,j,4]; val += ar * cos(i * x) * cos(j * y); val += br * cos(i * x) * sin(j * y); val += cr * sin(i * x) * cos(j * y); val += dr * sin(i * x) * sin(j * y); end; end; return val; end; #End of smooth random function. H = 1kilometer # unperturbed layer depth. h₀(x, y, t) = H + rand_smth(x,y). set!(model, h=h₀). uh, vh, h = model.solution. simulation = Simulation(model, Δt=0.002, stop_iteration=10000). using Oceananigans.OutputWriters: JLD2OutputWriter, IterationInterval. simulation.output_writers[:fields] =; JLD2OutputWriter(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2671:674,test,testing,674,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2671,1,['test'],['testing']
Testability,"High-order advection schemes invoke wide stencils that can produce unintended non-zero fluxes across solid immersed boundaries. This PR elides advective fluxes across immersed boundaries for `GridFittedImmersedBoundary` to address that. In addition, we should probably introduce boundary-conditional interpolation so that we limit to second-order advection close to immersed boundaries. I'll drop that into this PR too and add a test for high-order advection with immersed boundaries.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1719:429,test,test,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1719,1,['test'],['test']
Testability,Hijacking @christophernhill's branch and work!. @jm-c set up the same velocity halo exchange from https://github.com/CliMA/Oceananigans.jl/blob/7cc147bbf831fe4de66584d812e56debcfa6e43f/test/test_cubed_sphere_halo_exchange.jl#L378-L382 in MITgcm from which we were able to figure out where the Oceananigans cubed sphere halo exchange was going wrong. There were a several discrepancies (all at halo corners or adjacent to the halo corners). ```; u face 1: 2 discrepancies; v face 1: 3 discrepancies; u face 2: 2 discrepancies; v face 2: 3 discrepancies; u face 3: 1 discrepancies; v face 3: 2 discrepancies; u face 4: 1 discrepancies; v face 4: 3 discrepancies; u face 5: 0 discrepancies; v face 5: 2 discrepancies; u face 6: 0 discrepancies; v face 6: 2 discrepancies; u: 6 discrepancies; v: 15 discrepancies; ```. Not totally sure why our halo exchange algorithm isn't filling these correctly so for now we fix each one after filling all the velocity halos. Now that our halo exchange exactly matches MITgcm's we might want to add some extra tests to make sure we're testing each of these points. Some existing tests need to be cleaned up too. After this fix the Rossby-Haurwitz validation seems pretty happy (it used to exhibit numerical artifacts at some corners then blow up after a few days). https://user-images.githubusercontent.com/20099589/118747990-0317e680-b829-11eb-94c3-40002f928e52.mp4. The eddying aquaplanet validation from PR #1602 doesn't look as happy so it might still have setup issues (and maybe also plotting issues since vorticity is at the corners).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1669:185,test,test,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1669,4,['test'],"['test', 'testing', 'tests']"
Testability,"Hmmm, yeah one issue is that we don't actually test `show` methods. Perhaps it would be good to add a bunch of `show` tests which would also increase code coverage. _Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/700#issuecomment-599480673_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/705:47,test,test,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/705,2,['test'],"['test', 'tests']"
Testability,"However, we don't support reducing across the 4th dimension (yet). I think we should merge this now since it resolves #2424, but we should also raise an issue to add a test or two. Closes #2424",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2425:168,test,test,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2425,1,['test'],['test']
Testability,Hydrostatic model explicit vs. implicit free surface benchmarks + some small fixes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1604:53,benchmark,benchmarks,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1604,1,['benchmark'],['benchmarks']
Testability,HydrostaticFreeSurfaceModel regression test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1373:39,test,test,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373,1,['test'],['test']
Testability,"I added a test that fails due to #3829. I should also test the non-FFT case and test that the proper pre-conditioner was initialized. So the test could be better but it does fail as it should. What we need is a `using Oceananigans.ImmersedBoundaries` but the solvers module is defined well before the immersed boundaries module. So for a solver to depend on the immersed boundaries module, and really just the `ImmersedBoundaryGrid` type then the immersed boundaries module needs to be included first. Based on these comments maybe it's desirable to change the order of inclusion? But maybe it'll take some work. So otherwise we probably need to define another abstract type in `src/Oceananigans.jl` but this solution isn't ideal. https://github.com/CliMA/Oceananigans.jl/blob/13bf409616af8c155b72d8869b7b8f97ae0e844b/src/Oceananigans.jl#L214-L228. Resolves #3829",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3830:10,test,test,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3830,4,['test'],['test']
Testability,I am currently running a 0.083-degree global ocean simulation on Tesla V100 GPUs. I am benchmarking a bit to understand where we can target optimization to improve the performance and I thought I would leave the benchmarks here to document them for later use. (we do not have to merge this PR),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2760:87,benchmark,benchmarking,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2760,2,['benchmark'],"['benchmarking', 'benchmarks']"
Testability,"I am getting the following error from benchmark/distributed_nonhydrostatic_model.jl where I have set threaded = false and decomposition = Slab(). I get a very similar error from the distributed nonhydrostatic script when I run the tests script, but the distributed shallow water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:38,benchmark,benchmark,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,3,"['Benchmark', 'benchmark', 'test']","['Benchmarking', 'benchmark', 'tests']"
Testability,I am trying to run a case with GPU architecture on my school's HPC but I keep running into this same error (see gpu_error.log). This is my first time using the GPUs on the HPC so I am not sure if this is a user error or a software error. The error comes up during model instantiation.; [gpu_error.log](https://github.com/CliMA/Oceananigans.jl/files/5867606/gpu_error.log). Let me know if there is anything else you may need. The run script is also attached as a .txt. ; [model_gpu_waves.txt](https://github.com/CliMA/Oceananigans.jl/files/5867635/model_gpu_waves.txt),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317:122,log,log,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317,3,['log'],['log']
Testability,"I am using the master branch for nutrient tracers with a 3rd DST advection scheme. I found that the halo points don't have the same values as the boundaries in a periodic domain. Below is the configuration I use and a slice of u velocity. Not sure it's a bug or you intended to do so... Also, the fancy logger disappeared after I updated to 0.36.0. ```julia; grid = RegularCartesianGrid(size=(32, 2, 32), extent=(2*32, 2*2, 2*32), halo = (2, 2, 2)). RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 66.0], y ∈ [0.0, 6.0], z ∈ [-64.0, 2.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 2, 32); halo size (Hx, Hy, Hz): (2, 2, 2); grid spacing (Δx, Δy, Δz): (2.0, 2.0, 2.0); ```; ```julia; T_bcs = TracerBoundaryConditions(Ogrid, top = BoundaryCondition(Flux, Qᵀ), ; bottom = BoundaryCondition(Gradient, ∂T∂z)). model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = FPlane(f=f),; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=α, β=β)),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (T=T_bcs,); ); ```; ```julia; model.velocities.u.data.parent[:,:,3]; 36×6 Array{Float64,2}:; -0.0085938 -0.00844015 -0.0085938 -0.00844015 -0.0085938 -0.00844015; -0.010009 -0.0104645 -0.010009 -0.0104645 -0.010009 -0.0104645; -0.00859588 -0.00912747 -0.00829848 -0.00823567 -0.00859588 -0.00912747; -0.00742535 -0.00655195 -0.00594664 -0.00595502 -0.00742535 -0.00655195; -0.00536066 -0.0038463 -0.00437428 -0.00422142 -0.00536066 -0.0038463; -0.00241687 -0.00325761 -0.00216266 -0.00211736 -0.00241687 -0.00325761; 0.00258328 0.00188971 0.00159199 0.00141804 0.00258328 0.00188971; 0.00289388 0.00378436 0.00257106 0.00259916 0.00289388 0.00378436; 0.00363445 0.00407903 0.00342151 0.00360496 0.00363445 0.00407903; 0.00575018 0.00480254 0.00481157 0.00447708 0.00575018 0.00480254; 0.00667745 0.00577658 0.00495125 0.00499728 0.00667745 0.00577658; 0.00464067 0.00487611 0.00543163 0.00506227 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/949:303,log,logger,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949,1,['log'],['logger']
Testability,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549:1382,test,testing,1382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549,1,['test'],['testing']
Testability,"I cannot get the checkpointing test running in PR #140 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:31,test,test,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,1,['test'],['test']
Testability,"I could not get the Poisson pressure solver to work on the GPU. Most of it works but CUDA does not have a DCT function so I had to perform the DCT/IDCT in terms of the FFT/IFFT. The DCT/IDCT functions work in isolation (regression tested with `FFTW.r2r!`, see link to Jupyter notebook below) but not in the Poisson solver. More specifically, the IDCT fails when applied to the third dimension (after or before the IFFT is applied to dimensions 1 and 2). For now I got around this by copying the right hand side to the CPU, doing the transform on the CPU, and copying the geopotential back to the GPU. This operation is so much slower than the time stepping that it takes up like 98%+ of wall clock time. It might also be introducing further numerical errors. Link to current Poisson GPU solver:; https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L421. Messy Jupyter notebook: [Testing DCT/IDCT on the GPU](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/DCT%2BIDCT%20from%20DFT%2BIDFT.ipynb). Messy Jupyter notebook: [Testing GPU Poisson solver](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/GPU/Testing%20GPU%20Poisson%20solver.ipynb)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/56:231,test,tested,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56,4,"['Test', 'test']","['Testing', 'tested']"
Testability,I created a clean branch from the latest version of master that passed the documentation buildkite test. Looking at my old updated `benchmarks.md` through a markdown viewer/editor and I saw that a table that's written in HTML might be causing trouble so I replaced it with a code block quote table.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1952:99,test,test,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1952,2,"['benchmark', 'test']","['benchmarks', 'test']"
Testability,"I guess this is not something I was thinking of but John pointed out that it's crucial that the Fourier-spectral solver returns a nonhydrostatic pressure that when used to update the velocity field, produces a velocity field that is non-divergent at every grid point. Otherwise mass is being unphysically accumulated and tracer quantities will also be accumulated due to nonzero Q(∇·**u**) terms in the flux divergence operators ∇·(**u**Q) = Q(∇·**u**) + **u**·∇Q, leading to divergences and blowups. Right now the wavenumbers are computed as; ```; kx = 2π/Lx # DFT; ky = 2π/Ly # DFT; kz = 1π/Ly # DCT; ```; which should lead to a solver whose solutions converge spectrally. While it may solve for the pressure at the center of the cells very accurately, if ∇·**u** is non-zero this will be a big problem. This will require some testing on my part to see which solver best satisfies ∇·**u**. If we can satisfy it to machine precision, that would be amazing. If not, hopefully it can satisfy it better than the conjugate-gradient method and then we can use the continuity equation to enforce ∇·**u**=0. An alternative (not sure if this would work) is to discretize the derivative operators using a second-order centered-difference scheme (which I believe I've done for the 1D solver, and previous 3D solver) which explicitly places the discretization points on the center of the cells. Then the wavenumbers are; ```; kˣ² = (4 / Δx²) * sin(πl / Nˣ)² # DFT; kʸ² = (4 / Δy²) * sin(πm / Nʸ)² # DFT; kᶻ² = (2 / Δz²) * (cos(πn / Nᶻ) - 1) # DCT; ```; and of course you expect second-order convergence. But if it better satisfies ∇·**u**=0 then it might be the way to go. You can also derive wavenumbers for fourth-order discretization. EDIT: Fixed second-order wavenumbers.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8:829,test,testing,829,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8,1,['test'],['testing']
Testability,"I guess we agreed to make this change a while back after reading [Oreskes et al. (1994)](https://doi.org/10.1126/science.263.5147.641). On verification vs. validation:. > In contrast to the term verification, the term validation does not necessarily denote an establishment of truth (although truth is not precluded). Rather, it denotes the establishment of legitimacy, typically given in terms of contracts, arguments, and methods. We have some convergence tests which should fall under _validation experiments_ as well. Oreskes et al. (1994) comment on the fact that comparison of analytical vs. numerical solutions for Earth science models is an exercise in validation as e.g. users of Oceananigans.jl intend to model the real ocean (no analytical solutions) and not necessarily the Boussinesq equations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1108:458,test,tests,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1108,1,['test'],['tests']
Testability,I guess you need to use `Inf` instead of `∞` which isn't an actual `Float64` in Julia. We accidently merged a failing test from PR #1557 into the main branch: https://buildkite.com/clima/oceananigans/builds/1935#32b55ec6-724f-4c5d-951f-bf6735923583,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1559:118,test,test,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1559,1,['test'],['test']
Testability,"I have modified the [simple 1D diffusion example](https://clima.github.io/OceananigansDocumentation/v0.90.13/literated/one_dimensional_diffusion/) to test how to correct the boundary conditions by using the gradient boundary condition, the script can be found [here](https://github.com/liuchihl/Simple-tests/blob/85f34ec2443a6ff9860f5adfbc68ff39995f00bb/1Ddiffusion_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568:150,test,test,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568,2,['test'],"['test', 'tests']"
Testability,"I haven't had the the time to investigate this for now, but `min_Δz()` (and supposedly the x and y version as well) complains about scalar indexing on the GPU when using irregular z spacing:. ```; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::Recti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040:675,assert,assertscalar,675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040,1,['assert'],['assertscalar']
Testability,"I keep getting bit by this, so I think its time to make the change. We'll see if there are any tests that assume the default.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3860:95,test,tests,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3860,1,['test'],['tests']
Testability,"I know `MultipleForcings` is not exported and not tested so it's experimental. It seems like a useful feature so I tried using it but I ran into an error. Seems to be related to forcing function call arguments (or maybe incorrect regularization?) but I haven't been able to figure out the exact cause. Minimal working example:. ```julia; using Oceananigans. using Oceananigans.Forcings: MultipleForcings. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)). weird_forcing(λ, φ, z, t) = λ * φ + z; wonky_forcing(λ, φ, z, t) = z / (λ - φ). forcing1 = Forcing(weird_forcing); forcing2 = Forcing(wonky_forcing). forcing = (; u=MultipleForcings((forcing1, forcing2))). model = HydrostaticFreeSurfaceModel(; grid, forcing); ```. produces this error:. ```; ERROR: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::LatitudeLongitudeGrid{…}, ::@NamedTuple{…}, ::Nothing, ::Nothing). Closest candidates are:; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:8; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:4; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{Any}); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:1; ... Stacktrace:; [1] user_function_arguments; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:21 [inlined]; [2] ContinuousForcing; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/continuous_forcing.jl:137 [inlined]; [3] MultipleForcings; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/multiple_forcings.jl:32 [inlined]; [4] hydrostatic_free_surface_u_velocity_tendency; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tenden",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3736:50,test,tested,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736,1,['test'],['tested']
Testability,"I looked through the package and it seems like things are already in CuArrays then. https://github.com/climate-machine/Oceananigans.jl/blob/master/src/time_steppers.jl#L42-L78. this should quite readily port over to using DifferentialEquations.jl. It looks like you're using an IMEXEuler scheme? I think there would be some pretty good performance gains, and it would be interesting to start being able to use this entire package as a benchmark.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/391:435,benchmark,benchmark,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/391,1,['benchmark'],['benchmark']
Testability,I noticed that in a couple of tests in `test_grids.jl` the code was written in way that leads to some not-so-clear statements such as:. https://github.com/CliMA/Oceananigans.jl/blob/182e75c80645af0d6a7105ed2d8d4fcbceb7bccc/test/test_grids.jl#L381. The above seems wrong at first but it's actually correct since `Δzᵃᵃᶜ()` is defined the same way as `grid.Δzᵃᵃᶠ`. This PR changes that to make the notation clearer (i.e. `grid.Δzᵃᵃᶠ[2:Nz] == Δzᵃᵃᶠ.(2:Nz)`) and condenses 3 separate test functions for stretched grids (needing three separate grid instantiations) into one function (with the same tests). EDIT:. This also implements a suggestion by @glwagner in https://github.com/CliMA/Oceananigans.jl/pull/2865 that couldn't be implemented then. I'll open another PR in the near future to further condense some other tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2917:30,test,tests,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2917,5,['test'],"['test', 'tests']"
Testability,"I noticed that our git repo has ballooned in size some time in the past week. Someone, possibly me, committed a 52 MiB `ocean_wind_mixing_and_convection.jld2` file, possibly generated by running the example? But `docs/src/generated` is in `.gitignore` so not sure how it made it in. Either way, I think we should scrub it because the repo size has increased by an order of magnitude... ---. Here's a list of files over 500 KiB:; ```; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; eeeca1f2b394 2.4MiB test/deep_convection_golden_master_model_checkpoint_10.jld; 4eb0499aa289 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; 5b613ce426d5 52MiB v0.14.1/generated/ocean_wind_mixing_and_convection.jld2; 7fddefca8cc0 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; b5c2ca7312e5 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; d1ee57ba2365 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/509:454,test,test,454,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509,7,['test'],['test']
Testability,I noticed this deprecated warning... https://github.com/CliMA/Oceananigans.jl/blob/d9e2c31e20e78f1b1dcb4d9bd01a959c51bcb60e/test/test_boundary_conditions_integration.jl#L139-L140,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2091:124,test,test,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2091,1,['test'],['test']
Testability,"I propose that we adopt a policy that all tests contributed to `Oceananigans` must run on both the CPU and the GPU, because currently the GPU functionality is equal or more important than the CPU functionality. To resolve this issue and implement this policy moving forward, we need to adapt existing tests so that all tests run on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/242:42,test,tests,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/242,3,['test'],['tests']
Testability,I pushed this commit as part of PR #727 but I think GitHub servers were experiencing issues so it seems it somehow didn't make it into master. GPU tests passed so should be an easy merge.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/733:147,test,tests,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/733,1,['test'],['tests']
Testability,"I recently ran some benchmarks on threading for Oceananigans based on scripts added by @francispoulin in an older branch.; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_threaded.jl; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_serial.jl; Besides the benchmark scripts themselves, everything else was up to date with the latest version of master. Here are the results:; ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ┌───────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────────┬─────────┬─────────┐; │ size │ threads │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.453 s │ 1.454 s │ 1.454 s │ 1.456 s │ 1.37 MiB │ 2318 │ 4 │; │ (8192, 1024) │ 2 │ 2.909 s │ 2.933 s │ 2.933 s │ 2.956 s │ 21.52 MiB │ 1303192 │ 2 │; │ (8192, 2048) │ 4 │ 2.096 s │ 2.115 s │ 2.125 s │ 2.165 s │ 16.38 MiB │ 942343 │ 3 │; │ (8192, 4096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴───────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861:20,benchmark,benchmarks,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861,6,['benchmark'],"['benchmark', 'benchmarks']"
Testability,"I recently ran the weak scaling shallow water model benchmark with the MultiGPU architecture on Satori, thanks to @christophernhill.; Here are the results:; <html>; <body>; <!--StartFragment-->. size | ranks | min | median | mean | max | memory | allocs | samples; -- | -- | -- | -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 2.765 ms | 2.786 ms | 2.849 ms | 3.374 ms | 2.03 MiB | 5535 | 10; (4096, 512) | (1, 2) | 6.932 ms | 7.081 ms | 8.037 ms | 26.174 ms | 2.03 MiB | 5859 | 20; (4096, 1024) | (1, 4) | 12.592 ms | 14.603 ms | 16.417 ms | 31.468 ms | 2.03 MiB | 5859 | 40. <!--EndFragment-->; </body>; </html>. <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 2.54127 | 0.393505 | 1.00271 | 1.05854; (4096, 1024) | (1, 4) | 5.24053 | 0.19082 | 1.00271 | 1.05854. <!--EndFragment-->; </body>; </html>. The results are not good but at least we can benchmark multi-GPU performance now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882:52,benchmark,benchmark,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882,2,['benchmark'],['benchmark']
Testability,I suggest we convert the plankton example to use a vertically stretched grid. Then we can delete the `sandbox` directory from the repo. Also in the https://clima.github.io/OceananigansDocumentation/dev/model_setup/grids/ we should point the user to this example in the discussion (that doesn't exist yet?) about vertically stretched grid.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1394:102,sandbox,sandbox,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1394,1,['sandbox'],['sandbox']
Testability,"I suspect that the docstring for the `BatchedTridiagonalSolver`,. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L17-L23. is incorrect. The docstring suggests that `c` (the upper diagonal) is indexed from `k=2` to `k=Nz`; however it is actually indexed from `k=1` to `k=Nz-1`:. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L82-L84. In the above code the `c` index is downshifted by 1, so that, if I am interpreting the algorithm correctly, the docstring should read:. ```; b(i, j, 1)ϕ(i, j, 1) + c(i, j, 1)ϕ(i, j, 2) = f(i, j, 1), k = 1; a(i, j, k-1)ϕ(i, j, k-1) + b(i, j, k)ϕ(i, j, k) + c(i, j, k)ϕ(i, j, k+1) = f(i, j, k), k = 2, ..., N-1; a(i, j, N-1)ϕ(i, j, N-1) + b(i, j, N)ϕ(i, j, N) = f(i, j, N), k = N; ```. This is also consistent with the tests, which use arrays of length `Nz-1` for both `a` and `c`. If `c` were indexed in the way implied by the docstring, the `c` array would either have to be length `Nz` or have a `k` index that's offset by 1. The indexing convention that's _implemented_ (rather than the one implied by the docstring) matches constructor interface for the matrix type `Tridiagonal`, which is convenient for testing against solutions produced by julia's built-in `\` operator. However, it means that function inputs need to shift indices by 1 compared to what most would consider ""intuitive"" (that the index of the coefficient `c` matches the index of the solution element `ϕ` that it multiplies).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1643:915,test,tests,915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1643,2,['test'],"['testing', 'tests']"
Testability,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3048:700,log,logical,700,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048,1,['log'],['logical']
Testability,"I think the definition of ""cell volumes"" needs to be dispatched on for models of dimension < 3:. https://github.com/CliMA/Oceananigans.jl/blob/6b2cea36d5782f5a73402b97f4d7476de9237c93/src/Operators/areas_and_volumes.jl#L49-L50. Since `Flat` dimensions have zero grid spacing, cell volumes in models with `Flat` dimensions are spuriously calculated to be `0`, which leads to dividing by `0` in advection operators, eg. https://github.com/CliMA/Oceananigans.jl/blob/6b2cea36d5782f5a73402b97f4d7476de9237c93/src/Advection/tracer_advection_operators.jl#L15-L19. I found this while testing the `internal_wave.jl` example for #1014 . We should have a test that models with `Flat` dimensions don't NaN. In fact, I think most or all of the dynamics tests could be converted to use `Flat`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1023:577,test,testing,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1023,3,['test'],"['test', 'testing', 'tests']"
Testability,I think we should also add a test for the case that `window` and time-interval of output are identical.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1802:29,test,test,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1802,1,['test'],['test']
Testability,"I thought I had fixed this previously but it looks like not. So I've added a test that `isnothing(model.free_surface)` when `grid isa SingleColumnGrid`. For the sake of a verbose explanation:. When `grid isa SingleColumnGrid`, the constructor-helper `FreeSurface` should return `nothing` rather than some other free surface object, like `ExplicitFreeSurface`, etc. THEN, when `isnothing(model.free_surface)`, the handy function `fields(model)` should _omit_ the free surface displacement `η` from the `NamedTuple` of model fields. A bug crept into the code because we didn't have a test during #2121 when some of the function signatures changed (because we don't need `arch` _and_ `grid` if `arch` is stored in `grid`). cc @navidcy ; cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2196:77,test,test,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2196,2,['test'],['test']
Testability,"I took the shallow water Bickley jet example and made two modifications. I added `using CUDA` and changed the architecture to `GPU` and tried running it on my desktop. The GPU is nothing fancy but there is something and I thought that it should, based on previous tests. Unfortunately, `run!(simulation)` yields an error that you can find below. I also tried this on a server and found a similar error. Two questions.; 1. Could someone else try this in a GPU to see if they get an error?; 2. Anyone have a clue as to what id going wrong in this error?. ```; $ julia --project shallow_water_Bickley_jet.jl ; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 129, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 9, 1)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Face,Face,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Face,Face,Center,Nothing,Nothing,typeof(ω̄),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1477:264,test,tests,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477,1,['test'],['tests']
Testability,"I tried to run both the shallow water and incompressible benchmarks and ran into problems when they tried to output the CPU to GPU speedup table html file. ; The problem seems to be cause by the html file being named ""[model name]_CPU_->_GPU_speedup.html"" and "">"" not being allowed to be a part of filenames. It was fixed by changing the output filename to ""[model name]_CPU_to_GPU_speedup.html"".; This issue occurred while running on Windows10, but I think it would likely be a problem elsewhere too where "">"" is a reserved character for file and directory names.; @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1672:57,benchmark,benchmarks,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1672,1,['benchmark'],['benchmarks']
Testability,"I was going quickly through some tests for a PR and found more than one instance of something like this:. https://github.com/CliMA/Oceananigans.jl/blob/93c497a5f78a9a422d8f597dbd5406ccc0c09ceb/test/test_output_writers.jl#L181-L213. Where, unless I'm missing something we run a couple of unnecessary loops. In this case I believe we're creating 4 models, when we could be creating only two. Since the tests are taking a considerable amount of time to run (I think something around 2 hours on the CI servers) I think it'd be a good idea for us to tackle these as time permits. Not necessarily all at once, which would take a huge amount of effort, but maybe one PR here and there when we catch these things. (Although I'm also not opposed to re-organizing all the tests if it'll significantly improve performance.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990:33,test,tests,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990,4,['test'],"['test', 'tests']"
Testability,"I was trying to understand the dims pattern in the branching in `plan_transforms`, and ended up re-writing it a bit to understand it. Not sure if this is a preferable form, but I thought I'd open a PR in case. I need to double-check the logic, but maybe someone can confirm.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1435:237,log,logic,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1435,1,['log'],['logic']
Testability,I'd like to define a custom logger for the logging the progress of models (ModelLogger). It's based on `Logging.SimpleLogger` and currently attempts to format `@info` calls as:; `[dd/mm/yyyy HH:MM:SS] module source_file:line_number: message`. Once that is in place I'd like to define some custom LogStates and have ModelLogger handle those as well. Chiefly `@diagnostic`. . I wired up one of the examples to use ModelLogger rather than printf.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478:28,log,logger,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478,4,"['Log', 'log']","['LogStates', 'Logging', 'logger', 'logging']"
Testability,"I'll open a PR to add a test that covers this. ---. MWE:. ```julia; using Oceananigans; using Oceananigans.Solvers: ConjugateGradientPoissonSolver. grid = RectilinearGrid(; CPU(),; Float64,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0); ). ConjugateGradientPoissonSolver(grid); ```. Error:. ```; ERROR: UndefVarError: `ImmersedBoundaryGrid` not defined; Stacktrace:; [1] ConjugateGradientPoissonSolver(grid::RectilinearGrid{…}; preconditioner::Oceananigans.Solvers.DefaultPreconditioner, reltol::Float64, abstol::Float64, kw::@Kwargs{}); @ Oceananigans.Solvers ~/atdepth/Oceananigans.jl/src/Solvers/conjugate_gradient_poisson_solver.jl:54; [2] ConjugateGradientPoissonSolver(grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, CPU}); @ Oceananigans.Solvers ~/atdepth/Oceananigans.jl/src/Solvers/conjugate_gradient_poisson_solver.jl:47; [3] top-level scope; @ REPL[6]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3829:24,test,test,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3829,1,['test'],['test']
Testability,I'm amazed that the ultra-simple case of forcing with array values is still not properly supported. This PR adds that support. It needs a test.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498:138,test,test,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498,1,['test'],['test']
Testability,"I'm following the documentation so either we have a bug or the documentation needs to be clearer on how to use `JLD2OutputWriter` with named tuples. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)); model = Model(grid=grid); outputs = (u=model->model.velocities.u, T=model->model.tracers.T); model.output_writers[:jld2] = JLD2OutputWriter(model, outputs; frequency=1, prefix=""test"", verbose=true); time_step!(model; Δt=1, Nt=1); ```; produces; ```; [ Info: Calculating JLD2 output (:u, :T)...; ERROR: MethodError: Cannot `convert` an object of type Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} to an object of type Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} ; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:168; Stacktrace:; [1] setindex!(::Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}, ::Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol) at ./dict.jl:380; [2] Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}(::Base.Generator{Base.Iterators.Zip{Tuple{Tuple{Symbol,Symbol},Tu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/562:450,test,test,450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/562,1,['test'],['test']
Testability,"I'm getting an error while running the following example on a GPU, it runs correctly on CPU though. It has a problem with the immersed boundary conditions, but the same BC on the normal boundary doesn't throw the error.; ```; using CUDA; using Oceananigans. arch = has_cuda_gpu() ? GPU() : CPU(); topo = [Flat, Periodic, Bounded] ; underlying_grid = RectilinearGrid(arch, size = (1,1), ; extent = (1, 1),; topology = topo). @inline slope(x, y) = -2.0*y; immersed_grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). z₀ = 1e-2 # Charnock roughness; κ = 0.4 # Von Karman constant; @inline Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2; const dz = 0.1. @inline bottom_drag_v(x, y, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); @inline bottom_drag_v(x, y, z, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); v_drag_bc = FluxBoundaryCondition(bottom_drag_v, field_dependencies=(:v, :w), parameters=Cᴰ(dz)); v_bcs = FieldBoundaryConditions(bottom=v_drag_bc, immersed=v_drag_bc). boundary_conditions = (; v = v_bcs,). model = NonhydrostaticModel(grid = immersed_grid, ; boundary_conditions = boundary_conditions). simulation = Simulation(model, Δt = 0.1, stop_time = 1.0); run!(simulation); ```; Error, truncated stack trace for length:. ```; GPU compilation of kernel gpu_calculate_Gv!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gv!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563:619,log,log,619,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563,1,['log'],['log']
Testability,I'm testing this.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1567:4,test,testing,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1567,1,['test'],['testing']
Testability,"I'm trying to set up a small test where a zonal velocity forced by open boundary conditions goes around an immersed sea mount, using the new immersed pressure solver. Unfortunately I get immediate NaNs on iteration 1. Maybe there's a bug somewhere? I know I'm using a bunch of _experimental_ features together so perhaps this is not surprising. My setup could also be bad though. Curious if anyone has any insights on what's going wrong here. Does the pressure solver need to be modified to account for non-zero velocities at the boundaries? I guess the FFT pressure solver assumes either periodic or no-penetration at the boundaries, but then shouldn't the conjugate gradient solver converge on the correct pressure with enough iterations? Or maybe not if the pre-conditioner is very wrong?. ""MWE"" setup:. ```julia; using Printf; using Oceananigans; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver. L = 100; H = 100. underlying_grid = RectilinearGrid(; CPU(),; Float64,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; x = (0, L),; y = (0, L),; z = (-H, 0); ). h = H/2; w = L/5; mount(x, y) = h * exp(-x^2 / 2w^2) * exp(-y^2 / 2w^2); bottom(x, y) = -H + mount(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). @inline u_inflow(y, z, t) = 0.01. u_bcs = FieldBoundaryConditions(; west = OpenBoundaryCondition(u_inflow),; east = OpenBoundaryCondition(u_inflow); ). boundary_conditions = (; u=u_bcs). model = NonhydrostaticModel(;; grid,; boundary_conditions,; timestepper = :RungeKutta3,; pressure_solver = ConjugateGradientPoissonSolver(; grid;; preconditioner = fft_poisson_solver(grid.underlying_grid); ); ). simulation = Simulation(model; Δt=0.1, stop_time=60). progress(sim) = @printf(; ""iteration: %d, time: %.4f, U_max=(%.2e, %.2e, %.2e)\n"",; iteration(simulation),; time(simulation),; maximum(abs, model.velocities.u),; maximum(abs, model.velocities.v),; maximum(abs, model.velocities.w); ). simulation.callbacks[:progre",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831:29,test,test,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831,1,['test'],['test']
Testability,"I've been facing some trouble in https://github.com/CliMA/Oceananigans.jl/pull/2842/ for cubed sphere grids and I think that's why. Locally this change makes the tests there pass. Admittedly I know very little about cubed spheres, so input is appreciated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2875:162,test,tests,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2875,1,['test'],['tests']
Testability,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2445:123,benchmark,benchmark,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445,1,['benchmark'],['benchmark']
Testability,"I've figured out how to do the 3D pressure solve on a stretched grid following Chris' notes so I think we have all the pieces we need to implement vertically stretched grids, we just have to put it all together. I'm thinking about how to go about fully incorporating a vertically stretched grid, true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471:726,test,tested,726,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471,1,['test'],['tested']
Testability,"I've had a go at fixing #2928 which doesn't seem to be as hard as I thought it would be using @glwagner's idea for `SumOfFields. So far I've only done the nonhydrostatic model kernels but it wasn't much work and looks like its worked. Using the same code as https://github.com/CliMA/Oceananigans.jl/issues/2928#issuecomment-1433398895 I now get:. https://user-images.githubusercontent.com/26657828/227528544-2f786e88-4243-40b6-850e-1992b1e2d8d9.mp4. Which I believe is what we were expecting. I wasn't sure where to put the `SumOfFields` struct so currently have it in the `Fields.jl` file. These changes also negate the need for `biogeochemistry_rhs` since we don't need the advection to be with the biogeochemical tendencies (I think we origionally did this so we didn't need to change all of the kernels, but not we have todo that anyway), it does prevent us from using different advection schemes for the `biogeochemical_drift_velocity`. To do:. - [x] Hydrostatic free surface kernels; - [x] Shallow water kernels; - [x] Tests; - [x] Benchmark; - [x] Fix particle advection",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027:1025,Test,Tests,1025,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027,2,"['Benchmark', 'Test']","['Benchmark', 'Tests']"
Testability,"I've noticed a few weeks ago that my scripts were much slower after the Julia 1.6 upgrade (which is preventing me from upgrading). I thought it was due to my Julia 1.6 installation but after some tests I now think it's an Oceananigans issue, specifically with the WENO5 scheme. I ran the MWE below in both Julia 1.5 (with Oceananigans version 0.57.1) and Julia 1.6 (tried several Oceananigans versions but specifically for this example I'm using Oceananigans version 0.58.5) using GPUs and the speed difference is pretty huge. The interesting part is that this difference only happens if I use WENO5 with a GPU. If I use the 2nd order centered scheme there is no significant difference in time (I haven't tried other schemes) and if I run the script on CPUs the time difference also appears to be small. Here's the script:. ```julia; using Oceananigans; using Oceananigans.Units; using CUDA: has_cuda; Nx, Ny, Nz = 128, 1600, 64. if has_cuda(); arch = GPU(); else; arch = CPU(); Nx = Int(Nx/4); Ny = Int(Ny/4); Nz = Int(Nz/4); end . topology = (Periodic, Bounded, Bounded); grid = RegularRectilinearGrid(size=(Nx, Ny, Nz),; x=(0, 200),; y=(0, 2000),; z=(-100, 0),; topology=topology); println(""\n"", grid, ""\n""). model = IncompressibleModel(architecture = arch,; grid = grid,; advection = WENO5(),; timestepper = :RungeKutta3,; tracers=nothing,; buoyancy=nothing,; closure=nothing,; ); println(""\n"", model, ""\n""). start_time = 1e-9*time_ns(); using Oceanostics: SingleLineProgressMessenger; simulation = Simulation(model, Δt=10seconds,; stop_time=10hours,; wall_time_limit=23.5hours,; iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; stop_iteration=Inf,). println(""\n"", simulation,""\n"",); @info ""---> Starting run!\n""; run!(simulation, pickup=false); ```. The output for Julia 1.5:. ```julia; [ Info: ---> Starting run!; [ Info: [000.14%] i: 5, time: 50.000 seconds, Δt: 10 seconds, wall time: 1.447 minutes, adv CFL: 0.00e+00, diff CFL: 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764:196,test,tests,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764,1,['test'],['tests']
Testability,"I've noticed that Oceananigans is _much_ slower when using forcing functions. As an example, I set-up a simulation without any forcing functions and I noticed that in the first minute (wall time) of the running simulation I complete 3.5% of the whole simulation period. However, if I include forcing functions as; ```julia; bot_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bot_mask, target=0); forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge); ```; then in the first (wall time) minute of running I complete only 0.15% of the simulation. Basically around 20 times slower!. I of course expected a slowdown after including forcing functions, but not by this much. Is this normal behavior?. So far I ran my tests only on CPUs, but I've observed similar behaviors on GPUs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827:782,test,tests,782,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827,1,['test'],['tests']
Testability,Ideally all the tests we run on the CPU should be replicated with GPU models. This will mean more work for the JuliaGPU GitLab CI pipeline.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/78:16,test,tests,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/78,1,['test'],['tests']
Testability,If anyone is interested in setting up an example or test for advection: you set up a 2D model with a square or Gaussian initial condition for temperature and a constant background velocity that advects the square around the domain. We can use it to test our numerical methods and any advection schemes we implement in the future. It would be something like this: https://www.youtube.com/watch?v=NkSVHpZV-xU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/481:52,test,test,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/481,2,['test'],['test']
Testability,"If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::S",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:1738,log,log,1738,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,1,['log'],['log']
Testability,Implement a test that simply inspects the halos for correctness.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3021:12,test,test,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3021,1,['test'],['test']
Testability,"Improved and simplified BinaryOperation with ""stubborn"" location inference",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599:46,stub,stubborn,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599,2,['stub'],['stubborn']
Testability,Improving tracer budget tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/942:24,test,tests,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942,1,['test'],['tests']
Testability,"In PR #590 I added a small/quick strong scaling test and @francispoulin calculated the scaling efficiency which wasn't super great:. ```; np efficiency; == ==========; 2 0.96; 4 0.71; 8 0.62; 16 0.56; ```. I guess to improve performance we should do some MPI profiling to find bottlenecks. Could also benchmark the distributed pressure solve and the halo filling separately to see how they scale as well. Might also make sense to benchmark scaling with `ShallowWaterModel` to see if it's an `IncompressibleModel` issue. Might need a pretty large domain to see good scaling with a 2D shallow water model?. @tomchor pointed out that the benchmark could be flawed. We should make sure everything is compiled. Could also try different sizes and a weak scaling benchmark in case the 1D/slab decomposition isn't helping. Maybe trying on a different machine too. Not sure if there's a ""proper"" setup for doing these scaling benchmarks. Bad scaling efficiency might also be a sign of missing barriers/waits?. @vchuravy We might ask for your help!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1451:48,test,test,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1451,6,"['benchmark', 'test']","['benchmark', 'benchmarks', 'test']"
Testability,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/732:167,test,test,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732,6,"['Test', 'log', 'test']","['Test', 'log', 'test']"
Testability,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/942:25,test,test,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942,9,['test'],['test']
Testability,"In `test_dynamics.jl`, an experiment is set up with inhomogeneous boundary conditions on temperature:. https://github.com/CliMA/Oceananigans.jl/blob/f83fce8c9b7f7fde41247be700d544720537dd35/test/test_dynamics.jl#L310-L312. while using `closure = nothing`:. https://github.com/CliMA/Oceananigans.jl/blob/f83fce8c9b7f7fde41247be700d544720537dd35/test/test_dynamics.jl#L314-L321. This is at best misleading --- with `closure = nothing`, boundary conditions are not enforced. It may also be innocuous though, because there is no diffusive flux _anywhere_ -- not only across boundaries. It may in fact make sense to throw a warning when using `closure = nothing` with non-default boundary conditions (""Boundary conditions are not enforced when `isnothing(closure)`"").",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630:190,test,test,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630,2,['test'],['test']
Testability,"In addition, this PR solves #213: boundary conditions in `z` can now be set by writing. ```julia; model.boundary_conditions.T.z.top = top_bc; model.boundary_conditions.T.z.bottom = bottom_bc; ```. for any field `T`. In a future PR: physics tests that verify the boundary bc is correct.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/237:240,test,tests,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/237,1,['test'],['tests']
Testability,"In my last PR (#2335) I introduced tupled halo filling. . This PR required inferring the length of a Tuple of different element types on the GPU (which is not necessarily easy).; I found a hack to do it, but I was working in julia 1.7. Today, running a simulation with several different functional boundary conditions (in `discrete_form`) with julia 1.6, I found out that the compiler does not like my solution and does not infer the Tuple length (spitting out an `Invalid LLVM` error). This error is not there in julia-1.7. Unfortunately, I already merged my PR because I stupidly did not think to test all possible BC with julia-1.6. Now, to revert to a non-tupled halo filling which works across julia distribution it's a one-liner (in `field_tuples.jl`); ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; fill_halo_regions!(extract_field_data.(full_fields), extract_field_bcs.(full_fields), grid, args...; kwargs...); ```; to; ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; for field in full_fields; fill_halo_regions!(field, args...; kwargs...); end; end; ```. What should we do? We could change this line and leave the infrastructure intact for when we update to julia-1.7 (then we would't have tupled halo filling till then) or find a completely different solution (which will require a lot of restructuring); Probably we also need more tests for boundary conditions with different BC on different sides. I see that the tests that run on julia-1.6 do not return an error though. Do other people encounter the same error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2358:599,test,test,599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2358,3,['test'],"['test', 'tests']"
Testability,In response to #3040 I make sure that some of the grid tests also happen on GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3054:55,test,tests,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3054,1,['test'],['tests']
Testability,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320:1405,log,log,1405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320,4,"['Test', 'log']","['Test', 'Tested', 'log']"
Testability,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1077:418,test,tests,418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077,2,['test'],['tests']
Testability,"In this PR I'm exploring the possibility of adding methods for `diffusive_flux_x`, and `viscous_flux_ux` (along with other directions) for tuples. This is needed when reconstructing tracer variance and kinetic energy dissipation rates for tuples in a conservative formulation and, specifically, it's used in Oceanostics for that end (see https://github.com/tomchor/Oceanostics.jl/pull/112). At the moment these are [defined in Oceanostics](https://github.com/tomchor/Oceanostics.jl/blob/1264b4d61e00ab2fb2fd648d489e5fcd329a135c/src/FlowDiagnostics.jl#L347-L355), but as @glwagner mentioned [here](https://github.com/tomchor/Oceanostics.jl/pull/112#issuecomment-1479761310), this isn't ideal since in the future the behavior of the relevant functions may change in Oceananigans and subsequently this calculation will break in Oceanostics. The downside of defining these methods here is that it adds to the testing infrastructure, but I think the way I currently implemented the tests it doesn't contribute too negatively to this. I'm also proposing removing the fallback method here: https://github.com/CliMA/Oceananigans.jl/blob/200f0622278fcfa583da0119e9696048b334146f/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L154-L169. The reason is that I think these general fallback methods cause for hassle than they solve for less experienced Oceananigans developers (myself very much included) by silently returning something physically reasonable (zero in this case) for virtually any combination of arguments, which can be misleading in a debugging process. But I'm curious to get other people's opinion on this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3057:905,test,testing,905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3057,2,['test'],"['testing', 'tests']"
Testability,Include all convergence test plots in documentation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/879:24,test,test,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/879,1,['test'],['test']
Testability,Include benchmarks of the shallow water model on CPUs vs GPUs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1508:8,benchmark,benchmarks,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1508,1,['benchmark'],['benchmarks']
Testability,Include vector rotation in other test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3881:33,test,test,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3881,1,['test'],['test']
Testability,Incompressibility and pressure projection step test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/673:47,test,test,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/673,1,['test'],['test']
Testability,Incompressibility test.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/226:18,test,test,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/226,1,['test'],['test']
Testability,Incorporate performance benchmarks into tests and CI,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/684:24,benchmark,benchmarks,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/684,2,"['benchmark', 'test']","['benchmarks', 'tests']"
Testability,Increase tolerance for tracer conservation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/400:43,test,test,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/400,1,['test'],['test']
Testability,Increase tolerance in implicit free surface solver tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1686:51,test,tests,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1686,1,['test'],['tests']
Testability,Increase tolerance on `FieldTimeSeries` reduction tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1688:50,test,tests,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1688,1,['test'],['tests']
Testability,"Info(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 20); CoverageTools.MallocInfo(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 38); CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 45) ; CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 49) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 52) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 53) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 56) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 57) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 26) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 27) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 28) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 29) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 30) ; CoverageTools.MallocInfo(46400, ""./src/BoundaryConditions/apply_flux_bcs.jl.32885.mem"", 17) ; CoverageTools.MallocInfo(46400, ""./src/BoundaryConditions/apply_flux_bcs.jl.32885.mem"", 30) ; CoverageTools.MallocInfo(56320, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 20) ; CoverageTools.MallocInfo(95040, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 25) ; CoverageTools.MallocInfo(235751, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 55) ; CoverageTools.MallocInfo(249600, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 70) ; CoverageTools.MallocInfo(739712, ""./benchmark/benchmark_utils.jl.32885.mem"", 20) ; CoverageTools.MallocInfo(1686022, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 50) ; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/685:3839,benchmark,benchmark,3839,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685,3,['benchmark'],['benchmark']
Testability,Initializing environment on Buildkite can be a testing bottleneck,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1056:47,test,testing,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056,1,['test'],['testing']
Testability,Inspired by @Lichriszz and their problem in [#1362](https://github.com/CliMA/Oceananigans.jl/discussions/1362#discussioncomment-374286) I started to make an example of two dimensional turbulence using the shallow water model. At the moment the results are not necessarily worth looking at but I wonder if people could look at the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/two-dimensional-turbulence-shallow-water-example/examples/two_dimensional_turbulence_shallow_water.jl) and say whether the set up is what we want?. A few issues that I have come cross are the following:. - [x] Use the time stepping wizard for numerical stability; - [x] Reduce the number of import statements; - [ ] Plot the vorticity and the divergence fields; - [x] Pick the parameters to get nice results. What is a good a reference for a planar geometry?; - [ ] Should test on GPU; - [ ] Should test with higher resolution. One possible paper is [Polvani et al (1994)](https://aip.scitation.org/doi/pdf/10.1063/1.166002),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1365:865,test,test,865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365,2,['test'],['test']
Testability,"Inspired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780:535,benchmark,benchmarking,535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780,2,"['Benchmark', 'benchmark']","['Benchmarking', 'benchmarking']"
Testability,"Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:102551,test,test,102551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,Introduce `Flat` to shallow water benchmarks,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1735:34,benchmark,benchmarks,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1735,1,['benchmark'],['benchmarks']
Testability,Is `nothing` missing from here? Or something else?. https://github.com/CliMA/Oceananigans.jl/blob/4f80c386930a5b703f753bafd4af76419dbbcac9/test/test_matrix_poisson_solver.jl#L70. cc @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2135:139,test,test,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135,1,['test'],['test']
Testability,Is the fourth-order advection tested?; https://github.com/CliMA/Oceananigans.jl/blob/master/src/Advection/centered_fourth_order.jl. I tried using it in an example I'm drafting and code blew up. With the same time-step but the default advection scheme everything seemed fine... That doesn't necessarily mean that there is a problem but I was a bit alarmed I must say..,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/925:30,test,tested,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/925,1,['test'],['tested']
Testability,Is there a reason that `test_matrix_poisson_solver.jl` defines its own function for computing the laplacian:. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/test/test_matrix_poisson_solver.jl#L8-L15. instead of using the one in `utils_for_runtests.jl`. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/test/utils_for_runtests.jl#L60-L77. I can only note an extra `fill_halo_regions!(ϕ)` line. cc @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2638:197,test,test,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2638,2,['test'],['test']
Testability,Issues like the one fixed by #1755 suggest that the correctness or geometric consistency of `VerticallyStretchedRectilinearGrid` is not tested.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1756:136,test,tested,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1756,1,['test'],['tested']
Testability,"It could be nice to have a type for managing time stepping --- eg, `Simulation` --- rather than requiring the writing of explicit loops as in . https://github.com/climate-machine/Oceananigans.jl/blob/4b7e5bced1019b1a6804d3797cfe0ed41fda4a51/examples/ocean_wind_mixing_and_convection.jl#L190. `Simulation` could look like. ```julia; struct Simulation; model; Δt; simulation_stop_time; wall_time_limit; simulation_stop_iteration; progress; end; ```. Or something along those lines. The field `progress` could either be a function or callable object, or tuple / list of functions or callable objects. The field `Δt` could either be a constant time-step or a `TimeStepWizard`. We might also need a new type called `ProgressMessage` for managing logging / emitting progress messages for simulations. Then we can give it a `frequency` (and `interval`) of emission and support some other nice behaviors like a default format and auto-emission of diagnostic / monitoring results. xref: #432 #431",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447:741,log,logging,741,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447,1,['log'],['logging']
Testability,"It looks like that restarting from a checkpoint is not bit-for-bit? I think the issue is that when restarting from a checkpoint the time step is not restored -- it is still using the initial time step defined in `Simulation()`, not the `last_Δt` from the saved `Clock` object in the checkpoint file. See the example below, which is the output of the attached test case. . In the pickup run I changed the onscreen output from every 10 iterations to every 1 iterations to see the time step. Rather than using the previous time step (5.973 s) from the checkpoint, the pickup run is using a time step of 10 s which is the value when defining `simulation = Simulation(model, Δt=10, stop_iteration=220)`. I’m using v0.91.5. Initial run; ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, max(|u|) = 2.5e-01 ms⁻¹, wall time: 0 seconds; [ Info: ... simulation initialization complete (13.909 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.696 seconds).; Iteration: 0010, time: 1.833 minutes, Δt: 11.212 seconds, max(|u|) = 2.6e-01 ms⁻¹, wall time: 19.116 seconds; Iteration: 0020, time: 3.702 minutes, Δt: 10.681 seconds, max(|u|) = 2.8e-01 ms⁻¹, wall time: 19.345 seconds; Iteration: 0030, time: 5.482 minutes, Δt: 10.215 seconds, max(|u|) = 2.9e-01 ms⁻¹, wall time: 19.629 seconds; Iteration: 0040, time: 7.185 minutes, Δt: 9.802 seconds, max(|u|) = 3.0e-01 ms⁻¹, wall time: 19.854 seconds; Iteration: 0050, time: 8.819 minutes, Δt: 9.433 seconds, max(|u|) = 3.1e-01 ms⁻¹, wall time: 20.082 seconds; Iteration: 0060, time: 10.391 minutes, Δt: 9.100 seconds, max(|u|) = 3.2e-01 ms⁻¹, wall time: 20.306 seconds; Iteration: 0070, time: 11.907 minutes, Δt: 8.798 seconds, max(|u|) = 3.3e-01 ms⁻¹, wall time: 20.559 seconds; Iteration: 0080, time: 13.374 minutes, Δt: 8.523 seconds, max(|u|) = 3.4e-01 ms⁻¹, wall time: 20.773 seconds; Iteration: 0090, time: 14.794 minutes, Δt: 8.270 seconds, max(|u|) = 3.5e-01 ms⁻¹, wall time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3845:359,test,test,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3845,1,['test'],['test']
Testability,It seems like the animation in the internal wave example isn't displaying properly:. https://clima.github.io/OceananigansDocumentation/stable/generated/internal_wave/. I tested with 2 different browsers. It show up like this on firefox:. ![image](https://user-images.githubusercontent.com/13205162/215351544-f6b82ec2-58e6-4e31-8f89-da86c02d9714.png),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2884:170,test,tested,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2884,1,['test'],['tested']
Testability,It should be pretty easy to adapt `correct_incompressible_immersed_tendencies.jl` to create `correct_shallow_water_immersed_tendencies.jl` to this features to `ShallowWaterModel`. It may also make it easier to test the immersed boundary method as there is no need for a pressure solve in simulating the equations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1458:210,test,test,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458,1,['test'],['test']
Testability,"It was not copying halo regions, which are needed for correct offline diagnostics since `FieldTimeSeries` uses `set!`. Closes #3224 . Thanks very much to @hdrake and @ikeshwani for finding this offline-diagnostics-ruining bug!. I think the implementation of `set!` between `Field`s has waffled over time. We should add a test if we want to ensure this behavior.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3225:321,test,test,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3225,1,['test'],['test']
Testability,It will fail right now but should start passing once #161 is fixed (this test will tell us whether we actually fixed it).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/226:73,test,test,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/226,1,['test'],['test']
Testability,"It's better to use `Field` for boundary conditions rather than `Array` --- this eliminates translation issues when switching architectures (eg CPU, to GPU, to multi-region, to distributed), and also allows diagnostics to be performed directly on the boundary conditions (which isn't always needed, but is very welcome to have available --- for example the spatial derivative of a flux). So, I think we should declare that it's ""best practice"" to use `Field`, not `Array`. To encourage this we should change the docs that show how to use an `Array`:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/boundary_conditions/#.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array. to using a `Field`. Also, we should add correctness tests for using `Field`, which has a bug up until #3287. Curious about @simone-silvestri's input because he has used arrays a lot in boundary conditions. Note that we also are working on support for `FieldTimeSeries` as a boundary condition in #3233 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3298:780,test,tests,780,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3298,1,['test'],['tests']
Testability,Jlk9/enzyme constructor any test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3603:28,test,test,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3603,1,['test'],['test']
Testability,"Just cleaning up some stuff and removing unnecessary cruft: operator temporary fields, forcing fields, density field, and hydrostatic pressure field. This will save us a lot of memory!. Also added a CPU and GPU environment which we can start using for CI testing and local runs. Resolves #65",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/101:255,test,testing,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/101,1,['test'],['testing']
Testability,"Just hacked something together that allows for user-defined forcing functions for the CPU. Have not tested on the GPU yet. Basically there's a struct `Forcing` that stores the user-defined forcing functions. It will replace the old `ForcingFields` struct. See `examples/deep_convection_3d.jl` for how I switched to using a forcing function for T to enforce a cooling surface heat flux. A big issue is that the current implementation slows down the time stepping by a factor of 2-3x. So we'll have to figure out why before merging. The function must have a signature like `F(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k)` right now so this won't produce a nice solution as we will have to figure out #59 before the function signature can look as nice as `surface_cooling_disk(grid, velocities, tracers, i, j, k)`. This is work for another branch. Will keep working on this before merging. Just wanted to start something. Resolves #73",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/85:100,test,tested,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/85,1,['test'],['tested']
Testability,Just realized I left a bug... the solution was initialized with random numbers and as such was not converging some times. This finally solves the issue of the test not passing (hopefully),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2572:159,test,test,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2572,1,['test'],['test']
Testability,"Just so that we could run this validation test with latest Oceananigans. - fix Coriolis, Simulation setting and 2-D initial free-surface in; single face test: surface_gravity_waves_on_face.jl; - fix single face animation: animate_face.jl; - remove ""animate.jl"" (was identical to ""animate_face.jl""); - fix Simulation setting in full cubed test (but more to fix there).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2506:42,test,test,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2506,3,['test'],['test']
Testability,Just some small things from testing free convection with @SandreOuza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/123:28,test,testing,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/123,1,['test'],['testing']
Testability,Just updating the `Manifest.toml` and the Buildkite Julia version number to see if everything passes. I've been using 1.6 fine on my laptop so this should test 1.6 + GPUs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514:155,test,test,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514,1,['test'],['test']
Testability,"Kind of a work-in-progress but would be good to merge as PR #997 depends on these changes. Not the final form of the Buildkite pipeline as I'm still working on improving and expanding it but so far there's an initial job/stage that downloads Julia and instantiates, precompiles, etc. Then all the other jobs can use this new Julia environment to run their tests. Past behavior was just to reuse my Julia environment. I think it's important that CI always creates a fresh environment from scratch as this is how users will install the code usually, and it will help us catch issues like #991 early.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1031:356,test,tests,356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1031,1,['test'],['tests']
Testability,Kind of scary that we don't have tests for this. I wrote some as part of PR #167 but commented them out as I couldn't get them to work (I kept getting some CUDA error). I should make sure to finish that off.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/200:33,test,tests,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/200,1,['test'],['tests']
Testability,"L: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/07/30 10:27:44.108] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/07/30 10:28:25.970] INFO warming up; [2021/07/30 10:29:55.456] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/lwSps/lib/cudadrv/profile.jl:71; [2021/07/30 10:29:58.016] INFO done profiling (GPU, Float64, 128); ==104758== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl; ==104758== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 12.29% 502.36us 5 100.47us 94.015us 103.42us _Z25julia_gpu_ab2_step_field_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE20_gpu_ab2_step_field_16CompilerMetadataI10StaticSizeI15_128__128__128_E12DynamicCheckvv7NDRangeILi3ES5_I11_8__8__128_ES5_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE5Int64S9_S8_IS9_Li3ES10_IS9_Li3ELi1EEES8_IS9_Li3ES10_IS9_Li3ELi1EEE; 9.47% 386.91us 4 96.727us 88.672us 105.02us void regular_fft<unsigned int=128, unsigned int=8, unsigned int=16, padding_t=1, twiddle_t=0, loadstore_modifier_t=2, layout_t=1, unsigned int, double>(kernel_arguments_t<unsigned int>); 6.69% 273.47us 5 54.694us 53.503us 56.800us _Z33julia_gpu_store_field_tendencies_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE28_gpu_store_f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912:1823,test,test,1823,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912,1,['test'],['test']
Testability,"LD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:2379,test,test,2379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,1,['test'],['test']
Testability,LES regression test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/473:15,test,test,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/473,1,['test'],['test']
Testability,"Last TODO item for the JOSS paper. Was going to include the convergence tests as part of `test_verification.jl` but in cleaning them up (mostly by relying on the version of Oceananigans in the repository, `using .ConvergenceTests` as a local module, and making sure legends don't block off the plots) I noticed that the 2D convergence tests are all failing now. Pretty sure this must be a stupid mistake as they were all converging correctly as of Oceananigans v0.30.0 but haven't tried to figure out what went wrong yet... Since they're kinda important now I'm thinking we should have a test job that just runs all the convergence tests, tests that the order of convergence is as expected, and produces all the convergence plots so we can look at them. We can do this once we've set up Buildkite somewhere (see also @simonbyrne's https://github.com/CliMA/slurm-buildkite). Also, @glwagner do we still need `analyze_single_forced_fixed_slip.jl` and `analyze_forced_fixed_slip_pressure.jl`? They're not mentioned in the convergence tests `README.md` so maybe we should remove them?. Resolves #873. # Convergence test plots. ![point_exponential_decay_time_stepper_convergence](https://user-images.githubusercontent.com/20099589/91511129-04753d80-e8ad-11ea-95a9-582b79da9dab.png). ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511137-09d28800-e8ad-11ea-9ac5-f978cd49ae5b.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511140-0b9c4b80-e8ad-11ea-84ce-cb418b1971b0.png). ![gaussian_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511147-0dfea580-e8ad-11ea-8c09-9816a687e67e.png). ![gaussian_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511151-0f2fd280-e8ad-11ea-80c4-8b7920da8d64.png). ![two_dimensional_diffusion_convergence](https://user-images.githubusercontent.com/20099589/91511159-122ac300-e8ad-11ea-877e-251def",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/881:72,test,tests,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881,5,['test'],"['test', 'tests']"
Testability,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/850:12,benchmark,benchmarks,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850,4,['benchmark'],['benchmarks']
Testability,"Launching. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(MPI.COMM_WORLD). # Setup model; topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), extent=(2π, 2π)); c = CenterField(grid). f(x, y, z) = rand(); set!(c, f); cmax = maximum(c); @info ""(function) rank $rank has max|c|: $cmax"". a = rand(size(c)...); set!(c, a); cmax = maximum(c); @info ""(array) rank $rank has max|c|: $cmax""; ```. in a file `test.jl` with. ```; $ JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project test.jl; ```. produces. ```; $ JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project test.jl [18:22:01]; [ Info: (function) rank 0 has max|c|: 0.0; [ Info: (function) rank 1 has max|c|: 0.0; [ Info: (array) rank 0 has max|c|: 0.9891116380008036; [ Info: (array) rank 1 has max|c|: 0.9963683297139798; ```. So `set!` works with `Array` but not functions. `set! for distributed model should be fixed and tested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2350:609,test,test,609,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2350,4,['test'],"['test', 'tested']"
Testability,Let's be real; we need tests. Closes #2223 maybe,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2224:23,test,tests,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2224,1,['test'],['tests']
Testability,Linux CPU+GPU tests are running on Buildkite so we can stop testing on GitLab CI. One less CI pipeline to maintain.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1049:14,test,tests,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1049,2,['test'],"['testing', 'tests']"
Testability,Logging,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478:0,Log,Logging,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478,1,['Log'],['Logging']
Testability,Logging with crayons,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/855:0,Log,Logging,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855,1,['Log'],['Logging']
Testability,Logging.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71:0,Log,Logging,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71,1,['Log'],['Logging']
Testability,Logic for arguments to time-stepping related functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/448:0,Log,Logic,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/448,1,['Log'],['Logic']
Testability,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/188:23,benchmark,benchmarks,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188,3,['benchmark'],['benchmarks']
Testability,Looking at the latest Buildkite build for the master branch it looks like GPU CI is only running CPU tests: https://buildkite.com/clima/oceananigans/builds/3045. Not sure why this would be the case... `CUDA.versioninfo()` seems to return the expected info on Sverdrup during initialization: https://buildkite.com/clima/oceananigans/builds/3045#ad4268d2-9b56-4cc0-ab46-ab9fdd61527b/31-253. I wonder if `CUDA.has_cuda()` is returning `false` on Sverdrup for some weird reason? https://github.com/CliMA/Oceananigans.jl/blob/dfc028667493bdd0eb1056d66d287c46e2591a7f/test/runtests.jl#L56,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1794:101,test,tests,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1794,2,['test'],"['test', 'tests']"
Testability,Looks like the velocity field is now fully incompressible over time but we need better tests to show this. Will merge once tests are implemented. Fully resolves #161. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/229:87,test,tests,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/229,2,['test'],['tests']
Testability,"MWE ; ```julia; grid = RectilinearGrid(size = (5, 5, 5), extent = (1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); c = CenterField(grid; indices = (:, :, grid.Nz)); d = CenterField(grid); JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ```; fails with ; ```julia; julia> JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3835:242,test,test,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835,2,['test'],['test']
Testability,Major refactor of TurbulenceClosures module plus more tests for HydrostaticFreeSurfaceModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1449:54,test,tests,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449,1,['test'],['tests']
Testability,Makes SEAPICKLE! a bona fide Julia package. And adds a test.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3:55,test,test,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3,1,['test'],['test']
Testability,"Many models of size (16, 16, 16) are reduced to size (1, 1, 1). Oftentimes the test just executes a time-step to ensure there's no error. For this, a size (1, 1, 1) is sufficient.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/937:79,test,test,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/937,1,['test'],['test']
Testability,"Maybe this has already been extensively discussed but the GPU test suites on Buildkite fail often, requiring manual intervention to restart them for each PR. The obvious solution is a bigger machine for testing, but I have two suggestions that are much easier to implement:; 1. Updating Buildkite. Newer versions may be more stable. The latest version is 3.79 but Sverdrup is on v3.24.0 (almost 4 years old) and Tartarus is on v3.50.4.; 2. If builds are failing due to too much resource competition, reducing the number of Buildkite agents on Sverdrup may help. Right now there are 16. I wonder if GPU builds will be more stable with 8-12. Some builds may be slower but if no one has to restart a test suite then that would make for a better developer experience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3751:62,test,test,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3751,3,['test'],"['test', 'testing']"
Testability,MepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs); [A fourth-order Cartesian grid embedded boundary method for Poisson's equation](https://msp.org/camcos/2017/12-1/camcos-v12-n1-p03-s.pdf); [A New Terrain-Following Vertical Coordinate Formulation for Atmospheric Prediction Models](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml); [Comparison of Terrain-Following and Cut-Cell Grids Using a Nonhydrostatic Model](https://journals.ametsoc.org/view/journals/mwre/144/6/mwr-d-15-0226.1.xml); [Large-eddy simulations with ClimateMachine v0.2.0: a new open-source code for atmospheric simulations on GPUs and CPUs](https://gmd.copernicus.org/articles/15/6259/2022/); [Medium range forecasts using cut-cells: a sensitivity study](https://link.springer.com/article/10.1007/s00703-019-00681-w); [On methods for solving the oceanic equations of motion in generalized vertical coordinates](https://www.sciencedirect.com/science/article/abs/pii/S1463500305000090); [Representation of topography by porous barriers and objective interpolation of topographic data](https://www.sciencedirect.com/science/article/pii/S1463500313000425); [Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml); [Rescaled height coordinates for accurate representation of free-surface flows in ocean circulation models](https://www.sciencedirect.com/science/article/abs/pii/S1463500303000544); [Sliding or stumbling on the staircase: numerics of ocean circulation along piecewise-constant coastlines](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2022MS003594); ```[tasklist]; ### Tasks; - [ ] Tracer advection over seamount test case; - [ ] Two-dimensional implementation of `CutCellBottom`; - [ ] Three-dimensional implementation of `CutCellBottom`; - [ ] Merging of cells with small area (2D) or volume (3D) for cut cells; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123:4130,test,test,4130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123,1,['test'],['test']
Testability,Mid-Level Enzyme + Oceananigans Integration Test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3346:44,Test,Test,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3346,1,['Test'],['Test']
Testability,"Might be useful at the REPL for interactive stuff cause you can write. ```julia; julia> N² = compute!(α * ∂z(T) - β * ∂z(S)); ```. for example. If people like, I'll add docs and a test or two. I guess the equivalent one-liner right now is. ```julia; julia> N² = @compute Field(α * ∂z(T) - β * ∂z(S)); ```. and the equivalent two-liner is. ```julia; julia> N² = Field(α * ∂z(T) - β * ∂z(S)); julia> compute!(N²); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235:180,test,test,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235,1,['test'],['test']
Testability,Might not be enough so let's check. I think maybe `GridFittedBottom` and `GridFittedBoundary` need to know about `Flat` too?. Should add a test too. @simone-silvestri ; @raphaelouillon. Closes #2479,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2532:139,test,test,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2532,1,['test'],['test']
Testability,Might not end up being merged but testing if using shared memory for the `calculate_interior_source_terms` kernel via GPUifyLoop's `@stencil` abstraction improves performance for register-heavy kernels. We can use #289 to benchmark. Reliant on https://github.com/vchuravy/GPUifyLoops.jl/issues/85.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/293:34,test,testing,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/293,2,"['benchmark', 'test']","['benchmark', 'testing']"
Testability,Model verification tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81:19,test,tests,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81,1,['test'],['tests']
Testability,Modify `test_dynamics.jl` to includes tests for `ShallowWaterModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1448:38,test,tests,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1448,1,['test'],['tests']
Testability,More benchmarks,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/300:5,benchmark,benchmarks,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/300,1,['benchmark'],['benchmarks']
Testability,More comprehensive testing for immersed boundaries,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1937:19,test,testing,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1937,1,['test'],['testing']
Testability,More powerful and elegant benchmarking framework,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1088:26,benchmark,benchmarking,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088,1,['benchmark'],['benchmarking']
Testability,"More proper MPI etiquette, overlapping halo communication, and better scaling benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505:78,benchmark,benchmarks,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505,1,['benchmark'],['benchmarks']
Testability,More tests for boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2103:5,test,tests,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103,1,['test'],['tests']
Testability,More unit tests and comprehensive GPU testing.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/134:10,test,tests,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/134,2,['test'],"['testing', 'tests']"
Testability,Most of the convergence tests run in a reasonable amount of time except for a few:. For example: https://buildkite.com/clima/oceananigans-validation-experiments/builds/137. * CPU Gaussian advection-diffusion: ~2:40 hours; * GPU Gaussian advection-diffusion: ~1:45 hours; * CPU forced flow free-slip: ~8 hours. I think for the Gaussian advection-diffusion tests we can just reduce the number of iterations. Some tests run for 26214 iterations. Not sure why the CPU forced flow free-slip is so slow though. It's a 2D simulation. The CPU forced flow fixed-slip is similar I think and takes only ~20 minutes.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1420:24,test,tests,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1420,3,['test'],['tests']
Testability,Most of the sandbox scripts are very stale and could be misleading so I'm nuking them. Simulation scripts should go in respective repositories at this point. Sandbox scripts that are worth making into examples can go into `examples/`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/367:12,sandbox,sandbox,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/367,2,"['Sandbox', 'sandbox']","['Sandbox', 'sandbox']"
Testability,Move Enzyme extension tests to dedicated test group,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3347:22,test,tests,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3347,2,['test'],"['test', 'tests']"
Testability,"Moving a discussion from the slack channel here. . Basically I think it would be useful to have a way to compute averages inside a subset of the domain. From what I get understand from the discussion there are two ways to do this:. - Allowing to pass something like a `FieldSlicer` to `AveragedField`, which would then slice the field before computing the average. This was my original idea, but according to @glwagner it might be tricky.; - Creating something like `WindowedSpatialAverage`, for this purpose specifically. @glwagner suggested something like (not tested):. ```julia; struct WindowedSpatialAverage{F, I, J, K, D}; field :: F; i :: I; j :: J; k :: K; dims :: D; end. WindowedSpatialAverage(field; dims, i=Colon(), j=Colon(), k=Colon()) = WindowedSpatialAverage(field, i, j, k, dims). function (wsa::WindowedSpatialAverage)(model); compute!(wsa.field); window = view(data(wsa.field), wsa.i, wsa.j, wsa.k); return mean(window, dims=wsa.dims); end; ```. CC: @glwagner @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392:563,test,tested,563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392,1,['test'],['tested']
Testability,Multithreading benchmarks,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/869:15,benchmark,benchmarks,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/869,1,['benchmark'],['benchmarks']
Testability,Must not be tested.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3871:12,test,tested,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3871,1,['test'],['tested']
Testability,"My fault, must have messed up and forgot to skip `_apply_*_bcs!` for `NotFluxBC` in PR #631. . Fixes #675 and should fix failing tests on PR #671. Before:; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 24.3s / 2.17% 1.83GiB / 18.1% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 256ms 48.6% 25.6ms 170MiB 50.0% 17.0MiB; 32× 32× 32 [CPU, Float64] 10 270ms 51.4% 27.0ms 170MiB 50.0% 17.0MiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. After:; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 126s / 62.8% 1.46GiB / 0.13% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 39.4s 49.9% 3.94s 1.00MiB 50.0% 102KiB; 32× 32× 32 [CPU, Float64] 10 39.5s 50.1% 3.95s 1.00MiB 50.0% 102KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. Unfortunately still a bit higher than v0.22.0 (~50 KiB allocations) but much better and more acceptable than 17 MiB!. Remaining memory allocations seem to be occuring in `fill_halo_regions.jl` but tried inlining some functions and didn't help so I'll revisit the problem in the future. ```; julia> analyze_malloc("".""); 323-element Array{CoverageTools.MallocInfo,1}: ; ⋮ ; CoverageTools.MallocInfo(5008, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 36) ; CoverageTools.MallocInfo(5952, ""./benchmark/benchmark_utils.jl.32885.mem"", 35) ; CoverageTools.MallocInfo(6080, ""./src/TimeSteppers/time_stepping_kernels.jl.32885.mem"", 139) ; Cove",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/685:129,test,tests,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685,3,"['benchmark', 'test']","['benchmarks', 'tests']"
Testability,"N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107256,test,test,107256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"NING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_ru",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:17771,test,test,17771,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,Need more tests for `single_column_model_mode` and `slice_ensemble_model_mode`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2219:10,test,tests,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2219,1,['test'],['tests']
Testability,Need test for (Cu)Array of `IsopycnalSkewSymmetricDiffusivity` closures,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2258:5,test,test,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2258,1,['test'],['test']
Testability,Need test for non-trivial fluxes along two boundaries,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1938:5,test,test,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1938,1,['test'],['test']
Testability,Need to add some tests before merging though. cc @tomchor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1260:17,test,tests,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1260,1,['test'],['tests']
Testability,Need to test that time stepping works with all diffusivity closures,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/539:8,test,test,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/539,1,['test'],['test']
Testability,New Benchmarks,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:4,Benchmark,Benchmarks,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['Benchmark'],['Benchmarks']
Testability,New Threaded Benchmark Scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881:13,Benchmark,Benchmark,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881,1,['Benchmark'],['Benchmark']
Testability,New benchmarking framework,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169:4,benchmark,benchmarking,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169,1,['benchmark'],['benchmarking']
Testability,New plots for convergence test using Plots.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276:26,test,test,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276,1,['test'],['test']
Testability,New strategy for defining architecture in distributed tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3880:54,test,tests,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3880,1,['test'],['tests']
Testability,"Not sure if the bug label is appropriate here but `ShallowWaterModel` is instantiated with uh = vh = h = 0 and the tendencies have 1/h terms in them so time stepping this ""empty"" shallow water model leads to blow up. This is generally fine: if you time-step a nonsensical model it should blow up. The issue is that we add a NaN checker by default (which will still be there in #1138) so the shallow water time stepping tests keep triggering the NaN checker and failing. Should we just disable NaN checking for these tests by removing the NaN checker via `delete!(simulation.diagnostics, :nan_checker)`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1262:419,test,tests,419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1262,2,['test'],['tests']
Testability,Noticed this because `test_diffusion_cosine` was failing in PR #462. We should have that `length(zC) == Nz` but; ```julia; julia> Nz = 16; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 16. julia> Nz = 32; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 32. julia> Nz = 64; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 63. julia> Nz = 128; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 127. julia> Nz = 256; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 255; ```. Looks like a scary effect of round-off error to me. I'll make the switch to using the `range` function with a fixed `length` and add a test to check for this.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/480:667,test,test,667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/480,1,['test'],['test']
Testability,Nuke broken tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/368:12,test,tests,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/368,1,['test'],['tests']
Testability,Nuke sandbox,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/367:5,sandbox,sandbox,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/367,1,['sandbox'],['sandbox']
Testability,Nuke vertically stretched sandbox,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1395:26,sandbox,sandbox,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395,1,['sandbox'],['sandbox']
Testability,"Nukes Couette and Lid-driven flows, and reintroduces figures for convergence tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797:77,test,tests,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797,1,['test'],['tests']
Testability,Number of tests went down as a lot of them were regression tests between the three different sets of operators. But we will rebuild.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/96:10,test,tests,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/96,2,['test'],['tests']
Testability,"Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> model_mat = HydrostaticFreeSurfaceModel(grid = grid,; momentum_advection = nothing,; free_surface = ImplicitFreeSurface(solver_method=:HeptadiagonalIterativeSolver,; tolerance = 1e-15)); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 1×1×1 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> typeof(model_pcg.free_surface.implicit_step_solver.right_hand_side); Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}. julia> typeof(model_mat.free_surface.implicit_step_solver.right_hand_side); Vector{Float64} (alias for Array{Float64, 1}); ```. If this is OK then we need to drop `interior()` from the `right_hand_side` at:; https://github.com/CliMA/Oceananigans.jl/blob/4f730161c8ea189779eed8c3b56961065f7699d3/test/test_implicit_free_surface_solver.jl#L111. cc: @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2184:3413,test,test,3413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2184,1,['test'],['test']
Testability,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2222:27,test,tests,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222,2,['test'],"['test', 'tests']"
Testability,"Okay, so I'm just gonna throw this out there: is it advantageous to migrate the Poisson solvers to a separate package (PoissonSolvers.jl)? It would be akin to the relationship between PencilFFTs.jl and PencilArrays.jl. I've been thinking about it for the past few days and I can see some pros:. - Separating the code can make Oceananigans easier to maintain:; - fewer things to test in every PR (the tests are becoming larger and larger and apparently we're starting to have backlogs on buildkite); - fewer lines/modules in general can make it easier to make sense of the code, especially for beginner users/contributors (in general the smaller the code base, the easier it is to attract contributors). Also having (brief) docs just for the solvers would be a very useful reference in general imho.; - Efficient Poisson solvers are hard to write and it's an art of their own since different BCs generally require different algorithms. With that said, having a separate package just for that might not only benefit the community (a quick google search for something like ""poisson solver julia"" shows that there's interest) but also it might make it easier for someone who needs a specific algorithm that we don't yet have to make a contribution that might help us. That said, I've never touched the Poisson solvers in Oceananigans so I don't know how ""portable"" they are, or if there are significant disadvantages. So some feedback here would be helpful. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1553:378,test,test,378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553,2,['test'],"['test', 'tests']"
Testability,"On main we are passing the tendency kernel function as an argument to the kernel. ; Apparently, this prevents compilation on the CPU.; Another place where this design was implemented is the vertically implicit solver, where we pass functions to calculate the tridiagonal matrix coefficients. This PR fixes both problems. After this PR we should remember that we cannot pass functions as kernel arguments, ; not even as properties of a struct! Instead we can pass `Val(:function_name)` and dispatch on that to call the correct `function_name` (as implemented in this PR for the vertically implicit solver). Baroclinic adjustment test (with `Nx = Ny = 128, Nz = 10`); on main:; ```julia; [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 870.922 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 16.500 minutes; [ Info: ... simulation initialization complete (957.942 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (19.178 seconds).; [15.28%] i: 20, t: 5.500 hours, wall time: 1.732 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 18.150 minutes; [32.08%] i: 40, t: 11.550 hours, wall time: 1.376 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 19.965 minutes; [50.57%] i: 60, t: 18.205 hours, wall time: 1.333 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 20 minutes; [69.09%] i: 80, t: 1.036 days, wall time: 1.219 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 20 minutes; [87.61%] i: 100, t: 1.314 days, wall time: 1.175 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 20 minutes; [ Info: Simulation is stopping after running for 7.623 minutes.; [ Info: Simulation time 1.500 days equals or exceeds stop time 1.500 days.; ```. on this PR:; ```julia; [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 9.474 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 16.500 minutes; [ Info: ... simulation in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030:628,test,test,628,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030,1,['test'],['test']
Testability,Only run GPU tests on GPU CI builds,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/758:13,test,tests,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/758,1,['test'],['tests']
Testability,Only test Mac OSX on Travis now,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/933:5,test,test,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/933,1,['test'],['test']
Testability,Out of memory error with Docs tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779:30,test,tests,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779,1,['test'],['tests']
Testability,"OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 8",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:102666,Test,Test,102666,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,Overleaf documentation reflects this but not the code itself. This is the analytic solution we're testing against: https://en.wikipedia.org/wiki/Taylor%E2%80%93Green_vortex#Taylor%E2%80%93Green_vortex_solution,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/468:98,test,testing,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/468,1,['test'],['testing']
Testability,"Overturning, eddying channel validation test following Abernathey et al. 2011",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744:40,test,test,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744,1,['test'],['test']
Testability,"PL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.1.0+0; [781609d7] GMP_jll v6.2.1+6; [deac9b47] LibCURL_jll v8.4.0+0; [e37daf67] LibGit2_jll v1.6.4+0; [29816b5a] LibSSH2_jll v1.11.0+1; [c8ffd9c3] MbedTLS_jll v2.28.2+1; [14a3606d] MozillaCACerts_jll v2023.1.10; [4536629a] OpenBLAS_jll v0.3.23+4; [05823500] OpenLibm_jll v0.8.1+2; [efcefdf7] PCRE2_jll v10.42.0+1; [bea87d4a] SuiteSparse_jll v7.2.1+1; [83775a58] Zlib_jll v1.2.13+1; [8e850b90] libblastrampoline_jll v5.8.0+1; [8e850ede] nghttp2_jll v1.52.0+1; [3f19e933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:11769,Test,Testing,11769,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,2,"['Test', 'test']","['Testing', 'tests']"
Testability,"PR #2121 changed some function signatures, which broke functionality provided by `single_column_model_mode.jl` that sets `model.free_surface = nothing`. This PR restores that functionality. I think we could add a test, but the experimental nature of `single_column_model_mode.jl` could also mean it'd be better to wait.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2152:213,test,test,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2152,1,['test'],['test']
Testability,PR #3668 Introduced ambiguity for `TracerAdvection` on `ImmersedBoundaryGrid`s; This PR removes the ambiguity and adds a test to make sure this method is tested,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3696:121,test,test,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3696,2,['test'],"['test', 'tested']"
Testability,"PR co-authored with @sandreza . This PR tests Oceananigans with the Pearson vortex test from p. 310 of ""Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Application"" by Hesthaven & Warburton. Error after 100 time steps:; ```julia; i: 100, t: 0.008, Δu: (avg=0.000224, max=0.000224), Δw: (avg=0.000224, max=0.000224); ```; which compares well with the DG error (considering our low-order numerics). We discovered that recomputing w from continuity breaks this test because du/dx = 0 and dv/dy = 0 by construction so w = 0 even though this is wrong. This is probably because we need to impose Neumann boundary condition on w, but recomputing w from continuity requires us to assume the value of `w[i, j, :]`, which we take to be 0 since we usually run with a rigid lid. So we switched to explicitly time stepping w which means this PR is ""DO NOT MERGE"" is its current state. Note: Before the test is merged, more comments are needed in the pearson vortex test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336:40,test,tests,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336,5,['test'],"['test', 'tests']"
Testability,"PR for discussion of changes to main. There are some things that can go in soon, others may require more work. . Note . - Julia AMD GPU stack (AMDGPU.jl, KernelAbstractions.jl) needs 1.7 Julia at least.; - Currently AMDGPU.jl works against ROCM 4.2. More recent ROCM 5 has LLVM that is ahead of Julia 1.7, so that breaks things! ; - people who are working on relevant Julia support include @jpsamaroo @vchuravy @luraess and @matinraayai .... What fun! . A buildkite test is here ( https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/.buildkite/pipeline.yml#L496 ) which gives some clues on what is needed to run something on MI50.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2540:466,test,test,466,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2540,1,['test'],['test']
Testability,"PRs #1935 and #1936 fix bugs associated with `ImmersedBoundaryGrid`: the first is a functionality bug that needs a detailed functionality test to catch (for example, testing that budgets are correct with immersed boundaries); the second fixes a more trivial issue with dispatch. We have a small number of immersed boundary tests; however we need a more comprehensive suite of tests to ensure that immersed boundaries are compatible with various closures and advection schemes. I think we should use the hydrostatic model for these tests for the time being, because immersed boundaries with non hydrostatic models are still experimental and under development. cc @whitleyv @jm-c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1937:138,test,test,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1937,5,['test'],"['test', 'testing', 'tests']"
Testability,Pair programming with @francispoulin we figured out that the pressure solvers are not tested for `Flat` topologies which might be causing #1554. This PR just adds a warning about this until the pressure solvers properly support `Flat`. Resolves #1554 (?),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1556:86,test,tested,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1556,1,['test'],['tested']
Testability,"Partly an eyeball test for the channel, partly a source of new movies!. ![channel_plot_300000_cropped](https://user-images.githubusercontent.com/20099589/60388805-7b822c80-9a84-11e9-9fb6-05aca5a268b8.png). Doesn't look horrible but probably needs higher more grid points, lower grid cell aspect ratio, better advection scheme, and/or LES closure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/301:18,test,test,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/301,1,['test'],['test']
Testability,Pearson vortex test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336:15,test,test,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336,1,['test'],['test']
Testability,Perform some of the grid tests on GPU as well,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3054:25,test,tests,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3054,1,['test'],['tests']
Testability,Performance benchmarks section of the README is super out of date,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3684:12,benchmark,benchmarks,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684,1,['benchmark'],['benchmarks']
Testability,Performance benchmarks section of the README wrongly says we don't support `Distributed`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3758:12,benchmark,benchmarks,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3758,1,['benchmark'],['benchmarks']
Testability,Performance testing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3492:12,test,testing,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492,1,['test'],['testing']
Testability,"Perhaps we can split the `.jl` file, e.g., put these:. https://github.com/CliMA/Oceananigans.jl/blob/c71770c10f40ebd0789491a33bbb3f8b4f6de14a/test/test_poisson_solvers.jl#L280-L312. in a different script and on their own buildkite process?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2183:142,test,test,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2183,1,['test'],['test']
Testability,Physics tests for channel or box models with analytic solutions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/158:8,test,tests,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/158,1,['test'],['tests']
Testability,Physics tests for doubly-periodic domains with analytic solutions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/157:8,test,tests,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/157,1,['test'],['tests']
Testability,Physics tests with analytic solutions for the statistics,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/159:8,test,tests,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/159,1,['test'],['tests']
Testability,Plots and fixes for benchmarks,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1746:20,benchmark,benchmarks,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746,1,['benchmark'],['benchmarks']
Testability,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1746:35,benchmark,benchmarking,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746,7,"['Benchmark', 'benchmark']","['Benchmarks', 'benchmark', 'benchmarked', 'benchmarking']"
Testability,Plus a simple test with a plankton growth/death model similar to `examples/convecting_plankton.jl`. TODO:; * [x] Add the interface to `HydrostaticFreeSurfaceModel`; * [x] Better interface for defining the biogeochemical source function; * [x] Better interface for automagically adding biogeochemical tracers?. With @jagoosw,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802:14,test,test,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802,1,['test'],['test']
Testability,"Plus some cleanup of input validation, and a test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/508:45,test,test,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/508,1,['test'],['test']
Testability,Poisson solver test: recovery of an analytic solution.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/227:15,test,test,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/227,1,['test'],['test']
Testability,Poisson solver tests on GPU still take too long,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2183:15,test,tests,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2183,1,['test'],['tests']
Testability,Poisson solver tests use `CenterField` to represent fields at Faces,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1867:15,test,tests,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1867,1,['test'],['tests']
Testability,Portable random number generator for testing.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/176:37,test,testing,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/176,1,['test'],['testing']
Testability,PressureField and tests for AveragedFields and ComputedFields in operations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/956:18,test,tests,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/956,1,['test'],['tests']
Testability,Pretty important so we can turn on the second golden master test!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/219:60,test,test,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/219,1,['test'],['test']
Testability,Previously if you ran `benchmark_regression.jl` it'll run the benchmarks but not print any useful results. This PR prints some benchmark results to make it a useful benchmarking script.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1214:62,benchmark,benchmarks,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1214,3,['benchmark'],"['benchmark', 'benchmarking', 'benchmarks']"
Testability,"Previously the functions viscous_flux_u* and diffusive_flux_* dispatched on AbstractPrimaryGrid. AbstractPrimaryGrid (now called AbstractUnderlyingGrid is an abstract type for distinguishing between ImmersedBoundaryGrid and the ""primitive"" / ""primary"" / ""underlying"" counterparts (I guess I'm still not sure what the best name is). As a result, flux calculations with ImmersedBoundaryGrid were hitting fallback flux functions that returned 0. This PR removes most instances dispatching on grid (except where necessary, where the dispatched type was changed from AbstractPrimaryGrid to AbstractGrid). It also nukes the fallbacks (which were the reason this issue escaped detection originally). This PR also adds a minimal test that _vertical_ diffusive and viscous fluxes work. It does not test the horizontal fluxes, but the test will catch egregious bugs like the one this PR fixes. The original motivation for dispatching on AbstractPrimaryGrid is not only wrong but also appears to be unnecessary, since the tests on this PR pass. For some reason TwoDimensionalLeith was also having trouble compiling on the GPU, so we're skipping those tests for now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1835:721,test,test,721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1835,5,['test'],"['test', 'tests']"
Testability,Print system info before running tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1180:33,test,tests,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1180,1,['test'],['tests']
Testability,"Probably as a result of PR #3847, on the `main` branch precompiation fails due to some method overwriting. This may be harmless as all tests passed anyways, e.g. see the log from the last test of PR #3847: https://buildkite.com/clima/oceananigans/builds/18103#0192adf8-82f6-48e6-b72e-131502fdfcfc/26-746. But maybe there are some performance implications?. Output when running `using Oceananigans`:; ```; julia> using Oceananigans; Precompiling Oceananigans; Info Given Oceananigans was explicitly requested, output will be shown live ; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; ? Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; [ Info: Skipping preco",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3851:135,test,tests,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851,3,"['log', 'test']","['log', 'test', 'tests']"
Testability,"Probably makes sense to split `output_writers.jl`, `diagnostics.jl`, and `poisson_solvers.jl` into submodules. They're turning into megafiles that will benefit from being split into smaller logical chunks. And this will probably only get worse with time.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/495:190,log,logical,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/495,1,['log'],['logical']
Testability,Profiling MPI and benchmarking strong + weak scaling,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1451:18,benchmark,benchmarking,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1451,1,['benchmark'],['benchmarking']
Testability,Quick fixes as I recklessly merged a _non-test-passing_ PR,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2201:42,test,test-,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2201,1,['test'],['test-']
Testability,Quick test tells me everything works with latest CUDA packages which just got released but will have to refactor a bit to make use of GPUifyLoop's new `@launch` functionality (and remove the `@setup` calls).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/153:6,test,test,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153,1,['test'],['test']
Testability,Rayleigh-Benard regression test with forcing and passive tracer,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239:27,test,test,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239,1,['test'],['test']
Testability,Reduce the size of the eady_turbulence.jl script test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1058:49,test,test,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1058,1,['test'],['test']
Testability,Refactor of some stretched rectilinear grid tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2917:44,test,tests,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2917,1,['test'],['tests']
Testability,Regenerate LES regression test data,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/943:26,test,test,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/943,1,['test'],['test']
Testability,Regenerate regression test data following reversal of `k` index,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/526:22,test,test,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/526,1,['test'],['test']
Testability,Regression test for CATKE,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3762:11,test,test,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3762,1,['test'],['test']
Testability,Regression test for Hydrostatic free surface model,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2031:11,test,test,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031,1,['test'],['test']
Testability,Regression test on the latitude longitude grid ; - Hydrostatic free surface model; - only tested the explicit free surface ; - both periodic and bounded latitude topology tested. Comments; - at the moment the data is generated on the fly at tests/test_regression.jl on the CPU() and tested on the GPU(); - explore the option to load the data in OceananigansArtifacts.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2031:11,test,test,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031,5,['test'],"['test', 'tested', 'tests']"
Testability,Regression test(s) for `SplitExplicitFreeSurface`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3335:11,test,test,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3335,1,['test'],['test']
Testability,Regression tests for models with LES closures,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/479:11,test,tests,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/479,1,['test'],['tests']
Testability,Regression tests for models with LES closures (round 2),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/484:11,test,tests,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/484,1,['test'],['tests']
Testability,Regression tests for the Distributed module,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328:11,test,tests,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328,1,['test'],['tests']
Testability,"Release notes:. * Tests and fixes for `FFTBasedPoissonSolver` for topologies with `Flat` dimensions (#1560); * Improved `AbstractOperations` that are much more likely to compile on the GPU, with better ""location inference"" for `BinaryOperation` (#1595, #1599)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1600:18,Test,Tests,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1600,1,['Test'],['Tests']
Testability,Rename Pearson vortex test to Taylor-Green vortex,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/468:22,test,test,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/468,1,['test'],['test']
Testability,"Reported by @sandreza . Must have missed this (or tests didn't cover this case) in PR https://github.com/CliMA/Oceananigans.jl/pull/851. <img width=""1324"" alt=""Screen Shot 2020-08-21 at 5 45 54 PM"" src=""https://user-images.githubusercontent.com/20099589/90943555-4ce1b680-e3e8-11ea-8831-e3d66509adf6.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/864:50,test,tests,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/864,1,['test'],['tests']
Testability,"Reported in PR #666. Might be serious enough that it is slowing down documentation building in PR #671. ```; Julia Version 1.3.1; Commit 2d5741174c (2019-12-30 21:36 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-6.0.1 (ORCJIT, skylake); GPU: TITAN V. ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 173s / 51.2% 43.6GiB / 64.5% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 127ms 0.14% 12.7ms 170MiB 0.59% 17.0MiB; 32× 32× 32 [CPU, Float64] 10 153ms 0.17% 15.3ms 170MiB 0.59% 17.0MiB; 32× 32× 32 [GPU, Float32] 10 24.4ms 0.03% 2.44ms 10.0MiB 0.03% 1.00MiB; 32× 32× 32 [GPU, Float64] 10 24.2ms 0.03% 2.42ms 10.0MiB 0.03% 1.00MiB; 64× 64× 64 [CPU, Float32] 10 713ms 0.81% 71.3ms 676MiB 2.35% 67.6MiB; 64× 64× 64 [CPU, Float64] 10 868ms 0.98% 86.8ms 676MiB 2.35% 67.6MiB; 64× 64× 64 [GPU, Float32] 10 24.8ms 0.03% 2.48ms 10.0MiB 0.03% 1.00MiB; 64× 64× 64 [GPU, Float64] 10 25.2ms 0.03% 2.52ms 10.0MiB 0.03% 1.00MiB; 128×128×128 [CPU, Float32] 10 5.22s 5.90% 522ms 2.64GiB 9.39% 270MiB; 128×128×128 [CPU, Float64] 10 5.44s 6.14% 544ms 2.64GiB 9.39% 270MiB; 128×128×128 [GPU, Float32] 10 46.3ms 0.05% 4.63ms 10.0MiB 0.03% 1.00MiB; 128×128×128 [GPU, Float64] 10 45.6ms 0.05% 4.56ms 10.0MiB 0.03% 1.00MiB; 256×256×256 [CPU, Float32] 10 37.4s 42.3% 3.74s 10.5GiB 37.5% 1.05GiB; 256×256×256 [CPU, Float64] 10 37.7s 42.6% 3.77s 10.5GiB 37.5% 1.05GiB; 256×256×256 [GPU, Float32] 10 338ms 0.38% 33.8ms 10.0MiB 0.03% 1.00MiB; 256×256×256 [GPU, Float64] 10 336ms 0.38% 33.6ms 10.0MiB 0.03% 1.00MiB; ──────────────────────────────────────────────────────────────────────────────────────; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/675:458,benchmark,benchmarks,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/675,1,['benchmark'],['benchmarks']
Testability,Resolves #1027; Resolves #1252. ~~Needs tests.~~,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1259:40,test,tests,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1259,1,['test'],['tests']
Testability,Resolves #1113 . Needs new multi-threading benchmarks. Will do as part of #1088 (need to add nice multithreading benchmark script on `ar/benchmarks` branch).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1120:43,benchmark,benchmarks,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1120,3,['benchmark'],"['benchmark', 'benchmarks']"
Testability,"Resolves #1452 . Example:. ```julia; julia> using Oceananigans. julia> using Oceananigans.AbstractOperations: GridMetric. julia> grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (1.0, 1.0, 1.0). julia> Δz = GridMetric{Center, Center, Center}(Oceananigans.Operators.Δzᵃᵃᶜ, grid); GridMetric at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; GridMetric at (Center, Center, Center). julia> c = CenterField(CPU(), grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (3, 3, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux). julia> c_dz = c * Δz; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Center, Center, Center);    ├── Field located at (Center, Center, Center);    └── GridMetric at (Center, Center, Center); ```. TODO:. - [x] Add `architecture(grid)` for grids other than `RegularRectilinearGrid`.; - [x] Tests; - [x] Explore the possibility of special objects `Δx, Δy, Δz` that infer `BinaryOperation` location and create appropriate `GridMetric` operations at appropriate locations automagically.; - [x] I don't think we need `Difference` as proposed on #1452, but if others disagree we can add them here. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1607:1636,Test,Tests,1636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1607,1,['Test'],['Tests']
Testability,Resolves #1512. Needs tests. Docstring for `FieldSlicer` could probably be spruced up too.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1526:22,test,tests,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1526,1,['test'],['tests']
Testability,Resolves #1629 . TODO:. - [x] Perhaps a test?; - [x] OK from @ali-ramadhan that we bypass compute_and_slice_output for `LagrangianParticles`. cc @tomchor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1631:40,test,test,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1631,1,['test'],['test']
Testability,"Resolves #1702 noticed by @mukund-gupta . In a [previous PR](https://github.com/CliMA/Oceananigans.jl/commit/3afd5b59fce91f9ab4aa6d0d19cd64fef7aea4cf#) we changed the notation of the closure term to indicate that it's the divergence of a flux, rather than specifically the divergence of a _viscous_ or _diffusive_ flux. This notational change required us to change the term's sign. Specifically, we used the redefinition. ```; ∂ⱼ_2ν_Σ₁ⱼ = - ∂ⱼ_τ₁ⱼ; ```. for the diffusive flux of x-momentum. However, we did not change the sign of the flux divergence for `AnisotropicBiharmonicDiffusivity`; we only changed the _name_ of the term. This PR corrects the sign error. There are a few closures that don't have regression tests and this highlights the danger of that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1703:716,test,tests,716,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1703,1,['test'],['tests']
Testability,Resolves #1794 . We should also come up with a more permanent solution (perhaps another environment variable to toggle GPU-CI) that throws an error if GPU tests can't run on the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799:155,test,tests,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799,1,['test'],['tests']
Testability,Resolves #2061 . Todo:. - [x] Add a test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2062:36,test,test,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2062,1,['test'],['test']
Testability,Resolves #2106 . TODO:. - [x] Test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2108:30,Test,Test,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2108,1,['Test'],['Test']
Testability,Resolves #2581. Maybe we should test this?. cc @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582:32,test,test,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582,1,['test'],['test']
Testability,Resolves #3771. Not sure where to add tests for this though. Do we need a `test_immersed_grids.jl`?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3776:38,test,tests,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3776,1,['test'],['tests']
Testability,Resolves #578 ; Updates runtests to use the ModelLogger; Updates tests to use @info instead of println,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/585:65,test,tests,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/585,1,['test'],['tests']
Testability,"Resolves https://github.com/CliMA/Oceananigans.jl/issues/3750. Also supercedes #3794 where some tests are failing, not sure why. But that PR goes a bit further to clean up conditional ops. I think we want that too but let's start with this. cc @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3801:96,test,tests,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3801,1,['test'],['tests']
Testability,Restore netCDF output writer tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3167:29,test,tests,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3167,1,['test'],['tests']
Testability,Return statement in a test seems incomplete,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2135:22,test,test,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135,1,['test'],['test']
Testability,"Revert ""Adding norm for fields with some tests.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1562:41,test,tests,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1562,1,['test'],['tests']
Testability,"Revert ""Cut down the examples. Moved stuff into a sandbox.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/231:50,sandbox,sandbox,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/231,1,['sandbox'],['sandbox']
Testability,"Revert ""Revert ""Cut down the examples. Moved stuff into a sandbox.""""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/232:58,sandbox,sandbox,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/232,1,['sandbox'],['sandbox']
Testability,"Revert ""Updating Benchmark Docs""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1950:17,Benchmark,Benchmark,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1950,1,['Benchmark'],['Benchmark']
Testability,"Reverts CliMA/Oceananigans.jl#1444. PR #1444 is quite nice but unfortunately I think the new `fill_halo_regions!`. ```julia; fill_halo_regions!(c::AbstractArray, fieldbcs, grid, args...; kwargs...); ```. broke MPI halo filling since it needs dispatch on. ```julia; fill_halo_regions!(c::AbstractArray, bcs, arch::AbstractMultiArchitecture, grid, c_location, args...); ```. It might be tricky to fix since you can't tell whether you're on `CPU` or `MultiCPU` from inside `fill_halo_regions!` with just knowledge of the `field`... I propose we revert #1444 just for now (since distributed models + tests are broken on master) and immediately open a new PR with the contents of #1444 where we can find a solution. My only idea is to add `architecture` to Field but perhaps it feels a little bloated... This failure was not caught by Buildkite since PR #590 was merged after #1444 was opened, and I think Buildkite only runs tests on branches, not pull requests (i.e. it doesn't merge master and run tests).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1484:596,test,tests,596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1484,3,['test'],['tests']
Testability,"Reverts climate-machine/Oceananigans.jl#263 because boundary conditions API broke. Seems that the tests did not catch this maybe?. ```; (base) alir_mit_edu@oceananigans-debug:~/Oceananigans.jl$ julia --project newscript.jl ; WARNING: Method definition overdub(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; CUDA-enabled GPU(s) detected:; CuDevice(0): Tesla V100-SXM2-16GB; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Default,Nothing}, got BoundaryCondition{Flux,Float64}; Stacktrace:; [1] setbc!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Val{:left}, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:85; [2] setproperty!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Symbol, ::Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/272:98,test,tests,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/272,1,['test'],['tests']
Testability,Rewrite regression tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/665:19,test,tests,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665,1,['test'],['tests']
Testability,"Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:104451,benchmark,benchmark,104451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"Right now Buildkite only runs tests on the PR branch (pushes). Might be worth looking into whether Buildkite can also run pull request tests, i.e. merge the branch into master then run the tests. This would help catch issues like #1262.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1263:30,test,tests,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1263,3,['test'],['tests']
Testability,"Right now I'm just constructing grids with dimensions that are multiples of 16 so; ```julia; Tx, Ty = 16, 16 # Threads per block; Bx, By, Bz = Int(Nx/Tx), Int(Ny/Ty), Nz # Blocks in grid.; ```. @vchuravy suggested laying them out to fill out the _x_-direction first, then the _y_-direction, then the _z_-direction. That would also let us use grids with arbitrary sizes, i.e. not just multiples of 16. Not sure if it would affect performance for large problems. See https://github.com/vchuravy/GPUifyLoops.jl/pull/18#issuecomment-465150581. Update: Yeah I should have done this a long time ago. This issue is preventing us from running small grids (e.g. 1D column models) on the GPU and running certain tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/64:702,test,tests,702,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/64,1,['test'],['tests']
Testability,"Right now JLD2 files always include the full grid (with halos) in `file[""grid""]` which can make it hard to make plots of the data, especially if it was sliced (requiring users to know how to cut out the halos). Not sure if this is a bug as `file[""grid""]` might be referring to the grid the simulation was run on in which case it makes sense to include all the coordinates including halos, but this might still surprise users wishing to make plots. Thanks to @vchuravy for helping uncover this issue!. ```julia; using Oceananigans, Oceananigans.OutputWriters, JLD2; grid = RegularCartesianGrid(size=(8, 8, 8), extent=(1, 2, 3)); model = IncompressibleModel(grid=grid); simulation = Simulation(model, Δt=1, stop_iteration=1); simulation.output_writers[:test] = JLD2OutputWriter(model, merge(model.velocities, model.tracers), schedule=IterationInterval(1), prefix=""test"", field_slicer=FieldSlicer(k=grid.Nz, with_halos=false)); run!(simulation); f = jldopen(""test.jld2""); ```. so. ```julia; julia> size(f[""timeseries/u/1""]); (8, 8, 1); ```. but. ```julia; julia> f[""grid/zC""]; 10-element Array{Float64,1}:; -3.1875; -2.8125; -2.4375; -2.0625; -1.6875; -1.3125; -0.9375; -0.5625; -0.1875; 0.1875; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1194:751,test,test,751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1194,3,['test'],['test']
Testability,"Right now `Oceananigans.Distributed` requires the grid points to be split evenly among the ranks, e.g. if you have 4 ranks along the x-direction then `grid.Nx` must be a multiple of 4. @christophernhill suggested generalizing this. He's written some code for dividing nearly evenly into N subdomains when the global number of points is not exactly divisable by N: https://github.com/christophernhill/iap-2021-12.091/blob/e79dfe9dca5441e561cefd65b4c052b1a1dea5a3/step3.py#L36. `IncompressibleModel` can only be decomposed in y but `ShallowWaterModel` and `HydrostaticFreeSurfaceModel` can be decomposed in x and y so we should try this out with one of them. With shallow water model in this PR we could test different x, y, and xy domain decompositions (all non-equal).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1450:702,test,test,702,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1450,1,['test'],['test']
Testability,"Right now `SpecifiedTimes` is acting in a way different from its documentation. In addition to triggering a callback in the specified times, according to the docs, it's also triggering the callback in initialization. For example, the following MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=10). callback_func(sim) = @warn ""Function called in iteration $(sim.model.clock.iteration)""; simulation.callbacks[:cfl_changer] = Callback(callback_func, SpecifiedTimes([5, 10])). run!(simulation); ```. produces the following output. ```julia; [ Info: Initializing simulation...; ┌ Warning: Function called in iteration 0; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: ... simulation initialization complete (262.483 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.766 seconds).; ┌ Warning: Function called in iteration 5; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: Simulation is stopping. Model iteration 10 has hit or exceeded simulation stop iteration 10.; ┌ Warning: Function called in iteration 10; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; ```. Is this by design? If so the docs for `SpecifiedTimes` must be changed to account for that since they currently read:. ```; Return a callable TimeInterval that ""actuates"" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example,. • SpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719:782,sandbox,sandbox,782,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719,3,['sandbox'],['sandbox']
Testability,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:18,test,tests,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,12,"['Test', 'test']","['Testing', 'test', 'testing', 'tests']"
Testability,"Right now easiest thing to do would be to manually test the package on Supercloud or somewhere with multiple GPUs, but CI with GPUs would be nice. See for ideas: https://github.com/JuliaGPU/gitlab-ci. Might not be worth setting up for a while, seems like too much work.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/53:51,test,test,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/53,1,['test'],['test']
Testability,"Right now only 1 benchmark job is run to check for performance regression, which is important seeing as sometimes we introduce rogue bugs that kill performance. cc @simonbyrne will this work with the Slurm CI/CliMA bot framework you've set up? Will be awesome to start using it. No MPI stuff yet but will probably add some soon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/280:17,benchmark,benchmark,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/280,1,['benchmark'],['benchmark']
Testability,"Right now reductions only exclude _immersed_ peripheral nodes:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/ImmersedBoundaries/immersed_reductions.jl#L27. It recently caused me a lot of pain and confusion and time that ""ordinary"" peripheral nodes are included in the reduction, but immersed peripheral nodes are not. What is the logic for treating immersed boundaries differently from ordinary boundaries? I think we should either exclude only inactive nodes or peripheral nodes, but this behavior should be consistent between immersed and not immersed grids. This change would mean we don't need special reductions (at least for fields that are not reduced) on immersed vs not-immersed grids. @simone-silvestri may have the answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3064:376,log,logic,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3064,1,['log'],['logic']
Testability,"Right now regression data takes up a significant amount of space in the repo. I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:375,test,tests,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['tests']
Testability,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1056:10,test,tests,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056,4,['test'],"['testing', 'tests']"
Testability,Right now the `model` `TEST_GROUP` takes about 48 minutes to run on sverdrup. So it'd be nice to split this test group up so that each test build is < 30 minutes.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1048:108,test,test,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1048,2,['test'],['test']
Testability,"Right now we have a simple interval wave test in `test_dynamics.jl` (vertically propagating and only 10 time steps) and an example (@glwagner thinks it looks off). We should turn them into a rigorous verification experiment. Would be a good test of the pressure gradient term, and we can compare with an analytic solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/674:41,test,test,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/674,2,['test'],['test']
Testability,"Right now we load cubed sphere grids from a file which is a Julia/JLD2.jl version of the binary files used by MITgcm. These grid files are currently stored at https://github.com/CliMA/OceananigansArtifacts.jl. The easiest way to use them is to load them as a data dependency with DataDeps.jl: https://github.com/CliMA/Oceananigans.jl/blob/master/test/data_dependencies.jl. This works well for the CS32 and CS96 grids, but for much larger grids like the CS510 the grid file is ~200 MiB uncompressed (~118 MiB compressed with JLD2's `compress=true`) which is bigger than GitHub's 100 MiB file size limit. 200 MiB for a grid file is also a bit cumbersome. Right now I'm thinking of hosting CS510 on the engaging cluster, although git lfs for OceananigansArtifacts.jl may be an option. It would be nice to be able to generate conformal cubed sphere grid files to make it easier for users to use cubed sphere grids, and also for the added flexibility of not being limited to three common resolutions (CS32, CS96, and CS510). It would also be good to keep the ability to load a cubed sphere grid from file since we may want to do this for other grids besides the cubed sphere in the future (lat-lon-cap or LLC grids?), and it would be useful to test that the grids we generate are indeed correct by comparing with the grid files. I'm opening this issue just to document what we know about conformal cubed sphere grid generation. It's not a particularly urgent issue. # Computing grid metrics. We already have some code that generates conformal cubed sphere grids with the coordinates, but they are missing the grid metrics (grid spacings and areas). @christophernhill has pointed out these MITgcm MATLAB scripts that may just be what we need to compute the grid metrics. http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/README?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/calc_fvgrid.m?revis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1586:346,test,test,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1586,1,['test'],['test']
Testability,Run Windows tests on GitHub Actions.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1050:12,test,tests,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1050,1,['test'],['tests']
Testability,Run convergence tests as part of the verification testset,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/873:16,test,tests,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/873,2,['test'],"['tests', 'testset']"
Testability,Run convergence tests on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1216:16,test,tests,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1216,1,['test'],['tests']
Testability,"Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(timer[bn32]); 56 t64 = TimerOutputs.time(timer[bn64]); 57 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:108208,benchmark,benchmarks,108208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['benchmark'],"['benchmark', 'benchmarks']"
Testability,Running the `distributed_nonhydrostatic_model_mpi.jl` benchmark,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2433:54,benchmark,benchmark,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433,1,['benchmark'],['benchmark']
Testability,Running with 2 threads is the worst memory-wise. See benchmarks from https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-732516353 and similar results were reported by @francispoulin on a different machine from https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734500922. Not sure if this is because of Oceananigans.jl or because of KernelAbstractions.jl. Multithreaded seems to allocate a ton of memory in general though.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1218:53,benchmark,benchmarks,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1218,1,['benchmark'],['benchmarks']
Testability,"S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOperation`. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1886:3257,benchmark,benchmarking,3257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886,1,['benchmark'],['benchmarking']
Testability,Same as https://github.com/CliMA/Oceananigans.jl/pull/2899 but pinning GPUCompiler to version 0.16.4. This pinning made tests pass in https://github.com/CliMA/Oceananigans.jl/pull/2865,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2900:120,test,tests,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2900,1,['test'],['tests']
Testability,Sandbox scripts for Large eddy simulation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315:0,Sandbox,Sandbox,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315,1,['Sandbox'],['Sandbox']
Testability,"Scalar diffusivity fails on GPU if you use fields for the viscosity/diffusivity since there is no adapt method. . I've added them in this PR along with a test, feel free to remove the test if its too much.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3401:154,test,test,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3401,2,['test'],['test']
Testability,Search and replace testing for example scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/418:19,test,testing,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/418,1,['test'],['testing']
Testability,"See below for a MWE. ```Julia; $ julia --project=docs; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.9.0 (2023-05-07); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Glob. julia> glob(""src/*.jl""); 6-element Vector{String}:; ""src/Architectures.jl""; ""src/Biogeochemistry.jl""; ""src/Logger.jl""; ""src/Oceananigans.jl""; ""src/StokesDrift.jl""; ""src/Units.jl"". julia> glob(""src/**/*.jl""); 213-element Vector{String}:; ""src/AbstractOperations/AbstractOperations.jl""; ""src/AbstractOperations/at.jl""; ""src/AbstractOperations/binary_operations.jl""; ""src/AbstractOperations/broadcasting_abstract_operations.jl""; ""src/AbstractOperations/computed_field.jl""; ""src/AbstractOperations/conditional_operations.jl""; ""src/AbstractOperations/constant_field_abstract_operations.jl""; ""src/AbstractOperations/derivatives.jl""; ""src/AbstractOperations/grid_metrics.jl""; ""src/AbstractOperations/grid_validation.jl""; ""src/AbstractOperations/kernel_function_operation.jl""; ""src/AbstractOperations/metric_field_reductions.jl""; ""src/AbstractOperations/multiary_operations.jl""; ""src/AbstractOperations/show_abstract_operations.jl""; ""src/AbstractOperations/unary_operations.jl""; ""src/Advection/Advection.jl""; ""src/Advection/cell_advection_timescale.jl""; ""src/Advection/centered_advective_fluxes.jl""; ""src/Advection/centered_reconstruction.jl""; ""src/Advection/flat_advective_fluxes.jl""; ⋮; ""src/TurbulenceClosures/implicit_explicit_time_discretization.jl""; ""src/TurbulenceClosures/isopycnal_rotation_tensor_components.jl""; ""src/TurbulenceClosures/turbulence_closure_diagnostics.jl""; ""src/TurbulenceClosures/turbulence_closure_utils.jl""; ""src/TurbulenceClosures/velocity_tracer_gradients.jl""; ""src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl""; ""src/Utils/Utils.jl""; ""src/Utils/kernel_launching.jl""; ""src/Utils/multi_region_transformation.jl""; ""src/Utils/ordered_dict_show.jl""; ""src/Util",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3109:417,Log,Logger,417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3109,1,['Log'],['Logger']
Testability,See https://github.com/CliMA/Oceananigans.jl/discussions/3457. Made PR to see if tests will pass.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3458:81,test,tests,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3458,1,['test'],['tests']
Testability,Seems like a good idea to have an LES regression test for big PRs that modify the `TurbulenceClosures` module such as PR #452. I guess we can use a coarse stratified Couette flow or free convection simulation in steady state to check for this.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/473:49,test,test,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/473,1,['test'],['test']
Testability,"Seems like the `Float32` tracer conservation test is actually running with `Float64`... ```; [ Info: Tracer conservation after 10 time steps (CPU(), Float32): ⟨T⟩-T₀=-7.105427357601002e-14 °C; [ Info: Tracer conservation after 10 time steps (CPU(), Float64): ⟨T⟩-T₀=4.618527782440651e-14 °C; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/487:45,test,test,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/487,1,['test'],['test']
Testability,Set `-O0` when testing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1078:15,test,testing,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1078,1,['test'],['testing']
Testability,Set h=1 in shallow water time stepping tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1264:39,test,tests,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1264,1,['test'],['tests']
Testability,Set up Slurm pipeline for performance regression testing.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/280:49,test,testing,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/280,1,['test'],['testing']
Testability,"Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:1360,test,test,1360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['test'],['test']
Testability,Shallow water model tests are failing on master because `model.velocities.u` does not exist for `ShallowWaterModel`. This PR fixes this by checking for NaNs in the model's first field.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1257:20,test,tests,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1257,1,['test'],['tests']
Testability,Shallow water regression tests often fail on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922:25,test,tests,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922,1,['test'],['tests']
Testability,Should be `Δz^2` instead of `Δz`. But this cannot be merged as is because it breaks some tests: the Rayleigh–Bénard tracer regression test uses Value boundary conditions and so the regression data would have to be regenerated.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/322:89,test,tests,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/322,2,['test'],"['test', 'tests']"
Testability,"Should close #3833. Probably, we can wait to merge #3792 before this one and add some tests for fill halo regions here",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3834:86,test,tests,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3834,1,['test'],['tests']
Testability,"Should have instructions for:; * How to install the package as a user.; * How to `git clone`, `instantiate`, and `test` the package as a developer.; * CPU instructions.; * GPU instructions.; * When #151 is resolved, docker installation instructions. CPU and GPU instructions should not be separate but when #79 is solved, we should be able to run on the CPU without installing (and failing to build) all the CUDA packages.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/152:114,test,test,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/152,1,['test'],['test']
Testability,"Should run these benchmarks again once everything works on the GPU. Notes:; 1. Lat-lon grid seems slower than the single cubed sphere face, which is weird. Maybe the cost of computing the grid metrics on the fly is actually adding up to a significant overhead?; 2. Cubed sphere grid performs better than it should (less than 6x slower than 1 face), but allocates a lot of memory.; 3. Explicit vs. implicit free surface solver performance is problem-dependent so for the purposes of this benchmarks every implicit solver is forced to take 1 iteration. ```; Hydrostatic model benchmarks; ┌───────────────┬──────────────────────────────┬─────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬─────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ExplicitFreeSurface │ 3.127 ms │ 3.632 ms │ 3.665 ms │ 4.225 ms │ 263.23 KiB │ 1726 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ExplicitFreeSurface │ 9.765 ms │ 10.370 ms │ 10.428 ms │ 11.847 ms │ 290.50 KiB │ 1984 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ExplicitFreeSurface │ 5.986 ms │ 9.676 ms │ 10.276 ms │ 16.990 ms │ 151.66 KiB │ 1994 │ 10 │; │ CPU │ ConformalCubedSphereGrid │ ExplicitFreeSurface │ 24.817 ms │ 28.235 ms │ 30.393 ms │ 45.743 ms │ 2.12 MiB │ 41751 │ 10 │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ImplicitFreeSurface │ 6.418 ms │ 6.925 ms │ 7.147 ms │ 9.625 ms │ 578.41 KiB │ 3545 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ImplicitFreeSurface │ 15.913 ms │ 16.438 ms │ 17.028 ms │ 20.042 ms │ 656.92 KiB │ 4306 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ImplicitFreeSurface │ 9.89",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1604:17,benchmark,benchmarks,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1604,3,['benchmark'],['benchmarks']
Testability,Should speed up GitLab CI builds. CPU is already well-tested on Travis CI and Appveyor.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/758:54,test,tested,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/758,1,['test'],['tested']
Testability,Should tests be run with `julia --check-bounds=yes`?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3747:7,test,tests,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747,1,['test'],['tests']
Testability,Should we add multithreading benchmarks to README?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/900:29,benchmark,benchmarks,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/900,1,['benchmark'],['benchmarks']
Testability,Should we test also models run with tuple of closures and/or using different models?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2047:10,test,test,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2047,1,['test'],['test']
Testability,"Simple Dockerfile to build a Docker image with Oceananigans installed, precompiled, and with dependencies built. Should be useful for debugging and maybe speeding up CI. Image can be built then just downloaded by CI server, but usually testing is done before Docker image is built... We also have a Dockerhub repository where images will be published: https://cloud.docker.com/repository/docker/aliramadhan/oceananigans. We can look into automated builds: https://docs.docker.com/docker-hub/builds/. For GPU-accelerated container we can look into: https://github.com/NVIDIA/nvidia-docker. cc @christophernhill we're finally in the 21st century!. Resolves #151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/316:236,test,testing,236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/316,1,['test'],['testing']
Testability,Simple tests for correct halo filling + dynamics with the MultiRegion cubed sphere,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3020:7,test,tests,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020,1,['test'],['tests']
Testability,"Since it has to do with the `*nodes` functions this might be closely related to issue #3771 although the error is different so I'm opening a separate issue about it. I'll look into both together. MWE:. ```julia; using Oceananigans. underlying_grid = LatitudeLongitudeGrid(size = (12, 12, 12), latitude = (0, 1), longitude = (0, 1), z = (-1, 0)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid). NetCDFOutputWriter(model, model.velocities; filename=""test"", schedule=IterationInterval(1)); ```. Error:. ```; ERROR: MethodError: no method matching xnodes(::LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{…}, Float64, Float64, Float64, Float64, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, CPU}, ::Center; with_halos::Bool). Closest candidates are:; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:655; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:635; xnodes(::Any, ::Any, ::Any, ::Any; kwargs...); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/nodes_and_spacings.jl:79; ... Stacktrace:; [1] xnodes(ibg::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, loc::Center; kwargs::@Kwargs{with_halos::Bool}); @ Oceananigans.ImmersedBoundaries ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:268; [2] native_dimensions_for_netcdf_output(grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Dict{String, Tuple{…}}, TX::Type{Bounded}, TY::Type{Bounded}, TZ::Type{Bounded}, Hx::Int64, Hy::Int64, Hz::Int64); @ Oceananigans.OutputWriters ~/atdepth/Oceananig",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3775:541,test,test,541,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775,1,['test'],['test']
Testability,"Since you now report coverage via the gitlab-ci tests (to include GPU coverage) the coveralls.io is not needed. As far as I know, gitlab-ci is only able to report coverage to codecov.io. Thus, I propose to remove the coveralls badge. (Btw, the URL was broken anyway...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/762:48,test,tests,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/762,1,['test'],['tests']
Testability,Slightly reorganizes dependencies in tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2715:37,test,tests,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715,1,['test'],['tests']
Testability,Slims down model size for many tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/937:31,test,tests,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/937,1,['test'],['tests']
Testability,"So, let me start by saying that I'm not 100% sure that this issue is an Oceananigans issue or not, but it did start a few weeks ago when the errors due to `ArrayInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625:556,test,tests,556,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625,5,['test'],['tests']
Testability,"Some Poisson solver tests, e.g. test_3d_poisson_ppn_planned!_div_free, fail when using FFTW.MEASURE or FFTW.PATIENT.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/99:20,test,tests,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/99,1,['test'],['tests']
Testability,"Some TODOs:. - [ ] Make `set!` work for `Face, Face, Center` fields (eg streamfunctions); - [ ] Make broadcasting work for cubed sphere fields; - [x] Use plotting utilities from Imaginocean. With the above and fixing the tests then I think we are ready to merge. Supersedes #3221; closes #3204",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3266:221,test,tests,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3266,1,['test'],['tests']
Testability,Some cleaning up in the implicit free surface solvers tests. Resolves #2184.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2181:54,test,tests,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2181,1,['test'],['tests']
Testability,Some intermediate commits from last week attempting to subtype `AbstractField <: DimensionalData.AbstractDimArray` but needs more work as tests are failing. Resolves #457; Works on (partially resolves?) #1493,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1700:138,test,tests,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1700,1,['test'],['tests']
Testability,"Some of the buildkite pipelines take way too long. Specifically the `time_stepping_2`, `regression` and `solver` tests. I suggest we further split them?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2139:113,test,tests,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139,1,['test'],['tests']
Testability,"Some recent improvements in `CUDA.jl`:. https://juliagpu.org/post/2022-01-28-cuda_3.5_3.8/#preserving_array_indices. attempt to avoid promoting index types from 32-bit to 64-bit integers (64-bit integers are Julia's default). Throughout `Oceananigans` we use 64-bit integers by using the constant `1` for index calculations:. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Operators/difference_operators.jl#L7. According to that blog post, changing the above line. ```julia; @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; ```. may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. ```julia; julia> i = 0x1; 0x01. julia> typeof(i); UInt8. julia> i == 1; true. julia> i === 1; false; ```. The amount of code that generates our stencils is not all that large. We find stencil calculations in. * `Operators`; * `Advection`; * `ImmersedBoundaries`. I also found a few stray index manipulations in random places like. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L211. I think this issue also implies that we should strive to minimize the number of places where we do index calculations, to minimize the chances that we accidentally convert to `Int64`. We might also want to do some profiling to see the specific effect moving to `UInt8` indices might have. Perhaps we should benchmark two fully-loaded models, a `NonhydrostaticModel` LES with high-order advection, and a global-configuration of `HydrostaticFreeSurfaceModel` with an immersed boundary / continents, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2202:1554,benchmark,benchmark,1554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202,1,['benchmark'],['benchmark']
Testability,"Some tests for no flux boundary conditions, diffusion, and Boussinesq.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/126:5,test,tests,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/126,1,['test'],['tests']
Testability,"Something to do with . https://github.com/CliMA/Oceananigans.jl/blob/b32394a9e70598a3728c4ed6acbcd03b0946fc32/src/Fields/interpolate.jl#L6-L10. ??. Discovered by @johnryantaylor, who may be able to provide more details. First step: tests...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2300:232,test,tests,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2300,1,['test'],['tests']
Testability,Sometimes if you wait tests fix themselves,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/575:22,test,tests,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/575,1,['test'],['tests']
Testability,"Somewhat of a small frivolous PR but it improves logging in Oceananigans with some fancy formatting which includes using colors for timestamps and log levels (using the same colors as the base logger) and the source of the message is underlined (see screenshot below). It can be used via the usual macros (`@debug`, `@info`, `@warn`, and `@error`) once Oceananigans is loaded via `using` or `import`. Although this might actually be undesirable as it hijacks the global logger... The logger is now turned on globally in the `Oceananigans.__init__` function. I'd like to start using it for new simulations as it's useful to have timestamps. ![image](https://user-images.githubusercontent.com/20099589/90137955-51510400-dd44-11ea-9bb9-9c407db19b99.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/855:49,log,logging,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855,5,['log'],"['log', 'logger', 'logging']"
Testability,"Somewhere between this commit ; https://buildkite.com/clima/oceananigans-distributed/builds/3113#01917ace-fe81-401d-ba21-467037e6aead; and main, we switched from using `libmpitrampoline.so` in the distributed tests to `libmpi.so` downloaded from the artifacts. . Previously, the mpi trampoline was loading a CUDA-aware implementation of Open MPI, while the libmpi.so we use now is a ; MPICH implementation non CUDA-aware:; https://buildkite.com/clima/oceananigans-distributed/builds/4227#0192f70a-b947-4d38-bd1c-c2497a964de9. This makes our GPU distributed tests fail. ; I am wondering where this switch happened because I couldn't trace any changes to the code. @Sbozzolo, do you know if something changed in the `LocalPreferences.toml` in the Caltech cluster?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3897:209,test,tests,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3897,2,['test'],['tests']
Testability,Sorry meant to delete the sandbox before merging PR #1348.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1395:26,sandbox,sandbox,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395,1,['sandbox'],['sandbox']
Testability,Speed up matrix Poisson solver test + minor code cleanup,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2826:31,test,test,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2826,1,['test'],['test']
Testability,Split poisson solver tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2187:21,test,tests,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2187,1,['test'],['tests']
Testability,Split tests into four groups for CI job matrices,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/872:6,test,tests,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872,1,['test'],['tests']
Testability,Split tests into smaller bits and pieces,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2140:6,test,tests,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2140,1,['test'],['tests']
Testability,Split tests into smaller bits and pieces (take #2),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2151:6,test,tests,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2151,1,['test'],['tests']
Testability,Split timestep tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2324:15,test,tests,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2324,1,['test'],['tests']
Testability,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3020:208,Test,Test,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020,6,"['Test', 'test']","['Test', 'tests']"
Testability,"Starting to get tests failing because of conflicting qualifiers, e.g. both `Base` and `CUDAdrv` define `@elapsed`. Would be good to revise our existing `using` and `import` statements so that we only bring in exactly what we need to avoid these kinds of issues. And I believe it's good practice anyways.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/351:16,test,tests,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/351,1,['test'],['tests']
Testability,"Still a work in progress but working on bringing in more unit and system tests. The system tests will include some that we've already implemented (e.g. #126) and some regression tests on simple examples. Also working on comprehensive GPU testing so that we're testing the GPU as much as we're testing the CPU. In particular, the Poisson solver isn't tested on the GPU right now which is kind of scary. **Warning**: GPU testing can take a while as a lot of compilation is involved :( See #66. Resolves #18 ; Resolves #22; Resolves #78",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/134:73,test,tests,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/134,8,['test'],"['tested', 'testing', 'tests']"
Testability,Stop testing on GitLab CI,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1049:5,test,testing,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1049,2,['test'],['testing']
Testability,Strategy for implementing and testing models with vertically stretched grids,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471:30,test,testing,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471,1,['test'],['testing']
Testability,Stratified plane Couette flow test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310:30,test,test,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310,1,['test'],['test']
Testability,Super easy fix. Suggested by @vchuravy. Should rerun multithreading benchmarks after this.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1113:68,benchmark,benchmarks,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1113,1,['benchmark'],['benchmarks']
Testability,Switch Tests to use the new logger,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/585:7,Test,Tests,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/585,2,"['Test', 'log']","['Tests', 'logger']"
Testability,Switch tests to use the new logger,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/578:7,test,tests,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/578,2,"['log', 'test']","['logger', 'tests']"
Testability,Switching to Plots.jl and unbreaking the example tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/536:49,test,tests,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/536,1,['test'],['tests']
Testability,"T, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 16 │ (1, 2, 3) │ 13.948 μs │ 14.043 μs │ 20.717 μs │ 80.605 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ (1, 2, 3) │ 1.656 ms │ 1.717 ms │ 1.809 ms │ 2.697 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ (1, 2, 3) │ 229.619 ms │ 233.008 ms │ 234.033 ms │ 243.288 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 1 │ 3.240 μs │ 3.255 μs │ 3.603 μs │ 6.746 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 1 │ 445.803 μs │ 458.928 μs │ 513.041 μs │ 755.937 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 1 │ 61.083 ms │ 63.464 ms │ 63.969 ms │ 67.009 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 2 │ 4.085 μs │ 4.135 μs │ 4.723 μs │ 8.088 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 2 │ 564.769 μs │ 579.278 μs │ 615.731 μs │ 804.859 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 2 │ 110.718 ms │ 111.560 ms │ 111.506 ms │ 112.525 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 3 │ 7.772 μs │ 7.787 μs │ 9.499 μs │ 24.886 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 3 │ 684.541 μs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:2400,benchmark,benchmarks,2400,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['benchmark'],['benchmarks']
Testability,TODO:. - [] Test on_architecture for single column grid + `EnsembleColumnSize`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3886:12,Test,Test,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3886,1,['Test'],['Test']
Testability,TODO:. - [x] Add a test that `KernelComputedField` works with `ConformalCubedSphereGrid`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1603:19,test,test,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1603,1,['test'],['test']
Testability,Taylor-Green vortex verification experiment and convergence test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/611:60,test,test,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/611,1,['test'],['test']
Testability,Temporarily disable ShallowWater GPU regression test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2927:48,test,test,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2927,1,['test'],['test']
Testability,Test !(collecting) after output for `WindowedTimeAverage`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1802:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1802,1,['Test'],['Test']
Testability,Test ArgumentError for wrong background_field location,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1848:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1848,1,['Test'],['Test']
Testability,Test N-tuple `MultipleForcings` and make them work on the GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3743:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3743,1,['Test'],['Test']
Testability,Test NetCDF output for all grids,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1490:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1490,1,['Test'],['Test']
Testability,Test advection schemes with Float32 and Float64,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1782:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1782,1,['Test'],['Test']
Testability,Test and fix bugs in `RegularLatitudeLongitudeGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1415:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1415,1,['Test'],['Test']
Testability,Test correctness / geometric consistency of `VerticallyStretchedRectilinearGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1756:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1756,1,['Test'],['Test']
Testability,Test differentiation of Oceananigans broadcast kernel with Enzyme,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3598:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598,1,['Test'],['Test']
Testability,Test failing on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Test'],['Test']
Testability,Test for GPU Poisson solver,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/238:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/238,1,['Test'],['Test']
Testability,Test for incompressibility in hydrostatic and non-hydrostatic models,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1934:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1934,1,['Test'],['Test']
Testability,Test for second-order convergence of pressure solver,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/704:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704,1,['Test'],['Test']
Testability,Test needed for `ConsecutiveIterations` schedule,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2154:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2154,1,['Test'],['Test']
Testability,Test non-equal MPI domain decompositions soon,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1450:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1450,1,['Test'],['Test']
Testability,Test that horizontal average is correct over time,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/737:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/737,1,['Test'],['Test']
Testability,Test that the GPU Poisson solver solution is numerically divergence-free,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/246:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/246,1,['Test'],['Test']
Testability,Test time-stepping with all turbulent diffusivity closures,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/549:0,Test,Test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/549,1,['Test'],['Test']
Testability,Testing problem,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2222:0,Test,Testing,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222,1,['Test'],['Testing']
Testability,"Testing this branch vs main in a 3D example with `momentum_advection = VectorInvariant(vorticity_scheme = WENO(), divergence_scheme = WENO(), vertical_scheme = WENO())` and `tracer_advection = WENO()`. This branch:; ![Screenshot 2023-02-21 at 4 34 22 PM](https://user-images.githubusercontent.com/33547697/220463656-0ab7389b-2dc1-415e-98d1-c2d772b0b302.png). Main:; ![Screenshot 2023-02-21 at 4 34 02 PM](https://user-images.githubusercontent.com/33547697/220463630-48b3c9a1-f18c-4623-99e0-b383adeed088.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2936:0,Test,Testing,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2936,1,['Test'],['Testing']
Testability,Testing this change from type-stable-with-tracers,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406:0,Test,Testing,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406,1,['Test'],['Testing']
Testability,Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985:0,Test,Testing,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985,1,['Test'],['Testing']
Testability,Tests fail because shallow water model with h=0 blows up when time stepped,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1262:0,Test,Tests,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1262,1,['Test'],['Tests']
Testability,Tests for 'show' methods,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/705:0,Test,Tests,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/705,1,['Test'],['Tests']
Testability,Tests for `OffsetArrays-Field` broadcasts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2501:0,Test,Tests,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2501,1,['Test'],['Tests']
Testability,Tests for splitting output files using `TimeInterval`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3523:0,Test,Tests,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3523,1,['Test'],['Tests']
Testability,Tests still fail but docs passed somehow. ; https://clima.github.io/OceananigansDocumentation/previews/PR1568/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1568:0,Test,Tests,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1568,1,['Test'],['Tests']
Testability,Tests whether the Poisson solver can recover an analytic solution that is a product of sines and cosines. It can!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/227:0,Test,Tests,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/227,1,['Test'],['Tests']
Testability,"Thanks to @hennyg888 , we now have scalings results for the distributed shallow water and nonhydrostatic models for both weak and strong scaling going up to 128 cores. . https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md. The good news is that the `ShallowWaterModel`, in both weak and strong scaling, reaches efficienties of around 80% on 128 cores. This is something we can probably make better but not the first concern. The not so good news is that the `NonhydrostaticModel`, the efficiency goes down close to 10%. I don't know why but wanted to mention it as it's something that we should be able to do much better with. Thoughts? @christophernhill @glwagner @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1948:241,benchmark,benchmarks,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1948,1,['benchmark'],['benchmarks']
Testability,"Thanks to @leios and @francispoulin for feedback that helped locate the issue!. Resolves #1170 . This PR fixes a bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1228:554,test,test,554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228,5,['test'],"['test', 'tests']"
Testability,"The 3D solver with mixed boundary conditions (periodic in the horizontal with DFTs, Neumann in the vertical with DCTs) works now as tested against an analytic solution but for some reason once I switched to DCTs it's only first-order convergent. The relevant function is [`solve_poisson_3d_mbc`](https://github.com/ali-ramadhan/OceanDispatch.jl/blob/d7310255347ced6c12472903c07c7e0004882a44/src/spectral_solvers.jl#L121). ![solve_poisson_3d_mbc first order convergence](https://user-images.githubusercontent.com/20099589/48667435-603d5080-eaa3-11e8-9fb0-5dabc47ebcbb.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/7:132,test,tested,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/7,1,['test'],['tested']
Testability,The Convergence tests and Couette flow pages (in validation) had missing figures that somehow got lost at some point. I was able to find the figures by going back to older versions of Oceananigans and reintroduced them. Resolves #1459. Resolves #1696.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797:16,test,tests,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797,1,['test'],['tests']
Testability,"The Leith closure uses the isotropic operators for viscosity, but defines special operators for tracer diffusivities (so that tracer fluxes lie in a local isopycnal). I re-enabled the time-stepping test for Leith. We'll see if it works. Resolves #1034",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1074:198,test,test,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1074,1,['test'],['test']
Testability,The MPI we use in the distributed tests is not CUDA-aware,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3897:34,test,tests,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3897,1,['test'],['tests']
Testability,"The Validation experiments in the Docs is very incomplete. I suggest we nuke it? Perhaps just leave the convergence tests page there and rename it to ""Convergence Tests""?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1696:116,test,tests,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1696,2,"['Test', 'test']","['Tests', 'tests']"
Testability,"The `test_ensemble_hydrostatic_free_surface_models.jl ` fail when I run on my laptop. ```Julia; (base) navid:OC.jl/ (ncc/fix-race-issue) $ julia --project [12:21:26]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.2 (2022-09-29); _/ |\__'_|_|_|\__'_| |; |__/ |. shell> cd test/; /Users/navid/Research/OC.jl/test. julia> include(""test_ensemble_hydrostatic_free_surface_models.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition update_state!(Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel{TS, E, A, S, G, T, V, B, R, F, P, U, C, Φ, K, AF} where AF where K where Φ where C where U where P where F where R where B where V where T where G where S where A<:Oceananigans.Architectures.AbstractArchitecture where E where TS) in module HydrostaticFreeSurfaceModels at /Users/navid/Research/OC.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:18 overwritten at /Users/navid/Research/OC.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:20.; ** incremental compilation may be fatally broken for this module **. [ Info: Oceananigans will use 6 threads; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (53.522 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (15.625 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (556.792 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.679 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:413,test,test,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['test'],['test']
Testability,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076:132,test,tests,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076,3,['test'],"['tested', 'testing', 'tests']"
Testability,"The clause that controls the definition of `cell_diffusion_timescale` in `TimeStepWizard` had a bug. I re-wrote in a way that's clearer to understand and that fixes the bug. Consider the MWE below:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8, 8, 8), extent = (1,1,1),; topology=(Periodic, Periodic, Bounded)). closure = IsotropicDiffusivity(ν=1); model = NonhydrostaticModel(grid = grid,; closure = closure); @info """" model; ; wizard = TimeStepWizard(diffusive_cfl=0.1,); ```. Before this PR:. ```julia; julia> wizard.cell_diffusion_timescale(model); Inf. julia> @which wizard.cell_diffusion_timescale(model); infinite_diffusion_timescale(args...) in Oceananigans.Simulations at /home/tomas/.julia/packages/Oceananigans/IHPoE/src/Simulations/time_step_wizard.jl:12; ```. After this PR:. ```julia; julia> wizard.cell_diffusion_timescale(model); 0.015625. julia> @which wizard.cell_diffusion_timescale(model); cell_diffusion_timescale(model) in Oceananigans.TurbulenceClosures at /home/tomas/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:15; ```. I'll also add a test to catch this in the future, since there are no tests for `diffusive_cfl` that I could tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2213:1112,test,test,1112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2213,2,['test'],"['test', 'tests']"
Testability,"The code should allow all types of partitioning but there is a bug preventing the tests from passing for y- and xy-partitions. This PR aims to fix the bug (and consequently add the excluded y- and xy-partitioning tests) . rework `fill_halo_regions!` to split out non-communicating and communicating boundary conditions such that the latter are executed alone. . To give an example, for ; ```julia ; julia> boundary_conditions = FieldBoundaryConditions(west = NoFluxBoundaryCondition(), east = NoFluxBoundaryCondition(), south = ImpenetrableBoundaryCondition(), north = DistributedCommunicationBoundaryCondition(), bottom = nothing, top = nothing); Oceananigans.FieldBoundaryConditions, with boundary conditions; ├── west: FluxBoundaryCondition: Nothing; ├── east: FluxBoundaryCondition: Nothing; ├── south: OpenBoundaryCondition: Nothing; ├── north: DistributedBoundaryCondition: Nothing; ├── bottom: Nothing; ├── top: Nothing; └── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ```. in main:; ```julia; julia> halo_tuple = permute_boundary_conditions(boundary_conditions);. julia> for i in 1:length(halo_tuple[1]); @info ""operation $(halo_tuple[1][i]) with bcs $((halo_tuple[2][i], halo_tuple[3][i]))""; end; [ Info: operation fill_bottom_and_top_halo! with bcs (nothing, nothing); [ Info: operation fill_west_and_east_halo! with bcs (FluxBoundaryCondition: Nothing, FluxBoundaryCondition: Nothing); [ Info: operation fill_south_and_north_halo! with bcs (OpenBoundaryCondition: Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.DistributedCommunication, Nothing}); ```. in this PR; ```julia; julia> halo_tuple = permute_boundary_conditions(boundary_conditions);. julia> for i in 1:length(halo_tuple[1]); @info ""operation $(halo_tuple[1][i]) with bcs $(halo_tuple[2][i])""; end; [ Info: operation fill_bottom_and_top_halo! with bcs (nothing, nothing); [ Info: operation fill_south_halo! with bcs (OpenBoundaryCondition: Nothing,); [ Info: operation fill_west_and_east_halo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3338:82,test,tests,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338,2,['test'],['tests']
Testability,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3747:126,test,tests,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747,2,['test'],['tests']
Testability,The cubed sphere grid from the MIT as read from DataDeps has the faces ordered:; 1. `+ x` direction; 2. `+ y` direction; 3. `+ z` direction (Arctic); 4. `- x` direction; 5. `- y` direction; 6. `- z` direction (Antarctica); ; So to avoid confusion for (users and developers!) I thought I make sure that the ConformalCubedSphere follows the same convention. This PR does that + it adds tests to check whether the ConformalCubedSphereGrid metrics from the grid read from file and the grid constructed in Oceananigans.jl are the same. After this is merged we'll move on to #2867 to constructing `ConformalCubedSphereGrid` using MultiRegion (an possibly nuke the `CubedSpheres` module completely). We will have a `ConformalCubedSphereGrid` (which is the same as the `cs32` grid read from file) to bench our MultiRegion implementation with!. (This PR also moves some of the spherical trigonometry utility function to `grid_utils.jl`.). Closes #1586,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2871:384,test,tests,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2871,1,['test'],['tests']
Testability,"The deep convection golden master fails intermittently even if the random number generator is seeded with the same value. Some randomness is added to the initial surface temperature. For now the 5 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". @christophernhill suggested using a portable random number generator: http://mitgcm.org/download/daily_snapshot/MITgcm/model/src/port_rand.F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/176:197,test,tests,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/176,1,['test'],['tests']
Testability,"The fix we recently had to put in to get CATKE's parameters up-to-date with [Wagner et al 2024](https://glwagner.github.io/assets/pdf/CATKE.pdf) show that we should probably be regression-testing CATKE results, especially if we are going to make related/surrounding improvements to `TKEDissipationVerticalDiffusivity`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3762:188,test,testing,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3762,1,['test'],['testing']
Testability,The following PR adds a new script with immersed boundaries on a lat-lon grid as a validation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1880:94,test,test,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1880,1,['test'],['test']
Testability,"The intention of this PR is to extend the capability of `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233:773,test,testfile,773,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233,3,['test'],['testfile']
Testability,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97:834,test,tests,834,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97,3,['test'],"['testing', 'tests']"
Testability,"The main goal for this PR is to create a user-facing function to obtain grid spacings. EDIT:. The current behavior is that for every grid type there are functions `xspacings()`, `xspacing()`, `xnodes()` and `xnode()` (and similarly for y and z) that follow the pattern illustrated below:. ```julia; julia> grid = RectilinearGrid(size=(4, 4, 1), extent=(1, 1, 1)); 4×4×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> xnodes(grid, Center(), Center(), Face()); 4-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7), 1:4) with eltype Float64:; 0.125; 0.375; 0.625; 0.875. julia> xnode(2, 2, 2, grid, Center(), Center(), Face()); 0.375. julia> xspacings(grid, Center(), Center(), Face()); 0.25. julia> xspacing(1, 2, 3, grid, Center(), Center(), Face()); 0.25; ```. These functions also appropriately handle stretched coordinates. In addition, both `xspacings()` and `xnodes()` have a `with_halos` kwarg that controls whether of not halos points are included. Convenience functions with fewer arguments are also defined for the cases where that's possible. For example:. ```julia; julia> xnode(2,2,2, grid, Center(), Center(), Face()); 0.375. julia> xnode(2, grid, Center()); 0.375; ```. I added tests for these functions for every grid in a way that doesn't create new grid instantiations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2842:1477,test,tests,1477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842,1,['test'],['tests']
Testability,The main point of upgrading is to get rid of CUDA errors on the CPU and use `CUDAapi.has_cuda()` which replaces the `HAVE_CUDA` variable we've been using. This was originally in PR https://github.com/climate-machine/Oceananigans.jl/pull/378 (this PR is mostly cherry picked commits) but when it was merged @glwagner reported issues with forcing functions on the GPU. So now I've added a test that makes sure that forcing functions don't crash when used in a CPU or GPU model (one with and one without `const`).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/388:387,test,test,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/388,1,['test'],['test']
Testability,The meridional velocity had the wrong sign in the vector rotation operator for switching from extrinsic to intrinsic coordinates in an `OrthogonalSphericalShellGrid`.; The test was also poorly designed (my bad) and conspired to hide the bug. This PR should fix the rotation and update the test to make sure everything is correct.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3744:172,test,test,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3744,2,['test'],['test']
Testability,"The poisson solver tests have a mysterious property:. https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/test/test_poisson_solvers.jl#L17-L20. whereby `CenterField` is used for `Ru`, `Rv`, and `Rw` --- fields that should be located on faces, and have boundary conditions appropriate for velocity fields. When these fields are merely relocated to the correct location, the tests fail. Since by all accounts the Poisson solver is correct, there is probably something wrong with the tests. But we can't really be sure about either while the tests contain an obvious inconsistency. We should probably fix these tests. @ali-ramadhan, do you remember why we use `CenterField` for `Ru`, `Rv`, and `Rw`? The code was added in this PR: https://github.com/CliMA/Oceananigans.jl/pull/834/.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1867:19,test,tests,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1867,6,['test'],"['test', 'tests']"
Testability,"The primary issue fixed here are actually the tests themselves, rather than the implementation. However this PR also makes a number of small improvements to the implementation, including a bug in which `recompute_safely` was implemented wrong (despite producing correct behavior, due to a ""cancellation of errors""). It looks like computations on `Faces` and along `Bounded` dimensions may not be possible with `BuoyancyField`. I will open an issue with an MWE. This is not a high-priority, because making such computations on boundaries correct in general really requires solving #971 ; otherwise we cannot guarantee that boundary conditions are correct (and they will often be wrong when averages are taken, as they commonly are during output). Relies on #1016 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1020:46,test,tests,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1020,1,['test'],['tests']
Testability,The results over at https://github.com/glwagner/multithreaded-stencils suggest that we could be leaving as much as 2x on the table for CPU performance by choosing a non-optimal group size for multithreading. This PR changes the group size on the CPU. @hennyg888 could be good to runs some benchmarks to see if this improves our CPU / multithreading situation!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1902:289,benchmark,benchmarks,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902,1,['benchmark'],['benchmarks']
Testability,"The simple test code from @christophernhill, now successfully differentiating!. Not sure what the correct answer should be, so someone should check this. This probably makes sense to add a test somewhere at least, and also can be used as a starting point for future development. ```julia; using Enzyme; using Oceananigans; using KernelAbstractions: @index, @kernel; using Oceananigans.Utils: launch!; using Oceananigans.Architectures: device. using EnzymeCore. EnzymeCore.EnzymeRules.inactive_type(::Type{<:Oceananigans.Grids.AbstractGrid}) = true. arch=CPU(); FT=Float64. N = 100; topo = (Periodic, Flat, Flat); grid = RectilinearGrid(arch, FT, topology=topo, size=(N), halo=2, x=(-1, 1), y=(-1, 1), z=(-1, 1)). function del21d!(d2buf,fld::Field); g = fld.grid; Nx = g.Nx; for i=1:Nx; d2buf[i] = fld[i-1,1,1]+fld[i+1,1,1]-2fld[i,1,1]; end; return; end. @kernel function del21d_k!(d2buf_k,fld); i,j,k = @index(Global,NTuple); @inbounds d2buf_k[i,j,k] = fld[i-1,j,k]+fld[i+1,j,k]-2fld[i,j,k]; end. # 2. halo; function halo1d!(fld::Field); g = fld.grid; Hx = g.Hx; Nx = g.Nx; for i=1:Hx; fld[i-Hx,1,1]=fld[Nx-Hx+i,1,1]; fld[Nx+i,1,1]=fld[i ,1,1]; end; return nothing; end. # 3. simple model; function diffuse1d_model!(jcost,fld); grid=fld.grid; d2buf=ones(grid.Nx); arch=grid.architecture; d2buf_k = CenterField(grid); k=1.0; dt=0.1; nsteps=50; for i in 1:nsteps; del21d!(d2buf,fld); ### kernel style; event=launch!(arch,grid,:xyz,del21d_k!,d2buf_k,fld); for j in 1:fld.grid.Nx; d2buf[i] = d2buf_k[i]; end; for j in 1:fld.grid.Nx; fld[j,1,1] = fld[j,1,1] + k*d2buf[j]*dt; end; halo1d!(fld); end; jcost[1]=fld[15,1,1].*fld[15,1,1]; return nothing; end. c = CenterField(grid); c2 = CenterField(grid); f(x, y, z) = exp( -50((x-grid.xᶠᵃᵃ[1])/grid.Lx-0.5)^2 ); set!(c,f); halo1d!(c); set!(c2,f); halo1d!(c2); j=[0.]; diffuse1d_model!(j,c). bc=CenterField(grid); set!(c,f); set!(bc,0); j=[0.]; bj=[1.]; autodiff(Reverse, diffuse1d_model!,Duplicated(j,bj), Duplicated(c,bc) ). @show bj; @show bc; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3346:11,test,test,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3346,2,['test'],['test']
Testability,"The tests in `test_cubed_spheres.jl` were not used (the file was not included). Therefore, the tests on vector rotation were not performed. This PR includes these tests in a new file on a coarse cubed sphere grid. ; @navidcy and @siddharthabishnu are there any tests in `test_cubed_spheres.jl` we want to salvage?. Another problem is the inclusion of `OrthogonalSphericalShellGrids` in the tests. This has caused a bit of problems because of circular dependency. . The inclusion of `OrthogonalSphericalShellGrids` in the tests is to have a non-trivial `OrthogonalSphericalShellGrid` in the tests. For the moment, however, it is used only in the vector rotation test (which was not performed anyways), which is covered by using a conformal cubed sphere. . For this reason thought to remove this dependency here since at the moment does not add anything, and I will open an issue to discuss which non-trivial OrthogonalSphericalShellGrid we want to build to test the OrthogonalSphericalShellGrid capabilities.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3881:4,test,tests,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3881,9,['test'],"['test', 'tests']"
Testability,"There are a couple of issues with reductions on a fts.; Given the following field time series; ```julia; grid = RectilinearGrid(size = (1, 1, 1), extent = (1, 1, 1)); fts = FieldTimeSeries{Center, Center, Center}(grid, 1:10; backend = OnDisk(), path = ""./test.jld2"", name = ""T""); f = CenterField(grid). for i in 1:10; set!(f, i); set!(fts, f, i); end; ```. ```julia; julia> sum(f; dims = 1); ERROR: UndefVarError: `filltype` not defined; Stacktrace:; [1] sum(f::Function, fts::FieldTimeSeries{…}; dims::Int64, kw::@Kwargs{}); @ Oceananigans.OutputReaders ~/development/Oceananigans.jl/src/OutputReaders/field_time_series_reductions.jl:30; [2] sum(fts::FieldTimeSeries{…}; kw::@Kwargs{…}); @ Oceananigans.OutputReaders ~/development/Oceananigans.jl/src/OutputReaders/field_time_series_reductions.jl:38; [3] top-level scope; @ REPL[19]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; Also, I think that the index for the reduction here is wrong, `i` instead of `n`; https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/OutputReaders/field_time_series_reductions.jl#L42-L45",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3752:255,test,test,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3752,1,['test'],['test']
Testability,"There are few tests for this functionality, but it's crucial for `OceanTurbulenceParameterEstimation.jl`. We should add more tests (especially for slice ensemble models which I think have zero tests now). cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2219:14,test,tests,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2219,3,['test'],['tests']
Testability,"There is a test for immersed boundary inside `test_implicit_free_surface.jl` but it seems to be *trivially passing* (see, e.g., the [log](https://buildkite.com/clima/oceananigans/builds/8449#0182eb0d-74d3-440e-92a7-eb0ffecfb042/25-734) from tests run on `main`). One problem was that `set_simple_divergent_velocity!` function defined at; https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/test/test_implicit_free_surface_solver.jl#L17-L35; was setting a non-zero `u` velocity in the center of the domain at `k = 1`, but that was inside the immersed boundary. I changed the [`set_simple_divergent_velocity!`](https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/test/test_implicit_free_surface_solver.jl#L17-L46) function to address that. However, still there is an issue... I managed to pinpoint it down to the step:. https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L140. Here's a demonstration... (not a MWE). I have a model with non-zero `u` velocity:. ```; julia> model.velocities.u; 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> model.velocities.u[imid, 1, 3]; 0.1; ```. ```Julia; julia> ∫ᶻQ = model.free_surface.barotropic_volume_flux; NamedTuple with 2 Fields on 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; └── v: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723:11,test,test,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723,5,"['log', 'test']","['log', 'test', 'tests']"
Testability,There was a bug in some recent updates to KernelAbstractions.jl that caused Enzyme to break on broadcasting arrays in Oceananigans. This PR includes a test to make sure this bug doesn't occur again.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3598:151,test,test,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598,1,['test'],['test']
Testability,"There's been a bunch of interest in using Oceananigans for physical-biogeochemical interaction studies --- problems where systems of reacting tracers that represent either oceanic biological systems, chemical reactions and cycles, or both interact with turbulence and fluid dynamics simulated by Oceananigans. In order to organize the community's work (and also to support some work at Clima on biogeochemistry in Oceananigans), I propose that we create a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we mi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512:628,test,testing,628,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512,1,['test'],['testing']
Testability,"Thermal bubble regression test now works again. Dumb leftover mistake from #228. Inb4 we should have unified the poisson solvers. Love it when you're off by 10^50:. Before:; ```; [ Info: Δu: min=-3.55764e+54, max=3.55764e+54, mean=-2.0648e+35, absmean=6.04154e+52, std=2.66887e+53; [ Info: Δv: min=-3.55764e+54, max=3.55764e+54, mean=2.57926e+35, absmean=6.04154e+52, std=2.66887e+53; [ Info: Δw: min=-8.03359e+54, max=5.86492e+54, mean=-8.09207e+35, absmean=7.70596e+52, std=3.93725e+53; [ Info: ΔT: min=-9.12137e+52, max=3.63655e+52, mean=1.50945e+34, absmean=3.54008e+50, std=3.58814e+51; [ Info: ΔS: min=-3.2411e+53, max=1.29218e+53, mean=2.84495e+34, absmean=1.2579e+51, std=1.27498e+52; ```. After:; ```; [ Info: Δu: min=-1.20346e-17, max=1.11131e-17, mean=-3.21903e-22, absmean=6.46707e-19, std=1.21175e-18; [ Info: Δv: min=-1.8052e-17, max=1.07099e-17, mean=-3.80102e-22, absmean=6.51696e-19, std=1.25463e-18; [ Info: Δw: min=-3.97428e-17, max=3.5345e-17, mean=4.25729e-21, absmean=3.64351e-18, std=5.66798e-18; [ Info: ΔT: min=-1.77636e-15, max=1.77636e-15, mean=-4.77049e-18, absmean=1.95156e-17, std=1.86152e-16; [ Info: ΔS: min=0, max=0, mean=0, absmean=0, std=0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/243:26,test,test,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/243,1,['test'],['test']
Testability,Thermal wind example/test.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/179:21,test,test,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/179,1,['test'],['test']
Testability,"These lines do not work for `ImmersedBoundaryGrid`. https://github.com/CliMA/Oceananigans.jl/blob/be00e364f9dcd712b3d0c3d48e32b94b181a02fc/src/OutputWriters/netcdf_output_writer.jl#L391-L395. Changing the first line to; ```Julia; if model.grid isa AbstractRectilinearGrid || model.grid isa ImmersedBoundaryGrid{<:Any,<:Any,<:Any,<:Any,<:AbstractRectilinearGrid}; ```; temporarily fixed my problem. Here is the script that I use for testing this issue:; ```Julia; using Oceananigans. underlying_grid = RectilinearGrid(; size=(32, 32, 16),; x=(-3.0, 3.0), y=(-3.0, 3.0), z=(0.0, 1.0),; topology=(Periodic, Periodic, Bounded),; halo=(4, 4, 4),; ). hill(x::Real, y::Real) = 0.1 + 0.1 * exp(-x^2 - y^2). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(hill)). model = NonhydrostaticModel(;; grid,; advection = WENO(),; ). simulation = Oceananigans.Simulation(model; Δt = 1.0, stop_time = 100.0). fields = model.velocities. simulation.output_writers[:fields] = NetCDFOutputWriter(; model,; fields,; filename = ""output.nc"",; schedule = Oceananigans.TimeInterval(10.0),; ). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3069:432,test,testing,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3069,1,['test'],['testing']
Testability,"These lines multiply `h` (a field at ccc) with objects at `fcc` and `cfc` respectively. https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L16-L17. This doesn't look correct, but if there is some logic that makes it correct, it should be documented with a comment at least. I think if the bathymetric height is defined at cell centers, then the bathymetric height at a cell interface might need to be defined as the maximum of the height of the adjacent cells.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3051:296,log,logic,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3051,1,['log'],['logic']
Testability,"These lines should not be there and at the least lower the accuracy of calculations on stretched grids. We need tests that the metrics and grid geometry are correct for stretched grids (eg all the cell spacings added up gives the total domain size; cell centers are located halfway between cell interfaces, etc). . Not sure why these lines are there but it may have been necessary due to a serious bug with the vertically stretched Poisson solver that was fixed in https://github.com/CliMA/Oceananigans.jl/pull/1541. I'm not sure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1755:112,test,tests,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1755,1,['test'],['tests']
Testability,"This ""PR"" adapts one of the CPU Poisson solver tests to the GPU. The test fails. . Hopefully there is a bug in the test. If so, it should be fixed so that we have a valid test for the GPU Poisson solver. I suggest we use just one solver for both the CPU and the GPU --- unifying those could be in the scope of this PR. It'll also be nice to have one function that returns the (real) solution to the Poisson equation, given complex input. . Our algorithm (for Periodic-Periodic-Neumann --- this would not be the case for Periodic-Periodic-Periodic) requires one temporary storage variable (which stores a permuted, complex version of the solution) that should be part of the `PPNPoissonSolver` struct (see what I did there?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/238:47,test,tests,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/238,4,['test'],"['test', 'tests']"
Testability,"This PR ""enhances"" `JLD2OutputWriter` so it first _checks_ whether an iteration number exists in the file it's about to save to. If the iteration number does exist, it emits warning, but does not fail. Previously, it would fail. This helps when restoring a simulation from a checkpoint when output is saved at higher frequency than the simulation is checkpointed. TODO: probably test makes sense.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2537:379,test,test,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2537,1,['test'],['test']
Testability,"This PR (pair programmed with @francispoulin) allows users to select the `timestepper` and adds support for `forcing` functions as part of the `ShallowWaterModel`. We also added some simple tests. We also added a `shallow_water_model_forcing` function that should readily generalize to `IncompressibleModel` while being shorter, so we can consider using it to replace `model_forcing`. Resolves #1284",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1291:190,test,tests,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291,1,['test'],['tests']
Testability,"This PR (part 3/3) upgrades the field abstraction so fields store their own boundary conditions. This simplifies the model boundary condition hierarchy and generalizes the field and boundary conditions abstractions so they can be used for a compressible model (and any other model we come up with in the future). All future fields will have boundary conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, nor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:662,test,test,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['test'],['test']
Testability,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1348:288,test,tests,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348,6,"['Benchmark', 'Test', 'test']","['Benchmarks', 'Test', 'test', 'testing', 'tests']"
Testability,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/704:46,test,test,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704,3,['test'],['test']
Testability,This PR adapts the hydrostatic regression tests to be run in distributed mode. an important step in this direction is to allow array partitioning under the hood in `set!` if the array size coincides with the global size of the field (implemented here). a more important step is to remove the topology from the `Distributed` architecture (it should not know anything about topology which is a grid property),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328:42,test,tests,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328,1,['test'],['tests']
Testability,"This PR adds MPI waits after sending and receiving all the halos and overlaps halo communication (thanks @christophernhill!). I was initially worried that overlapping halo communication would cause the corner halos to become wrong (I'm not even sure if the corner halos should be filled via communication?). But running the MPI example the movie looked fine so I'll keep the overlapping for now. Scaling benchmarks are better now! Results seem quite machine-dependent but on Satori for weak scaling I'm seeing >90% efficiency up to 16 ranks then ~85% efficiency on 32 ranks. Strong scaling seems noisier/a bit worse for some reason (including a 104% efficiency hit haha) but definitely better than before. # Weak scaling (shallow water). ```; Shallow water model weak scaling benchmark; ┌──────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬────────────┬────────┬─────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├──────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼────────────┼────────┼─────────┤; │ (8192, 256) │ (1, 1) │ 1.188 s │ 1.190 s │ 1.190 s │ 1.193 s │ 416.81 KiB │ 2665 │ 5 │; │ (8192, 512) │ (1, 2) │ 1.187 s │ 1.192 s │ 1.192 s │ 1.200 s │ 408.80 KiB │ 3178 │ 10 │; │ (8192, 1024) │ (1, 4) │ 1.204 s │ 1.206 s │ 1.206 s │ 1.212 s │ 408.80 KiB │ 3178 │ 20 │; │ (8192, 2048) │ (1, 8) │ 1.220 s │ 1.223 s │ 1.223 s │ 1.230 s │ 408.80 KiB │ 3178 │ 40 │; │ (8192, 4096) │ (1, 16) │ 1.281 s │ 1.283 s │ 1.284 s │ 1.291 s │ 408.80 KiB │ 3178 │ 64 │; │ (8192, 8192) │ (1, 32) │ 1.347 s │ 1.417 s │ 1.424 s │ 1.497 s │ 408.80 KiB │ 3178 │ 128 │; └──────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴────────────┴────────┴─────────┘; ```. ```; Shallow water model weak scaling speedup; ┌──────────────┬─────────┬──────────┬────────────┬──────────┬────────┐; │ size │ ranks │ slowdown │ efficiency │ memory │ allocs │; ├──────────────┼─────────┼──────────┼────────────┼──────────┼────────┤; │ (8192, 256) │ (1, 1) │ 1.0 │ 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505:404,benchmark,benchmarks,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505,2,['benchmark'],"['benchmark', 'benchmarks']"
Testability,This PR adds `Oceananigans.Diagnostics.WindowedTimeAverage` for computing the average of a quantity or 'kernel' over a specified time window. The design of `WindowedTimeAverage` is discussed extensively on #501 . . This PR only implements the basic functionality needed to compute `WindowedTimeAverage`. A streamlined user interface through `JLD2OutputWriter` and `NetCDFOutputWriter` will be implemented in a future PR. Todo:. - [x] tests. Resolves #501,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/856:434,test,tests,434,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/856,1,['test'],['tests']
Testability,"This PR adds `boundary_conditions` to `ComputedField`. I added a new `DefaultComputedFieldBoundaryCondition`, because `DefaultBoundaryCondition` specifies an `ImpenetrableBoundaryCondition` when a field is located on `Face` and the direction is `Bounded`. But I think this is only appropriate for velocities and is not what we want in general. Arguably, we should change `DefaultBoundaryCondition` instead and implement special behavior for velocity fields... Strictly speaking the boundary conditions are only ""correct"" in periodic directions, since we have no way of evaluating what the boundary conditions need to be in `Bounded` directions. Should we use a `nothing` default for `Bounded` directions in all cases for `ComputedField`?. Current tests pass, but I still need to add tests to make sure that halos are filled properly. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1340:747,test,tests,747,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1340,2,['test'],['tests']
Testability,"This PR adds a `FieldSlicer` that slices fields on indices prior to output. This PR is a work in progress because we at least need unit tests:. - [x] add unit tests for `FieldSlicer`. It probably also make sense to test integration with both `JLD2OutputWriter` and `WindowedTimeAverage`:. - [x] add tests for integration with `JLD2OutputWriter` and `WindowedTimeAverage`. In the future, we would like to permit slicing at physical locations (rather than indices). This can be accomodated in the constructor for `FieldSlicer` in various ways (outside the scope of this PR). We would also like the ability to interpolate to locations. For this we want something like `InterpolatingFieldSlicer`. Comments and suggestions for the API are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/932:136,test,tests,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932,4,['test'],"['test', 'tests']"
Testability,"This PR adds a `TurbulenceClosures` module to `Oceananigans`. At the moment nothing in the `Oceananigans` algorithm is touched --- the module is simply loaded and exported. I suggest that we keep it this way, given the size of this PR, and work on integrating the code into `Oceananigans` in a future PR. A simple incremental test in that future PR will be to replace the diffusive operators with the ones here and ensure that the regression tests still pass. Ultimately `TurbulenceClosures` will provide code for all the different diffusive terms we want to provide for `Oceananigans` users. The current design is that a 'closure' must provide a diffusive flux divergence term for `Oceananigans`. These diffusive flux terms are. * `∇_κ_∇ϕ(i, j, k, grid, ϕ, closure, u, v, w, T, S)` for a scalar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234:326,test,test,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234,2,['test'],"['test', 'tests']"
Testability,"This PR adds a `dims` keyword argument to `zero_halo_regions`, so that we can avoid zeroing out halo regions in directions that are not averaged. It also adds tests to ensure that this works. This PR does not solve all the issues with averaging halo regions, however. In particular, the halo regions are not guaranteed to be correct because they may have been previously zeroed out. This can be solved by calling `fill_halo_regions` prior to computing an average. However, this solution is not possible with the current syntax, because field boundary conditions can depend on other fields of model that are not available within `compute!(averaged_field)`. I will raise an issue after this PR to discuss this other problem, which involves some difficult trade-offs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/970:159,test,tests,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/970,1,['test'],['tests']
Testability,This PR adds a `with_halos` option to the `Average` diagnostic. By default `with_halos = false`. Previously `with_halos` was always `true` which was awkward as most use cases did not warrant halos in the output. PR test `Average` with halos and add result size tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/859:215,test,test,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/859,2,['test'],"['test', 'tests']"
Testability,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:15,benchmark,benchmarking,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,5,['benchmark'],"['benchmark', 'benchmarking', 'benchmarks']"
Testability,"This PR adds a bunch of examples, tests them, and writes them so that `Literate.jl` can be used to generate markdown files from them. . In the future, we can add these markdown files to the documentation. Examples that might be good to add to ~~this~~ a future PR:. - 2D convection into a stratified fluid with ""phytoplankton-like"" tracer: demonstrates forcing functions, nice boundary conditions, etc; - 2D Kelvin-Helmholtz instability: just a simple but interesting stratified example; - Stratified Couette flow example: nice 3D example with `Value` boundary conditions. Also: . - [x] Clean up and simplify deepening mixed layer example: should become a good 3D example; perhaps merge into single 'case' including forcing by both wind and unstable buoyancy forcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/425:34,test,tests,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/425,1,['test'],['tests']
Testability,"This PR adds a convenience function `PressureField(model)` that returns a `ComputedField` representing total pressure, with data stored by default in the hydrostatic pressure field. It also adds tests for using `AveragedField`s and `ComputedField`s in operations, and fixes a method ambiguity associated with deducing interpolation to `Nothing` locations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/956:195,test,tests,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/956,1,['test'],['tests']
Testability,"This PR adds a docstring for `ImmersedBoundaryGrid` that includes the `active_cells_map` feature. It moves the interface to the top-level, and fixes `with_halo` to work with the new interface. We should add a test for `with_halo` with `ImmersedBoundaryGrid`. resolves #2988",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2989:209,test,test,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2989,1,['test'],['test']
Testability,This PR adds a few barotropic turbulence validation tests on `RegularLatitudeLongitudeGrid`. It also includes some miscellaneous improvements needed for these simulations:. * Bugfixes for `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (missing functions + closure shenanigans to solve type inference issues); * Allows `TimeStepWizard` to accept user-defined `cell_advection_timescale` functions; * Implements `auxiliary_fields` computed during `update_state!` for `HydrostaticFreeSurfaceModel`. Here's where we are at:. https://user-images.githubusercontent.com/15271942/116346519-4ab5d000-a79f-11eb-8c7f-91281db0ff56.mp4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1626:52,test,tests,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1626,1,['test'],['tests']
Testability,"This PR adds a field `erroring` to the `NaNChecker`, and also makes the `NaNChecker` mutable. This means that the default `NaNChecker` can be converted to an erroring `NaNChecker` by writing. ```julia; simulation.callbacks[:nan_checker].func.erroring = true; ```. or. ```julia; erroring_NaNChecker!(simulation); ```. TODO. - [x] Test. Resolves #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2087:329,Test,Test,329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087,1,['Test'],['Test']
Testability,This PR adds a naive fifth-order advection scheme called `UpwindBiasedFifthOrder`. This primarily interesting to see the advantages of the WENO algorithm at the same order of accuracy. ![Square_RungeKutta3_UpwindBiasedFifthOrder_N64_CFL0 50_U+1](https://user-images.githubusercontent.com/15271942/94488260-49440b00-01b0-11eb-985f-ab8aed3892ab.gif). ![Square_RungeKutta3_UpwindBiasedFifthOrder_N64_CFL0 50_U-1](https://user-images.githubusercontent.com/15271942/94488252-46491a80-01b0-11eb-92c3-23b814e44f18.gif). Still need to. - [ ] update convergence tests to include `UpwindBiasedFifthOrder`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/994:553,test,tests,553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/994,1,['test'],['tests']
Testability,"This PR adds a new `AbstractModel` called `HydrostaticFreeSurfaceModel` to `IncompressibleModel` and `ShallowWaterModel` in the Oceananigans model suite. `HydrostaticFreeSurfaceModel` is intended to solve the hydrostatic Boussinesq equations beneath a free surface. This PR adds the basic infrastructure needed to time step models on a `RegularCartesianGrid` with explicit free surface dynamics. I think we should save dynamics tests and an example for a future PR, and just work on getting some of the basic ingredients into this model. The time-stepping tests are currently in place, but most of `time_step!(model::HydrostaticFreeSurface, dt)` needs to be fleshed out. Todo for this PR:. - [x] correct tendency calculation and time-stepping for an Adams-Bashforth timestepping method; - [x] calculation of vertical velocity from the continuity equation",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1349:428,test,tests,428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349,2,['test'],['tests']
Testability,"This PR adds a new `Diagnostic` type called `Timeseries`, which takes a function or callable object of model (anything that has a method of the form `obj(model)`), and stores the result in `data` vector and the time-of-collection in a `time` vector. It also adds an object called `CFL` which computes the Courant-Freidrichs-Lewy number. `CFL` associates with a function `timescale`, which is used to provide convenience constructors `AdvectiveCFL` and `DiffusiveCFL`. We also add an object for computing `maximum(f, field.data.parent)` for `field`s, for an element wise operation `f`. The PR includes tests and docstrings for this functionality.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/407:601,test,tests,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/407,1,['test'],['tests']
Testability,"This PR adds a new function `interpolate(field, x, y, z)` that interpolates `field` to the physical point `(x, y, z)` using trilinear interpolation. This may be used for Lagrangian particle tracking (X-Ref #511), output on custom grids, and checkpoint restoration onto a new grid. No guarantees when `(x, y, z)` lies outside the domain of the field. I think it interpolates into the halo regions and I can test for this if we think it's important (actually this might be an important case...). Worrying about out of bounds, boundary conditions, extrapolation, etc. could slow down the `interpolate` function so it assumes the input makes sense. I think it's the particle's job to stay within the domain of the field. Output on a new grid is possible via. ```julia; new_field_data = interpolate.(Ref(field), nodes(loc, new_grid, reshape=true)...); ```. or. ```julia; new_field_data = interpolate.(Ref(field), xs, ys, zs); ```. so I did not feel the need to define any new types like `InterpolatedField` or `Interpolator`. @glwagner has pointed out that when restoring onto a new grid, you may want to respect global budgets in which case `interpolate` may not be appropriate for checkpoint restoration and an `integrator` (?) of some kind might be needed to ensure conservation of field quantities (momentum, tracers) via Gaussian quadrature. Is this a problem with linear interpolation though? Seems like linear interpolation should preserve global integrals?. Resolves #975",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1090:406,test,test,406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090,1,['test'],['test']
Testability,"This PR adds a new nonlinear equation of state, @sandreza's favorite 55-term polynomial approximation to TEOS-10 suitable for Boussinesq models as described in Roquet et al. (2014). The TEOS-10 polynomial approximation implemented in this PR has been translated into Julia from https://github.com/fabien-roquet/polyTEOS/blob/master/polyTEOS10.py (Thank you @fabien-roquet!). The Roquet et al. (2014) paper has some test/check values so I added some basic tests based on those, which pass. There are two things to figure out before merging:; 1. How to make `TEOS10` work with different float types. Right now the coefficients are defined as `const`s but then they're `Float64` by default. Perhaps it makes sense to define them as part of a `TEOS10` struct, but that will make the code a bit messier.; 2. Integrate `TEOS10` with `Oceananigans.Buoyancy` by defining `ρ′`, `thermal_expansion`, and `haline_contraction` functions. We can readily do this, just gotta convert geopotential depth `D` (which Oceananigans uses) to dbar (which `TEOS10` expects).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/731:415,test,test,415,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/731,2,['test'],"['test', 'tests']"
Testability,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2088:740,Test,Tests,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088,1,['Test'],['Tests']
Testability,This PR adds a new submodule `Oceananigans.CubedSpheres` that implements new grid and field types for running `HydrostaticFreeSurfaceModel` with a fully connected cubed sphere (should eventually also be flexible enough to just use 1 < n < 6 faces but I'm just testing 6 faces for now). This PR is still a work-in-progress and is quite messy with some pretty horrible code (please don't judge :sob:). I'll be adding to it and refactoring it over the next few days. Compile times have increased significantly with `grid::ConformalCubedSphereGrid` which has slowed down development but should be pretty close to being able to time step. EDIT: This might only be on Julia 1.6...,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522:260,test,testing,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522,1,['test'],['testing']
Testability,"This PR adds a new submodule called `Oceananigans.Advection`. The advection scheme for a model is chosen by using the advection keyword in the constructor for `IncompressibleModel`. For example,. ```julia; model = IncompressibleModel(advection=CenteredSecondOrder(), ...); ```. This PR also adds a `CenteredFourthOrder` advection scheme. Convergence tests and instantiation tests are forthcoming.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/815:350,test,tests,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/815,2,['test'],['tests']
Testability,"This PR adds a new turbulence closure called `HorizontalCurvilinearDiffusivity`, following section 2.15.7 in the MITgcm documentation:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#horizontal-dissipation. There it is stated that this closure. > conserves potential vorticity (thickness weighted relative vorticity) and divergence and dissipates energy, enstrophy and divergence squared. The same details are not given for tracer diffusion, so I left the tracer diffusivity at zero for now. @christophernhill please advise. I also needed to add a few operators. I'm not sure where to put them since we have both ""closure_operators.jl"" and ""viscous_dissipation_operators.jl"". It might make sense to clean this up a bit in this PR --- @ali-ramadhan let me know what you think. To do:. - [x] Tracer diffusion valid on curvilinear grids; - [x] Some clean up of `TurbulenceClosures` module; - [x] Unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1375:916,test,tests,916,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1375,1,['test'],['tests']
Testability,"This PR adds a property to `IncompressibleModel` called `background_fields`. `background_fields.velocities` contains background velocity fields; `background_fields.tracers` contains background tracer fields. Background fields are specified with a `NamedTuple` similar to forcing functions and boundary conditions:. ```julia; background_u(x, y, z, t) = z * sin(t). model = IncompressibleModel(grid=grid, background_fields=(u,), ...); ```. Background fields are neglected in all tendency terms _except_ the advection terms. This restricts their use, but greatly simplifies their implementation. Todo:. - [x] update physics docs to include background fields in model equations; - [x] update model setup docs; - [x] tests; - [x] update `eady_turbulence.jl` and `internal_wave.jl` example to use `background_fields`; - [x] extend implementation of `FunctionField` to take parameters and add a special constructor for background `FunctionFields`. Resolves #960",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1014:712,test,tests,712,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014,1,['test'],['tests']
Testability,"This PR adds a step in the outer `Field` constructor that validates boundary conditions. We check three things:. 1. That boundary conditions are compatible with the topology. Namely, we are restricted to default choices in `Periodic` or `Flat` directions; anything but default throws an error. 2. If a topology is `Bounded`, we check that boundary conditions are compatible with field location. Mostly we cannot support flux, value, or gradient boundary conditions for fields at faces, and we only support `nothing` for fields in `Flat` directions. 3. That boundary condition arrays are on the right architecture. TODO:. - [x] Test. Resolves #419; Resolves #890. Supercedes #1732",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2163:627,Test,Test,627,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2163,1,['Test'],['Test']
Testability,"This PR adds a test that automatically differentiates a hydrostatic turbulence simulation that uses `Centered` momentum advection and an `ExplicitFreeSurface`. . @wsmoses @jlk9 . Previously we had deduced that this model was differentiable, but it looks like there are still some issues. Not sure what the other test was doing. I think we should consider this separately from #3822 since that PR is currently working on the `SplitExplicitFreeSurface`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867:15,test,test,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867,2,['test'],['test']
Testability,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1480:279,test,test,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480,1,['test'],['test']
Testability,This PR adds a vertical regrid feature + tests. cc @adelinehillier,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1987:41,test,tests,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987,1,['test'],['tests']
Testability,"This PR adds a work-in-progress lid-driven cavity verification experiment. It also somewhat acts as a test for PR #475. It's a very classic test case and makes for a nice simple example: https://www.cfd-online.com/Wiki/Lid-driven_cavity_problem. I will compare point-wise velocity values along vertical and horizontal lines through the geometric center of the cavity at a resolution of 128x128 for various Reynolds numbers from Re=100 to Re=10,000. The values are reported in Tables 1 and 2 of [Ghia et al. (1982)](https://doi.org/10.1016/0021-9991(82)90058-4). Basically doing what this YouTube video is doing: https://www.youtube.com/watch?v=gkg3nG_qU7g. Helps with #332 and #346",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/476:102,test,test,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/476,2,['test'],['test']
Testability,"This PR adds another validation script for quick tests and such of distributed `NonhydrostaticModel`. We've been using the benchmark script, but that has additional features (and as a benchmark, is expensive to run). Hopefully these prove useful for fleshing out support for distributed cases. Right now I've just added a simple 2D turbulence script. TODO:; - [x] Add output to 2D turbulence script; - [ ] Add a 3D `NonhydrostaticModel` case; - [ ] Add `HydrostaticFreeSurfaceModel` case; - [ ] Add a script that runs into #2347 . cc @johnryantaylor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2348:49,test,tests,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2348,3,"['benchmark', 'test']","['benchmark', 'tests']"
Testability,"This PR adds areas, volumes, and a few product operators needed to evaluate correct Coriolis terms on curvilinear grids, following. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8. Before merging we should discuss:. - Should I update all the Coriolis terms? (`beta_plane.jl, non_traditional_f_plane.jl`, etc?); - Are we ok using three-letter codes, even though we only plan to support horizontally-curvilinear grids (rather than vertically curvilinear grids) in the near future?; - Should we add more regression tests / evaluate existing regression tests before changing terms that are not covered?; - It's not feasible to adapt the _entire_ codebase to work on curvilinear grids right now. How should we handle throwing errors for cases that are not supported? Adding `RegularCartesianGrid` annotations in key places seems like the easiest strategy, but we should be careful not to miss any. We can perhaps add annotations to _all_ operators, and then support curvilinearity in as parsimonious fashion as possible to be conservative.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1371:533,test,tests,533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371,2,['test'],['tests']
Testability,This PR adds biharmonic diffusion appropriate for curvilinear grids as described by the MITgcm docs:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#horizontal-dissipation. Looking for suggestions on more comprehensive tests / validation experiments.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1531:237,test,tests,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1531,1,['test'],['tests']
Testability,"This PR adds comparison operators to our supported operators, and also cleans up `Field` constructors for cases where computations or reductions return non-floating-point elements (such as Booleans). This support is progress towards allowing users to specify things like conditional averages as diagnostics, using `AbstractOperation`s. It's still a WIP because we need tests, and probably should also wait for a few other PRs before merging (eg #2097).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2169:369,test,tests,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2169,1,['test'],['tests']
Testability,"This PR adds experimental support for rotating/tilting the gravity vector. I'm not even sure if it works properly but I'm opening a draft PR as it might be ready to be experimented with? I don't think we can have a non-zero gravity component along a periodic direction as the fluid just free falls along that dimension and the model blows up. But here's a thermal bubble rising with gravity tilted at 45 degrees. ![tilted_gravity_plume](https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif). This is an experimental feature since it needs more rigorous testing and because full support for tilted gravity may require more work, e.g.; 1. Should AMD use `z_dot_g_b` now?; 2. Should `∂x_b` return a vector or should it be split up into `x_dot_∂x_b`, etc.? The Leith closure uses `∂x_b`.; 3. We may want to clean up and refactor the implementation, taking some suggestions from #1151. cc @tomchor . Resolves #1151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242:602,test,testing,602,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242,1,['test'],['testing']
Testability,"This PR adds new features to the `NetCDFOutputWriter` and fixes some bugs. 1. It now always writes useful metadata to all NetCDF files (the date the file was generated, the Julia version, and the Oceananigans version used). This is essential for reproducibility.; 2. Add a `verbose` flag (default is `false`) in case you want to track what's being to disk and how long it takes for each output to be computed.; 3. Add an `include_halos` flag (default is `false`) in case you want to use the full grid including halos to write fields and custom output. Added new tests for this.; 4. Test that the x, y, z coordinates being written to NetCDF files are correct. They were not (I think this happened when we switched to using offset arrays for `grid.xC`, etc.). This has been fixed.; 5. Added jldoctest examples showing how to write fields and custom output to NetCDF.; 6. There was a bug in showing/printing grid domains for bounded dimensions, e.g.; ```julia; julia> grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0625]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (16, 16, 16); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.0625, 0.0625, 0.0625); ```; Notice that `z ∈ [-1.0, 0.0625]` should be `z ∈ [-1.0, 0.0]`. This has been fixed now. I'd like to start using these features in LESbrary.jl (and in PR #572) so I'll tag v0.33.0 once this PR is merged. Resolves #683",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/823:562,test,tests,562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/823,2,"['Test', 'test']","['Test', 'tests']"
Testability,This PR adds some convenience functions for interacting with fields that are functions. Unfortunately I can't test it on my mac because I don't have `CUDAnative` (?) and CUDA stuff is broken for some reason on my desktop. . I added an example in `examples/working_with_fields.jl` to demonstrate how to use the abstraction. @ali-ramadhan can you help me debug and test? This PR is small and simple. Addresses #174.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/210:110,test,test,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/210,2,['test'],['test']
Testability,This PR adds support for Krylov.jl and aims to test it out for solving the Poisson equation. cc @xkykai @amontoison. Closes #3803,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812:47,test,test,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812,1,['test'],['test']
Testability,"This PR adds support for in-place reduction operations where the target is an `AbstractReducedField` and the source is either an `AbstractDataField`, `AbstractOperation`, or array of some kind. These work on the GPU. In the end the solution was simple since we now subtype `AbstractArray`; we only need to pass a view into the interior indices of the target to `Base.mapreducedim!` (which on the GPU ends up at `GPUArrays.mapreducedim!`). The result is that `AveragedField(op::AbstractOperation)` no longer needs to allocate memory for the three-dimensional result of computing `op`. Instead, `op` is reduced in a kernel. This is both faster (much much faster, I think --- though a benchmark is a good idea) and more memory efficient. It also greatly simplifies `compute!(field::AveragedField)`:. ```julia; function compute!(avg::AveragedField, time=nothing); compute_at!(avg.operand, time); mean!(avg, operand); return nothing; end; ```. So, resolves #1422. I also took the liberty of resolving #1610 and nuking `interiorparent`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1611:682,benchmark,benchmark,682,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1611,1,['benchmark'],['benchmark']
Testability,"This PR adds tests for ""sliced"" `compute!(field)`, when `field.indices != (:, :, :)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2521:13,test,tests,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2521,1,['test'],['tests']
Testability,This PR adds tests for Face-Face halo filling and ensures that the `fill_halo_regions!` for Face-Face fields are done correctly. After this PR a `fill_halo_regions!` works on a Face-Face field on a `ConformalCubedSphereGrid` **with the exception** of the 2 corner points that belong in the halo regions and _do not_ correspond to any interior point!. If those corner points are filled manually. https://github.com/CliMA/Oceananigans.jl/blob/b0ff6c4874355ec69208f437be4f46fc8935f3d7/validation/multi_region/cubed_sphere_tracer_advection.jl#L32-L53. Then everything seems fine. (This is of course not a final solution but I wanted to make a note here.). (work done with @siddharthabishnu),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3324:13,test,tests,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3324,1,['test'],['tests']
Testability,"This PR adds tests for `RegularLatitudeLongitudeGrid` which uncovered a couple of stupid bugs in the process. Sorry everyone. I guess we shouldn't be approving important PRs without tests in the future. I've somehow convinced myself that we need `Nλ + 2Hλ + 1` grid points in longitude even when it's periodic (tests don't pass otherwise), but not sure why so maybe let's hold off on merging just yet. This PR should fix things in PR #1404. Also, I didn't like `test_grids.jl` so I refactored it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1415:13,test,tests,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1415,3,['test'],['tests']
Testability,"This PR adds the ability to set boundary conditions on the LES diffusivities. The primary purpose of this functionality is to allow users to fix both fluxes and the gradients of fields on boundaries. This flexibility is needed because currently, if the flux of a field is specified, the gradient of that field across the boundary is naively set to zero. . This naive assumption, which is unfortunately incorrect and means that the calculation of near-wall diffusivities is also incorrect, was made in lieu of formulating some kind of nonlinear solver for the algebraic problem generated by the combination of a prescribed flux and nonlinear boundary diffusivity. Formulating a nonlinear solver to be applied along the boundary to determine boundary gradients from prescribed fluxes and general nonlinear LES formulations might be viewed as ""somewhat difficult"", and may not be useful, either. This PR permits an alternate solution to the puzzle: users may now prescribe both fluxes and gradients (essentially introducing a wall model on top of the interior LES model) by simultaneously setting the value of the LES diffusivity and the gradient of a field on the boundary. The flux of the field across the boundary is then calculated consistently as part of the interior solution. The interior LES model and calculation of nonlinear viscosities and diffusivities at interior cell centers is unchanged. The method for setting boundary values of diffusivities roughly sketched by a test of the new feature in . https://github.com/climate-machine/Oceananigans.jl/blob/f1d341ac8512ba13b4fc165b24a25f6bdf3696ef/test/test_boundary_conditions.jl#L95. This new feature is useful mainly for advanced users at the moment due to the convoluted scripting gymnastics needed to instantiate the `ModelBoundaryConditions` prior to instantiating the `Model`. Some improvements to the user API would be welcome if this feature gains popularity or importance in the future.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/601:1479,test,test,1479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/601,2,['test'],['test']
Testability,"This PR adds the capability for treating the ""33"" component of the symmetric isoneutral diffusive flux implicitly. cc @sandreza would be great if you test this. This depends on #2481",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2487:150,test,test,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2487,1,['test'],['test']
Testability,"This PR adds the keyword arguments `time_averaging_window` and `time_averaging_stride` to the constructors for `JLD2OutputWriter` and `NetCDFOutputWriter`. A non-`nothing` `time_averaging_window` transforms all the specified output to a `WindowedTimeAverage`. I have implemented this feature for `JLD2OutputWriter` only so far. ~~@ali-ramadhan, can you confirm that the pattern applied to `JLD2OutputWriter` will work for `NetCDFOutputWriter`? I'm not 100% sure how it would work with the ""slice"" functionality of the `NetCDFOutputWriter`.~~. Todo:. - ~~[ ] Implement convenience kwargs for `NetCDFOutputWriter`~~; - [ ] Tests for `JLD2OutputWriter`; - ~~[ ] Tests for `NetCDFOutputWriter`~~. Edit: I think we should just get this working for the `JLD2OutputWriter` for now. The `NetCDFOutputWriter` needs a bit of work anyways. We can extend `NetCDFOutputWriter` to averaged output once that preliminary work is complete.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/887:621,Test,Tests,621,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/887,2,['Test'],['Tests']
Testability,"This PR adds third-order advection schemes, plus convergence tests for advection schemes. To do:. - [ ] Finish writing third-order momentum advection operators; ~~- [ ] Integration tests for time-stepping with different advection schemes~~; ~~- [ ] Generalize validation experiments to test third-order and fourth-order advection~~. Minor:. Should we call it `UpwindThirdOrder` or `UpwindBiasedThirdOrder` ?. As a side note, we eventually need to generalize advection schemes so that a different scheme can be applied to momentum and tracers, and possibly even to every tracer individually. This is not difficult since we have a similar pattern implemented for turbulence closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/936:61,test,tests,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/936,3,['test'],"['test', 'tests']"
Testability,"This PR adds two features:. 1. The ability to specify multiple forcing functions with a tuple (eg #2136); 2. A new forcing function type `AdvectiveForcing` for adding advective terms as a forcing function. A few users want to model buoyant or sinking particles so we need a nice way to support this that doesn't require importing low-level Oceananigans kernel functions. This was discussed on Slack and in #2385 . Some notes:. * `AdvectiveForcing` can also model advection of momentum, but this will only work for `NonhydrostaticModel` at the moment (because the kernel functions for momentum advection have different names for nonhydrostatic vs hydrostatic); * ""forcing tuples"" are wrapped in a lightweight `MultipleForcings` wrapper; this is just an internal convenience. However it does mean that we can more easily support alternative ways to ""combine"" forcings (other than just adding them) in the future if need be. ### Example of multiple forcings. From #2136, in model constructors:. ```julia; forcing = (; u = (u_relaxation, u_sponge)); ```. ### Example of `AdvectiveForcing`. From the docstring:. ```julia; # Physical parameters; gravitational_acceleration = 9.81 # m s⁻²; ocean_density = 1026 # kg m⁻³; mean_particle_density = 2000 # kg m⁻³; mean_particle_radius = 1e-3 # m; ocean_molecular_kinematic_viscosity = 1.05e-6 # m² s⁻¹. # Terminal velocity of a sphere in viscous flow; Δb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density; ν = ocean_molecular_kinematic_viscosity; R = mean_particle_radius. w_Stokes = - 2/9 * Δb / ν * R^2. settling = AdvectiveForcing(WENO5(), w=w_Stokes); ```. Closes #2136 . TODO:; - [x] Tests; - [x] Validation case with simple sinking, reacting particle that combines `MultipleForcing` and `AdvectiveForcing`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389:1665,Test,Tests,1665,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389,1,['Test'],['Tests']
Testability,"This PR adds two new features for interacting with `Checkpointer`s. The first is the method. ```julia; set!(model, checkpointer_filepath::AbstractString); ```. that sets all the checkpointed data in `checkpointer_filepath` to `model`, including tendencies, and synchronizes the model clock and iteration with the checkpointed clock and iteration. The second is a kwarg in `run!` meant to be used as either. ```julia; run!(simulation, pickup=true); ```. or . ```julia; run!(simulation, pickup=n); ```. or . ```julia; run!(simulation, pickup=filepath); ```. where `n` is an integer that refers to an iteration number of a checkpointer file to be ""picked up"" and run from, and `filepath` is a string that indicates the path to checkpoint data. `pickup=true` looks for the latest checkpointed file and picks up the simulation from there. To do:. - [x] actually add run!(simulation, pickup=true); - [x] tests for `set!`; - [x] tests for `run!`; - [x] modify `JLD2OutputWriter` so it doesn't fail in common use cases. Resolves #1068 ; Resolves #602",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1082:898,test,tests,898,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082,2,['test'],['tests']
Testability,This PR adds two regression tests for models that use the `ConstantSmagorinsky` closure and the `AnisotropicMinimumDissipation` closure. It also organizes the regression tests into a separate directory. Resolves #473,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/479:28,test,tests,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/479,2,['test'],['tests']
Testability,"This PR adds verification tests for numerical convergence of time-stepping and spatial discretization. One test does not pass (the most complicated one): forced, fixed slip simulation. More detailed analysis of this test is needed. Below is a summary of the results. # Time stepping convergence tests. ![image](https://user-images.githubusercontent.com/15271942/83302597-a65f8e00-a1c9-11ea-89b0-c1816cd7328e.png). # Advection and diffusion of a one-dimensional cosine. ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/15271942/83302620-ae1f3280-a1c9-11ea-90ed-17642646350d.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/15271942/83302631-b24b5000-a1c9-11ea-9e75-457e3b912203.png). # Advection and diffusion of a one-dimensional Gaussian. ![image](https://user-images.githubusercontent.com/15271942/83302659-be371200-a1c9-11ea-9398-0bddd4f20a6e.png). ![image](https://user-images.githubusercontent.com/15271942/83302666-c1320280-a1c9-11ea-8d74-d454336ab22b.png). # Two-dimensional diffusion. ![image](https://user-images.githubusercontent.com/15271942/83303244-b5930b80-a1ca-11ea-9ef1-deb7f1230ac4.png). # Two-dimensional Taylor-Green vortex. ![taylor_green_convergence](https://user-images.githubusercontent.com/15271942/83302684-c8f1a700-a1c9-11ea-8ddb-f4f8d7e11962.png). # Two-dimensional forced flow with free-slip boundary conditions. ![forced_free_slip_convergence](https://user-images.githubusercontent.com/15271942/83303260-bd52b000-a1ca-11ea-83ad-6d6a71c530a8.png). # Two-dimensional forced flow with fixed-slip boundary conditions. _This test does not pass_. We don't know if there is a bug in the test or a problem in Oceananigans. ![forced_fixed_slip_convergence](https://user-images.githubusercontent.com/15271942/83303305-cf345300-a1ca-11ea-81c8-2cdcb14d4066.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/767:26,test,tests,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767,6,['test'],"['test', 'tests']"
Testability,"This PR aims to add a regular lat-lon grid (i.e. with regularly spaced latitude and longitude lines), mainly to test all the new curvilinear operators. Final design TBD probably until PR #1375 is merged. Also gotta figure out the halo situation (probably quite similar to `RegularCartesianGrid`) and add some unit tests. The implementation is based on MITgcm's `ini_spherical_polar_grid.F`: https://github.com/MITgcm/MITgcm/blob/fc300b65987b52171b1110c7930f580ca71dead0/model/src/ini_spherical_polar_grid.F#L142-L151. Since Oceananigans.jl has always assumed rectilinear grids so far, I have kept some conventions like `Nx, Ny, Nz` instead of going for `Nλ, Nϕ, Nz`. I have made the assumption that the user will primarly be interested in the (latitude, longitude) of each grid point. So the grid stores e.g. Δλ and λᶠᵃᵃ instead of Δx and xᶠᵃᵃ. `RegularLatitudeLongitudeGrid` seems possible with very little memory as the grid spacings are cheap to compute, so I think we should try computing as much as we can on the fly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1380:112,test,test,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1380,2,['test'],"['test', 'tests']"
Testability,"This PR aims to add the forced flow analytic test as a verification experiment. The test is described in section 6.1 of [Brown, Cortez, & Minion (2001)](https://doi.org/10.1006/jcph.2001.6715) and is used to test various projection methods for the incompressible Navier-Stokes equations. The reason for implementing this test is to investigate the accuracy of Oceananigans' projection (or fractional step) method following concerns brought up by @sandreza. In particular, we can test whether Oceananigans' time-stepping is indeed second-order accurate in velocity and pressure. A couple of points regarding the accuracy of projection methods for us:; 1. In the introduction to Brown et al. (2001), they heuristically suggest adding a correction term to the pressure update that is linearly proportional to the viscosity ν. To me this suggests that perhaps the accuracy of the projection method matters more at low Reynolds number. The forced flow test uses Re = 1 so it's probably in a regime where the accuracy of the projection method matters a lot.; 2. The entire paper seems to focus on the semi-implicit form of the discrete Navier-Stokes equations where diffusion is treated implicitly. It's unclear to me whether their paper matters to us since we currently treat diffusion completely explicitly. Right now the test blows up (no matter how small the time step). Not sure why. I'll have to investigate and plots things a bit. Most likely I just set things up incorrectly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/573:45,test,test,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/573,7,['test'],['test']
Testability,"This PR aims to add the lid-driven cavity as a verification experiment (first) and as a simple example (second) that is very well-known in the CFD world. It's set up as a 2D problem in the _yz_ plane. It also tests that horizontal/channel boundary conditions work. The verification experiment aims to reproduce the results detailed by [Ghia, Ghia, & Shin (1982)](https://doi.org/10.1016/0021-9991(82)90058-4). Unfortunately right now it seems to blow up no matter what I do. Once the top plate is set in motion a vorticity anomaly makes its way along the top plate then down to the bottom plate at which point blow up seems to occur no matter the time step or Reynolds number. A [Physics StackExchange post](https://physics.stackexchange.com/questions/461782/clarification-on-the-lid-driven-cavity-problem-in-cfd) suggested that quiescent initial conditions should be fine ""although if the wall Mach number is large, the sudden impulse could be numerically destabilizing"" which would only make sense for compressible models. I tried with vortical initial conditions too but no luck.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/572:209,test,tests,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/572,1,['test'],['tests']
Testability,"This PR aims to create a single `FieldBoundaryConditions` function to replace `HorizontallyPeriodicBCs` and `ChannelBCs`. This paves the way for boundary conditions to become a `Field` property (#606). It's a pretty big breaking change so would be good to agree on the design and API before refactoring. Side note: Ideally we would set `default_bc(::Flat) = nothing` but until we elide operations and halo filling along `Flat` dimensions, I think we should use `default_bc(::Flat) = PeriodicBC()`. @glwagner Let me know if this looks like what we discussed. If so, I'll go ahead and change all the tests and examples to use it instead of `HorizontallyPeriodicBCs` and `ChannelBCs`. Reminder to self: Documentation, especially model setup, will have to be revised as part of this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/620:598,test,tests,598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/620,1,['test'],['tests']
Testability,"This PR allows `NetCDFOutputWriter` to write arbitrary outputs, similar to how we pass functions that return data to be saved to disk with the JLD2 output writer, but now with metadata! The `dimensions` kwarg allows you to pass a dictionary of dimensions to apply to any outputs. I also cleaned up the `NetCDFOutputWriter` a bit and changed the name of the time dimension from `""Time""` to `""time""`. @suyashbire1 Let me know if I did anything wrong. I added a pretty comprehensive test that shows how you might write a mix of scalars, profiles, and slices to a NetCDF file with grid/unit/name metadata and global attributes. Here's what the API looks like right now:; ```julia; # Define scalar, vector, 2D slice, and 3D field outputs; f(model) = model.clock.time^2; g(model) = @. model.clock.time * exp(model.grid.zC); h(model) = @. model.clock.time * sin(model.grid.xC) * cos(model.grid.yC'). outputs = Dict(""scalar"" => f, ""profile"" => g, ""slice"" => h); dims = Dict(""scalar"" => (), ""profile"" => (""zC"",), ""slice"" => (""xC"", ""yC"")). output_attributes = Dict(; ""scalar"" => Dict(""longname"" => ""Some scalar"", ""units"" => ""bananas""),; ""profile"" => Dict(""longname"" => ""Some vertical profile"", ""units"" => ""watermelons""),; ""slice"" => Dict(""longname"" => ""Some slice"", ""units"" => ""mushrooms""); ). global_attributes = Dict(""location"" => ""Bay of Fundy"", ""onions"" => 7). simulation.output_writers[:fruits] =; NetCDFOutputWriter(; model, outputs; frequency=1, filename=""test_function_outputs.nc"", dimensions=dims,; global_attributes=global_attributes, output_attributes=output_attributes). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/643:480,test,test,480,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/643,1,['test'],['test']
Testability,This PR attempts to enable Codecov code coverage reports from tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2329:62,test,tests,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329,1,['test'],['tests']
Testability,"This PR borrowed very heavily from #1024 and successfully uses `Flat` in the context of the shallow water model in various ways: z direction only, y and z direction and x,y,z directions. All possibilities should work but these are the ones that I have tested explicitly. . There is a file `test/test_flat_shallow_water_model.jl` needs to be turned into a proper test. Also, I modified the shallow water Bickley jet example and it works. I am curious to see whether this has any impact on the other models. . What do you think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1504:252,test,tested,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1504,3,['test'],"['test', 'tested']"
Testability,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2538:1168,test,test,1168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538,2,['test'],"['test', 'tests']"
Testability,This PR builds off #664 and rewrites the regression tests to match changes made in #664 to the time-stepping algorithm. It also does some minor refactoring and cleanup of the regression test scripts.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/665:52,test,tests,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665,2,['test'],"['test', 'tests']"
Testability,"This PR builds on @navidcy's excellent work to convert all the examples to Makie. I tried to unify the coding style in the examples as best I could. Also, there was a bit too much logging / plotting messages in the examples, which polluted the docs. TODO:. - [x] We should use `Axis3` in the baroclinic adjustment animation.; - [x] The stretched grid is not displayed in the tilted bottom boundary layer (we could also get rid of this, because we already visualize a similar stretched grid in another example); - [x] Remove logging noise from shallow water bickley jet, horizontal convection, and tilted bottom boundary layer examples",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2576:180,log,logging,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576,2,['log'],['logging']
Testability,"This PR changes the default size of face fields so that the length of a field along a `Bounded` dimension is `N+1`, rather than `N`, and therefore includes the bounding faces. The default for `Periodic` and `Flat` dimensions is unchanged. This PR is a work in progress because testing are failing for the NetCDF output writer, and for horizontal averages.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/644:277,test,testing,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/644,1,['test'],['testing']
Testability,This PR changes the grid coordinate arrays so that they are not reshaped to three-dimensional arrays. . The coordinate arrays are now one-dimensional `OffsetArray`s wrapped around a range. This simplifies some code and also makes our more complicated `AbstractOperations` tests pass.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/757:272,test,tests,272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/757,1,['test'],['tests']
Testability,"This PR changes the name of the `Forcing` constructor to `ModelForcing` to clarify the difference between constructors for forcing objects on single fields, and constructors for the `NamedTuple` of forcing objects for all model fields. It also conventionalizes the name of the fields in `ModelForcing`, so that . ```julia; forcing = ModelForcing(u=u_forcing); ```. is used to apply the forcing function `u_forcing` to `u`. . In addition it adds a new type ""`SimpleForcing`"", which permits users to pass functions of `x`, `y`, `z`, and `t`. A few validating lines in the `ModelForcing` constructor ensure that forcing functions for `u`, `v`, and `w` are applied at the correct locations. For example, we can now write. ```julia; T_forcing = SimpleForcing((x, y, z, t) -> exp(z) * cos(t)). model = Model(forcing=ModelForcing(T=T_forcing)); ```; To create a forcing on temperature that decays exponentially in z and oscillates in time. To test this functionality, this PR introduces an example ""`ocean_convection_with_plankton`"" that uses `SimpleForcing` to model the growth and decay of a plankton-like tracer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/444:936,test,test,936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444,1,['test'],['test']
Testability,"This PR changes the names of the `y` and `z` components of the rotation vector for the non-traditional f-plane to `fy` and `fz`. It updates the tests and documentation. It also adds a section about the non-traditional f-plane approximation to the ""physics"" section of the documentation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/617:144,test,tests,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/617,1,['test'],['tests']
Testability,This PR cleans up the horizontal divergence and vertical vorticity operators for horizontally-curvilinear grids. It also adds a test to ensure that `HydrostaticFreeSurfaceModel` continues to work with `momentum_advection=VectorInvariant()`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1374:128,test,test,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1374,1,['test'],['test']
Testability,"This PR continues #767 by adding documentation of the convergence tests. There is still some todo:. - [x] document forced, free-slip convergence test; - [x] document forced, fixed-slip convergence test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/782:66,test,tests,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/782,3,['test'],"['test', 'tests']"
Testability,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1807:502,test,tests,502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807,2,['test'],"['test', 'tests']"
Testability,"This PR defines some binary operations involving `ZeroField`s that might be useful, and adds tests for those operations. The issue came up at https://github.com/tomchor/Oceanostics.jl/pull/104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2883:93,test,tests,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2883,1,['test'],['tests']
Testability,"This PR does some minor refactoring to reduce code length. It also introduces an `AdamsBashforthTimestepper` type which will be useful in the future if new timesteppers are implemented. @ali-ramadhan, can you check to see that GPU tests pass? I had some trouble on my local machine.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/325:231,test,tests,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325,1,['test'],['tests']
Testability,"This PR eliminates `AbstractEddyDiffusivity` in favor of simply defining `viscosity` and `diffusivity` directly for the LES closures. It also converts the boundary layer parameterizations to subtype `AbstractScalarDiffusivity{TD, VerticalFormulation}`. This change eliminates much code duplication. I'm also removing the ""background"" diffusivities/viscosities from the LES closures. Closes #1277; Closes #1381. TODO:. - [x] Pass closures into `ivd_upper_diagonal` and implement `ivd_upper_diagonal` for closure tuples and filter out explicit closures before implicit solve; - [x] Change ""diffusivity extractors"" like `κᶠᶜᶜ` so they take `closure` as an argument.; - [x] Support `viscosity(closure::Tuple, K)` cc @tomchor ; - [x] Test `DiffusiveCFL` for closure tuples; - [x] We won't need `z_diffusivity` etc anymore?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295:729,Test,Test,729,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295,1,['Test'],['Test']
Testability,"This PR extends the `JLD2OutputWriter` with two new options: `verbose` and `max_filesize`. When `verbose=true` the `JLD2OutputWriter` logs what it is doing, how long it takes to copy/compute output and write output, and the file size of the output (current and delta). When `max_filesize=true`, the `JLD2OutputWriter` will stop writing to the output file once the file size exceeds `max_filesize`, and write to a new one with a consistent naming scheme. In action:; ```julia; using Oceananigans; model = Model(N=(64, 64, 64), L=(1, 1, 1)). u(model) = model.velocities.u.data.parent; fields = Dict(:u => u); ow = JLD2OutputWriter(model, fields; prefix=""test"", frequency=5, max_filesize=10MiB, force=true, verbose=true); push!(model.output_writers, ow). time_step!(model, 50, 1); ```; ```; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 4.608 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=3.822 s, size=2.2 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.891 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.262 ms, size=4.4 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.118 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.564 ms, size=6.6 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.479 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=18.126 ms, size=8.8 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.421 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=23.091 ms, size=11.0 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.627 μs; [ Info: Filesize 11.0 MiB has exceeded maximum file size 10.0 MiB.; [ Info: Renaming first part: ./test.jld2 -> ./test_part1.jld2; [ Info: Now writing to: ./test_part",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/350:134,log,logs,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350,2,"['log', 'test']","['logs', 'test']"
Testability,"This PR extends the implementation of `IsotropicDiffusivity` to accept `AbstractField`s (such as `ComputedField`) as diffusivities and viscosities. Using this implementation with `model.velocities` or `model.tracers` requires that users instantiate the velocity and tracer fields prior to building the model. The test provided with this PR gives an example:. ```julia; arch = CPU(); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)) . tracer_names = (:T, :S, :c) ; u, v, w = velocities = VelocityFields(arch, grid); T, S, c = tracers = TracerFields(arch, grid, tracer_names). ν = @at (Cell, Cell, Cell) u^2 * ∂z(T); κ = @at (Cell, Cell, Cell) S * c * sin(T). closure = IsotropicDiffusivity(ν = ComputedField(ν),; κ = ComputedField(κ)). model = IncompressibleModel(architecture=arch, grid=grid, closure=closure,; velocities=velocities, tracers=tracers); ```. A major gotcha with this implementation is that users _must_ pass the velocity and tracer fields on to `IncompressibleModel` (or the prescribed viscosity will be meaningless. We should probably also ensure that diffusivities-as-`Field`s are located at `Cell, Cell, Cell`, as the viscous and diffusive flux operators assume. A way we can prevent this error is to check that `ComputedField` viscosities or diffusivities contain references to `model.velocities` or `model.tracers`. However, this could --- in principle anyways --- exclude valid cases. I'm happy to merge as-is, or to make the implementation more robust, somehow. Possible todo:. - [ ] Allow specification of `AbstractOperation`s rather than `ComputedField`s in `IsotropicDiffusivity` constructor; - [ ] Check that `Field`-viscosities and diffusivities have correct location in `IsotropicDiffusivity` constructor; - [ ] Make implementation more robust / less error-prone?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/999:313,test,test,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999,1,['test'],['test']
Testability,"This PR felt so good!. The internal code base had to be massively refactored thus the size of this PR but I think it's taking the code base in the right direction with submodules for everything, and will make implementing big new features (like vertically stretched grid and MPI) much easier and cleaner. There were a few breaking changes, e.g. `Face` and `Cell` moving to `Oceananigans.Fields`. In particular, Oceananigans does not export `day`, `minute`, `second`, and `hour` anymore as they conflict with the `Dates` module used by the logger. And it might also confuse users as to why Oceananigans is exporting these common names. They are now exported by `Oceananigans.Utils`. But otherwise, the impact to user scripts is pretty minimal (the examples barely changed). This should be merged as the next PR ASAP as merging anything else in will probably create some form of merge conflict hell. Resolves #456; Resolves #495; Resolves #497; Resolves #563",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/591:539,log,logger,539,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/591,1,['log'],['logger']
Testability,"This PR finally reverses the `k` index although it's still a work in progress as a few tests fail. In particular, it seems that incompressibility is not satisfied even though I managed to get the ""recomputing w from continuity"" test to pass. Need to think about this some more. Resolves #90; Resolves #468 ; Resolves #480",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462:87,test,tests,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462,2,['test'],"['test', 'tests']"
Testability,This PR finally sets up a CI pipeline to run convergence tests and validation experiments for CPU and GPU on Buildkite. Don't think this should run on every push like the main pipeline does and I couldn't figure out how to trigger it via a GitHub comment (see https://github.com/CliMA/slurm-buildkite/issues/13). We can trigger this pipeline manually from Buildkite and I've scheduled it to run every night at 3am EST (on the master branch). Cool thing is that it uploads the convergence plots as artifacts so we can view them from Buildkite!. ![image](https://user-images.githubusercontent.com/20099589/100450878-6b5ceb00-3084-11eb-9cec-8072098b03b9.png). Resolves #1216,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223:57,test,tests,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223,1,['test'],['tests']
Testability,This PR fixes `Average` to correctly to use `mean!` when reducing over regular dimensions. It also adds a few tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2173:110,test,tests,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2173,1,['test'],['tests']
Testability,This PR fixes `set!` for `CubedSphereReducedField` for now which is used in the Rossby-Haurwitz validation experiment (and adds tests).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1622:128,test,tests,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1622,1,['test'],['tests']
Testability,"This PR fixes a bug in the `FourierTridiagonalPoissonSolver` that almost certainly meant it produced incorrect answers. There were two concurrent bugs that cancelled each other out, which allowed tests to pass:. 1. The Laplacian operator (previously called `∇²`, now called `∇²ᶜᶜᶜ`) was incorrect, because ""Face"" and ""Center"" superscripts were swapped. In other words, the Laplacian operator was correct for an object located at `(Face, Face, Face)`, rather than `(Center, Center, Center)` as it was being applied.; 2. `ΔzF` and `ΔzC` were also swapped in derivation of the `FourierTridiagonalPoissonSolver`. This means that both the docs and the code were incorrect. The tests passed because these two bugs effectively cancel each other out. This PR fixes both bugs. There still may be a lingering issue however, because the docs multiply the entire Poisson equation by the vertical grid spacing (which in the docs is written `ΔzC`, but should be `ΔzF`), including the source term. I didn't see immediately where to replace `ΔzC` with `ΔzF` in `solve_poisson_equation!`. The tests may pass anyways because there is no test that incompressibility is maintained on a stretched grid. I also cleaned up the Laplacian operators a bit, and the grid spacing operators, and added a convenience function `set_source_term!` so that users don't have to know about the special formulation that `FourierTridiagonalPoissonSolver` uses. TODO:. - [x] Update the docs; - [x] Test incompressibility on a stretched grid",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1541:196,test,tests,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541,5,"['Test', 'test']","['Test', 'test', 'tests']"
Testability,This PR fixes a bug that (apparently) crept in on #3401 --- I think. It's hard to know for sure because GPU tests don't pass right now. There may be more to fix. @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. @wsmoses @jlk9 we may need this to pass for your test PRs to be useful. @navidcy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413:108,test,tests,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413,3,['test'],"['test', 'tests']"
Testability,This PR fixes a bug that crept in during #2295 that affects closure tuples with more than one vertically-implicit closure. The bug was an incorrect calculation of the diagonal coefficient of the tridiagonal matrix that's solved to effect an implicit time-step. This PR also adds a test to the good ol' `test_diffusion_cosine` for a tuple of two vertically-implicit `VerticalScalarDiffusivity`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2377:281,test,test,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2377,1,['test'],['test']
Testability,"This PR fixes a test that compares the conjugate gradient and matrix-based implicit implicit free surface solvers. This test is failing because `tracer_advection = WENO5()`, which requires `halo = (3, 3, 3)`, while grid halos were left at the default `halo = (1, 1, 1)`. I also cleaned up some of the test formatting. @christophernhill @simone-silvestri any idea how this failing test got merged? I guess tests passed on a PR but not on `main` where #2105 was merged with #2108. This PR should be merged before #2130.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2131:16,test,test,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131,5,['test'],"['test', 'tests']"
Testability,This PR fixes an error in the Adams-Bashforth time-stepping algorithm so that tendencies from time-step `n-1` are computed correctly. This PR also computes tendencies after a time-step is complete rather than at the beginning of a time-step. This change causes the regression tests to fail. We should merge this change and correct the regression tests in a subsequent PR.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/664:276,test,tests,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/664,2,['test'],['tests']
Testability,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/839:131,test,tests,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839,3,['test'],"['tested', 'tests']"
Testability,"This PR fixes the behavior seen in https://github.com/CliMA/Oceananigans.jl/issues/2497. Basically due to the behavior of `construct_output()` and the default values for `indices` in the output writer constructors, whenever we pass a `Field` that is already sliced, we re-slice it when constructing the outputs. I'm not sure how to best avoid this behavior (I'm inclined to change the default value of `indices` in the output writers, but I'm taking suggestions), so I'm starting by simply adding a test that should fail without this fix. Closes https://github.com/CliMA/Oceananigans.jl/issues/2497",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508:499,test,test,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508,1,['test'],['test']
Testability,"This PR fixes the diffusive flux argument in the divergence of diffusive flux, `∇_dot_qᶜ`,; https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/src/TurbulenceClosures/diffusion_operators.jl#L47 to allow for the immersed boundary version using `_diffusive_flux_x`. This will make the tracer equations feel the immersed boundaries correctly. This also adds a very small 1D validation to test this. With a uniform buoyancy, validation checks if the buoyancy changes in time (it shouldn't). Below are the results before and after the fix. We can, of course, not include the validation and instead add a test for this.; ![b_plot1D_tracertest_bad](https://user-images.githubusercontent.com/67593861/129624223-70449ca0-5efb-4037-914a-20e1b565d4ca.png); ![b_plot1D_tracertest](https://user-images.githubusercontent.com/67593861/129624224-1eac8bae-7e78-4cc2-8b39-a202def6e975.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1935:420,test,test,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935,2,['test'],['test']
Testability,"This PR fixes two bugs in `WindowedTimeAverage`. The first is discussed in #962. The second occurs because it is possible that the output time specified by `time_interval` is reached prior to the completion of `time_window`. This PR changes `WindowedTimeAverage` so that average finalization occurs just prior to output. It'd probably be good to add a test to this PR. In addition, issues like this suggest it may be best to adjust the time-step so that output is ""aligned"". We can do this without cost now that we have a RungeKutta3 timestepper.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/964:352,test,test,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/964,1,['test'],['test']
Testability,"This PR generalizes `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` to accept functions of `x, y, z, t` as well as constants. It also generalizes `AnisotropicDiffusivity` to allow different diffusivities in `x`, `y`, and `z`, rather than 'horizontal' and 'vertical'. It preserves backward compatibility by providing constructors, `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` with the same syntax as previously. Todo:. - [x] add tests. Resolves #781 . cc @sandreza @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/806:471,test,tests,471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/806,1,['test'],['tests']
Testability,"This PR generalizes `fill_halo_regions!` for flux boundary conditions to work correctly for biharmonic diffusivities, in addition to second-order diffusivities. This will allow biharmonic diffusivities to be used in closed domains or along `Bounded` dimensions. In particular (and after tweaking the definition of `AnisotropicBiharmonicDiffusivity`), no flux conditions on any even diffusion operator are enforced by ensuring that odd derivatives across the boundary are zero. This was already done for the first derivative, but did not work for third derivatives and higher. In this PR, kernels are written that _reflect_ fields across the boundary for flux boundary conditions. Reflection implies that odd derivatives are zero and ensures that no flux is enforced for diffusivities of order higher than two. Note that `Value` and `Gradient` boundary conditions do not work for biharmonic diffusivity (and likely never will). Thus only `Flux` and `Periodic` boundary conditions are supported with biharmonic diffusivity. This PR also does some minor shuffling of file content and names, and generalizes the tracer and momentum budget tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/904:1135,test,tests,1135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/904,1,['test'],['tests']
Testability,"This PR generalizes the broadcasting implementation to work with fields reduced in any direction. The changes mean that, for example, if broadcasting to a field that's reduced in _two_ directions (eg a 1D field on a 3D grid), the kernel that's launched to do the computation will be 1D and therefore will not ""waste"" computation. It also turns out that the ""generalization"" requires less code than the original implementation (doh). This PR also adds more tests for broadcasting to reduced fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2157:456,test,tests,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2157,1,['test'],['tests']
Testability,This PR greatly simplifies the logic behind `conditional_operation` and how its extended for immersd boundary grid. The end result besides source code clean up seems to be an improvement in type inference. Resolves #3750 I think. But @ali-ramadhan please test. EDIT: I decided not to work on #3791 (here) because this requires fixing a bunch of tests and is a bigger effort.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794:31,log,logic,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794,3,"['log', 'test']","['logic', 'test', 'tests']"
Testability,"This PR implements Craik-Leibovich terms in Oceananigans, so that users may model the effect of surface waves. We use the Lagrangian-mean interpretation for the velocity field when surface waves are included, which requires much less modification of the governing equations than the Eulerian-mean interpretation. For example, the tracer equation (and particle advection equation) is unchanged in the Lagrangian-mean interpretation. This PR adds docs that describe the Lagrangian-mean equations, a simple test for instantiation, and an example that runs a very coarse version of the simulation in [McWilliams et al, ""Langmuir turbulence in the ocean,"" Journal of Fluid Mechanics (1997)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38). The surface wave terms are added to a module in `SurfaceWaves.jl`. As discussed previously, this may not be the source code organization we want. We should discuss.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/519:504,test,test,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/519,1,['test'],['test']
Testability,"This PR implements a major refactor of the `TurbulenceClosures` module. In particular, it ""standardizes"" how turbulence closures specify diffusive fluxes. Each turbulence closure now defines 12 functions (or opts in to functionality via subtyping, eg `AbstractEddyViscosityClosure`):. * `diffusive_flux_x`, `diffusive_flux_y`, and `diffusive_flux_z` for tracer diffusive fluxes; * `viscous_flux_ux`, `viscous_flux_uy`, and `viscous_flux_uz` for viscous fluxes of x-momentum; * 6 other functions similar to `viscous_flux_ux`, etc for `y` and `z` momentum components. Then there is a single implementation of `∇_κ_∇c`, for example, which calculates the divergence of the diffusive fluxes in a way that generalizes to curvilinear grids. This refactor was not that difficult because many turbulence closures had functions analogous to these --- they were just called by different names. So in a way this PR simply establishes standard notation. A major advantage of standard notation is that we can now correctly specify flux boundary conditions even when we cannot fill halos for this purpose. For example, right now we fill halos so that (fingers crossed!) boundary fluxes are zero when the diffusion operator is evaluated on boundary-adjacent cells, and then in a second step add the specific boundary fluxes. But with a function `diffusive_flux_x`, we can now ""reverse"" boundary fluxes and add specified fluxes generically. This PR therefore makes progress towards #1400. Work on this PR started with a few extra tests for `HydrostaticFreeSurfaceModel` (though its focus is not quite different). So as a bonus this PR also adds tests for `HydrostaticFreeSurfaceModel` (which may need to be disabled if they fail on the GPU so that we can get this PR in sooner rather than later).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1449:1513,test,tests,1513,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449,2,['test'],['tests']
Testability,"This PR implements a minor performance optimization that changes the 'default' boundary condition type to `BoundaryCondition{Flux, Nothing}`. Using this type elides the adding of 0's in the case of zero flux boundary conditions. The functionality for eliding computation in this case was already implemented; however it was not used by default. . This may address #397, but @ali-ramadhan we need to benchmark.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/402:399,benchmark,benchmark,399,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/402,1,['benchmark'],['benchmark']
Testability,"This PR implements a new boundary condition API. It's a bit of a work in progress. Before merging we need:; * tests (simple 1D test with temperature to see if budgets are correct?); * export some appropriate objects / functions to user; * some API development to make boundary condition specification easier; * documentation. Criticism welcome!. ## Summary of implementation: the `BoundaryCondition`. The core type of this PR is `BoundaryCondition`. The `BoundaryCondition` has one field, `calc`, and is made callable via. ```julia; (bc::BoundaryCondition)(args...) = bc.calc(args...); ```. A `BoundaryCondition` has one parameter: `BCType`. The `BCType` can be `Default`, `Flux`, or `Value`. We include `Default` because the specification of boundary conditions is baked in to the algorithm. In the case of 'default' boundary conditions, no calculations are made. ### `nboundary_conditions = nfields x ndims x 2`. In principle, the user can specify `5 x 3 x 2` boundary conditions: on each of the 5 fields (which we currently have --- unfortunately, we may want more in the future), the user can specify a condition on any of the 6 boundaries. The model is initialized with all 30 boundary conditions set to `Default`. We allow for all possible boundaries to have conditions by introducing three structs:. * `CoordinateBoundaryConditions` with fields `left` and `right`; * `FieldBoundaryConditions` with fields `x`, `y`, and `z`; * `BoundaryConditions` with fields `u`, `v`, `w`, `T`, and `S`. ### Specifying boundary conditions and user API. A boundary condition is now specified by defining a function that calculates it within a kernel that loops over the boundary in question. The arguments of a flux boundary conditions on a top or bottom boundary (the only situation supported so far) are. ```julia; u, v, w, T, S, t, step, Nx, Ny, Nz, Δx, Δy, Δz, i, j; ```. This will probably change in the future. The user API is rather threadbare at the moment. To define a constant flux boundary condition,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118:110,test,tests,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118,2,['test'],"['test', 'tests']"
Testability,"This PR implements a new framework for high-order advection schemes. There are two types of advection schemes: `AbstractCenteredAdvectionScheme` and `AbstractUpwindBiasedAdvectionScheme`. This PR implements momentum and tracer flux operators such that an centered advection scheme needs only to implement 7 functions: 6 `symmetric_interpolate_*` functions for `x, y, z` at cell centers and interfaces, and a `boundary_buffer` scheme that indicates the buffer needed around boundaries in `Bounded` directions`. . Upwind biased advection schemes need 19 functions: `halo_buffer`, 12 functions for `left_biased_interpolate_*` and `right_biased_interpolate_*`, and 6 functions for `symmetric_interpolate_*` that use a symmetric interpolation (typically of order `m-1`, where `m` is the order of the upwind scheme). These are used for momentum advection. This PR refactors fourth order advection to use the framework. It still needs:. - [x] third-order upwind biased advection (as an example); - [x] tests. Resolves #965",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/972:995,test,tests,995,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/972,1,['test'],['tests']
Testability,"This PR implements a new schedule called `ConsecutiveIterations`. This schedule is constructed with a ""parent schedule"" as an argument and an optional second argument specifying the ""number"" of consecutive iterations to actuate for:. ```julia; schedule = ConsecutiveIterations(TimeInterval(100)). schedule = ConsecutiveIterations(IterationInterval(4)). schedule = ConsecutiveIterations(IterationInterval(20), 3); ```. The schedule will then actuated (ie, triggering output writing or callback execution) at _both_ the moment specified by the parent schedule, and for `N` iterations consecutive to that one, where `N=1` by default. This PR also adds a property `offset` to `IterationInterval`. Together, this allows one to compute time-derivatives (either forward derivative, or, if using `IterationInterval(N, offset=-1)`, a centered difference). cc @whitleyv . TODO. - [ ] Test. This could also maybe be called `SubsequentIterations`... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2100:874,Test,Test,874,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100,1,['Test'],['Test']
Testability,"This PR implements a regression test framework for `HydrostaticFreeSurfaceModel`. This PR doesn't actually change any of the tests; it just adds a script. We'd like to put the regression test data somewhere else, like `OceananigansRegressionTests.jl` or something, and then use `DataDeps.jl` to download updated regression test data if need be. We can experiment with that workflow here. It'd be nice to get regression test data in before modifying any non-regression-tested operators to work on curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1373:32,test,test,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373,6,['test'],"['test', 'tested', 'tests']"
Testability,"This PR implements a relatively simple convective adjustment scheme that provides the option for convective adjustment of both momentum and tracers. The closure scheme implements only a vertical diffusivity, and has a convenience ""background diffusivity"" in addition to a convective diffusivity that is active when the buoyancy gradient is unstable. Both the convective and background diffusivities may be functions of space and time, or may be discrete fields, and can be different for each tracer. Here's a result from a new validation test:. ![image](https://user-images.githubusercontent.com/15271942/120872660-cf88cc00-c54b-11eb-991a-8ff835bd3eb0.png). I also need to add unit tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1738:538,test,test,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738,2,['test'],"['test', 'tests']"
Testability,"This PR implements a sponge layer to dampen waves at the bottom layer of the model, needed for seasonal cycle mixed layer simulations following the re-stratification process which seems to generate internal waves that grow unphysically large in amplitude (from PR #292). It's implemented by appending wave damping terms to the existing forcing functions. Not sure if this will work, but it's the ideal implementation I think. For now it's just a prototype. But the point is that if you want a sponge layer, you just call `add_sponge_layer!(model; damping_timescale)`. Still needs a test. cc @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/291:582,test,test,582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/291,1,['test'],['test']
Testability,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/945:657,test,tests,657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945,3,['test'],"['test', 'tests']"
Testability,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968:959,Test,Tests,959,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968,1,['Test'],['Tests']
Testability,"This PR implements dichotomous forms for `ShallowWaterModel.solution`: if `solution = ConservativeSolution()`, then the solution fields are `uh, vh, h` and the PDE is written in ""conservative"" form. If `solution = PrimitiveSolution()`, then the `solution` fields are `u, v, η` and the solution is written in the ""primitive"" form. . We will also linearize the solution around `h = H + η`; however @francispoulin and I deemed that `LinearizedPrimitiveSolution` might be misleading since the momentum equation is still nonlinear (only the height equation is linearized). Alternative names to `PrimitiveSolution` are welcome... . To do:. - [ ] implement tendency equations for `solution::PrimitiveSolutionFields`; - [ ] basic tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1339:722,test,tests,722,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1339,1,['test'],['tests']
Testability,"This PR implements seven new internal wave dynamics tests that run for both `IncompressibleModel` and `HydrostaticFreeSurfaceModel`, on vertically-stretched grids, and on `Flat` topologies for both models and both regular and stretched grids. The tests show that `VerticallyStretchedRectilinearGrid` does not work with `Flat` dimensions. For `IncompressibleModel`, this usage produces a warning that ""`FourierTridiagonalPoissonSolver` is probably not correct."" Ironically, it's this warning thats _probably_ not correct: the issue with `Flat` and vertically-stretched grids appears to lie in the lack of flat grid metrics for any grid but `RegularRectilinearGrid` --- not the Poisson solver. We can fix this problem in this PR. In that case it will resolve #1849.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1865:52,test,tests,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865,2,['test'],['tests']
Testability,"This PR implements the infrastructure for open boundary conditions in the `NonhydrostaticModel` as well as a few simple methods. . This PR:. - [x] Adds a `matching_scheme` property to `Open` boundary classifications to allow different `fill_X_halo!` to be dispatched; - [x] Introduces `update_boundary_condition!` to be called before halo fills allowing the `mathcing_scheme` to have properties which can evolve with the model; - [x] Make the existing tests pass; - [x] and implements a zero gradient matching scheme. (Others please feel free to update this comment as necessary.). ------------------------------------------------------------------------; Hi all,. Following discussion with @glwagner, @simone-silvestri, and @jm-c this is a first attempt at implementing open boundary conditions. First I will try to get it working for the non-hydrostatic model which seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:452,test,tests,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['test'],['tests']
Testability,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639:911,test,test,911,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639,2,['test'],"['test', 'tests']"
Testability,"This PR incorporates significant updates from PR #3306. Most importantly, it employs the new halo-filling functions to update the halos of the prognostic variables. Additionally, it removes the replace_horizontal_vector_halos! function, enhances existing methods and function calls related to the cubed sphere grid, and refines the vorticity computation function. It also implements a new test to verify that the norm of the prognostic variables of the Rossby-Haurwitz wave remains almost constant as it propagates over the cubed sphere.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570:389,test,test,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570,1,['test'],['test']
Testability,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910:314,test,tests,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910,3,['test'],['tests']
Testability,"This PR integrates the `TurbulenceClosures` module into time stepping and boundary conditions. The need to abstractly deal with anisotropic transport coefficients for arbitrary boundaries introduces considerable complexity. This problem is solved by exporting `NamedTuples` that collect functions to calculate the diagonal components of viscosity and diffusivity at the necessary locations. The consequence of this implementation is viewed in the `apply_bcs!` function. Only the `ConstantAnisotropicDiffusivity`closure (corresponding to the former default) is currently tested. In the future, we should probably make `ConstantIsotropicDiffusivity` the default, and remove the option to set the horizontal and vertical diffusion tensor components in the `Model` constructor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245:570,test,tested,570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245,1,['test'],['tested']
Testability,"This PR integrates the finite volume operators introduced in PR #283. This includes merging `closure_operators.jl` into `Oceananigans.Operators`. All tests pass but there's quite a bit of cleanup to be done. @glwagner This PR affects a lot of code you've written so we should probably work on merging this PR together. Now that tests pass we can focus on cleanup. I still need to convert the biharmonic operators and `leith_enstrophy_diffusivity.jl` closure to finite volume. I'll also add a test for Leith. There are regression tests for constant diffusivty, Smagorinsky, and AMD, but not for other closures, so we should probably be careful that closures with no regression test remain unchanged. Some comments:. 1. The `norm` functions defined in `velocity_tracer_gradients.jl` https://github.com/climate-machine/Oceananigans.jl/blob/2bb32015e64bff830f2233d588360ccc6b8605b4/src/TurbulenceClosures/velocity_tracer_gradients.jl#L130-L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/529:150,test,tests,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529,5,['test'],"['test', 'tests']"
Testability,"This PR intends to abstract the concept of a grid with ""multiple regions"" from the cubed sphere. We only need one `MultiRegionGrid` to support a wide variety of configurations, including the CubedSphere. The hope in the near term is that this clarifies the code and implementation of cross-region halo exchanges. This PR was also going to implement broadcasting and try to get `ComputedField` working for fields and `AbstractOperations` distributed across multiple regions. This would get the PreconditionedConjugateGradientSolver working on MultiRegionGrid. To get this working we ""only"" need to define `get_region(op, i)` for `op::BinaryOperation, UnaryOperation, MultiaryOperation, Derivative`, which might not be too difficult. It also intends to define a macro `@regionalize` which we can use either to decorate existing functions or to conveniently extend functions to broadcast across multiple regions. Right now ""regional broadcasting"" is done manually, which is cumbersome and presumably can only lead to a build up of boilerplate. My changes broke the halo exchange tests however. @ali-ramadhan I need your help to fix these. If we can fix the tests, then we can move forward with this PR. Otherwise we may have to start over.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1614:1076,test,tests,1076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1614,2,['test'],['tests']
Testability,"This PR introduces a Beta Plane option for Coriolis. If merged, it will replace #438. We should consider introducing an example (and regression test based on that example) that runs a model on a beta plane, and in a channel to demonstrate / test some currently undemonstrated features. Co-authored with @suyashbire1.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/490:144,test,test,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/490,2,['test'],['test']
Testability,"This PR introduces a major refactor of `FieldBoundaryConditions` and changes the user API. The `grid` and field location are no longer necessary to build `FieldBoundaryConditions`. This means that the constructors `TracerBoundaryConditions`, `UVelocityBoundaryConditions`, etc, are gone. Instead we have only `FieldBoundaryConditions`, which is used like. ```julia; u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(-1e-4), bottom=FluxBoundaryCondition((x, y, t, u) = -1e-3 * u, field_dependencies=:u)). T_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)); ```. There's also a new constructor `AuxiliaryFieldBoundaryConditions` which takes the place of `ComputedFieldBoundaryConditions` and is now the default for `Field` and `ComputedField`. The difference is that `AuxiliaryFieldBoundaryConditions` have `nothing` instead of an `ImpenetrableBoundaryCondition` in `Bounded` directions when they're located on faces. Under the hood the `FieldBoundaryConditions` struct is ""flattened"" so there's no more `CoordinateBoundaryConditions`. In addition, a new field `immersed` is added to `FieldBoundaryConditions` in addition to `east`, `west`, etc. This will be used to support boundary conditions on immersed boundaries in the future. There's still quite a few validation experiments to clean up and probably some lingering issues with tests, but I was able to get the examples to run so I thought it was the right time to open the PR. On the API changes: it seemed like a positive change that we don't need `grid` in the boundary conditions constructor, and that we only have one name `FieldBoundaryConditions` rather than 4. However, if others feel they liked the old API, we can add convenience functions `TracerBoundaryConditions`, etc back to the source.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843:1354,test,tests,1354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843,1,['test'],['tests']
Testability,"This PR introduces a metric to compute the implicit dissipation introduced by flux form advection schemes.; This metric has been devised by @jm-c and is still subject of some tests + writeup of the method, so this PR is still very much a work in progress.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3877:175,test,tests,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3877,1,['test'],['tests']
Testability,"This PR introduces a new reentrant channel model type, the `ChannelModel`, which is periodic in x, has walls in the y-direction, and has the usual rigid lid at the top. It's just a regular `Model` but with no-flux boundary conditions in the y-direction on all fields. The halo regions are filled in appropriately to apply the free-slip boundary conditions. This is nice as we get a channel without having to change the operators or time-stepping at all. @jm-c has pointed out that things could get complicated with this approach when we get to implementing e.g. positivity-preserving advection schemes with having to fill the halo regions very frequently, but we agreed to cross that bridge when we get there. At that point, masks may turn out to be a better approach. It would be nice to have a solid physics test before merging this. Perhaps https://github.com/climate-machine/Oceananigans.jl/issues/100#issuecomment-483255199 would work, although we've had some issues setting up a flow in thermal wind balance (see PR #179). It might still work as an eyeball test. I will release a new minor version once this PR is merged. Resolves #100. Helps with #242 ; Helps with #258",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/290:810,test,test,810,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290,2,['test'],['test']
Testability,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239:36,test,test,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239,10,"['sandbox', 'test']","['sandbox', 'test', 'tests']"
Testability,"This PR introduces a new steady-state test case tailored for the cubed sphere. It initializes surface elevation and velocities using a steady-state solution, aiming to study the temporal evolution arising from the numerical discretization errors. Smooth spatial and temporal error increments are expected. However, if the errors escalate at an unprecedented rate between panels with non-trivial connectivities, it indicates a potential bug, such as improperly filled halos.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302:38,test,test,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302,1,['test'],['test']
Testability,"This PR introduces a script for simulating Stratified Couette flow with the aim of reproducing the LES results of Vreugdenhil & Taylor (2018). See https://github.com/climate-machine/Oceananigans.jl/issues/310 for more details. When the verification is completely successfully, I will ensure the script is maintained in the `test/verification/` subdirectory so that the verification can be reproduced at any time. I will also convert it to a regression test. See #347. Resolves #310 ; Resolves #415; Contributes to #346 and #347",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/381:324,test,test,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/381,2,['test'],['test']
Testability,This PR introduces a test to verify the correct execution of a distributed immersed latitude longitude grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3487:21,test,test,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3487,1,['test'],['test']
Testability,"This PR introduces a validation test replicating the mesoscale eddying channel setup discussed in section 3(b) of Haine & Marshall (1998). It's not clear we want to make this a full validation test so I'm leaving it as a draft PR for now. We may instead want to move to more realistic simulations with a LESbrary approach. References; ----------; Haine & Marshall (1998). [Gravitational, symmetric, and baroclinic instability of the ocean mixed layer](https://doi.org/10.1175/1520-0485(1998)028<0634:GSABIO>2.0.CO;2). Journal of physical oceanography, **28**(4), pp. 634-658.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771:32,test,test,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771,2,['test'],['test']
Testability,"This PR introduces test functions to verify the accurate halo filling at face-face locations of the orthogonal spherical shell grids comprising the six panels of the conformal cubed sphere. Additionally, it provides comments and docstrings for these test functions, thereby closing #3242.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3277:19,test,test,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3277,4,['test'],['test']
Testability,"This PR introduces the `NormalFlow` boundary condition, and renames `BoundaryCondition(NoPenetration, nothing)` to `BoundaryCondition(NormalFlow, 0)`. There is an alias `ImpenetrableBoundaryCondition() = BoundaryCondition(NormalFlow, 0)`, though this probably won't be touched by users. This PR also extends boundary conditions to the `x`-direction, and reversed an incorrect assumption that `Value` and `Gradient` boundary conditions should be applied at all halo points. In reality, extra boundary conditions are required for the case that halo regions are larger than 1. Developing an abstraction for higher-order boundary conditions is straightforward, but is not a priority. The implementation of `NormalFlow` boundary conditions is likely incorrect for general stretched grids. We don't have a test for this, however. I think we should wait until we have full stretched grid implementation to fix this; it should not be hard. It requires correctly satisfying the continuity equations in halo regions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/710:800,test,test,800,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/710,1,['test'],['test']
Testability,"This PR is a first stab at tackling #1493. It adds a `FieldTimeSeries` type that stores a time series of an entire field taken from a JLD2 file and a `FieldDataset` function that stores all the fields from a JLD2 file in a `Dict{String,FieldTimeSeries}`. There are two flavors: `FieldTimeSeries{InMemory}` where the data is loaded fully into memory into a 4D array, and `FieldTimeSeries{OnDisk}` which lazily loads different time snapshots from disk. Indexing linearly into a `FieldTimeSeries` returns a `Field`. Immediate TODO:; - [x] Test `architecture = GPU()`. Right now it's pretty barebones. Some more work on `Oceananigans.Fields` might be needed before we get a fully-featured `FieldTimeSeries`. Eventually it would be great to be able to be able to:; 1. Have `FieldTimeSeries` work with abstract operations like it was a `Field` broadcasting over time.; 2. Work with `FieldTimeSeries` as if it were a 4D array (with operations ignoring the halos).; 2. Have named dimensions, slick selectors, and references dimensions through DimensionalData.jl. Some things to think about:; 1. Since the aim is to work with abstract operations, `FieldTimeSeries` right now only work with JLD2 data that includes halos. Do we want to support loading data without halos?; 2. Do we want `FieldTimeSeries` to support reading from NetCDF? If the answer to (1) is yes then this shouldn't be hard to support.; 3. Right now function boundary conditions are lost in serialization. We should probably allow users to specify boundary conditions on `FieldTimeSeries`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1641:536,Test,Test,536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641,1,['Test'],['Test']
Testability,"This PR is a first, explorational, attempt to introduce higher order (upwind and WENO) schemes in a Vector Invariant formulation (following chapter 7 of https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.705.7543&rep=rep1&type=pdf). To test them, this PR also revamps some test cases implemented by @sandreza in #1570 and new ones from the test set of Williamson et al 1992. Here a comparison between the 2nd order vector invariant scheme and the WENO vector invariant scheme on the Rossby-Haurwitz wave test case implemented in #1570 with an Implicit free surface formulation (`g = 900 ms⁻²`) and no dissipation. The video shows contours of vertical vorticity. https://user-images.githubusercontent.com/33547697/156962391-77527d5d-a059-450e-b3bb-a517237e485c.mp4. This is a first exploration. I am not completely convinced WENO interpolation can be used for vorticity onto curvilinear coordinates without a proper coordinate transform (although this is what we do for tracers...). Indeed, I am not completely sure about the correctness of the solution showed in the videos above... The scheme is for sure more stable, but I think it's just the byproduct of numerical diffusion being too high (there is no viscosity!). The same was happening when using uniform WENO on a stretched grid. It actually seems that a coordinate transformation should be applied and WENO weights should be different in case of a curvilinear grid (https://arxiv.org/pdf/1711.06212.pdf). . Applying WENO one dimension at a time instead of doing a full 2D/3D interpolation might also be incorrect for FV... (This might also impact how we do tracer advection with WENO on curvilinear grids)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317:243,test,test,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317,4,['test'],['test']
Testability,"This PR is a revision of Github issue PR [2949](https://github.com/CliMA/Oceananigans.jl/pull/2949) and is related to issue [1546](https://github.com/CliMA/Oceananigans.jl/issues/1546). There is a potential conflicting PR [2538](https://github.com/CliMA/Oceananigans.jl/pull/2538). This PR brings in the AMDGPU backend for kernelabstractions for the hydrostatic primitive equation solver. . @simone-silvestri and @siddharthabishnu have guided me towards using a global double drake simulation as a testbed for this porting activity, benchmark scripts are at https://github.com/simone-silvestri/OceanScalingTests.jl/blob/ss-js/adapt_double_drake/run_double_drake.sh",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3466:498,test,testbed,498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3466,2,"['benchmark', 'test']","['benchmark', 'testbed']"
Testability,"This PR is a stab at implementing the pressure solvers plan/overhaul outlined in #586. So far it implements pressure solvers for all types of domains (triply/doubly periodic, channels, and boxes) on regular grids (except boxes on GPUs for now). Equally important, it refactors and cleans up the pressure solvers so that we can now easily add in pressure solvers for vertically stretched grids and distributed models. A lot of cleanup was done in the process as well. Pressure solver code and kernels have been fully moved from the `TimeSteppers` submodule to the `Solvers` submodule. Different parts have been reorganized into multiple files and the index permutation business has been abstracted away a bit so we have fewer ugly kernels (and fewer kernels!). I could have gone much further in condensing the code base and number of pressure solvers. You'll notice quite a bit of code repetition, but I think for now and the forseeable future this is actually a good thing. The pressure solver code is nontrivial and keeping it as simple as possible will improve the readability and longevity of the code base. It's also easier to add and modify pressure solvers now. For example, if @sandreza wants to implement a fast pressure solve that only works for horizontally periodic domains (Kleiser-Schumann?), it's now much easier to do that. I should probably add some benchmarks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/589:1366,benchmark,benchmarks,1366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/589,1,['benchmark'],['benchmarks']
Testability,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/727:42,benchmark,benchmarking,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727,6,"['benchmark', 'log', 'test']","['benchmark', 'benchmarking', 'logs', 'test', 'tested']"
Testability,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035:410,test,tests,410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035,3,['test'],"['test', 'tests']"
Testability,"This PR is part 1 of _n_ implementing halo regions (originally PR #167). Here I just replace Arrays and CuArrays with OffsetArrays containing an Array or CuArray. . An important change is the introduction of the `data(::Field)` function which returns the data stored by the field, i.e. without halo data. Lots of refactoring had to happen but it was mostly in updating the tests to use the `data` function. The Poisson solver had to be refactored because FFTW and cuFFT won't work properly on an offset array containing halos. The Poisson solver now keeps track of the right-hand-side, Fourier coefficients, and solution using `solver.storage` which is a regular `Array` or `CuArray`. This cuts down memory usage as well. Works on #104. Resolves #45; Resolves #122; Resolves #177",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/250:373,test,tests,373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250,1,['test'],['tests']
Testability,"This PR is ready for merger when approved, and tests pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/408:47,test,tests,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/408,1,['test'],['tests']
Testability,"This PR just implements the proposed solution in issue #3679 so that the CFL calculation is correct on flat grids. I also added a test that fails without the fix, and passes with the fix. Resolves #3679",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3737:130,test,test,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3737,1,['test'],['test']
Testability,This PR just merges in @glwagner's closure benchmarking script. Should be useful in investigating how much shared memory can speed up the model while running constant Smagorinsky.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/289:43,benchmark,benchmarking,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/289,1,['benchmark'],['benchmarking']
Testability,"This PR makes `model.diagnostics` and `model.output_writers` into `OrderedDict`s by default. In addition, we add functionality that preserves the existing behavior: when the user calls `push!(model.diagnostics, new_diagnostic)`, the diagnostic `new_diagnostic` is given a default name (something like `:diag1`). In addition, the diagnostics can be accessed by index (an integer) or by name (assumed to be a `Symbol`, though in principle anything except an integer might be used). Giving names to diagnostics should prove useful for saving `Timeseries` diagnostics, or accessing the value of a diagnostic for logging / other purposes. We use `OrderedDict` so that the diagnostics and output writers are executed in the order they were inserted, which is a potentially useful feature for interdependent diagnostics. We also add code that extends the functionality of `Timeseries` so that the user may pass a `NamedTuple` of timeseries, eg:. ```julia; cfl_timeseries = Timeseries((adv=AdvectiveCFL(dt), diff=DiffusiveCFL(dt)), frequency=1); model.diagnostics[:timeseries] = cfl_timeseries; ```. The sampled values would then be stored in `cfl_timeseries.data.adv` and `cfl_timeseries.data.diff`. By extending `getproperty`, we also provide syntax such that. ```julia; cfl_timeseries.adv; ```. returns the array `cfl_timeseries.data.adv`, for user convenience. As for ""non-tupled"" diagnostics, the samples in `cfl_timeseries.data.adv` can be plotted alongside `cfl_timeseries.time`. Resolves #362.; Resolves #361.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/411:608,log,logging,608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/411,1,['log'],['logging']
Testability,"This PR makes a few bugfixes and improvments:. 1. Fixes a bug for `VectorInvariantEnstrophyConserving` Coriolis scheme for `HydrostaticSphericalCoriolis`; 2. Edits tracer advection operators so they run on curvilinear grids; 3. Adds `validation/solid_body_rotation/` based on [Williamson et al. 1992](https://www.sciencedirect.com/science/article/pii/S0021999105800166). This PR also attempted to add a tracer advection test (using the solid body rotation solution), but this test fails. So we have some work to do to get tracer advection to work still. It'd be nice to implement some quantitative measures of error for the solid body rotation test before merging. Here's a movie that illustrates what the solid body rotation test does (showing incorrect tracer advection):. https://user-images.githubusercontent.com/15271942/109338288-0c9a3f80-7834-11eb-8189-9137cec2cd92.mp4. As a side note, it would be extremely useful to have a utility that computes a height field satisfying discrete geostrophic balance with some flow + Coriolis implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1404:420,test,test,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404,4,['test'],['test']
Testability,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [ ] Tests that allocating reductions of abstract operations work (`maximum(a * b)`, etc); - [ ] Test that allocating reductions are correct (eg they only reduce over the interior of an array); - [ ] Benchmark?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2039:203,Test,Tests,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2039,3,"['Benchmark', 'Test']","['Benchmark', 'Test', 'Tests']"
Testability,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. ~~One change is to perform in-place reductions of `AbstractDataField` (fields backed by data) using the parent arrays (this is much faster as those arrays are contiguous).~~ (This doesn't work, obviously in hindsight) We also try to support allocating reductions of `AbstractOperations` like `maximum(a * b)`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [x] Tests that allocating reductions of abstract operations work; - [x] Test that allocating reductions are correct (eg they only reduce over the interior of an array); ~~- [ ] Benchmark?~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2040:513,Test,Tests,513,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2040,3,"['Benchmark', 'Test']","['Benchmark', 'Test', 'Tests']"
Testability,"This PR makes a few small changes needed to use ContinuousBoundaryFunction with auxiliary fields, which have no notion of ""time"" or other model fields. For this case; we want to be able to write something like. ```julia; c_surface(x, y) = cos(pi * x); c_bcs = FieldBoundaryConditions(grid, (Center, Center, Center), top = ValueBoundaryCondition(c_surface)); c = CenterField(grid, c_bcs); fill_halo_regions!(c.architecture, c); ```. Prior to this PR this would fail (we only supported constant boundary conditions on auxiliary fields). This PR also ""reduces"" the location at which the boundary condition is applied, so that `ReducedField`s might use something like. ```julia; r_surface(x) = cos(pi * x); r_bcs = FieldBoundaryConditions(grid, (Center, Nothing, Center), top = ValueBoundaryCondition(r_surface)); r = ReducedField(Center, Nothing, Center, grid, r_bcs); fill_halo_regions!(r.architecture, r); ```. if we eventually set the location of fields in `Flat` dimensions to `Nothing` this will also have an impact on syntax used for building models. This PR needs a test or two before merging. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1859:1070,test,test,1070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859,1,['test'],['test']
Testability,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1924:865,benchmark,benchmark,865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924,2,"['Benchmark', 'benchmark']","['Benchmarking', 'benchmark']"
Testability,"This PR makes tests and validations pipelines to run using Julia v1.7.; Furthermore, it updates `Manifest.toml` files from v1.0 to v2.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2090:14,test,tests,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090,1,['test'],['tests']
Testability,This PR moves tests on Julia v1.9.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100:14,test,tests,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100,1,['test'],['tests']
Testability,This PR nukes the `BasicModel` legacy constructor to avoid potential confusion. I also made the `NonDimensionalModel` constructor act more like the `Model` constructor. Also fixed a typo there and added a test. Resolves #429,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/496:205,test,test,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/496,1,['test'],['test']
Testability,"This PR nukes the last two broken tests: deep convection which has been stale and broken for months, and the example test which was never working anyways. Now that we're back to having no broken tests, would be nice to keep it that way.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/368:34,test,tests,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/368,3,['test'],"['test', 'tests']"
Testability,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1971:1394,test,tests,1394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971,1,['test'],['tests']
Testability,"This PR partially generalizes the implementation of flux boundary conditions to work on curvilinear grids. The design implemented in this PR required a number of changes:. - Preservation of field locations in GPU kernels through a generalization of `adapt_structure(to, field::Field)`; - Creation of generic area and volume operators that dispatch on location like `Ax(i, j, k, grid, X, Y, Z)` (others are `Ay`, `Az`, and `volume`); - Generalization of `apply_top_z_flux!`, etc. The similar functions for `x` and `y` could also be generalized in this PR, though we don't have regression tests to ensure that they still work as before...; - Activation of `calculate_boundary_tendencies!` for `HydrostaticFreeSurfaceModel`. The new `validation/barotropic_gyre.jl` experiment is definitely a work in progress but will eventually produce a movie like. https://user-images.githubusercontent.com/15271942/110257064-a747fc00-7f61-11eb-83aa-18665f01efb4.mp4. We may want to add side and bottom drag, tweak the surface stress, and tweak the viscosity.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1433:587,test,tests,587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1433,1,['test'],['tests']
Testability,"This PR permutes the dimensions of the _temporary array_ that's used by the `DistributedFFTBasedPoissonSolver` (and `PencilFFTs`) compared to Oceananigans data layout to look like (z, x, y). This permits ""pencil"" decompositions in x, y via PencilFFTs, which cannot partition along the first dimension. This PR should probably expand the tests to cover these cases, which weren't tested previously because it wasn't supported. Co-developed with @johnryantaylor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2513:337,test,tests,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2513,2,['test'],"['tested', 'tests']"
Testability,This PR picks up from where PR #479 left off. From #479:. > This PR adds two regression tests for models that use the ConstantSmagorinsky closure and the AnisotropicMinimumDissipation closure. It also organizes the regression tests into a separate directory. Resolves #473,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/484:88,test,tests,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/484,2,['test'],['tests']
Testability,"This PR provides a convenience constructor for building `UniformStokesDrift` with four `Field`s for the Stokes shear and tendency, rather than functions. It also adds kernel functions for the field case, so users now have the choice between functions of `(z, t)`, `Field`s, or `nothing`. This is useful when calculating the Stokes profile is a relatively expensive or involved computation (eg, involving integration over a spectrum of waves). This permits two optimizations:. 1. Stationary Stokes shear profiles can be precomputed.; 2. Time-dependent Stokes shear profiles and Stokes tendencies can be computed in a `Callback`. This saves computation time for 3D runs because the Stokes profiles are 1D.; ; co-authored with @qingli411. TODO: . - [x] add a test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2320:756,test,test,756,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2320,1,['test'],['test']
Testability,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/570:510,test,tests,510,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570,4,"['benchmark', 'test']","['benchmark', 'benchmarks', 'tests']"
Testability,"This PR refactors the Poisson solvers so that:. 1. All our solvers (FFT-based, mixed FFT / tridiagonal, tridiagonal, and preconditioned conjugate gradient) have a consistent interface that's reminiscent of linear algebra solvers, eg we use the syntax. ```julia; solve!(x, solver, b); ```. which solves `A*x = b` for `x`, where `A` is described by `solver`. This resembles the syntax `ldiv!(x, A, b)` implemented by `LinearAlgebra.jl`. One exception is the mixed FFT / tridiagonal solver, which also permits `solve!(x, solver)` as an optimization. This extension is used because the ""source term"" is represented differently (eg in a way that depends on the vertical grid spacing) than the other Poisson solvers. The mixed solver also accepts `solve!(x, solver, b)` like the others; this will launch an extra kernel to copy and scale `b` appropriately. 2. The FFT-based solver supports the ""screened"" Poisson equation. ```; (∇² + m) ϕ = b; ```. via `solve!(x, solver, b, m)`, where `m` is a _constant_. This will allow us to solve the elliptic equation posed by an implicit time discretization of the free surface evolution equation. Todo:. - [x] Implement an FFT-based solver for the implicit free surface; - [x] Test demonstrating that the preconditioned conjugate gradient solver and FFT-based solver get the same answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1869:1212,Test,Test,1212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869,1,['Test'],['Test']
Testability,"This PR refactors the `NetCDFOutputWriter` constructor by getting rid of the `write_grid_and_attributes` function and by changing the boolean `clobber` keyword argument to `mode`, which is passed to NCDatasets.jl and takes on the values `""c""` for create/clobber or `""a""` for append. Passing `mode=""a""` allows you to append to an existing NetCDF file. I added some tests for this. This is important if we want to keep using the same NetCDF file after restoring from a checkpoint. cc @suyashbire1 . Resolves #913",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/915:364,test,tests,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/915,1,['test'],['tests']
Testability,"This PR refactors the `NetCDFOutputWriter` to use `FieldSlicer` (which cleans it up a bit) and adds support for time-averaging for NetCDF. All the existing NetCDF tests pass (of which there are quite a few). I also added a test for strided windowed time averaging of horizontal averages for `NetCDFOutputWriter`. Oceananigans solves `∂c/∂t = - λ(x, y, z) c` where `λ(x, y, z) = x + (1 - y)^2 + tanh(z)` which is independent exoponential decay at every grid point so you can analytically compute what the output of the horizontal average and the strided windowed time average should be. Thankfully the test passes :tada:. I also reorganized `test_output_writers.jl` quite a bit. I think it's big enough that it should be split up into multiple files but I'll leave this for a future PR since it would make reviewing this PR's diff difficult. Would be nice if NetCDF accepted a named tuple for `outputs` and had a less clunky interface than just dicts for everything. Might have to wait for a future PR though... X-Ref: https://github.com/Alexander-Barth/NCDatasets.jl/issues/105. Resolves #876",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1040:163,test,tests,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1040,3,['test'],"['test', 'tests']"
Testability,"This PR refactors the `PreconditionedConjugateGradientSolver` and `ImplicitFreeSurface` and their tests. It adds one new test that ensures a single time-step of the `HydrostaticFreeSurfaceModel` can be made with `free_surface = ImplicitFreeSurface()`. In the new interface the maximum iterations and tolerance of the conjugate gradient solver used for the implicit free surface step are adjusted via kwargs to `ImplicitFreeSurface`. For example:. ```julia; free_surface = ImplicitFreeSurface(tolerance = 1e-7, maximum_iterations = Nx * Ny); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1575:98,test,tests,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575,2,['test'],"['test', 'tests']"
Testability,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405:1212,test,tests,1212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405,1,['test'],['tests']
Testability,"This PR refactors the grid implementation so that the coordinate arrays `xC`, `yC`, `zC`, `xF`, `yF`, and `zF` have nodal points within the halo regions of fields and are reshape to match their respective dimension. In other words, we now have `size(c, 2) == length(yC)` and `size(u, 1) == length(xF)`, for example, and `xC * yC * zC` produces an object of `size(c)`. There are three new methods `xnodes(loc, grid::AbstractGrid)`, `ynodes(loc, grid::AbstractGrid)`, `znodes(loc, grid::AbstractGrid)`. For example, `xnodes(Cell, grid)` extracts a view over the interior nodes `grid.xC`, while `xnodes(Face, grid) extracts a view over the physical points of `grid.xF`, which include both boundaries for `Bounded` directions. In addition, the `RegularCartesianGrid` keyword `length` is changed to `extent`, and the `VerticallyStretchedCartesianGrid` no longer accepts a keyword `length`, or a keyword `z`.; Note that the `VerticallyStretchedCartesianGrid` implementation is incomplete and untested. This PR should enable saving the halos of fields in NetCDF data if desired, which is needed for reconstructing field gradients and interpolating fields in post-processing. ~~However, it seems the output writer is currently broken and tests are failing. Thus this PR is WIP.~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/715:1230,test,tests,1230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/715,1,['test'],['tests']
Testability,"This PR regenerates data for the ""Ocean LES"" regression tests. It should be merged after #711.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/943:56,test,tests,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/943,1,['test'],['tests']
Testability,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326:180,test,test,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326,1,['test'],['test']
Testability,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/711:1396,test,tests,1396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711,4,['test'],"['test', 'tests']"
Testability,"This PR removes the CubedSpheres module and re-implements CubedSphere grid using the MultiRegion module. Furthermore, it improves the OrthogonalSphericalShellGrid. ## Implemented in this PR; - uses Distances package which allowed us to clear up various utilities in the grid_utils.jl file regarding great circle distances on the sphere; - fix some bugs that didn't allow an OrthogonalSphericalShellGrid to be constructed with any topology; - better and more accurate show methods that also work on the GPU.; - construct ConformalCubedSphereGrid + tests; - introduces the Connectivity type for MultiRegionGrids + adds a default CubedSphereGrid connectivity; - adds halo filling functionality for tracers + velocities ( + tests); - introduced CubedSphereField abstraction; - introduces CubedSphereConnectivity + tests. ## Outstanding issues; (Several issues will be opened as soon as this PR is merged for the following); - Coordinate and metric halo fillings for the ConformalCubedSphereGrid are hardcoded. We need to re-implement this based on the connectivity of the grid so that it works (i) for any connectivity and (ii) for any CubedSpherePartition.; - Properties `ξₗ, ξᵣ, ηₗ, ηᵣ` should be taken out from OrthogonalSphericalShellGrid _or_, even better, be grouped together into a property `conformal_cubed_sphere` or something. This way, the OrthogonalSphericalShellGrid will be general and not necessarily tied to the conformal cubed sphere.; - Differentiate the OrthogonalSphericalShellGrid constructors from the cubed_sphere_panel constructors; - Shortcut for velocity halo filling; - Alleviate the need for multiple hallo filling passes for velocities (**important for performance/scaling**); - Add testing for MultiRegionGrids with `YPartition`; - Allow uneven x-y partition for ConformalCubedSphere",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867:547,test,tests,547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867,4,['test'],"['testing', 'tests']"
Testability,This PR removes the `RoquetEquationOfState` and `TEOS10` and adds a dependency to `SeawaterPolynomials`. We need. - [x] remove the tests that depend on Roquet and TEOS10; - [x] test that we can time-step a model with a `SeawaterPolynomials.BoussinesqEquationOfState`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/742:131,test,tests,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/742,2,['test'],"['test', 'tests']"
Testability,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:140,test,test,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,10,"['Benchmark', 'Test', 'test']","['BenchmarkTools', 'Testing', 'test', 'test-suite', 'testset']"
Testability,This PR removes the now out-of-date `restore_from_checkpoint` function and updates the docs. Unfortunately the checkpointer test that was commented out in PR https://github.com/CliMA/Oceananigans.jl/pull/1639 is failing again now when uncommented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1670:124,test,test,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1670,1,['test'],['test']
Testability,"This PR reorganizes the diagnostics structs and introduces a new `VerticalProfile` diagnostic that can calculate vertical profiles efficiently on-the-fly on CPUs and GPUs. Product profiles and velocity covariance profiles are built on top of it. `HorizontallyAveragedVerticalProfile` would be a more accurate name, but is much longer. So I'm sticking with the ""convention"" that a profile is implied to be horizontally averaged. The `profile` can be passed to an output writer which can write it to disk. The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352:656,test,test,656,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352,2,"['benchmark', 'test']","['benchmarks', 'test']"
Testability,"This PR restores some test on netCDF output. (The tests were removed, if I recall correctly, because at some point netCDF was creating issues on unix machines. Things seems fine now!). Closes #2956",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3167:22,test,test,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3167,2,['test'],"['test', 'tests']"
Testability,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169:27,benchmark,benchmarking,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169,11,"['Benchmark', 'benchmark']","['BenchmarkGroup', 'BenchmarkTools', 'benchmark', 'benchmarking', 'benchmarks']"
Testability,"This PR rewrites the user interface for specifying rotation rates and buoyancy parameters, such as gravitational acceleration, and the relationship between tracers and density via an equation of state. The main purpose of this PR is to move towards a more logical, functionality-driven encapsulation of parameters. . For rotation, this PR defines a new type called `AbstractRotation` whose subtypes are intended to describe parameters related to the background rotation rate of the model. At the moment there is only one such type: `VerticalRotationAxis`, or `FPlane`. In the future we expect to have `BetaPlane` and `TiltedRotationAxis` or `FullCoriolis`. The `AbstractRotation` types are uniquely associated with a function that computes the x, y, and z components of ""f X U"", associated with the background vorticity `f`. For density, equations of state, and buoyancy, a new abstract type `AbstractBuoyancy` is defined. This type is intended to encapsulate both a gravitational acceleration parameter (when applicable), and an equation of state that contains parameters associated with the relationship between tracer values and density. The advantage of this design is that parameters logically associated with certain terms in the equation of motion are now associated with a particular abstract type. This permits an easy extension of the rotational of buoyancy/equation of state models currently contained in the code; for example in the future we hope to support a `TracerBuoyancy` type for the case that buoyancy is itself a tracer and gravitational acceleration is no longer a parameter, and perhaps a `TemperatureBuoyancy` type for the case that only temperature contributes to buoyancy, rather than both temperature and salinity as is currently the case. In addition, our hydrostatic and non-hydrostatic pressure fields now have the same units and can be directly summed to obtain the total pressure. Resolves #191.; Resolves #217.; Resolves #403.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412:256,log,logical,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412,2,['log'],"['logical', 'logically']"
Testability,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/872:19,test,tests,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872,6,['test'],"['test', 'tests']"
Testability,This PR splits up `test_output_writers.jl` into three files since it was getting pretty long and unwieldy and adds tests for `NetCDFOutputWriter` with `VerticallyStretchedRectilinearGrid` and `RegularLatitudeLongitudeGrid` which pass thanks to @tomchor's PR #1487!. cc @mukund-gupta,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1490:115,test,tests,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1490,1,['test'],['tests']
Testability,This PR splits up the model tests into two and adds explicit dependencies for Buildkite jobs. Both these changes should speed up testing. Resolves #1048 ; Resolves #1056,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1064:28,test,tests,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1064,2,['test'],"['testing', 'tests']"
Testability,This PR starts the processes of integrating LES functionality from glwagner/pass-tests into Oceananigans master. It is very much WIP at the moment.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309:81,test,tests,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309,1,['test'],['tests']
Testability,"This PR stops generating the regression test data in-CI, and instead downloads regression data from `OceananigansArtifacts.jl` to compare against the CI-generated data. With @simone-silvestri . Resolves #2031",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2036:40,test,test,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2036,1,['test'],['test']
Testability,This PR temporarily removes GPU shallow water test (see issue #2922). We will have to regenerate the shallow water bickley jet data with a lower number of time steps,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2927:46,test,test,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2927,1,['test'],['test']
Testability,This PR tests whether `push_previews` will work with buildkite using the latest version of Documenter.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1387:8,test,tests,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1387,1,['test'],['tests']
Testability,"This PR toggles conditional differences with `immersed_inactive_node`, rather than `inactive_node`. The difference is that `inactive_node` returns `true` if the node is outside the domain (either immersed _or_ outside the domain in a `Bounded` direction). `immersed_inactive_node` only returns true if the node is within the immersed boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/ImmersedBoundaries/ImmersedBoundaries.jl#L220-L221. This matters for applying `ValueBoundaryCondition` or `GradientBoundaryCondition` across non-immersed boundaries, on `ImmersedBoundaryGrid`, because both of these are enforced by filling the halo regions on the other side of a `Bounded` direction. Thus we have to be able to correctly evaluate differences / interpolate across non-immersed `Bounded` boundaries. Closes #3208 . We might want to add a test so this doesn't break in the future. It'd also be great to make this code more understandable (suggestions welcome...). @hdrake",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3209:888,test,test,888,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3209,1,['test'],['test']
Testability,This PR tries to make the script a bit easier to run based on my experiences with it. For example `Benchmark` and `@gpu_sync` aren't needed in this case and we can delete it. So far I've only been able to run this with one core (see https://github.com/CliMA/Oceananigans.jl/issues/2433). Closes https://github.com/CliMA/Oceananigans.jl/issues/2433,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2432:99,Benchmark,Benchmark,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432,1,['Benchmark'],['Benchmark']
Testability,"This PR tweaks `initialize_simulation!` so that the schedules get called when `iteration == 0` --- in addition to running diagnostics, executing callbacks, and writing output. This is a tiny step in the direction of having a robust initialization procedure. I think we still need to work on the abstractions a bit though, since it'd be nice to initialize schedules / callbacks more explicitly rather than implicitly relying on `iteration == 0`. This change will affect `SpecifiedTimes` and `WallTimeInterval` the most, I think. TODO:. - [ ] Test for initialization of `SpecifiedTimes`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2268:541,Test,Test,541,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2268,1,['Test'],['Test']
Testability,"This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm. This PR also extends the tests to include non-uniform distributed partitioning . The proposal of this PR (up to discussion and tweaking) is to allow calling; ```julia; arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); ```; which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3339:137,test,tests,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339,1,['test'],['tests']
Testability,"This PR updates CATKE parameters, which was needed after the semi-implicit time-stepping for the TKE equation was introduced in #2426. This PR is all @adelinehillier's work!. The results were generated by training with a 2 minute time-step (previously we had to use time-steps as small as 1 second during training), and are pretty promising:. ![image](https://user-images.githubusercontent.com/15271942/164771409-22f836fc-6ccb-4432-b97b-74de87dbb825.png). The next step is to calibrate and test CATKE at different vertical resolutions. But this is a good start.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2461:490,test,test,490,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461,1,['test'],['test']
Testability,"This PR updates PencilFFTs to 0.13.4, and fixes the DistributedFFTBasedPoissonSolver. Previously we were attempting to ""partition"" the eigenvalues manually, which produce an inconsistency between the layout of the spectral-space pressure and the eigenvalues. This PR uses `PencilFFTs.localgrid` to partition the eigenvalues instead, and furthermore correctly identifies `last(solver.storage)` (not `solver.storage[2]`) with the _outcome_ of the in-place spectral transform of pressure. Thanks @jlpolanco especially for patiently enduring my utter inability to read documentation. I believe this should resolve #2347 but we'll need to test that directly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2502:634,test,test,634,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502,1,['test'],['test']
Testability,"This PR updates the `Simulation tips` section in the Docs with the new `show()` methods and latest model constructor args. However, the following does not work and needs attention:. ```julia; julia> using CUDA; CUDA.allowscalar(true). julia> model.velocities.u.data; 3×3×3 OffsetArray(::CuArray{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:53; [3] getindex(::CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:86; [4] getindex; @ /g/data/v45/nc3020/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:412 [inlined]; [5] getindex; @ ./subarray.jl:276 [inlined]; [6] isassigned(::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, ::Int64, ::Int64); @ Base ./abstractarray.jl:513; [7] alignment(io::IOContext{Base.TTY}, X::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, rows::UnitRange{Int64}, cols::UnitRange{Int64}, cols_if_complete::Int64, cols_otherwise::Int64, sep::Int64)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2316:949,assert,assertscalar,949,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316,1,['assert'],['assertscalar']
Testability,This PR updates the ancient `test_flux_budget` to be able to test all topologies and boundaries. I've also called it `test_incompressible_flux_budget` since it uses `IncompressibleModel`. This will allow us to generalize `apply_x_bcs` and `apply_y_bcs` to curvilinear grids without fear that we've broken something.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1486:61,test,test,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1486,1,['test'],['test']
Testability,"This PR updates the code to use kinematic (density normalized) hydrostatic pressure and buoyancy rather than density perturbation. Using kinematic pressure simplifies the code because the reference density no longer affects the algorithm. Using buoyancy instead of the density perturbation will ultimately simplify the code further because it is needed for turbulence closures (for example). The docs should be updated before merging. Also, the golden master tests should be updated elsewhere; then it can be confirmed here that these changes preserve the functioning of the code (these changes do not affect the outcome of the algorithm). I have also copy/pasted an interpolation operator that will become part of the code once #234 is merged. Prior to this PR, the interpolation of the buoyancy field to z faces was done manually. We need a function to calculate buoyancy for the turbulence closures; so I think we are better off deleting the density perturbation function, ultimately. After this change the reference density ceases to be used in the algorithm. I have also included salinity in the calculation of buoyancy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/236:459,test,tests,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/236,1,['test'],['tests']
Testability,"This PR uses a continuous forcing immersed boundary method to simulate viscous flow around a cylinder. I think this is a pretty common test case of CFD codes: as you increase the Reynolds number, you should start to see vortex shedding behind the cylinder which we do see. Movie: https://www.youtube.com/watch?v=s7u_OJXFMoQ; ![image](https://user-images.githubusercontent.com/20099589/76267706-05081200-6242-11ea-8567-41068235616e.png). I think it shows the ease with which Oceananigans can support topography and arbitrary boundaries that could even depend on time: e.g. static cavities in ice shelves, an urban skyline, or a moving lid (non-interacting ice floe?). This method is much simpler to implement than sigma coordinates, is more flexible, and is probably pretty accurate for most problems you'd try to model with Oceananigans (i.e. we're not modeling coastlines on a sphere). Should discuss what an API for topography/boundaries would look like before finishing this PR off. See #694. X-Ref #530",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/693:135,test,test,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693,1,['test'],['test']
Testability,"This PR uses a view into the underlying array of grid spacings rather than a view into the OffsetArray of grid spacings in `Base.show` for `VerticallyStretchedRectilinearGrid`. This should allow `maximum` and `minimum` to run without errors and allow `VerticallyStretchedRectilinearGrid` to be printed on the GPU. Would be best to add a test, cc @navidcy. Closes #1637 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1638:337,test,test,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1638,1,['test'],['test']
Testability,"This PR uses https://github.com/CliMA/CubedSphere.jl to add grids and fields for the conformal cubed sphere (both a grid for representing one face and for the full cubed sphere). I tried to keep it flexible so that we can do things on only one face, a portion of a face, multiple faces, and can rotate the faces any way in case we want to put the corners on land, etc. This PR is still a work-in-progress. Need to add a `fill_halo_regions!` function and add more tests! Also need to figure out how to compute grid spacings and areas... Originally I wasn't sure how to organize everything so I'm doing everything in a `sandbox` for now. Might also be cool to maybe produce some visualizations for the docs. ![image](https://user-images.githubusercontent.com/20099589/109649608-284e6000-7b2a-11eb-9c67-0ca5bf0d26e5.png). Looking kinda cramped at those corners. ![image](https://user-images.githubusercontent.com/20099589/109650065-b6c2e180-7b2a-11eb-8aa9-f5c8064858ed.png). Unfortunately I had plotting issues with GeoMakie.jl (e.g. https://github.com/JuliaPlots/GeoMakie.jl/issues/55) which is not being maintained right now, so I went back to using matplotlib + cartopy for plotting on maps with projections. ![cubed_sphere_points](https://user-images.githubusercontent.com/20099589/109649281-afe79f00-7b29-11eb-87bf-aa3fe3192cca.png). ![cubed_sphere_staggered_grid](https://user-images.githubusercontent.com/20099589/109649284-b118cc00-7b29-11eb-955f-49ce81cfa3a8.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1417:463,test,tests,463,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417,2,"['sandbox', 'test']","['sandbox', 'tests']"
Testability,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1057:596,test,tests,596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057,2,"['benchmark', 'test']","['benchmark', 'tests']"
Testability,This adds a test for Enzyme AD applied to a hydrostatic free surface model with `ExplicitFreeSurface` momentum advection.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3822:12,test,test,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3822,1,['test'],['test']
Testability,"This adds a test that should fail; but we should be able to fix it by defining . ```julia; @inline Base.Broadcast.materialize!(dest::AbstractField, bc::Broadcasted{<:DefaultArrayStyle}) =; Base.Broadcast.materialize!(interior(dest), bc); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1947:12,test,test,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947,1,['test'],['test']
Testability,"This adds an enzyme test for differentiating flux boundary conditions with Enzyme, which is of interest for solving inverse problems and other applications. @wsmoses",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3643:20,test,test,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3643,1,['test'],['test']
Testability,"This adds current implicit free surface code so we can discuss tidying and also tweak setups, agree on unit tests etc... Code runs with geostrophic adjust test e.g. this movie shows the implicit free surface v fully explicit approach for a small timestep. https://user-images.githubusercontent.com/3535328/109848197-fcaca200-7c1d-11eb-96fa-a3e1e4400162.mp4. as expected the implicit free surface damps waves slightly, but otherwise works the same. . Note - this needs some changes to bring in sync with spatial varying operators. It also has some extra grid terms that might be better in grid/operators somewhere etc...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1418:108,test,tests,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1418,2,['test'],"['test', 'tests']"
Testability,"This correctly adds the time-step wizard to `ShallowWaterModel`. . All the tests pass but there are two warnings that maybe should be adressed?. ```; ...; [2021/02/01 11:45:05.426] INFO Testing setting shallow water model fields...; [2021/02/01 11:45:12.752] WARN Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)` -@-> /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:43; ...; [2021/02/01 11:45:39.457] INFO Testing time-step wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]]...; [2021/02/01 11:45:39.641] WARN You have used the default iteration_interval=1. This simulation will recalculate the time step every iteration which can be slow. -@-> /home/fpoulin/software/Oceananigans.jl/src/Simulations/simulation.jl:68. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1328:75,test,tests,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1328,3,"['Test', 'test']","['Testing', 'tests']"
Testability,"This creates a partial cell immersed boundary method, following [Adroft et al. (1997)](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). Things to be done still:. - [ ] test for tracer advection (done but needs to be added to tests); - [ ] test with momentum integrtion, both in rectilinear and lat lon grids (needs to be done)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306:219,test,test,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306,3,['test'],"['test', 'tests']"
Testability,"This draft PR introduces a few enhancements to `RiBasedVerticalDiffusivity`. `RiBasedVerticalDiffusivity` imposes viscosities and diffusivities of the form. ```; ν₀ * tapering(Ri, Ri_c, Ri_d); ```. where `Ri_c` is a ""critical"" Richardson number where tapering starts and `Ri_d` is the width of the tapering function. We have piecewise-linear tapering. ```julia; piecewise_linear_tapering = 1 - min(1, max(0, (Ri - Ri_c) / Ri_d)); ```. This PR introduces an exponential tapering. ```julia; exponential_tapering = exp(- max(0, (Ri - Ri_c) / Ri_d)); ```. and hyperbolic tangent tapering. ```julia; hyperbolic_tangent_tapering = (1 - tanh((x - x₀) / δ)) / 2; ```. (which I haven't tested yet). I calibrated the piecewise linear case and exponential case using https://github.com/glwagner/LocalOceanClosureCalibration. ; Neither is perfect but the exponential results look a bit better, so I'm making them default. Here's some results from an EKI calibration algorithm, calibrating the closure to the [""LESbrary 1.0""]:. ![multi_case_model_observation_comparison_iteration_220](https://user-images.githubusercontent.com/15271942/162448303-7dfa75eb-f1bf-4fdb-8d7f-e34c4b288d31.png). apologies for no plot labels... every row is a different LES ""truth"" case ranging from convection to pure shear with no rotation. The parameters are. ```; latest_summary = IterationSummary for 4000 particles and 6 parameters at iteration 220; ν₀ | κ₀ | Ri₀ν | Ri₀κ | Riᵟν | Riᵟκ |; ensemble_mean: 8.760e-01 | 2.089e-01 | -1.241e+00 | -3.919e-01 | 5.919e-01 | 6.570e-01 |; best particle: 9.243e-01 | 1.779e-01 | -1.342e+00 | -1.252e-01 | 6.104e-01 | 5.959e-01 | error = 3.728775e-01; worst particle: 9.677e-01 | 2.479e-01 | -2.920e+00 | -1.969e-01 | 6.291e-01 | 4.083e-01 | error = 9.724616e-01; minimum: 2.634e-02 | 3.839e-02 | -3.590e+00 | -2.641e+00 | 1.856e-02 | 7.557e-02 |; maximum: 9.973e-01 | 9.938e-01 | 2.362e+00 | 1.775e+00 | 8.018e+00 | 2.498e+00 |; ensemble_variance: 4.043e-03 | 2.982e-03 | 1.173e-01 | 1.078e-01",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2423:677,test,tested,677,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423,1,['test'],['tested']
Testability,"This error may not be consequential for any work we've done so far because it amounts to changing an irrelevant 'gauge condition' on the pressure in many cases. It does impact set-ups with vertically stretched grids, and it may impact set-ups that specify a horizontal buoyancy gradient at the surface. None of the regression tests deal with such scenarios.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/612:326,test,tests,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/612,1,['test'],['tests']
Testability,This fixes a bug in `MultiRegion` for which `copyto!` is by default asynchronous. This is not a problem until very large meshes (which unfortunately is what we want with multi GPU) ; I still have to test performance... and maybe we also want another solution,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2547:199,test,test,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2547,1,['test'],['test']
Testability,"This fixes a minor bug in the grid constructor and contributes some simple tests to verify correct grid construction. It also adds the syntax. ```julia; g = RegularCartesianGrid(Float32, (nx, ny, nz), (Lx, Ly, Lz)); ```. for constructing grids with element type `Float32` (for example).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/4:75,test,tests,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/4,1,['test'],['tests']
Testability,"This fixes the error we were getting when writing `Field`s reduced over 3 dimensions to disk with `NetCDFOutputWriter` according to the upstream provided in a PR at NCDatasets: https://github.com/Alexander-Barth/NCDatasets.jl/issues/197. This PR also adds a test to catch this in the future. For now this is only working on the `master` branch of `NCDatasets` so tests should fail for now, but once a new version of NCDatasets is released I'll update the packages. Closes https://github.com/CliMA/Oceananigans.jl/issues/2857",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865:258,test,test,258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865,2,['test'],"['test', 'tests']"
Testability,"This function lives in the tests but is never used in the tests, right?. https://github.com/CliMA/Oceananigans.jl/blob/acb298b7f7447747e9f4bcb1ffbbfbe09d9f3d98/test/test_netcdf_output_writer.jl#L14-L46. In fact the whole of this file. I remember some issues with NetCDF at some point on linux machines -- was this why this test was removed?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2956:27,test,tests,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2956,4,['test'],"['test', 'tests']"
Testability,"This has a few benefits:. 1. Users know when `set!` has been invoked, and how long it takes to run (if we emit timing data as well); 2. Incorrect initial conditions may be detected. In a way this would look like just a single output of @christophernhill 's ""state checker"" idea, so we might be able to combine code for those utilities (which could also pave the way for default logging in `run!`...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2462:378,log,logging,378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2462,1,['log'],['logging']
Testability,"This has been discussed quite a bit but beyond unit tests we also need model verification tests that ensure the model output is mathematically/scientifically correct by comparison with known analytic solutions or statistics. The only one we've done so far is confirming the existence of steady-state convection rolls in Rayleigh–Bénard convection at Ra=5000 with an aspect ratio of 6. We can start with basic tests like isotropic diffusion and build up to more complicated stuff like slantwise convection. @edoddridge has a lot of ideas regarding this, he might be a good person to talk to here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81:52,test,tests,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81,3,['test'],['tests']
Testability,This has been tested using the advection schemes but should be easy enough to generalize to other tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276:14,test,tested,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276,2,['test'],"['tested', 'tests']"
Testability,This has drifted a bit from latest APIs. . This updates to make validation cube sphere eddying aquaplanet great again. . Will allow to be used to start testing @simone-silvestri @jm-c @glwagner fixed up immersed boundaries with functioning implicit vertical terms plus working stretched grid 👍 awesomeness.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2170:152,test,testing,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170,1,['test'],['testing']
Testability,"This is a (somewhat minor) convenience for parameter studies, because it means that if `u` was constructed with. ```julia; u_boundary_conditions = FieldBoundaryConditions(top = FluxBoundaryCondition(1.0)); ```. we can later write things like. ```julia; u.boundary_conditions.top = FluxBoundaryCondition(2.0); ```. to change the value of the boundary condition. Note that the _type_ of the boundary condition can't change. . Just opening this PR to see if tests pass with this change. If so it seem positive to me (I don't think `FieldBoundaryConditions` needs to be immutable for performance reasons, but please speak up if anyone thinks/knows otherwise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2063:455,test,tests,455,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063,1,['test'],['tests']
Testability,"This is a revival of PR #475 adding support for applying boundary conditions on y, useful for channel models. I also added some basic tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/546:134,test,tests,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/546,1,['test'],['tests']
Testability,This is a wilderness of the code with not many tests. This is part of ongoing work to build infrastructure for calibrating mesoscale parameterizations in conjunction with `OceanTurbulenceParameterEstimation.jl`. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2215:47,test,tests,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2215,1,['test'],['tests']
Testability,"This is adds a pre-conditioned conjugate gradient (PCG) solver, with example working against rigid lid internal wave experiment and a single test. This is a first step toward a implicit free-surface PCG solver that can be used with general curvilinear grid finite-volume operators. . Not quite ready for merging yet. 1. we need to iterate a bit the right interface, examples/ etc... . 2. it runs kind of slow on GPU so it needs a little work on indexing and/or broadcast foo is upsetting GPU stuff. . 3. there is only one unit test with periodic bc's. we can add some more with different bc's once it runs fast on GPU. Movie shows internal wave example with PCG solver integration left and FFT solver integration right. . https://user-images.githubusercontent.com/3535328/107964974-f066ea80-6f77-11eb-8c7b-3025fdcf2a47.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1360:141,test,test,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360,2,['test'],['test']
Testability,"This is an attempt to make the left menu of the docs feel a bit more intuitive and organized. What I did:. - Moved benchmarks, function index and library to appendix. I think not many people need that information, so it makes sense put it there I think); - Moved appendix to be the last item on the menu (as is customary for most documents); - Moved gallery to after the contributor's guide (since I think contributor's guide is more important so it can come first). I know this is unprompted (nobody complained about the docs) but I think it's a positive change. Eager to hear opinions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1838:115,benchmark,benchmarks,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1838,1,['benchmark'],['benchmarks']
Testability,This is an attempt to resolves test failing after 39ee546.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1566:31,test,test,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1566,1,['test'],['test']
Testability,"This is finishing up some work I started last October on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592:363,test,test-driven,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592,3,['test'],"['test', 'test-driven']"
Testability,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634:756,test,tests,756,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634,1,['test'],['tests']
Testability,"This is related to https://github.com/CliMA/Oceananigans.jl/pull/2432. I'm trying to run the [`distributed_nonhydrostatic_model_mpi.jl` benchmark](https://github.com/CliMA/Oceananigans.jl/blob/9eb055064e68f6a725cebcf9973a3ebf1cbad16b/benchmark/distributed_nonhydrostatic_model_mpi.jl) but I'm running into problems. It seems to be something silly but I haven't been able to figure it out. First off, here's the command I'm using to run the script:. ```; $ /glade/work/tomasc/.julia/bin/mpiexecjl --project -n 2 julia --project distributed_nonhydrostatic_model_mpi.jl 8 8 8 1 2 1; ```. Which should (if I understand correctly) create a simulation on an 8x8x8 grid that partitioned into 2 in the y direction. However, I always get this error:. ```; [2022/04/12 16:43:26.454] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 0...; [2022/04/12 16:43:26.473] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 1...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 1...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(shape::_bcs(shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Tuple{Base.OneTo{Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2433:136,benchmark,benchmark,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433,2,['benchmark'],['benchmark']
Testability,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:144,test,tested,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,4,"['Test', 'test']","['Test', 'tested', 'tests']"
Testability,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1930:39,benchmark,benchmark,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930,9,['benchmark'],"['benchmark', 'benchmarks']"
Testability,This is the first step towards #2012. The goal is to test the method with a flat-bottom and compare performance / stability with respect to the other free-surface implementations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2013:53,test,test,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013,1,['test'],['test']
Testability,"This is the second attempt at flipping the sign of `gravity_unit_vector`. The first attempt (https://github.com/CliMA/Oceananigans.jl/pull/2963) had an issue where the doctests were getting stuck with no apparent cause. For this attempt, I proceeded more carefully, step by step to try and pinpoint what was happening. The good news is that the doctests are now passing locally. The bad news is that I still don't know why they were getting stuck in https://github.com/CliMA/Oceananigans.jl/pull/2963. Since tests pass locally for me (I tested everything except the examples) I'm hopefully that this time they'll also pass on buildkite. @navidcy your modifications to https://github.com/CliMA/Oceananigans.jl/pull/2963 are also included here!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2990:508,test,tests,508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2990,2,['test'],"['tested', 'tests']"
Testability,"This is what's keeping tests in https://github.com/tomchor/Oceanostics.jl/pull/151 from passing. Here's the simplest MWE I could come up with:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid,);. julia> test(i, j, k, grid, auxiliary_fields,) = 1.0;. julia> a = KernelFunctionOperation{Center, Center, Center}(test, model.grid, model.auxiliary_fields);. julia> compute!(Field(a)); ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:466; [2] isregional(t::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:105; [3] _findfirst_rec (repeats 2 times); @ ./tuple.jl:414 [inlined]; [4] findfirst(f::Function, t::Tuple{Tuple{DataType, DataType, DataType}, NamedTuple{(), Tuple{}}}); @ Base ./tuple.jl:421; [5] #construct_regionally#52; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:146 [inlined]; [6] construct_regionally; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:143 [inlined]; [7] #construct_regionally#51; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139 [inlined]; [8] construct_regionally(::Function, ::Tuple{DataType, DataType, DataType}, ::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139; [9] indices(κ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3232:23,test,tests,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232,3,['test'],"['test', 'tests']"
Testability,"This is work in progress to solve #2866 so I would apprciate some advice:. 1. I added a specific constructor of Checkpointer for when the model is a ShallowWater model; 2. I added a set! function for when the model is a shallow water model (the difference of these two and the other ones is that they do not require the ""particles"" property.; 3. I added a low-res test case . Is OutputWriters/checkpointer a good place to put these methods in, or should they go somewhere in models/?; Is it okay to no add a new docstring to the new constructor and instead modify the existing one mentioning the difference with the ShallowWater case? If I add new one, the docs of Checkpointer will be huge.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2868:364,test,test,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2868,1,['test'],['test']
Testability,"This isn't a huge issue but I've noticed recently that often the shallow water regression tests on GPU fail with the following error:. ```; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93;   | Expression: all(test_fields.v .≈ truth_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /net/ocean/home/data44/data5/glwagner/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool);   | @ Main /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; ```. Sometimes I need to restart the test twice for it to pass. Like I said, it's not a huge issue, but do we understand why that's happening? Is there anything we can do to prevent that behavior?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922:90,test,tests,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922,7,"['Test', 'test']","['Test', 'test', 'tests']"
Testability,"This issue will help to combine several outstanding issues involving the `ShallowWaterModel.jl`. I suggest the following in this order:. - [ ] Fix inconsistent tendencies in the two models (#2928); - [ ] Fix up shallow water regression tests (#3049); - [ ] Add viscosity; - [ ] Speed up shallow water example when building docs (#3151); - [ ] Make shallow water Bickley jet less expensive (#3169); - [ ] Update immersed bondaries validation scripts (#2985); - [ ] Introduce multi-layer shallow water model (#2507); - [ ] Validate positive preserving WENO schemes. For the first part, I put together this document that shows and derives the equations for the two different models. Next I will look at the tendencies. . Any suggestions on what else to do, or what to do differently, are welcome!. [ShallowWaterModel_eqns.pdf](https://github.com/CliMA/Oceananigans.jl/files/13393977/ShallowWaterModel_eqns.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394:236,test,tests,236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394,1,['test'],['tests']
Testability,"This lets me do . export TEST_GROUP=""none""; export TEST_FILE=""test_matrix_poisson_solver.jl"". so I don't have to edit runtest to try a single file test. Not sure if its good idea???",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2122:147,test,test,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2122,1,['test'],['test']
Testability,"This line:. https://github.com/climate-machine/Oceananigans.jl/blob/6502f078c8f7698a2fb6cd398d9e96cfacccc787/src/Simulations.jl#L166. prevents the method `progress(simulation)` from being called if `progress` is not a subtype of the abstract type `Function`. . This makes using callable objects for `progress` more complicated (at least, these callable objects would have to subtype `Function`, which seems like an arbitrary requirement for such objects). What is the reasoning behind requiring `progress` to subtype `Function` (and furthermore enforcing this with an if-statement)? If `progress` does not subtype function, the keyword argument is unused (despite the desperate efforts of flailing users, such as myself). Callable objects are nice for `progress`. For example, a callable object is a good way to keep track of wall time, make plots, automatically format strings containing diagnostics information, or otherwise reference objects outside `simulation` for the purposes of logging.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/723:986,log,logging,986,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/723,1,['log'],['logging']
Testability,This long overdue PR implementations a validation step in the lowest-level outer constructor for `Field`. This resolves a number of issues but I need to find them. Couple todo's:; - [ ] tests; - [x] expand error message to help users choose valid boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1732:186,test,tests,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1732,1,['test'],['tests']
Testability,"This long overdue PR nukes `restore_from_checkpoint` and all its tests. We've decided to support ""picking up"" a simulation from a checkpoint instead via `run!(simulation, pickup=true)`. The reason is that we can only restore a limited subset of models that don't utilize user-defined functions. ""Restoring"" a model from a checkpoint is an error-prone processes, and supporting `restore_from_checkpoint` has proven difficult. Picking up via `run!(simulation, pickup=true)` has the downside of requiring the original run script to restart a simulation, but the advantage of simplicity. I've also updated the checkpointer documentation to describe `run!(simulation, pickup=true)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1893:65,test,tests,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893,1,['test'],['tests']
Testability,This may resolve #1601 . We'll need to test manually I think since we don't want to update the whole `Manifest.toml`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1621:39,test,test,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1621,1,['test'],['test']
Testability,"This pull request changes the compat entry for the `Adapt` package from `3` to `3, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3409:157,test,tested,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3409,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `Adapt` package from `^2` to `^2, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287:160,test,tested,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `ArrayInterface` package from `= 3.1.6` to `= 3.1.6, 3.1`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1624:179,test,tested,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1624,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDAKernels` package from `0.2, 0.3` to `0.2, 0.3, 0.4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2305:179,test,tested,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2305,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDAKernels` package from `0.2` to `0.2, 0.3`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1828:168,test,tested,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1828,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDAKernels` package from `0.3.3` to `0.3.3, 0.4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2781:173,test,tested,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2781,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDA` package from `3.0.0 - 3.3.6` to `3.0.0 - 3.3.6, 3`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1999:180,test,tested,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1999,4,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDA` package from `3.8, 3.9` to `3.8, 3.9, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2889:170,test,tested,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2889,4,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDA` package from `4` to `4, 5`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3276:156,test,tested,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3276,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDA` package from `^1, ^2` to `^1, ^2, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1565:167,test,tested,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1565,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDA` package from `^1, ^2` to `^1, ^2, 3.1`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1628:167,test,tested,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1628,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDA` package from `^1, ^2` to `^1, ^2, 3.2`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1645:167,test,tested,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1645,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDA` package from `^1` to `^1, 2.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1022:159,test,tested,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1022,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDAapi` package from `^1.1, ^2` to `^1.1, ^2, 4.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/689:174,test,tested,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/689,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDAdrv` package from `^3.1, ^5` to `^3.1, ^5, 6.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/688:174,test,tested,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/688,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CUDAnative` package from `^2.3` to `^2.3, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/717:169,test,tested,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/717,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CuArrays` package from `^1.2` to `^1.2, 2.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/718:167,test,tested,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/718,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CubedSphere` package from `0.1, 0.2` to `0.1, 0.2, 0.3`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3764:179,test,tested,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3764,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `CubedSphere` package from `0.1` to `0.1, 0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2021:169,test,tested,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2021,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `DocStringExtensions` package from `^0.8` to `^0.8, 0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2578:179,test,tested,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2578,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `Enzyme` package from `0.11.14` to `0.11.14, 0.12`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3607:173,test,tested,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3607,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `Enzyme` package from `0.12.20` to `0.12.20, 0.13`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3782:173,test,tested,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3782,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `GPUArrays` package from `= 8.3.1` to `= 8.3.1, 8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2511:173,test,tested,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2511,4,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `JLD2` package from `0.4` to `0.4, 0.5`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3769:162,test,tested,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3769,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `JLD2` package from `^0.1.2, ^1` to `^0.1.2, ^1, 0.2`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/888:175,test,tested,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/888,6,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `JLD2` package from `^0.2, ^0.3` to `^0.2, ^0.3, 0.4`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1359:175,test,tested,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1359,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `JLD2` package from `^0.2` to `^0.2, 0.3`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1185:163,test,tested,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1185,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.6, 0.7` to `0.6, 0.7, 0.8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2304:186,test,tested,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2304,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.6` to `0.6, 0.7`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1829:175,test,tested,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1829,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.7.2` to `0.7.2, 0.8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2850:180,test,tested,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2850,4,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.8` to `0.8, 0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2965:176,test,tested,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2965,4,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `KernelAbstractions` package from `^0.3, 0.4, 0.5` to `^0.3, 0.4, 0.5, 0.6`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1524:197,test,tested,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1524,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `KernelAbstractions` package from `^0.3, 0.4` to `^0.3, 0.4, 0.5`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1295:187,test,tested,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1295,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `KernelAbstractions` package from `^0.3` to `^0.3, 0.4`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/924:177,test,tested,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/924,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `MPI` package from `0.16, 0.17, 0.18, 0.19` to `0.16, 0.17, 0.18, 0.19, 0.20`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2767:200,test,tested,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2767,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `MPI` package from `0.16, 0.17, 0.18` to `0.16, 0.17, 0.18, 0.19`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1911:187,test,tested,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1911,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `MPI` package from `0.16, 0.17` to `0.16, 0.17, 0.18`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1692:175,test,tested,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1692,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `MPI` package from `0.16` to `0.16, 0.17`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1472:163,test,tested,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1472,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `NCDatasets` package from `0.10` to `0.10, 0.11`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1217:170,test,tested,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1217,4,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `NCDatasets` package from `0.12.10, 0.13.1` to `0.12.10, 0.13.1, 0.14`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3410:193,test,tested,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3410,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `NCDatasets` package from `0.12.10` to `0.12.10, 0.13`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3330:177,test,tested,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3330,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `NCDatasets` package from `^0.10, ^0.11` to `^0.10, ^0.11, 0.12`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2313:187,test,tested,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2313,6,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `PencilArrays` package from `0.16, 0.17, 0.18` to `0.16, 0.17, 0.18, 0.19`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3185:197,test,tested,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3185,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `PencilArrays` package from `0.16, 0.17` to `0.16, 0.17, 0.18`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3119:185,test,tested,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3119,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `PencilArrays` package from `0.16` to `0.16, 0.17`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2544:173,test,tested,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2544,4,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `PencilFFTs` package from `0.12` to `0.12, 0.13`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2178:171,test,tested,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2178,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `PencilFFTs` package from `0.13.5, 0.14` to `0.13.5, 0.14, 0.15`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3120:187,test,tested,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3120,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `PencilFFTs` package from `^0.13.5` to `^0.13.5, 0.14`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2611:177,test,tested,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2611,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `SeawaterPolynomials` package from `^0.2.3` to `^0.2.3, 0.3`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2777:183,test,tested,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2777,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `StaticArrays` package from `0.12` to `0.12, 1.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1222:171,test,tested,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1222,4,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `StructArrays` package from `0.4, 0.5` to `0.4, 0.5, 0.6`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1781:179,test,tested,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1781,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `StructArrays` package from `0.4` to `0.4, 0.5`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1347:169,test,tested,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1347,2,['test'],"['tested', 'tests']"
Testability,"This pull request changes the compat entry for the `Tullio` package from `0.2` to `0.2, 0.3`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1792:163,test,tested,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1792,2,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `AMGX` package to `0.1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2738:143,test,tested,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2738,3,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `ArrayInterface` package to `3.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `ArrayInterface` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1673:212,test,tested,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1673,3,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2517:49,Benchmark,BenchmarkTools,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517,8,"['Benchmark', 'test']","['BenchmarkTools', 'tested', 'tests']"
Testability,"This pull request sets the compat entry for the `CUDA` package to `4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3070:141,test,tested,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3070,3,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `CubedSphere` package to `0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `CubedSphere` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1474:206,test,tested,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1474,3,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `Glob` package to `1.3`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Glob` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1102:192,test,tested,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1102,3,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `IncompleteLU` package to `0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2124:151,test,tested,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2124,3,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `IterativeSolvers` package to `0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2123:155,test,tested,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2123,3,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `PencilArrays` package to `0.16`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2539:152,test,tested,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2539,3,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `Rotations` package to `1.0`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Rotations` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1475:202,test,tested,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1475,3,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/898:210,test,tested,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898,3,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/751:222,test,tested,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/751,6,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `Statistics` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3366:147,test,tested,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3366,3,['test'],"['tested', 'tests']"
Testability,"This pull request sets the compat entry for the `Tullio` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Tullio` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1563:196,test,tested,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1563,3,['test'],"['tested', 'tests']"
Testability,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/891:257,log,log,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891,5,"['log', 'test']","['log', 'test', 'testing', 'tests']"
Testability,This seems a brittle:. https://github.com/CliMA/Oceananigans.jl/blob/9ffbee31bc5a2fa38dd93fa1594b94cddaebba8c/test/utils_for_runtests.jl#L34. some bug that caused MPI not to be initialized would cause the tests to be worthless but it might not be detected.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3879:110,test,test,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3879,2,['test'],"['test', 'tests']"
Testability,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272:12,test,tests,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272,3,"['Test', 'test']","['Test', 'tests']"
Testability,This should speed up Appveyor builds which currently take forever. Also not sure how much we get out of testing x86/32-bit Windows... Helps with #89,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/279:104,test,testing,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/279,1,['test'],['testing']
Testability,This significantly reduced the time to first plot for Plots.jl: https://github.com/JuliaPlots/Plots.jl/pull/2544. I guess the idea is we don't care about performance when running our tests. Most of the time is spent compiling so if we can reduce compile time (at the cost of having sub-optimal code) then our tests will run faster.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1076:183,test,tests,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1076,2,['test'],['tests']
Testability,"This solves #2438 . I tested with the following code and it is working. ```julia; using Oceananigans; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); b = CenterField(grid); location(b); ```. Returns:; ```julia; (Center, Center, Center); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2439:22,test,tested,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2439,1,['test'],['tested']
Testability,"This somewhat large and WIP PR implements immersed boundary in the non-hydrostatic algorithm used by `IncompressibleModel`. . It also accelerates using `ImmersedBoundaryGrid` with high-order advection by encoding the ""boundary buffer"" (the number of grid points away from the boundary where second-order advection must be used) in the type signature of each advection scheme. This allows us to use dispatch to identify the correct criterion to use to determine whether a grid point is ""near boundary"" or not. It adds two validation tests: `shallow_water_flow_past_cape.jl` and `immersed_bickley_jet.jl`. The intent of `immersed_bickley_jet.jl` is to compare simulations with a ""native"" boundary and an immersed boundary with the same effective domain size, grid spacing, and numerics. @whitleyv I suggest that we merge this PR once we verify that the validation scripts run efficiently. After that we can work on careful testing and analysis of the validation case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733:532,test,tests,532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733,2,['test'],"['testing', 'tests']"
Testability,"This test is to stop the error below from reappearing (once the test is fixed!). . ```; nested task error: MethodError: no method matching (::Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}})(::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, ::Clock{Float64}, ::NamedTuple{(:u, :v, :η), Tuple{Field{Face, Center, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#u_bottom_drag#29""}}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}}, Field{Center, Face, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1928:5,test,test,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928,2,['test'],['test']
Testability,This test occasionally fails as I set the tolerance a little low.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/400:5,test,test,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/400,1,['test'],['test']
Testability,This tests also fails intermittently due to being slightly above the tight tolerance: https://buildkite.com/clima/oceananigans/builds/2660#fdbc1bf9-350b-4051-9977-5ec4683ca080/22-534,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1688:5,test,tests,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1688,1,['test'],['tests']
Testability,"This warning appears in the log when we run the simulation:. ```Julia; ┌ Warning: some parameters could not be resolved for type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,24,Main.__atexample__named__ocean_wind_mixing_and_convection.#Qˢ,Float64,Tuple{Symbol},Tuple{Int64},Tuple{typeof(Oceananigans.Operators.identity4)}}; reconstructing; └ @ JLD2 ~/.julia/packages/JLD2/1i6ZM/src/data/reconstructing_datatypes.jl:440; ```. See, e.g., https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/. Is this something we need to address or make the example better so that it does not appear? Users might be intimidated...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1775:28,log,log,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1775,1,['log'],['log']
Testability,"This will be useful for doing mixed precision stuff, like using single-precision FFT-based preconditioners for Poisson solvers in double-precision simulations. cc @xkykai . TODO: tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3809:179,test,tests,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3809,1,['test'],['tests']
Testability,This won't pass tests until https://github.com/CliMA/SeawaterPolynomials.jl/pull/20 is merged and registered. We also need to update `Manifest.toml`. Closes #2528. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2529:16,test,tests,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2529,1,['test'],['tests']
Testability,Threaded benchmarks,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861:9,benchmark,benchmarks,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861,1,['benchmark'],['benchmarks']
Testability,"Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 14.2 ms Histogram: frequency by time 14.4 ms <. Memory estimate: 47.78 KiB, allocs estimate: 320. ```. The counterpart using the new branch `julia --project=""environments/one_sided_branch"" --check-bounds=no`; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true; BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 16.463 ms … 18.503 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 16.466 ms ┊ GC (median): 0.00%; Time (mean ± σ): 16.878 ms ± 908.449 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▆ ▁; 16.5 ms Histogram: frequency by time 18.5 ms <. Memory estimate: 250.06 KiB, allocs estimate: 676. julia> trial1 = run_model_benchmark!(tracer_kernel_test, arch;; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 6.695 ms … 7.461 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 6.789 ms ┊ GC (median): 0.00%; Time (mean ± σ): 6.908 ms ± 312.944 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █ ██ █ █; █▁▁▁▁▁██▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 6.69 ms Histogram: frequency by time 7.46 ms <. Memory estimate: 46.39 KiB, allocs estimate: 231. ```. P.S. some vestigial code not used is bei",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658:2712,Benchmark,BenchmarkTools,2712,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658,1,['Benchmark'],['BenchmarkTools']
Testability,Time stepping tests for ShallowWaterModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1195:14,test,tests,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1195,1,['test'],['tests']
Testability,"TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iter",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:106822,test,test,106822,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,Timestep tests gave yet again become too long. (~3hrs on gpu); This PR attempts to split them. Closes #2325.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2324:9,test,tests,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2324,1,['test'],['tests']
Testability,"To fill the halos of sliced fields we call `fill_halo_size`:. https://github.com/CliMA/Oceananigans.jl/blob/6b22a796001f9cbd49aea1e44c931ccb8e8e374e/src/BoundaryConditions/fill_halo_regions.jl#L335-L337. However, that code incorrectly assumes that an indices of `:` means that the whole dimension should be filled. This is wrong for fields with `Nothing` locations, which have only 1 point in the `Nothing` direction, but can still have indices `:`. There is also logic for `Nothing` locations:. https://github.com/CliMA/Oceananigans.jl/blob/6b22a796001f9cbd49aea1e44c931ccb8e8e374e/src/BoundaryConditions/fill_halo_regions.jl#L339-L352. But this is never used because of the incorrect assumption about the meaning of indices. One possibility is to convert indices in `Nothing` directions to `nothing`. That would permit dispatching on the type of the indices like we're trying to do. Another possibility is to fix the logic here. Dispatch is annoying because `loc` is a tuple, but it can be done. A third possibility is just to avoid the symbol sizes `:yz`, `xz` and `:xy`. That last seems maybe like the best choice. This bug would prevent anyone from using `ImmersedBoundaryGrid`. So I'm confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3473:464,log,logic,464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3473,2,['log'],['logic']
Testability,To make sure that the code does not slow down in between merges it would be useful to have a standard case and test that the time stepping is not significantly increased between different PRs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2176:111,test,test,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2176,1,['test'],['test']
Testability,"To reproduce this bug:; ```Julia; using Oceananigans. grid = RectilinearGrid(; CPU(),; size=(128, 128, 128),; x=(0.0, 1.0), y=(0.0, 1.0), z=(0.0, 1.0),; topology=(Bounded, Bounded, Bounded),; ). model = NonhydrostaticModel(;; grid,; ). simulation = Oceananigans.Simulation(model; Δt = 1.0, stop_iteration = 8). fields = model.velocities. simulation.output_writers[:compression_0] = NetCDFOutputWriter(; model,; fields,; filename = ""compression_0.nc"",; compression = 0,; schedule = IterationInterval(1),; overwrite_existing = true,; ). simulation.output_writers[:compression_4] = NetCDFOutputWriter(; model,; fields,; filename = ""compression_4.nc"",; compression = 4,; schedule = IterationInterval(1),; overwrite_existing = true,; ). run!(simulation). @info filesize(""compression_0.nc""); @info filesize(""compression_4.nc""); ```. Output:; ```; Info: Initializing simulation...; Info: ... simulation initialization complete (915.221 ms); Info: Executing initial time step...; Info: ... initial time step complete (5.500 seconds).; Info: Simulation is stopping after running for 8.465 seconds.; Info: Model iteration 8 equals or exceeds stop iteration 8.; Info: 460126123; Info: 460126123; ```. Expected behavior: the size of `compression_4.nc` should be much smaller than that of `compression_0.nc`, since the data are all zeros. Test enviroment:; - Julia: 1.9.1; - Oceananigans: v0.83.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3152:1326,Test,Test,1326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3152,1,['Test'],['Test']
Testability,"To start testing Oceananigans at low-precision arithmetic and with alternative types with @milankl:. > I think the first thing I would need to do is making sure that Oceananigans is type stable. Meaning that you can pass a type T as an argument and this type is used throughout all computations. Even though you may only use Float64 atm, but having an entirely type-stable code that also means things like; > ```julia; > function f(A::AbstractMatrix); > ...; > 0.5*A[i,j]; > ...; > end; > ```; > are written as; > ```julia; > function f(A::Array{T,2}) where T; > ...; > one_half = T(0.5); > one_half*A[i,j]; > ```; > , makes sure that we can use Sherlog64 to understand where the problems are.; >; > Ideally, all type conversion are explicitly written into the code rather than relying on promotion",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/552:9,test,testing,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/552,1,['test'],['testing']
Testability,"To verify that the momentum equation is correctly implemented, we need a few validation tests. These can use `ExplicitFreeSurface`; getting `SplitExplicitFreeSurface` to work will be tackled separately. We should set the gravitational acceleration so that the barotropic wave speed is roughly 10x faster than the dynamics velocity (eg low Mach number). We propose 3 tests:. 1. Solid body rotation test. This can be implemented by attempting a free running simulation using the velocity field from the tracer advection test.; 2. Rossby-Haurwitz test, following https://github.com/CliMA/Oceananigans.jl/blob/main/validation/solid_body_rotation/rossby_haurwitz.jl; 3. Freely-decaying barotropic turbulence on the sphere (eg following https://github.com/CliMA/Oceananigans.jl/blob/v0.70.0/validation/near_global_lat_lon/freely_decaying_barotropic_turbulence.jl).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3265:88,test,tests,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3265,5,['test'],"['test', 'tests']"
Testability,Travis CI does not run the GPU tests so the code coverage statistics is submits to Codecov and Coveralls is not accurate. We should probably be submitting code coverage statistics from GitLab CI which does run GPU tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/138:31,test,tests,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/138,2,['test'],['tests']
Testability,True portable RNG for deep convection golden master test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/219:52,test,test,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/219,1,['test'],['test']
Testability,"Trying to use OceanScalingTest.jl from @simone-silvestri as a benchmark for TTFTS (Time-To-First-Time-Step) I came across this delightful error:. ```; ERROR: LoadError: Evaluation into the closed module `Grids` breaks incremental compilation because the side effects will not be permanent. This is likely due to some other module mutating `Grids` with `eval` during precompilation - don't do this.; Stacktrace:; [1] eval; @ ./boot.jl:428 [inlined]; [2] allocate_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Oceananigans.DistributedComputations.Distributed{Oceananigans.Architectures.GPU, false, Oceananigans.DistributedComputations.Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/kBe5X/src/Grids/latitude_longitude_grid.jl:554; [3] with_precomputed_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3555:62,benchmark,benchmark,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555,1,['benchmark'],['benchmark']
Testability,"Trying to use `AnisotropicMinimumDissipation` with `buoyancy = nothing` threw an error because it tries to access `buoyancy.model`, which doesn't exist when `buoyancy = nothing`. This PR fixes that bug and adds a few tests for time-stepping AMD with different buoyancy models, including `buoyancy=nothing`. The bug is fixed by adding a new default `Cb = nothing` (rather than `Cb = 0.0`), in which case the computation of the buoyancy modification term is elided entirely. This might speed up some models (but who knows by how much). It is _still_ the case that users who specify a non-default `Cb` without a buoyancy model receive error that could be hard to interpret. We could `validate_closure` for this. I feel it's not worth the effort right now though because the buoyancy modification term is not implemented correctly anyways, and it seems that even if implemented correctly it may not improve the fidelity of simulations with buoyancy. A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1619:217,test,tests,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619,1,['test'],['tests']
Testability,"Unfortunately I don't have an example of this on hand (and our tests don't catch it), but I've noticed occasional irregularities in output writing that are presumably due to rounding artifacts when aligning a time-step for `TimeInterval`. One common case is that I run a parameter sweep and one of the files is one iteration shorter than another. This is often at the end of a long run. I think the culprit might be round-off error when computing `align_time_step` or `schedule_aligned_Δt`. Maybe using `Base.TwicePrecision` for some of the calculations would solve the problem?. Here's some of the code involved:. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Simulations/run.jl#L43-L58. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L51. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L152",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2321:63,test,tests,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321,1,['test'],['tests']
Testability,Unit tests are ~~failing~~ hanging because a data dependency has been updated causing the checksum to not match. https://github.com/CliMA/OceananigansArtifacts.jl/pull/3,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1552:5,test,tests,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1552,1,['test'],['tests']
Testability,Until the CPU and GPU Poisson solvers are unified this should give us confidence that the GPU Poisson solver is doing its job. Found it easier to write the test independently so this supersedes PR #238 . Resolves #200,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/246:156,test,test,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/246,1,['test'],['test']
Testability,Update Performance Benchmarks in Docs and README,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1676:19,Benchmark,Benchmarks,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1676,1,['Benchmark'],['Benchmarks']
Testability,Update and test benchmarks,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/727:11,test,test,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727,2,"['benchmark', 'test']","['benchmarks', 'test']"
Testability,Update architecture in distributed benchmark scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338:35,benchmark,benchmark,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338,1,['benchmark'],['benchmark']
Testability,Update benchmarks for JOSS,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/850:7,benchmark,benchmarks,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850,1,['benchmark'],['benchmarks']
Testability,Update benchmarks.md,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2680:7,benchmark,benchmarks,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2680,1,['benchmark'],['benchmarks']
Testability,Update benchmarks.md - attempt 2.0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1952:7,benchmark,benchmarks,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1952,1,['benchmark'],['benchmarks']
Testability,Update examples and test them again,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/671:20,test,test,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/671,1,['test'],['test']
Testability,Update performance benchmarks plot and discuss results,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/607:19,benchmark,benchmarks,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/607,1,['benchmark'],['benchmarks']
Testability,Update regression test data,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3373:18,test,test,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3373,1,['test'],['test']
Testability,Update test to also catch multiple of 16 bug,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/909:7,test,test,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/909,1,['test'],['test']
Testability,Updates Benchmarks environment,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2417:8,Benchmark,Benchmarks,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417,1,['Benchmark'],['Benchmarks']
Testability,Updating Benchmark Docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1930:9,Benchmark,Benchmark,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930,1,['Benchmark'],['Benchmark']
Testability,Use `-O1` or even `-O0` to reduce compile time for faster testing?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1076:58,test,testing,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1076,1,['test'],['testing']
Testability,Useful regression benchmark,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1214:18,benchmark,benchmark,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1214,1,['benchmark'],['benchmark']
Testability,Uses ValueBoundaryCondition in stratified couette flow validation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1982:66,test,test,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1982,1,['test'],['test']
Testability,Using Flat for shallow water benchmark,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1659:29,benchmark,benchmark,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1659,1,['benchmark'],['benchmark']
Testability,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1088:7,Benchmark,BenchmarkGroup,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088,12,"['Benchmark', 'benchmark']","['BenchmarkGroup', 'BenchmarkTools', 'benchmarking', 'benchmarks']"
Testability,"Using `min_Δz(grid::VerticallyStretchedRectilinearGrid)` on GPU fails. The reason is that. ```julia; julia> minimum(view(grid.Δzᵃᵃᶜ, 1:grid.Nz)); ERROR: scalar getindex is disallowed; ```; fails on the GPU. The line should be `minimum(view(parent(grid.Δzᵃᵃᶜ), 1:grid.Nz))`. This error had been there all along but I guess no one caught it. This commit should fix it, but should we also include a test that would catch it?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1751:396,test,test,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751,1,['test'],['test']
Testability,"Using the `FFTBasedPoissonSolver` in complex domains on the `ImmersedBoundaryGrid` leads to resulting solution that either. 1. Does not conserve tracers in the flow; or; 2. Leads to divergent flow along the immersed boundary. On the other hand, using the `PreconditionedConjugateGradientSolver` on complex domains leads to exact solution at a much slower speed on the GPU. This PR implements an `ImmersedPressureSolver` that uses the `FFTBasedPoissonSolver` as a preconditioner, then iterates `PreconditionedConjugateGradientSolver` to arrive at the correct solution. This approach is much faster than using a vanilla `PreconditionedConjugateGradientSolver` as the number of iterations scale much more slowly with grid size on the GPU. This PR will include the `ImmersedPressureSolver`, a few validation examples for benchmarking purposes and a number of example use cases where this solver would be useful. @glwagner @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3188:817,benchmark,benchmarking,817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188,1,['benchmark'],['benchmarking']
Testability,"Utilities for benchmarking user-defined forcing, boundary conditions, and output calculation",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:14,benchmark,benchmarking,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,1,['benchmark'],['benchmarking']
Testability,Validation + Convergence tests: images not showing up,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1459:25,test,tests,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1459,1,['test'],['tests']
Testability,Validation and performance benchmarks.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/136:27,benchmark,benchmarks,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136,1,['benchmark'],['benchmarks']
Testability,Validation test: Abernathey et al 2011,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/774:11,test,test,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/774,1,['test'],['test']
Testability,Validation tests for immersed boundary implementations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775:11,test,tests,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775,1,['test'],['tests']
Testability,Validation tests of numerical convergence,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/767:11,test,tests,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767,1,['test'],['tests']
Testability,Velocity profile of channel flow case has difference with log-law,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195:58,log,log-law,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195,1,['log'],['log-law']
Testability,Verification experiments should become sophisticated tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/347:53,test,tests,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/347,1,['test'],['tests']
Testability,Verification tests comparing performance of different LES closures,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/441:13,test,tests,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/441,1,['test'],['tests']
Testability,"Was adding some grid tests and noticed this. Will fix as part of PR #543. ```julia; julia> grid = RegularCartesianGrid(Float32; size=(10, 10, 10), length=(1, 1//7, 2π)); julia> eltype.([grid.xF, grid.yF, grid.zF, grid.xC, grid.yC, grid.zC]); 6-element Array{DataType,1}:; Float64; Float64; Float64; Float64; Float64; Float64; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/544:21,test,tests,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/544,1,['test'],['tests']
Testability,"We agreed that stratified plane Couette flow could be a test case against which we can verify the implementation of AMD in PR #309, although the published results [Vreugdenhil & Taylor (2018)] use a slightly modified version of AMD. They report a number of LES runs, and since we don't have a vertically stretched grid, it might be easiest to try and reproduce the Pr = 0.7 case which they do with (Nx, Ny, Nz) = (64, 49, 64) grid points [for Ri=0 or 0.01, for Ri = 0.04 it's (64, 65, 64)]. I might suggest focusing on the Ri = 0 case as they also run a resolved DNS with (Nx, Ny, Nz) = (256, 129, 256) against which we might be able to compare (might not be possible, depending on vertical grid stretching). Unfortunately, I don't think we can reproduce their results without a vertically stretched grid... If I understand the paper correctly, the grid is stretched according to; ```; y_j = h*tanh(Sf*(2*(j-1)/(Ny-1))) / tanh(Sf); ```; so for h=1 you get grid spacings of Δy ~ 0.125 away from the wall and Δy ~ 0.0000035 adjacent to the wall. So a faithful reproduction would need 285,000+ vertical levels lol. I don't fully understand how they got their values for the vertical grid cell size adjacent to the wall `∆y_w^+`, but it seems like if h = 100,000 then our values agree (they get a spacing of Δy ~ 0.35 adjacent to the wall). Either way, the ratio between the thickest and thinnest spacings is ~35,000. Not sure if there's still a way we could compare results in this case without a vertically stretched grid... Absolute worst case scenario, I've been working on an implementation of a vertically stretched grid (see PRs #283 and #306) but it's a work in progress and might not be the best use of our efforts right now. Reference: Catherine A. Vreugdenhil and John R. Taylor, [Large-eddy simulations of stratified plane Couette flow using the anisotropic minimum-dissipation model](https://aip.scitation.org/doi/abs/10.1063/1.5037039), Physics of Fluids 30, 085104 (2018). cc @glwagner @raf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310:56,test,test,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310,1,['test'],['test']
Testability,"We currently have no checkpointing anymore. We need a barebones checkpointer that only checkpoints and saves the essentials. Should be more transparent than serializing the `Model` to disk, which also comes with multiple issues. Should also be useful for long runs (e.g. seasonal cycle simulations) and more rigorous regression tests that actually test the dynamics.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/324:328,test,tests,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/324,2,['test'],"['test', 'tests']"
Testability,We dumped Appveyor Windows testing since it was super slow. @jakebolewski suggested that CliMA has a lot of Windows testing resources through GitHub Actions so we should try to set something up.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1050:27,test,testing,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1050,2,['test'],['testing']
Testability,We need GPU-specific tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/78:21,test,tests,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/78,1,['test'],['tests']
Testability,We need regression tests for `SplitExplicitFreeSurface` on serial and distributed architectures. cc @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3335:19,test,tests,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3335,1,['test'],['tests']
Testability,We need to add a test for `ConsecutiveIterations` schedule that was introduced by #2100,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2154:17,test,test,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2154,1,['test'],['test']
Testability,"We need to benchmark various flavors of `ImmersedBoundaryGrid` including. * `GridFittedBoundary` for immersed boundaries that are both function-based (computed on the fly) and array-based (precomputed); * `GridFittedBottom` for the same (I think for _this_ case, precomputation is always wise. That's not the case for `GridFittedBoundary` though. The benchmarks will hopefully show this.); * Various immersed boundary conditions implemented in #2437 . These should be implemented for both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2452:11,benchmark,benchmark,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2452,2,['benchmark'],"['benchmark', 'benchmarks']"
Testability,"We need to extend our verification tests for the AMD closure to compare results for all turbulence closures we have implemented. As of now, the only turbulence closure implemented is `SmagorinskyLilly`. When #440 is resolved we can compare to the Vreman closure as well. This applies to . * Stratified Couette flow verification; * free convection verification; * Kato-Phillips verification. ref #81 and #381 . cc @tapios",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/441:35,test,tests,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/441,1,['test'],['tests']
Testability,"We need to implement a forward Euler time-stepping scheme, which is useful for testing if for nothing else. We need also better and more stable time-steppers. One option is to implement by hand a 3rd-order low storage Runge Kutta scheme. Another interesting avenue is to figure out how to integrate with `DifferentialEquations.jl`, which would give us access to a large number of new time-steppers (issue #391). However, we are unsure how this would couple with the our incoming GPU tridiagonal solvers for implicit time-stepping.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506:79,test,testing,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506,1,['test'],['testing']
Testability,We need to upgrade our testing infrastructure soon-ish.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:23,test,testing,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,1,['test'],['testing']
Testability,"We never made one. Might be good to do some advertising, point to the examples, and say it's ready for research use. https://discourse.julialang.org/c/community/packages/47. TODO (by @glwagner):. * [ ] stabilze JLD2OutputWriter API (resolve #963); * [ ] update README (resolve #961); * [ ] a few more cool movies (we can just pluck from current projects, eg eady turbulence, boundary layer turbulence, Andre’s); * [ ] YouTube channel for the movies?; * [ ] More benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1111:462,benchmark,benchmarks,462,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1111,1,['benchmark'],['benchmarks']
Testability,"We should add a benchmark for a fully loaded model, e.g. WENO-5 + RK3 + multiple passive tracers + TEOS-10(?) + output writing + time averaging + ... With #1088 we can serialize such a `BenchmarkGroup` to disk and compare with results from `benchmark_static_ocean.jl` to automatically generate tables of slowdown values for barebones simulation -> fully loaded simulation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1089:16,benchmark,benchmark,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1089,2,"['Benchmark', 'benchmark']","['BenchmarkGroup', 'benchmark']"
Testability,"We should add it to the `verification` folder as I'll mention it in the JOSS paper. I believe this verification test with Van Roekel et al. (2018) lives in https://github.com/glwagner/ColumnModelOptimizationProject/blob/master/les/deepening_mixed_layer.jl. @glwagner since you ran those tests do you want to do it? If you're busy I'm happy to do this. I think you also had some stuff on Overleaf that we can maybe transfer to the documentation?. Also, do you think your Kato & Phillips experiments should go in there as well?. ---. Using an analysis script to produce a figure like this might be useful:. ![image](https://user-images.githubusercontent.com/20099589/70105665-8468c280-160f-11ea-846d-c4bddcf02564.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/547:112,test,test,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/547,2,['test'],"['test', 'tests']"
Testability,We should add some annotations/docstrings on these functions. https://github.com/CliMA/Oceananigans.jl/blob/f8b4936d9553d53b399b43d5f27678867b9bcee6/test/test_multi_region_cubed_sphere.jl#L9-L65,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3242:149,test,test,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3242,1,['test'],['test']
Testability,"We should have some more sophisticated CPU and GPU benchmarks to make sure commits and pull requests don't surprisingly kill performance. Ideally along with CI (not sure if JuliaGPU's GitLab CI will let us do extensive benchmarking). Right now I just benchmark the global operators on the CPU, but I think a more meaningful benchmark would be something like average wall clock time per model time step between time steps 10-90 to avoid transients (+ no disk output) or something. Have a look at: https://github.com/KristofferC/TimerOutputs.jl; Also see: https://github.com/glwagner/CuBenchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/67:51,benchmark,benchmarks,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/67,4,['benchmark'],"['benchmark', 'benchmarking', 'benchmarks']"
Testability,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/136:47,test,tests,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136,3,"['benchmark', 'test']","['benchmarking', 'test', 'tests']"
Testability,"We should look into using `mapreduce` as a way of computing reduced grid metrics and statistics using abstract operations. This could speed up `AveragedField` (and upcoming `SummedField`, `IntegratedField`, etc.) and make them lighter by not having to store a scratch space. There are two methods for `mapreduce`:. ```julia; mapreduce(f, op, itrs...; [init]); mapreduce(f, op, A::AbstractArray...; dims=:, [init]); ```. The first one might be useful for abstract operations (as long as `getindex` is defined?). Might be useful to do a bit of benchmarking to see if we can use them (and potentially get rid of some existing code). The second function I guess would only be useful if we already have a `ComputedField` with an array. We already use `mapreduce` a bit (the second method) but crucially we needed to pass in a view into a `CuArray` (and not a view into an `OffsetArray{CuArray}`): https://github.com/CliMA/Oceananigans.jl/blob/master/src/Solvers/preconditioned_conjugate_gradient_solver.jl#L57-L58",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1422:542,benchmark,benchmarking,542,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1422,1,['benchmark'],['benchmarking']
Testability,"We should merge this after PR #805. # Release notes. This release fixes a major bug where you couldn't run GPU models so if you're using GPUs you should upgrade to this version. **Oceananigans.jl now requires Julia 1.4+.**. Major changes:; * Updated the backend to use [KernelAbstractions.jl](https://github.com/JuliaGPU/KernelAbstractions.jl) instead of [GPUifyLoops.jl](https://github.com/vchuravy/GPUifyLoops.jl).; * Updated to using [CUDA.jl](https://github.com/JuliaGPU/CUDA.jl) instead of CuArrays.jl, CUDAnative.jl, and CUDAdrv.jl.; * Updated and slightly expanded the model setup documentation.; * Added a bibliography and citations to the documentation.; * Generalized `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` to accept functions of `x, y, z, t` as well as constants. These types are called `IsotropicDiffusivity` and `AnisotropicDiffusivity`; `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` aliases are provided for backwards compatibility.; * Lots of new convergence tests confirming the accuracy of the model!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/810:1025,test,tests,1025,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/810,1,['test'],['tests']
Testability,We should run the [Performance Benchmarks](https://clima.github.io/OceananigansDocumentation/stable/benchmarks/) with the latest Oceananigans.jl version and on Julia v1.6.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1676:31,Benchmark,Benchmarks,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1676,2,"['Benchmark', 'benchmark']","['Benchmarks', 'benchmarks']"
Testability,We should tag and release v0.40.0 once PR #1020 is merged since GPU tests fail on v0.39.0 and #1020 fixes things so all tests pass.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1021:68,test,tests,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1021,2,['test'],['tests']
Testability,We should test our docs:. https://juliadocs.github.io/Documenter.jl/stable/man/doctests/index.html,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/493:10,test,test,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/493,1,['test'],['test']
Testability,We should use CI to test that examples and verification tests run without errors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/415:20,test,test,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/415,2,['test'],"['test', 'tests']"
Testability,"We test `ContinuousForcing` on the GPU. For example:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1059:3,test,test,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059,3,['test'],['test']
Testability,What if we just wanna run one test file?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3507:30,test,test,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507,1,['test'],['test']
Testability,"When attempting to run the problem in #1916 I noticed something alarming: models that are 2D in ""xz"" are far less performant than models that are 2D in ""xy"" on both the CPU and the GPU. On the CPU, 2D models in ""xz"" have alarmingly high memory allocation (allocations also seem high for ""xy"", something it seems we've lost track of). I tested this on a number of branches / versions and found similar behavior on all them, so it doesn't seem there's been a performance regression (at least not recently). I haven't tested any branches requiring julia 1.5 --- I'd like to try that too. To illustrate this I put together a small benchmarking script:. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: time_step!; using BenchmarkTools. xy_grid = RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 alloc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919:336,test,tested,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919,4,"['Benchmark', 'benchmark', 'test']","['BenchmarkTools', 'benchmarking', 'tested']"
Testability,"While in a perfect world we would include diffusivities in `model_fields` for both forcing functions and boundary condition functions, including them makes trouble for the compilation of `ContinuousForcing` (see #1059). We should have had a test that `ContinuousForcing` works with non-trivial turbulence closures (and perhaps tuples of closures as well). Since we don't include `diffusivities` in `model_fields` anymore, there's no need for such a test. But let it be noted that if `diffusivities` is ever restored to `model_fields`, we'll need to test that this works with various forcing functions and boundary condition functions (perhaps the problem will disappear as the julia versions march ever onwards...). This PR relies on #1057 (though it shouldn't...). Resolves #1059",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1061:241,test,test,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1061,3,['test'],['test']
Testability,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:14,test,tests,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,1,['test'],['tests']
Testability,Why in the tests for the implicit free surface we use a grid with `Ny = 1` and not `Flat` y?. https://github.com/CliMA/Oceananigans.jl/blob/27f7d044619b4159154a5940443be1d3d843aa5b/test/test_implicit_free_surface_solver.jl#L84-L86. cc @elise-palethorpe,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2625:11,test,tests,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2625,2,['test'],"['test', 'tests']"
Testability,"Will be useful for pressure solver and time stepping tests, and long running simulations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/224:53,test,tests,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/224,1,['test'],['tests']
Testability,"With @henryg888, we made these changes to make these shallow water benchmarks. Next, we will introduce code to plot the results, as can be found in #1722",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1735:67,benchmark,benchmarks,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1735,1,['benchmark'],['benchmarks']
Testability,With the arrival of `CUDA.versioninfo()` (see https://github.com/JuliaGPU/CUDA.jl/commit/f531c5f588164c2a577a7e669b37f51b3f84dd92) in CUDA.jl v1.1.0 we should probably make use of it in `Utils.versioninfo_with_gpu()` for NetCDF metadata (maximizes reproducibility?) and benchmarks.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/874:270,benchmark,benchmarks,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/874,1,['benchmark'],['benchmarks']
Testability,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3492:556,test,test,556,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492,3,['test'],"['test', 'tests']"
Testability,With this PR we can now apply boundary conditions on `x` and `y`. I still need to add tests and benchmark performance (nothing should change). One discussion point: Should we even add support for `x` boundary conditions seeing as we only support `Periodic` boundary conditions in the `x` direction?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/475:86,test,tests,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/475,2,"['benchmark', 'test']","['benchmark', 'tests']"
Testability,"Working with @elise-palethorpe we see that the preconditioned conjugate gradient solver is much slower than expected. See #2654. In particular, benchmarks on solving the Poisson equation on a doubly bounded domain on the [ep/pcg-with-multigrid](https://github.com/CliMA/Oceananigans.jl/tree/ep/pcg-with-multigrid) branch give:. ```Julia; julia> include(""validation/elliptic_solvers/doubly_bounded_poisson.jl""). julia> include(""doubly_bounded_poisson.jl""); [ Info: Solving the Poisson equation with an FFT-based solver...; 123.083 μs (93 allocations: 17.56 KiB); [ Info: Solving the Poisson equation with a conjugate gradient iterative solver...; 64.748 ms (80482 allocations: 25.93 MiB); [ Info: Solving the Poisson equation with the Algebraic Multigrid solver...; 9.491 ms (498 allocations: 8.46 MiB); [ Info: Solving the Poisson equation with a conjugate gradient preconditioned iterative solver w/ AMG as preconditioner...; 47.891 ms (12771 allocations: 111.97 MiB); ```. We'd expect the PCG to perform similarly to MG and MG-preconditioned PGC to perform better. There is definitely some issue with memory allocations but, possibly, something else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2728:144,benchmark,benchmarks,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728,1,['benchmark'],['benchmarks']
Testability,Would be good to set this up with Slurm CI (PR #280) and start doing continuous performance testing to ensure we don't make mistakes that slow the model down.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/380:92,test,testing,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/380,1,['test'],['testing']
Testability,"Would be helpful in giving content to any benchmarks produced. Probably also useful to include Julia `versioninfo()`, CUDA version maybe, other systems specs, MPI version, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/466:42,benchmark,benchmarks,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/466,1,['benchmark'],['benchmarks']
Testability,Would be helpful information to have especially when tests fail. We should also print `CUDA.versioninfo()` if running GPU tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1180:53,test,tests,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1180,2,['test'],['tests']
Testability,Would be nice to switch from print statements to using a real logger. We can start doing this in the tests where we have a lot of print statements. Logging would also be nice there so we can quickly eyeball how long tests take to execute from build logs. @arcavaliere said he'd be interested in doing this :tada:,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/578:62,log,logger,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/578,5,"['Log', 'log', 'test']","['Logging', 'logger', 'logs', 'tests']"
Testability,Would be useful to have some kind of state checker diagnostic that logs the min/max/mean/std/etc. of every model field for debugging purposes. Would be good to resolve #1117 first (which would make the state checker implementation cleaner).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1135:67,log,logs,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1135,1,['log'],['logs']
Testability,Would we need a `wall-time` regression test?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2176:39,test,test,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2176,1,['test'],['test']
Testability,"Yesterday, in https://github.com/openjournals/joss-reviews/issues/2018, I mentioned some failing tests on GPU. Since then, I tried to reproduce them in a clean and up-to-date environment but I now have issues even to install CUDA.jl. I'm suspecting a problem with my CUDA setup, and I don't really have the time nor the need to look into this. I pasted below the tracebacks I got a few days ago, just in case there is something useful for you in it, but don't feel any obligation to look into this issue that I can't reproduce. ```; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136; Test threw exception; Expression: time_step_with_forcing_functions(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:97,test,tests,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,4,"['Test', 'test']","['Test', 'test', 'tests']"
Testability,"[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:7185,Test,Test,7185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,"[inlined]; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/QYJpb/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:85; [3] with_halo(halo::Tuple{Int64, Int64, Int64}, ibg::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/QYJpb/src/ImmersedBoundaries/ImmersedBoundaries.jl:140; [4] top-level scope; @ ~/Desktop/test.jl:9; [5] include(fname::String); @ Base.MainInclude ./client.jl:476; [6] top-level scope; @ REPL[10]:1; [7] top-level scope; @ ~/.julia/packages/CUDA/BbliS/src/initialization.jl:52; ```. This prevents us from writing `WENO(immersed_boundary_grid)`, since `with_halo` is used by `WENO` to calculate reconstruction coefficients for stretched grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2988:2185,test,test,2185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2988,1,['test'],['test']
Testability,"[inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mod",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:7647,Test,Test,7647,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to bench",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107039,test,test,107039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_ed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:2950,test,test,2950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:19563,test,test,19563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:20371,test,test,20371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:19962,test,test,19962,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:20164,test,test,20164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:102294,Test,Test,102294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 937939cc1ef2 990KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 841a7461932f 1.0MiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 061ab36b8d44 1.3MiB docs/src/verification/convergence_pl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:3686,test,test,3686,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:11933,test,test,11933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/r,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:2879,test,test,2879,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['test'],['test']
Testability,_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_itera,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:2488,test,test,2488,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,`ConstantCartesianCoriolis` test dominates GPU testing wall time,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2647:28,test,test,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2647,2,['test'],"['test', 'testing']"
Testability,`Float32` tracer conservation test not actually `Float32`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/487:30,test,test,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/487,1,['test'],['test']
Testability,`HydrostaticFreeSurfaceModel` dynamics tests on `ConformalCubedSphereGrid` with fully explicit treatment of the free surface,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3265:39,test,tests,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3265,1,['test'],['tests']
Testability,"`IsotropicDiffusivity` currently uses a viscosity and thermal diffusivity appropriate for water at 20 degrees Celsius and 35 psu:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L11-L28. When I put this in I originally thought it was positive because it provided a reference. It's also cute because its ""oceanic"". But as time has gone on I now fear its actually surprising and also not very useful, since it's not actually a common to use Oceananigans for direct numerical simulations of miniscule boxes with molecular transport coefficients. Instead, `IsotropicDiffusivity` is useful for 1) idealized problems, education, examples and 2) as a simple turbulence closure when setting up a simulation / testing ideas, possibly prior to implementing a more complicated closure. This ""ocean-realistic"" default is inconvenient for either case. So, I propose changing the default for both the viscosity and diffusivity to 0. cc @tomchor @xiaozhour",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1278:824,test,testing,824,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1278,1,['test'],['testing']
Testability,"`NetCDFOutputwriter` has a bug for Immersed curvilinear grids, in practice for an immersed boundary the default ; `native_dimensions_for_netcdf_output` is called instead of the one for curvilinear grids. This PR should address the issue. ; Also it seems to not be tested so I ll add a test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3666:264,test,tested,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3666,2,['test'],"['test', 'tested']"
Testability,"`Oceananigans.TurbulenceClosures` is a bit messy right now. One big issue is that we have two implementations of `AnisotropicMinimumDissipation`. I think we should commit to `VerstappenAnisotropicMinimumDissipation`, and possibly change its name to just `AnisotropicMinimumDissipation`. We should also probably only support one version of `Smagorinsky`. We have an implementation of the Smagorinsky model that is _apparently_ used by the UK Met Office's Large Eddy Model (LEM), aka ""BLASIUS"" (`blasius_smagorinsky.jl`). But we never use this model and its untested. It's no small piece of work to really test all that code. Maybe we should delete it and just keep the much more common and popular `smagorinsky_lilly.jl`? We can also delete the alias `ConstantSmagorinsky`. Some functions should probably be shuffled around: all of the code in `closure_operators.jl` should be moved to `viscous_dissipation_operators.jl` and `diffusion_operators`. Also to be consistent we should rename `viscous_dissipation_operators.jl` to `viscosity_operators.jl` (or at the least, `viscous_friction_operators.jl`. The functions in `closure_operators.jl` also need to be converted to finite-volume form. I think the implementation of those functions can also be simplified to accept an isotropic viscosity rather than the entire `diffusivities` object. We should also probably wrap all of the closures in their own submodules? Or maybe not... The implementation for tupled closures is also split into the top-level file and `closure_tuples.jl`. We should put the whole thing in `closure_tuples.jl`. What else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1002:604,test,test,604,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1002,1,['test'],['test']
Testability,"``. Broadcasting also works with `AbstractOperations`:. ```julia; julia> d = Field(Face, Center, Center, CPU(), grid); Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (4, 4, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux). julia> dx_c = ∂x(c); Derivative at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ∂xᶠᶜᵃ at (Face, Center, Center) via identity;    └── Field located at (Center, Center, Center). julia> d .= 2 .* dx_c. julia> interior(d); 2×2×1 view(OffsetArray(::Array{Float64,3}, 0:3, 0:3, 0:2), 1:2, 1:2, 1:1) with eltype Float64:; [:, :, 1] =; 4.36713 3.46522; -1.988 4.13932; ```. Under the hood we launch kernels, so broadcasting is multithreaded and works on the GPU as well as the CPU. This is just the beginning I think. This PR only implements in-place broadcasting, but out-of-place (allocating) broadcasting would be useful for analysis of data via `AbstractField`. For this I think we need to define `Base.copy` in addition to `copyto!` (but this is simple since we already have `similar`...) ~~We also need to write a lot more code to make broadcasting robust: for example, we should check that broadcasted objects have the same location. We might also be able to implement interpolation correctly. This PR shows that all of this is possible.~~. This PR implements interpolated broadcasting by transforming `Base.Broadcast.Broadcasted` to `AbstractOperation`. Note: it also defines some new helper functions for `BinaryOperation` that should help with type inference and GPU compilation. This was necessary to get some of the broadcasting tests work (since broadcasting also uses `AbstractOperation`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1596:2370,test,tests,2370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1596,1,['test'],['tests']
Testability,`benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`. I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2417:1,benchmark,benchmarks,1,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417,5,['benchmark'],"['benchmarking', 'benchmarks']"
Testability,`required_halo_size` does not exist:. https://github.com/CliMA/Oceananigans.jl/blob/03b8acf4f378eeefdb5e79ceeafcf29fa711e94c/src/Advection/vector_invariant_advection.jl#L215. I guess it's not tested.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3865:192,test,tested,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3865,1,['test'],['tested']
Testability,`test/test_*.jl` is a redundant naming scheme,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/871:1,test,test,1,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/871,1,['test'],['test']
Testability,"`z_viscosity` is supposed to return the vertical diffusivity, or the coefficient `ν` that appears in the term `∂z ν ∂z u` --- _when that term exists for a given closure_. This means that. ```julia; julia> using Oceananigans. julia> using Oceananigans.TurbulenceClosures: z_viscosity. julia> horizontal_diffusivity = HorizontalScalarDiffusivity(ν=1, κ=1); ScalarDiffusivity{ExplicitTimeDiscretization, HorizontalFormulation}(ν=1.0, κ=1.0). julia> z_viscosity(horizontal_diffusivity, nothing); 1.0; ```. is wrong since `z_viscosity(horizontal_diffusivity, nothing) = 0`. I'm not sure if this affects functionality. `z_viscosity` is only used for vertically-implicit time-stepping. Regardless we should do the right thing here. We also need tests (eventually) for this ""internal interface"" for grabbing viscosities and diffusivities. (eg the functions `viscosity`, `diffusivity`, `z_viscosity`, `z_diffusivity`). It's a bit underdeveloped at the moment.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2291:738,test,tests,738,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2291,1,['test'],['tests']
Testability,a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:2234,test,test,2234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"ace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:114288,benchmark,benchmark,114288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"ages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:38161,Test,Test,38161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Test'],['Test']
Testability,"all : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = Time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:104501,benchmark,benchmark,104501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"ally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:1499,test,test,1499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"ally we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a draft PR for now because there are some things that need doing:. - [x] Generalize the filter for stretched grids. For now it assumes a regular grid for simplicity, but it's trivial to generalize.; - [x] Optimize the calculation of the coefficient. At the moment I'm creating four extra fields in order to calculate the Smag coefficient: `LM`, `MM` are 3D fields; and `LM_avg` and `MM_avg` are 1D or 2D. What I'm doing is to first calculate $L_{ij} M_{ij}$ and $M_{ij} M_{ij}$ pointwise, and then `LM_avg` and `MM_avg` receive their averages. We should be able to calculate everything without needing `LM`, `MM` are 3D fields, I just couldn't figure out how yet :); - [ ] Write docs; - [x] Write tests; - [x] Validate that model is working as intended. CC @glwagner @simone-silvestri @xkykai @whitleyv . Feel free to add more things to the to-do list that I may have forgotten.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642:2695,test,tests,2695,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642,1,['test'],['tests']
Testability,"alyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure. Resolves #1088",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169:1562,benchmark,benchmark,1562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169,3,['benchmark'],"['benchmark', 'benchmarking', 'benchmarks']"
Testability,"an benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 126s / 62.8% 1.46GiB / 0.13% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 39.4s 49.9% 3.94s 1.00MiB 50.0% 102KiB; 32× 32× 32 [CPU, Float64] 10 39.5s 50.1% 3.95s 1.00MiB 50.0% 102KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. Unfortunately still a bit higher than v0.22.0 (~50 KiB allocations) but much better and more acceptable than 17 MiB!. Remaining memory allocations seem to be occuring in `fill_halo_regions.jl` but tried inlining some functions and didn't help so I'll revisit the problem in the future. ```; julia> analyze_malloc("".""); 323-element Array{CoverageTools.MallocInfo,1}: ; ⋮ ; CoverageTools.MallocInfo(5008, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 36) ; CoverageTools.MallocInfo(5952, ""./benchmark/benchmark_utils.jl.32885.mem"", 35) ; CoverageTools.MallocInfo(6080, ""./src/TimeSteppers/time_stepping_kernels.jl.32885.mem"", 139) ; CoverageTools.MallocInfo(7136, ""./src/Architectures.jl.32885.mem"", 39) ; CoverageTools.MallocInfo(12160, ""./src/Utils/tuple_utils.jl.32885.mem"", 14) ; CoverageTools.MallocInfo(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 20); CoverageTools.MallocInfo(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 38); CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 45) ; CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 49) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 52) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 53) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 56) ; CoverageTools.MallocInfo(1664",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/685:1855,benchmark,benchmark,1855,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685,1,['benchmark'],['benchmark']
Testability,"anParticles` parameters, forcing functions (?), and callafters so that particle properties can be tracked, evolved, and interacted with tracers to model biogeochemistry (https://github.com/JuliaOcean/PlanktonIndividuals.jl) or play ecological games (https://github.com/ali-ramadhan/lagrangian-microbes). Right now I suppose it only advects particles using forward Euler. Using the model's RK3 for particle advection would double (or triple?) the memory usage of the particle tracker as we would have to store previous tendencies (velocities). I wonder if the accuracy of forward Euler is acceptable for Lagrangian particle tracking. I'm also wondering whether it makes sense to support both forward Euler and RK3 in case you want to advect a huge number of particles and memory is limiting the amount of particles you can track? I guess you can do RK3 or RK4 inside the `advect_particles!` kernel but it would assume that the velocity field is constant between stages. Perhaps a convergence test is needed to answer these questions. I think there are a lot of things that can be done at boundaries (see e.g. https://github.com/OceanParcels/parcels/issues/37, https://github.com/OceanParcels/parcels/issues/47, https://github.com/OceanParcels/parcels/issues/61) so I think we should pick a decent default and leave other options for future PRs. Right now, periodic dimensions are handled correctly but otherwise if a particle goes through a wall it will be placed back at the wall. This may cause it to get stuck at the wall. cc @suyash @zhenwu0728 Would something like this work for you guys?. TODO:. - [x] Figure out how we want to time step particle advection.; - [x] Decide on a default way of handling boundary conditions.; - [x] Tell NetCDF and JLD2 output writers how to write `LagrangianParticles` locations to disk.; - [x] Test that particle locations are correct after advection. Can test with an analytic solution produced by a constant flow field.; - [x] Write documentation for how to use",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091:1720,test,test,1720,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091,1,['test'],['test']
Testability,"ance regression (at least not recently). I haven't tested any branches requiring julia 1.5 --- I'd like to try that too. To illustrate this I put together a small benchmarking script:. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: time_step!; using BenchmarkTools. xy_grid = RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919:1458,Benchmark,Benchmarking,1458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919,1,['Benchmark'],['Benchmarking']
Testability,"and Oceananigans.jl. I'm not sure which modules would go where but the idea is that users will only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:6485,test,test,6485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['test'],['test']
Testability,"ans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:b,), Tuple{Float64}}}, diffusivities::Tuple{Nothing, NamedTuple{(:νₑ,), Tuple{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ Oceananigans.TurbulenceClosures /glade/work/tomasc/.julia/packages/Oceananigans/yF0dQ/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:51; ```. This PR fixes that and generalizes a test so that this issue can be caught in the future.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2945:2362,test,test,2362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2945,1,['test'],['test']
Testability,assert shallow water model is flat and add test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662:0,assert,assert,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662,2,"['assert', 'test']","['assert', 'test']"
Testability,"at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 ####",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107705,Benchmark,Benchmark,107705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,"['Benchmark', 'benchmark']","['Benchmark', 'benchmarking']"
Testability,"at the moment, the default time stepping function is designed with the non-hydrostatic model in mind, so the logical steps of a time step (or substep for RK3) are. ```julia; step_variables!(...); calculate_pressure_correction!(...) ; pressure_correct_velocities!(...); compute_new_tendencies!(...); ```; In the hydrostatic model, we are extending the `step_variables!` function to include a `step_free_surface!` function that calculates `η` and we set ; ```julia; calculate_pressure_correction!(::HydrostaticFreeSurfaceModel, ...) = nothing; ```; I would like to calculate the free surface in the `calculate_pressure_correction!` function to unify conceptually the `NonhydrostaticModel` and the `HydrostaticFreeSurfaceModel`, minimize the amount of code, and reduce the necessity for extending the time-stepping function.; This will make it easier to implement new time-stepping schemes that work for both the models",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3895:109,log,logical,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3895,1,['log'],['logical']
Testability,"at_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110656,test,test,110656,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"aticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:8103,test,test,8103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"atisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: see above; └─restricted by compatibility requirements with NNlib [872c559c] to versions: [1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled — no versions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:1802,log,log,1802,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['log'],['log']
Testability,"ative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CU; DAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnat; ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.C; uDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDevi; ceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oce; ananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func)}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f__apply); Stacktrace:; [1] overdub at /data5/glwagner/.julia/packages/Cassette/xggAf/src/context.jl:260; [2] ν_ccc at /data5/glwagner/Projects/Oceananigans.jl/src/closures/constant_smagorinsky.jl:109; [3] ν_Σᵢⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:405; [4] ∂x_faa at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:64; [5] ∂x_2ν_Σ₁₁ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:409; [6] ∂ⱼ_2ν_Σ₁ⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:432; [7] calculate_interior_source_terms! at /data5/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:152; [8] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); ```. I think this is specific to the package upgrades. I also got this error when running the `rayleigh_benard_passive_tracer.jl` script (associated with the function that forces salinity). Mysteriously, it does not throw this error when it runs the tests. Not sure where to raise an issue (if this is an issue)... _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/245#issuecomment-496472606_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248:2329,test,tests,2329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248,1,['test'],['tests']
Testability,"b.com/JuliaOcean/PlanktonIndividuals.jl) or play ecological games (https://github.com/ali-ramadhan/lagrangian-microbes). Right now I suppose it only advects particles using forward Euler. Using the model's RK3 for particle advection would double (or triple?) the memory usage of the particle tracker as we would have to store previous tendencies (velocities). I wonder if the accuracy of forward Euler is acceptable for Lagrangian particle tracking. I'm also wondering whether it makes sense to support both forward Euler and RK3 in case you want to advect a huge number of particles and memory is limiting the amount of particles you can track? I guess you can do RK3 or RK4 inside the `advect_particles!` kernel but it would assume that the velocity field is constant between stages. Perhaps a convergence test is needed to answer these questions. I think there are a lot of things that can be done at boundaries (see e.g. https://github.com/OceanParcels/parcels/issues/37, https://github.com/OceanParcels/parcels/issues/47, https://github.com/OceanParcels/parcels/issues/61) so I think we should pick a decent default and leave other options for future PRs. Right now, periodic dimensions are handled correctly but otherwise if a particle goes through a wall it will be placed back at the wall. This may cause it to get stuck at the wall. cc @suyash @zhenwu0728 Would something like this work for you guys?. TODO:. - [x] Figure out how we want to time step particle advection.; - [x] Decide on a default way of handling boundary conditions.; - [x] Tell NetCDF and JLD2 output writers how to write `LagrangianParticles` locations to disk.; - [x] Test that particle locations are correct after advection. Can test with an analytic solution produced by a constant flow field.; - [x] Write documentation for how to use Lagrangian particle tracking (add a page to the model setup docs).; - [x] Benchmark Lagrangian particle tracking with 1 - 100,000,000 particles.; - [x] Make cool movie. Resolves #511",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091:2560,Test,Test,2560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091,3,"['Benchmark', 'Test', 'test']","['Benchmark', 'Test', 'test']"
Testability,bcomp_jll v1.4.6+0; [33bec58e] Xorg_xkeyboard_config_jll v2.39.0+0; [c5fb5394] Xorg_xtrans_jll v1.5.0+0; [3161d3a3] Zstd_jll v1.5.5+0; [35ca27e7] eudev_jll v3.2.9+0; [214eeab7] fzf_jll v0.43.0+0; [1a1c6b14] gperf_jll v3.1.1+0; [477f73a3] libaec_jll v1.1.2+0; [a4ae2306] libaom_jll v3.4.0+0; [0ac62f75] libass_jll v0.15.1+0; [2db6ffa8] libevdev_jll v1.11.0+0; [f638f0a6] libfdk_aac_jll v2.0.2+0; [36db933b] libinput_jll v1.18.0+0; [b53b4c65] libpng_jll v1.6.43+1; [f27f6e37] libvorbis_jll v1.3.7+1; [337d8026] libzip_jll v1.10.1+0; [009596ad] mtdev_jll v1.1.6+0; [1270edf5] x264_jll v2021.5.5+0; [dfaa095f] x265_jll v3.5.0+0; [d8fb68d0] xkbcommon_jll v1.4.1+1; [0dad84c5] ArgTools v1.1.1; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8ba89e20] Distributed; [f43a241f] Downloads v1.6.0; [7b1f6079] FileWatching; [9fa8497b] Future; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL v0.6.4; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions v1.2.0; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9abbd945] Profile; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.1.0+0; [781609d7] GMP_jll v6.2.1+6; [deac9b47] LibCURL_jll v8.4.0+0; [e37daf67] LibGit2_jll v1.6.4+0; [29816b5a] LibSSH2_jll v1.11.0+1; [c8ffd9c3] MbedTLS_jll v2.28.2+1; [14a3606d] MozillaCACerts_jll v2023.1.10; [4536629a] OpenBLAS_jll v0.3.23+4; [05823500] OpenLibm_jll v0.8.1+2; [efcefdf7] PCRE2_jll v10.42.0+1; [bea87d4a] SuiteSparse_jll v7.2.1+1; [83775a58] Zlib_jll v1.2.13+1; [8e850b90] libblastrampoline_jll v5.8.0+1; [8e850ede] nghttp2_jll v1.52.0+1; [3f19e933] p7zip_jll v17.4.0+2; Info Packages marked with,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:10622,Log,Logging,10622,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Log'],['Logging']
Testability,benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/reg,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:2149,test,test,2149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110873,test,test,110873,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"benchmarks scripts cannot write CPU to GPU speedup table to html file due to "">"" being in filename",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1672:0,benchmark,benchmarks,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1672,1,['benchmark'],['benchmarks']
Testability,"ber of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 16) : (16, 16, 16); 53 na, np = test_case; 54 tracers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:116814,test,test,116814,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"ble_incompressible_model.jl. Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/07/30 10:27:44.108] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/07/30 10:28:25.970] INFO warming up; [2021/07/30 10:29:55.456] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/lwSps/lib/cudadrv/profile.jl:71; [2021/07/30 10:29:58.016] INFO done profiling (GPU, Float64, 128); ==104758== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl; ==104758== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 12.29% 502.36us 5 100.47us 94.015us 103.42us _Z25julia_gpu_ab2_step_field_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE20_gpu_ab2_step_field_16CompilerMetadataI10StaticSizeI15_128__128__128_E12DynamicCheckvv7NDRangeILi3ES5_I11_8__8__128_ES5_I11_16__16__1_EvvEE11OffsetA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912:1265,benchmark,benchmark,1265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912,1,['benchmark'],['benchmark']
Testability,bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_ite,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:2361,test,test,2361,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"bulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more th",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:114218,benchmark,benchmark,114218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:1142,test,test,1142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,1,['test'],['test']
Testability,"by endowing `BinaryOperation` with three interpolation operators: two interpolation operators applied to each field prior to interpolation, and an interpolation operator that is applied to the result. Special cases can then be handled by defining operators for cases in which a computation should be performed at the location of one or both of the fields. Furthermore, we do not provide `PolynaryOperation`s with default locations. In other words, a `PolynaryOperation` only arises when location is specified, eg:. ```julia; julia> op1 = u + v + w;. julia> op2 = @at (Cell, Cell, Cell) u + v + w;. julia> typeof(op1).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation. julia> typeof(op2).name.wrapper; Oceananigans.AbstractOperations.PolynaryOperation; ```. This also means that all fields in a `PolynaryOperation` are interpolated *prior* to computation. # Computations. This PR also adds a type for making ""computations"" with an `AbstractOperation`. We call this a `Computation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here has been defined as `model.pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the horizontal average of `computation.result`. # Some important details. * This PR changes the meaning of `data`, which is used extensively in forming operations. This resolves #454. A new function `interior` serves the original purpose of `data`. * This PR depends on the arbitrary tracers ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:5460,test,tests,5460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['test'],['tests']
Testability,c6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [124859b0] DataDeps v0.7.13; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.18; [e2d170a0] DataValueInterfaces v1,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:1935,Test,Test,1935,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Test'],['Test']
Testability,c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 26236174 (Pool: 26209699; Big: 26475); GC: 35; ```. I'll test CPU then try to see if this situation is tested.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:6382,test,test,6382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,2,['test'],"['test', 'tested']"
Testability,"calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_dis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:22077,test,test,22077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"cate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:22718,test,test,22718,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"cation tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:1065,test,test,1065,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,1,['test'],['test']
Testability,cc @sandreza this affects your Rossby-Haurwitz test.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1439:47,test,test,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1439,1,['test'],['test']
Testability,"cd64354) as suggested by @simone-silvestri. It turned out that using `ImmersedPoissonSolver` makes the simulation tens of times slower than the original simulation without using an immersed boundary condition. Besides. using `AsymptoticInverse` or `ILUFactorization` preconditioner makes the simulation even slower. Here are the details of my runs. I did three runs. The domain size is 170 x 1320 x 50. In the first run, I used no preconditioner,; and the pressure solver is; ```Julia; pressure_solver = ImmersedPoissonSolver(; ib_grid,; solver_method = :HeptadiagonalIterativeSolver,; reltol = 1e-8,; verbose = true; ); ```. In the second run, I used the `AsymptoticInverse` preconditioner:; ```Julia; pressure_solver = ImmersedPoissonSolver(; ib_grid,; solver_method = :HeptadiagonalIterativeSolver,; reltol = 1e-8,; preconditioner = :AsymptoticInverse,; verbose = true; ); ```. In the third run, I used the `ILUFactorization` preconditioner:; ```Julia; pressure_solver = ImmersedPoissonSolver(; ib_grid,; solver_method = :HeptadiagonalIterativeSolver,; reltol = 1e-8,; preconditioner = :ILUFactorization,; verbose = true; ); ```. I ran each simulation on a NVIDIA V100 GPU \(on MIT Satori\) for 4 hours and calculated the number of iterations in unit time. As a result, the speeds of these three simulations are 134, 62, and 29 iterations per hour respectively. The full scripts for three runs and the corresponding output logs are given here:; - No preconditioner: [run_a1.tar.gz](https://github.com/CliMA/Oceananigans.jl/files/14963710/run_a1.tar.gz); - `AsymptoticInverse` preconditioner: [run_a2.tar.gz](https://github.com/CliMA/Oceananigans.jl/files/14963712/run_a2.tar.gz); - `ILUFactorization` preconditioner: [run_a3.tar.gz](https://github.com/CliMA/Oceananigans.jl/files/14963714/run_a3.tar.gz). Version info:; - Julia: v1.9.3; - Oceananigans v0.86.0 `dev/Oceananigans` [this branch](https://github.com/CliMA/Oceananigans.jl/commit/4529c6e49b9ebd9dbefb71725ef32b1d3cd64354); - CUDA v5.2.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552:1584,log,logs,1584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552,1,['log'],['logs']
Testability,"chmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:112068,benchmark,benchmark,112068,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:1973,assert,assertscalar,1973,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['assert'],['assertscalar']
Testability,"cs. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to test because the feature does not exist yet (such as accurate reduced precision algorithm or nonlinear free surface). Thus we should consider this PR carefully.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:4056,test,tests,4056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,3,['test'],"['test', 'tested', 'tests']"
Testability,"cted. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:7637,benchmark,benchmarks,7637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['benchmark'],['benchmarks']
Testability,"d,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1seconds, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. Here's the output log of the script:; ```; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 74.284 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.75, 1.0], y(particle): [0.0, 0.25, 0.5, 0.75, 1.0], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: ... simulation initialization complete (72.159 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (92.717 ms).; i: 1, t: 100 ms, wall time: 96.815 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.25, 0.5], y(particle): [0.0, 0.25, 0.5, 0.25, 0.5], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: Simulation is stopping after running for 171.290 ms.; [ Info: Model iteration 2 equals or exceeds stop iteration 2.; i: 2, t: 200 ms, wall time: 2.341 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.25, 0.5], y(particle): [0.0, 0.25, 0.5, 0.25, 0.5], z(p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3415:1878,log,log,1878,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3415,1,['log'],['log']
Testability,"dBoundaryGrid && begin; while grid.immersed_boundary.bottom_height[imid, jmid] > grid.underlying_grid.zᵃᵃᶜ[k_index]; k_index += 1; end; end. k_index = k_index + 1 ≤ grid.Nz ? k_index + 1 : k_index; ; u[imid, jmid, k_index] = 0.1. update_state!(model). return nothing; end. arch = CPU(). rectilinear_grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (-500kilometers, 500kilometers),; y = (0, 1),; z = (-400, 0),; topology = (Bounded, Periodic, Bounded)). Lz = rectilinear_grid.Lz; width = 50kilometers; bump(x, y) = - Lz * (1 - 0.2 * exp(-x^2 / 2width^2)). grid = ImmersedBoundaryGrid(rectilinear_grid, GridFittedBottom(bump)). free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; abstol=1e-15, reltol=0). model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface). set_simple_divergent_velocity!(model). @show model.velocities.u. events = ((device_event(arch), device_event(arch)), (device_event(arch), device_event(arch))). Δt = 900.0; implicit_free_surface_step!(model.free_surface, model, Δt, 1.5, events). η = model.free_surface.η; @info ""implicit free surface solver test, norm(η): $(norm(η)), maximum(abs, η): $(maximum(abs, η))""; ```. gives. ```Julia; julia> @show model.velocities.u; model.velocities.u = 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> @info ""implicit free surface solver test, norm(η): $(norm(η)), maximum(abs, η): $(maximum(abs, η))""; [ Info: implicit free surface solver test, norm(η): 0.0, maximum(abs, η): 0.0; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723:4840,test,test,4840,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723,3,['test'],['test']
Testability,da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [124859b0] DataDeps v0.7.13; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.18; [e2d170a0] DataValueInterfaces v1.0.0; [8bb1440f] DelimitedFiles v1.9.1; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [7da242da] Enzyme v0.11.19; ⌅ [,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:2151,Benchmark,BenchmarkTools,2151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Benchmark'],['BenchmarkTools']
Testability,"daryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[2]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:30; ```. But also, I anticipate there are more bugs waiting to be found with `VerticallyStretchedGrids`. If I issue the command `grep -r ""\<Δz\>"" *` (which basically looks for instances of `Δz` and excludes `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ`) and I get this:. ```; ~/repos2/Oceananigans.jl/src$ grep -r ""\<Δz\>"" *; Fields/interpolate.jl:@inline fractional_z_index(z, ::Center, grid::RegularRectilinearGrid) = @inbounds (z - grid.zC[1]) / grid.Δz; Fields/interpolate.jl:@inline fractional_z_index(z, ::Face, grid::RegularRectilinearGrid) = @inbounds (z - grid.zF[1]) / grid.Δz; Grids/regular_latitude_longitude_grid.jl: Δz :: FT; Grids/regular_latitude_longitude_grid.jl: Δλ, Δϕ, Δz = Δ = @. L / N; Grids/regular_latitude_longitude_grid.jl: return RegularLatitudeLongitudeGrid{FT, TX, TY, TZ, typeof(λᶠᵃᵃ)}(Nλ, Nϕ, Nz, Hλ, Hϕ, Hz, Lλ, Lϕ, Lz, Δλ, Δϕ, Δz, λᶠᵃᵃ, λᶜᵃᵃ, ϕᵃᶠᵃ, ϕᵃᶜᵃ, zᵃᵃᶠ, zᵃᵃᶜ, radius); Grids/regular_latitude_longitude_grid.jl: ""grid spacing (Δλ, Δϕ, Δz): "", (g.Δλ, g.Δϕ, g.Δz)); Grids/regu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466:16597,sandbox,sandbox,16597,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466,1,['sandbox'],['sandbox']
Testability,data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotro,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:3241,test,test,3241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:16045,test,test,16045,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"del resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(timer[bn32]); 56 t64 = TimerOutputs.time(timer[bn64]); 57 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:108743,benchmark,benchmark,108743,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['benchmark'],"['benchmark', 'benchmarks']"
Testability,"diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl#L217. and by `NetCDFOutputWriter` (though a bit differently since it gives a timing for each output):.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:1173,Benchmark,Benchmarking,1173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,1,['Benchmark'],['Benchmarking']
Testability,"dic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 16 │ (1, 2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:1663,Benchmark,Benchmark,1663,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['Benchmark'],['Benchmark']
Testability,"down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; │ [6] macro expansion; │ @ ./none:0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:1223,log,log,1223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['log'],['log']
Testability,"duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definitio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:22286,test,test,22286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:21225,test,test,21225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"e `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating the examples and docs, though we still need to. - [x] finish updating verification scripts; - [x] finish updating docs. Since we now have a fairly convincing test about the accuracy of `WindowedTimeAverage`, I think we should also. - [x] add documentation for `WindowedTimeAverage`. which is apropos to this PR since it changes the syntax through which averaging is specified. Eventually, we should use the ""scheduling"" concept for both callafter function in `run!(simulation)` and the `TimeStepWizard` (separately), which will get rid of the `iteration_interval` argument in `run!(simulation)`. PS: should we use `WindowAveragedTimeInterval` rather than `AveragedTimeInterval`? I wasn't sure if the added verbosity added clarity here (the important part is the ""Averaging"") but I'm open to considering it. Resolves #1019 ; Resolves #853 ; Resolves #845",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070:2158,test,test,2158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070,1,['test'],['test']
Testability,"e calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:21652,test,test,21652,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"e same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNIN",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:16675,test,test,16675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"e.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczyn",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:1669,test,tests,1669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,1,['test'],['tests']
Testability,"e/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:108028,benchmark,benchmark,108028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"e:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670:1789,test,test,1789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670,1,['test'],['test']
Testability,"e; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:10980,Test,Testing,10980,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Testing']
Testability,"e; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:8876,Test,Testing,8876,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Testing']
Testability,ean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 937939cc1ef2 990KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 841a7461932f 1.0MiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 061ab36b8d44 1.3MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 2f48fac8a7f5 1.4MiB paper/free_convection_and_baroclinic_instability.png; 7ef3d,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:3822,test,test,3822,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"ed over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +). BenchmarkTools.Trial: ; memory estimate: 2.88 KiB; allocs estimate: 64; --------------; minimum time: 39.129 ms (0.00% GC); median time: 39.245 ms (0.00% GC); mean time: 39.248 ms (0.00% GC); maximum time: 39.374 ms (0.00% GC); --------------; samples: 128; evals/sample: 1; ```. Probably optimal performance:; ```julia; @benchmark CuArrays.@sync mean(a, dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 8.56 KiB; all",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352:1595,Benchmark,BenchmarkTools,1595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352,1,['Benchmark'],['BenchmarkTools']
Testability,"ed]; [6] construct_regionally; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:143 [inlined]; [7] #construct_regionally#51; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139 [inlined]; [8] construct_regionally(::Function, ::Tuple{DataType, DataType, DataType}, ::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139; [9] indices(κ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64, typeof(test), Tuple{NamedTuple{(), Tuple{}}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/pbNSE/src/AbstractOperations/kernel_function_operation.jl:74; [10] Field(operand::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64, typeof(test), Tuple{NamedTuple{(), Tuple{}}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/pbNSE/src/AbstractOperations/computed_field.jl:37; [11] top-level scope; @ REPL[12]:1; ```. For some reason it seems this only happens when passing `auxiliary_fields` to KFO.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3232:2074,test,test,2074,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232,2,['test'],['test']
Testability,ed_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:3054,test,test,3054,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"ee #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczynski @simonbyrne: Just wondering if this is a problem you guys are anticipating for CliMA.jl? We might be able to share some common solutions?. Resources:; * [Nvidia slides on building a GPU-focused CI solution](http://on-demand.gputechconf.com/gtc/2018/presentation/s8563-building-a-gpu-focused-ci-solution.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:2079,test,tests,2079,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,3,['test'],"['test-with-several-processors', 'testing', 'tests']"
Testability,"enAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:112325,benchmark,benchmarks,112325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['benchmark'],"['benchmark', 'benchmarks']"
Testability,"enchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110222,test,test,110222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"er/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of ac",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:114428,benchmark,benchmark,114428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"er/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107894,benchmark,benchmarks,107894,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmarks']
Testability,"er: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:80; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; [9] top-level scope at none:1. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:5203,test,test,5203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,5,['test'],['test']
Testability,"er[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110777,Test,Test,110777,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"eration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.083 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (842.167 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.379 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.602 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing Coriolis ensemble member (1, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:9",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:5083,Test,Test,5083,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,"ersion: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:14235,test,test,14235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"es. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it would solve all the of the problems above. The downsides that I can think of are:. 1. Simulations using this feature would possibly waste space on disk by outputting ""frozen"" tracer fields before they start evolving.; 2. One more thing in the models to test and maintain. Maybe the biggest issue is that I'm not sure this is something enough people actually want to do with their simulations. This has been a relatively common thing for my research, and I know @whitleyv does this too, but maybe we're the exception?. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154:2254,test,test,2254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154,1,['test'],['test']
Testability,"essure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 16 │ (1, 2, 3) │ 13.948 μs │ 14.043 μs │ 20.717 μs │ 80.605 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ (1, 2, 3) │ 1.656 ms │ 1.717 ms │ 1.809 ms │ 2.697 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ (1, 2, 3) │ 229.619 ms │ 233.008 ms │ 234.033 ms │ 243.288 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 1 │ 3.240 μs │ 3.255 μs │ 3.603 μs │ 6.746 μs │ 0 b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:1992,benchmark,benchmarks,1992,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['benchmark'],['benchmarks']
Testability,"ests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 mod",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:103765,benchmark,benchmark,103765,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:7325,benchmark,benchmarks,7325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['benchmark'],['benchmarks']
Testability,"f), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:80; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:4901,test,test,4901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['test'],['test']
Testability,"f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 14.2 ms Histogram: frequency by time 14.4 ms <. Memory estimate: 47.78 KiB, allocs estimate: 320. ```. The counterpart using the new branch `julia --project=""environments/one_sided_branch"" --check-bounds=no`; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true; BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 16.463 ms … 18.503 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 16.466 ms ┊ GC (median): 0.00%; Time (mean ± σ): 16.878 ms ± 908.449 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▁▁▁▁▁▁▁▁▁",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658:2009,Benchmark,BenchmarkTools,2009,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658,1,['Benchmark'],['BenchmarkTools']
Testability,"face_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:7719,test,test,7719,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,fix benchmark link,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1953:4,benchmark,benchmark,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1953,1,['benchmark'],['benchmark']
Testability,fjp/updating-benchmarks-with-shallow-water-model,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1508:13,benchmark,benchmarks-with-shallow-water-model,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1508,1,['benchmark'],['benchmarks-with-shallow-water-model']
Testability,"for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 co",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:113729,Test,Test,113729,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"for the JOSS paper. Was going to include the convergence tests as part of `test_verification.jl` but in cleaning them up (mostly by relying on the version of Oceananigans in the repository, `using .ConvergenceTests` as a local module, and making sure legends don't block off the plots) I noticed that the 2D convergence tests are all failing now. Pretty sure this must be a stupid mistake as they were all converging correctly as of Oceananigans v0.30.0 but haven't tried to figure out what went wrong yet... Since they're kinda important now I'm thinking we should have a test job that just runs all the convergence tests, tests that the order of convergence is as expected, and produces all the convergence plots so we can look at them. We can do this once we've set up Buildkite somewhere (see also @simonbyrne's https://github.com/CliMA/slurm-buildkite). Also, @glwagner do we still need `analyze_single_forced_fixed_slip.jl` and `analyze_forced_fixed_slip_pressure.jl`? They're not mentioned in the convergence tests `README.md` so maybe we should remove them?. Resolves #873. # Convergence test plots. ![point_exponential_decay_time_stepper_convergence](https://user-images.githubusercontent.com/20099589/91511129-04753d80-e8ad-11ea-95a9-582b79da9dab.png). ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511137-09d28800-e8ad-11ea-9ac5-f978cd49ae5b.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511140-0b9c4b80-e8ad-11ea-84ce-cb418b1971b0.png). ![gaussian_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511147-0dfea580-e8ad-11ea-8c09-9816a687e67e.png). ![gaussian_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511151-0f2fd280-e8ad-11ea-80c4-8b7920da8d64.png). ![two_dimensional_diffusion_convergence](https://user-images.githubusercontent.com/20099589/91511159-122ac300-e8ad-11ea-877e-251defc28879.png). !",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/881:1031,test,tests,1031,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881,1,['test'],['tests']
Testability,"for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition fie",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:16249,test,test,16249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,fourth-order advection tested?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/925:23,test,tested,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/925,1,['test'],['tested']
Testability,"fsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},Array{Int64,1},Array{Periodic,1},Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing}}}}},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(print_progress),Int64,Nothing}) at /home/tomas/repos2/Oceananigans.jl/src/Simulations/run.jl:127; [7] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; [8] include(::String) at ./client.jl:457; [9] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; ```. This is the MWE I'm running:. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz), ; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,; halo=(3,3,3)); ; ; model = IncompressibleModel(grid = grid,; ); ; wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=10,; ). run!(simulation); ```. The bug in question seems to be in the `cell_advection_timescale` routine: htt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1465:51286,sandbox,sandbox,51286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465,1,['sandbox'],['sandbox']
Testability,fusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:2823,test,test,2823,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"g = 0, dVdz_bg = 0). if isnothing(data); data = new_data(model.architecture, model.grid, (Cell, Cell, Face)); end. u, v, w = model.velocities; b = model.tracers.b. return RichardsonNumber(data, model.grid, u, v, b, dUdz_bg, dVdz_bg, N²_bg); end. function compute!(Rich::RichardsonNumber). arch = architecture(Rich.data). workgroup, worksize = work_layout(Rich.grid, :xyz, location=(Cell, Cell, Face)). compute_kernel! = compute_richardson_number!(device(arch), workgroup, worksize). event = compute_kernel!(Rich.data, Rich.grid,; Rich.u, Rich.v, Rich.b,; Rich.dUdz, Rich.dVdz, Rich.N2; dependencies=Event(device(arch))). wait(device(arch), event). return nothing; end. @kernel function compute_richardson_number!(Ri, grid, u, v, b, Uz, Vz, N2); i, j, k = @index(Global, NTuple). #dBdz = ∂zᵃᵃᶠ(i, j, k, grid, b) + N2 # dbdz(c, c, f); #dUdz_tot = ℑxᶜᵃᵃ(i, j, k, grid, ∂zᵃᵃᶠ, u) + Uz # dudz(f, c, f) => dudz(c, c, f); #dVdz_tot = ℑyᵃᶜᵃ(i, j, k, grid, ∂zᵃᵃᶠ, v) + Vz # dvdz(c, f, f) => dvdz(c, c, f). #@inbounds Ri[i, j, k] = dBdz / (dUdz_tot^2 + dVdz_tot^2); @inbounds Ri[i, j, k] = N2 / (Uz^2 + Vz^2); end; ```. So, note that, as a test, I'm using using `N2`, `Uz` and `Vz` in the actual calculation at the end. These are all constants (background stratification and shear) and the value of Ri should be exactly `1` at end. However, this is what I'm getting (I'm showing a horizontal average of a time step):. ```python; <xarray.DataArray 'Ri' (zF: 17)>; array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0.]); Coordinates:; * zF (zF) float64 -100.0 -87.5 -75.0 -62.5 ... 62.5 75.0 87.5 100.0; xC float64 7.812; xF float64 0.0; time float64 600.0; ```. For those unfamiliar with xarray, the output is `1` everywhere (good!) except at the upper boundary, where for some reason it is zero (bad!). Since I'm only using constants to calculate this, it seems to me that, for some reason, the corresponding `k` isn't being calculated at all. . Any ideas of how I might fix this?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1290:1960,test,test,1960,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1290,1,['test'],['test']
Testability,"g under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:6598,test,tests,6598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,2,['test'],"['test', 'tests']"
Testability,"gans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:76412,test,test,76412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"get a very similar error from the distributed nonhydrostatic script when I run the tests script, but the distributed shallow water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:1144,benchmark,benchmarking,1144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,1,['benchmark'],['benchmarking']
Testability,"h_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] #",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:113946,Test,Test,113946,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"h`.; * Probably `MultiArch` should take a similar approach as the grid constructor; ie we can't distribute a grid in `Flat` directions, so `ranks` should be a 2-tuple for 2D topology, 1-element for 1D topology.; * We might want some functions for `arch` (and also `grid`, `model`, `sim`):; * `communicator(grid)` returns eg `MPI.COMM_WORLD`; * `local_rank(grid)` returns eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:14",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:1339,log,logs,1339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,1,['log'],['logs']
Testability,"hange the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:1440,test,test,1440,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"he fluxes using the `indices` flag, and an y-average of them:. ```julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(size=(16, 16, 16), extent = (500, 500, 120)). n_tracers = 6; tracer_symbols = [ Symbol(:τ,i) for i in 1:n_tracers ]; model = NonhydrostaticModel(; grid, tracers = (tracer_symbols...,)); @info model. uᵢ(x, y, z) = 1e-2 * randn(); set!(model, w=uᵢ). tracer_IC_odd(x, y, z) = sin(2π*z/grid.Lz); for i in 1:n_tracers; @info ""Setting tracer $i""; expression = Meta.parse(""set!(model, τ$i=tracer_IC_odd)""); eval(expression); end. simulation = Simulation(model, Δt=30, stop_time=0.15hours). u, v, w = model.velocities. wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers)). outputs_full = (; wτ...). outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full) ). outputs_xz1 = merge(outputs_full, outputs_yavg); simulation.output_writers[:xz1_writer] = NetCDFOutputWriter(model, outputs_xz1;; filename = ""data/TEST.nc"",; schedule = TimeInterval(simulation.stop_time),; verbose=true,; indices = (:, 1, :),; overwrite_existing = true,; ); run!(simulation); ```. While the outputs should be the same (since the tracers and their advection are identical), I get different results for the y-averaged fluxes for different tracers:. ![image](https://user-images.githubusercontent.com/13205162/219516253-394a7e77-8c7e-4be1-be29-d2bdfadacdb3.png). Note that, while similar, tracers α=1,3,4 are different from α=2,5,6. The difference isn't large in this example, but can be made larger with more complexity in the calculations. A couple of notes:. - Changing the line `wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers))` to ; ```julia; wτ = NamedTuple(Symbol(:w, key) => w*τ for (key,τ) in pairs(model.tracers)); ```; gets rid of the issue. Although doing the above prevents a user from using `Field(op, data=scratch_data.data)` to save memory, wh",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931:1282,TEST,TEST,1282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931,1,['TEST'],['TEST']
Testability,"he repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:1147,test,test,1147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"hly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditioner is faster (benchmarks below). ; * Both the ""matrix"" and ""non-matrix"" solvers use conjugate gradient iteration --- the difference is in how they compute the left-hand-side (ie the linear left-side operator above, and the preconditioners that are supported). ## Benchmarks. Note that ""PCGImplicitFreeSurface"" below means ""PCGImplicitFreeSurface with FFT based preconditioner"". These benchmarks have a problem size 256 x 128 x 1. ### CPU; ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 6.635 ms │ 7.733 ms │ 13.564 ms │ 33.224 ms │ 3.07 MiB │ 5626 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 9.578 ms │ 11.644 ms │ 11.541 ms │ 13.400 ms │ 4.55 MiB │ 8023 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 13.193 ms │ 14.087 ms │ 14.329 ms │ 17.618 ms │ 5.34 MiB │ 9656 │ 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:2675,Benchmark,Benchmarks,2675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['Benchmark'],['Benchmarks']
Testability,"hmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 56 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:106398,test,test,106398,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"https://github.com/CliMA/Oceananigans.jl/blob/28dadbcc52a2badd242e89ba30c8cc34f9117327/src/Operators/vorticity_operators.jl#L1-L2. At the cubed sphere corners the grid is not actually orthogonal and so the vector-invariant formulation breaks down unless we compute the circulation carefully for each corner. ![image](https://user-images.githubusercontent.com/20099589/114737069-a8183e80-9d14-11eb-9a9c-07b5243af3c2.png). I've attached the appropriate reference (Adcroft et al., 2004):. [Adcroft et al, 2004, Monthly Weather Review, Implementation of an Atmosphere–Ocean General Circulation Model on the Expanded Spherical Cube.pdf](https://github.com/CliMA/Oceananigans.jl/files/6311899/Adcroft.et.al.2004.Monthly.Weather.Review.Implementation.of.an.Atmosphere.Ocean.General.Circulation.Model.on.the.Expanded.Spherical.Cube.pdf). Here is the MITgcm implementation: https://github.com/MITgcm/MITgcm/blob/master/pkg/mom_common/mom_calc_relvort3.F. Once this is fixed, the Rossby-Haurwitz test case in PR #1570 with momentum advection should stop blowing up at the corners.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1584:986,test,test,986,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1584,1,['test'],['test']
Testability,https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/test/runtests.jl#L3. We should remove this,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3039:87,test,test,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3039,1,['test'],['test']
Testability,https://github.com/climate-machine/Oceananigans.jl/blob/e69e81a0a7f93029b7e8c1eed62b8414c11dec1a/test/test_output_writers.jl#L137,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/716:97,test,test,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/716,1,['test'],['test']
Testability,"ia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:1573,log,log,1573,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['log'],['log']
Testability,ian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simu,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:2696,test,test,2696,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"icFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Resea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:12317,test,test,12317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"icate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:21436,test,test,21436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"id/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Us",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:15637,test,test,15637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"ies.u.data.parent; fields = Dict(:u => u); ow = JLD2OutputWriter(model, fields; prefix=""test"", frequency=5, max_filesize=10MiB, force=true, verbose=true); push!(model.output_writers, ow). time_step!(model, 50, 1); ```; ```; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 4.608 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=3.822 s, size=2.2 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.891 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.262 ms, size=4.4 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.118 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.564 ms, size=6.6 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.479 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=18.126 ms, size=8.8 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.421 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=23.091 ms, size=11.0 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.627 μs; [ Info: Filesize 11.0 MiB has exceeded maximum file size 10.0 MiB.; [ Info: Renaming first part: ./test.jld2 -> ./test_part1.jld2; [ Info: Now writing to: ./test_part2.jld2; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=19.754 ms, size=2.2 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.320 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=13.866 ms, size=4.4 MiB, Δsize=2.2 MiB; ...; ..; .; .; .; ```. At the end:; ```; Permissions Size User Date Modified Name; .rw-r--r-- 11M alir 10 Aug 10:20 test_part1.jld2; .rw-r--r-- 11M alir 10 Aug 10:20 test_part2.jld2; .rw-r--r-- 2.3M alir 10 Aug 10:20 test_part3.jld2; ```. Resolves #344",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/350:1934,test,test,1934,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350,1,['test'],['test']
Testability,"igans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:117566,Test,Test,117566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"in Oceananigans to perform upwind reconstruction is roughly:; ```julia; R_left = _left_reconstruction(.....); R_right = _right_reconstruction(.....). return ifelse(u > 0, u * R_left, u * R_right); ``` . This means that we are always performing the reconstruction twice. This is not a huge problem for linear reconstruction schemes (`UpwindBiased`) but leads to register blowup for `WENO` schemes that are extremely heavy to compute. ; This PR aims to push the `left` - `right` choice _inside_ the reconstruction function by realizing that the only difference between left and right reconstruction is how the data is organized in the stencil.; In this way, only one reconstruction is required significantly reducing register pressure, and consequently, computation time.; This follows the same pattern found in [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/4fd8c045fbc493f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658:1048,benchmark,benchmarks,1048,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658,1,['benchmark'],['benchmarks']
Testability,"include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(A",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:21873,test,test,21873,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"ined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_model",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:11861,Test,Test,11861,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"ion is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (540.375 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.642 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization compl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:2832,Test,Testing,2832,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Testing']
Testability,"ion would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:1219,test,test,1219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"is works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come with an API for accessing the data. Right now we have `fields(model)`. We could divide this into two functions: `prognostic_fields(model)` and `diagnostic_fields(model)`, and then also `fields(model)` which combines the two. One decision there is whether to ""flatten"" the lists, or to maintain the hierarchical structure that we currently have in `diffusivity_fields`. . I also think we need an interface for extracting mixing coefficients / diffusivities (rather than requiring that users spelunk into the model properties to find the information they want). We have a prototype with `viscosity` and `diffusivity` functions but it hasn't been used much and isn't really tested. So that would have to be expanded upon as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2422:1873,log,logical,1873,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422,2,"['log', 'test']","['logical', 'tested']"
Testability,"it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169:978,benchmark,benchmarking,978,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169,2,['benchmark'],"['benchmarking', 'benchmarks']"
Testability,"itten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:15835,test,test,15835,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, CenteredSecondOrder, Nothing, Nothing, VerstappenAnisotropicMinimumDissipation{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}},Float64,NamedTuple{(:T, :S),Tup",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1059:1152,test,test,1152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059,1,['test'],['test']
Testability,"jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Me",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:16458,test,test,16458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bn",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:103889,benchmark,benchmark,103889,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:6704,test,test,6704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"k setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of active tracers to buoyancy """"""; 37 function na2buoyancy(n); 38 n == 0 && return nothing; 39 n == 1 && return BuoyancyTracer(); 40 n == 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 16) : (16, 16, 16); 53 na, np = test_case; 54 tracers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:115720,benchmark,benchmarks,115720,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,3,"['benchmark', 'test']","['benchmark', 'benchmarks', 'test']"
Testability,"ker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of active tracers to buoyancy """"""; 37 function na2buoyancy(n); 38 n == 0 && return nothing; 39 n == 1 && return BuoyancyTracer(); 40 n == 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:114901,benchmark,benchmark,114901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"l and we end up with `Nx*Ny` tridiagonal systems, one for each column so they can be solved in parallel. We might be able to speed up the already fast tridiagonal solve via cyclic reduction. For PNN boundary conditions, it should work if we use an FFT in the x and a DCT in the y. So far I have a working 1D solver. The two tricks that had to be made were:; 1. @christophernhill figured out that we need to stop the algorithm once a zero eigenvalue is reached. This should only occur at the last element for our tridiagonal systems.; 2. There are `Nz+1` faces in the vertical but we only keep track of the first `Nz`. The tridiagonal system needs to explicitly account for all `Nz+1` faces. Thus we impose the staggered Neumann boundary conditions at `k=Nz+1` and the (Nz+1)th entry of right-hand-side is zero. (Chris probably told me this but I forgot...) Previously, the DCT did this for us as all the eigenfunctions satisfied the boundary condition anyways. I tested it against our existing solver but it doesn't work for variable dz yet. Not sure if it's because of my implementation of the Laplacian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reduction must be applied recursively `m+1` times for a system of size `Nz = 2^m + 1`. The optimal number of cyclic reductions is `log2(log2(Nz))` so it's possible that we don't gain much. There may also be numerical accuracy issues with taking too many cyclic reduction steps. Some thoughts:; * The batched cyclic reduction solver @maleadt developed only wo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/306:1313,test,tested,1313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306,1,['test'],['tested']
Testability,"l; 131M	Oceananigans-6.jl; ```. I run [a script](https://dev.to/jakecarpenter/shrinking-your-git-repository-with-bfg-repo-cleaner-145e) to find the big files. There are some `.jld2` files in the GitHub repo... and also some `report-....nsys-rep` files.... (@simone-silvestri?). ```; All sizes are in kB's. The pack column is the size of the object, compressed, inside the pack file.; size pack SHA location; 48992 16829 1dd3f4706ebc79549624bee40f78b5aa2c0d644d report-last.sqlite; 48916 16814 839a363a9dd693e35abb48f4822be360ac313a4c report-shared-memory.sqlite; 20694 12212 950954a5d3ef4fac9d6d0480886b95e66d7ec510 report-shufflin.nsys-rep; 20664 12149 283618488234bf4285558c4da6617a6c9583482c report-last.nsys-rep; 20605 12036 1f746e5f46363e656115984a84ddae8003572135 report-shared-memory.nsys-rep; 2465 1984 eeeca1f2b394f43e2547462dc8bbc09d8b2e379d test/deep_convection_golden_master_model_checkpoint_10.jld; 2229 628 f72f4d2641339222c75da6404a1808dd8e4a8952 logger; 1413 1303 7ef3d2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:1569,log,logger,1569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['log'],['logger']
Testability,"l` but in cleaning them up (mostly by relying on the version of Oceananigans in the repository, `using .ConvergenceTests` as a local module, and making sure legends don't block off the plots) I noticed that the 2D convergence tests are all failing now. Pretty sure this must be a stupid mistake as they were all converging correctly as of Oceananigans v0.30.0 but haven't tried to figure out what went wrong yet... Since they're kinda important now I'm thinking we should have a test job that just runs all the convergence tests, tests that the order of convergence is as expected, and produces all the convergence plots so we can look at them. We can do this once we've set up Buildkite somewhere (see also @simonbyrne's https://github.com/CliMA/slurm-buildkite). Also, @glwagner do we still need `analyze_single_forced_fixed_slip.jl` and `analyze_forced_fixed_slip_pressure.jl`? They're not mentioned in the convergence tests `README.md` so maybe we should remove them?. Resolves #873. # Convergence test plots. ![point_exponential_decay_time_stepper_convergence](https://user-images.githubusercontent.com/20099589/91511129-04753d80-e8ad-11ea-95a9-582b79da9dab.png). ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511137-09d28800-e8ad-11ea-9ac5-f978cd49ae5b.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511140-0b9c4b80-e8ad-11ea-84ce-cb418b1971b0.png). ![gaussian_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511147-0dfea580-e8ad-11ea-8c09-9816a687e67e.png). ![gaussian_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511151-0f2fd280-e8ad-11ea-80c4-8b7920da8d64.png). ![two_dimensional_diffusion_convergence](https://user-images.githubusercontent.com/20099589/91511159-122ac300-e8ad-11ea-877e-251defc28879.png). ![taylor_green_convergence](https://user-images.githubusercontent.com/20099589/91511163-12c3598",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/881:1111,test,test,1111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881,1,['test'],['test']
Testability,"lar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR makes a significant contribution to `Oceananigans`' suite of operators: we introduce difference and interpolation operators that act on functions, thereby permitting the *composition* of such operations. The notation for a difference operator denoted by `δ` would be. `δx_caa` or `δx_faa` . where the three letters `caa` denote that differencing is performed at the location ""x cell, any y location, any z location"". The three letter format is an unambiguous specification of the location of a field in three dimensions on a staggered grid. Note that in this PR I have only defined partial derivative operators in this format, rather than difference operators, as we currently only accommodate regular grids. An interpolation operator is denoted by ""blacktriangleright"", so that. `▶x_caa`. den",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234:1790,test,tests,1790,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234,1,['test'],['tests']
Testability,"lation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (540.375 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.642 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ I",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:2893,Test,Testing,2893,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Testing']
Testability,"le-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.46e-01; [ Info: Rank 0: max|ζ|: 7.58e+01, max(e): 2.31e-01; [ Info: ... simulation initialization complete (9.536 seconds); [ Info: Executing initial time step...; [ Info: ... simulation initialization complete (8.565 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (42.937 seconds).; [ Info: ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:2197,log,logger,2197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,2,['log'],"['logger', 'logging']"
Testability,"le=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:117662,test,test,117662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"le_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:7850,Test,Test,7850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"lia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topol",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107357,benchmark,benchmark,107357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"lia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortb",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107936,benchmark,benchmarking,107936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmarking']
Testability,"lia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:10914,test,test,10914,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"lia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:8810,test,test,8810,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"licate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Metho",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:22500,test,test,22500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:111276,benchmark,benchmark,111276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"ll time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:104317,benchmark,benchmarks,104317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmarks']
Testability,"lver.storage)); arch = architecture(solver); grid = solver.local_grid. launch!(arch, grid, :xyz, calculate_permuted_pressure_source_term_fft_based_solver_rapid!,; rhs, grid, Δt, U★, solver.input_permutation,). # Solve pressure Poisson equation for pressure, given rhs; solve!(pressure, solver). return pressure; end; ```. I tried to run it on CPU (Oceananigans v0.84.1 & Julia v1.8.4) like (A simple case of Langmuir turbulence case in a shallow water):. ```julia; using Oceananigans; using Printf; using Oceananigans.Units. # Grid; const H = 30; grid = RectilinearGrid(GPU();; size = (100, 100, 48),; halo = (3, 3, 3),; x = (0, 2π*H),; y = (0, 2π*H),; z = (-H, 0)); # Buoyancy; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=2e-4, haline_contraction=8e-4)). # Surface boundary conditions; u₁₀ = 10 ; cᴰ = 1.25e-3 ; ρₐ = 1.225 ; ρₒ = 1026.0 ; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) . # Bottom boundary conditions; z₀ = 0.01; κ = 0.4 ; z₁ = grid.Δzᵃᵃᶠ/2 ; cᴰ = (κ / log(z₁ / z₀))^2 . @inline drag_u(x, y, t, u, v, p) = - p.cᴰ * √(u^2 + v^2) * u; @inline drag_v(x, y, t, u, v, p) = - p.cᴰ * √(u^2 + v^2) * v. drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰ)); drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰ)). u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom = drag_bc_u); v_bcs = FieldBoundaryConditions(bottom = drag_bc_v). # Coriolis; f₀ = 1e-4; coriolis = FPlane(f=f₀). # Background current ; U∞ = 0.25 # m s⁻¹. # Stokes drift; using Oceananigans.BuoyancyModels: g_Earth. const amplitude = 0.8 ; const wavelength = 60 ; const wavenumber = 2π / wavelength ; const frequency = sqrt(g_Earth * wavenumber * tanh(wavenumber * H)) . ## Stokes drift velocity at the surface; const Uˢ = amplitude^2 * wavenumber * frequency # m s⁻¹ # 0.0676 . # The vertical derivative of the Stokes drift is; ∂z_uˢ(z, t) = Uˢ * wavenumber * sinh(2 * wavenumber * (z + H)) / (sinh(wa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3459:6202,log,log,6202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459,1,['log'],['log']
Testability,"ly it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 175.995 ms (281950 allocations: 91.17 MiB); ```. The discrepencies are more extreme for larger models as noted on #1919. I think we should also do GPU benchmarks. @hennyg888 if you have anything to add please feel free...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1923:1335,Benchmark,Benchmarking,1335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923,6,"['Benchmark', 'benchmark']","['Benchmarking', 'benchmark', 'benchmarks']"
Testability,"m the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner scales with `n²` so it might be very expensive if very large grid sizes want to be empoloyed (I have tested it up to `512 x 256` grid and still it was ok, but anyways, I will provide some benchmarking below). This matrix based solver is used in the free surface `MatrixImplicitFreeSurface` to solve implicitly for the free surface. The validation of the method has been included in tests `test_matrix_poisson_solver.jl`, `test_hydrostatic_free_surface_models.jl`, `test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl` and `test_implicit_free_surface_solvers.jl` . Benchmarks in `benchmark_hydrostatic_model.jl` (grid size of `256 x 128`) show how the method compares with other free-surfaces methods, the preconditioner settings used where; - `τ = 0.001` for the `CPU()` preconditioner; - `ε = 0.1` and `nzrel = 1.0` for the `GPU()` preconditioner. ```. ┌───────────────┬───────────────────────┬───────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼───────────────────────┼───────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 4.866 ms │ 5.112 ms │ 5.161 ms │ 6.002",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:3328,test,tests,3328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,1,['test'],['tests']
Testability,"m=(false, true, false)`, the matrix will be filled with `Ax[i, 1, k], Az[i, 1, k], C[i, 1, k]` and `D[i, 1, k]`) ; - `settings` which include `maximum_iterations`, `tolerance`, `precondition` (`false` or `true`). The preconditioner employed on the CPU is the (always perfect) ILU factorization (from the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner scales with `n²` so it might be very expensive if very large grid sizes want to be empoloyed (I have tested it up to `512 x 256` grid and still it was ok, but anyways, I will provide some benchmarking below). This matrix based solver is used in the free surface `MatrixImplicitFreeSurface` to solve implicitly for the free surface. The validation of the method has been included in tests `test_matrix_poisson_solver.jl`, `test_hydrostatic_free_surface_models.jl`, `test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl` and `test_implicit_free_surface_solvers.jl` . Benchmarks in `benchmark_hydrostatic_model.jl` (grid size of `256 x 128`) show how the method compares with other free-surfaces methods, the preconditioner settings used where; - `τ = 0.001` for the `CPU()` preconditioner; - `ε = 0.1` and `nzrel = 1.0` for the `GPU()` preconditioner. ```. ┌───────────────┬───────────────────────┬───────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:3047,test,tested,3047,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,2,"['benchmark', 'test']","['benchmarking', 'tested']"
Testability,"mark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 14.2 ms Histogram: frequency by time 14.4 ms <. Memory estimate: 47.78 KiB, allocs estimate: 320. ```. The counterpart using the new branch `julia --project=""environments/one_sided_branch"" --check-bounds=no`; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true; BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 16.463 ms … 18.503 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 16.466 ms ┊ GC (median): 0.00%; Time (mean ± σ): 16.878 ms ± 908.449 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▆ ▁; 16.5 ms Histogram: frequency by time 18.5 ms <. Memory estimate: 250.06 KiB, allocs estimate: 676. julia> trial1 = run_model_benchmark!(tracer_kernel_test, arch;; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 6.695 ms … 7.461 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 6.789 ms ┊ GC (median): 0.00%; Time (mean ± σ): 6.908 ms ± 312.944 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █ ██ █ █; █▁▁▁▁▁██▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 6.69 ms Histogram: frequency by time 7.46 ms <. Memory estimate: 46.39 KiB, allocs estimate: 231. ```. P.S. some vestigial code not used is being removed as part of this PR because not beneficial (in terms of both accuracy and performance) that is; - the JS weno formulation (dominated by the Z-weno formulation); - Velocity Upwinding for the vector invariant weno formulation (dominated by the other two formulations)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658:3215,Benchmark,BenchmarkTools,3215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658,1,['Benchmark'],['BenchmarkTools']
Testability,"mark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:114078,benchmark,benchmark,114078,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"mble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mode",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:5746,Test,Test,5746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"mble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:9954,Test,Test,9954,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"me-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl#L217. and by `NetCDFOutputWriter` (though a bit differently since it gives a timing for each output):. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:1251,Benchmark,Benchmarking,1251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,1,['Benchmark'],['Benchmarking']
Testability,"medTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:37758,test,test,37758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"meterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float32}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); FPlane{Float64}(f=0.000103126); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float64}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float64}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); Test Summary: | Pass Total Time; Oceananigans | 90 90 1.8s; Testing Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:23624,test,test,23624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/177:1251,test,test,1251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177,1,['test'],['test']
Testability,"ms │ 4.81 MiB │ 200327 │ 10 │; │ GPU │ Float64 │16384 │ 552.752 ms │ 552.786 ms │ 552.883 ms │ 553.533 ms │14.14 MiB │ 811831 │ 10 ; └───────────────┴─────────────┴──────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘. Shallow water model CPU to GPU speedup; ┌─────────────┬──────┬──────────┬─────────┬─────────┐; │ Float_types │ Ns │ speedup │ memory │ allocs │; ├─────────────┼──────┼──────────┼─────────┼─────────┤; │ Float64 │ 32 │ 0.635088 │ 1.34893 │ 2.54017 │; │ Float64 │ 64 │ 0.984322 │ 1.3489 │ 2.53792 │; │ Float64 │ 128 │ 2.2418 │ 1.3489 │ 2.53792 │; │ Float64 │ 256 │ 7.04691 │ 1.3489 │ 2.53792 │; │ Float64 │ 512 │ 27.1702 │ 1.34893 │ 2.50842 │; │ Float64 │ 1024 │ 110.972 │ 1.34931 │ 2.52311 │; │ Float64 │ 2048 │ 178.096 │ 1.43913 │ 5.98747 │; │ Float64 │ 4096 │ 185.419 │ 1.83529 │ 21.2678 │; │ Float64 │ 8192 │ 189.573 │ 3.52748 │ 86.6092 │; │ Float64 │16384 │ 193.026 │ 10.376 │ 350.986 │; └─────────────┴──────┴──────────┴─────────┴─────────┘; ```; Benchmarkable incompressible model:; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:4468,Benchmark,Benchmarkable,4468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['Benchmark'],['Benchmarkable']
Testability,"n the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:1756,Test,Test,1756,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['Test'],['Test']
Testability,"nGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [7] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [8] read(::JLD.JldFile, ::String) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:346; [9] restore_from_checkpoint(::String) at /home/alir/Oceananigans.jl/src/output_writers.jl:94; [10] run_thermal_bubble_checkpointer_tests() at /home/alir/Oceananigans.jl/test/test_output_writers.jl:34; [11] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:295; [12] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [13] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:294; [14] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [15] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:290; [16] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [17] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:14; [18] include(::String) at ./client.jl:403; [19] top-level scope at none:0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/177:2736,test,test,2736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177,11,"['Test', 'test']","['Test', 'test']"
Testability,n_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/regression_tests/data/rayleigh_benard_iteration1100.jld2; ```. I can use [BFG repo-cleaner](https://rtyley.github.io/bfg-repo-cleaner/) to remo,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:3021,test,test,3021,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['test'],['test']
Testability,n_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/regression_tests/data/rayleigh_benard_iteration1100.jld2; ```. I can use [BFG repo-cleaner](https://rtyley.github.io/bfg-repo-cleaner/) to remove those files from the git history of the repo. But **NOTE that everyone would have to delete their local clones after that and reclone**. Otherwise you',MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:3163,test,test,3163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['test'],['test']
Testability,"n` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, CenteredSecondOrder, Nothing, Nothing, VerstappenAnisotropicMinimumDissipation{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}},Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}, NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1059:1179,Test,Test,1179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059,1,['Test'],['Test']
Testability,"nanigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLV",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:37520,test,test,37520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"nclude`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Ma",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:17127,test,test,17127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"ndaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 175.995 ms (281950 allocations: 91.17 MiB); ```. The discrepencies are more extreme for larger models as ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1923:1173,Benchmark,Benchmarking,1173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923,1,['Benchmark'],['Benchmarking']
Testability,"nditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditioner is faster (benchmarks below). ; * Both the ""matrix"" and ""non-matrix"" solvers use conjugate gradient iteration --- the difference is in how they compute the left-hand-side (ie the linear left-side operator above, and the preconditioners that are supported). ## Benchmarks. Note that ""PCGImplicitFreeSurface"" below means ""PCGImplicitFreeSurface with FFT based preconditioner"". These benchmarks have a problem size 256 x 128 x 1. ### CPU; ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 6.635 ms │ 7.733 ms │ 13.564 ms │ 33.224 ms │ 3.07 MiB │ 5626 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 9.578 ms │ 11.644 ms │ 11.541 ms │ 13.400 ms │ 4.55 MiB │ 8023 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 13.193 ms │ 14.087 ms │ 14.329 ms │ 17.618 ms │ 5.34 MiB │ 9656 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 20.311 ms │ 21.363 ms │ 23.938 ms │ 36.792 ms │ 5.19 MiB │ 8279 │ 10 │; │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:2796,benchmark,benchmarks,2796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['benchmark'],['benchmarks']
Testability,"nditions wherever a submodel shares a halo with another rank. This is then dispatched on so no need to modify existing code.; 6. With PR #589 we will be able to easily slide in a `DistributedPressureSolver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, but this is definitely not performant. @vchuravy suggested that we may be able to send and receive into strided buffers, so will look into this. cc @simonbyrne maybe you know more about this?. Quality of life features we may want in the future (which might effect design choices):; * Distributed diagnostics: these will be pretty expensive no matter how we implement them due to the extra reduction step (`MPI.Gather`) required across all ranks. I wonder if it's even worth thinking about them much. If we really need things like a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590:1958,test,testing,1958,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590,1,['test'],['testing']
Testability,"nds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing Coriolis ensemble member (1, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_model",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:5543,Test,Test,5543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"ne (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:18174,test,test,18174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"ne Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:104359,benchmark,benchmarking,104359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmarking']
Testability,"ng Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², v)); @inline u_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.u[i, j, k] * speedᶠᶜᶜ(i, j, k, grid, f.u, f.v, f.w); @inline v_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.v[i, j, k] * speedᶜᶠᶜ(i, j, k, grid, f.u, f.v, f.w); @inline w_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.w[i, j, k] * speedᶜᶜᶠ(i, j, k, grid, f.u, f.v, f.w). ϰ = 0.4 # ""Von Karman"" constant; ℓ = 1e-4 # simply an estimated roughness length; d = minimum_xspacing(grid) / 2 # assuming an isotropic grid, using half cell-width as ""distance to the wall""; cᴰ = (ϰ / log(d / ℓ))^2. u_drag_bc = FluxBoundaryCondition(u_drag, discrete_form=true, parameters=cᴰ); v_drag_bc = FluxBoundaryCondition(v_drag, discrete_form=true, parameters=cᴰ); w_drag_bc = FluxBoundaryCondition(w_drag, discrete_form=true, parameters=cᴰ); ```. Note, this only really makes sense on an isotropic grid and I think to strictly treat anisotropic grids we need to manually construct `ImmersedBoundaryCondition`. Even with the simplifications we've made, it's still a lot of code that has to be repeated every time somebody wants to implemented a drag law on an immersed boundary. So we could easily motivate implementing an abstraction `drag_boundary_conditions` that returns the bcs for `u, v, w`, eg:. ```julia; u_drag_bc, v_drag_bc, w_drag_bc = drag_boundary_conditions(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe om",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:3762,log,log,3762,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['log'],['log']
Testability,"nitially (stably) linearly stratified . All the boundary conditions are default, and the only other IC modification is to add a zero-mean small-scale noise (1e-6 m/s) to `u`. I'd expect this to remain quasi-quiescent. Instead, this is what I get:. https://user-images.githubusercontent.com/13205162/220440495-ab5466f3-5ad9-4c68-81c2-5ada1b422318.mp4. The code to plot the animation can be found [here](https://pastebin.com/ZB41VFPE). The same thing happens when `b=0` initially and the linear stratification is instead included as a `BackgroundVelocity`. For example, if I remove the drag boundary condition from the [tilted bottom boundary layer example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/#) and add the same zero-mean noise, the same issue happens:. https://user-images.githubusercontent.com/13205162/220441379-9f8c83ce-2414-45e1-960e-1758dee6fe65.mp4. [Here's the code for the example above.](https://pastebin.com/DUbgqtF5). I understand that hydrostatic balance in a mathematical sense doesn't exactly translate directly to a discrete system (since the forces might not exactly cancel due to the discretization, interpolation, etc.), but I also don't expect deviations from it that are this large and keep amplifying. In fact, what led me here was some pretty strange behavior that I'm experiencing in one of my simulations where internal waves seem to appear out of nowhere, so I believe this is relevant. Am I missing something here? Or is this a bug?. An important note is that we used to have a test that spun up a simulation much like the one above, ran it for a few hours, and made sure that there wasn't any movement. That test used to pass but was remove because it was too computationally-expensive. So I think this issue might have been introduced relatively recently. EDIT:. Note that this happens even when the added noise is (on average) well below the machine epsilon (for example for `noise(x, y, z) = 1e-18 * rand()`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935:2811,test,test,2811,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935,2,['test'],['test']
Testability,"ns. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scratch_cheyenne$ cd julia_test/; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ touch Project.toml; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (p39) toma",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625:1230,test,tests,1230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625,1,['test'],['tests']
Testability,"ns/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:114358,benchmark,benchmark,114358,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"ns::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:102401,test,test,102401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"nsBase.jl, OceananigansIncompressible.jl, OceananigansCompressible.jl, and Oceananigans.jl. I'm not sure which modules would go where but the idea is that users will only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large mode",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:6357,Test,Tests,6357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['Test'],['Tests']
Testability,"ntf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators |",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:117349,Test,Test,117349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"oat64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); │ @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/i1inK/src/Fields/field.jl:606; │ [26] top-level scope; │ @ logging.jl:340; │ [27] include(mod::Module, _path::String); │ @ Base ./Base.jl:386; │ [28] exec_options(opts::Base.JLOptions); │ @ Base ./client.jl:285; │ [29] _start(); │ @ Base ./client.jl:485; └ @ Main /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; ```. Has someone encountered this behavior before? Is someone able to reproduce it? Downgrading CUDA to 3.9 solves this issue for me, which indicates that this might be a CUDA bug, but I can't reproduce it using only CUDA tools so it's hard for me to open an issue there. @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:19336,log,logging,19336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['log'],['logging']
Testability,"od definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:17355,test,test,17355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"odel.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mode",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:12064,Test,Test,12064,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"odels that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl#L217. and by `NetCDFOutputWriter` (though a bit differently since it gives a timing for each output):. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/netcdf_output_writer.jl#L459-L463. so we may not actually have to provide tools for benchmarking those. The `NetCDFOutputWriter` message is wrong in general because output is not always ""computed"" --- we should fix that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:1705,benchmark,benchmark,1705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,2,['benchmark'],"['benchmark', 'benchmarking']"
Testability,"olver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditione",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:1446,benchmark,benchmarking,1446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['benchmark'],['benchmarking']
Testability,"olver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, but this is definitely not performant. @vchuravy suggested that we may be able to send and receive into strided buffers, so will look into this. cc @simonbyrne maybe you know more about this?. Quality of life features we may want in the future (which might effect design choices):; * Distributed diagnostics: these will be pretty expensive no matter how we implement them due to the extra reduction step (`MPI.Gather`) required across all ranks. I wonder if it's even worth thinking about them much. If we really need things like a `DistributedHorizontalAverage` then we can look into that.; * Distributed output writers: I wonder if we should add e.g. a distributed NetCDF output writer or if each rank just writes out its own outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590:2241,test,tests,2241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590,1,['test'],['tests']
Testability,"omplex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Dict{String,Field{X,Y,Z,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X}; filename::String, iteration_interval::Int64, time_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:101811,test,test,101811,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"on't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:6704,test,tests,6704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['test'],['tests']
Testability,"on.StaticSize{(1, 1)}, Nothing, Nothing}}, NTuple{4, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Gradient, Float64}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Tuple{Tuple{Face, Center, Center}, Tuple{Center, Face, Center}, Tuple{Center, Center, Face}, Tuple{Center, Center, Center}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w, :b), NTuple{4, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to _fill_bottom_halo!(i, j, grid, c, bc::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryConditions.Gradient}}, loc, args...) in Oceananigans.BoundaryConditions at /home/greg/.julia/packages/Oceananigans/W63bs/src/BoundaryConditions/fill_halo_regions_value_gradient.jl:73); ```. probably affects `ValueBoundaryCondition` too. We should probably have regression tests for these boundary conditions, as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2709:2832,test,tests,2832,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2709,1,['test'],['tests']
Testability,"only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:6575,test,tests,6575,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['test'],['tests']
Testability,"op-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:111742,Benchmark,Benchmark,111742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,"['Benchmark', 'benchmark']","['Benchmark', 'benchmarking']"
Testability,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:3529,test,tests,3529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['test'],['tests']
Testability,"ope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:6770,Test,Testing,6770,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Testing']
Testability,"orcing` on the GPU. For example:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, CenteredSecondOrder, No",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1059:1004,Test,Testing,1004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059,1,['Test'],['Testing']
Testability,"otentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2027,test,testing,2027,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['test'],['testing']
Testability,"p-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, gri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:103827,benchmark,benchmark,103827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"pe at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:103703,benchmark,benchmark,103703,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"ping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (795.416 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.083 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (842.167 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.379 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.602 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing Coriolis ensemble member (1, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro exp",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:4668,Test,Testing,4668,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Testing']
Testability,"ple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryCondit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:77002,test,test,77002,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"ple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Ba",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:37651,Test,Test,37651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"pt(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to bench",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:111051,benchmark,benchmark,111051,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"put unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/pii/S1463500314001796) (Petersen et al 2015); * [GVC in a nonhydrostatic compressible atmospheric model ENDgame](https://rmets.onlinelibrary.wiley.com/doi/full/10.1002/qj.3368) (Kavcic and Thuburn, 2018); * [Correct calculation of pressure gradients in a finite volume model](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=vsSBQiBsJugAAAAA:GHaDu6afxrLQ4NIdCDiGWl47xClDdYRdM-CSFlZ8kGxQMAOov7vSHAKp_Ch5hQ9OsousvG8sCg) (Adcroft et al 2008); [An “adaptive”, semi-Lagrangian GVC](https://www.sciencedirect.com/science/article/pii/S1463500302000604) (Burchard and Beckers 2004) See also a [3D description](https://www.sciencedirect.com/science/article/pii/S1463500309002248?casa_token=l2d7ijIAiN8AAAAA:kVzMMRqaP2d6U0QDaqB1vqfWKHjIpGWZr0EovdkMJtxHxGSb_xEQ8SlG3OtYkb2mz-6ggmGwGA) (Hofmeister et al 2010) and [realistic test case](https://www.sciencedirect.com/science/article/pii/S1463500311000801?casa_token=CkEoHLOnIxMAAAAA:QWjy9Ck26XOhdWf5K-IaJghogprZ06FDTuCZeORuBO69lWLcRYiWkz4uFtoXRLbfTATnuk932w) (Hofmeister et al 2011); [“z star” GVC in MITgcm](https://www.sciencedirect.com/science/article/pii/S1463500303000544) (Adcroft and Campin 2004)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:5020,test,test,5020,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['test'],['test']
Testability,"r duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:17970,test,test,17970,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"r the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scratch_cheyenne$ cd julia_test/; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ touch Project.toml; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ ~/Downloads/julia-1.5.4/bin/julia --project; _",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625:1329,test,tests,1329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625,1,['test'],['tests']
Testability,"r/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:108130,Benchmark,Benchmark,108130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Benchmark'],['Benchmark']
Testability,"racers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estim",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:117011,test,test,117011,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"rchitecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 modul",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:113512,Test,Test,113512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"re=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:117132,Test,Test,117132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,required to force the model with a field time series.; This PR adds `update_model_field_time_series!` to the `update_state!` for single column grids and a test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3756:155,test,test,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3756,1,['test'],['test']
Testability,"rgs...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492. ┌ Info: benchmark for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 0.016049044, ; │ WENO5S uniform setting : 0.015951728, ; └ WENO5 (only uniform) : 0.015978376; ┌ Info: benchmark for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 0.016095937, ; │ WENO5S uniform setting : 0.015944528, ; └ WENO5 (only uniform) : 0.015961198; ┌ Info: benchmark for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 0.005800518, ; │ WENO5S uniform setting : 0.005535015, ; └ WENO5 (only uniform) : 0.006188944; ┌ Info: benchmark for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 0.005982374, ; │ WENO5S uniform setting : 0.005827935, ; └ WENO5 (only uniform) : 0.006182819. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2059:2135,benchmark,benchmark,2135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059,4,['benchmark'],['benchmark']
Testability,"rk: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:112120,Benchmark,Benchmark,112120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Benchmark'],['Benchmark']
Testability,"rm algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Array{Int64,1}:; 1; 5; 2; 4; 3. julia> [unpermute(i, N) for i in L]; 5-element Array{Int64,1}:; 1; 2; 3; 4; 6; ```. # Fix. ```julia; julia> unpermute(i, N) = i <= ceil(N/2) ? 2i-1 : 2(N-i+1); unpermute (g",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1228:1191,test,test,1191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228,2,['test'],"['test', 'tested']"
Testability,"rostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/st",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:6631,Test,Test,6631,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"rue,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancell",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:37889,Test,Test,37889,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:19371,test,test,19371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"ry roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.o",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2651,test,test,2651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['test'],['test']
Testability,"s than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +). BenchmarkTools.Trial: ; memory estimate: 2.88 KiB; allocs estimate: 64; --------------; minimum time: 39.129 ms (0.00% GC); median time: 39.245 ms (0.00% GC); mean time: 39.248 ms (0.00% GC); maximum time: 39.374 ms (0.00% GC); --------------; samples: 128; evals/sample: 1; ```. Probably optimal performance:; ```julia; @benchmark CuArrays.@sync mean(a, dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 8.56 KiB; allocs estimate: 220; --------------; minimum time: 7.426 ms (0.00% GC); median time: 7.526 ms (0.00% GC); mean time: 7.527 ms (0.00% GC); maximum time: 8.817 ms (0.00% GC); --------------; samples: 663; evals/sample: 1; ```. Resolves #186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352:2057,benchmark,benchmark,2057,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352,4,"['Benchmark', 'benchmark']","['BenchmarkTools', 'benchmark']"
Testability,"s these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:112838,benchmark,benchmark,112838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,4,"['Test', 'benchmark']","['Test', 'benchmark', 'benchmarks']"
Testability,"s │ 39.898 ms │ 40.168 ms │ 42.705 ms │ 2.67 MiB │ 2185 │ 10 │; │ GPU │ LatitudeLongitudeGrid │ ExplicitFreeSurface │ 2.183 ms │ 2.413 ms │ 2.607 ms │ 4.697 ms │ 2.79 MiB │ 4336 │ 10 │; │ GPU │ LatitudeLongitudeGrid │ ImplicitFreeSurface │ 210.184 ms │ 222.141 ms │ 245.991 ms │ 324.810 ms │ 124.16 MiB │ 463523 │ 10 │; │ GPU │ LatitudeLongitudeGrid │ MatrixImplicitFreeSurface │ 24.591 ms │ 24.738 ms │ 25.103 ms │ 28.283 ms │ 4.93 MiB │ 31007 │ 10 │; └───────────────┴───────────────────────┴───────────────────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘. ```. The price you have to pay for the initialization of a GPU preconditioner is shown below in terms of `N` (where the grid is `N²`), `ε` and `nzrel` . These are outputs of `benchamarks/benchmark_spai_preconditioner.jl`. ```; SPAI preconditioner benchmarks; ┌─────┬─────┬───────┬────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬─────────┐; │ N │ ε │ nzrel │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├─────┼─────┼───────┼────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼─────────┤; │ 64 │ 0.1 │ 0.5 │ 1.733 s │ 1.873 s │ 1.884 s │ 2.046 s │ 1.73 GiB │ 8969362 │ 3 │; │ 64 │ 0.3 │ 0.5 │ 1.559 s │ 1.779 s │ 1.722 s │ 1.828 s │ 1.73 GiB │ 8969362 │ 3 │; │ 64 │ 0.6 │ 0.5 │ 411.863 ms │ 430.678 ms │ 425.296 ms │ 433.009 ms │ 478.89 MiB │ 1296680 │ 5 │; │ 64 │ 0.1 │ 2.0 │ 4.711 s │ 4.748 s │ 4.748 s │ 4.786 s │ 5.20 GiB │ 40335010 │ 2 │; │ 64 │ 0.3 │ 2.0 │ 1.326 s │ 1.341 s │ 1.344 s │ 1.368 s │ 1.73 GiB │ 8969362 │ 4 │; │ 64 │ 0.6 │ 2.0 │ 388.265 ms │ 414.406 ms │ 413.665 ms │ 449.928 ms │ 478.89 MiB │ 1296680 │ 5 │; │ 64 │ 0.1 │ 1.0 │ 1.328 s │ 1.354 s │ 1.356 s │ 1.387 s │ 1.73 GiB │ 8969362 │ 4 │; │ 64 │ 0.3 │ 1.0 │ 1.283 s │ 1.290 s │ 1.310 s │ 1.376 s │ 1.73 GiB │ 8969362 │ 4 │; │ 64 │ 0.6 │ 1.0 │ 387.341 ms │ 389.817 ms │ 395.236 ms │ 411.333 ms │ 478.89 MiB │ 1296680 │ 5 │; │ 128 │ 0.1 │ 0.5 │ 13.551 s │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:6386,benchmark,benchmarks,6386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,1,['benchmark'],['benchmarks']
Testability,"s │ 67.009 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 2 │ 4.085 μs │ 4.135 μs │ 4.723 μs │ 8.088 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 2 │ 564.769 μs │ 579.278 μs │ 615.731 μs │ 804.859 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 2 │ 110.718 ms │ 111.560 ms │ 111.506 ms │ 112.525 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 3 │ 7.772 μs │ 7.787 μs │ 9.499 μs │ 24.886 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 3 │ 684.541 μs │ 688.275 μs │ 811.874 μs │ 1.463 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ 3 │ 93.902 ms │ 94.489 ms │ 94.604 ms │ 95.639 ms │ 0 bytes │ 0 │; └───────────────┴─────┴───────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘. 3D FFT --> 3 × 1D FFTs slowdown:; CPU, 16: 1.0807x; CPU, 64: 1.0053x; CPU, 256: 1.1567x; ```. # To batch or not to batch for CUFFT on GPUs?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ (1, 2, 3) │ 25.478 μs │ 32.459 μs │ 122.062 μs │ 703.376 μs │ 224 bytes │ 13 │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:4171,Benchmark,Benchmark,4171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['Benchmark'],['Benchmark']
Testability,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389:1902,test,tests,1902,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389,1,['test'],['tests']
Testability,"s/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110979,benchmark,benchmark,110979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"s?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ (1, 2, 3) │ 25.478 μs │ 32.459 μs │ 122.062 μs │ 703.376 μs │ 224 bytes │ 13 │; │ GPU │ 64 │ (1, 2, 3) │ 67.226 μs │ 71.497 μs │ 146.042 μs │ 647.734 μs │ 224 bytes │ 13 │; │ GPU │ 256 │ (1, 2, 3) │ 2.982 ms │ 3.041 ms │ 3.036 ms │ 3.116 ms │ 224 bytes │ 13 │; │ GPU │ 16 │ 1 │ 14.755 μs │ 30.020 μs │ 107.932 μs │ 677.045 μs │ 96 bytes │ 5 │; │ GPU │ 64 │ 1 │ 26.521 μs │ 41.294 μs │ 114.587 μs │ 674.834 μs │ 96 bytes │ 5 │; │ GPU │ 256 │ 1 │ 930.371 μs │ 936.222 μs │ 954.771 μs │ 1.060 ms │ 96 bytes │ 5 │; │ GPU │ 16 │ 2 │ 26.547 μs │ 49.440 μs │ 127.426 μs │ 768.771 μs │ 1.41 KiB │ 59 │; │ GPU │ 64 │ 2 │ 116.160 μs │ 117.772 μs │ 193.909 μs │ 797.293 μs │ 1.41 KiB │ 59 │; │ GPU │ 256 │ 2 │ 4.963 ms │ 5.010 ms │ 5.014 ms │ 5.073 ms │ 1.41 KiB │ 59 │; │ GPU │ 16 │ 3 │ 14.918 μs │ 22.509 μs │ 40.029 μs │ 110.119 μs │ 224 bytes │ 13 │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:4784,benchmark,benchmarks,4784,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['benchmark'],['benchmarks']
Testability,"s?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/177:1166,Test,Test,1166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177,1,['Test'],['Test']
Testability,"se.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{FFTW.r2rFFTWPlan{ComplexF64, Vector{Int32}, true, 3, Vector{Int64}}, Oceananigans.Solvers.Backward, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Int64, Bounded, Float64, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, Nothing, Nothing, Nothing, NamedTuple{(), Tuple{}}}, Δt::Int64; callbacks::Vector{Any}, euler::Bool); @ Oceananigans.TimeSteppers ~/Documents/Projects/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:91; </details>. In this example, you could achieve it by just using a normal array forcing, but there are more complicated cases where I would find this useful. I would like to do this for boundary conditions too but removing the `Forcing` from here:https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/BoundaryConditions/boundary_condition.jl#L52. and changing ; https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/BoundaryConditions/boundary_condition.jl#L20. to dispatch on numbers or arrays does not work and loads of the tests fail.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3237:53098,test,tests,53098,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237,1,['test'],['tests']
Testability,"seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to be a topology because otherwise, users have to manually specify boundary conditions on everything? Then we can automatically set `OpenBoundaryCondition(nothing)` unless a user sets something else.; - Should we have an automatic way to setup a sponge layer?; - Do we think it is correct not to add a term to the pressure for time-varying inflow? I think we do not (see below). <details>; <summary>How I understand the maths:</summary>; Starting from the momentum equation:. $\partial_t\vec u = \vec{G_u} - \nabla P$. We split the time step by defining:. $\vec u^\star - \vec u^n = \int_{t_n}^{t_{n+1}}\vec{G_u}dt$. so. $\vec u^{n+1} - \vec u^\star = -\int_{t_n}^{t_{n+1}}\nabla P_{non}dt \approx -\Delta t\nabla P_{non}$. we take the divergence of this (and requiring $\nabla \cdot \vec u^{n+1}$) to give:. $\nabla^2P_{non} = \frac{\nabla \cdot \vec u^\star}{\Delta t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:1864,test,test,1864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['test'],['test']
Testability,"sercontent.com/render/math?math=Ax_{i%2B 1jk} \eta_{i%2B 1jk} %2B Ax_{ijk} \eta_{i-1jk} %2B Ay_{ij%2B 1k} \eta_{ij%2B 1k} %2B Ay_{ijk} \eta_{ij-1k} %2B Az_{ijk%2B 1} \eta_{ijk%2B 1} %2B Az_{ijk} \eta_{ijk-1} - 2 (Ax_{i%2B 1jk} %2B Ax_{ijk} %2B Ay_{ij%2B 1k} %2B Ay_{ijk} %2B Az_{ijk%2B 1} %2B Az_{ijk} ) \eta_{ijk} %2B ( C_{ijk} %2B D_{ijk} /\Delta t^2 ) \eta_{ijk} = b_{ijk}""> . the coefficients are specified as 3D arrays (also fields should be good). To solve for a `Center, Center, Center` value, `Ax` should be on `Face, Center, Center`, `Ay` should be on `Center, Face, Center`, `Az` on `Center, Center, Face` and `C` and `D` on `Center, Center, Center`. . `b` (the rhs) is specified as a 1D `Array` (or `CuArray` on GPUs). Example: coefficients to solve a Poisson equation of the form <img src=""https://render.githubusercontent.com/render/math?math=\nabla^2 \eta = b""> in a finite volume framework <img src=""https://render.githubusercontent.com/render/math?math=\sum_k A_k \nabla \eta = b \cdot V""> are shown in `test/test_matrix_poisson_solver.jl`. to construct the type, a part from the coefficients it is possible to specify; - the type of `iterative_solver` desired (`cg` is the default) ; - `reduced_dim::Tuple(Bool, Bool, Bool)` to have a lower-dimensional solve (a reduced dimension will mean that the matrix will be filled with the coefficients of index 1 in that direction, as an example, if `reduced_dim=(false, true, false)`, the matrix will be filled with `Ax[i, 1, k], Az[i, 1, k], C[i, 1, k]` and `D[i, 1, k]`) ; - `settings` which include `maximum_iterations`, `tolerance`, `precondition` (`false` or `true`). The preconditioner employed on the CPU is the (always perfect) ILU factorization (from the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:1622,test,test,1622,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,1,['test'],['test']
Testability,"spired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780:988,Benchmark,Benchmarking,988,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780,1,['Benchmark'],['Benchmarking']
Testability,"src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _sta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:2463,test,test,2463,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,1,['test'],['test']
Testability,"st.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of active tracers to buoyancy """"""; 37 function na2buoyancy(n); 38 n == 0 && return nothing; 39 n == 1 && return BuoyancyTracer(); 40 n == 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:114953,Benchmark,Benchmark,114953,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Benchmark'],['Benchmark']
Testability,st/deep_convection_golden_master_model_checkpoint_10.jld; 2229 628 f72f4d2641339222c75da6404a1808dd8e4a8952 logger; 1413 1303 7ef3d2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfd,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:2461,test,test,2461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['test'],['test']
Testability,"st/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:114148,benchmark,benchmark,114148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"st/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:18962,test,test,18962,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"staticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:5999,test,test,5999,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"staticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:10207,test,test,10207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"static_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:10841,Test,Test,10841,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"static_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:8737,Test,Test,8737,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"stop iteration 100.; [ Info: Testing Coriolis ensemble member (1, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:5615,test,test,5615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"sts. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:1363,test,test,1363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,t/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 937939cc1ef2 990KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 841a7461932f 1.0MiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 061ab36b8d44 1.3MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 2f48fac8a7f5 1.4MiB paper/free_convection_and_baroclinic_instability.png; 7ef3d2c84f36 1.4MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:3935,test,test,3935,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,5,['test'],['test']
Testability,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:118249,Test,Test,118249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,8,"['Test', 'benchmark']","['Test', 'benchmark', 'benchmarks']"
Testability,"t32,3,Array{Float32,3}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/constant_smagorinsky.jl:88; [14] ▶y_afa(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::ConstantSmagorinsky{Float32}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:204; [15] κ_∂y_ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Function, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:482; [16] ∂y_aca(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:114; [17] ∇_κ_∇ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:506; [18] test_smag_divflux_finiteness(::Type) at /home/alir/Oceananigans.jl/test/test_turbulence_closures.jl:173; [19] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:466; [20] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [21] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:464; [22] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [23] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:427; [24] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [25] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:20; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/260:3746,test,test,3746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260,11,"['Test', 'test']","['Test', 'test']"
Testability,"t64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110439,test,test,110439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"t_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:111414,benchmark,benchmark,111414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"t_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:111206,benchmark,benchmark,111206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"t_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 act",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:113391,test,test,113391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,ta/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fd,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:3158,test,test,3158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"tby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(timer[bn32]); 56 t64 = TimerOutputs.time(timer[bn64]); 57 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:109949,benchmark,benchmark,109949,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,"['Test', 'benchmark']","['Test', 'benchmark']"
Testability,"te calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:22941,test,test,22941,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/974:0,test,test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/974,1,['test'],['test']
Testability,test Oceananigans returns CUDA error depsite being able to run examples on CPU and GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/788:0,test,test,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788,1,['test'],['test']
Testability,test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 937939cc1ef2 990KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 841a7461932f 1.0MiB docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:3550,test,test,3550,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:19164,test,test,19164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service althou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:1546,test,tests,1546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,1,['test'],['tests']
Testability,"th `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another future PR. I hope this sparks some discussion about the future of the `Field` abstraction as well. I think it has the potential to be quite powerful. Resolves #454 ; Resolves #428",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:7754,test,tests,7754,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,2,['test'],['tests']
Testability,"the `inertial_oscillations_work_with_rotation_in_different_axis` (in `test_dynamics.jl`) takes about 1.5 hours to complete on a GPU, despite testing only slanted coriolis force. It would be probably better to skip it or design a slimmer version of the test...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2647:141,test,testing,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2647,2,['test'],"['test', 'testing']"
Testability,this release includes PR #3695 that ensures backwards compatibility with versions 0.91.x and adds tests that were missing in #3695,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3709:98,test,tests,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3709,1,['test'],['tests']
Testability,"tic_model.jl where I have set threaded = false and decomposition = Slab(). I get a very similar error from the distributed nonhydrostatic script when I run the tests script, but the distributed shallow water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:1048,Benchmark,Benchmarking,1048,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,1,['Benchmark'],['Benchmarking']
Testability,"tilinear grids as a _preconditioner_ for a conjugate gradient iterative solver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:1323,test,test,1323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['test'],['test']
Testability,"time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Sol",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:117445,test,test,117445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczynski @simonbyrne: Just wondering if this is a problem you guys are anticipating for CliMA.jl? We might be able to share some common solutions?. Resources:; * [Nvidia slides on building a GPU-focused CI solution](",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:1898,test,tests,1898,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,2,['test'],['tests']
Testability,tionUnwrapping v0.1.10; [e2ba6199] ExprTools v0.1.10; [c87230d0] FFMPEG v0.4.1; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.2; [53c48c17] FixedPointNumbers v0.8.4; [1fa38f19] Format v1.3.6; [0c68f7d7] GPUArrays v10.0.2; [46192b85] GPUArraysCore v0.1.6; ⌅ [61eb1bfa] GPUCompiler v0.25.0; [28b8d3ca] GR v0.73.3; [c27321d9] Glob v1.3.1; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.10.3; [615f187c] IfElse v0.1.1; [40713840] IncompleteLU v0.2.1; [842dd82b] InlineStrings v1.4.0; [41ab1584] InvertedIndices v1.3.0; [92d709cd] IrrationalConstants v0.2.2; [42fd0dbc] IterativeSolvers v0.9.4; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.46; [1019f520] JLFzf v0.1.7; [692b3bcd] JLLWrappers v1.5.0; [682c06a0] JSON v0.21.4; [0f8b85d8] JSON3 v1.14.0; [63c18a36] KernelAbstractions v0.9.18; [929cbde3] LLVM v6.6.0; [8b046642] LLVMLoopInfo v1.0.0; [8ac3fa9e] LRUCache v1.6.1; [b964fa9f] LaTeXStrings v1.3.1; [23fbe1c1] Latexify v0.16.2; [2ab3a3ac] LogExpFunctions v0.3.27; [e6f89c97] LoggingExtras v1.0.3; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [1914dd2f] MacroTools v0.5.13; [739be429] MbedTLS v1.1.9; [442fdcdd] Measures v0.3.2; [e1d29d7a] Missings v1.1.0; [78c3b35d] Mocking v0.7.7; [85f8d34a] NCDatasets v0.14.3; [5da4648a] NVTX v0.3.4; [77ba4419] NaNMath v1.0.2; [d8793406] ObjectFile v0.4.1; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [4d8831e6] OpenSSL v1.4.2; [bac558e1] OrderedCollections v1.6.3; [65ce6f38] PackageExtensionCompat v1.0.2; [69de0a69] Parsers v2.8.1; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [b98c9c47] Pipe v1.3.0; [eebad327] PkgVersion v0.3.3; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.4.1; [91a5bcdd] Plots v1.40.2; [2dfb63ee] PooledArrays v1.4.3; ⌃ [aea7be01] PrecompileTools v1.2.0; [21216c6a] Preferences v1.4.3; [08abe8d2] PrettyTables v2.3.1; [49802e3a] ProgressBars v1.5.1; [94ee1d12] Quaternions v0.7.6; [74087812] Random123 v1.7.0; [e6cf234a] Random,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:4197,Log,LoggingExtras,4197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Log'],['LoggingExtras']
Testability,"tions to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 56 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchma",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:105106,benchmark,benchmark,105106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['benchmark'],"['benchmark', 'benchmarks']"
Testability,"tions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,typeof(Oceananigans.Forcings.zeroforcing)}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3,Array{Int64,1}},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3,Int64},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3,Array{Int64,1}},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3,Int64}}},Nothing},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}},Int64,Array{Any,1},Float64,Int64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}; pickup::Bool) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:106; [4] top-level scope at REPL[6]:1; ```. But this mean you have to add boilerplate logic like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. if checkpointed; run!(simulation, pickup=true); else; run!(simulation, pickup=false); end; ```. I think `pickup=true` should print a warning if no checkpoints were found, allowing such scripts to run simulations without boilerplate logic. `pickup::Int` and `pickup::String` should error of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1159:11809,log,logic,11809,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159,2,['log'],['logic']
Testability,"tive`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:1582,log,log,1582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,1,['log'],['log']
Testability,"to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\J",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:1092,test,test,1092,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,1,['test'],['test']
Testability,todo. - [x] Implement the preconditioner for free surface Implicit solver; - [x] Allow for flux boundary conditions with `Array` type parameters; - [ ] Implement multi-region output writers (and eventually readers?); - [x] Adapt `AbstractOperations` to `MultiRegionFields`; - [x] Add more tests for implicit solvers; - [x] Benchmark results. Closes #1582 ; Closes #2255 ; closes #2005,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253:289,test,tests,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253,2,"['Benchmark', 'test']","['Benchmark', 'tests']"
Testability,"top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in arc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:111348,benchmark,benchmark,111348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another future PR. I hope this sparks some discussion about the future of the `Field` abstraction as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:7489,test,tested,7489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['test'],['tested']
Testability,"try to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474:1374,benchmark,benchmarks,1374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474,1,['benchmark'],['benchmarks']
Testability,"ts.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:18366,test,test,18366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"u^\star$ term having the term `u_{2jk} - u_{1jk}` at the `i=1` point (in the central difference case, I don't know where spatial operation approximations are defined in the code) change from `u_{2jk} - 0` in the no penetration case to `u_{2jk} - u_{open boundary}$. In the case where the interior velocity is already the same as the specified velocity (and everything else is uniform), this means that at `i=1` $\nabla^2 P_{non}$ changes from being positive to zero, so we go from having a pressure gradient at the wall counteracting the flow away from the wall (or I suppose a reconfiguration to `u=0` everywhere to enforce compressibility) to having no pressure gradient across the wall. . Thinking about it this is exactly what happens for periodic domains where we are essentially specifying the flow outside of the domain. That makes me think that we don't need to do anything else for time-varying inflows.; </details>. As for making the outflows more correct, I think we should be able to extend to the method for calculating ht phase velocity by the method in 3.3 of https://doi.org/10.1016/0021-9991(83)90127-4 (linked in https://github.com/CliMA/Oceananigans.jl/issues/833) which doesn't depend on previous time steps as some other Orlanski methods do, but it does depend on the time difference of the interior solution with the next step which currently does not get passed to the boundary conditions. Perhaps it might be most straightforward to evaluate $c=-\frac{\partial\phi/\partial t}{\partial\phi/\partial x}$ by passing the tendencies and using $\partial\phi/\partial t = G_n$ (although this isn't quite correct for the velocity so maybe $-\nabla P$. I think passing the tendencies automatically is going to require some materialization step when the model is setup to pass $G^n$ into the boundary conditions but I know we're trying to avoid doing that so any other suggestions would be useful. I've started testing this by initialising the timestepper first but it is a bit clumsy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:4984,test,testing,4984,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['test'],['testing']
Testability,"ub.com/CliMA/OceananigansArtifacts.jl. The easiest way to use them is to load them as a data dependency with DataDeps.jl: https://github.com/CliMA/Oceananigans.jl/blob/master/test/data_dependencies.jl. This works well for the CS32 and CS96 grids, but for much larger grids like the CS510 the grid file is ~200 MiB uncompressed (~118 MiB compressed with JLD2's `compress=true`) which is bigger than GitHub's 100 MiB file size limit. 200 MiB for a grid file is also a bit cumbersome. Right now I'm thinking of hosting CS510 on the engaging cluster, although git lfs for OceananigansArtifacts.jl may be an option. It would be nice to be able to generate conformal cubed sphere grid files to make it easier for users to use cubed sphere grids, and also for the added flexibility of not being limited to three common resolutions (CS32, CS96, and CS510). It would also be good to keep the ability to load a cubed sphere grid from file since we may want to do this for other grids besides the cubed sphere in the future (lat-lon-cap or LLC grids?), and it would be useful to test that the grids we generate are indeed correct by comparing with the grid files. I'm opening this issue just to document what we know about conformal cubed sphere grid generation. It's not a particularly urgent issue. # Computing grid metrics. We already have some code that generates conformal cubed sphere grids with the coordinates, but they are missing the grid metrics (grid spacings and areas). @christophernhill has pointed out these MITgcm MATLAB scripts that may just be what we need to compute the grid metrics. http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/README?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/calc_fvgrid.m?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/gengrid_fn.m?revision=1.1.1.1&view=markup. He also ment",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1586:1239,test,test,1239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1586,1,['test'],['test']
Testability,"ular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼──",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:1589,Benchmark,Benchmark,1589,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,2,['Benchmark'],['Benchmark']
Testability,"ularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X}; filename::String, iteration_interval::Int64, time_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:102052,Test,Test,102052,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"ulence closure benchmark script with grid size 256 x 256 x 128.; There was an issue with the Nothing closure which was avoided by removing that type of closure from the closure array.; ```. Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ┌───────────────┬──────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Closures │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ AnisotropicBiharmonicDiffusivity │ 3.634 s │ 3.637 s │ 3.637 s │ 3.639 s │ 1.77 MiB │ 2316 │ 2 │; │ CPU │ AnisotropicDiffusivity │ 2.045 s │ 2.052 s │ 2.059 s │ 2.079 s │ 1.77 MiB │ 2316 │ 3 │; │ CPU │ AnisotropicMinimumDissipation │ 3.240 s │ 3.240 s │ 3.240 s │ 3.241 s │ 2.09 MiB │ 2763 │ 2 │; │ CPU │ IsotropicDiffusivity │ 2.342 s │ 2.344 s │ 2.344 s │ 2.345 s │ 1.77 MiB │ 2316 │ 3 │; │ CPU │ SmagorinskyLilly │ 3.501 s │ 3.504 s │ 3.504 s │ 3.507 s │ 2.03 MiB │ 2486 │ 2 │; │ CPU │ TwoDimensionalLeith │ 4.813 s │ 4.820 s │ 4.820 s │ 4.828 s │ 1.88 MiB │ 2481 │ 2 │; │ GPU │ AnisotropicBiharmonicDiffusivity │ 24.699 ms │ 24.837 ms │ 26.946 ms │ 46.029 ms │ 3.16 MiB │ 29911 │ 10 │; │ GPU │ AnisotropicDiffusivity │ 16.115 ms │ 16.184 ms │ 16.454 ms │ 18.978 ms │ 2.97 MiB │ 17169 │ 10 │; │ GPU │ AnisotropicMinimumDi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:12379,benchmark,benchmarks,12379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['benchmark'],['benchmarks']
Testability,"ulia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.90364838",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:10710,test,test,10710,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"ulia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.9565854067170",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:8606,test,test,8606,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"undaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditioner is faster (benchmarks below). ; * Both the ""matrix"" and ""non-matrix"" solvers use conjugate gradient iteration --- the difference is in how they compute the left-hand-side (ie the linear left-side operator above, and the preconditioners that are supported). ## Benchmarks. Note that ""PCGImplicitFreeSurface"" below means ""PCGImplicitFreeSurface with FFT based preconditioner"". These benchmarks have a problem size 256 x 128 x 1. ### CPU; ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼───",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:2426,benchmark,benchmarks,2426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['benchmark'],['benchmarks']
Testability,"undary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we need 1) unit tests and 2) a validation tests that exercises the momentum equations. Supporting user-specified fluxes can come in a subsequent PR. Some of the pieces to support immersed boundaries with VerticallyImplicitTimeDiscretization are in place but it's not 100% supported yet. cc @hdrake @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654:1387,test,test,1387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654,4,['test'],"['test', 'tests']"
Testability,"uple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:76650,test,test,76650,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"urface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:9823,test,test,9823,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"user-images.githubusercontent.com/67593861/108130156-2f329880-707d-11eb-87db-6d519e2513be.gif); ; The barebones of this implementation is rather old at this point. Even though it has been updated to work with the current set up, I imagine there are things that might still need more updating or have become superfluous. All suggestions are appreciated!. ### Description:; Instead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. In practice, when your boundary conforms to the grids, creating a stair-step like boundary, this becomes much simpler to handle. Here, we replace the tendency terms in `correct_immersed_tendencies.jl` so that when you take the next Runge-Kutta step, you end up with U = 0. . Since this process occurs before the pressure correction, there is a small amount of error that seems to fit with the correction as seen here for various places within the cylinder where it should be zero:; ![Pcorrect_vs_velocity_inside_dx04](https://user-images.githubusercontent.com/67593861/108130321-7ae54200-707d-11eb-9101-273350597d8c.png); ; It would need more testing to truly verify that this is the case, but seems to fit the data so far. ### To Do/ Upcoming:; - Currently working on an arbitrary grid implementation, that can intersect the boundary however it wants. This involves a good amount of interpolation, but it well on the way. This implementation will easily handle Neumann and Dirichlet boundary conditions. It makes more sense for normal and tangential boundary conditions rather than specific (u,v,w) conditions, so we will also project the velocities along with interpolating.; - Need to add a way for the user to specify boundary conditions; - Add tracer capabilities. The implementation is slightly different for arbitrary grids, since tracers will be a scalar that is not rotated into normal and tangential components for implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1368:1810,test,testing,1810,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368,1,['test'],['testing']
Testability,ussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAni,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:2592,test,test,2592,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/na",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:19760,test,test,19760,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,vel scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Re,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:117969,Benchmark,BenchmarkTools,117969,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Benchmark'],['BenchmarkTools']
Testability,"vely setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Array{Int64,1}:; 1; 5; 2; 4; 3. julia> [unpermute(i, N) for i in L]; 5-element Array{Int64,1}:; 1; 2; 3; 4; 6; ```. # Fix. ```julia; julia> unpermute(i, N) = i <= ceil(N/2) ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Array{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1228:1306,test,test,1306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228,2,['test'],"['test', 'tested']"
Testability,"w water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:1223,Benchmark,Benchmarking,1223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,1,['Benchmark'],['Benchmarking']
Testability,"ward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 16 │ (1, 2, 3) │ 13.948 μs │ 14.043 μs │ 20.717 μs │ 80.605 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ (1, 2, 3) │ 1.656 ms │ 1.717 ms │ 1.809 ms │ 2.697 ms ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:1917,benchmark,benchmarks,1917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['benchmark'],['benchmarks']
Testability,"with @glwagner we introduced broadcasts across fields and `OffsetArrays` that include halos, so that. ```; field1 = CenterField(grid); field2 = CenterField(grid). set!(field1, (x, y, z) -> x). data = field1.data. field2 .= data; ```; or alternatively; ```; set!(field2, data); ```; will set not only the interior of the field, but also the halos, without the need of `fill_halo_regions!`. We need tests to make sure this feature does not break somewhere...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2501:397,test,tests,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2501,1,['test'],['tests']
Testability,"with the development of multi GPU we have to expand our test capabilities to include this functionality. ; We should introduce a new Agent that can handle single-node and multi-node multi GPU to our CI pipeline. . @christophernhill @glwagner @navidcy, any candidates in mind?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2526:56,test,test,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2526,1,['test'],['test']
Testability,"x-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_ru",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:14450,test,test,14450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"xecution of the WENO scheme on stretched and uniform grids alike. . In practice:. if the direction is uniform (`typeof(Δc) <: Number`) the scheme defaults to the usual 5th order interpolation coefficients (""uniform setting""). otherwise if the grid is stretched:. - `WENO5S(grid = grid)` will precompute the WENO coefficients for the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation is: it is way too expensive!); - `WENO5s()` will default to the uniform 5th order coefficients (""uniform"" setting); - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; `WENO5()` is obsolete as all the functionalities of `WENO5()` are included in `WENO5S()`, on the other hand, I kept this type for the moment for validation and benchmark purposes. When the `WENO5S(args...)` scheme is approved we can refractor it to `WENO5(args...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ W",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2059:1032,test,test,1032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059,1,['test'],['test']
Testability,"y=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 56 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running chan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:106322,benchmark,benchmark,106322,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,"['Test', 'benchmark']","['Test', 'benchmark']"
Testability,"ype that looks something like. ```julia; struct FunctionOperand{F, G, A}; func :: F; grid :: G; args :: A; end. @inline Base.getindex(o::FunctionOperand, i, j, k) = o.func(i, j, k, o.grid, o.args...); ```. This works because the kernel that computes a `ComputedField`'s data is. https://github.com/CliMA/Oceananigans.jl/blob/c5f47e01ef0fab0cd1e99260e578ace7ad04084c/src/Fields/computed_field.jl#L85-L88. Then with a bit of boilerplate we can define constructors for all the terms we might need, eg. ```julia; TendencyTermField(X, Y, Z, term_func, grid; args, data=nothing) =; ComputedField{X, Y, Z}(FunctionOperand(term_func, grid, args), data=data). using Oceananigans.Advection: momentum_flux_uu, momentum_flux_uw. uu = TendencyTermField(Cell, Cell, Cell, momentum_flux_uu, grid, args=(model.advection, model.velocities.u, model.velocities.u)); wu = TendencyTermField(Cell, Cell, Face, momentum_flux_uw, grid, args=(model.advection, model.velocities.w, model.velocities.u)); ```. We probably want to define aliases for all the terms that appear in our tendency equations, as well as the advective and diffusive fluxes, so that we can ensure they are correct and correctly located on the staggered grid. Unfortunately this does involve a lot of boiler plate and introduces a maintenance and testing burden. If we can push responsibility more to users I am open to that, but I'm not 100% how to make this process more programmatic. Ideas very welcome. If functions like `momentum_flux_uu` are going to emerge from darkness into users' scripts, we may want to have a discussion about whether our names / naming convention is sensible. By the way, `ComputedField` seems to assume that `operand` has a property called `grid`:. https://github.com/CliMA/Oceananigans.jl/blob/c5f47e01ef0fab0cd1e99260e578ace7ad04084c/src/Fields/computed_field.jl#L43-L47. We could create a type called `AbstractOperand`, of which `AbstractOperation` (and other concrete operands) are subtypes. cc @qingli411, @BrodiePearson",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1073:1883,test,testing,1883,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1073,1,['test'],['testing']
Testability,"|; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms. But I'd like to keep the five initial goals in mind. This issue will probably be open for a while.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:2801,benchmark,benchmarking,2801,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,1,['benchmark'],['benchmarking']
Testability,"~Also bumps to 0.68.8.~. The application for this kind of regridding is from a field that, while living on a 3D grid, is reduced in x and y. Because the field is reduced in x and y it's a valid source field for a target field that's on a 1D grid. We should probably add a test to this PR (regridding from a reduced field on a 3D grid to a non-reduced field on a 1D grid). cc @adelinehillier @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2186:272,test,test,272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2186,1,['test'],['test']
Testability,"~~Since this wasn't caught by tests, I think this PR should add a test.~~. A test will be added in an imminent PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/953:30,test,tests,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/953,3,['test'],"['test', 'tests']"
Testability,"~~This PR adapts `BetaPlane` coriolis implementation for curvilinear grids (following #1371 and [MITgcm docs](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8)).~~. ~~Note that the MITgcm docs specify averaging the Coriolis parameter / planetary vorticity (from corner / vorticity nodes, ffc, to the velocity nodes fcc and cfc). However, because the variation in the planetary vorticity is linear, I think the implementation in this PR is correct for beta planes? @jm-c please advise.~~. I would ~~also~~ like to add a Coriolis term valid for the sphere and hydrostatic models (which amounts to the ""traditional approximation""). ~~I'll do this once #1380 is merged.~~ This PR depends on #1380. Some feedback on what to call this object is certainly welcome! I have preliminary proposed ""`HydrostaticSphericalCoriolis` because it was the first silly thing I could think of. To do:. - [x] Add `HydrostaticSphericalCoriolis` plus unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384:952,test,tests,952,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384,1,['test'],['tests']
Testability,"λx, :λy, :λz), Tuple{Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}}}, PencilArrays.ManyPencilArray{ComplexF64, 3, 3, Tuple{PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.NoPermutation, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(2, 1, 3), 3}, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(3, 2, 1), 3}, Vector{UInt8}}}}, Vector{ComplexF64}}}); @ Oceananigans.Distributed ~/.julia/packages/Oceananigans/nqpMM/src/Distributed/distributed_fft_based_poisson_solver.jl:65; ```; ... the error continues. Also, this part of the distributed tests is currently passing 1.6: https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/test/test_distributed_models.jl#L469-L473. But fails on Julia 1.7 with the same error that I get (part of the reason why https://github.com/CliMA/Oceananigans.jl/pull/2307 isn't ready): https://buildkite.com/clima/oceananigans/builds/6202#6f169fce-d4b4-43e6-947e-fade1e4c7ad3/19-1203. At first I thought this was a limitation of `PencilArrays.jl`, which is why I created https://github.com/jipolanco/PencilArrays.jl/issues/49. But from the answer I got there that doesn't seem to be the case. I don't fully understand [the answer](https://github.com/jipolanco/PencilArrays.jl/issues/49#issuecomment-1100907232), but it makes me think that something might be up with our distributed architecture implementation and it'd be nice to get some other eyes here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2445:14880,test,tests,14880,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445,2,['test'],"['test', 'tests']"
Testability,"────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 126s / 62.8% 1.46GiB / 0.13% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 39.4s 49.9% 3.94s 1.00MiB 50.0% 102KiB; 32× 32× 32 [CPU, Float64] 10 39.5s 50.1% 3.95s 1.00MiB 50.0% 102KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. Unfortunately still a bit higher than v0.22.0 (~50 KiB allocations) but much better and more acceptable than 17 MiB!. Remaining memory allocations seem to be occuring in `fill_halo_regions.jl` but tried inlining some functions and didn't help so I'll revisit the problem in the future. ```; julia> analyze_malloc("".""); 323-element Array{CoverageTools.MallocInfo,1}: ; ⋮ ; CoverageTools.MallocInfo(5008, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 36) ; CoverageTools.MallocInfo(5952, ""./benchmark/benchmark_utils.jl.32885.mem"", 35) ; CoverageTools.MallocInfo(6080, ""./src/TimeSteppers/time_stepping_kernels.jl.32885.mem"", 139) ; CoverageTools.MallocInfo(7136, ""./src/Architectures.jl.32885.mem"", 39) ; CoverageTools.MallocInfo(12160, ""./src/Utils/tuple_utils.jl.32885.mem"", 14) ; CoverageTools.MallocInfo(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 20); CoverageTools.MallocInfo(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 38); CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 45) ; CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 49) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 52) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 53) ; CoverageTools.MallocInfo(16640, ""./src/Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/685:1767,benchmark,benchmark,1767,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685,1,['benchmark'],['benchmark']
Testability,"────────┴─────────┴─────────┴────────────┴────────┴─────────┘; ```. ```; Shallow water model weak scaling speedup; ┌──────────────┬─────────┬──────────┬────────────┬──────────┬────────┐; │ size │ ranks │ slowdown │ efficiency │ memory │ allocs │; ├──────────────┼─────────┼──────────┼────────────┼──────────┼────────┤; │ (8192, 256) │ (1, 1) │ 1.0 │ 1.0 │ 1.0 │ 1.0 │; │ (8192, 512) │ (1, 2) │ 1.00165 │ 0.998349 │ 0.980769 │ 1.1925 │; │ (8192, 1024) │ (1, 4) │ 1.01309 │ 0.987079 │ 0.980769 │ 1.1925 │; │ (8192, 2048) │ (1, 8) │ 1.02721 │ 0.973514 │ 0.980769 │ 1.1925 │; │ (8192, 4096) │ (1, 16) │ 1.07822 │ 0.927452 │ 0.980769 │ 1.1925 │; │ (8192, 8192) │ (1, 32) │ 1.19049 │ 0.83999 │ 0.980769 │ 1.1925 │; └──────────────┴─────────┴──────────┴────────────┴──────────┴────────┘; ```. # Strong scaling (shallow water). ```; Shallow water model strong scaling benchmark; ┌──────────────┬─────────┬──────────┬──────────┬──────────┬──────────┬────────────┬────────┬─────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├──────────────┼─────────┼──────────┼──────────┼──────────┼──────────┼────────────┼────────┼─────────┤; │ (8192, 8192) │ (1, 1) │ 37.687 s │ 37.687 s │ 37.687 s │ 37.687 s │ 417.50 KiB │ 2709 │ 1 │; │ (8192, 8192) │ (1, 2) │ 19.278 s │ 19.280 s │ 19.280 s │ 19.282 s │ 409.48 KiB │ 3222 │ 2 │; │ (8192, 8192) │ (1, 4) │ 9.027 s │ 9.030 s │ 9.029 s │ 9.031 s │ 409.48 KiB │ 3222 │ 4 │; │ (8192, 8192) │ (1, 8) │ 5.499 s │ 5.514 s │ 5.513 s │ 5.520 s │ 409.48 KiB │ 3222 │ 8 │; │ (8192, 8192) │ (1, 16) │ 2.587 s │ 2.598 s │ 2.599 s │ 2.608 s │ 409.48 KiB │ 3222 │ 32 │; │ (8192, 8192) │ (1, 32) │ 1.355 s │ 1.437 s │ 1.438 s │ 1.544 s │ 408.80 KiB │ 3178 │ 128 │; └──────────────┴─────────┴──────────┴──────────┴──────────┴──────────┴────────────┴────────┴─────────┘; ```. ```; Shallow water model strong scaling speedup; ┌──────────────┬─────────┬─────────┬────────────┬──────────┬─────────┐; │ size │ ranks │ speedup │ efficiency │ memory │ allocs │; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505:2510,benchmark,benchmark,2510,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505,1,['benchmark'],['benchmark']
Testability,"│ 2 │ 4.085 μs │ 4.135 μs │ 4.723 μs │ 8.088 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 2 │ 564.769 μs │ 579.278 μs │ 615.731 μs │ 804.859 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 2 │ 110.718 ms │ 111.560 ms │ 111.506 ms │ 112.525 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 3 │ 7.772 μs │ 7.787 μs │ 9.499 μs │ 24.886 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 3 │ 684.541 μs │ 688.275 μs │ 811.874 μs │ 1.463 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ 3 │ 93.902 ms │ 94.489 ms │ 94.604 ms │ 95.639 ms │ 0 bytes │ 0 │; └───────────────┴─────┴───────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘. 3D FFT --> 3 × 1D FFTs slowdown:; CPU, 16: 1.0807x; CPU, 64: 1.0053x; CPU, 256: 1.1567x; ```. # To batch or not to batch for CUFFT on GPUs?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ (1, 2, 3) │ 25.478 μs │ 32.459 μs │ 122.062 μs │ 703.376 μs │ 224 bytes │ 13 │; │ GPU │ 64 │ (1, 2, 3) │ 67.226 μs │ 71.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:4213,Benchmark,Benchmark,4213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['Benchmark'],['Benchmark']
Usability," 2), extent=(1, 1, 1)); RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (2, 2, 2); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.5, 0.5, 0.5). julia> c = CenterField(CPU(), grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (2, 2, 2); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> c0 = reshape(rand(2), 1, 1, 2); 1×1×2 Array{Float64, 3}:; [:, :, 1] =; 0.8285541189507857. [:, :, 2] =; 0.4097696419875272. julia> c .= c0 # should fill every c-column with identical values. julia> c[1, 1, :]; 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 0.8285541189507857; 0.4097696419875272; 0.0. julia> c[1, 2, :]; 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 0.4097696419875272; 2.3732366066e-314; 0.0. julia> c[2, 2, :]; 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 2.3732366066e-314; 2.2804048985e-314; 0.0. julia> c[2, 1, :]; 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 0.4097696419875272; 2.3732366066e-314; 0.0; ```. The column `c[1, 1, :]` is correct, but the others are not. We shouldn't work too hard here since something as simple as . ```julia; julia> interior(c) .= c0; 2×2×2 view(::Array{Float64, 3}, 2:3, 2:3, 2:3) with eltype Float64:; [:, :, 1] =; 0.828554 0.828554; 0.828554 0.828554. [:, :, 2] =; 0.40977 0.40977; 0.40977 0.40977. julia> c[2, 1, :]; 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 0.8285541189507857; 0.4097696419875272; 0.0; ```. is fine...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1942:1783,simpl,simple,1783,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1942,1,['simpl'],['simple']
Usability," This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variabl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2365,simpl,simple,2365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['simpl'],['simple']
Usability," euler); time_step!(coupled_model.atmos, Δt; euler); update_state!(coupled_model, false); return nothing; end; ```. Air-sea fluxes are computed in `update_state!`:. ```julia; # Use broadcasting to compute bulk formula for surface wind stress; topo = topology(atmos_grid); Nx, Ny, Nz = size(atmos_grid); Hx, Hy, Hz = atmos_grid.Hx, atmos_grid.Hy, atmos_grid.Hz; ii = Hx+1:Hx+Nx; jj = topo[2]() isa Flat ? 1 : Hy+1:Hy+Ny # hack because 2D can be fun; k = atmos_grid.Hz+1 # surface atmospheric velocity; ua₁ = view(parent(ua), ii, jj, k:k); va₁ = view(parent(va), ii, jj, k:k). @. atmos_surface_flux_u = - cᴰ * ua₁ * sqrt(ua₁^2 + va₁^2); @. atmos_surface_flux_v = - cᴰ * va₁ * sqrt(ua₁^2 + va₁^2). @. ocean_surface_flux_u = ρ_atmos / ρ_ocean * atmos_surface_flux_u; @. ocean_surface_flux_v = ρ_atmos / ρ_ocean * atmos_surface_flux_v; ```. A few tweaks to how output writers work (making them function more like callbacks) makes output work with the coupled models, too. This PR also contributes a simple boundary layer turbulence example. The setup is not very user-friendly right now, but this PR shows that this sort of science is possible. In short, this is accomplished by building two Oceananigans models and passing them to `CoupledAtmosphereOceanModel`. ## Notes on how development could proceed . To make the setup more user friendly, this abstraction should probably include:. * more automated grid creation that ensure horizontal domains are the same extent; * better bulk formulae that include heat fluxes, salt fluxes, and trace gas fluxes; * automated generation + checking of interface boundary condition arrays. A short feature wish list might be. * budget preserving interpolation between horizontal grids of different resolution; * multi-rate time-stepping / sub-stepping of 'fast' model components; * compressible atmospheric model (:-D). Once I get this going on the GPU and tweak parameters I'll post a visualization. For now we'll have to be satisfied with. ![image](https://user-ima",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1916:1512,simpl,simple,1512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916,1,['simpl'],['simple']
Usability," file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different wa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:1177,usab,usability,1177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,1,['usab'],['usability']
Usability," into `Oceananigans.Operators`. All tests pass but there's quite a bit of cleanup to be done. @glwagner This PR affects a lot of code you've written so we should probably work on merging this PR together. Now that tests pass we can focus on cleanup. I still need to convert the biharmonic operators and `leith_enstrophy_diffusivity.jl` closure to finite volume. I'll also add a test for Leith. There are regression tests for constant diffusivty, Smagorinsky, and AMD, but not for other closures, so we should probably be careful that closures with no regression test remain unchanged. Some comments:. 1. The `norm` functions defined in `velocity_tracer_gradients.jl` https://github.com/climate-machine/Oceananigans.jl/blob/2bb32015e64bff830f2233d588360ccc6b8605b4/src/TurbulenceClosures/velocity_tracer_gradients.jl#L130-L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ = Δᶠzᶜᶜᶜ = Δᶠ_ccc`?. 6. I could never find a symbol like `\cdot` for divergences that can be used in function na",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/529:1103,clear,clearer,1103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529,1,['clear'],['clearer']
Usability," simulation which is failing now. This was working a few days ago.; ```; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC; xC, yC, zC = reshape(xC, (Nx, 1, 1)), reshape(yC, (1, Ny, 1)), reshape(zC, (1, 1, Nz)). # Set heating flux at the bottom.; Q = 9200 # W/m^2; Rp = 50 # plume radius [m]. r = @. sqrt((xC - Lx/2)^2 + (yC - Ly/2)^2). bottom_flux = zeros(Nx, Ny, 1); bottom_flux[r .< Rp] .= g * ɑ * Q / (ρ₀ * cₚ); bottom_flux = CuArray(bottom_flux). model.boundary_conditions.T.z.right = BoundaryCondition(Flux, bottom_flux); ```. This now fails with:; ```; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Flux,Int64}, got BoundaryCondition{Flux,CuArray{Float64,3}}; Stacktrace:; [1] setbc!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Val{:right}, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:81; [2] setproperty!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Symbol, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:80; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] include(::String) at ./client.jl:403; [8] top-level scope at none:0; in expression starting at /home/betaeffect/oceananigans/hydrothermal_plume/nukappa1em4/plume.jl:37; ```. I am not fully proficient in Julia yet, so wasn't able to figure out from the code how to fix this issue. Is there a simple fix?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314:2163,simpl,simple,2163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314,1,['simpl'],['simple']
Usability," stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that shear production and buoyancy flux include the _total_ contribution, not just the contribution from CATKE diffusion (@simone-silvestri this is especially important if we want to pair CATKE with a mass flux scheme). Does anyone else have any suggestion or things on their wishlist?. cc @adelinehillier @sandreza @navidcy @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2450:1609,simpl,simpler,1609,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450,1,['simpl'],['simpler']
Usability,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:589,simpl,simplest,589,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,1,['simpl'],['simplest']
Usability,"### Discussed in https://github.com/CliMA/Oceananigans.jl/discussions/2455. <div type='discussions-op-text'>. <sup>Originally posted by **iuryt** April 21, 2022</sup>; Hi,. I couldn't find an example from the docs that uses a regular array, converts to `CudaArray` and them use it as an initial condition for a GPU run. Do you guys have any example of that that could share? Maybe would be good to consider putting an example like this on the docs.</div>. I think we should add examples on the docs for setting initial conditions with Arrays using CPU and GPU.; https://clima.github.io/OceananigansDocumentation/stable/model_setup/setting_initial_conditions/#Setting-initial-conditions. I know that for CPU it should be straight forward, but I think it is important to make it clear. Also, it might not be like this for GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2457:777,clear,clear,777,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2457,1,['clear'],['clear']
Usability,"(and better boundary conditions API). This PR adds two scripts to the sandbox for performing large eddy simulation of:. - [ ] a 'simple flux' scenario of a ~100 m square ocean forced by constant surface fluxes, and; - [ ] stratified Couette flow. We may also want to add an example based on one of these scripts. Addresses #310.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315:129,simpl,simple,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315,1,['simpl'],['simple']
Usability,"(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes. In terms of a path forward, I think we could simply start with the constant roughness length case, and perhaps make the utility a bit general so that users could also directly specify a drag coefficient if desired. For example in hydrostatic cases we often specify the drag coefficient directly, and we also usually omit the dependence on `w`. There are even more considerations one might consider... for example, in a finite volume model (and in the code above) the distance to the wall is taken as the ""center of the cell"", ie half the cell thickness. But this is not really consistent with the finite volume framework, and better approaches have been proposed (eg see [Nishizawa and Kitamura 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001534)). Note that if we want to compute fluxes across the air-sea interface, it's probably better to use ClimaOcean (tools for building coupled and realistic air-sea, air-ice-sea models) for that. But ClimaOcean is not going to support the algorithmically simpler, yet geometrically more complicated case of computing momentum fluxes into complex solid objects. I think this is in scope for Oceananigans since it is not a concept in coupling between two fluids, like the air-sea case handled by ClimaOcean is.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:6286,simpl,simpler,6286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['simpl'],['simpler']
Usability,"); return nothing; end; ```. Air-sea fluxes are computed in `update_state!`:. ```julia; # Use broadcasting to compute bulk formula for surface wind stress; topo = topology(atmos_grid); Nx, Ny, Nz = size(atmos_grid); Hx, Hy, Hz = atmos_grid.Hx, atmos_grid.Hy, atmos_grid.Hz; ii = Hx+1:Hx+Nx; jj = topo[2]() isa Flat ? 1 : Hy+1:Hy+Ny # hack because 2D can be fun; k = atmos_grid.Hz+1 # surface atmospheric velocity; ua₁ = view(parent(ua), ii, jj, k:k); va₁ = view(parent(va), ii, jj, k:k). @. atmos_surface_flux_u = - cᴰ * ua₁ * sqrt(ua₁^2 + va₁^2); @. atmos_surface_flux_v = - cᴰ * va₁ * sqrt(ua₁^2 + va₁^2). @. ocean_surface_flux_u = ρ_atmos / ρ_ocean * atmos_surface_flux_u; @. ocean_surface_flux_v = ρ_atmos / ρ_ocean * atmos_surface_flux_v; ```. A few tweaks to how output writers work (making them function more like callbacks) makes output work with the coupled models, too. This PR also contributes a simple boundary layer turbulence example. The setup is not very user-friendly right now, but this PR shows that this sort of science is possible. In short, this is accomplished by building two Oceananigans models and passing them to `CoupledAtmosphereOceanModel`. ## Notes on how development could proceed . To make the setup more user friendly, this abstraction should probably include:. * more automated grid creation that ensure horizontal domains are the same extent; * better bulk formulae that include heat fluxes, salt fluxes, and trace gas fluxes; * automated generation + checking of interface boundary condition arrays. A short feature wish list might be. * budget preserving interpolation between horizontal grids of different resolution; * multi-rate time-stepping / sub-stepping of 'fast' model components; * compressible atmospheric model (:-D). Once I get this going on the GPU and tweak parameters I'll post a visualization. For now we'll have to be satisfied with. ![image](https://user-images.githubusercontent.com/15271942/127759981-e9b15398-8484-4e63-ad29-3ef7f9462472.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1916:1576,user-friendly,user-friendly,1576,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916,1,['user-friendly'],['user-friendly']
Usability,", z) = T0(z) + dTdz * model.grid.Lz * 1e-6 * Ξ(z). ## `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=S₀); ```; When I tried to output `model.pressures.prapid`, I got:. ```julia; 100×100×48 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 100×100×48 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 106×106×54 OffsetArray(::Array{Float64, 3}, -2:103, -2:103, -2:51) with eltype Float64 with indices -2:103×-2:103×-2:51; └── max=NaN, min=NaN, mean=NaN; ```; The NaN value appears. But for $p_{NHS}$ and $p_{HY'}$, the results are reasonable. So any comments or ideas about this error? . Another issue is about the calculation of the pressure terms for which the boundary conditions are inhomogeneous Neumann boundary conditions ($p_b'$, $p_{st}'$ and $p_{sg}'$, see Appendix A for details in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). For this issue, I have checked the related issue #1232. I wanna ask do I need to subtly update the boundary values of $p_b'$, $p_{st}'$ and $p_{sg}'$ to convert the inhomogeneous Neumann problem to the homogeneous Neumann problem? If so, how do I determine the values the boundary should update?. I hope I've described this issue clearly, but please let me know if anything confuse you. In addition, this is my first attempt to make a possible contribution to an open source project, and I would like to ask what is the most efficient way to conduct the discussion? Should we talk about this here firstly or can I start with a PR to better let you know what specific changes I've made to the code?. Thank you very much for any comments, suggestions or ideas!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3459:9723,clear,clearly,9723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459,1,['clear'],['clearly']
Usability,",Int64,Periodic,Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},Oceananigans.Solvers.Backward,GPU,VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},Int64,Bounded,Int64,NamedTuple{(:forward, :backward),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}},Tuple{Int64,Int64,Int64}}}}}},Tuple{Nothing,Nothing},NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},Int64,Array{Any,1},Int64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}) at /home/guptam/.julia/packages/Oceananigans/wJDxT/src/Simulations/run.jl:127; [8] top-level scope at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:80; [9] include(::Function, ::Module, ::String) at ./Base.jl:380; [10] include(::Module, ::String) at ./Base.jl:368; [11] exec_options(::Base.JLOptions) at ./client.jl:296; [12] _start() at ./client.jl:506; in expression starting at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:76; ```. I believe this is caused by the `AnisotropicBiharmonicDiffusivity` component of the turbulence closure, since using a simple `AnisotropicDiffusivity` works fine. Also note that the above setup works on a `RegularRectilinearGrid`. Any ideas? . I am working on the `ali/unclog-docs` branch to avoid the error reported here #1571, using Julia v1.5.4 and Oceananigans v0.54.0 + GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574:93595,simpl,simple,93595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574,1,['simpl'],['simple']
Usability,- [x] Changes `mode` and `force` to overwrite existing; - [x] Change `prefix` to something clearer (maybe `filename`); - [x] Separate keyword `filepath` in `NetcdfOutputWriter` into `dir` and `filename` (or whatever is replacing `prefix`); - [x] Maybe add a couple more tests for `NetcdfWriter`. Closes https://github.com/CliMA/Oceananigans.jl/issues/884; Closes https://github.com/CliMA/Oceananigans.jl/issues/2427,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416:91,clear,clearer,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416,1,['clear'],['clearer']
Usability,"- cᴰ * f.u[i, j, k] * speedᶠᶜᶜ(i, j, k, grid, f.u, f.v, f.w); @inline v_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.v[i, j, k] * speedᶜᶠᶜ(i, j, k, grid, f.u, f.v, f.w); @inline w_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.w[i, j, k] * speedᶜᶜᶠ(i, j, k, grid, f.u, f.v, f.w). ϰ = 0.4 # ""Von Karman"" constant; ℓ = 1e-4 # simply an estimated roughness length; d = minimum_xspacing(grid) / 2 # assuming an isotropic grid, using half cell-width as ""distance to the wall""; cᴰ = (ϰ / log(d / ℓ))^2. u_drag_bc = FluxBoundaryCondition(u_drag, discrete_form=true, parameters=cᴰ); v_drag_bc = FluxBoundaryCondition(v_drag, discrete_form=true, parameters=cᴰ); w_drag_bc = FluxBoundaryCondition(w_drag, discrete_form=true, parameters=cᴰ); ```. Note, this only really makes sense on an isotropic grid and I think to strictly treat anisotropic grids we need to manually construct `ImmersedBoundaryCondition`. Even with the simplifications we've made, it's still a lot of code that has to be repeated every time somebody wants to implemented a drag law on an immersed boundary. So we could easily motivate implementing an abstraction `drag_boundary_conditions` that returns the bcs for `u, v, w`, eg:. ```julia; u_drag_bc, v_drag_bc, w_drag_bc = drag_boundary_conditions(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:4193,simpl,simplifications,4193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['simpl'],['simplifications']
Usability,"096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴───────────┴─────────┴─────────┘. Shallow water model weak multithreading scaling speedup; ┌───────────────┬─────────┬──────────┬────────────┬─────────┬─────────┐; │ size │ threads │ slowdown │ efficiency │ memory │ allocs │; ├───────────────┼─────────┼──────────┼────────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.0 │ 1.0 │ 1.0 │ 1.0 │; │ (8192, 1024) │ 2 │ 2.01669 │ 0.495862 │ 15.7412 │ 562.205 │; │ (8192, 2048) │ 4 │ 1.45397 │ 0.687771 │ 11.9861 │ 406.533 │; │ (8192, 4096) │ 8 │ 1.51106 │ 0.661786 │ 13.0337 │ 425.838 │; │ (8192, 8192) │ 16 │ 1.52536 │ 0.655582 │ 13.4078 │ 397.94 │; │ (8192, 16384) │ 32 │ 1.79793 │ 0.556195 │ 17.7701 │ 481.816 │; └───────────────┴─────────┴──────────┴────────────┴─────────┴─────────┘. ```; They're not terrific, but they're decent. I am running these on 32 CPUs, so what I assume is 1 thread per CPU up to 32 threads. The slight increase in efficiency going from 2 to 4 threads is likely some flat overhead being overcome by actual efficiency increase of multithreading. ; @christophernhill @glwagner is there anything we can do to improve multithreading efficiency for Oceananigans? It might not be as simple as adding `@threads` in front of the main for loops but with just a little bit of improvement then multithreading efficiency might just match MPI efficiency.; As it is, multithreading is already a worthwhile option to achieve speedups on systems with multiple CPUs but no MPI. So far I've only run the scripts on one node up to 32 threads and CPUs. I'll update this issue with the result of running it on multiple nodes going up to 64 or maybe 128 CPUs just to see if efficiency is affected going from one node to more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861:3176,simpl,simple,3176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861,1,['simpl'],['simple']
Usability,": T; end; ```. where `α` is the thermal expansion coefficient and `β` is the haline contraction coefficient.; Including only parameters that are explicitly used is important for avoiding problems and confusion in the future with the addition of new types, features and functionality. Finally, we must discuss the functions that are associated with buoyancy. Previously, it was proposed that we use a function called `buoyancy`. However, this was rejected. I believe the reason (please clarify if I am wrong) was that these semantics do not generalize properly to the case of a nonlinear equation of state and may lead to bugs and confusion in the future. To solve the aforementioned issues, I propose that we require each buoyancy type to define (at least) three functions:. 1) `buoyancy_perturbation(i, j, k, grid, buoyancy, C)`, or perhaps just `b′`, which computes the perturbation from a (possibly compression-related and z-dependent) background given the tracers `C`. In the case of `TracerBuoyancy`, this simply returns `C.b[i, j, k]`. In the case of `buoyancy::Nothing`, this returns `0`. In the case of a linear equation of state for seawater, we might have . ```julia; function buoyancy_perturbation(i, j, k, grid, buoyancy, C); return buoyancy.gravitational_acceleration * (; buoyancy.equation_of_state.α * C.T[i, j, k]; - buoyancy.equation_of_state.β * C.S[i, j, k] ); end; ```. for example. @jm-c @christophernhill @johncmarshall54 @rafferrari please advise that this concept will work with our algorithm as it stands, and that it generalizes to nonlinear equations of state (for example, do we need the pressure field as well?). 2) `total_buoyancy(i, j, k, grid, buoyancy, C)`, which returns the total buoyancy, perturbation plus background (is this needed?). 3) `total_buoyancy_gradient` and `perturbation_buoyancy_gradient` which returns the buoyancy gradients needed for turbulence closures, parameters, and such. @jm-c @christophernhill @johncmarshall54 @rafferrari, please advise if ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/403:3061,simpl,simply,3061,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/403,1,['simpl'],['simply']
Usability,"> Is this for examples and docs? It does obviously read better; I'm not sure about the downside of name proliferation. Maybe we can stew on it and update in a future PR?. I was thinking both, i.e. encourage their use to improve script readability. Yeah we can just update things as we go along. I guess the downside is that new users may not immediately notice that these common words, e.g. `minutes`, are actually being exported by `Oceananigans.Utils`. Perhaps if they were exported by a submodule like `Oceananigans.Units` that would be clearer. Also, newcomers to Julia may not realize that you can write things like `2π` or `3hours` but this should not stop us from using this nice language feature. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1075:540,clear,clearer,540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1075,1,['clear'],['clearer']
Usability,@JuliaRegistrator register(). Bug fix in PR #337 is important for GPU usability so releasing a new patch.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/339:70,usab,usability,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/339,1,['usab'],['usability']
Usability,@JuliaRegistrator register(). The sophisticated `set!` function introduced in PR #343 is important for usability so releasing a new patch that incorporates it.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/345:103,usab,usability,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/345,1,['usab'],['usability']
Usability,"@ali-ramadhan and I have discussed a potential redesign of `Simulation` and `run!` that has several key features:. 1. Coalesce all of the ""callbacks"" (arbitrary functions that are executed during a time-stepping loop) other than `OutputWriter`s into a single list. Current objects that we can classify / redesign as callbacks are: stop criteria, `TimeStepWizard`, and diagnostics. All callbacks are required to possess `callback.schedule`, and we can provide convenience objects for coupling simple callback functions to `AbstractSchedule`. 2. Within the time-stepping loop, execute `simulation.callbacks` prior to writing output. This ensures that data calculated in a callback can be output during the same time-step, such as `WindowedTimeAverage` and other non-local-in-time output. 3. Wrap the time-stepping loop inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138:492,simpl,simple,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138,1,['simpl'],['simple']
Usability,"@ali-ramadhan etc... the function index here. https://climate-machine.github.io/Oceananigans.jl/stable/function_index/. seems to miss a bunch of functions. It would be more useful if it had all the functions. . For example ```compute_w_from_continuity!``` appears from ``` Oceananigans.jl/src/TimeSteppers/kernels.jl```, but lots of other functions in their don't. Looking at code its not clear to me why that is. Is there a way to get all functions in the index?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/599:389,clear,clear,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/599,1,['clear'],['clear']
Usability,"@ali-ramadhan this looks odd to me; https://github.com/ali-ramadhan/OceanDispatch.jl/blob/c4aaa79323008270294d9052c088da7ddaf47fb2/src/operators.jl#L34. if I do ; ```; julia> a=Vector(1:4);circshift(a,1); ```; I get; ```; 4-element Array{Int64,1}:; 4; 1; 2; 3; ```. doesn't this mean that ; ```; δˣ(f) = (f .- circshift(f, (1, 0, 0))); ```. is more intuitively. ```; δˣ(f) = (circshift(f, (1, 0, 0)) .- f); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/9:349,intuit,intuitively,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/9,1,['intuit'],['intuitively']
Usability,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1232:566,simpl,simply,566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"@glwagner Mostly a couple of notes of where I was in case you're thinking of working on the abstractions:. Currently `Field` is a struct with an `f::Array` in them, and are collected together in a struct of type `FieldCollection`. This kind of sucks because to create a new set of velocity + tracer fields and set the surface temperature field to 300 K for example, the code looks like:; ```; using OceanDispatch; g = RegularCartesianGrid((100, 100, 50), (2000, 2000, 1000), Float64); fs = Fields(g); fs.θ.f[:, :, 1] .= 300; ```; when I think it would be much more intuitive to be able to just write `fs.θ[:, :, 1] .= 300`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/5:565,intuit,intuitive,565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/5,1,['intuit'],['intuitive']
Usability,"@johncmarshall54 has suggested we switch to a full equation of state for seawater for LESbrary simulations as temperature and salinity profiles from state estimates may not be statically stable in Oceananigans when using a linear equation of state. The Roquet et al. (2015a) idealized nonlinear equation of state should be better. Ideally we would use the same equation of state as ECCO/SOSE I think, but TEOS-10 should be what we aim for I suppose. I think we have a couple of options:; 1. There's a Julia wrapper for the TEOS-10 C library but this probably won't work on the GPU: https://github.com/ax1ine/GSW.jl; 2. A 6+52-term polynomial approximation to TEOS-10, accurate to ~0.1% and suitable for Boussinesq models, from Roquet et al. (2015b). We can code up a pure Julia version as there already exist Python, MATLAB, and Fortran implementations here: https://github.com/fabien-roquet/polyTEOS (Thank you @fabien-roquet!). In implementing a pure Julia TEOS-10 equation of state we should make sure it can be shared between Oceananigans and CliMA Ocean (cc @blallen). cc @jm-c @christophernhill @glwagner @rafferrari who might have suggestions or comments. @leios Do you think evaluating a 52-term polynomial at every grid point will be problematic on the GPU? I imagine GPUs should be fast at evaluating polynomials but maybe we have to be smart about storing the coefficients in memory?. References:; 1. Roquet et al. (2015a), ""Defining a Simplified Yet “Realistic” Equation of State for Seawater"", DOI: https://doi.org/10.1175/JPO-D-15-0080.1; 2. Roquet et al. (2015b), ""Accurate polynomial expressions for the density and specific volume of seawater using the TEOS-10 standard"", DOI: https://doi.org/10.1016/j.ocemod.2015.04.002",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/692:1447,Simpl,Simplified,1447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692,1,['Simpl'],['Simplified']
Usability,"@johncmarshall54 suggested it might be a bit dangerous to assume default boundary conditions, so they should always be specified. Worth discussing as this might apply to other model properties too. A common question for simple model setups is ""what are the boundary conditions?"".",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/459:220,simpl,simple,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/459,1,['simpl'],['simple']
Usability,"@liuchihl and I are trying to implement forcing functions that depend the tracer diffusivity. It is clear how to do this for a `ScalarDiffusivity` but not for a flow-dependent closure such as `SmagorinskyLilly`. The root of the problem seems to be that forcing functions only have access to the model `grid` and a limited tuple of `model_fields`. Since [diffusivities are also treated as `Fields` internally](https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/diffusivity_fields.jl), it is not clear to me why these are not included in the `model_fields` tuple that is passed to the Forcing function:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L203-L204. Maybe what I am asking for is the same thing as suggested by this comment:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/Models.jl#L124-L126",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582:100,clear,clear,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582,2,['clear'],['clear']
Usability,"@mukund-gupta discovered a bug (see #1104) that prevents the use of function diffusivities with the `TimeStepWizard`. We don't want the wizard to be so all-powerful that it samples a diffusivity function over the whole grid just to compute it's maximum value. So, this PR does the simple thing and avoids limiting the time-step by the diffusivity when it's a function. A better solution would require users to explicitly ask their time-step to be limited by diffusivities, and for that step to fail when the diffusivity is a function (eg #1087). It could make sense to add a test for all possible combinations of diffusivities and wizards, but it might be better to wait for a more comprehensive PR that addresses #1087... Resolves #1104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1105:281,simpl,simple,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1105,1,['simpl'],['simple']
Usability,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59:397,guid,guidance,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59,2,"['guid', 'simpl']","['guidance', 'simple']"
Usability,"@simone-silvestri brainstormed today about ways to clean up `TurbulenceClosures`. One idea that came up is to combine `IsotropicDiffusivity` and `HorizontallyCurvilinearAnisotropicDiffusivity` into a single `ScalarDiffusivity` (where isotropy in various directions is _implied_). We'll also simplify the ""anisotropic"" diffusivity in this process. The user interface could look something like. ```julia; three_dimensional_diffusivity = ScalarDiffusivity(ThreeDimensional(), ν=1); horizontal_diffusivity = ScalarDiffusivity(Horizontal(), ν=1); vertical_diffusivity = ScalarDiffusivity(Vertical(), ν=1); ```. so, no more `νh` and `νz`. The advantage is that we eliminate / share much more code. Arguably the API is a bit cleaner as well. (We can discuss aliases and defaults like `HorizontalScalarDiffusivity`, etc.). Under the hood we'll add the `Directionality` type to the type parameters of `ScalarDiffusivity`:. ```julia; struct ScalarDiffusivity{TimeDisc, Nu, Kappa, Directionality} <: AbstractScalarDiffusivity{TimeDisc, Dir}; ν :: Nu; κ :: Kappa. function IsotropicDiffusivity{TimeDisc}(dir::Dir, ν::Nu, κ::Ka) where {TimeDisc, Dir, Nu, Ka}; return new{TimeDisc, Nu, Ka, Dir}(ν, κ); end; end; ```. Then `abstract_isotropic_diffusivity.jl` becomes `abstract_scalar_diffusivity.jl`, and will implement the necessary abstractions for 3D isotropic scalar diffusivities, horizontally-isotropic diffusivities (a la MITgcm), and vertical diffusivities. . Consolidating code is an important precursor to a larger refactor that might. 1) support `AbstractOperation` viscosities and diffusivities at all locations on the grid; 2) eliminate `diffusivity_fields` and; 3) perhaps also involve fixing `TwoDimLeith` and implementing a biharmonic Leith.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2239:291,simpl,simplify,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2239,1,['simpl'],['simplify']
Usability,"@thabbott and I have been thinking about potential ways we can reuse LES/turbulence closures between incompressible and compressible models. One approach we came up is for all turbulence closures to define functions for the SGS stress tensor like ∂ⱼτᵢⱼ where τᵢⱼ = νˢᵍˢSᵢⱼ and where νˢᵍˢ will dispatch on the type of closure while the strain-rate tensor Sᵢⱼ will dispatch on whether the model is compressible or incompressible. For compressible models, Sᵢⱼ will instead compute and return the _traceless_ strain-rate tensor Sᵢⱼ - ⅓Sₖₖδᵢⱼ. A turbulence closure can define ∂ⱼτᵢⱼ directly to elide or short circuit computations or in case the SGS stress tensor is not of the form ∂ⱼτᵢⱼ = νˢᵍˢSᵢⱼ. Still learning more about this topic but it seems that as a start, just using the traceless strain-rate tensor for compressible models allows us to reuse a closure from an incompressible model. @thabbott suggested that νˢᵍˢ might have to dispatch on the thermodynamic variable as well. Is this true for the viscosity or only the diffusivities κˢᵍˢ? I.e. do we have to treat SGS fluxes of moisture and energy in a special way?. Couple of useful references for compressible LES (mostly with dynamic Smagorinsky):; 1. Moin et al. (1991), A dynamic subgrid‐scale model for compressible turbulence and scalar transport: https://doi.org/10.1063/1.858164; 2. Chai & Mahesh (2012), Dynamic k-equation model for large-eddy simulation of compressible flows: https://doi.org/10.1017/jfm.2012.115. ---. Some notational and misc. changes I'd like to make:. 1. Rename `∂ⱼ_2ν_Σ₁ⱼ` to `∂ⱼτ₁ⱼ` as τᵢⱼ = 2νSᵢⱼ is would no longer be true for `CompressibleModel`, it's τᵢⱼ = 2νSᵢⱼ + λSₘₘδᵢⱼ where λ is the _second viscosity_, or τᵢⱼ = 2μ(Sᵢⱼ - ⅓Sₖₖδᵢⱼ) + μᵥSₖₖδᵢⱼ where μᵥ is the _bulk_ or _volume viscosity_. 2. For constant isotropic viscosity: rename `∂ⱼνᵢⱼ∂ᵢu` to `ν∇²u`. For constant isotropic diffusivity: rename `∂ⱼκᵢⱼ∂ᵢc` to `κ∇²c`. 3. For constant anistropic viscosity: rename `∂ⱼνᵢⱼ∂ᵢu` to `νⱼ∂ⱼ²u`. For constant anis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/654:700,learn,learning,700,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/654,1,['learn'],['learning']
Usability,"A Simple preliminary way to use our advection reconstruction stencils to do high-order Coriolis reconstruction. ```; advection = WENO(grid); coriolis = HydrostaticSphericalCoriolis(scheme = advection); ```. this PR is here just to test the idea, but the design will probably change",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2729:2,Simpl,Simple,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729,1,['Simpl'],['Simple']
Usability,"A better name for `NoPenetration` is zero `NormalFlow`. Rather than `NoPenetration`, we can use. ```julia; BoundaryCondition(NormalFlow, 0); ```. This name makes it more clear that this boundary condition can only be applied to the velocity component normal to a `Bounded` boundary. It will also allow the specification of non-zero normal flow on a boundary, or ""open"" boundaries. Currently the user doesn't touch these boundary conditions (no penetration boundary conditions are determined automatically through the grid topology), so this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/703:170,clear,clear,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/703,1,['clear'],['clear']
Usability,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2180:106,user-friendly,user-friendly,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180,1,['user-friendly'],['user-friendly']
Usability,"A few ideas:. 1. Allow `grid` as a positional argument so we can write `WENO5(grid)` rather than `WENO5(grid=grid)`; 2. Emit a warning about ""stretched WENO"" in the model constructor rather than `WENO5`. It's misleading to throw a warning when using WENO5 on a uniform grid; we should only throw a warning if users specify `WENO5` with a stretched grid.; 3. Alternatively to 2, we can re-build WENO in model constructors with a `validate_advection` method. We already have `validate_momentum_advection` for hydrostatic models:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L127. The downside to 3 is that it's bad for testing, since it might _prevent_ us from using the ""uniform"" flavor of WENO on stretched grids. (@simone-silvestri is that true?) Also something that's not clear to me --- @simone-silvestri do coefficients like. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L30. become `Nothing` in regular directions, even with `WENO5(grid=grid)`? Or are they only `Nothing` for `WENO5()`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2271:891,clear,clear,891,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271,1,['clear'],['clear']
Usability,A longer-term solution for efficient global ocean simulations is to implement a split-explicit time-stepping scheme. The first step should involve a simple but stable method where efficiency/accuracy tests can be performed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2012:149,simpl,simple,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2012,1,['simpl'],['simple']
Usability,Add contributing section to README and contributor's guide,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/436:53,guid,guide,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/436,2,['guid'],['guide']
Usability,Adds a correct simplified Inverse preconditioner,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2141:15,simpl,simplified,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2141,2,['simpl'],['simplified']
Usability,Adds instruction for building docs locally in the Contributors Guide,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1389:63,Guid,Guide,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1389,1,['Guid'],['Guide']
Usability,Adds simple script for profiling NonhydrostaticModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1914:5,simpl,simple,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1914,2,['simpl'],['simple']
Usability,"After discovering FourierFlows I guess it was only time before I came across Oceananigans. Great name by the way!. I would be interested in contributing to this and might even be able to get students to work on this as well. I am brand new to this repo and CliMA but am keen to learn more and work on something. . I have some ideas but also wonder what are the top 10 things that you want to have done now. If chatting would be easier, I'm happy to organize that sometime.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153:278,learn,learn,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153,1,['learn'],['learn']
Usability,"Ah sorry I accidently merged yesterday without addressing this point. Dellar (2011) and other literature I've read commonly use f and f̃ (`\tilde{f}`) to refer to `fz` and `fy`, although I think `fz` and `fy` is clearer and we did decide to switch to `fz` and `fy` at some point. Following the same logic, `βz` and `βy` would be both consistent and clearer. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/899#discussion_r483949249_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/918:212,clear,clearer,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/918,2,['clear'],['clearer']
Usability,Allows field-dependent SimpleForcing. Updates plankton growth example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/744:23,Simpl,SimpleForcing,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/744,1,['Simpl'],['SimpleForcing']
Usability,"Apparently it's 4~5x faster to do operations on `Field.data` instead of `Field` even thought I've inlined `getindex` and `setindex!`, not that it changes things much.; ```julia; @inline getindex(f::Field, inds...) = getindex(f.data, inds...); @inline setindex!(f::Field, v, inds...) = setindex!(f.data, v, inds...); ```; Probably just missing something simple but for now I'll use `Field.data`. Would be nice to figure this out though. ```julia; g = RegularCartesianGrid((100, 100, 100), (10, 10, 10)); f1, f2 = CellField(g), FaceFieldX(g). function δx1!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf[i, j, k] = f[i, j, k] - f[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx1!(g, f1, f2); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 4.542 ms (0.00% GC); median time: 5.007 ms (0.00% GC); mean time: 5.120 ms (0.00% GC); maximum time: 11.010 ms (0.00% GC); --------------; samples: 975; evals/sample: 1; ```; ```julia; function δx2!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf.data[i, j, k] = f.data[i, j, k] - f.data[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx2!(g, f2, f1); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 1.099 ms (0.00% GC); median time: 1.198 ms (0.00% GC); mean time: 1.253 ms (0.00% GC); maximum time: 2.679 ms (0.00% GC); --------------; samples: 3967; evals/sample: 1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/13:353,simpl,simple,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/13,1,['simpl'],['simple']
Usability,"As GPUifyLoops.jl relies on Julia 1.1+, so does Oceananigans. We should print an error (there must be some Julia pattern people do here) if someone tries to run Oceananigans with Julia <1.1. Currently it's really bad for usability as Ubuntu repositories are ancient as usual and still on Julia 1.0.3, and Debian is probably even worse. And you get pretty cryptic messages if running Oceananigans from Julia 1.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/193:221,usab,usability,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/193,1,['usab'],['usability']
Usability,"As HydrostaticFreeSurfaceModel is further developed we're going to have to restructure the docs significantly. In addition to that the docs have grown a bit stale and could probably use a refresh. I think it's a good time too to leverage the year or two of experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventual",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852:558,guid,guide,558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"As of now, our tracers are advected by three ""different"" velocities ; - Velocity; - Background velocity; - Advective forcing. to these, another additional velocity is being added in PR #2802 ; All these velocities are applied differently and might have different advection schemes. This might be a headache in terms of understanding the cause of stability problems. Imagine a situation in which a model is characterized by 3 different velocities that all advect a centered second-order reconstruction of the tracer. If we run into stability problems it might not be immediately clear what the course of action is: is the instability caused by the interaction of the tracer with velocity 1, 2, or 3?. This is not the only issue with this implementation. The implementation is _wrong_ if we use an upwinding reconstruction of the tracer for any of the velocities e.g.:. Imagine we have a Background velocity $U_b = 1$ and an advective forcing $U_a = -1$ and we upwind separately.; The tracer advective flux should be zero everywhere, but, if we upwind:; $$(U_b c) + (U_a c) = c^L - c^R$$. If we want to be able to advect with different velocities consistently we have to ensure that; - the same scheme is used; - we _sum_ the velocities and _not_ apply reconstruction separately. A way to do it could by defining; ```; struct AdvectiveU{A, B, C, D}; u :: A; ubkg :: B; ufrc :: C; ubgc :: D; end. Base.getindex(u::AdvectiveU, i, j, k) = u.u[i, j, k] + u.ubkg[i, j, k] + u.ubcg[i, j, k] + u.ufrc[i, j, k]; ```; and passing this velocity to the tracer tendency kernel.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2928:578,clear,clear,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2928,1,['clear'],['clear']
Usability,"As well as more general decompositions, and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2536:340,learn,learned,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536,1,['learn'],['learned']
Usability,"At the GPU hackathon way back in June we learned that the `calculate_interior_source_terms` kernel was a bottleneck as each thread required a lot of registers. It could benefit greatly from shared memory to reduce register pressure and allow more threads to run at a time. Some preliminary work has been done in PR https://github.com/climate-machine/Oceananigans.jl/pull/293. @vchuravy has an `@stencil` abstraction in development at https://github.com/vchuravy/GPUifyLoops.jl/pull/81. But would be good to implement plain shared memory without an abstraction and see how much of a performance boost we get, especially with LES closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/442:41,learn,learned,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/442,1,['learn'],['learned']
Usability,"At the moment the error throwing in the function `validate_index()` isn't working due to an undefined variable. For indices that aren't valid, the error ends up being not useful:. ```julia; caused by: UndefVarError: I not defined; Stacktrace:; [1] validate_index(idx::UnitRange{Int64}, loc::Type, topo::Type, N::Int64, H::Int64); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:90; [2] validate_index; @ /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:94 [inlined]; ```. This PR fixes that with a simpler error message.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2824:571,simpl,simpler,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824,1,['simpl'],['simpler']
Usability,"At the moment, `derivative_operators.jl` defines second order center differencing, which is great. For ShallowWaterModel, I am splitting up the advection terms and the pressure. For advection I plan to use WENO5 and would similarly like a 4th order center differencing scheme for pressure. . The stencil for 4th order derivatives is `[-2, 16, -16, 2]/16`. . Based on that, I think a 4th oder derivative could simply be . ```@inline ∂xᶠᵃᵃ(i, j, k, grid, f::F, args...) where F<:Function = ( -2 f(i+1, j, k, grid, args...) + 16 f(i, j, k, grid, args...) - 16 f(i-1, j, k, grid, args...) + 2 f(i-2, j, k, grid, args...)) / (12 Δx(i, j, k, grid))```. My initial ideal was to add a sub or superscript 4 somewhere to denote the fact that this was 4th order. @ali mentioned that maybe we might want to dispatch based on the order. What do people think is the best way moving forward?. I don't think I would ever go higher than 4th since that makes for a much bigger stencil but if people wanted to, this could be done I suppose.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265:409,simpl,simply,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265,1,['simpl'],['simply']
Usability,"At the moment, the fill halo regions follow a particular ordering where. Flux, Value, Gradient > Periodic; Periodic > Halo Communication. where > indicates the priority of execution.; We also fill the two sides of one direction together. ; This execution order cannot be respected in case:; ```julia; bc.west isa Periodic; bc.east isa Periodic; bc.south isa Flux; bc.north isa DistributedCommunication; ```. The possible solutions are two:; - eliminate the order requirements between Flux, Value, Gradient and Periodic by including corners in all local `fill_halo_regions!` (at the moment only `Periodic` fills the corners); - do not fill two sides together. probably the first solution is better because it leads to simpler code both in terms of actual implementation and in terms of logic of execution",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3342:717,simpl,simpler,717,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3342,1,['simpl'],['simpler']
Usability,"Below is a simple script that defines an immersed boundary method for the case of a linearly sloping bottom. Nothing fancy but the resolution is very coarse. ```; using Oceananigans; Lx, Lz = 1000, 200; bottom(x) = -Lz + 2e-2*x; underlying_grid = RectilinearGrid(size = (5, 5), x = (0, Lx), z = (-Lz, 0),; topology = (Bounded, Flat, Bounded)); grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)); ```. The `z` levels are correct. ```; julia> underlying_grid.zᵃᵃᶠ[1:6, 1, 1]; 6-element Vector{Float64}:; -200.0; -160.0; -120.0; -80.0; -40.0; 0.0; ```. However, the bottom heights can't be right as they do not align with the level heights. Can someone help me find exactly where the `bottom_heights` are computed?; ````; julia> grid.immersed_boundary.bottom_height.data[1:6,1,1]; 6-element Vector{Float64}:; -198.0; -194.0; -190.0; -186.0; -182.0; -182.0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3537:11,simpl,simple,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3537,1,['simpl'],['simple']
Usability,BoundaryFunction wrapper for simple boundary condition functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/513:29,simpl,simple,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/513,2,['simpl'],['simple']
Usability,Bugfix in ModelForcing constructor for SimpleForcing of tracers,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/772:39,Simpl,SimpleForcing,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/772,1,['Simpl'],['SimpleForcing']
Usability,"Can't build docs locally based on instructions in ""Contributor's guide""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1542:65,guid,guide,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1542,2,['guid'],['guide']
Usability,Change contributor's guide to ColPrac,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1044:21,guid,guide,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1044,2,['guid'],['guide']
Usability,Clearer Model instantiation error when HAVE_CUDA=false,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/295:0,Clear,Clearer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295,1,['Clear'],['Clearer']
Usability,Clearer error in operation average constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858:0,Clear,Clearer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858,1,['Clear'],['Clearer']
Usability,Clearer names for `frequency` and `interval` for diagnostics,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/672:0,Clear,Clearer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/672,1,['Clear'],['Clearer']
Usability,"Closes https://github.com/CliMA/Oceananigans.jl/issues/1392. CC: @glwagner @ali-ramadhan . Sorry that the issue I create went so long! I was doing a bunch of wrong things but in the end it was pretty straightforward. At this point all I have is a working example of `WindowedSpatialAverage` in the sandbox and I'm creating this PR for two reasons:. - Getting feedback on possible edge cases, and maybe figuring out how the `NetCDFOutput` can infer the dimensions correctly; - Figuring out where to include this; - This isn't necessarily attached to an `OutputWriter`, so it feels odd to add it there; - Everywhere else in Oceananigans also feels inappropriate ; - Maybe add it to Oceanostics?; . Anyway, feedback is appreciated. . Also, big thanks to @ali-ramadhan for helping me out with this one.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397:359,feedback,feedback,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397,2,['feedback'],['feedback']
Usability,"Closes https://github.com/CliMA/Oceananigans.jl/issues/1478. As mentioned in https://github.com/CliMA/Oceananigans.jl/issues/1542 I couldn't build the docs locally so I probably made some markdown mistakes along the way, which is why this is a draft pull request. This first draft is also somewhat incomplete. I figured I'd create the PR early to get some feedback along the way though. I'm especially unfamiliar with the part about converting arrays to CUDA etc., so some help/collaboration there is much appreciated. CC @ali-ramadhan @glwagner @navidcy @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543:356,feedback,feedback,356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543,1,['feedback'],['feedback']
Usability,Confusing API for specifying parameters in low-level forcing functions versus `SimpleForcing`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/565:79,Simpl,SimpleForcing,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/565,1,['Simpl'],['SimpleForcing']
Usability,"Currently it is not generically possible to call. ```julia; fill_halo_regions!(field); ```. Part of this is trivial as noted in #969. But another part is that boundary conditions on fields can depend on other _other_ fields, to which `field` contains no reference. We allow field boundary conditions to depend on anything in `state(model)`, which includes the model velocity fields, tracer fields, pressure fields, and diffusivities. Because references to `state(model)` are required to fill halo regions in general, we are unable to fill halo regions prior to computing an `AveragedField` (for example). We may not _want_ to solve this problem because it require too-invasive changes. For example, we certainly want to support the concept of fields that are independent of other fields. General support for interdependent fields may be too difficult. Some possible solutions:. * an ""optional"" `state` property of `Field` which is set to `nothing` by default. We can ensure that `state` is properly determined in the constructor for `IncompressibleModel` for the model fields. * an ""optional"" `state` or `fields` property within each individual boundary condition (with a similar function as the optional property above). This property could be activated only for boundary conditions that need it (currently, only discrete form boundary conditions, though this could be extended to continuous form boundary conditions in the future via #897). Solving this will simplify time-stepping code a bit and permit simpler halo region filling via `fill_halo_regions!(field)` with no additional arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/971:1461,simpl,simplify,1461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971,2,['simpl'],"['simpler', 'simplify']"
Usability,"Currently the `Oceananigans` module exports. ```julia; Flux, Value, Gradient, NormalFlow,; FluxBoundaryCondition, ValueBoundaryCondition, GradientBoundaryCondition,; ```. so there's some redundancy (perhaps we should export one set to reduce namespace pollution) but a minor practical issue is that the `Flux` type conflicts with the popular Flux.jl package (I guess I'm the only one using them together right now but there may be more in the future?). There's also some inconsistency in exporting `NormalFlow` but not `NormalFlowBoundaryCondition`. In deciding on what to export for the user interface (see #1132) I'm wondering what do people think about only exporting the long-name version, e.g. `FluxBoundaryCondition` instead of `Flux`. I think this will have a few benefits:; 1. Lower probability for conflicts. `Flux` is one example, but `Value` and `Gradient` are pretty generic terms so I wouldn't be surprised if they conflict with exports from other packages future users may want to work with.; 2. Scripts might read more intuitively, e.g. because you say ""a flux boundary condition"" and not ""a boundary condition of type flux"".; 3. If we decide to export the complete set of boundary conditions we could do it by exporting `PeriodicBoundaryCondition` without having to worry about conflicting with the `Periodic` topology. X-Ref: #1132",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1140:1034,intuit,intuitively,1034,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1140,1,['intuit'],['intuitively']
Usability,"Currently the argument `state` used in boundary condition functions and forcing functions adopts the hierarchy in `IncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4/src/Models/Models.jl#L30-L32. so that the `u`-velocity, for example, is accessed via `state.velocities.u`. I'm wondering if we should flatten `state`:. ```julia; @inline state(model) = merge(datatuple(model.velocities), datatuple(model.tracers), datatuple(model.diffusivities)); ```. Life is a bit simpler because then all the fields are accessed via `state.u`, `state.v`, `state.T`, etc. A related question is nomenclature: we can change `state` to `fields`, or maybe `model_fields`, as there is a similar function called `fields`:. https://github.com/CliMA/Oceananigans.jl/blob/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4/src/Models/Models.jl#L34. `model_fields` is a bit more specific so might be a bit more interpretable than `state`. For users this is only a question of documentation of boundary condition forcing and forcing functions since they don't see the internal implementation anyways.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/985:523,simpl,simpler,523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/985,1,['simpl'],['simpler']
Usability,"Currently, output writers accept two types of criterion for writing output: a `time_interval`, and an `iteration_interval`. For example, a user might instantiate a `JLD2OutputWriter` with. ```julia; field_outputs = FieldOutputs(merge(model.velocities, model.tracers)). simulation.output_writers[:fields] = JLD2OutputWriter(model, field_outputs, prefix=""fields"", time_interval=2minute); ```. which specifies output every 2 minutes of simulation time. `iteration_interval` is used similarly. These criteria are triggered by the function `time_to_run`:. https://github.com/CliMA/Oceananigans.jl/blob/994eae3d4550898914309e535ccbfd4655854646/src/Utils/output_writer_diagnostic_utils.jl#L55-L65. The function `time_interval_is_ripe` is, for example,. https://github.com/CliMA/Oceananigans.jl/blob/994eae3d4550898914309e535ccbfd4655854646/src/Utils/output_writer_diagnostic_utils.jl#L46-L53. This API is simple and effective for many purposes. However, it is not general or extensible. For example, a user cannot specify output to be saved based on other criteria, like some property of the flow, or on the elapsed wall time. A more general method might use types. For example, we can define `AbstractCriterion` like `TimeInterval` and `IterationInterval`. The above example would become. ```julia; field_outputs = FieldOutputs(merge(model.velocities, model.tracers)). simulation.output_writers[:fields] = JLD2OutputWriter(model, field_outputs, prefix=""fields"", write_criterion=TimeInterval(2minute)); ```. By making the criteria callable objects, we could use syntax like `output_writer.write_criteria(model)` as a replacement for `time_to_run(clock, output_writer)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/853:898,simpl,simple,898,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/853,1,['simpl'],['simple']
Usability,"Currently, we use the constructor `output_writer.array_type` to convert array data prior to outputting:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/OutputWriters/fetch_output.jl#L17. But we should use `convert` instead, because this avoids allocating memory when no type conversion is needed:. ```julia; julia> a = rand(1, 1, 1); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b = convert(Array{Float64}, a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b === a; true; ```. so `b` is just a reference to `a`, but. ```julia; julia> c = Array{Float64}(a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> c === a; false; ```. `c` is not a reference to `a`. This matters very little since we basically always need to allocate memory to convert from Float64 to Float32. A related minor optimization would be to avoid converting views to the same type as the parent array, since we could just output those directly. I think we have to use dispatch on one of the type parameters of `SubArray` for that. But maybe simpler code is worth not implementing a minor optimization for an edge case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1182:1109,simpl,simpler,1109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1182,1,['simpl'],['simpler']
Usability,Docstring did not match the actual constructor. They do now. @suyashbire1 Do you think `clobber` should be true or false by default?. Also updated the docstring to make it clear that `outputs` needs to be a `Dict` for now. Resolves #553,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556:172,clear,clear,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556,1,['clear'],['clear']
Usability,"Even clearer `show(io, ::AbstractGrid)`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2114:5,clear,clearer,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2114,2,['clear'],['clearer']
Usability,Expands contributor guidelines,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1765:20,guid,guidelines,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1765,2,['guid'],['guidelines']
Usability,Feedback,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2:0,Feedback,Feedback,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2,1,['Feedback'],['Feedback']
Usability,First thing is simply to use more threads. But if we can uses parallelism at a little higher level we might do better.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3075:15,simpl,simply,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3075,1,['simpl'],['simply']
Usability,Fix typo in header for simple diffusion example.; It also fixes crosslinks from quickstart not working.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3554:23,simpl,simple,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3554,1,['simpl'],['simple']
Usability,Fixes timestepper docstrings and simplifies constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/977:33,simpl,simplifies,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/977,2,['simpl'],['simplifies']
Usability,Fixes typo in docs for non-traditional beta plane and simplifies language,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/978:54,simpl,simplifies,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/978,2,['simpl'],['simplifies']
Usability,"Following [Adroft et al. (1997)](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml), we are developing a **partial cell method** in the following branch: fjp/partial_cell_immersed_boundaries. Presently, we can build the mesh without any complaints, but nothing else. I thought a good first step would be to try and use `mask_immersed_field!` on a scalar field. When I try with the current set up, it doesn't complain, but it also doesn't modify the entries either. Clearly more work needs to be done. . I don't understand all of `mask_immersed_field.jl` but I wonder if we need to build a new `scalar_mask`. At present, it only works for grids that are `AbstractGridFittedBoundary`, but the new grid is not of that type. . Any advice on whether we need to create a new `scalar_mask` for dispatch? I tried something pretty simple but that had no effect so I suspect it's not being used,. ```; @inline function scalar_mask(i, j, k, grid, ::PartialCellBottom, LX, LY, LZ, value, field); return @inbounds ifelse(solid_interface(LX, LY, LZ, i, j, k, grid),; value,; field[i, j, k]); end; ```. Or maybe the problem should be solved by going into `mask_immersed_field.jl` and modifying `solid_interface`?. Any suggestions @simone-silvestri ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251:513,Clear,Clearly,513,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251,2,"['Clear', 'simpl']","['Clearly', 'simple']"
Usability,"For JOSS we need to have a helpful `CONTRIBUTING.md` file, and I thought it would be good to put one up for Hacktoberfest. I'm a big fan of MetPy's contributor's guide so I heavily based it on theirs, I don't think I could have done a better job. MetPy uses a [BSD-3-Clause](https://tldrlegal.com/license/bsd-3-clause-license-(revised)) license so I think this means we'd have to license our `CONTRIBUTING.md` file under BSD-3-Clause? @christophernhill is this an issue?. cc MetPy devs @dopplershift @jrleeman: Your MetPy contributor's guide is really excellent! I hope you don't mind if I borrowed heavily from it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/436:162,guid,guide,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/436,2,['guid'],['guide']
Usability,"For a thesis project about the migration and dispersal of fish larvae in the sea I am looking for CFD tools that allow a newcomer in this field (like myself) the simulation of agent based models (each agent represents a fish) in laminar flows and later in more realistic turbulences. I chose the following steps as milestones:. - First, as a means for validation, I will show a lid driven cavity flow (Oceananigans already does this in an example).; - After this I will combine this with an agent based model where an agent will represent a larvae. At that state the agent should follow simple rules, like drift in the direction of a laminar flow.; - If that works, I will implement a continuity equation to simulate the odor which comes from the reef and which is supposed to help the larvae to find back to the home reef.; - Next, putting n agents into the water and see, if the individuals are behaving differently when put into a swarm. . I am planning to keep this in 2D since doing it in 3D would probably be to difficult given the limited time (3 months). I will not try to simulate the exact ocean currents or the bottom of the ocean. Are you capable of assessing the suitability of Oceananigans for those steps? Is it possible to deliver those steps? . For the Agent based modelling I will be working with the [Agents.jl](https://juliadynamics.github.io/Agents.jl/stable/) package probably, since it seems well documented.; Since I have found Oceananigans, which is also a CFD tool, I was wondering what you think the differences are between that and [WaterLily.jl](https://github.com/weymouth/WaterLily.jl)? Given my description of the project above, would you tend to use either of them?; Thank you!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1438:587,simpl,simple,587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1438,1,['simpl'],['simple']
Usability,"For example, here:; https://github.com/CliMA/Oceananigans.jl/blob/6b2cea36d5782f5a73402b97f4d7476de9237c93/examples/two_dimensional_turbulence.jl#L38; clearly the initial condition is not incompressible. `set!` should somehow remove the compressible part of the initial conditions and perhaps also print out a warning so that the user knows that the model is not initialized exactly with the fields they provided?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1027:151,clear,clearly,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1027,1,['clear'],['clearly']
Usability,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1045:435,Clear,Clear,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045,1,['Clear'],['Clear']
Usability,"For example, you need values of `ΔzC[0]` and `ΔzF[0]` (in the halo regions) to compute vertical derivatives at the top and bottom. I think the halo cells in this case are all the same size and equal in size to the top-most or bottom-most cells. The simplest way to get this to work is to provide `ΔzC` and `ΔzF` as offset arrays and we won't have to do anything special at the boundaries. Hmmm, on a domain `z ∈ [0, L]` I guess a hack would be to call e.g. `ΔzC(x, y, min(max(0, z), L))` instead of `ΔzC(x, y, z)` but this seems dirty. I don't see a disadvantage of using an offset array over a function in this case. Users can specify `ΔzC` using an array or a function which we convert to an offset array. This issue also crops up in the atmosphere where you need to take derivatives of a base state, but if it's defined as a function then you run into this issue at the boundaries.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/531:249,simpl,simplest,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/531,1,['simpl'],['simplest']
Usability,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1342:1572,usab,usable,1572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342,1,['usab'],['usable']
Usability,"Forcing functions use `model.parameters` while `SimpleForcing` have their own parameters. Could be confusing as boundary condition functions also rely on `model.parameters`. To be consistent and clearer to users, I feel like `SimpleForcing` should use `model.parameters` instead of storing its own. But maybe I'm missing something and there was a good reason for this. https://github.com/climate-machine/Oceananigans.jl/blob/7080929008182b8d8e2d09e6a1de5d2f23f276d7/src/forcing.jl#L1-L13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/565:48,Simpl,SimpleForcing,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/565,3,"['Simpl', 'clear']","['SimpleForcing', 'clearer']"
Usability,"From the discussion #3587 @scott-conn found out that our definition of immersed derivatives ~~does not work very well~~ is **wrong** when using reduced fields. Consider, for example, a field reduced in z. If we try performing a derivative in the x-direction it will check the immersed condition ; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/ImmersedBoundaries/conditional_differences.jl#L21; on `k == 1`. This might be ~~very~~ wrong if the field is a sum (or a mean) over the column. ; For example, for integrals we want to check if the whole column is immersed.; If we are dealing with a `GridFittedBottom`, instead, we just need to check the upmost grid cell (`k == Nz`). We could procede in a couple of ways from here:; - use simple derivatives for `AsbtractOperations` that do not account for immersed boundaries. ; - We can augment operations on Immersed `Reduced` fields by attaching to them a `condition` like in conditional operations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588:777,simpl,simple,777,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588,1,['simpl'],['simple']
Usability,"Given that the doc examples are gonna run much faster due to https://github.com/CliMA/Oceananigans.jl/pull/3135 (I'm assuming it's gonna get merged soon) should we create an example with an immersed boundary with drag forces?. My main reasons for suggesting this are:. 1. Probably there's a lot of user interest in this application, but no example showing this capability (https://github.com/CliMA/Oceananigans.jl/pull/3132 will add an `ImmersedBoundaryGrid` example, but with default boundary conditions);; 2. Coming up with an intuitive way to impose flux boundary conditions on immersed boundaries is hard (see for example https://github.com/CliMA/Oceananigans.jl/pull/3142 and discussion in https://github.com/CliMA/Oceananigans.jl/pull/2437), so I think it'd be good to give users a guaranteed-to-work easy-to-find example to base themselves off of.; 3. I also think having such examples probably makes counter-intuitive definitions and bugs more likely to be caught (and therefore fixed) early, since it makes the `ImmersedBoundaryGrid` API more visible to users, who will be more likely to use it for explorations. So my opinion is that including an example will increase our confidence in the IBG implementation (although, again, this is already being done with https://github.com/CliMA/Oceananigans.jl/pull/3132, albeit with default BCs). If there's interest we can discuss what this example should look like. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148:529,intuit,intuitive,529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148,2,['intuit'],['intuitive']
Usability,Guidelines for style in CONTRIBUTING.md and clarity about pull requests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1801:0,Guid,Guidelines,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1801,1,['Guid'],['Guidelines']
Usability,"Hi Oceananigans Community,. As discussed with @glwagner and @johnryantaylor, I post an issue about adding Lagrangian particles to a nonuniform grid in the z-direction. Hope the following minimum working example is mini enough and bug-free. Happy to learn and discuss. . Best,; Si Chen. <details open>; <summary>Minimum Working Example</summary>. ```; using Random; using Printf; using Plots. using Oceananigans; using Oceananigans.Units: minute, minutes, hour. Nz = 24 # number of points in the vertical direction; Lz = 32 # (m) domain depth. refinement = 1.2 # controls spacing near surface (higher means finer spaced); stretching = 12 # controls rate of stretching at bottom. h(k) = (k - 1) / Nz. ζ₀(k) = 1 + (h(k) - 1) / refinement. Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1). grid = RectilinearGrid(size = (32, 32, Nz), ; x = (0, 64),; y = (0, 64),; #z = (-Lz, 0)) # Errors are gone for uniform grid ; z = z_faces). ############################ Lagrangian Particles; n_particles = 10;; x₀ = 60*rand(n_particles); ; y₀ = 60*rand(n_particles);; z₀ = -Lz*0.5*rand(n_particles); ; lagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀, restitution=0); ############################. b_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)). model = NonhydrostaticModel(advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:b,),; coriolis = FPlane(f=1e-4),; buoyancy = BuoyancyTracer(),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (b=b_bcs,),; particles=lagrangian_particles) ############################ Lagrangian Particles. bᵢ(x, y, z) = 1e-5 * z + 1e-9 * rand(). set!(model, b=bᵢ). simulation = Simulation(model, Δt=10.0, stop_time=20minutes). wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=1minute). simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). run!(simulation); ```; </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2395:249,learn,learn,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395,1,['learn'],['learn']
Usability,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:137,simpl,simplicity,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,1,['simpl'],['simplicity']
Usability,"Hi all,. I think there's been a mistake in the open boundary filling that's only becoming a problem now that we're trying to fill non-zero value. https://github.com/CliMA/Oceananigans.jl/blob/3ea2545331d9910d8b467dd8eb31074fb426af5b/src/BoundaryConditions/fill_halo_regions_open.jl#L86-L91. The open fill has always set point at index `1` on the right hand side and `grid.N+1` on the right hand side, but `1` is part of the prognostic domain and halo points we need are just for computing gradients at the face point, which should be at `0`. I came across this because I've only been testing open boundaries on the right side, but was checking it worked in the other directions and realised it always failed when I just switched the direction and sides for a simple case. Am I missing something here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810:759,simpl,simple,759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810,1,['simpl'],['simple']
Usability,"Hi all,. Thanks, @glwagner for creating the [PR](https://github.com/CliMA/Oceananigans.jl/pull/3660) for solving the issue of `TimeInterval`. After merging it, I noticed a potential problem related to `AveragedTimeInterval`. Specifically, when resuming from a checkpoint, discontinuity seems to occur. For instance, in the figure below, the tidally averaged velocity is saved for each tidal period. The first run covers days 0-20, and the second run covers days 20-40. A noticeable discontinuity appears at the checkpoint transition from the first run.; <img width=""301"" alt=""image"" src=""https://github.com/user-attachments/assets/ffe04dc8-d829-49a7-8052-0b5a58c2b9a3"">. Here is a MWE for this issue:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670:844,simpl,simple,844,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670,1,['simpl'],['simple']
Usability,"Hi all,; I have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference?; ![u_profile (2)](https://github.com/CliMA/Oceananigans.jl/assets/117068415/14e2c865-ec3b-4065-a13a-213a99257d31); ![uw_flux (1)](https://github.com/CliMA/Oceananigans.jl/assets/117068415/1cd16836-6f59-465b-8d02-0577052b52ba). ```julia; const H=15 #/m; grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); const u★=0.01 #friction velocity; Fx(x,y,z,t)=u★^2/H #forcing. const z₀ = H*1e-4 # m (roughness length); const κ = 0.4 # von Karman constant; const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient. @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v). drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)). u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); v_bcs = FieldBoundaryConditions(bottom = drag_bc_v). model = NonhydrostaticModel(; grid, coriolis,; advection = WENO(),; timestepper = :RungeKutta3,; tracers =(:T,:S),; buoyancy = SeawaterBuoyancy(),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; forcing=(u=Fx,)); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195:45,simpl,simple,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195,1,['simpl'],['simple']
Usability,"Hi all,; We have come across what seems to be a bug in background_fields. This arose in another context, but the code below is the simplest way that I have come up with so far that demonstrates the problem. Here there is a stable linear buoyancy profile (imposed as a background gradient) with random noise for the initial velocity. This generates extra turbulence at the top and bottom. I wonder if the background gradient in the halo region isn't playing nicely with the initial conditions. Has anyone else seen something like this or have any ideas for where to look for the problem?; I am using Julia 1.9.2 and Oceananigans 0.85.0; Thanks!; John. ```julia; using Oceananigans; using JLD2; using Plots; using Printf. Lx = 1; Lz = 1; Nx = 64; Nz = 64. grid = RectilinearGrid(size=(Nx, Nz), x=(0, Lx), z=(0, Lz), topology=(Periodic, Flat, Periodic)). # Create a stable background buoyancy gradient; N = 1 # buoyancy frequency [s⁻¹]; B_func(x, y, z, t, N) = N^2 * z; B = BackgroundField(B_func, parameters=N). model = NonhydrostaticModel(; grid,; advection = WENO(),; timestepper = :RungeKutta3,; closure = ScalarDiffusivity(ν=1e-6, κ=1e-6),; tracers = :b,; buoyancy = BuoyancyTracer(),; background_fields = (; b=B)) # `background_fields` is a `NamedTuple`. A=0.01; u_ic(x,y,z) = A * randn(); w_ic(x,y,z) = A * randn(). set!(model, u=u_ic, w=w_ic). simulation = Simulation(model, Δt = 0.01, stop_iteration=200). wizard = TimeStepWizard(cfl=0.3, diffusive_cfl=0.3, max_change=1.2, max_Δt=1); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(1)). progress(sim) = @printf(""i: % 6d, sim time: % 1.3f, wall time: % 10s, Δt: % 1.4f, advective CFL: %.2e, diffusive CFL: %.2e\n"",; iteration(sim), time(sim), prettytime(sim.run_wall_time),; sim.Δt, AdvectiveCFL(sim.Δt)(sim.model), DiffusiveCFL(sim.Δt)(sim.model)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""background_field_test""; simulation.output_writers[:velocities] = JLD2OutputWriter(model",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364:131,simpl,simplest,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364,1,['simpl'],['simplest']
Usability,Hi devs. This is not an issue but more of comment. I will immediately close this after some feedbacks. . I was wondering if Oceananigans in its current form has support for coastal or regional modelling? I ask because my impression is that Oceananigans follows similar paradigm as MITgcm with the latter seemingly used in regional ocean modelling. Are there plans to use the model for such setup? What will it takes for the community to get to such level? . Thanks.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3269:92,feedback,feedbacks,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3269,1,['feedback'],['feedbacks']
Usability,"Hi,. I have been confused about what the `max_change` and `min_change` means.; I understand from the documentation that this is to avoid the time step to change too quickly, but how is it used?. Is it in time units? e.g., taking the default `max_change` of 1.1, that means that for dated simulation it will change the time step at max in 1.1 seconds? . Is it a multiplication? e.g., `new_time_step = 1.1*time_step` ?. I think we can try to be more clear about that in the docs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3244:448,clear,clear,448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3244,1,['clear'],['clear']
Usability,"Hi,; I have been working with a shallow water model simulation that consists simply of a stochastic height field as the initial condition. It's been working well on a 2pi by 2pi domain without using the Units module. . However, once I tried to scale this same simulation to a 2000km by 2000km domain, I encountered some issues. Specifically, it seems the simulation becomes static. The output I'm viewing is just the height field animation. I also apologize if the initial condition code is confusing and added an image of the initial height function. I scaled the initial height function to match the domain so that should not be a source of bugs, theoretically. I've been testing and trying to fix this issue but am not sure what to do. . Thanks for any help or advice!. **Code:**; ```; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; using Oceananigans.Units. #Parameters; Nx, Ny = 128, 128; Lx = 1000kilometer; Ly = 1000kilometer. grid = RectilinearGrid(size = (Nx, Ny),; x=(-Lx, Lx), y=(-Lx, Ly),; topology = (Periodic, Periodic, Flat)). model = ShallowWaterModel(; grid=grid,; gravitational_acceleration=9.81,; coriolis=FPlane(f=1),; ). #SMOOTH RANDOM FUNCTION; using Random; Random.seed!(17). n = 16; m = 16; len = n * m * 4. global alea; alea = rand(-1:1, (n, m, 4)). function rand_smth(x::Float64, y::Float64); X = x / 1000000; Y = y / 1000000; val = 0; for i in 1:n; for j in 1:m; ar = alea[i,j,1]; br = alea[i,j,2]; cr = alea[i,j,3]; dr = alea[i,j,4]; val += ar * cos(i * x) * cos(j * y); val += br * cos(i * x) * sin(j * y); val += cr * sin(i * x) * cos(j * y); val += dr * sin(i * x) * sin(j * y); end; end; return val; end; #End of smooth random function. H = 1kilometer # unperturbed layer depth. h₀(x, y, t) = H + rand_smth(x,y). set!(model, h=h₀). uh, vh, h = model.solution. simulation = Simulation(model, Δt=0.002, stop_iteration=10000). using Oceananigans.OutputWriters: JLD2OutputWriter, IterationInterval. simulation.output_writers[:fields] =; JLD2OutputWriter(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2671:77,simpl,simply,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2671,1,['simpl'],['simply']
Usability,How to handle boundary conditions nicely? User-friendly API + kernels that support multiple BCs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/86:42,User-friendly,User-friendly,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/86,1,['User-friendly'],['User-friendly']
Usability,"I am attempting to use`ConjugateGradientPoissonSolver` in my simulation, but the error specifically occurs when the grids are stretched. The error happens when running either `fft_poisson_solver(grid.underlying_grid)` or `ConjugateGradientPoissonSolver(grid; preconditioner, maxiter=20)`. . The error message: ; ```; ERROR: type RectilinearGrid has no field underlying_grid; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] fft_poisson_solver(grid::RectilinearGrid{…}); @ Oceananigans.Solvers ~/code/Oceananigans.jl/src/Solvers/Solvers.jl:55; [3] top-level scope; @ REPL[7]:1. ```; I don't understand why there is no `underlying_grid`, which clearly exists.; Here is the MWE that I slightly modified from https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426, thanks to @ali-ramadhan, @glwagner ; ```julia; using Printf; using Statistics; using Oceananigans; using Oceananigans.Grids: with_number_type; using Oceananigans.BoundaryConditions: FlatExtrapolationOpenBoundaryCondition; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver; using Oceananigans.Utils: prettytime. N = 16; h, w = 50, 20; H, L = 100, 100; x = y = (-L/2, L/2). # Create stretched vertical grid; kwarp(k, N) = (N + 1 - k) / N; # Linear near-surface generator; ζ(k, N, refinement) = 1 + (kwarp(k, N) - 1) / refinement; # Bottom-intensified stretching function; Σ(k, N, stretching) = (1 - exp(-stretching * kwarp(k, N))) / (1 - exp(-stretching)); # Generating function; z_faces(k) = - H * (ζ(k, N, 1.2) * Σ(k, N, 15) - 1); z = z_faces. # uniform vertical grid; # z = (-H, 0). grid = RectilinearGrid(size=(N, N, N); x, y, z, halo=(2, 2, 2), topology=(Bounded, Periodic, Bounded)). mount(x, y=0) = h * exp(-(x^2 + y^2) / 2w^2); bottom(x, y=0) = -H + mount(x, y); grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). prescribed_flow = OpenBoundaryCondition(0.01); extrapolation_bc = FlatExtrapolationOpenBoundaryCondition(); u_bcs = FieldBoundaryConditions(west = p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3889:653,clear,clearly,653,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3889,1,['clear'],['clearly']
Usability,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549:1375,simpl,simply,1375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549,1,['simpl'],['simply']
Usability,"I feel like this impacts usability, especially interactive use, but it's not a bug in the sense that your simulation scripts are fine. Is it worth trying to fix this?. Maybe not. After all, executing `model.velocities.u.data` in the REPL with a GPU model produces a similar error to the one below. One nuclear option is to allow scalar operations in `show` methods, but in this particular example it's for a `SubArray{OffsetVector{CuArray}}` so not a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/Offs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:25,usab,usability,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,1,['usab'],['usability']
Usability,"I have been exclusively using the netCDF output option and, after upgrading to v0.44.2, I've noticed the behavior of `NetCDFWriter` changed. . - First thing is that I get a message that the mode hasn't been set even when it has, which seems like a bug to me. So, for example, setting the writer as . ```; using Oceananigans.OutputWriters. outputs_netcdf = (u = model.velocities.u,; v = model.velocities.v,; ). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, outputs_netcdf,; filepath = ""mwe.nc"",; schedule = TimeInterval(5seconds),; mode = ""c""); ```. I get a warning saying `mwe.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file.`, even though the mode is clearly set to clobber. And sure enough, if I run the simulation it appends to the previous netcdf file. (Also, the docs still say that the default mode is `""c""`, but it now changed to `""a""`). - The other thing is that after I set up the `NetCDFWriter` the file is always open by the Julia REPL and unreachable from anywhere else. So for example if I want to check on the simulation by opening the output netcdf file with Python I get an error saying that the file is being used. So I need to either make a copy of the file and access the copy (which uses up space) or wait for the simulation to finish, which isn't ideal. I can't imagine opening and closing a netCDF file takes long (especially since we ideally won't write to it at every time step), so is there a reason for the netCDF file to always stay open inside Julia?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227:757,clear,clearly,757,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227,1,['clear'],['clearly']
Usability,"I have been thinking that we should expand a bit our Smagorinsky models.; Currently the only Smagorinsky-type model we have is the Smagorinsky-Lilly, which works well in some cases, notably the canonical horizontally-periodic turbulence, but has some downsides for more complex flows. For example when turbulence is not heterogeneous, or when there are persistent mean gradients in the flow. AMD is a good option in some cases, but often there are numerical artifacts in stratified, laminar regions in the flow (I don't think it's clear exactly what causes this, but it happens in many of my simulations, and I've herd similar things from others). So I think having at least one option to run a dynamic Smag would be good. One possibility is that, as a start, we allow for user-defined Smagorinsky coefficients that could depend on the velocities. Something like. ```julia; cₛ(i, j, k, grid, C::Function) = C(i, j, k, grid, u, v, w); ```; where `C(i, j, k, grid, u, v, w)` is provided by the user. That would allow the user a bit more control, and they could implement local dynamic Smag models, such as the [dynamic gradient Smagorinsky](https://journals.aps.org/prfluids/abstract/10.1103/PhysRevFluids.7.074604). Something similar is currently done for AMD, although I think it's a bit more restrictive than what I'm proposing. Soon, if there's interest, I'm planning on implementing a scale-independent Smagorinsky that's averaged in the symmetric flow directions (generally this is referred to as Planar-Averaged Scale-Independent Smag, but we wouldn't be limited to a planar average in our case). From then on, the extension to a Langrangian-Averaged Scale-Independent Smag would be straightforward. Eventually it would be nice to extend these to a Scale-_dependent_ model, but I think it's wise to start with the simpler cases. How do people feel about this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637:531,clear,clear,531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637,2,"['clear', 'simpl']","['clear', 'simpler']"
Usability,"I have modified the [simple 1D diffusion example](https://clima.github.io/OceananigansDocumentation/v0.90.13/literated/one_dimensional_diffusion/) to test how to correct the boundary conditions by using the gradient boundary condition, the script can be found [here](https://github.com/liuchihl/Simple-tests/blob/85f34ec2443a6ff9860f5adfbc68ff39995f00bb/1Ddiffusion_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568:21,simpl,simple,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568,3,"['Simpl', 'simpl']","['Simple-tests', 'simple']"
Usability,I have recently realized that the current definition of `gravity_unit_vector` is a vector that's in the _opposite_ direction to gravity:. https://github.com/CliMA/Oceananigans.jl/blob/10a9479ec462f4f5f053e7447ff667fdfe20542d/src/BuoyancyModels/buoyancy.jl#L11-L13. This sounds counter-intuitive to me. I wonder if we can come up with a better name. Maybe `buoyancy_unit_vector`? It can't be something like `vertical_unit_vector` because then we'd potentially run into inconsistencies (see https://github.com/CliMA/Oceananigans.jl/pull/2266).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2356:285,intuit,intuitive,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356,1,['intuit'],['intuitive']
Usability,"I just updated my packages and now I get an error .... UndefVarError: RectilinearGrid not defined; Stacktrace:; [1] top-level scope; @ In[8]:18; [2] eval; @ .\boot.jl:360 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base .\loading.jl:1116. ....with even the simples grid-defenition, e.g. ; ```; Nz = 24 # number of points in the vertical direction; Lz = 32 # domain depth; grid = RectilinearGrid(size = (32, 32, Nz),; x = (0, 64),; y = (0, 64),; z = (-64, 0)); ```; What am I doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2077:324,simpl,simples,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2077,1,['simpl'],['simples']
Usability,I noticed that in a couple of tests in `test_grids.jl` the code was written in way that leads to some not-so-clear statements such as:. https://github.com/CliMA/Oceananigans.jl/blob/182e75c80645af0d6a7105ed2d8d4fcbceb7bccc/test/test_grids.jl#L381. The above seems wrong at first but it's actually correct since `Δzᵃᵃᶜ()` is defined the same way as `grid.Δzᵃᵃᶠ`. This PR changes that to make the notation clearer (i.e. `grid.Δzᵃᵃᶠ[2:Nz] == Δzᵃᵃᶠ.(2:Nz)`) and condenses 3 separate test functions for stretched grids (needing three separate grid instantiations) into one function (with the same tests). EDIT:. This also implements a suggestion by @glwagner in https://github.com/CliMA/Oceananigans.jl/pull/2865 that couldn't be implemented then. I'll open another PR in the near future to further condense some other tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2917:109,clear,clear,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2917,2,['clear'],"['clear', 'clearer']"
Usability,"I noticed that in the `Periodic` directions, particles that have coordinates within the last cell at the end of the domain get moved into the first cell when I think it should not be. Here's a MWE:. ```julia; using Oceananigans; using Oceananigans.Units; using StructArrays; using Printf; using Random; using Statistics. grid = RectilinearGrid(CPU(), Float64,; size = (2, 2, 2),; halo = (5, 5, 5),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). struct SimpleParticle{X}; x :: X; y :: X; z :: X; end. n_particles = 5; x_particle = collect(range(0, stop=1, length=n_particles)); y_particle = collect(range(0, stop=1, length=n_particles)); z_particle = collect(fill(-0.5, n_particles)). particles = StructArray{SimpleParticle}((x_particle, y_particle, z_particle)). lagrangian_particles = LagrangianParticles(particles). model = NonhydrostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1seconds, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. Here's the output log of the script:; ```; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 74.284 ms, max(u): (0.000e+00, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3415:489,Simpl,SimpleParticle,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3415,2,['Simpl'],['SimpleParticle']
Usability,"I noticed that the [Ocean wind mixing and convection](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/#The-grid) example now went back to a simpler `VerticallyStretchedGrid` that's hyberbolically-spaced. This is mostly fine, but just to give a bit of context: originally that example had a simple hyperbolic function, but that meant that the spacing in the mixed layer changed relatively fast, which is numerically undesirable. Because of that, we had changed that to a more complex function that preserved approximately constant spacing near the top, where we care more about the dynamics: https://github.com/CliMA/Oceananigans.jl/pull/1810. For some reason this was changed back to a simple function here: https://github.com/CliMA/Oceananigans.jl/commit/335e47659a11b92df32bf844cebe6e518dec9fc8; It was a pretty big PR so I didn't notice it at the time and couldn't comment on it. I also don't understand why this was changed in that PR, since it doesn't seem to relate to the PR title. In any case, I was wondering if we should again change the vertical spacing function the a function that approximately preserves constant spacing in the mixing layer. Unless there's a reason to keep the hyperbolic function, I don't see why not.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2043:192,simpl,simpler,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2043,3,['simpl'],"['simple', 'simpler']"
Usability,"I noticed that when I pass a `NamedTuple` to a `KernelFunctionOperation`, it'll generally give me an incorrect result if one of the variables used in the calculation is in the tuple and it's an operation. Here's a MWE where I'm creating a model with a constant `u=2`, setting up a simple KFO that returns `u` from `velocities`:. ```julia; using Oceananigans; using Oceananigans.AbstractOperations: KernelFunctionOperation; using Oceananigans.Fields: @compute. grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));. model = NonhydrostaticModel(; grid,); u₀ = 2;; set!(model, u=u₀). @inline ufunc(i, j, k, grid, velocities) = velocities.u[i, j, k]; ```. If I just pass `model.velocities` to it, it works fine and returns `u`. If I try to pass, for example, the perturbation `u - Average(u)`, then for some reason the KFO returns `u`:. ```julia; julia> velocities = (u = (model.velocities.u - Field(Average(model.velocities.u))),);. julia> @compute f1 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f1) # This should be all zero; 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 2.0. [:, :, 2] =; 2.0. [:, :, 3] =; 2.0. [:, :, 4] =; 2.0; ```. I expected the above to either work (i.e. produce the correct result) or throw an error, but returning `u` is unexpected. If, however, I define `velocities = (u = Field(model.velocities.u - Field(Average(model.velocities.u))),)` (i.e. wrap the operation in a `Field`) then the result is correct. Curiously, if I use `u₀` as the average in the snippet above (without wrapping the operation in `Field`), it appears to work:. ```julia; julia> velocities = (u = (model.velocities.u - u₀),);. julia> @compute f2 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f2); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Als",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455:281,simpl,simple,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455,1,['simpl'],['simple']
Usability,"I recently received the error. ```; ERROR: LoadError: ArgumentError: The grid halo (3, 3, 3) must be at least equal to (4, 4, 4). Note that an ImmersedBoundaryGrid requires an extra halo point.; ```. It's not clear what ""extra halo point"" means. I think this error needs to be a little bit more specific like, ""Note that an ImmersedBoundaryGrid requires an extra halo point in all directions compared to a non-immersed grid.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2983:209,clear,clear,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2983,1,['clear'],['clear']
Usability,"I see a few things to improve with the grid right now. 1. We need to add some kind of type information that indicates whether a given dimension is 'flat'. One way to do this could simply be to add the grid sizes in each dimension as parameters in the abstract type `Grid`, aka:. ```julia; abstract type Grid{T, Nx, Ny, Nz} end. struct RegularCartesianGrid{T, R, Nx, Ny, Nz} <: Grid{T, Nx, Ny, Nz}; ...; end; ```. Functions can then dispatch when one of `Nx`, etc is `1` (including halo-filling functions, which I think may fail when the size of the halo is 0). Another option is to use flags for each dimension rather than the actual size of the grid. In my opinion using the size makes the most sense. Using the actual size could have future advantages; for example, if some optimizations are possible when `Nz=2`. It is also nice to see the size of the grid from the type signature. A disadvantage is that we then could not have `mutable` grid types, but I'm not sure we want that. 2. There is a lot of redundant information in the `RegularCartesianGrid` struct: cell areas, volumes, total number of grid points, etc. I think it would be better --- meaning that our code would be shorter, easier to read, easier to maintain, easier to reason about (since storing them implies they *cannot* be computed, which is incorrect) and more computationally efficient --- to add functions that compute these quantities on the fly, rather than storing them in memory. Related: #287.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/330:180,simpl,simply,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330,1,['simpl'],['simply']
Usability,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455:13,learn,learn,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455,1,['learn'],['learn']
Usability,"I suspect that the docstring for the `BatchedTridiagonalSolver`,. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L17-L23. is incorrect. The docstring suggests that `c` (the upper diagonal) is indexed from `k=2` to `k=Nz`; however it is actually indexed from `k=1` to `k=Nz-1`:. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L82-L84. In the above code the `c` index is downshifted by 1, so that, if I am interpreting the algorithm correctly, the docstring should read:. ```; b(i, j, 1)ϕ(i, j, 1) + c(i, j, 1)ϕ(i, j, 2) = f(i, j, 1), k = 1; a(i, j, k-1)ϕ(i, j, k-1) + b(i, j, k)ϕ(i, j, k) + c(i, j, k)ϕ(i, j, k+1) = f(i, j, k), k = 2, ..., N-1; a(i, j, N-1)ϕ(i, j, N-1) + b(i, j, N)ϕ(i, j, N) = f(i, j, N), k = N; ```. This is also consistent with the tests, which use arrays of length `Nz-1` for both `a` and `c`. If `c` were indexed in the way implied by the docstring, the `c` array would either have to be length `Nz` or have a `k` index that's offset by 1. The indexing convention that's _implemented_ (rather than the one implied by the docstring) matches constructor interface for the matrix type `Tridiagonal`, which is convenient for testing against solutions produced by julia's built-in `\` operator. However, it means that function inputs need to shift indices by 1 compared to what most would consider ""intuitive"" (that the index of the coefficient `c` matches the index of the solution element `ϕ` that it multiplies).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1643:1479,intuit,intuitive,1479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1643,1,['intuit'],['intuitive']
Usability,"I think for Oceananigans it may not matter much, but it seems to matter a lot for the atmosphere so maybe it would be good to match up with the atmosphere so we can share operators. Here's @thabbott's argument for making z the fast index for an atmospheric LES model (taken from https://github.com/thabbott/JULES.jl/pull/16):; > I think that there are three strong argument to be made in favor of making ``z`` the fast index for this model:; >; > 1. Radiative transfer operates in columns; > 2. Rain falls downward relative to the air it's embedded in; > 3. Vertical momentum is solved implicitly within columns on the acoustic time step; > ; > This means that these three calculations can operate completely independently over different columns and (at least for calculations using a CPU) it's more efficient to store variables in the same column close to each other in memory. I don't think we have to change the function signatures relative to Oceananigans to make ``z`` the fast index, though---we just have to change the indexing order in ``differences.jl`` and ``interpolation.jl``. I think @vchuravy said that this might change with GPUs and/or shared memory, so maybe it's not super clear whether the change is worth making. Although for CPUs it will probably help a lot.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470:1191,clear,clear,1191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470,1,['clear'],['clear']
Usability,"I think it will be extremely helpful to be able to output boundary conditions and other fields (like fluxes, evaporation, and others) at the ocean interface. Following the discussion from #3081, something on those lines could be implemented, but it ideally it will be nice to have something like `model.boundary_conditions`. ```; using Oceananigans.BoundaryConditions: getbc; using Oceananigans: fields. # Boundary condition extractor in ""kernel function form""; @inline kernel_getbc(i, j, k, grid, boundary_condition, clock, fields) =; getbc(boundary_condition, i, j, grid, clock, fields). # Kernel arguments; grid = model.grid; clock = model.clock; model_fields = merge(fields(model), model.auxiliary_fields); u, v, w = model.velocities; u_bc = u.boundary_conditions.bottom; v_bc = v.boundary_conditions.bottom. # Build operations; u_bc_op = KernelFunctionOperation{Face, Center, Nothing}(kernel_getbc, grid, u_bc, clock, model_fields); v_bc_op = KernelFunctionOperation{Center, Face, Nothing}(kernel_getbc, grid, v_bc, clock, model_fields); ```. However it will be great to have something more general to simplify diagnosing simulations, that outputs the relevant boundary condition, in the example will be the `bottom` boundary.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3774:1107,simpl,simplify,1107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3774,1,['simpl'],['simplify']
Usability,"I think it'd be cleaner to change `node` so that `Flat` dimensions are omitted. For example, this would mean that on a grid that is flat in `z` (two-dimensional in `x, y`, we would write initial conditions. ```julia; ui(x, y) = # initial u; set!(model, u=ui); ```. Basically, grids that are `Flat` in `z` cannot depend on `z`. So it would be clearer if initial conditions also did not depend on `z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285:342,clear,clearer,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285,1,['clear'],['clearer']
Usability,"I think it's time to discuss the implementation of an abstraction for implementing drag forces on immersed boundaries. Curious to get feedback on this and also corrections if anything is wrong, plus additional considerations that I may be missing. ## Background. First a bit of background on why we impose quadratic drag boundary conditions on solid surfaces. Similarity theory supposes that shear is a function of only distance $d$ from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often tak",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:134,feedback,feedback,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,2,"['feedback', 'simpl']","['feedback', 'simple']"
Usability,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3048:753,clear,clear,753,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048,1,['clear'],['clear']
Usability,"I think the docs weren't 100% clear before on how to actually use different horizontal and vertical components in a single closure. I also couldn't figure out how to set `νx` different from `νy`, but I'm assuming that possible. So if anyone knows, I think we could also add that there.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2262:30,clear,clear,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2262,1,['clear'],['clear']
Usability,"I think we formally support Flat topologies now, so we should at least mention them in the page that teaches users about the grids. So I added a couple of simple sentences. I don't think we need much more for now (especially since all the 2D examples now use `Flat`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1774:155,simpl,simple,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1774,1,['simpl'],['simple']
Usability,"I want to set the gradient boundary condition to east, west, south, north directions in u and v variables. However, for u variable, cannot specify east boundary condition using GradientBoundaryCondition at Face(). So, how should i solve this problem. . Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. Thanks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3612:512,simpl,simple,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612,1,['simpl'],['simple']
Usability,"I was wondering if it would be advantageous to have a place dedicated to document the features that are still experimental. I think that'd make it easier for other people to contribute to those features and having them mature faster. The main motivation for me to ask this is that often users (myself included) will ask about a particular feature that's still under development (generally immersed solids or parallelism), and someone ends up describing the state of affairs at that point and pointing to a validation script and the user has to figure everything out from there. I realize all these things are available in issues and PRs, but it's hard to find the right ones and distill what's ""relevant"" information from there. I'm going through that this moment with `ImmersedBoundaryGrid`, which I'm trying to advance. I can work backwards from a given script to figure out how the implementation exists now and get a sense of to expand it, but it'd be way easier if I could read about what's implemented already, why that's the chosen implementation, bumps on the road, etc. Another motivation is that the code has grown so much lately that I sometimes see PRs/issues here about some features and I realize I simply don't recognize (and I'm fairly involved with Oceananigans' development). Some of those features might be useful for my research, or they may be things that I'd be interest in developing that I'm missing out on. Possible places to host that info would be a dedicated section of the docs possibly named ""Experimental features"", but maybe the easiest way would be allowing a wiki for that. I think discussions wouldn't be as organized. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2355:1213,simpl,simply,1213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355,1,['simpl'],['simply']
Usability,"I wonder if it may be a good idea to add a generic, user-definable 'parameters' field in `Model`. . The main purpose of this field would be to provide the user with more flexibility for boundary condition and forcing functions. Consider the implementation of a simple sponge layer in a script:. ```julia; const dTdz = 0.01; const μ₀ = 0.02. @inline μ(z, Lz) = μ₀ * exp(-(z + Lz) / 0.05Lz); @inline T₀(z) = dTdz * z. @inline FT(grid, U, Φ, i, j, k) = @inbounds -μ(grid.zC[k], grid.Lz) * (Φ.T[i, j, k] - T₀(grid.zC[k])). model = Model(forcing=Forcing(FT=FT), ...); ```. This works, of course. However, it requires the global `const`s `dTdz` and `μ₀` in order to compile on the GPU. This prevents users from, for example, defining a function of the form `create_and_run_model(μ₀, dTdz, other_parameters...)`. The only way to set `μ₀` or `dTdz` is by defining them as global `const`s; therefore a new script (or argument parsing via `ArgParse` and bash scripting) is required for each new run. I feel this is a potentially major limitation to current and future automation and we should attempt to find a solution to address the problem. One partial solution is to add a field `parameters` to the model. This field is then passed down into `calculate_interior_source_terms!` and the boundary condition algorithm to be used, if desired, within a user-defined functions. In this case, the above pattern could become:. ```julia; @inline μ(z, Lz, μ₀) = μ₀ * exp(-(z + Lz) / 0.05Lz); @inline T₀(z, dTdz) = dTdz * z. @inline FT(grid, U, Φ, i, j, k, params) = @inbounds -μ(grid.zC[k], grid.Lz, params.μ₀) * (Φ.T[i, j, k] - T₀(grid.zC[k], params.dTdz)). model = Model(forcing = Forcing(FT=FT), parameters=(μ₀=0.02, dTdz=0.01), ...); ```. We need not restrict the type of the field `parameters`; we can simply add. ```julia; mutable struct Model{P, ...}; ...; parameters :: P; end; ```. And set it to `nothing` by default in the `Model` constructor. The user may provide any kind of `parameters` they wish.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/394:261,simpl,simple,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/394,2,['simpl'],"['simple', 'simply']"
Usability,I'd like to define a custom logger for the logging the progress of models (ModelLogger). It's based on `Logging.SimpleLogger` and currently attempts to format `@info` calls as:; `[dd/mm/yyyy HH:MM:SS] module source_file:line_number: message`. Once that is in place I'd like to define some custom LogStates and have ModelLogger handle those as well. Chiefly `@diagnostic`. . I wired up one of the examples to use ModelLogger rather than printf.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478:112,Simpl,SimpleLogger,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478,1,['Simpl'],['SimpleLogger']
Usability,I'm amazed that the ultra-simple case of forcing with array values is still not properly supported. This PR adds that support. It needs a test.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498:26,simpl,simple,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498,1,['simpl'],['simple']
Usability,"I'm following the documentation so either we have a bug or the documentation needs to be clearer on how to use `JLD2OutputWriter` with named tuples. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)); model = Model(grid=grid); outputs = (u=model->model.velocities.u, T=model->model.tracers.T); model.output_writers[:jld2] = JLD2OutputWriter(model, outputs; frequency=1, prefix=""test"", verbose=true); time_step!(model; Δt=1, Nt=1); ```; produces; ```; [ Info: Calculating JLD2 output (:u, :T)...; ERROR: MethodError: Cannot `convert` an object of type Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} to an object of type Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} ; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:168; Stacktrace:; [1] setindex!(::Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}, ::Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol) at ./dict.jl:380; [2] Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}(::Base.Generator{Base.Iterators.Zip{Tuple{Tuple{Symbol,Symbol},Tu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/562:89,clear,clearer,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/562,1,['clear'],['clearer']
Usability,"I'm just now reading about the new `ScalarDiffusivity` and trying to use it. I think it's a great idea and I love how it simplifies things, but the use of the word ""isotropy"" kinda threw me off a bit. To me setting a scalar diffusivity as `ScalarDiffusivity(..., isotropy=Horizontal())`, implies that the diffusivity is the same in the horizontal directions, but that you can also set a different diffusivity in the vertical direction. Which you can't in this instance of the constructor; you have to create a new one. There's an extra issue I think if you set `ScalarDiffusivity(..., isotropy=Vertical())`. Since by definition isotropy is [uniformity in all orientations](https://en.wikipedia.org/wiki/Isotropy#:~:text=Isotropy%20is%20uniformity%20in%20all,the%20prefix%20an%2C%20hence%20anisotropy.), I don't think it's accurate to say something is isotropic over one single direction. Maybe a better word would be ""directions""? Or directionality? (if that's even a word...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2261:121,simpl,simplifies,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2261,1,['simpl'],['simplifies']
Usability,"I'm not 100% we want to enforce this, but it should be possible to ensure that `BinaryOperations` always occur at shared locations of fields. `BinaryOperations` are constructed via. https://github.com/CliMA/Oceananigans.jl/blob/c572c39b291bfea49e8ca4f6cdd4cb94e8cb4893/src/AbstractOperations/binary_operations.jl#L38-L43. A simple check will ensure that `Lab` always contains shared locations:. ```julia; Lab = Tuple(La[i] === Lb[i] && !isnothing(La[i]) ? La[i] : Lab[i] for i = 1:3); ```. I believe @jm-c has mentioned that this should always be enforced... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/959:324,simpl,simple,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/959,1,['simpl'],['simple']
Usability,"I'm not sure why this was added, so we will see if something breaks. But through usage I've realized that its inconvenient (and unexpected) that the length of `FieldTimeSeries` depends on the backend. My intuition is that the length stays the same regardless of _where_ the data is (in memory, or on disk, or a combination of the two). It's also helpful that behavior is the same between backends, which makes switching backends for performance reasons painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3825:204,intuit,intuition,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3825,1,['intuit'],['intuition']
Usability,"I'm opening this issue to have a discussion and solicit feedback on a few proposed improvements to CATKEVerticalDiffusivity. The most crucial improvement was to implement semi-implicit time-stepping for the dissipation term in the TKE equation, in #2426 . In `validation/windy_convection.jl`, the time-step had to be 30 seconds for CATKE stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2450:56,feedback,feedback,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450,1,['feedback'],['feedback']
Usability,"I'm thinking about the future and hoping to start a discussion about the future of our equation abstraction system. ## The problem. We need an abstraction for the concept of an equation, so that we can make the model as performant and lightweight as possible for a given use case. For example, I think we should require that. 1. The memory footprint of our model is no larger than it needs to be for a given problem (no 'extra' allocation of memory for unused tracers, for hydrostatic pressure when running in non hydrostatic mode, etc). 2. We do not perform unnecessary floating-point computations or indexing into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the bes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:764,clear,clearly,764,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['clear'],['clearly']
Usability,"I'm trying to code a simple 2D channel model in v0.17.0 where the periodic dimension is the flat dimension. I keep experiencing seemingly spontaneous velocity blowup during spin-up despite changing parameters/removing most forcing. Here is an example:. ```; Nx = 1; Ny = 256; Nz = 32; Lx = 1000e3; Ly = 1000e3; Lz = 4e3; N² = 1e-5; Δp = 1e-5 #will set to be a function of y; end_time = 1day. # ## Define a forcing function; pressure_gradient(x, y, z, t) = Δp / Lx; pressure_gradient_forcing = SimpleForcing(pressure_gradient). ## Instantiate the model; model = ChannelModel(; grid = RegularCartesianGrid(size = (Nx, Ny, Nz), x = (0, Lx), y = (-Ly/2, Ly/2), z=(-Lz, 0)),; closure = ConstantIsotropicDiffusivity(ν=100, κ=100),; coriolis = FPlane(f=1e-5),; tracers = (:b,),; buoyancy = BuoyancyTracer(),; forcing = ModelForcing(v=pressure_gradient_forcing); ). ## Set initial condition.; b₀(x, y, z) = N² * z; set!(model, b=b₀). ## A wizard for managing the simulation time-step.; wizard = TimeStepWizard(cfl=0.2, Δt=1.0, max_change=1.1, max_Δt=90.0); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/579:21,simpl,simple,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/579,2,"['Simpl', 'simpl']","['SimpleForcing', 'simple']"
Usability,"I've been experiencing a odd behavior when outputting dissipation where the results outputting a snapshot and a time-averaged field are different. This doesn't seem to happen for other outputs for some reason and I'm having a hard time understanding what's going on. . Maybe the best way to illustrate this is with a simplified version of the Eady turbulence example in the docs. The first part of the simulation is basically the same as the example, except with a simple constant isotropic diffusivity for closure (and a different progress messenger). I'm listing it below for completeness, but if you're familiar with the example in the docs you can skip this:. ```julia; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Units; using Printf. grid = RegularRectilinearGrid(size=(24, 24, 16), x=(0, 1e6), y=(0, 1e6), z=(-4e3, 0)); coriolis = FPlane(f=1e-4) # [s⁻¹]. const basic_state_parameters = ( α = 10 * coriolis.f, # s⁻¹, geostrophic shear; f = coriolis.f, # s⁻¹, Coriolis parameter; N = 1e-3, # s⁻¹, buoyancy frequency; Lz = grid.Lz) # m, ocean depth. using Oceananigans.Fields: BackgroundField. # Background fields are defined via functions of x, y, z, t, and optional parameters; U(x, y, z, t, p) = + p.α * (z + p.Lz); B(x, y, z, t, p) = - p.α * p.f * y + p.N^2 * z. U_field = BackgroundField(U, parameters=basic_state_parameters); B_field = BackgroundField(B, parameters=basic_state_parameters). #++++ Drag; const cᴰ = 1e-4 # quadratic drag coefficient. @inline drag_u(x, y, t, u, v, cᴰ) = - cᴰ * u * sqrt(u^2 + v^2); @inline drag_v(x, y, t, u, v, cᴰ) = - cᴰ * v * sqrt(u^2 + v^2). drag_bc_u = BoundaryCondition(Flux, drag_u, field_dependencies=(:u, :v), parameters=cᴰ); drag_bc_v = BoundaryCondition(Flux, drag_v, field_dependencies=(:u, :v), parameters=cᴰ). u_bcs = UVelocityBoundaryConditions(grid, bottom = drag_bc_u); v_bcs = VVelocityBoundaryConditions(grid, bottom = drag_bc_v); #-----. #++++ Turbulence closures; const κ = 1e-2 # [m² s⁻¹] Laplacian vertical viscosity ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517:317,simpl,simplified,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517,2,['simpl'],"['simple', 'simplified']"
Usability,"I've been facing an error using CUDA versions 3.10 and up that's been very hard for me to pinpoint. . It's pretty hard to come up with a _truly minimum_ working example in this case because the error doesn't happen every time, which slows down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:286,simpl,simplify,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['simpl'],['simplify']
Usability,"I've been playing around with the `immersed_couette_flow.jl` validation experiment and think I discovered a bug in the immersed boundaries implementation which causes non-immersed boundary conditions to be ignored. The BCs specified are here:; https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/validation/immersed_boundaries/immersed_couette_flow.jl#L16-L23. It is clear from the movie produced by the script that the flow adjusts to the immersed value BCs of u(0.1)=1 and c(0.1)=1 but does not adjust to meet the top BCs of u(1)=-1 and c(1)=-1. https://github.com/CliMA/Oceananigans.jl/assets/12971166/fb6ac2a8-7081-4edf-b363-87850b47fc6a. I ran into the same problem when adding an immersed boundary to the `horizontal_convection.jl` experiment. Adding an immersed boundary invalidated the surface buoyancy forcing, even when no `immersed` boundary condition was explicitly specified. Has anyone run into this issue or know what might be going on?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3208:402,clear,clear,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208,1,['clear'],['clear']
Usability,"I've long been unsatisfied with how we build output. It requires a lot of typing --- that is, [_boilerplate_](https://en.wikipedia.org/wiki/Boilerplate_text). I often feel a sense of dread when I have to go beyond ""visualizing the final iteration"" of a prototype to defining an output writer. _So much typing_. This PR is an attempt to make output easier and more fun. I use JLD2 as an example but if there is some consensus then I think this PR should extend the same to NetCDF. The main thrust of this PR is a new function called `output!`. It works like this:. ```julia; output!(simulation, outputs; schedule=TimeInterval(1), filename=""low_hanging_fruit""); ```. The default is `JLD2Format()`. For `NetCDF` users would write. ```julia; output!(simulation, outputs, NetCDFFormat(); kw...); ```. The function adds an output writer to `simulation`, choosing a ""generic name"" for the `simulation.output_writers` dictionary. Does this enable one line output writing?. I'd love to hear feedback about this design. I implemented it in the `two_dimensional_turbulence.jl` example for illustration:. https://github.com/CliMA/Oceananigans.jl/blob/6a6853ddf53c53c321c16393682b786e82ef5a8f/examples/two_dimensional_turbulence.jl#L109. There are two more things. First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Simulations are cheap, but life is short!. PS I also want to change `add_callback!` to just `callback!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793:982,feedback,feedback,982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793,2,"['feedback', 'simpl']","['feedback', 'simply']"
Usability,"Ideally, a user could set up and analyze an Oceananigans simulation without knowing anything about the staggered grid. Right now output includes `xC`, `xF`, etc. so this is the one place the user is forced to know about the staggered grid. Many users just want to plot output and not worry about N+1 faces and closing budgets, etc. We should have an option to save output onto an interpolated grid. One option would be to save everything at `(Center, Center, Center)`. Then the output will just have `x`, `y`, and `z`. Interpolated output would become especially useful for users on more complicated grid like the cubed sphere. Most users will probably want plain and intuitive `lat`, `lon`, `z` output.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1364:668,intuit,intuitive,668,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1364,1,['intuit'],['intuitive']
Usability,"If you pass something like `global_attributes = Dict(""Re"" => Re)` into the `NetCDFOutputWriter` constructor then it's type will be `Dict{String,Int}` and the constructor will fail as it tries to add `{String,String}` metadata entries. The user could explicitly specify `global_attributes = Dict{String,Any}(""Re"" => Re)` but I think a more user-friendly solution would be for the constructor to recast the type of `global_attributes` into `Dict{String,Any}`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/841:339,user-friendly,user-friendly,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/841,1,['user-friendly'],['user-friendly']
Usability,Implement a test that simply inspects the halos for correctness.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3021:22,simpl,simply,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3021,1,['simpl'],['simply']
Usability,"Improved and simplified BinaryOperation with ""stubborn"" location inference",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599:13,simpl,simplified,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599,2,['simpl'],['simplified']
Usability,In [A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2) a simple method for generalizing WENO stencils for stretched grids is described. This scheme is easy to implement and limits to what we already have implemented in the case of a regular grid.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1704:6,simpl,simple,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704,2,['simpl'],['simple']
Usability,"In a perfect world one would be able to use `AbstractOperations` for all output needs. But alas, there is #1241. The discussion on #1234 makes clear that this will continue to be a serious issue. There may also be output that cannot be expressed as an abstract operation. One work around for advanced users (which may be nice to have anyways) is to design an abstraction for `KernelComputedField`s that are computed based on a user-supplied kernel. I think usage could be something like (using [`ViscousDissipation`](https://github.com/CliMA/LESbrary.jl/blob/master/src/TurbulenceStatistics/viscous_dissipation.jl) as an example). ```julia; model = IncompressibleModel(...). @kernel function compute_viscous_dissipation!(ϵ, grid, clock, νₑ, u, v, w); i, j, k = @index(Global, NTuple). Σˣˣ = ∂xᶜᵃᵃ(i, j, k, grid, u); Σʸʸ = ∂yᵃᶜᵃ(i, j, k, grid, v); Σᶻᶻ = ∂zᵃᵃᶜ(i, j, k, grid, w). Σˣʸ = (ℑxyᶜᶜᵃ(i, j, k, grid, ∂yᵃᶠᵃ, u) + ℑxyᶜᶜᵃ(i, j, k, grid, ∂xᶠᵃᵃ, v)) / 2; Σˣᶻ = (ℑxzᶜᵃᶜ(i, j, k, grid, ∂zᵃᵃᶠ, u) + ℑxzᶜᵃᶜ(i, j, k, grid, ∂xᶠᵃᵃ, w)) / 2; Σʸᶻ = (ℑyzᵃᶜᶜ(i, j, k, grid, ∂zᵃᵃᶠ, v) + ℑyzᵃᶜᶜ(i, j, k, grid, ∂yᵃᶠᵃ, w)) / 2. @inbounds ϵ[i, j, k] = νₑ[i, j, k] * 2 * (Σˣˣ^2 + Σʸʸ^2 + Σᶻᶻ^2 + Σˣʸ^2 + Σˣᶻ^2 + Σʸᶻ^2); end. νₑ = model.diffusivities.νₑ; u, v, w = model.velocities. viscous_dissipation = KernelComputedField(Cell, Cell, Cell, model, compute_viscous_dissipation;; field_dependencies=(νₑ, u, v, w)); ```. In this example `viscous_dissipation` is then a bonafide field with a fully-fledged `compute!` function that can be used in output, time-averaging, in an `AveragedField`, etc. Users will need to write a kernel with `KernelAbstractions` language (which we'll have to document and provide examples for), but they won't have to write all the other boilerplate that goes into defining the struct and writing a `compute!` function (see again [`ViscousDissipation`](https://github.com/CliMA/LESbrary.jl/blob/master/src/TurbulenceStatistics/viscous_dissipation.jl) to get an idea of what this boiler plat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1246:143,clear,clear,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1246,1,['clear'],['clear']
Usability,"In addition to studying problems in oceanography, I also investigate problems in solar physics. Basically, the same equations as for the ocean but with magnetohydrodynamics. After learning about Oceananigans, it would be very easy (and desirable for me) to add a model (sometime, not right away) that would solve the MHD Shallow Water Model. This is something that I can see my students could use and benefit from. However, this is not a pure ocean problem so it does not fit in terms of the physics. **Question:** How would people feel about having an MHD model as part of Oceananigans?. If people agree that it doesn't fit, then I could learn to create another repo that piggy backs on Oceananigans, and that would be something that only I would be responsble to maintain. Would this be an option for the Oceananigans group?. Any thoughts are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1304:180,learn,learning,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1304,2,['learn'],"['learn', 'learning']"
Usability,"In all the scripts I found on distributed simulations, we seem to query the MPI state using `COMM_WORLD`, eg:. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L74. and. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L59-L60. But `Distributed` allows the `communicator` to be set, so `arch.communicator` can be something other than `COMM_WORLD`, eg. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/src/DistributedComputations/distributed_architectures.jl#L60-L66. Presumably we should never write scripts that make assumptions about the communicator (and we should strongly discourage users from doing so). So first of all the validation scripts must be changed. Secondly, I think something that could encouarge clean and good practices would be to extend functions like `Comm_rank` to `arch::Distributed` and possibly to the `grid` as well, so that we can call:. ```julia; rank = MPI.Comm_rank(arch); rank = MPI.Comm_rank(grid); Nranks = MPI.Comm_size(arch); ```. We'd have the option of throwing an error when non-distributed, or returning some sensible fallback like `Comm_rank(arch) = 0` and `Comm_size(arch) = 1`. Alternatively, we can develop our own API, since the MPI-based one is rather irregular and abbreviated, thus difficult for newbies to understand (I've been in this boat...). For example, perhaps simply `Base.size` and `rank` would suffice:. ```julia; Base.size(arch::Distributed) = MPI.Comm_size(arch.communicator); Base.size(arch::AbstractArchitecture) = 1; ```. ```julia; rank(arch::Distributed) = MPI.Comm_rank(arch.communicator); rank(arch::AbstractArchitecture) = 0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3318:1599,simpl,simply,1599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318,1,['simpl'],['simply']
Usability,"In for `MultiRegionField`s, we often forced to do, e.g.,. ```julia; for region in 1:number_of_regions(grid); u[region] .= - ∂y(ψ[region]); v[region] .= + ∂x(ψ[region]); end; ```. We'd like to be able to simply do:. ```Julia; u .= - ∂y(ψ); v .= + ∂x(ψ); ```. See, e.g.,; https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/validation/multi_region/cubed_sphere_tracer_advection.jl#L59-L69. cc @siddharthabishnu, @simone-silvestri, @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3577:203,simpl,simply,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577,1,['simpl'],['simply']
Usability,"In practice:. if the direction is uniform (`typeof(Δc) <: Number`) the scheme defaults to the usual 5th order interpolation coefficients (""uniform setting""). otherwise if the grid is stretched:. - `WENO5S(grid = grid)` will precompute the WENO coefficients for the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation is: it is way too expensive!); - `WENO5s()` will default to the uniform 5th order coefficients (""uniform"" setting); - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; `WENO5()` is obsolete as all the functionalities of `WENO5()` are included in `WENO5S()`, on the other hand, I kept this type for the moment for validation and benchmark purposes. When the `WENO5S(args...)` scheme is approved we can refractor it to `WENO5(args...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2059:1124,simpl,simple,1124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059,1,['simpl'],['simple']
Usability,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1077:1064,simpl,simplifies,1064,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077,1,['simpl'],['simplifies']
Usability,"Increasingly we have the need to offset kernel indices; ie to perform computations over ""windows"" for incomplete `Field` `indices`:. https://github.com/CliMA/Oceananigans.jl/blob/be00e364f9dcd712b3d0c3d48e32b94b181a02fc/src/AbstractOperations/computed_field.jl#L84-L92. or for @simone-silvestri's work to overlap communication and computation, eg #3067. Possibly, such a feature can be supported by `KernelAbstractions` eg https://github.com/JuliaGPU/KernelAbstractions.jl/issues/384 which would simplify our code a lot (since we won't have to pass the offsets into the kernel explicitly).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3068:496,simpl,simplify,496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3068,1,['simpl'],['simplify']
Usability,"Index computations inside`Field` constructors are wrong on `MultiArch`. As a result, this script. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(comm). topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), halo=(3, 3), extent=(2π, 2π)). model = NonhydrostaticModel(; grid). uᵢ = rand(size(grid)...); vᵢ = rand(size(grid)...); set!(model, u=uᵢ, v=vᵢ). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u). simulation = Simulation(model, Δt=0.01, stop_iteration=3). simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, (; ζ)),; schedule = IterationInterval(1),; with_halos = false,; prefix = ""test_output_writing_rank$rank"",; force = true). run!(simulation); ```. which is run with. ```; JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project mpi_output_writing.jl; ```. errors with a huge stack trace... part of which is. ```; caused by: BoundsError: attempt to access 16×8×1 Array{Float64, 3} at index [1:16, 9:11, 1:1]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; ```. However, if `with_halos=true` we're fine... I think. The index computation is clearly wrong (when we have `with_halos=false`, we compute the indices we want to output in the output writer constructor), but the confusing thing is that this only an issue for `ζ` from the output works. Needs to be investigated. Here's the index computation:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/output_construction.jl#L32-L41",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2352:1473,clear,clearly,1473,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2352,1,['clear'],['clearly']
Usability,"Inspired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780:147,learn,learn,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780,1,['learn'],['learn']
Usability,"It seems it was put here simply for ""historical reasons"", ie it is the most recent parameter to be added. But that is not a good way to motivate design:. https://github.com/CliMA/Oceananigans.jl/blob/9c6ed92edf212daaa4c709c4441ce770cdd0bae3/src/Grids/orthogonal_spherical_shell_grid.jl#L46. I think it belongs second, after `architecture`. Also, the type parameter should be 5th, after TZ:. https://github.com/CliMA/Oceananigans.jl/blob/9c6ed92edf212daaa4c709c4441ce770cdd0bae3/src/Grids/orthogonal_spherical_shell_grid.jl#L12. This will help with silly constructs like. https://github.com/CliMA/OrthogonalSphericalShellGrids.jl/blob/379d0de985a0927c026e6c3e43b2ebd163e054aa/src/tripolar_grid.jl#L13. cc @simone-silvestri @siddharthabishnu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3826:25,simpl,simply,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3826,1,['simpl'],['simply']
Usability,"It seems that the ivd_diagonal (main diagnonal) has not the right 1/ Δz factor:; idv_diagonal(k) should only be function of Δz_c(k) and also Δz_f(k) & Δz_f(k+1); I think by switching k_f & k_c in the definition of ""kappa_ Δz^2"" it should fix this (to check).; This problem should only shows up with vertically streched grid. For the 2 other diagonals ((upper & lower), it's not clear to me because I don't really know what this comment: ""# Shift to adjust for Tridiagonal indexing convenction"" means: Does this means that we don't pick one of the 2 simpler conventions for indexing the tri-diagonal coeff, i.e, either by line/row or by columns ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2065:378,clear,clear,378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065,2,"['clear', 'simpl']","['clear', 'simpler']"
Usability,"It would be relatively simple to create a new type called `PrescribedVelocities` for the purpose of solving tracer advection problems with prescribed fluid motion. The velocity fields would be specified as functions of `x, y, z, t`, wrapped in a [`FunctionField`](https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/function_field.jl) at the appropriate locations, and stored in `PrescribedVelocities`:. ```julia; struct PrescribedVelocities{U, V, W}; u :: U; v :: V; w :: W; end; ```. The next part of this implementation is overloading halo filling, time stepping, pressure corrections, and other functions that act on `model.velocities` with a bypass for `PrescribedVelocities`. This would be tedious but straightforward. We can also avoid allocating memory for pressure fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958:23,simpl,simple,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958,1,['simpl'],['simple']
Usability,"It'd be simpler to maintain just one 2nd order and 4th order diffusivity implementation. Also, `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` is _truly_ biharmonic, whereas `AnisotropicBiharmonicDiffusivity` is not. Deletion of the existing schemes and renaming of the curvilinear-friendly schemes will easily resolve this issue.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2113:8,simpl,simpler,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2113,1,['simpl'],['simpler']
Usability,"Just to share an experience I just had... More or less I set up a model with. ```julia; model = IncompressibleModel(grid = grid, boundary_conditions = (κₑ=(T=κₑ_T))); ```. and was surprised when the boundary conditions were not set on diffusivity. Why? Because I forgot a comma: the line. ```julia; boundary_conditions = (κₑ=(T=κₑ_T)) # wrong; ```. should be. ```julia; boundary_conditions = (κₑ=(T=κₑ_T,)) # correct; ```. In other words, the field `κₑ` must be a `NamedTuple` to work correctly. I think `#wrong` version essentially parses as `κₑ=T=κₑ_T`, so that `κₑ` is a `FieldBoundaryCondition` rather than a `NamedTuple` of `FieldBoundaryCondition`s. We could potentially do some checking as a band-aid. But in general, I think this is a tough problem and I don't have too many bright ideas on how to make this elegant and intuitive. So perhaps we can discuss here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721:828,intuit,intuitive,828,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721,1,['intuit'],['intuitive']
Usability,"Kinda feels like we're getting closer to a version 1.0 release, although I don't think we need to put a time frame on it. Is it worth discussing which major development milestones we think should be part of v1.0?. Since we're following [SemVer](https://semver.org/) I guess it's not really about which features we want to see in v1.0 but more about whether we think the user interface will be relatively stable. New features could be introduced in v1.1, v1.2, etc. but if we make any breaking changes we'll have to release v2.0. Maybe it's still useful to list some major milestones as they're quite likely to introduce breaking changes?. I'll start with the three big ones on my mind:; - [x] Pressure solvers for all topologies and grids (#586); - [x] MPI distributed parallelism (#590) [not necessarily super optimized, just something that works okay]; - [x] Vertically stretched grid (#471); - [ ] Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`.; - [ ] Specifying `architecture` when building `grid` (#1825).; - [ ] Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere); - [ ] Finalize spherical implementations; - [ ] Finalize bathymetry. Would be great to hear what people think and if anyone has any thoughts on v1.0. Might also be good to include @whitleyv's immersed boundary implementation and @francispoulin's shallow water model since both might bring some breaking changes as well. PS: Stuff added on 2021-07-23.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1234:940,simpl,simple,940,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234,2,"['Simpl', 'simpl']","['Simplify', 'simple']"
Usability,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/188:773,simpl,simple,773,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188,1,['simpl'],['simple']
Usability,"MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:161; [13] step_lagrangian_particles!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\LagrangianParticleTracking.jl:131 [inlined]; [14] step_lagrangian_particles!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:76 [inlined]; [15] time_step!(model::NonhydrostaticModel{…}, Δt::Float64; callbacks::Tuple{}, compute_tendencies::Bool); @ Oceananigans.TimeSteppers c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\TimeSteppers\runge_kutta_3.jl:110; [16] time_step!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\TimeSteppers\runge_kutta_3.jl:81 [inlined]; [17] time_step!(sim::Simulation{…}); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:122; [18] run!(sim::Simulation{…}; pickup::Bool); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:97; [19] run!(sim::Simulation{…}); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:85; [20] top-level scope; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\lagrangian_particle_MWE.jl:59; ```. The error indicates that `fractional_z_index` function hits https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Fields/interpolate.jl#L133 instead of https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Fields/interpolate.jl#L129, which is the intended function dispatch. Note: doing something like ; ```julia; struct SimpleParticle{X}; x :: X; y :: X; end; ```; is not supported, but perhaps this is a separate discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3632:5905,Simpl,SimpleParticle,5905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632,1,['Simpl'],['SimpleParticle']
Usability,Make OnDisk backend minimally usable,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3014:30,usab,usable,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3014,2,['usab'],['usable']
Usability,Make it easier to build simple HydrostaticFreeSurfaceModels,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3620:24,simpl,simple,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3620,2,['simpl'],['simple']
Usability,"Many of the examples could be shortened and simplified using `FieldTimeSeries` to post-process output. Even though `FieldTimeSeries` is not fully featured yet, it's still better than the many appearances of silly boiler plate like `iterations = parse.(Int, keys(file[""timeseries/t""]))`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1871:44,simpl,simplified,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1871,1,['simpl'],['simplified']
Usability,"Mentioned in #2134, I want to include both a `Relaxation` and `Forcing` for a velocity component, specifically a sponge layer at the top and bottom of the domain and a forcing function within the non-sponge domain. One potential syntax for this suggested by @glwagner is passing a tuple to the model constructor: ; ```; forcing = (; u = (u_relaxation, u_sponge)),; ```. This seems like a straightforward syntax from a user perspective since it's similar to other model constructor syntax, e.g., specifying tracers. Since a `Relaxation` can be called from within a `Forcing` function, it might be easier to simple provide an example of that syntax to create a combined `Forcing`. The calling order of the forcings is explicit in that case since the user is writing the function and it doesn't require any additional development (well, other than an example).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2136:606,simpl,simple,606,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2136,1,['simpl'],['simple']
Usability,"Might be good to start learning how to properly profile Oceananigans. It is slowing down a little bit as we add more things and develop stuff (see https://github.com/climate-machine/Oceananigans.jl/pull/147#issuecomment-479474578). We can easily profile it on a CPU to see where the code spends the most time and maybe find some easy things to optimize before profiling it on a GPU where things might be less obvious. Some useful links:; * https://docs.julialang.org/en/v1/manual/profile/index.html; * https://github.com/JuliaLang/julia/issues/4483 (might have to patch LLVM, could be a pain to get working).; * https://docs.nvidia.com/cuda/profiler-users-guide/index.html; * https://juliagpu.github.io/CUDAnative.jl/stable/man/performance.html#Optimizing-1; * https://discourse.julialang.org/t/writing-fast-stencil-computation-kernels-that-work-on-both-cpus-and-gpus/20200 (I pasted some commands where I use nvprof)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/162:23,learn,learning,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/162,2,"['guid', 'learn']","['guide', 'learning']"
Usability,Minor clearing up in Bickley jet example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1979:6,clear,clearing,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1979,2,['clear'],['clearing']
Usability,Minor code simplifications,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/325:11,simpl,simplifications,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325,2,['simpl'],['simplifications']
Usability,More user-friendly JLD2OutputWriter,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/963:5,user-friendly,user-friendly,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963,2,['user-friendly'],['user-friendly']
Usability,"Now that `ShallowWaterModel` is established I think it's important to make it more efficient. At the moment when we use `WENO5`, as I've been doing, we define 3 halo points in each direction. That means that our 1-layer model is really a 7-layer model, which is much more storage than we need. I very much want to remove this so that we can be much more efficient and have the code run faster. I know that #1024 tried to establish a flat dimension for `IncompressibleModel`. This is before my time and I heard multiple people tried doing this and it was a challenge. . I would like to do something independent of #1024, and force that any grid for `ShallowWaterModel` not define halo regions in the vertical and then not fill in those halo regions as it evolves. Below are a list of different things that I think should be done but am very curious to know what people suggest. I haven't tried this so I'm sure there are some details that I have not thought of and hoping to learn from others. - [ ] Maybe define the boundary conditions to be `flat` in the vertical and then try and get flat to work for this model?; - [ ] Maybe in `field_boundary_conditions.jl`, define `uhFluxBoundaryCondtions`, `vhFluxBoundaryCondtions`, `hBoundaryCondtions` that do not do anything to `top` and `bottom`?; - [ ] If we set the number of halos in the vertical to be 0, then we should still be able to use `new_data.jl` without having to modify it?; - [ ] Tell `fill_halo_regions.jl` to not do anything for `bottom` and `top`.; - [ ] If we remove the halos then I don't think we have to modify the tendencies at all so that might be fine.; - [ ] Other things that I've not considered?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499:974,learn,learn,974,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499,1,['learn'],['learn']
Usability,"Now that most operators are 3D we could simplify the nomenclature for the difference and interpolation operators by getting rid of the `ᵃ`, no? I think it would make code more legible. For example something like this (from [Oceanostics](https://github.com/tomchor/Oceanostics.jl/blob/da1d9174480df4bacd05b0e050fa9f25f51ab337/src/TKEBudgetTerms.jl#L29-L33)). ```julia; @inline function turbulent_kinetic_energy_ccc(i, j, k, grid, u, v, w, U, V, W); return (ℑxᶜᵃᵃ(i, j, k, grid, ψ′², u, U) +; ℑyᵃᶜᵃ(i, j, k, grid, ψ′², v, V) +; ℑzᵃᵃᶜ(i, j, k, grid, ψ′², w, W)) / 2; end; ```. could become this, which I think is way easier on the eyes:. ```julia; @inline function turbulent_kinetic_energy_ccc(i, j, k, grid, u, v, w, U, V, W); return (ℑxᶜ(i, j, k, grid, ψ′², u, U) +; ℑyᶜ(i, j, k, grid, ψ′², v, V) +; ℑzᶜ(i, j, k, grid, ψ′², w, W)) / 2; end; ```. Double interpolators could go from `ℑxyᶠᶜᵃ` to `ℑxyᶠᶜ` or `ℑxᶠyᶜ`. Thoughts?. This was originally suggested by @simone-silvestri in #2214",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2236:40,simpl,simplify,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2236,1,['simpl'],['simplify']
Usability,Nukes unused code and simplifies timestepping,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/786:22,simpl,simplifies,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/786,2,['simpl'],['simplifies']
Usability,"OK so looks like this will have to be the JOSS release and include the JOSS paper in the repository (#564). I'd also like to include PRs #910 and #915 in this release. @glwagner Do you want to include any PRs in v0.36.0?. Release notes:. This release coincides with the publication of the Oceananigans.jl Journal of Open Source Software (JOSS) paper. Changelog:; * Simplified boundary condition interface, types, and constructors. (@glwagner do you want add to this, maybe include a list of breaking changes?); * Support for a `NonTraditionalBetaPlane` Coriolis force implementation.; * The `AnisotropicBiharmonicDiffusivity` closure now works properly in closed domains with zero `Flux` boundary conditions, as higher-order boundary conditions are enforced.; * Bug fix: Appending to NetCDF files with `NetCDFOutputWriter` works now.; * Bug fix: Computations of abstract operations compute the right end point of face-centered fields along bounded dimensions.; * Bug fix: Averages `with_halos=false` return results with the correct dimensions for face-centered results along bounded dimensions.; * Small bug fixes for `show` methods. Breaking changes:; * When constructing a `NetCDFOutputWriter`, use `mode=""c""` instead of `clobber=true` and `mode=""a""` instead of `clobber=false`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/916:365,Simpl,Simplified,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/916,1,['Simpl'],['Simplified']
Usability,"Oceanangans.jl v0.51.0 changed the NetCDF time attribute from. ```julia; Dict(""longname"" => ""Time"", ""units"" => ""s""); ```. to. ```julia; Dict(""longname"" => ""Time"", ""units"" => ""seconds"") # seemed clearer to me.; ```. so now some packages such as xarray decode the time dimension as a `timedelta` instead of just a plain floating-point number. Old behavior can be reproduced via the `decode_times=False` kwarg for [`xarray.open_dataset`](http://xarray.pydata.org/en/stable/generated/xarray.open_dataset.html#xarray.open_dataset). I think this is a good change but the unintended consequence surprised some users (cc @suyashbire1) so I'm opening this issue to see if we indeed want this. If we don't then we shouldn't add a time attribute (and provide a way for users to specify one). @tomchor Maybe you have some thoughts since you've used NetCDF/xarray/Oceananigans.jl quite extensively.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421:194,clear,clearer,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421,1,['clear'],['clearer']
Usability,"Oceananigans.jl supplies an interface for inserting user-defined functions into a model via `ContinuousForcing`, `DiscreteForcing`, `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction`. User functions are also permitted as input to some model terms: turbulence closures, Stokes drift, etc, and can be used in diagnostics and AbstractOperations. It's often necessary or convenient to formulate user functions in terms of global variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:723,simpl,simple,723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['simpl'],['simple']
Usability,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2222:323,clear,clears,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222,1,['clear'],['clears']
Usability,"Okay, so I'm just gonna throw this out there: is it advantageous to migrate the Poisson solvers to a separate package (PoissonSolvers.jl)? It would be akin to the relationship between PencilFFTs.jl and PencilArrays.jl. I've been thinking about it for the past few days and I can see some pros:. - Separating the code can make Oceananigans easier to maintain:; - fewer things to test in every PR (the tests are becoming larger and larger and apparently we're starting to have backlogs on buildkite); - fewer lines/modules in general can make it easier to make sense of the code, especially for beginner users/contributors (in general the smaller the code base, the easier it is to attract contributors). Also having (brief) docs just for the solvers would be a very useful reference in general imho.; - Efficient Poisson solvers are hard to write and it's an art of their own since different BCs generally require different algorithms. With that said, having a separate package just for that might not only benefit the community (a quick google search for something like ""poisson solver julia"" shows that there's interest) but also it might make it easier for someone who needs a specific algorithm that we don't yet have to make a contribution that might help us. That said, I've never touched the Poisson solvers in Oceananigans so I don't know how ""portable"" they are, or if there are significant disadvantages. So some feedback here would be helpful. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1553:1422,feedback,feedback,1422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553,1,['feedback'],['feedback']
Usability,"One solution for compiling kernels with fields as arguments is to define. ```julia; Adapt.adapt_structure(to, field::AbstractField) = data(field); ```. and. ```julia; Adapt.adapt_structure(to, fields::NamedTuple{S, NTuple{N, <:AbstractField}}) where {S, N} =; datatuple(fields); ```. This approach will automatically unwrap fields when they are passed to GPU kernels (I think). . The disadvantage of this approach is that the code is a little bit harder to interpret, because if you miss the definition of this function, you might be confused why `field.boundary_conditions` and `field.grid` were not accessible from inside GPU kernels. On the other hand, this only affects the lowest-level kernels, and GPU programmers probably know that an `adapt_structure` method must be defined somewhere for an exotic object like `Field` to be passed into a kernel. If we document what we are doing clearly, we may solve this problem. Doing this means we would no longer have to unwrap fields manually prior to passing them to GPU kernels. Are there any other issues that I'm not seeing?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722:888,clear,clearly,888,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722,1,['clear'],['clearly']
Usability,"Our model constructor API asks users to pass several `NamedTuple`s for field-specific input like `forcing`, `boundary_conditions`, etc. For example:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L108. We currently enforce that these are `NamedTuple` by typing the keyword argument. However, this leads to obscure `TypeError` that may not be all that helpful / interpretable. For example:. ```; ERROR: LoadError: TypeError: in keyword argument forcing, expected NamedTuple, got a value of type Oceananigans.Forcings.DiscreteForcing{NamedTuple{(:x₀, :z₀, :δᴸ, :R), NTuple{4, Float64}}, typeof(b_discrete_forcing_func)}; ```. A more user-friendly error might be an `ArgumentError` that says something like. ```; $argname must be `NamedTuple` but is $argtype instead! Check for missing commas or semicolons. A common typo is to write `(field=value)` rather than `(field=value,)` or `(; field=value)`.; ```. In particular, a super common typo is to write something like. ```julia; forcing = (u=u_forcing),; ```. rather than the two-character-different. ```julia; forcing = (; u=u_forcing),; ```. We can write a little utility for throwing an error message like this, and then just loop over the relevant `NamedTuple` inputs in every model constructor. We can also check that `keys(arg)` are contained in the fields of the model and emit a warning if there's a key that'll be unused. Noticed while working on a script with @raphaelouillon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2269:728,user-friendly,user-friendly,728,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269,1,['user-friendly'],['user-friendly']
Usability,"Our time-stepping functions / kernels in `time_steppers.jl` are a bit chaotic with long argument lists, etc. To bring order to this world, it might be a good idea to adopt some kind of convention / preferred ordering to the function arguments. . Almost all of the functions are mutating, so I think the first argument(s) should be the objects that are mutated by the function. This follows the [julia style guide recommendation](https://docs.julialang.org/en/v1/manual/style-guide/index.html#Write-functions-with-argument-ordering-similar-to-Julia-Base-1). After that, the style guide doesn't offer guidance though it could make sense to put important objects for dispatch first (mostly `arch`). . The rest of the objects fall into a few categories (I think):. * grid; * parameter structs; * `NamedTuple`s of fields / arrays / boundary conditions; * scalars. Perhaps we can use an ordering along the lines of. 1. object being mutated; 2. architecture (if used); 3. grid (if used); 4. scalars; 5. parameter structs; 6. `NamedTuple`s of stuff. I'm open to other patterns too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/448:407,guid,guide,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/448,4,['guid'],"['guidance', 'guide']"
Usability,"Our user interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1011:625,simpl,simply,625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011,1,['simpl'],['simply']
Usability,"Output writer usability issues: hard to `pickup` with high frequency output, dangerous `overwrite_existing`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:14,usab,usability,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,2,['usab'],['usability']
Usability,Plus a simple test with a plankton growth/death model similar to `examples/convecting_plankton.jl`. TODO:; * [x] Add the interface to `HydrostaticFreeSurfaceModel`; * [x] Better interface for defining the biogeochemical source function; * [x] Better interface for automagically adding biogeochemical tracers?. With @jagoosw,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802:7,simpl,simple,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802,1,['simpl'],['simple']
Usability,Probably a question for @whitleyv or @glwagner but how hard would it be to support tracers with the current immersed boundary implementation?. My understanding is that currently the velocity tendencies are corrected inside the immersed boundary but not tracer tendencies (which seems to work fine in 2D?). Is it as simple as adding a new kernel like [`_correct_immersed_tendencies!`](https://github.com/CliMA/Oceananigans.jl/blob/6bfc1551c57403268138b85620d88dba8114a4c0/src/Models/IncompressibleModels/correct_incompressible_immersed_tendencies.jl#L43) but for tracers?. cc @gianlisi @wanyingkang,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1548:315,simpl,simple,315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1548,1,['simpl'],['simple']
Usability,Resolves #1010. This PR also adds an annotation to `DiscreteForcing` that may help with GPU compilation (its not 100% clear now however).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1016:118,clear,clear,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1016,1,['clear'],['clear']
Usability,Resume from checkpoint should be integrated with model constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/602:0,Resume,Resume,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/602,1,['Resume'],['Resume']
Usability,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2051:835,simpl,simply,835,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051,1,['simpl'],['simply']
Usability,Right now `interior(field)` returns a view into `f.data` --- an `OffsetArray`. But we obtain the same indexing behavior if `interior(field)` returns a view into `parent(f)` with appropriate indices. The benefit is that a view into `parent(f)` is `Base.SubArray` and supported in many GPU operations. It's also simpler (a single wrapper around an `AbstractArray`). A `view` into `OffsetArray` is a wrapper around a wrapper. Since indexing is the same I don't think this is a breaking change either. Just wondering if anyone objects. If nobody does we can probably nix `interiorparent` as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1610:310,simpl,simpler,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1610,1,['simpl'],['simpler']
Usability,"Right now in the `NonhydrostaticModel`, we remake a user-provided `grid` if the halos are not big enough:. https://github.com/CliMA/Oceananigans.jl/blob/04ca8e2f143afd53fd60bdaeb885a4dc1ed5825c/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L127. This is a nice convenience for users experimenting with different advection schemes, closures, etc. One major caveat, however, is that models that incorporate user-created fields, when those fields are provided at the time of model construction, may have been created on the ""wrong"" grid. This problem is most acute for `PrescribedVelocityFields` with the `HydrostaticFreeSurfaceModel`; however the issue is generic. It doesn't appear to be very common for users to create their own fields, which is perhaps why no great problems have been detected. Nevertheless, this is an insidious ""gotcha"" that could lead to hard to define or undetectable bugs. One solution is to throw an error if the grid's halos are not big enough, rather than recreating it. The error will instruct the user to specify larger halos. This damages usability (since users need to know and care about their halos) but makes user experiments more resilient against bugs. In the future, if we also use large halos by default (eg `(3, 3, 3)` as proposed by #1245) then such an error would be encountered only rarely.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2107:1078,usab,usability,1078,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107,1,['usab'],['usability']
Usability,Right now the callback/progress function is only called for the first time when `iteration = iteration_interval` but I think we actually want to run the progress function at iteration 0 as it helps provide more feedback to the user at a time of heavy compilation. This would help with #1013 and having output at iteration 0 tells the user that the simulation is starting to time step. Sometimes when the terminal is blank for a while I'm not sure if Julia is still compiling or if I accidentally created a huge CPU model that's taking forever to take each time step.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1250:211,feedback,feedback,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1250,1,['feedback'],['feedback']
Usability,"Right now we have a simple interval wave test in `test_dynamics.jl` (vertically propagating and only 10 time steps) and an example (@glwagner thinks it looks off). We should turn them into a rigorous verification experiment. Would be a good test of the pressure gradient term, and we can compare with an analytic solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/674:20,simpl,simple,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/674,1,['simpl'],['simple']
Usability,"S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOperation`. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1886:2597,ux,uxvywz,2597,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886,3,['ux'],['uxvywz']
Usability,"See `show(io::IO, g::RegularCartesianGrid)` for a simple example.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/26:50,simpl,simple,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/26,1,['simpl'],['simple']
Usability,See: https://discourse.julialang.org/t/cuarrays-cudanative-psa-simplified-package-loading/27897,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/376:63,simpl,simplified-package-loading,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/376,1,['simpl'],['simplified-package-loading']
Usability,"Seems like a leftover relic from a time when we only had 1 pressure solver for `(Periodic, Periodic, Bounded)`. . Might be good to be explicit about the topology, but maybe we should wait until all 9 (or 27) topologies are usable?. Would be good to be explicit since it may be unclear whether adding walls should happen via boundary conditions or via a grid topology. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1178:223,usab,usable,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1178,1,['usab'],['usable']
Usability,Seems like a solid guide and we already follow some of the guidlines: https://github.com/SciML/ColPrac. This would modify https://github.com/CliMA/Oceananigans.jl/blob/master/CONTRIBUTING.md. We also get a nice badge:. [![ColPrac: Contributor's Guide on Collaborative Practices for Community Packages](https://img.shields.io/badge/ColPrac-Contributor's%20Guide-blueviolet)](https://github.com/SciML/ColPrac),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1044:19,guid,guide,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1044,3,"['Guid', 'guid']","['Guide', 'guide', 'guidlines']"
Usability,Seems like when we call. ```Julia; julia> maximum(f); ```; where `f::Field` then this is called:; https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/src/Fields/field.jl#L600-L618. This errors on the GPU. Why not simply:. ```julia; import Base: maximum. maximum(f::Field) = maximum(parent(f.data)); ```; ?. cc @taimoorsohail,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2727:248,simpl,simply,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2727,1,['simpl'],['simply']
Usability,"Simple Dockerfile to build a Docker image with Oceananigans installed, precompiled, and with dependencies built. Should be useful for debugging and maybe speeding up CI. Image can be built then just downloaded by CI server, but usually testing is done before Docker image is built... We also have a Dockerhub repository where images will be published: https://cloud.docker.com/repository/docker/aliramadhan/oceananigans. We can look into automated builds: https://docs.docker.com/docker-hub/builds/. For GPU-accelerated container we can look into: https://github.com/NVIDIA/nvidia-docker. cc @christophernhill we're finally in the 21st century!. Resolves #151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/316:0,Simpl,Simple,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/316,1,['Simpl'],['Simple']
Usability,"Simple fix to use the cell-centered vertical spacing (face-to-face distance) in the continuity equation for determining w in the hydrostatic model. The code currently uses the face-centered spacing (center-to-center distance), which is the same for the uniform grid but not for the vertically stretched grid. With help from @sandreza and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1932:0,Simpl,Simple,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932,1,['Simpl'],['Simple']
Usability,Simple tests for correct halo filling + dynamics with the MultiRegion cubed sphere,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3020:0,Simpl,Simple,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020,1,['Simpl'],['Simple']
Usability,Simpler boundary condition functions and forcing functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697:0,Simpl,Simpler,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697,1,['Simpl'],['Simpler']
Usability,Simplification and generalization of Model constructors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/401:0,Simpl,Simplification,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401,1,['Simpl'],['Simplification']
Usability,"Simplifies boundary condition interface, types, and constructors",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894:0,Simpl,Simplifies,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894,1,['Simpl'],['Simplifies']
Usability,Simplifies models' constructors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1726:0,Simpl,Simplifies,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1726,1,['Simpl'],['Simplifies']
Usability,"Simplifies the `make_example.jl` script that is used to build the Documentation only with 1 or 2 examples (e.g., an example one developer is currently working on). This makes previewing how the example will look like in the actual documentation much faster.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1353:0,Simpl,Simplifies,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1353,1,['Simpl'],['Simplifies']
Usability,"Simplify AbstractModel, fixes show for RegularCartesianGrid",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/408:0,Simpl,Simplify,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/408,1,['Simpl'],['Simplify']
Usability,Simplify checkpointer and make it work for large models,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/628:0,Simpl,Simplify,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628,1,['Simpl'],['Simplify']
Usability,Simplify implementation of SmagorinskyLilly + some other closure doc fixes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3102:0,Simpl,Simplify,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3102,1,['Simpl'],['Simplify']
Usability,Simplify kernel launching and add `exclude_periphery` option,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814:0,Simpl,Simplify,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814,1,['Simpl'],['Simplify']
Usability,Simplify the baroclinic adjustment example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2819:0,Simpl,Simplify,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2819,1,['Simpl'],['Simplify']
Usability,Simplify user interface for `KernelFunctionOperation`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2964:0,Simpl,Simplify,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2964,1,['Simpl'],['Simplify']
Usability,Simplify way users have access to grid metrics,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058:0,Simpl,Simplify,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058,1,['Simpl'],['Simplify']
Usability,Simplifying notation for difference and interpolation operators,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2236:0,Simpl,Simplifying,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2236,1,['Simpl'],['Simplifying']
Usability,"Since PR #621 introduced simulations, the examples have actually started looking worse as plotting + animation + simulations are all mixed together. Simplest example from https://climate-machine.github.io/Oceananigans.jl/stable/generated/one_dimensional_diffusion/; ```julia; anim = @animate for i=1:100; simulation.stop_iteration += 100; run!(simulation). plot(interior(T)[1, 1, :], zC, linewidth=2, title=tracer_label(model),; label="""", xlabel=""Tracer concentration"", ylabel=""z"", xlims=(0, 1)); end. mp4(anim, ""1d_diffusion.mp4"", fps = 15) # hide; ```. I don't think that's a clean use of the simulation class. I think we should add an output writer, run the simulation, then have a separate loop that reads the output and plots/animates it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/676:149,Simpl,Simplest,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/676,1,['Simpl'],['Simplest']
Usability,"So now we can specify the domain using; ```julia; RegularCartesianGrid(Float64; N=(10, 10, 10), x=(-5, 5), y=(-π, π), z=(0, 1)); ```; but if we only care about the length of each dimension then you can still use; ```julia; RegularCartesianGrid((32, 32, 32), (1, 1, 1)); ```. This is nice for a lot of problems where the domain isn't `x=(0, Lx), y=(0, Ly), z=(-Lz, 0)`. I also learned that keyword arguments do not participate in dispatch so you can't have both `RegularCartesianGrid(T; N, L)` and `RegularCartesianGrid(T; x, y, z)` :( Apparently it's a pretty old Julia issue: https://github.com/JuliaLang/julia/issues/9498. Resolves #413",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464:376,learn,learned,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464,1,['learn'],['learned']
Usability,Some simplifications in Docs/Simulations For GPUs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3170:5,simpl,simplifications,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3170,2,['simpl'],['simplifications']
Usability,"Some time ago I told @simone-silvestri I wanted to show a ""simple 2D example"" in a tutorial, to which he responded. > It's actually harder to construct a 2D grid than a 3D grid. @simone-silvestri's point, I think, is that to reduce the dimension of a grid we have to pass `topology` with `Flat` elements. It's easier to construct a grid with the default topology `(Periodic, Periodic, Bounded)`. This has been haunting me ever since. I think one way we can solve this issue is to introduce convenience constructors like. ```julia; grid = ZRectilinearGrid(size=16, z=(0, 1), topology=Bounded); grid = XYRectilinearGrid(size=(64, 64), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic)); ```. These are relatively simple to implement since they're one-liners:. ```julia; XYRectilinearGrid(args...; topology=(Periodic, Periodic), kw...) = XYRectilinearGrid(args...; kw..., topology=tuple(topology[1:2]..., Flat)); ```. et cetera. We can also define the appropriate type aliases:. ```julia; const XYRectilinearGrid{FT, TX, TY} = RectilinearGrid{FT, TX, TY, Flat} where {FT, TX, TY}; ```. and change `show` (if we desire). Is this friendly / a good idea?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2292:59,simpl,simple,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2292,2,['simpl'],['simple']
Usability,"Started to write documentation and docstrings but some parts of the code were a little too messy to be documented easily, so I ended up doing some cleanup that seems to deserve its own PR. I mainly renamed all the abstract types to have the `Abstract` prefix (following the Julia style guide) and simplified `LinearEquationOfState`, `PlanetaryConstants`, and `RegularCartesianGrid` where I removed properties that weren't being used or that were redundant/useless. Resolves #190 (because the constants in question have been removed); Resolves #285",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/406:286,guid,guide,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/406,2,"['guid', 'simpl']","['guide', 'simplified']"
Usability,"Still a work in progress but working on bringing in more unit and system tests. The system tests will include some that we've already implemented (e.g. #126) and some regression tests on simple examples. Also working on comprehensive GPU testing so that we're testing the GPU as much as we're testing the CPU. In particular, the Poisson solver isn't tested on the GPU right now which is kind of scary. **Warning**: GPU testing can take a while as a lot of compilation is involved :( See #66. Resolves #18 ; Resolves #22; Resolves #78",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/134:187,simpl,simple,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/134,1,['simpl'],['simple']
Usability,"Strange that we don't have this already but this PR refactors the operators to be truly finite volume. By using multiple dispatch we only have one operator rather than having a different operator for each grid. The beautiful ϊ (`\iota\ddot`) now denotes interpolation. Thanks @sandreza!. Need to switch to using the `caa`, `afa`, etc. notation and introduce some composite operators from `closure_operators.jl`. Just opening this PR early so people can see what the new operators look like, get some feedback, etc. Once this PR is merged, implementing a vertically stretched grid will be easy, and implementing wall bounded directions should be as simple as defining something like; ```julia; Ay(i, j, k, grid) = ifelse(j == 0, 0, Δx(i, j, k, grid) * Δz(i, j, k, grid)); ```; but still thinking about the best way to dispatch on e.g. `DoublyPeriodicDomain`, `ChannelDomain`, `TriplyPeriodicDomain`, etc. I will also release v0.7.0 once this PR is merged. Resolves #115; Resolves #146 ; Resolves #469",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283:501,feedback,feedback,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283,2,"['feedback', 'simpl']","['feedback', 'simple']"
Usability,Switch to ColPrac: Contributor's Guide on Collaborative Practices for Community Packages,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1155:33,Guid,Guide,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1155,1,['Guid'],['Guide']
Usability,"Take the 1D diffusion example: https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/. This is the plotting code:. ```julia; using JLD2. file = jldopen(simulation.output_writers[:temperature].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). anim = @animate for (i, iter) in enumerate(iterations). T = file[""timeseries/T/$iter""][1, 1, :]; t = file[""timeseries/t/$iter""]. plot(T, z, linewidth=2, title=@sprintf(""t = %.3f"", t),; label="""", xlabel=""Temperature"", ylabel=""z"", xlims=(0, 1)); end; ```. But where did `z` come from? From `z = znodes(model.tracers.T)` some lines above. But what if I want to plot in a separate script? Or what if I run my simulation on a cluster and want to plot some data on a different machine?. One solution would be to use `z = file[""grid/zC""]`. However, users may be surprised to learn that this output is not sliced and includes halos though (https://github.com/CliMA/Oceananigans.jl/issues/1194) so many plotting libraries will error because of some dimension mismatch. So if you don't have access to the `grid` then you can't plot the coordinates correctly without wrangling with `file[""grid""]` (which requires users to know about halos). And users may want to plot using other programming languages and libraries/programs where you can't get access to an Oceananigans grid. ---. I guess I'm advocating for plotting without using any Oceananigans functions to make the examples more useful for users. We can make the plotting code more local which would make it more copy-paste-able for users (more user friendly).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1405:864,learn,learn,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1405,1,['learn'],['learn']
Usability,"Thanks to @leios and @francispoulin for feedback that helped locate the issue!. Resolves #1170 . This PR fixes a bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1228:40,feedback,feedback,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228,1,['feedback'],['feedback']
Usability,"Thanks to @simone-silvestri , I learned today that we cannot compute the divergence on a `LatitudeLongitudeGrid` using the simple formula of. $$; \zeta = \partial_x(v) - \partial_y(u); $$. Instead, we should use `VerticalVorticityField`. . Since this function exists, do we also want to create a [`HorizontalDivergenceField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/vertical_vorticity_field.jl), which computes the equivalent of the following but correctly on all grids?. $$; \delta = \partial_x(u) - \partial_y(v); $$. I for one expect that I would use this almost as often.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2575:32,learn,learned,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2575,2,"['learn', 'simpl']","['learned', 'simple']"
Usability,"The Adams-Bashforth time stepper relies on an approximate time-integral to calculate the tendencies. ; This time integral, when using a constant time step, is simply approximated as; ```math; G^{n+1} = \left(\frac{3}{2} + \chi \right) G^n - \left( \frac{1}{2} +\chi \right) G^{n-1}; ```; The $\chi$ term should be a small deviation from the time integral, added to reduce the noise generated by non-linear terms. ; I wanted to open a bit of a discussion about the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have adde",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738:159,simpl,simply,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738,1,['simpl'],['simply']
Usability,"The argument `grid` is required --- of course --- in model constructors. Our current API makes `grid` a keyword argument. Originally (and it was a long time ago now) it was argued that keyword arguments are just better and that's why we should keep it. Also, we don't dispatch on it. However, we violate that concept in `Simulation`, where the `model` is a positional argument. I think it's more natural to input `grid` as a positional argument in the models. It's a relatively minor thing, but it avoids anti-patterns like `grid=grid`, which appeared in many scripts before `; grid` was possible. It looks better. This has come up because we are adding more Oceananigans-based `AbstractModel`s over in [`ClimaSeaIce`](https://github.com/CliMA/ClimaSeaIce.jl), and my first intuition there was to make `grid` a required positional argument. Ultimately though, we should strive for all models to have uniform interfaces, so either we change `Oceananigans` or we change `ClimaSeaIce`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3250:774,intuit,intuition,774,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250,1,['intuit'],['intuition']
Usability,"The clause that controls the definition of `cell_diffusion_timescale` in `TimeStepWizard` had a bug. I re-wrote in a way that's clearer to understand and that fixes the bug. Consider the MWE below:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8, 8, 8), extent = (1,1,1),; topology=(Periodic, Periodic, Bounded)). closure = IsotropicDiffusivity(ν=1); model = NonhydrostaticModel(grid = grid,; closure = closure); @info """" model; ; wizard = TimeStepWizard(diffusive_cfl=0.1,); ```. Before this PR:. ```julia; julia> wizard.cell_diffusion_timescale(model); Inf. julia> @which wizard.cell_diffusion_timescale(model); infinite_diffusion_timescale(args...) in Oceananigans.Simulations at /home/tomas/.julia/packages/Oceananigans/IHPoE/src/Simulations/time_step_wizard.jl:12; ```. After this PR:. ```julia; julia> wizard.cell_diffusion_timescale(model); 0.015625. julia> @which wizard.cell_diffusion_timescale(model); cell_diffusion_timescale(model) in Oceananigans.TurbulenceClosures at /home/tomas/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:15; ```. I'll also add a test to catch this in the future, since there are no tests for `diffusive_cfl` that I could tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2213:128,clear,clearer,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2213,1,['clear'],['clearer']
Usability,"The discussion on https://github.com/CliMA/Oceananigans.jl/discussions/3098 had me thinking about how we might allow users to access more model data within forcing or boundary condition functions. The problem we encountered in the past (especially for diffusivity fields) is that dumping _everything_ into the forcing function often caused GPU compilation to fail. That's why forcing functions only have access (for example) to velocities, tracers, and auxiliary fields:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L62. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L74. A possible solution to this is a utility `with_auxiliary_fields` for ""rebuilding"" a model with new auxiliary fields. I think this would be relatively simple to implement, because the `auxiliary_fields` don't have any role within a model constructor. Thus we can develop something like. ```julia; model = with_auxiliary_fields(model, new_auxiliary_fields); ```. which is quite easy I think, something like... ```julia; function with_auxiliary_fields(model::NonhydrostaticModel, new_auxiliary_fields); model_properties = OrderedDict{Any, Any}(name => getproperty(model, name) for name in propertynames(model)); model_properties[:auxiliary_fields] = new_auxiliiary_fields; return NonhydrostaticModel(model_properties.values...); end; ```. Then users can run simulations with the ""updated"" model, putting any fields they like from the ""old"" model into `auxiliary_fields`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3099:958,simpl,simple,958,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3099,1,['simpl'],['simple']
Usability,"The doc does not make it clear to me how to know which input is expected when using `AveragedField`. E.g. the following line. How do I decide what dims() should be?. `T_avg = AveragedField(model.tracers.T, dims=(1, 2))`. The [library](https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Output-writers) search for `AveragedField` doesn't give away much information either.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1965:25,clear,clear,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1965,1,['clear'],['clear']
Usability,"The example [`validation/immersed_boundaries/flow_over_hills.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) in the main branch is failing for me with the following cryptic error (which I've truncated because it was too long to fit). The error clearly has something to do with how bottom drag interacts with the immersed boundaries, but I haven't made much progress debugging. ```julia; Exception has occurred: CompositeException; TaskFailedException. nested task error: BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/dy5oz/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./range.jl:932 [inlined]; [5] ynode(::Face, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [6] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [7] ynode(::Face, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:303,clear,clearly,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,1,['clear'],['clearly']
Usability,"The installation instructions are helpful for users who have downloaded julia. However, to run examples one needs to know how to use git, and also to have a text editor. Neither of these is necessarily trivial so it might be nice both to provide some simple explanations about how to get started with running the examples, and also to link to info about text editing, IDEs, and using github.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1149:251,simpl,simple,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1149,1,['simpl'],['simple']
Usability,"The issue of whether fields should store their boundary conditions was brought up in #601. We've discussed this idea before but I'm opening this issue to see if this is something we want to pursue. Note: Moving boundary conditions to fields should happen alongside or after the introduce of grid topologies (#489) which would decouple the grid topology from the boundary conditions (although some boundary conditions will be determined by the grid topology). I think it's a good idea that will pay off in code clarity and ease of use.; 1. Functions such as [`fill_halo_regions!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/BoundaryConditions/fill_halo_regions.jl#L22) will simplify as we no longer need to pass in both a field and boundary conditions, just the field itself.; 2. No need to prepare boundary condition tuples to pass to functions, for example, in [`complete_pressure_correction_step!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/TimeSteppers/TimeSteppers.jl#L177-L183).; 3. Oceananigans has have a pretty deep hierarchy of boundary conditions: BC -> Coordinate BCs -> field BCs -> Solution BCs -> Model BCs. Moving BCs to fields will eliminate the need for solution BCs and model BCs, which will create a simpler hierarchy of just BC -> coordinate BCs -> field BCs. This will make it easier to developers and users to access and interact with boundary conditions, especially as [`ModelBoundaryConditions`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl#L155-L177) can only grow in complexity.; 4. Storing fields in one struct and boundary conditions in another struct feels antithetical to orthogonal design. Another reason to consider having fields carry their boundary conditions around is to avoid having to build more boundary condition machinery, i.e. more [solution_and_model_boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606:731,simpl,simplify,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606,1,['simpl'],['simplify']
Usability,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97:1402,simpl,simply,1402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97,1,['simpl'],['simply']
Usability,"The objective of this PR is to more clearly and quickly advertise the setting up of Oceananigans models in more than one configuration. We currently have one ""quickstart"", which sets up `NonhydrostaticModel` to do decaying turbulence. I propose that we add two more for `HydrostaticFreeSurfaceModel`: a rectangular configuration (say baroclinic adjustment) and a spherical configuration, maybe with bathymetry. I think we should also change defaults to grease the wheels a bit. So this PR will change the free surface to split explicit. I also think we should use WENO advection schemes and increase the default halo size to (4, 4, 4) so that 5th order WENO works on immersed boundary grid. Basically, I think the default should be useful: second-order advection with nothing closure is not useful. . I'd also like to add the quick start setups to the docs, in addition to the README. A few more miscellaneous ideas:. - A bulleted list of the examples with a short description of what each example demonstrates (so that one does not have to wade through all of them to find what they are looking for); - A new page in the docs that summarizes the ""major capabilities"" of each model. More docs refactoring is ultimately needed but I think this is a good start. Closes #3289",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3308:36,clear,clearly,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308,1,['clear'],['clearly']
Usability,"The signature of the model constructor is . ```julia; function IncompressibleModel(;; grid,; architecture = CPU(),; float_type = Float64,; tracers = (:T, :S),; closure = ConstantIsotropicDiffusivity(float_type, ν=ν₀, κ=κ₀),; clock = Clock{float_type}(0, 0), ; buoyancy = SeawaterBuoyancy(float_type),; coriolis = nothing,; surface_waves = nothing,; forcing = ModelForcing(),; boundary_conditions = (u=UVelocityBoundaryConditions(grid),; v=VVelocityBoundaryConditions(grid),; w=WVelocityBoundaryConditions(grid)),; parameters = nothing,; velocities = VelocityFields(architecture, grid, boundary_conditions),; tracer_fields = TracerFields(architecture, grid, tracernames(tracers), boundary_conditions),; pressures = PressureFields(architecture, grid, boundary_conditions),; diffusivities = DiffusivityFields(architecture, grid, tracernames(tracers), boundary_conditions, closure),; timestepper_method = :AdamsBashforth,; timestepper = TimeStepper(timestepper_method, float_type, architecture, grid, tracernames(tracers)),; pressure_solver = PressureSolver(architecture, grid, PressureBoundaryConditions(grid)); ) ; ```. Issues:. 1. `tracers` is apparently expected only to be a tuple of symbols. Nevertheless, the function `tracernames` is called on this argument --- whose only purpose is to return tracer names when its argument may *either* be a tuple of symbols, or a tuple of fields. 2. The arguments (`tracers`, `tracer_fields`) and (`timestepper_method`, `timestepper`) are redundant. . 3. Worse, `tracer_fields` can be set to something inconsistent with `tracers`, and therefore `diffusivities` and `timestepper`. It's probably best if we assign only one keyword argument to each ""concept"", for the sake of simplicity and interpretability. A little bit of cleaning / interpretation to arguments (eg, if an argument may either be a tuple of symbols corresponding to tracer names, or a tuple of tracer fields) is ok, in my opinion, because it could make the code less confusing and easier to use.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/647:1713,simpl,simplicity,1713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/647,1,['simpl'],['simplicity']
Usability,"The simple test code from @christophernhill, now successfully differentiating!. Not sure what the correct answer should be, so someone should check this. This probably makes sense to add a test somewhere at least, and also can be used as a starting point for future development. ```julia; using Enzyme; using Oceananigans; using KernelAbstractions: @index, @kernel; using Oceananigans.Utils: launch!; using Oceananigans.Architectures: device. using EnzymeCore. EnzymeCore.EnzymeRules.inactive_type(::Type{<:Oceananigans.Grids.AbstractGrid}) = true. arch=CPU(); FT=Float64. N = 100; topo = (Periodic, Flat, Flat); grid = RectilinearGrid(arch, FT, topology=topo, size=(N), halo=2, x=(-1, 1), y=(-1, 1), z=(-1, 1)). function del21d!(d2buf,fld::Field); g = fld.grid; Nx = g.Nx; for i=1:Nx; d2buf[i] = fld[i-1,1,1]+fld[i+1,1,1]-2fld[i,1,1]; end; return; end. @kernel function del21d_k!(d2buf_k,fld); i,j,k = @index(Global,NTuple); @inbounds d2buf_k[i,j,k] = fld[i-1,j,k]+fld[i+1,j,k]-2fld[i,j,k]; end. # 2. halo; function halo1d!(fld::Field); g = fld.grid; Hx = g.Hx; Nx = g.Nx; for i=1:Hx; fld[i-Hx,1,1]=fld[Nx-Hx+i,1,1]; fld[Nx+i,1,1]=fld[i ,1,1]; end; return nothing; end. # 3. simple model; function diffuse1d_model!(jcost,fld); grid=fld.grid; d2buf=ones(grid.Nx); arch=grid.architecture; d2buf_k = CenterField(grid); k=1.0; dt=0.1; nsteps=50; for i in 1:nsteps; del21d!(d2buf,fld); ### kernel style; event=launch!(arch,grid,:xyz,del21d_k!,d2buf_k,fld); for j in 1:fld.grid.Nx; d2buf[i] = d2buf_k[i]; end; for j in 1:fld.grid.Nx; fld[j,1,1] = fld[j,1,1] + k*d2buf[j]*dt; end; halo1d!(fld); end; jcost[1]=fld[15,1,1].*fld[15,1,1]; return nothing; end. c = CenterField(grid); c2 = CenterField(grid); f(x, y, z) = exp( -50((x-grid.xᶠᵃᵃ[1])/grid.Lx-0.5)^2 ); set!(c,f); halo1d!(c); set!(c2,f); halo1d!(c2); j=[0.]; diffuse1d_model!(j,c). bc=CenterField(grid); set!(c,f); set!(bc,0); j=[0.]; bj=[1.]; autodiff(Reverse, diffuse1d_model!,Duplicated(j,bj), Duplicated(c,bc) ). @show bj; @show bc; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3346:4,simpl,simple,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3346,2,['simpl'],['simple']
Usability,"There are a couple of files (e.g. `Oceananigans.jl` and `runtests.jl`) that have these mega import statements where a lot of things are imported. I find it hard to understand why certain things are being imported and where they are being used, so I'm thinking it might be better if we import things at the top of the file where they are being used. This means using more local import statements which I'm thinking will make it clearer where and why things are being imported and used. @glwagner @suyashbire1: What do you guys think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497:427,clear,clearer,427,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497,1,['clear'],['clearer']
Usability,"There are a few applications that require building fields before `IncompressibleModel`, in order to form `AbstractOperations` and `ComputedFields` that need be computed during a model time step (eg PR #1091). I think this use case will only become more and more important in the future. Currently this functionality is possible but plagued by a huge useability issue: the default `grid` has a halo size of 1, while most applications benefit from higher-order advection schemes. To hide the need to specify halo region sizes from users, we currently ""inflate"" halos inside the constructor for `IncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/5ddace160c2b8c4469d49f6b35c1c748879a0c17/src/Models/IncompressibleModels/incompressible_model.jl#L111-L112. This means that users who want to build fields before `IncompressibleModel` do, in fact, have to know the halo size they need to specify for their chosen advection scheme. This isn't well-documented right now... Somehow, we have to figure out how to smooth this whole process out. One huge help will simply be to choose a default advection scheme that is useful for science: either `UpwindBiasedFifthOrder` or `WENO5`, and to set the default halo size for the grid to 5. Having these default will mitigate the problem greatly I think. But we also probably need utilities (or documentation at the very least) that explains this issue and how to choose the halo size if one needed to build the grid outside the model. Or, perhaps there are even better solutions to this issue. Basically the point is that the grid depends ""circularly"" on aspects of `IncompressibleModel`, which becomes an issue when things like `VelocityFields` (which also depend on the grid) need to be constructed prior to `IncompressibleModel`. We don't want users to have to replicate the `IncompressibleModel` constructor in their scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1245:1070,simpl,simply,1070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245,1,['simpl'],['simply']
Usability,"There are a few gotchas when setting up GPU simulations so it's not always as simple as just changing `CPU` to `GPU`, mainly related to things the GPU compiler does not like. A common one that produces a very non-obvious error is using global variables in forcing functions or any function that will get used in a GPU kernel (e.g. https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733435704 and https://github.com/CliMA/Oceananigans.jl/issues/1477). Might be helpful for users if we add a section or page to the docs that describes these issues.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478:78,simpl,simple,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478,1,['simpl'],['simple']
Usability,"There is a mismatch between what the docstring of the `RectilinearGrid` claims for what the metrics (e.g., `Δxᶜᵃᵃ` or `Δxᶠᵃᵃ`) are and what the metrics actually correspond to. The docstring says that, e.g., `Δxᶜᵃᵃ` is the distances between cell centers. I think this is wrong. First of all, this is not uniquely defined as, e.g., the distance between a cell center and the adjacent cell centers may be different on each side of the cell. I believe that `Δxᶜᵃᵃ` is, instead, the length of the corresponding cell that is centered at `caa`, _or equivalently_, is the distances between the adjacent faces of each cell's center. Note that for a regularly-spaced grid what I claim to be correct and what the docstring mentions are equivalent (and possibly this is what lead to the current docstring?). However, for a variably-spaced grid they are not equivalent. Here's an example:. ```julia; julia> Nx = 3; grid = RectilinearGrid(size = Nx, topology = (Bounded, Flat, Flat), x = [0, 1, 2, 10]); 3×1×1 RectilinearGrid{Float64, Bounded, Flat, Flat} on CPU with 3×0×0 halo; ├── Bounded x ∈ [0.0, 10.0] variably spaced with min(Δx)=1.0, max(Δx)=8.0; ├── Flat y; └── Flat z. julia> grid.xᶜᵃᵃ[1:Nx]; 3-element Vector{Float64}:; 0.5; 1.5; 6.0. julia> grid.xᶠᵃᵃ[1:Nx+1]; 4-element Vector{Float64}:; 0.0; 1.0; 2.0; 10.0. julia> grid.Δxᶜᵃᵃ[1:Nx]; 3-element Vector{Float64}:; 1.0; 1.0; 8.0. julia> grid.Δxᶠᵃᵃ[1:Nx+1]; 4-element Vector{Float64}:; 1.0; 1.0; 4.5; 8.0; ```. A schematic of the cell faces and centers together with the corresponding values for `Δx` is below:. ```julia; F C F C F C F. xᶠᵃᵃ 0 1 2 10; xᶜᵃᵃ 0.5 1.5 6.0. Δxᶠᵃᵃ 1 1 4.5 8; Δxᶜᵃᵃ 1 1 8; ```. I am pretty sure that what we want is what the code actually does. In this case, what's left to be done is simply to fix the docstring. Am I right?. (P.S.: I stumbled upon this while trying to fill the halos properly for #3239.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3252:1756,simpl,simply,1756,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3252,1,['simpl'],['simply']
Usability,"This PR (pair programmed with @francispoulin) allows users to select the `timestepper` and adds support for `forcing` functions as part of the `ShallowWaterModel`. We also added some simple tests. We also added a `shallow_water_model_forcing` function that should readily generalize to `IncompressibleModel` while being shorter, so we can consider using it to replace `model_forcing`. Resolves #1284",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1291:183,simpl,simple,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291,1,['simpl'],['simple']
Usability,"This PR (part 3/3) upgrades the field abstraction so fields store their own boundary conditions. This simplifies the model boundary condition hierarchy and generalizes the field and boundary conditions abstractions so they can be used for a compressible model (and any other model we come up with in the future). All future fields will have boundary conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, nor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:102,simpl,simplifies,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['simpl'],['simplifies']
Usability,"This PR adds a `TurbulenceClosures` module to `Oceananigans`. At the moment nothing in the `Oceananigans` algorithm is touched --- the module is simply loaded and exported. I suggest that we keep it this way, given the size of this PR, and work on integrating the code into `Oceananigans` in a future PR. A simple incremental test in that future PR will be to replace the diffusive operators with the ones here and ensure that the regression tests still pass. Ultimately `TurbulenceClosures` will provide code for all the different diffusive terms we want to provide for `Oceananigans` users. The current design is that a 'closure' must provide a diffusive flux divergence term for `Oceananigans`. These diffusive flux terms are. * `∇_κ_∇ϕ(i, j, k, grid, ϕ, closure, u, v, w, T, S)` for a scalar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234:145,simpl,simply,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234,2,['simpl'],"['simple', 'simply']"
Usability,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:489,simpl,simple,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"This PR adds a bunch of examples, tests them, and writes them so that `Literate.jl` can be used to generate markdown files from them. . In the future, we can add these markdown files to the documentation. Examples that might be good to add to ~~this~~ a future PR:. - 2D convection into a stratified fluid with ""phytoplankton-like"" tracer: demonstrates forcing functions, nice boundary conditions, etc; - 2D Kelvin-Helmholtz instability: just a simple but interesting stratified example; - Stratified Couette flow example: nice 3D example with `Value` boundary conditions. Also: . - [x] Clean up and simplify deepening mixed layer example: should become a good 3D example; perhaps merge into single 'case' including forcing by both wind and unstable buoyancy forcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/425:445,simpl,simple,445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/425,2,['simpl'],"['simple', 'simplify']"
Usability,"This PR adds a few sections to `CONTRIBUTING.md` with guidelines for opening an issue, and for becoming an Oceananigans collaborator.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1765:54,guid,guidelines,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1765,1,['guid'],['guidelines']
Usability,"This PR adds a new minimal example that simulates and plots a rising buoyant bubble:. ```julia; # # Hello, ocean!; #; # > How inappropriate to call this planet Earth, when it is quite clearly _Ocean_.; #; # --Arthur C. Clark. using Oceananigans, Oceananigans.Grids, Plots. grid = RegularCartesianGrid(size = (1, 64, 64),; x = (0, 1), y = (-4, 4), z = (-4, 4),; topology = (Periodic, Bounded, Bounded)). model = IncompressibleModel(grid = grid,; architecture = CPU(),; advection = Oceananigans.Advection.WENO5(),; tracers = :b,; buoyancy = BuoyancyTracer(),; closure = IsotropicDiffusivity(ν=1e-3, κ=1e-3)). @info ""Simulating a rising buoyant bubble with"" model. set!(model, b = (x, y, z) -> exp(-y^2 - z^2)). run!(Simulation(model, Δt=0.01, stop_iteration=800)). # Analyze the data. b = model.tracers.b. plt = contourf(ynodes(b), znodes(b), interior(b)[1, :, :]',; xlabel = ""y"", ylabel = ""z"", title = ""Buoyancy"",; xlim = (grid.yF[1], grid.yF[end]), ylim = (grid.zF[1], grid.zF[end]),; aspectratio = :equal, linewidth = 0). display(plt) # hide; ```. If we do think an example like this would be nice to have, it might make sense to replace the README example with this one (and perhaps otherwise improve the README). I didn't add it to the list of examples in the docs, but it is set up (in it's minimal way) for Literate-ing. Or we can un-literate it. Suggest away and I shall commit!. The script produces. ![image](https://user-images.githubusercontent.com/15271942/99148581-9859d880-2656-11eb-989a-a137635e11df.png). Could also add a `pkg""add Oceananigans, Plots""` at the top per the discussion on #1149, but it might better to unify all the examples at once in a dedicated PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1181:184,clear,clearly,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1181,1,['clear'],['clearly']
Usability,"This PR adds a property to `IncompressibleModel` called `background_fields`. `background_fields.velocities` contains background velocity fields; `background_fields.tracers` contains background tracer fields. Background fields are specified with a `NamedTuple` similar to forcing functions and boundary conditions:. ```julia; background_u(x, y, z, t) = z * sin(t). model = IncompressibleModel(grid=grid, background_fields=(u,), ...); ```. Background fields are neglected in all tendency terms _except_ the advection terms. This restricts their use, but greatly simplifies their implementation. Todo:. - [x] update physics docs to include background fields in model equations; - [x] update model setup docs; - [x] tests; - [x] update `eady_turbulence.jl` and `internal_wave.jl` example to use `background_fields`; - [x] extend implementation of `FunctionField` to take parameters and add a special constructor for background `FunctionFields`. Resolves #960",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1014:560,simpl,simplifies,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014,1,['simpl'],['simplifies']
Usability,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1480:288,simpl,simplest,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480,1,['simpl'],['simplest']
Usability,"This PR adds a work-in-progress lid-driven cavity verification experiment. It also somewhat acts as a test for PR #475. It's a very classic test case and makes for a nice simple example: https://www.cfd-online.com/Wiki/Lid-driven_cavity_problem. I will compare point-wise velocity values along vertical and horizontal lines through the geometric center of the cavity at a resolution of 128x128 for various Reynolds numbers from Re=100 to Re=10,000. The values are reported in Tables 1 and 2 of [Ghia et al. (1982)](https://doi.org/10.1016/0021-9991(82)90058-4). Basically doing what this YouTube video is doing: https://www.youtube.com/watch?v=gkg3nG_qU7g. Helps with #332 and #346",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/476:171,simpl,simple,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/476,1,['simpl'],['simple']
Usability,"This PR adds an `architecture` property to the `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Eventually, this PR will remove the `architecture` property from all models and fields. The new API will require `architecture` to be specified once when building the grid and never thereafter. This major change to the API is crucial for supporting a clean, simple API for grid metrics stored in arrays (all cases except the edge case of a fully regular grid). In the new API, both the architecture and floating point type are exclusive properties of `grid`. In addition this change will simplify the construction of models on distributed architectures and will eliminate the need for special model constructors for that case. Ultimately, we hope to go beyond this change to support just three grids:. 1. `RectilinearGrid`; 2. `LatitudeLongitudeGrid`; 3. `OrthogonalSphericalShellGrid`. In the first two cases, ""regularity"" is established if the grid metrics are numbers (rather than arrays or functions). This is another major change to the API (and a major internal refactor) that will hopefully reduce, simplify, and generalize grid constructors and applications. Closes #1825.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1998:372,simpl,simple,372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1998,3,['simpl'],"['simple', 'simplify']"
Usability,"This PR adds another validation script for quick tests and such of distributed `NonhydrostaticModel`. We've been using the benchmark script, but that has additional features (and as a benchmark, is expensive to run). Hopefully these prove useful for fleshing out support for distributed cases. Right now I've just added a simple 2D turbulence script. TODO:; - [x] Add output to 2D turbulence script; - [ ] Add a 3D `NonhydrostaticModel` case; - [ ] Add `HydrostaticFreeSurfaceModel` case; - [ ] Add a script that runs into #2347 . cc @johnryantaylor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2348:322,simpl,simple,322,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2348,1,['simpl'],['simple']
Usability,"This PR adds docstrings for all exported functions (i.e. functions that will be part of the public API) so users can actually look up what functions do. In the next PR I will make sure all the necessary docstrings get compiled to documentation. I followed the guidelines on https://docs.julialang.org/en/v1.0.2/manual/documentation/ and limited docstrings to 92 character lines. I ended up documenting abstract types because although they aren't exported, they show up in the docstrings of many functions, so it's reasonable to expect that users may want to look them up. One thing I noticed is how often we use this pattern where we define extra constructors like; ```julia; thing(T=Float64; kwargs) = thing{T}(kwargs); ```; when it seems like we should just be using `thing{T}(kwargs)` which will help declutter the public user API a bit. I also noticed that using the prefix `Abstract` for all abstract types may reduce code readability (and isn't followed in Julia Base: see the abstract types `AbstractFloat`, `Number`, `Real`). So we might have to judge a little bit: `AbstractGrid` is probably a good idea but `AbstractBoundaryConditionType` is going a little far and `AbstractTensorDiffusivity` seems a little verbose. Not sure of the best guideline to stick to. Some things that still need to be done:; 1. Not sure of the proper citation(s) to use for `DeardorffSmagorinsky`. @glwagner; 2. Will wait for PR #409 before I write docstrings for `fields.jl`.; 3. While not part of the public user API, I'll write docstrings for the time stepping kernels as I think they'll prove to be valuable.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/410:260,guid,guidelines,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/410,2,['guid'],"['guideline', 'guidelines']"
Usability,This PR adds instructions for how a contributor can build the documentations locally and preview them. I was tempted to add some info about doc previews but I think doc previews are not generated for PR that come from forks so it's not a good idea to have it in the Contributors Guide.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1389:279,Guid,Guide,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1389,1,['Guid'],['Guide']
Usability,"This PR adds model setup documentation describing all the possible options the user has when setting up a model. Right now it's still a mega-page work-in-progress but the more useful parts will describe how to set up different kinds of boundary conditions with several examples, how diagnostics work and how flexible they are, and also output writers including finally a little guide on how to checkpoint and restore from a checkpoint. I think this PR is the last piece of work we agreed is needed before a JOSS submission.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/534:378,guid,guide,378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/534,1,['guid'],['guide']
Usability,This PR adds some convenience functions for interacting with fields that are functions. Unfortunately I can't test it on my mac because I don't have `CUDAnative` (?) and CUDA stuff is broken for some reason on my desktop. . I added an example in `examples/working_with_fields.jl` to demonstrate how to use the abstraction. @ali-ramadhan can you help me debug and test? This PR is small and simple. Addresses #174.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/210:390,simpl,simple,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/210,1,['simpl'],['simple']
Usability,"This PR adds support for in-place reduction operations where the target is an `AbstractReducedField` and the source is either an `AbstractDataField`, `AbstractOperation`, or array of some kind. These work on the GPU. In the end the solution was simple since we now subtype `AbstractArray`; we only need to pass a view into the interior indices of the target to `Base.mapreducedim!` (which on the GPU ends up at `GPUArrays.mapreducedim!`). The result is that `AveragedField(op::AbstractOperation)` no longer needs to allocate memory for the three-dimensional result of computing `op`. Instead, `op` is reduced in a kernel. This is both faster (much much faster, I think --- though a benchmark is a good idea) and more memory efficient. It also greatly simplifies `compute!(field::AveragedField)`:. ```julia; function compute!(avg::AveragedField, time=nothing); compute_at!(avg.operand, time); mean!(avg, operand); return nothing; end; ```. So, resolves #1422. I also took the liberty of resolving #1610 and nuking `interiorparent`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1611:245,simpl,simple,245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1611,2,['simpl'],"['simple', 'simplifies']"
Usability,"This PR adds support for variable ""closure constants"" in `SmagorinskyLilly`, and refactors the `AnisotropicMinimumDissipation` to share it. It discontinues support for `Function` closure constants in AMD. As an example, the ""Van Driest"" damping function (discussed in #3369) would be implemented in a simple channel simulation as follows:. ```julia; # Vertically-bounded resolved LES; #; # This script builds a simulation of freely-decaying turbulence in; # a vertically-bounded domain, where turbulence far from the wall is modeled using; # the SmagorinskyLilly eddy diffusivity closure, but the dynamics close to the wall; # is fully resolved. The Van Driest damping function is used to modify the SmagorinkyLilly; # model constant close to the wall to ensure that the dynamics is relatively unaffected; # by the eddy diffusivity. using Oceananigans; using Oceananigans.Grids: zspacing; using Oceananigans.Fields: FunctionField; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization. grid = RectilinearGrid(size=(64, 64, 256), x=(0, 1), y=(0, 1), z=(0, 1),; topology = (Periodic, Periodic, Bounded)). vitd = VerticallyImplicitTimeDiscretization(); molecular_diffusivity = ScalarDiffusivity(vitd, ν=1.05e-6). """"""; van_driest_damping_function(x, y, z, p). Return the model constant for SmagorinskyLilly which decreases to zero; at the center of the first grid cell away from the wall.; """"""; @inline function van_driest_damping_function(x, y, z, p); # Position of first grid cell; z₀ = p.Δz₀ / 2; z₁ = 1 - p.Δz₁ / 2. # Distances to the wall; d⁺₀ = (z - z₀) / p.δ⁺; d⁺₁ = (z₁ - z) / p.δ⁺; d⁺ = min(d⁺₀, d⁺₁). # Model constants; A⁺ = p.A⁺; C = p.C. return C * (1 - exp(d⁺ / A⁺)); end. # Find grid spacing at top and bottom, assuming rectilinearity; Nz = size(grid, 3); Δz₀ = zspacing(1, 1, 1, grid, Center(), Center(), Center()); Δz₁ = zspacing(1, 1, Nz, grid, Center(), Center(), Center()). parameters = (C = 0.16,; A⁺ = 26, # :-D; Δz₀ = Δz₀, # vertical grid spacing at the bottom;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3370:301,simpl,simple,301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370,1,['simpl'],['simple']
Usability,"This PR adds two features:. 1. The ability to specify multiple forcing functions with a tuple (eg #2136); 2. A new forcing function type `AdvectiveForcing` for adding advective terms as a forcing function. A few users want to model buoyant or sinking particles so we need a nice way to support this that doesn't require importing low-level Oceananigans kernel functions. This was discussed on Slack and in #2385 . Some notes:. * `AdvectiveForcing` can also model advection of momentum, but this will only work for `NonhydrostaticModel` at the moment (because the kernel functions for momentum advection have different names for nonhydrostatic vs hydrostatic); * ""forcing tuples"" are wrapped in a lightweight `MultipleForcings` wrapper; this is just an internal convenience. However it does mean that we can more easily support alternative ways to ""combine"" forcings (other than just adding them) in the future if need be. ### Example of multiple forcings. From #2136, in model constructors:. ```julia; forcing = (; u = (u_relaxation, u_sponge)); ```. ### Example of `AdvectiveForcing`. From the docstring:. ```julia; # Physical parameters; gravitational_acceleration = 9.81 # m s⁻²; ocean_density = 1026 # kg m⁻³; mean_particle_density = 2000 # kg m⁻³; mean_particle_radius = 1e-3 # m; ocean_molecular_kinematic_viscosity = 1.05e-6 # m² s⁻¹. # Terminal velocity of a sphere in viscous flow; Δb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density; ν = ocean_molecular_kinematic_viscosity; R = mean_particle_radius. w_Stokes = - 2/9 * Δb / ν * R^2. settling = AdvectiveForcing(WENO5(), w=w_Stokes); ```. Closes #2136 . TODO:; - [x] Tests; - [x] Validation case with simple sinking, reacting particle that combines `MultipleForcing` and `AdvectiveForcing`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389:1699,simpl,simple,1699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389,1,['simpl'],['simple']
Usability,"This PR aims to add the lid-driven cavity as a verification experiment (first) and as a simple example (second) that is very well-known in the CFD world. It's set up as a 2D problem in the _yz_ plane. It also tests that horizontal/channel boundary conditions work. The verification experiment aims to reproduce the results detailed by [Ghia, Ghia, & Shin (1982)](https://doi.org/10.1016/0021-9991(82)90058-4). Unfortunately right now it seems to blow up no matter what I do. Once the top plate is set in motion a vorticity anomaly makes its way along the top plate then down to the bottom plate at which point blow up seems to occur no matter the time step or Reynolds number. A [Physics StackExchange post](https://physics.stackexchange.com/questions/461782/clarification-on-the-lid-driven-cavity-problem-in-cfd) suggested that quiescent initial conditions should be fine ""although if the wall Mach number is large, the sudden impulse could be numerically destabilizing"" which would only make sense for compressible models. I tried with vortical initial conditions too but no luck.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/572:88,simpl,simple,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/572,1,['simpl'],['simple']
Usability,"This PR changes our contributor's guide to [ColPrac](https://github.com/SciML/ColPrac), which I think is a pretty useful guide on how to work collaboratively on packages. We already follow some of the guide's suggestions around PRs so might as well follow the entire guide. What do people think about it?. Might be good to adopt something like ColPrac as more people start working together on Oceananigans. cc @navidcy @whitleyv @francispoulin. Resolves #1044",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1155:34,guid,guide,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1155,4,['guid'],['guide']
Usability,This PR changes the confusing names `frequency` and `interval` for diagnostics and output writers to the clearer `iteration_interval` and `time_interval`. It also changes `progress_frequency` to `iteration_interval` for simulations. It also converts some examples to doctests. Resolves #672,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/836:105,clear,clearer,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/836,1,['clear'],['clearer']
Usability,This PR changes the grid coordinate arrays so that they are not reshaped to three-dimensional arrays. . The coordinate arrays are now one-dimensional `OffsetArray`s wrapped around a range. This simplifies some code and also makes our more complicated `AbstractOperations` tests pass.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/757:194,simpl,simplifies,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/757,1,['simpl'],['simplifies']
Usability,"This PR changes the name of the `Forcing` constructor to `ModelForcing` to clarify the difference between constructors for forcing objects on single fields, and constructors for the `NamedTuple` of forcing objects for all model fields. It also conventionalizes the name of the fields in `ModelForcing`, so that . ```julia; forcing = ModelForcing(u=u_forcing); ```. is used to apply the forcing function `u_forcing` to `u`. . In addition it adds a new type ""`SimpleForcing`"", which permits users to pass functions of `x`, `y`, `z`, and `t`. A few validating lines in the `ModelForcing` constructor ensure that forcing functions for `u`, `v`, and `w` are applied at the correct locations. For example, we can now write. ```julia; T_forcing = SimpleForcing((x, y, z, t) -> exp(z) * cos(t)). model = Model(forcing=ModelForcing(T=T_forcing)); ```; To create a forcing on temperature that decays exponentially in z and oscillates in time. To test this functionality, this PR introduces an example ""`ocean_convection_with_plankton`"" that uses `SimpleForcing` to model the growth and decay of a plankton-like tracer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/444:458,Simpl,SimpleForcing,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444,3,['Simpl'],['SimpleForcing']
Usability,"This PR cleans up / shortens code for `FieldTimeSeries` and makes the `OnDisk` backend usable. In a future PR I think we'll need a ""partially in memory"" abstraction, ie chunked data retrieval.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3014:87,usab,usable,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3014,1,['usab'],['usable']
Usability,"This PR continues #1085 the work that started on a fork long ago. @siddharthabishnu feel free to continue working on this Oceananigans branch now ;). Some of the things we discussed to do:. - [ ] convert to lat-lon grid; - [ ] add some bathymetry, e.g., bathtub-type of domain prescribed by some analytical function; - [ ] use Ri-based diffusivity for BL closure; - [ ] remove horizontal viscosities/diffusivities; - [ ] potentially run long, save checkpoint, and then resume to run for 6-12 months in the docs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3087:469,resume,resume,469,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087,1,['resume'],['resume']
Usability,"This PR converts `Simulation.stop_criteria` to `Callback`s. This change allows users to more easily add their own custom stop criteria as callbacks. ### Example. We're interested in running a suite of turbulence simulations involving a transition to turbulence. For this purpose, we'd like to stop a simulation whenever the turbulent kinetic energy exceeds some multiple of its initial value (since I'm interested mainly in the _transition_ to turbulence, rather than the ensuing dynamics. After this PR, this can be implemented by writing. ```julia; # Build a simulation. function turbulent_kinetic_energy_threshold_exceeded(sim). mean_tke = mean(tke_operation) # tke_operation is an `AbstractOperation` that computes turbulent kinetic energy. if mean_tke > 1e-6 # arbitrary threshold for this example!; @info ""Simulation is stopping because the turbulent kinetic energy threshold has been exceeded.""; sim.running = false; end. return nothing; end. # Because this computation is relatively expensive, we perform it every 100 iterations; simulation.callbacks[:tke_threshold] = Callback(turbulent_kinetic_energy_threshold_exceeded, IterationInterval(100)); ```. Previously, it wasn't useful to modify `sim.running` because it would be overwritten immediately. So before this PR, the only way to stop a simulation is to throw an error. This PR _could_ also convert the `NaNChecker` to a stop criterion. In fact we should probably do that. But feedback is welcome beforehand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2048:1441,feedback,feedback,1441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048,1,['feedback'],['feedback']
Usability,"This PR differentiates the AMD model constants for eddy viscosity and eddy diffusivity, and permits them to be functions of `x, y, z`. . For simplicity we will permit just one model constant specification for all tracers. It is possible to permit different constants for different tracers, but . Also, with this PR the ""Verstappen"" implementation of AMD is now diverging from the ""Rozema"" implementation. It may be time to nuke the ""Rozema"" implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/622:141,simpl,simplicity,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/622,1,['simpl'],['simplicity']
Usability,"This PR eliminates `AbstractEddyDiffusivity` in favor of simply defining `viscosity` and `diffusivity` directly for the LES closures. It also converts the boundary layer parameterizations to subtype `AbstractScalarDiffusivity{TD, VerticalFormulation}`. This change eliminates much code duplication. I'm also removing the ""background"" diffusivities/viscosities from the LES closures. Closes #1277; Closes #1381. TODO:. - [x] Pass closures into `ivd_upper_diagonal` and implement `ivd_upper_diagonal` for closure tuples and filter out explicit closures before implicit solve; - [x] Change ""diffusivity extractors"" like `κᶠᶜᶜ` so they take `closure` as an argument.; - [x] Support `viscosity(closure::Tuple, K)` cc @tomchor ; - [x] Test `DiffusiveCFL` for closure tuples; - [x] We won't need `z_diffusivity` etc anymore?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295:57,simpl,simply,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295,1,['simpl'],['simply']
Usability,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1301:485,simpl,simply,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301,1,['simpl'],['simply']
Usability,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/839:353,intuit,intuitive,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839,1,['intuit'],['intuitive']
Usability,"This PR fixes the behavior seen in https://github.com/CliMA/Oceananigans.jl/issues/2497. Basically due to the behavior of `construct_output()` and the default values for `indices` in the output writer constructors, whenever we pass a `Field` that is already sliced, we re-slice it when constructing the outputs. I'm not sure how to best avoid this behavior (I'm inclined to change the default value of `indices` in the output writers, but I'm taking suggestions), so I'm starting by simply adding a test that should fail without this fix. Closes https://github.com/CliMA/Oceananigans.jl/issues/2497",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508:483,simpl,simply,483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508,1,['simpl'],['simply']
Usability,"This PR follows up on PR #337 . Should help with adding noise to initial conditions as `rand` and `randn` aren't available in CUDAnative.jl. So we can use arrays to initialize with noise. @glwagner you had issues with generating random numbers on the GPU in the past?. Looks like a ridiculously simple kernel lol but it means you just supply an` Nx*Ny*Nz` sized array and not have to worry about halos, or broadcasting over views of non-contiguous views (which results is slow CuArray scalar operations).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/341:295,simpl,simple,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/341,1,['simpl'],['simple']
Usability,"This PR gets rid of the kwargs `computed_dependencies` and `parameters`. Instead we just have ""arguments"", which are varargs to the constructor:. ```julia; using Oceananigans.Operators: ζ₃ᶠᶠᶜ # called with signature ζ₃ᶠᶠᶜ(i, j, k, grid, u, v). grid = model.grid; u, v, w = model.velocities. ζ_op = KernelFunctionOperation{Face, Face, Center}(ζ₃ᶠᶠᶜ, grid, u, v); ```. `compute!` on `KernelFunctionOperation` calls `compute!` on all of the kernel arguments. I think this is a simpler and more intuitive interface leading to more understandable code.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2964:474,simpl,simpler,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2964,2,"['intuit', 'simpl']","['intuitive', 'simpler']"
Usability,This PR greatly simplifies the logic behind `conditional_operation` and how its extended for immersd boundary grid. The end result besides source code clean up seems to be an improvement in type inference. Resolves #3750 I think. But @ali-ramadhan please test. EDIT: I decided not to work on #3791 (here) because this requires fixing a bunch of tests and is a bigger effort.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794:16,simpl,simplifies,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794,1,['simpl'],['simplifies']
Usability,"This PR implements Craik-Leibovich terms in Oceananigans, so that users may model the effect of surface waves. We use the Lagrangian-mean interpretation for the velocity field when surface waves are included, which requires much less modification of the governing equations than the Eulerian-mean interpretation. For example, the tracer equation (and particle advection equation) is unchanged in the Lagrangian-mean interpretation. This PR adds docs that describe the Lagrangian-mean equations, a simple test for instantiation, and an example that runs a very coarse version of the simulation in [McWilliams et al, ""Langmuir turbulence in the ocean,"" Journal of Fluid Mechanics (1997)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38). The surface wave terms are added to a module in `SurfaceWaves.jl`. As discussed previously, this may not be the source code organization we want. We should discuss.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/519:497,simpl,simple,497,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/519,1,['simpl'],['simple']
Usability,"This PR implements a field-dependent boundary conditions feature. This is an extension to the boundary conditions API that leaves existing functionality unchanged. The functionality is similar to that for `Forcing`. For quadratic bottom stress acting on the `u`-velocity we'd write. ```julia; u_bottom_stress(x, y, t, u, v, Cd) = - Cd * u * sqrt(u^2 + v^2). bottom_bc = BoundaryCondition(Flux, u_bottom_stress, field_dependencies=(:u, :v), parameters=1e-3); ```. Dealing with the wall-normal velocity components is a bit annoying. For now we don't interpolate them, which leads to different behavior at left and right boundaries (due to the fact that the wall-normal index is assumed to refer to cell centers). Right now this is not much of a practical issue --- it would only affect cases in which wall-normal velocities were non-zero _and_ those values were used in boundary conditions on other fields. One solution is to store ""wall-normal"" indices separately for each of the `field_dependencies`. Then we can correctly infer the boundary index in `regularize_boundary_condition` because we know field locations there. We still need to:. - [x] update boundary conditions docs; - [x] see if any examples can be simplified?. Resolves #897",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1093:1213,simpl,simplified,1213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1093,1,['simpl'],['simplified']
Usability,"This PR implements a major refactor of the `TurbulenceClosures` module. In particular, it ""standardizes"" how turbulence closures specify diffusive fluxes. Each turbulence closure now defines 12 functions (or opts in to functionality via subtyping, eg `AbstractEddyViscosityClosure`):. * `diffusive_flux_x`, `diffusive_flux_y`, and `diffusive_flux_z` for tracer diffusive fluxes; * `viscous_flux_ux`, `viscous_flux_uy`, and `viscous_flux_uz` for viscous fluxes of x-momentum; * 6 other functions similar to `viscous_flux_ux`, etc for `y` and `z` momentum components. Then there is a single implementation of `∇_κ_∇c`, for example, which calculates the divergence of the diffusive fluxes in a way that generalizes to curvilinear grids. This refactor was not that difficult because many turbulence closures had functions analogous to these --- they were just called by different names. So in a way this PR simply establishes standard notation. A major advantage of standard notation is that we can now correctly specify flux boundary conditions even when we cannot fill halos for this purpose. For example, right now we fill halos so that (fingers crossed!) boundary fluxes are zero when the diffusion operator is evaluated on boundary-adjacent cells, and then in a second step add the specific boundary fluxes. But with a function `diffusive_flux_x`, we can now ""reverse"" boundary fluxes and add specified fluxes generically. This PR therefore makes progress towards #1400. Work on this PR started with a few extra tests for `HydrostaticFreeSurfaceModel` (though its focus is not quite different). So as a bonus this PR also adds tests for `HydrostaticFreeSurfaceModel` (which may need to be disabled if they fail on the GPU so that we can get this PR in sooner rather than later).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1449:903,simpl,simply,903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449,1,['simpl'],['simply']
Usability,"This PR implements a new boundary condition API. It's a bit of a work in progress. Before merging we need:; * tests (simple 1D test with temperature to see if budgets are correct?); * export some appropriate objects / functions to user; * some API development to make boundary condition specification easier; * documentation. Criticism welcome!. ## Summary of implementation: the `BoundaryCondition`. The core type of this PR is `BoundaryCondition`. The `BoundaryCondition` has one field, `calc`, and is made callable via. ```julia; (bc::BoundaryCondition)(args...) = bc.calc(args...); ```. A `BoundaryCondition` has one parameter: `BCType`. The `BCType` can be `Default`, `Flux`, or `Value`. We include `Default` because the specification of boundary conditions is baked in to the algorithm. In the case of 'default' boundary conditions, no calculations are made. ### `nboundary_conditions = nfields x ndims x 2`. In principle, the user can specify `5 x 3 x 2` boundary conditions: on each of the 5 fields (which we currently have --- unfortunately, we may want more in the future), the user can specify a condition on any of the 6 boundaries. The model is initialized with all 30 boundary conditions set to `Default`. We allow for all possible boundaries to have conditions by introducing three structs:. * `CoordinateBoundaryConditions` with fields `left` and `right`; * `FieldBoundaryConditions` with fields `x`, `y`, and `z`; * `BoundaryConditions` with fields `u`, `v`, `w`, `T`, and `S`. ### Specifying boundary conditions and user API. A boundary condition is now specified by defining a function that calculates it within a kernel that loops over the boundary in question. The arguments of a flux boundary conditions on a top or bottom boundary (the only situation supported so far) are. ```julia; u, v, w, T, S, t, step, Nx, Ny, Nz, Δx, Δy, Δz, i, j; ```. This will probably change in the future. The user API is rather threadbare at the moment. To define a constant flux boundary condition,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118:117,simpl,simple,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118,1,['simpl'],['simple']
Usability,"This PR implements a relatively simple convective adjustment scheme that provides the option for convective adjustment of both momentum and tracers. The closure scheme implements only a vertical diffusivity, and has a convenience ""background diffusivity"" in addition to a convective diffusivity that is active when the buoyancy gradient is unstable. Both the convective and background diffusivities may be functions of space and time, or may be discrete fields, and can be different for each tracer. Here's a result from a new validation test:. ![image](https://user-images.githubusercontent.com/15271942/120872660-cf88cc00-c54b-11eb-991a-8ff835bd3eb0.png). I also need to add unit tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1738:32,simpl,simple,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738,1,['simpl'],['simple']
Usability,"This PR implements the formulation of the default preconditioner for GPU following Marshall J. et al., ""Finite-volume, incompressible Navier Stokes model for studies of the ocean on parallel computers"" (here called `SimplifiedInversePreconditioner`). Also, the `Jacobi` preconditioner has been removed as it gives no benefits in terms of speed",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2141:216,Simpl,SimplifiedInversePreconditioner,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2141,1,['Simpl'],['SimplifiedInversePreconditioner']
Usability,"This PR implements the infrastructure for open boundary conditions in the `NonhydrostaticModel` as well as a few simple methods. . This PR:. - [x] Adds a `matching_scheme` property to `Open` boundary classifications to allow different `fill_X_halo!` to be dispatched; - [x] Introduces `update_boundary_condition!` to be called before halo fills allowing the `mathcing_scheme` to have properties which can evolve with the model; - [x] Make the existing tests pass; - [x] and implements a zero gradient matching scheme. (Others please feel free to update this comment as necessary.). ------------------------------------------------------------------------; Hi all,. Following discussion with @glwagner, @simone-silvestri, and @jm-c this is a first attempt at implementing open boundary conditions. First I will try to get it working for the non-hydrostatic model which seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:113,simpl,simple,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['simpl'],['simple']
Usability,"This PR introduces a validation test replicating the mesoscale eddying channel setup discussed in section 3(b) of Haine & Marshall (1998). It's not clear we want to make this a full validation test so I'm leaving it as a draft PR for now. We may instead want to move to more realistic simulations with a LESbrary approach. References; ----------; Haine & Marshall (1998). [Gravitational, symmetric, and baroclinic instability of the ocean mixed layer](https://doi.org/10.1175/1520-0485(1998)028<0634:GSABIO>2.0.CO;2). Journal of physical oceanography, **28**(4), pp. 634-658.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771:148,clear,clear,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771,1,['clear'],['clear']
Usability,"This PR introduces an interface for `column_height` that returns the height of the water column. ; This is simply `grid.Lz` in regular grids. For `AbstractGridFittedBottom` immersed grids, the column height is readily read from the immersed boundary, provided that the immersed boundary represents the _numerical_ bottom rather than the _physical_ bottom. ; Therefore, this PR changes the constructor of the `ImmersedBoundaryGrid` to store the z-coordinate of the last immersed cell. In this way, the bottom height is also uniquely defined for `GridFittedBottom`, removing the necessity of having a`CenterImmersedCondition` and a `InterfaceImmersedCondition`. . An immediate application of this interface is in the `SplitExplicitFreeSurface` where the bottom_height was previously stored.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841:107,simpl,simply,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841,1,['simpl'],['simply']
Usability,"This PR is a revision of Github issue PR [2949](https://github.com/CliMA/Oceananigans.jl/pull/2949) and is related to issue [1546](https://github.com/CliMA/Oceananigans.jl/issues/1546). There is a potential conflicting PR [2538](https://github.com/CliMA/Oceananigans.jl/pull/2538). This PR brings in the AMDGPU backend for kernelabstractions for the hydrostatic primitive equation solver. . @simone-silvestri and @siddharthabishnu have guided me towards using a global double drake simulation as a testbed for this porting activity, benchmark scripts are at https://github.com/simone-silvestri/OceanScalingTests.jl/blob/ss-js/adapt_double_drake/run_double_drake.sh",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3466:436,guid,guided,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3466,1,['guid'],['guided']
Usability,"This PR is a stab at implementing the pressure solvers plan/overhaul outlined in #586. So far it implements pressure solvers for all types of domains (triply/doubly periodic, channels, and boxes) on regular grids (except boxes on GPUs for now). Equally important, it refactors and cleans up the pressure solvers so that we can now easily add in pressure solvers for vertically stretched grids and distributed models. A lot of cleanup was done in the process as well. Pressure solver code and kernels have been fully moved from the `TimeSteppers` submodule to the `Solvers` submodule. Different parts have been reorganized into multiple files and the index permutation business has been abstracted away a bit so we have fewer ugly kernels (and fewer kernels!). I could have gone much further in condensing the code base and number of pressure solvers. You'll notice quite a bit of code repetition, but I think for now and the forseeable future this is actually a good thing. The pressure solver code is nontrivial and keeping it as simple as possible will improve the readability and longevity of the code base. It's also easier to add and modify pressure solvers now. For example, if @sandreza wants to implement a fast pressure solve that only works for horizontally periodic domains (Kleiser-Schumann?), it's now much easier to do that. I should probably add some benchmarks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/589:1031,simpl,simple,1031,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/589,1,['simpl'],['simple']
Usability,"This PR is part 1/3 of making boundary conditions a field property. I was refactoring the fields module, and in doing so I added optional kwargs to allow for data arrays to be passed. This allows the checkpointer to be simplified as it no longer has to keep track of array references, and makes restoring/checkpointing large models possible. I will address this in part 2. Changes:. 1. `AbstractLocatedField` has been removed. Now there is only `AbstractField`. 2. Fields can now be initialized with a data array. This will make restoring/checkpointing large models possible. Right now `field.data` can store anything. We could check to make sure that `field.data` has the same size as the grid, but this is extra code and could limit flexibility in the future so I did not add a check for this. 3. Field tuple initializers (`VelocityFields`, `TracerFields`, etc.) can now accept data arrays through keyword arguments. 4. `FaceFieldX` has been renamed to `XFaceField`, and same for y and z. Note: This PR branches off #626.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/627:219,simpl,simplified,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627,1,['simpl'],['simplified']
Usability,"This PR makes it a bit easier to prescribe `BoundaryFunction`s by providing field-specific constructors. The field-specific constructors ""know"" about the locations of tracers and velocity fields and relieve the user of the (often confusing) task of specifying the `BoundaryFunction` location.; I also added a further wrapper around `BoundaryCondition` to permit patterns like. ```julia; northern_velocity(x, z, t) = cos((x - sin(t))); u_bcs = UVelocityBoundaryConditions(grid, north=UVelocityBoundaryCondition(Value, :y, northern_velocity)); ```. It doesn't look perfect to me, but I do think it's progress over what the user had to do previously. A potential source of confusion (?) is that `UVelocityBoundaryCondition` is only needed for simple boundary functions. We could alleviate this with more verbosity; eg `UVelocityFunctionBoundaryCondition` or something silly like that. But I'm hesitant because we already seem to have a verbosity problem. We need better design, not more words... I've also added a `parameters` field to `BoundaryFunction`. (It only just occurs to me that perhaps what we want are types like `Tracer()`, `U()`, `V()`, and `W()`. We might use these to classify boundary conditions and forcing functions... ?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/699:740,simpl,simple,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/699,1,['simpl'],['simple']
Usability,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2597:417,simpl,simplify,417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597,3,['simpl'],"['simpler', 'simplifies', 'simplify']"
Usability,"This PR modifies the time-stepping algorithm so that the tendencies for wall-normal velocity components are calculated on boundaries in `Bounded` directions. In other words, when `x` is `Bounded`, the algorithm now calculates `Gu` on east boundaries, where `i=Nx+1`. Previously `Gu` was only calculated on west boundaries where `i=1`. The same applies to `y` and `z`. This change is necessary because, in general, the values of `Gu`, `Gv`, and `Gw` on `x`, `y`, or `z` boundaries are needed to impose predictor velocity and pressure boundary conditions when `x`, `y`, or `z` are `Bounded` --- respectively. The changes in this PR also motivated a slight refactoring of the way ""equations"" are specified. There is now a file dedicated to equation / tendency specification, called `velocity_and_tracer_tendencies.jl` in `src/TimeStepping`. Resolves #259 (since it implements a simple / minimal abstraction for equations).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/677:875,simpl,simple,875,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/677,1,['simpl'],['simple']
Usability,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1971:96,simpl,simplifies,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971,1,['simpl'],['simplifies']
Usability,"This PR overhauls the infrastructure supporting user-defined forcing functions. Many of these changes are discussed in #896 . ## `ModelForcing` is no more. The first important change is the elimination of `ModelForcing`. The `forcing` kwarg in the constructor for `IncompressibleModel` now accepts a named tuple, similar to the kwarg `boundary_conditions`. ## New default for `IncompressibleModel`. Second, functions that are passed directly to `IncompressibleModel` are assumed to have the ""continuous form"" signature. ```julia; func(x, y, z, t); ```. ## New user-facing function: `Forcing`. Third, forcing functions that deviate from this default behavior should be constructed with the function `Forcing`. Thus `SimpleForcing` is eliminated, as well as `ParameterizedForcing`. Moreover, simple-forcing-like functions can now depend on arbitrary fields interpolated to the location at which the forcing is applied. We thus support constructs like. ```julia; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P); ```. provided that `:P` is in `model.tracers`. ### Docstring for `Forcing`. ```julia; """"""; Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false). Returns a forcing function added to the tendency of an Oceananigans model field. If `discrete_form=false` (the default), and neither `parameters` nor `field_dependencies`; are provided, then `func` must be callable with the signature. `func(x, y, z, t)`. where `x, y, z` are the east-west, north-south, and vertical spatial coordinates, and `t` is time.; Note that this form is also default in the constructor for `IncompressibleModel` and `Forcing` is; not needed for forcing functions of this form. If `discrete_form=false` (the default), and `field_dependencies` are provided,; the signature of `func` must include them. For example, if `field_dependencies=(:u, :S)`; (and `parameters` are _not_ provided), then `func` must be callable with the sign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:715,Simpl,SimpleForcing,715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,2,"['Simpl', 'simpl']","['SimpleForcing', 'simple-forcing-like']"
Usability,"This PR prototypes a concept for a coupled atmosphere-ocean model. This introduces a new relatively simple `AbstractModel` type:. ```julia; struct CoupledAtmosphereOceanModel{O, A, C, P} <: AbstractModel{Nothing}; atmos :: A; ocean :: O; clock :: C; air_sea_flux_parameters :: P; end; ```. which defines a new `update_state!` that computes bulk formulae, and a `time_step!` that looks like. ```julia; function time_step!(coupled_model::CoupledAtmosphereOceanModel, Δt; euler=false); time_step!(coupled_model.ocean, Δt; euler); time_step!(coupled_model.atmos, Δt; euler); update_state!(coupled_model, false); return nothing; end; ```. Air-sea fluxes are computed in `update_state!`:. ```julia; # Use broadcasting to compute bulk formula for surface wind stress; topo = topology(atmos_grid); Nx, Ny, Nz = size(atmos_grid); Hx, Hy, Hz = atmos_grid.Hx, atmos_grid.Hy, atmos_grid.Hz; ii = Hx+1:Hx+Nx; jj = topo[2]() isa Flat ? 1 : Hy+1:Hy+Ny # hack because 2D can be fun; k = atmos_grid.Hz+1 # surface atmospheric velocity; ua₁ = view(parent(ua), ii, jj, k:k); va₁ = view(parent(va), ii, jj, k:k). @. atmos_surface_flux_u = - cᴰ * ua₁ * sqrt(ua₁^2 + va₁^2); @. atmos_surface_flux_v = - cᴰ * va₁ * sqrt(ua₁^2 + va₁^2). @. ocean_surface_flux_u = ρ_atmos / ρ_ocean * atmos_surface_flux_u; @. ocean_surface_flux_v = ρ_atmos / ρ_ocean * atmos_surface_flux_v; ```. A few tweaks to how output writers work (making them function more like callbacks) makes output work with the coupled models, too. This PR also contributes a simple boundary layer turbulence example. The setup is not very user-friendly right now, but this PR shows that this sort of science is possible. In short, this is accomplished by building two Oceananigans models and passing them to `CoupledAtmosphereOceanModel`. ## Notes on how development could proceed . To make the setup more user friendly, this abstraction should probably include:. * more automated grid creation that ensure horizontal domains are the same extent; * better bulk for",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1916:100,simpl,simple,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916,1,['simpl'],['simple']
Usability,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/570:455,simpl,simplified,455,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570,1,['simpl'],['simplified']
Usability,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405:852,simpl,simply,852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405,1,['simpl'],['simply']
Usability,This PR refactors the kernels for turbulence closures to pave the way for new closures that require knowledge of buoyancy and buoyancy gradients. It also performs some minor cleanup in `closure_operators.jl` and moves the turbulence closure implementations into a separate folder so that it is clear from the source structure which turbulence closures are implemented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/515:294,clear,clear,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/515,1,['clear'],['clear']
Usability,This PR reformulates TKEBasedVerticalDiffusivity simply through a redefinition of parameters. It also makes a more important change to the code that passes `model.closure` and `model.buoyancy` to the kernels that evaluate boundary fluxes. This is necessary to make `TKEBasedVerticalDiffusivity` models robust against changes to parameters after model construction. The changes are made in a way that have no affect on the API or other models. Resolves #1695 . cc @adelinehillier,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1883:49,simpl,simply,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1883,1,['simpl'],['simply']
Usability,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/711:1540,simpl,simply,1540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711,1,['simpl'],['simply']
Usability,"This PR removes some of the warnings that output writers throw when trying to save or serialize functions to disk. These warnings are outdated in a way because they are really aimed at users trying to restore models from a checkpoint. Previously, we used to require that an entire model could be deserialized from disk when restoring from a checkpoint. This created special headaches for models that involved user-defined functions. . But now we have a much better and simpler way for restoring models from a checkpoint. As a result we rarely care whether or not boundary conditions are serialized to disk if they are functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2375:469,simpl,simpler,469,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2375,1,['simpl'],['simpler']
Usability,"This PR removes the CubedSpheres module and re-implements CubedSphere grid using the MultiRegion module. Furthermore, it improves the OrthogonalSphericalShellGrid. ## Implemented in this PR; - uses Distances package which allowed us to clear up various utilities in the grid_utils.jl file regarding great circle distances on the sphere; - fix some bugs that didn't allow an OrthogonalSphericalShellGrid to be constructed with any topology; - better and more accurate show methods that also work on the GPU.; - construct ConformalCubedSphereGrid + tests; - introduces the Connectivity type for MultiRegionGrids + adds a default CubedSphereGrid connectivity; - adds halo filling functionality for tracers + velocities ( + tests); - introduced CubedSphereField abstraction; - introduces CubedSphereConnectivity + tests. ## Outstanding issues; (Several issues will be opened as soon as this PR is merged for the following); - Coordinate and metric halo fillings for the ConformalCubedSphereGrid are hardcoded. We need to re-implement this based on the connectivity of the grid so that it works (i) for any connectivity and (ii) for any CubedSpherePartition.; - Properties `ξₗ, ξᵣ, ηₗ, ηᵣ` should be taken out from OrthogonalSphericalShellGrid _or_, even better, be grouped together into a property `conformal_cubed_sphere` or something. This way, the OrthogonalSphericalShellGrid will be general and not necessarily tied to the conformal cubed sphere.; - Differentiate the OrthogonalSphericalShellGrid constructors from the cubed_sphere_panel constructors; - Shortcut for velocity halo filling; - Alleviate the need for multiple hallo filling passes for velocities (**important for performance/scaling**); - Add testing for MultiRegionGrids with `YPartition`; - Allow uneven x-y partition for ConformalCubedSphere",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867:236,clear,clear,236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867,1,['clear'],['clear']
Usability,"This PR replaces #3509. Also, it builds off #3585 which hopefully we can merge soon so we don't enter merge conflict hell. In short this PR implements k-epsilon. Although, the version that's implemented now is not by-the-book k-epsilon but rather a simplified version. I'd like to merge this PR basically as is and hopefully continue to work on it in the future. There are some numerical considerations which should be reviewed and documented I think. First of all is the challenge of specifying a minimum tke, minimum dissipation rate, and also a maximum dissipation rate. These are useful for producing smooth diffusivities, which note are . $$ \kappa \sim \frac{e^2}{\epsilon} $$. But then there are challenges with implementing the TKE and dissipation equations. Because depending on the term, one may either want to impose or not impose these constraints. It could be useful to try to get some lessons from other codes too. It's not ready for production use, but at least it's doing reasonable things... <img width=""384"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/c7df14e6-8ed2-4c13-b892-99b04e5f8809"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3605:249,simpl,simplified,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3605,1,['simpl'],['simplified']
Usability,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2121:1406,simpl,simply,1406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121,1,['simpl'],['simply']
Usability,"This PR simplifies and generalizes the model constructor, which is a major change to the API. Except for `initialize_tracers` and `float_type`, all of the keyword arguments to `Model` now correspond semantically to the fields of model. In addition to clarifying the arguments of the model constructor, this will make checkpointing easier. . In addition, model fields that contain arrays, and thus are involved with large amounts of memory allocation, can be initialized through the model constructor. This should enable upgrades to the checkpointer that make it possible to checkpoint very large models that fill GPU memory. Finally, we add three new convenience constructors that retain the legacy behavior of model, and provide convenient ways to initialize particular models: `BasicModel`, `BasicChannelModel`, and `NonDimensionalModel`. `BasicModel` and `BasicChannelModel` closely resembles the original model constructor, while `NonDimensionalModel` allow parameters to be set by specifying non-dimensional numbers, rather than dimensional constants. Resolves #372.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/401:8,simpl,simplifies,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401,1,['simpl'],['simplifies']
Usability,"This PR simplifies the API for specifying boundary conditions that are functions. We build boundary conditions by writing. ```julia; bc = BoundaryCondition(BCType, condition); ```. where `BCType` is the ""type"" of the boundary condition (`Value`, `Gradient`, `Flux`, `NormalFlow`), and `condition` is the boundary condition. If `condition` is a function, it is now assumed it can be called with the signature `condition(ξ, η, t)`, where `(ξ, η)` are spatial coordinates that vary along the boundary in question (`y, z` for `x`-boundaries, `x, z` for `y`-boundaries, and `x, y` for `z`-boundaries). Different behavior is achieved by specifying keyword arguments of `BoundaryCondition`. For example, a non-`nothing` `parameters` keyword argument means that the last argument of condition is `parameters`: `condition(ξ, η, t, parameters)`. If `discrete_form=true`, the original behavior of `BoundaryCondition` is recovered, so that `condition` is called with the ""discrete form"" `condition(i, j, grid, clock, state)`, where `i, j` are indicies that vary along the boundary in question. Specifying both `discrete_form=true` and non-`nothing` `parameters` transforms `condition` into a `ParameterizedDiscreteBoundaryFunction`, which is called with `condition(i, j, grid, clock, state, parameters)`. Under the hood, this functionality is achieved by assuming that boundary conditions for fields are always built with `FieldBoundaryConditions`. This assumptions means we can use the information provided there to ensure that `BoundaryFunction`s are always tagged with the correct boundary plane and cell location. This relieves the user from having to specify the boundary plane and cell location of a `BoundaryFunction` explicitly. We hope this simplifies the API. Resolves #769",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894:8,simpl,simplifies,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894,2,['simpl'],['simplifies']
Usability,"This PR simplifies the Docs/Appandix/Library and also adds missing modules in it. . Furthermore, it enhances formatting in several docstrings and converts some examples to doctests. Closes #2080. For example, regarding 2 vs 4 spaces in markdown formatting,. **before this PR**. <img width=""994"" alt=""Screen Shot 2021-11-25 at 4 03 01 pm"" src=""https://user-images.githubusercontent.com/7112768/143382619-b30f8312-fd64-4240-a59a-d8b3d6e50484.png"">. while **after this PR**. <img width=""861"" alt=""Screen Shot 2021-11-25 at 4 02 41 pm"" src=""https://user-images.githubusercontent.com/7112768/143382640-469f9d58-07cc-4a42-97f4-1c6c4bdeb43b.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2082:8,simpl,simplifies,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2082,1,['simpl'],['simplifies']
Usability,"This PR simplifies the function signatures for boundary condition functions and forcing functions. ; It also nukes the `model.parameters` field in favor of more local ""parameters"" functionality, and adds `ParameterizedForcing` and `ParameterizedBoundaryCondition` convenience types and functions. The new forcing function signature is. ```julia; F(i, j, k, grid, clock, state); ```. while the new boundary condition function signature is. ```julia; bc(i, j, grid, clock, state); ```. where `i, j` are indices along the boundary. `state` is a `NamedTuple` with fields `:velocities`, `:tracers`, and `:diffusivities`, each corresponding to an `OffsetArray` that references the data associated with each field. In the future, if we make substantial changes to `model`, the hope is that we can modify/extend `state` appropriately and thus leave user code unbroken. We should probably release a new minor version when this is merged. Resolves #682 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697:8,simpl,simplifies,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697,1,['simpl'],['simplifies']
Usability,"This PR simply cherry picks the commits from #698, which were accidentally reverted with #697 was merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/709:8,simpl,simply,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/709,1,['simpl'],['simply']
Usability,"This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm. This PR also extends the tests to include non-uniform distributed partitioning . The proposal of this PR (up to discussion and tweaking) is to allow calling; ```julia; arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); ```; which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3339:26,simpl,simplify,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339,1,['simpl'],['simplify']
Usability,"This PR updates the code to use kinematic (density normalized) hydrostatic pressure and buoyancy rather than density perturbation. Using kinematic pressure simplifies the code because the reference density no longer affects the algorithm. Using buoyancy instead of the density perturbation will ultimately simplify the code further because it is needed for turbulence closures (for example). The docs should be updated before merging. Also, the golden master tests should be updated elsewhere; then it can be confirmed here that these changes preserve the functioning of the code (these changes do not affect the outcome of the algorithm). I have also copy/pasted an interpolation operator that will become part of the code once #234 is merged. Prior to this PR, the interpolation of the buoyancy field to z faces was done manually. We need a function to calculate buoyancy for the turbulence closures; so I think we are better off deleting the density perturbation function, ultimately. After this change the reference density ceases to be used in the algorithm. I have also included salinity in the calculation of buoyancy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/236:156,simpl,simplifies,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/236,2,['simpl'],"['simplifies', 'simplify']"
Usability,"This PR uses a continuous forcing immersed boundary method to simulate viscous flow around a cylinder. I think this is a pretty common test case of CFD codes: as you increase the Reynolds number, you should start to see vortex shedding behind the cylinder which we do see. Movie: https://www.youtube.com/watch?v=s7u_OJXFMoQ; ![image](https://user-images.githubusercontent.com/20099589/76267706-05081200-6242-11ea-8567-41068235616e.png). I think it shows the ease with which Oceananigans can support topography and arbitrary boundaries that could even depend on time: e.g. static cavities in ice shelves, an urban skyline, or a moving lid (non-interacting ice floe?). This method is much simpler to implement than sigma coordinates, is more flexible, and is probably pretty accurate for most problems you'd try to model with Oceananigans (i.e. we're not modeling coastlines on a sphere). Should discuss what an API for topography/boundaries would look like before finishing this PR off. See #694. X-Ref #530",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/693:687,simpl,simpler,687,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693,1,['simpl'],['simpler']
Usability,"This PR will implement support boundary conditions on immersed boundaries. The design is to add a new function to the tendency kernel function for each field that represents the contribution to the viscous / diffusive flux divergence in boundary-adjacent cells due to the user-defined immersed boundary condition. This PR will support `Flux` boundary conditions for sure. If it turns out to be simple, this PR will also support `Value` / `Gradient` boundary conditions for `ScalarDiffusivity`. There may be some challenges when `ScalarDiffusivity` is embedded in a closure tuple (ie the case we get for wall-resolved LES). Hopefully the solution to that is not too complicated. Another problem to solve is how to ""regularize"" `ContinuousBoundaryFunction`. Immersed boundary conditions are 3D, so function of `i, j, k`. Thus we need a slightly different interface for them. `discrete_form=true` will also have a different signature (`i, j, k, grid, ...` rather than `i, j, grid, ...`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437:394,simpl,simple,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437,1,['simpl'],['simple']
Usability,"This PR will rename some variables and funcitons in the `TurbulenceClosures` module to make things more clear. ~It will also remove the fallback dispatch of `calc_ κᶜᶜᶜ()` and define `calc_ κᶜᶜᶜ()` at least for the Smagorisnky-Lilly closure.~. It also changes the behavior of `viscosity()` to return a tuple when given a tuple, instead of `sum`ming all the viscosities in the tuple. This avoids misuse by unattentive users who have a tuple with different-formulation-viscosities (for example horizontal and vertical formulations). ([This comment](https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938) provides an example.). Closes https://github.com/CliMA/Oceananigans.jl/issues/2751. CC @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752:104,clear,clear,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752,1,['clear'],['clear']
Usability,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1057:849,simpl,simplify,849,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057,1,['simpl'],['simplify']
Usability,"This changes the behavior of `show()` for VerticallyStretchedGrids to. ```julia; VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 500.0], y ∈ [0.0, 23.4375], z ∈ [0.0, 100.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (128, 1, 32); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (3.90625, 23.4375, [min=0.97654576571653, max=5.174919985099578]); ```. This is very clear but also a bit on the verbose side. Another option would be. ```julia; VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 500.0], y ∈ [0.0, 23.4375], z ∈ [0.0, 100.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (128, 1, 32); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (3.90625, 23.4375, [0.97654576571653, 5.174919985099578]); ```. and then the `min` and `max` are implicit. I'm happy to change to whatever is preferred. CC @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1494:446,clear,clear,446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1494,1,['clear'],['clear']
Usability,"This fixes a minor bug in the grid constructor and contributes some simple tests to verify correct grid construction. It also adds the syntax. ```julia; g = RegularCartesianGrid(Float32, (nx, ny, nz), (Lx, Ly, Lz)); ```. for constructing grids with element type `Float32` (for example).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/4:68,simpl,simple,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/4,1,['simpl'],['simple']
Usability,"This fleshes out the `ReducedField` implementation a bit more by adding `boundary_conditions`. The `DefaultBoundaryCondition` for a reduced dimension is `nothing`. . This PR also generalizes our `launch!` utility so that kernel layouts can be ""flattened"" along reduced dimensions. It feels like there's a lot of boilerplate in our halo-filling functionality, but I'm not 100% sure how to mitigate (except with some hacky code generation which, we already have some of, and doesn't seem like the right solution). I also took the liberty to generalize halo filling for `Value` and `Gradient` halos while I was in the files (slight scope creep) so that simple `Value`/`Gradient` boundary conditions can be implemented that don't require the `clock, model_fields` keyword arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1350:650,simpl,simple,650,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1350,1,['simpl'],['simple']
Usability,"This is a minor thing but I just noticed that the package's description is this:. ![Screenshot_20211016_073544](https://user-images.githubusercontent.com/13205162/137591563-50280525-ffbd-46cf-b838-b0983a7ed0d2.png). Maybe it's because I'm not a native English speaker, but ""oceanic library"" reads pretty weird to me. Maybe ""ocean-focused"" lilbrary? Or maybe something simpler but a bit more verbose: ""A library for fast, friendly, data-driven fluid dynamics on CPUs and GPUs with a focus on the ocean"".",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017:368,simpl,simpler,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017,1,['simpl'],['simpler']
Usability,This is a simple example with immersed boundary. https://github.com/CliMA/Oceananigans.jl/assets/7112768/b225a647-7f21-4dcc-8b12-1ae9d662d106,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132:10,simpl,simple,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132,1,['simpl'],['simple']
Usability,"This is a very minor thing, but I have been using netCDF files almost exclusively and I've noticed that, while all the length dimensions have their names and units very well defined in the attributes, the `time` dimension does not. . It's clear what `time` is so this isn't a big issue, but it would be nice somewhere along the line to also include that. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1208:239,clear,clear,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1208,1,['clear'],['clear']
Usability,"This is an attempt to make the left menu of the docs feel a bit more intuitive and organized. What I did:. - Moved benchmarks, function index and library to appendix. I think not many people need that information, so it makes sense put it there I think); - Moved appendix to be the last item on the menu (as is customary for most documents); - Moved gallery to after the contributor's guide (since I think contributor's guide is more important so it can come first). I know this is unprompted (nobody complained about the docs) but I think it's a positive change. Eager to hear opinions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1838:69,intuit,intuitive,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1838,3,"['guid', 'intuit']","['guide', 'intuitive']"
Usability,"This is the current docstring:. ```julia; help?> WENOVectorInvariant; search: WENOVectorInvariant. WENOVectorInvariant(; upwinding = nothing,; multi_dimensional_stencil = false,; weno_kw...); ```. It doesn't make it clear how we would build the advection scheme that is the current default for the hydrostatic model in `ClimaOcean` (arguably the most important case). X-ref: https://github.com/CliMA/ClimaOcean.jl/issues/129",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3703:216,clear,clear,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3703,1,['clear'],['clear']
Usability,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1930:205,feedback,feedback,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930,2,"['feedback', 'simpl']","['feedback', 'simply']"
Usability,"This is what's keeping tests in https://github.com/tomchor/Oceanostics.jl/pull/151 from passing. Here's the simplest MWE I could come up with:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid,);. julia> test(i, j, k, grid, auxiliary_fields,) = 1.0;. julia> a = KernelFunctionOperation{Center, Center, Center}(test, model.grid, model.auxiliary_fields);. julia> compute!(Field(a)); ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:466; [2] isregional(t::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:105; [3] _findfirst_rec (repeats 2 times); @ ./tuple.jl:414 [inlined]; [4] findfirst(f::Function, t::Tuple{Tuple{DataType, DataType, DataType}, NamedTuple{(), Tuple{}}}); @ Base ./tuple.jl:421; [5] #construct_regionally#52; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:146 [inlined]; [6] construct_regionally; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:143 [inlined]; [7] #construct_regionally#51; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139 [inlined]; [8] construct_regionally(::Function, ::Tuple{DataType, DataType, DataType}, ::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139; [9] indices(κ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3232:108,simpl,simplest,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232,1,['simpl'],['simplest']
Usability,"This long overdue PR nukes `restore_from_checkpoint` and all its tests. We've decided to support ""picking up"" a simulation from a checkpoint instead via `run!(simulation, pickup=true)`. The reason is that we can only restore a limited subset of models that don't utilize user-defined functions. ""Restoring"" a model from a checkpoint is an error-prone processes, and supporting `restore_from_checkpoint` has proven difficult. Picking up via `run!(simulation, pickup=true)` has the downside of requiring the original run script to restart a simulation, but the advantage of simplicity. I've also updated the checkpointer documentation to describe `run!(simulation, pickup=true)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1893:572,simpl,simplicity,572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893,1,['simpl'],['simplicity']
Usability,"This makes it so that discrete-form function boundary conditions. ```; bc(i, j, grid, a, b, c, d); ```. will work provided that `fill_halo_regions!` is called with. ```julia; fill_halo_regions!(field, a, b, c, d); ```. The trade-off here is between code clarity and generality. I added a comment to make it clear that at least for Oceananigans models, we use `clock, model_fields`. @simone-silvestri wants to advertise Oceananigans as more generally applicable to any model using a finite volume grid, so this will help achieve that goal...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3630:307,clear,clear,307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3630,1,['clear'],['clear']
Usability,"This question is a bit of a detour from the Ocean, but might occur in the oceanographic context sometime, maybe?. With @writingindy, we have put together a one-layer shallow water magnetohydrodynamic model as presented in [Gilman 2000](https://iopscience.iop.org/article/10.1086/317291/meta). You can see the results of a simulation in the animation below and find the code [here](https://github.com/writingindy/SWMHD/blob/main/sw_mhd_adjustment.jl). To do this we simply needed to add a tracer for the magnetic potential and add a Lorentz force. Luckily, Oceananigans makes it easy to do both! In our formulation, we wrote the Lorentz force as Jacobian, which means that it tends to be noisy and needs dissipation for numerical stability. The Lorentz force can also be written in in terms of advection, but the advection is by a tracer field, which leads to the following question:. Can we use advection schemes in the forcing functions?. https://user-images.githubusercontent.com/8239041/173368598-90b26027-63ab-4fcd-91e9-76618ae002bc.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2609:465,simpl,simply,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2609,1,['simpl'],['simply']
Usability,"This will be one big PR that merges in; 1. code/interface documentation from docstrings,; 2. high-level documentation about the continuous equations and numerical methods employed,; 3. documentation about the verification experiments, and; 4. generated Markdown tutorials from the Literate.jl examples. Once we're happy with the documentation, we'll be ready to submit an entry to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474:963,Simpl,Simple,963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474,1,['Simpl'],['Simple']
Usability,"Title sounds ridiculous but @jm-c mentioned that for stretched grids, models (e.g. WRF) usually place the cell center halfway between the two cell faces, but apparently this choice can be relaxed so that you can specify cell centers to be slightly offset from the true center. I guess they won't be ""cell centers"" anymore, but just opening an issue in case there's anything to discuss. Without assuming cell centers are halfway between the two faces then interpolation operators are a bit more complicated; ```julia; @inline ℑz_aac(i, j, k, grid::VerticallyStretchedCartesianGrid, f) =; @inbounds ((grid.zC[k] - grid.zF[k]) * f[k, j, i] + (grid.zF[k+1] - grid.zC[k]) * f[k+1, j, i]) / grid.ΔzF[k]; ```; and if we assume e.g. `grid.zC[k] - grid.zF[k] = grid.ΔzF[k]/2` then the interpolation operators simplify. So it seems maybe we should just assume that the cell centers are exactly halfway between the faces, unless there's a good reason or important use case for having custom/offset cell center locations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/491:800,simpl,simplify,800,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/491,1,['simpl'],['simplify']
Usability,"To better understand [Wenegrat and Thomas, JPO 2020](https://journals.ametsoc.org/view/journals/phoc/50/6/JPO-D-20-0027.1.xml?tab_body=pdf) (WT2020) I modifed the following examples:. 1. [Internal tide by a seamount](https://clima.github.io/OceananigansDocumentation/stable/generated/internal_tide/) and . 2. [Tilted bottom boundary layer example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/) ,. to study the dynamics of constant flow over a linearly slowing bottom. Note that I tried to pick the parameters as close to one of the cases in WT2020, however I did make some modifications. 1. I changed the direction of the constant horizontal flow (along bathymetry) to avoid inertial instability. This produces simpler dynamics.; 2. The code uses free-slip boundary conditons by default, but I believe I have no slip working as well.; 3. Currently diffusion and viscosity is larger by a factor of `100` as it's easier to resolve the boundary layer that develops. The examples were very easy to modify, which shows that people have done a great job in making them friendly, as promised. Thanks everyone for that! You can find my examples on branch `fjp/Test_ImmersedBoundaryMethod`. . The first code, what I call [take1](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl), uses the immersed boundary method. . Thet second code, what I call [take2](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take2.jl) used the tilted geometry approach. . Below I will share some results that people might find interest, maybe @tomchor in particular?. The first plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of an immersed boundary (take1). We see the isopycnals incrop (reach the bathymetry) at a 90 degree angle, which is consistent with ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526:763,simpl,simpler,763,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526,1,['simpl'],['simpler']
Usability,"To enable checkpoint restoration for large models, we need to revise the model constructor so that `velocities` and `tracers` can be passed as keyword arguments. In addition, I think it might make sense to remove `N`, `L`, and the viscosities from keyword arguments, so that all of the constructor arguments in the *base* model constructor correspond to subfields of `Model`. At the same time and for user convenience, we should add new constructors (perhaps something like `SimpleModel` or `BasicModel`) that *do* have keyword arguments for `N`, `L`, etc. . Through this method we can provide both convenience for users looking for simple and basic functionality while also cleaning up the *base* model constructor for the purpose of checkpointing, code cleanliness, and easier usage for advanced users. We will probably want to remove `N` and `L` from the model constructor anyways when we have more than one type of grid for a user to choose.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/372:475,Simpl,SimpleModel,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/372,2,"['Simpl', 'simpl']","['SimpleModel', 'simple']"
Usability,"To implement the ""Gent-McWilliams"" turbulence closure (and variants of this closure) we need a turbulence closure that accepts skew and symmetric diffusivity components (?), and rotates the diffusive / viscous fluxes into the isopycnal coordinate frame. I think this requires simplifying the already-implemented `TwoDimensionalLeith` closure, which defines functions like. ```julia; # Components of the Redi rotation tensor. @inline function Redi_tensor_xz_fcc(i, j, k, grid::AbstractGrid{FT}, buoyancy, C) where FT; bx = ∂x_b(i, j, k, grid, buoyancy, C); bz = ℑxzᶠᵃᶜ(i, j, k, grid, ∂z_b, buoyancy, C); return ifelse(bx == 0 && bz == 0, zero(FT), - bx / bz); end. @inline function Redi_tensor_xz_ccf(i, j, k, grid::AbstractGrid{FT}, buoyancy, C) where FT; bx = ℑxzᶜᵃᶠ(i, j, k, grid, ∂x_b, buoyancy, C); bz = ∂z_b(i, j, k, grid, buoyancy, C); return ifelse(bx == 0 && bz == 0, zero(FT), - bx / bz); end. @inline function Redi_tensor_yz_cfc(i, j, k, grid::AbstractGrid{FT}, buoyancy, C) where FT; by = ∂y_b(i, j, k, grid, buoyancy, C); bz = ℑyzᵃᶠᶜ(i, j, k, grid, ∂z_b, buoyancy, C); return ifelse(by == 0 && bz == 0, zero(FT), - by / bz); end. @inline function Redi_tensor_yz_ccf(i, j, k, grid::AbstractGrid{FT}, buoyancy, C) where FT; by = ℑyzᵃᶜᶠ(i, j, k, grid, ∂y_b, buoyancy, C); bz = ∂z_b(i, j, k, grid, buoyancy, C); return ifelse(by == 0 && bz == 0, zero(FT), - by / bz); end. @inline function Redi_tensor_zz_ccf(i, j, k, grid::AbstractGrid{FT}, buoyancy, C) where FT; bx = ℑxzᶜᵃᶠ(i, j, k, grid, ∂x_b, buoyancy, C); by = ℑyzᵃᶜᶠ(i, j, k, grid, ∂y_b, buoyancy, C); bz = ∂z_b(i, j, k, grid, buoyancy, C); return ifelse(by == 0 && bx == 0 && bz == 0, zero(FT), (bx^2 + by^2) / bz^2); end; ```. The users most interested in this feature in the immediate future are @sandreza and @xiaozhour . @sandreza and @xiaozhour , can you provide a mathematical description of the closure you would like implemented? Are the Redi tensor functions defined above sufficient? I think they make a small-angle approxima",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1972:276,simpl,simplifying,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1972,1,['simpl'],['simplifying']
Usability,"To improve our documentation before submitting something to JOSS I'd like to actually document more of the numerical methods we use. It would also be good to document everything here in one place (as opposed to merely citing papers) as some of these methods have very little modern documentation online. The only way to understand them is to wade through the original papers which can be frustrating and time consuming. I already have lots of notes on these in my notebook, just need to typeset it into documentation:; * Direct solution of Poisson's equation on a staggered grid using FFTs [Schumann & Sweet (1988)].; * How a fast discrete cosine transform is computed on the GPU [Makhoul (1980)]. The 2D fast DCT is especially undocumented anywhere but the paper and was frustrating to implement.; * Operator splitting, how we enforce incompressibility, and how we treat pressure boundary conditions [Orszag, Israeli, & Deville (1986) will be helpful here].; * How Dirchlet, Neumann, and flux boundary conditions are enforced. Upcoming features that will need to be document. I already have a lot of notes on these:; * Finite volume operators. Will be especially useful to document exactly how the ""implicit"" no-flux boundary conditions are enforced and which fluxes are zeroed out. This would apply to the rigid lid and channel walls.; * Solving Poisson's equation on a vertically stretched grid with the Fourier analysis cyclic reduction (FACR) algorithm.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/327:728,undo,undocumented,728,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/327,1,['undo'],['undocumented']
Usability,"Today @qingli411 and I attempted to install `Oceananigans` on his laptop, but ran into a problem when the HDF5 compilation (through julia) stalled for something like 15 minutes. We were only able to proceed by completely removing the dependency of `Oceananigans` on HDF5 and NetCDF (after which we got the code to run!). I think we should consider moving heavy dependencies like HDF5 and NetCDF into separate packages (say, `OceananigansOutput.jl`) to make a simple barebones installation of `Oceananigans` quick, easy, and painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284:459,simpl,simple,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284,1,['simpl'],['simple']
Usability,"Trying to use `AnisotropicMinimumDissipation` with `buoyancy = nothing` threw an error because it tries to access `buoyancy.model`, which doesn't exist when `buoyancy = nothing`. This PR fixes that bug and adds a few tests for time-stepping AMD with different buoyancy models, including `buoyancy=nothing`. The bug is fixed by adding a new default `Cb = nothing` (rather than `Cb = 0.0`), in which case the computation of the buoyancy modification term is elided entirely. This might speed up some models (but who knows by how much). It is _still_ the case that users who specify a non-default `Cb` without a buoyancy model receive error that could be hard to interpret. We could `validate_closure` for this. I feel it's not worth the effort right now though because the buoyancy modification term is not implemented correctly anyways, and it seems that even if implemented correctly it may not improve the fidelity of simulations with buoyancy. A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1619:1043,simpl,simplify,1043,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619,1,['simpl'],['simplify']
Usability,Typo in Contributors guide,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1425:21,guid,guide,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1425,2,['guid'],['guide']
Usability,"Unlike the `NonhydrostaticModel`, which has these lines:. https://github.com/CliMA/Oceananigans.jl/blob/1c96350d03e1ee066d5c9060089e043e15f711d6/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L120-L122. It's nice to validate the halos, because sometimes there are non-intuitive constraints (eg on #1994 we may have discovered that isopycnal closures need halos of size 2). cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2041:277,intuit,intuitive,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2041,1,['intuit'],['intuitive']
Usability,Updated the matplotlib scripts that I used to produce contourf3d and pcolormesh3d plots using the NetCDF output from Oceananigans. They're now in two separate files with a more general function call for re-usability. Example output: the 3D deep convection figure in the README. @SandreOuza we can use these to make 3D plots of free convection. But a NetCDF viewer like Panoply might be better for quick inspection.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/135:206,usab,usability,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/135,1,['usab'],['usability']
Usability,Usability concerns and possible improvements for `MultiArch`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:0,Usab,Usability,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,1,['Usab'],['Usability']
Usability,User-friendly field reductions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1412:0,User-friendly,User-friendly,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1412,1,['User-friendly'],['User-friendly']
Usability,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1156:666,simpl,simply,666,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156,1,['simpl'],['simply']
Usability,"We currently allow users to implement custom forcing functions with the signature:. ```julia; F(i, j, k, grid, time, U, C, parameters); ```. where `U` is a named tuple of velocity fields, `C` is a named tuple of tracer fields, and `parameters` is the object passed to `IncompressibleModel` via the `parameters` keyword argument. Boundary condition functions have the signature:. ```julia; condition(i, j, grid, time, iteration, U, C, parameters); ```. To stabilize the API, we may want to get rid of `parameters`, include `clock` rather than `time` or `iteration`, and add a named tuple container called `state` that holds `U`, `C`, and any other state variables that we want to add (now or in the future) as accessible to forcing functions or boundary condition functions. I'd propose that state be defined something like. ```julia; state = (velocities=U, tracers=C, diffusivities=K, pressures=pressures, tendencies=G); ```. If we form `state` within the time-stepping loop, it could also simplify the function signatures for time-stepping kernels. Related is #565.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682:990,simpl,simplify,990,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682,1,['simpl'],['simplify']
Usability,"We currently have a `Timeseries` diagnostic which accumulates the output of `some_function(model)` in a vector `data`. . It'd be nice to have a simple way to save a timeseries to file. The problem is that we don't want to duplicate data; eg we want to periodically append data to an array that was previously saved in a file. . Note that it is not possible to, for example, delete data within a `JLD2` file and replace it with something else:. https://github.com/JuliaIO/JLD2.jl/issues/38. @ali-ramadhan @suyashbire1 is this possible in NetCDF / `NCDatasets.jl`?. There are two other possibilities. One is to ""unspool"" the time series into a `group` within a `JLD2` file and write the data from each time stamp individually in the file. This allows new data to be appended to the group easily. I'm not sure how performant this would be, but perhaps its fine. The second is to simply delete the old file and replace it with a new one with the updated time series. This is the hack that I've been using so far. The downside is that we have to save each timeseries in their own file. Curious to hear if there are any other ideas for solving this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/502:144,simpl,simple,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/502,2,['simpl'],"['simple', 'simply']"
Usability,"We have the need for continuous (not discrete) boundary condition functions that depend on the field to which the boundary condition is applied. For example, in the `ocean_convection_and_wind_mixing.jl`, the prescribed salinity flux depends on the salinity adjacent to the boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/ocean_wind_mixing_and_convection.jl#L73. The linear drag boundary condition implemented in `eady_turbulence.jl` is similar:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/eady_turbulence.jl#L60. A slightly simpler interface would allow users to implement the salinity flux (for example) with. ```julia; Qˢ(x, y, t, S, evaporation) = - evaporation * S; ```. For this to work, a number of changes must be made in `BoundaryFunction`, `BoundaryCondition`, `FieldBoundaryConditions`, and the `TracerFields` constructor:. - `BoundaryFunction` must record whether or not the function is `field_dependent`, as well as the ""`side`"" of the boundary condition (left or right, so that the wall-normal index may be inferred), the `field_name`, and the `field_container` in which the field lives (`model.velocities` or `model.tracers`). - `BoundaryCondition` must provide the option `field_dependent=true`. - `FieldBoundaryConditions` must supply the `side` at which the boundary condition is applied (`Left()` for west, south, bottom and `Right()` for east, north, and top). - `TracerFields` must supply the tracer name. New methods for field-dependent `BoundaryFunction`s are also required. For `z`-boundaries, for example, we need. ```julia; @inline function (bc::BoundaryFunction{:z, X, Y, true})(j, k, grid, clock, state) where {X, Y}; k = wall_adjacent_index(bc.side, grid.Nz); container = getproperty(state, bc.field_container); field = getproperty(container, bc.field_name); ; return @inbounds call_boundary_function(bc.func, xnode(X, i, grid), ynode(Y, j, grid), clock.time, f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/897:636,simpl,simpler,636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897,1,['simpl'],['simpler']
Usability,"We may have discussed this in the past or proposed similar ideas but just thought I'd open a suggestion issue as I think it might make model construction simpler for future users. Right now, for example, creating a parameterized boundary function takes 5 steps; ```julia; B_params = (; Ly = Ly,; B½ = 1.96e-7, # Buoyancy flux at midchannel [m²/s³]; Lᶠ = 10kilometer # Characteristic length scale of the forcing [m]; ); B(x, y, p) = p.B½ * (tanh(2 * (y - p.Ly/2) / p.Lᶠ) + 1) # Surface buoyancy flux [m²/s³]; B_bf = BoundaryFunction{:z, Cell, Cell}(B, B_params); top_b_bc = FluxBoundaryCondition(B_bf); b_bcs = TracerBoundaryConditions(grid, top=top_b_bc); ```. I wonder if we can brush a lot of this under the hood so the user just has to type; ```julia; B_params = (; Ly = Ly,; B½ = 1.96e-7, # Buoyancy flux at midchannel [m²/s³]; Lᶠ = 10kilometer # Characteristic length scale of the forcing [m]; ); B(x, y, p) = p.B½ * (tanh(2 * (y - p.Ly/2) / p.Lᶠ) + 1) # Surface buoyancy flux [m²/s³]; b_bcs = TracerBoundaryConditions(grid, top=FluxBoundaryCondition(B)); ```; I guess it really only skips one step but with 3 arguments it can be inferred to be a parameterized boundary function and the location `{:z, Cell, Cell}` can be inferred from the fact that the BC is being applied at the `top` and it's for a tracer field. Other construction patterns can probably be streamlined too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/769:154,simpl,simpler,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/769,1,['simpl'],['simpler']
Usability,"We may want to consider modularizing our code a bit more; for example we could have a `Diagnostics` module, an `OutputWriters` module, etc, with folders that correspond to the module name, and with module functionality split into multiple files. . This may make the source code more navigable and also create some opportunities for a clearer API, since we can selectively export different functionality from `Oceananigans` than from `Oceananigans.Diagnostics` (for example). In other words, we could write the API so that `using Oceananigans` brings only bare-bones diagnostics functionality into scope for users, while `using Oceananigans.Diagnostics` brings a full-fledged suite of diagnostics functionality into scope if that is desired.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/456:334,clear,clearer,334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/456,1,['clear'],['clearer']
Usability,"We need a unified interface for specifying forcing functions. The first change needed is to assume that, by default, forcing functions are called with the signature. ```julia; forcing(x, y, z, t); ```. This can be achieved with modest changes to [`ModelForcing`](https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/src/Forcing/model_forcing.jl). Next, we can introduce an interface, something like `Forcing(func; kwargs...)`, where `func` is the forcing function. A few kwargs that we might want:. - `parameters`: when `parameters` is specified, `func` is transformed into either a `SimpleForcing` or `ParameterizedForcing` which takes parameters. - `discrete_form`: when `discrete_form=true`, the function signature is assumed to have the ""discrete form"" `func(i, j, k, grid, clock, state)`. - `field_dependent`: this only applies when `discrete_form=false`, and specifies that the function signature contains field. We'll also need a new type, perhaps `DiscreteForcing`, that ensures a forcing function is not transformed into a `SimpleForcing` inside the `ModelForcing` constructor. Finally, we can add keyword arguments to `ModelForcing` that apply the relevant transformations to every forcing function as a convenience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/896:618,Simpl,SimpleForcing,618,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/896,2,['Simpl'],['SimpleForcing']
Usability,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/136:370,clear,clear,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136,1,['clear'],['clear']
Usability,"When using `LagrangianParticles` in a `grid` with one direction having `Flat` topology, the code fails because the fractional index function hits the wrong line of code. Here is a MWE:. ```julia; using Oceananigans; using StructArrays; using Printf. grid = RectilinearGrid(CPU(), Float64,; size = (2, 2),; halo = (5, 5),; x = (0, 1),; y = (0, 1),; topology = (Periodic, Bounded, Flat)). #%%; struct SimpleParticle{X}; x :: X; y :: X; z :: X; end. x_particle = [0.5]; y_particle = [0.5]; z_particle = [0.5]. particles = StructArray{SimpleParticle}((x_particle, y_particle, z_particle)). lagrangian_particles = LagrangianParticles(particles). #%%; model = NonhydrostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which gives an error output of. ```julia; ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base .\tuple.jl:31; [2] fractional_z_index; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:110 [inlined]; [3] fractional_indices; @ c:\Use",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3632:399,Simpl,SimpleParticle,399,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632,2,['Simpl'],['SimpleParticle']
Usability,"With @writingindy, we are trying to learn how to specify a forcing function that depends on the derivatives of a tracer. We have looked at the convecting plantkon example, and tried modifying the forcing function as follows:. ```; growing_and_grazing(x, y, z, t, P, params) = (params.μ₀ * exp(z / params.λ) - params.m) * ∂x(P). ```. When we define the model with this new forcing function, this is not a problem. However, when we run the simulation, we get the following error, that it does not have the correct method,. How can we define the forcing function to depend on derivatives?. ```; julia> run!(simulation); [ Info: Initializing simulation...; Iteration: 0, time: 0 seconds, Δt: 2 minutes; [ Info: ... simulation initialization complete (5.216 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: MethodError: no method matching ∂x(::Float64); Closest candidates are:; ∂x(::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}) at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:46; ∂x(::Tuple, ::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:63; ∂x(::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:90; Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] growi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2586:36,learn,learn,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586,1,['learn'],['learn']
Usability,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3492:450,simpl,simplify,450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492,1,['simpl'],['simplify']
Usability,"Would be nice to have a nice and user-friendly API for setting boundary conditions. What boundary conditions should we be supporting? What should this API look like? Just starting a discussion around this that I've had with @SandreOuza and @glwagner. @glwagner made the point that the user should just have to specify whether they'd like Dirchlet, Neumann, or Robin boundary conditions. Periodic should be another option. We don't have to support all combinations. But in finite volume boundary conditions are converted into conditions on the fluxes. Right now we have something like this; ```julia; model.boundary_conditions = BoundaryConditions(x=:periodic, y=:periodic, top=:free_slip, bottom=:free_slip); ```; and all the ugliness is swept under the rug. This may involve refactoring some of the difference and interpolation operators as they might have been implicitly assuming that free-slip is being imposed. Will have to confirm with @jm-c. PS: Assigning multiple people as I don't have much experience around this (just to get your attention) Would be good to talk and figure out what kind of API works for all of us. Pinging: @SandreOuza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/86:33,user-friendly,user-friendly,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/86,1,['user-friendly'],['user-friendly']
Usability,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:126,simpl,simple,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['simpl'],['simple']
Usability,"[This `if`-statement](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/time_steppers.jl#L140) is not necessary, because the architecture can be known from the array types of the `CellField`s. Specifically, [this line](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/spectral_solvers.jl#L389) can be changed to. ```; function solve_poisson_3d_ppn_planned!(ssp::SpectralSolverParameters, g::RegularCartesianGrid, f::CellField{T}, ϕ::CellField{T}) where T<:CuArray. ... end; ```. I think it would actually be preferable to dispatch on the type of the arrays in `RegularCartesianGrid`. However, it does not appear that the arrays representing the coordinates of the grid are parameterized in [the definition of `RegularCartesianGrid`](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/grids.jl#L12). Why is that? . If the array type of the problem is part of `RegularCartesianGrid`, then dispatch can be used in place of `if`-statements all over the code, especially in `fields.jl`. Finally, the term 'spectral solvers' is misleading here. The solver does not have spectral accuracy; it simply uses the FFT, which *happens* to be used to solve different problems that have a 'spectral' character.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/45:1230,simpl,simply,1230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/45,1,['simpl'],['simply']
Usability,"`FieldBoundaryConditions` has two constructors: one for ""prognostic"" fields and one for ""auxiliary"" fields:. 1. `FieldBoundaryCondition(; kwargs...)` for prognostic fields;; 2. `FieldBoundaryCondition(grid, location; kwargs...)` for auxiliary fields.; ; The distinction is that boundary conditions on _prognostic_ fields are ""regularized"" within a model constructor, and can be complex (can depend nonlinearly on other fields). Boundary conditions on auxiliary fields must be simpler and are not regularized, which is why `grid` and `location` are required for auxiliary boundary conditions. It's easy for a user to mistakenly apply prognostic boundary conditions to an auxiliary field by using the wrong constructor. To help users fix this issue, we should throw a nice error when `fill_side_halo!` (where `side = (east, west, north, south, top, bottom))` is called with the ""specification"" type `DefaultPrognosticFieldBoundaryCondition` rather than a ""real"" (regularized or simple) `BoundaryCondition`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1968:476,simpl,simpler,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968,2,['simpl'],"['simple', 'simpler']"
Usability,"`GridFittedImmersedBoundary` uses a masking technique to immerse a grid-fitted boundary into some primary grid. For this purpose it elides diffusive fluxes across immersed interfaces (and soon will elide advective fluxes via #1719). This permits simulations that conserve tracers and momentum. However, users typically want to enforce boundary conditions across immersed boundaries. The simplest boundary condition to support is `FluxBoundaryCondition`. But there are a number of complications. Our current boundary condition API really bakes in the assumption of directionally-aligned boundaries, since fluxes are defined in the x, y, z direction, according to the boundary in question. This only makes sense for boundaries that are aligned with x, y, z, respectively. For boundaries that can point in any direction, it probably makes more sense to define fluxes _normal_ to the boundary. But then if we want to have a consistent API for specifying boundary conditions for both immersed boundaries and grid boundaries, we need to change the current convention for specifying grid boundary conditions. Fluxes would no longer point in the positive direction but _inwards_ or _outwards_ (in the former case, this means that negative tracer fluxes at the top boundary would lead to a decrease in tracer, eg cooling in the case of temperature). Not hard to implement, but certainly a _major_ breaking change. Another question is where we should _store_ the boundary conditions. Right now boundary conditions are stored in `Field.boundary_conditions for each field`. If we continue with this approach we need to generalize / redesign `FieldBoundaryConditions`. It might make sense to flatten the structure and have boundary conditions for `west, east, south, north, bottom, top[, immersed_boundary_label]`. This has the _potential_ to permit us to specify different boundary conditions on different ""parts"" of the immersed boundary, if we come up with an abstraction for partitioning an immersed boundary. ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720:387,simpl,simplest,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720,1,['simpl'],['simplest']
Usability,"`IsotropicDiffusivity` currently uses a viscosity and thermal diffusivity appropriate for water at 20 degrees Celsius and 35 psu:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L11-L28. When I put this in I originally thought it was positive because it provided a reference. It's also cute because its ""oceanic"". But as time has gone on I now fear its actually surprising and also not very useful, since it's not actually a common to use Oceananigans for direct numerical simulations of miniscule boxes with molecular transport coefficients. Instead, `IsotropicDiffusivity` is useful for 1) idealized problems, education, examples and 2) as a simple turbulence closure when setting up a simulation / testing ideas, possibly prior to implementing a more complicated closure. This ""ocean-realistic"" default is inconvenient for either case. So, I propose changing the default for both the viscosity and diffusivity to 0. cc @tomchor @xiaozhour",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1278:767,simpl,simple,767,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1278,1,['simpl'],['simple']
Usability,"`KernelComputedField` contains a property called `field_dependencies`, which is supposed to be some kind of iterable whose members get `compute!` called on them:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L76-L80. and then are later splatted into the function signature of the `kernel`:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L92. But since `compute!` can be called on non-fields harmlessly, its possible to put any objects at all in `field_dependencies`. The name doesn't help clear things up, since the meaning of ""field dependencies"" is ambiguous (do we mean ""dependencies of the KernelComputed _field_"", and therefore any objects at all, or ""specifically objects that are _fields_ on which the KernelComputedField depends""?). Perhaps even worse is the fact that it makes sense to put `AbstractOperations` in `field_dependencies`, because its possible for `AbstractOperations` to themselves depend on fields, thus warranting the `compute!(abstract_operation)`. A better name than `field_dependencies` is probably `computed_dependencies`. At least this makes clear what's happening under the hood. We should also throw an error if `computed_dependencies` is not iterable (failure will occur later on anyways). A more drastic change is to get rid of `parameters`, which I would be ok with too. However, I think it is potentially a nice feature that some users will appreciate and use to make their scripts and code a little cleaner and more interpretable. See also the discussion on https://github.com/tomchor/Oceanostics.jl/issues/1. cc @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1369:644,clear,clear,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369,2,['clear'],['clear']
Usability,"`NetCDFOutputWriter` and `JLD2OutputWriter` currently have different options. ```; NetCDFOutputWriter(model, outputs; filepath, schedule; array_type = Array{Float32},; field_slicer = FieldSlicer(),; global_attributes = Dict(),; output_attributes = Dict(),; dimensions = Dict(),; mode = nothing,; compression = 0,; verbose = false); ```. ```; JLD2OutputWriter(model, outputs; prefix, schedule,; dir = ""."",; field_slicer = FieldSlicer(),; array_type = Array{Float32},; max_filesize = Inf,; force = false,; init = noinit,; including = [:grid, :coriolis, :buoyancy, :closure],; verbose = false,; part = 1,; jld2_kw = Dict{Symbol, Any}()); ```. Some arguments are unique to each writer, but I think it would make things easier and more usable if we unified some of the arguments that really do the same thing. Specifically `filepath` could replace `dir` and `prefix`, and `mode` could replace`force`. I understand that the NetCDF and JLD2 libraries work differently when writing to disk (probably that's where the difference come from) but maybe we can do some translation behind the scenes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2217:731,usab,usable,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2217,1,['usab'],['usable']
Usability,"`Oceananigans.TurbulenceClosures` is a bit messy right now. One big issue is that we have two implementations of `AnisotropicMinimumDissipation`. I think we should commit to `VerstappenAnisotropicMinimumDissipation`, and possibly change its name to just `AnisotropicMinimumDissipation`. We should also probably only support one version of `Smagorinsky`. We have an implementation of the Smagorinsky model that is _apparently_ used by the UK Met Office's Large Eddy Model (LEM), aka ""BLASIUS"" (`blasius_smagorinsky.jl`). But we never use this model and its untested. It's no small piece of work to really test all that code. Maybe we should delete it and just keep the much more common and popular `smagorinsky_lilly.jl`? We can also delete the alias `ConstantSmagorinsky`. Some functions should probably be shuffled around: all of the code in `closure_operators.jl` should be moved to `viscous_dissipation_operators.jl` and `diffusion_operators`. Also to be consistent we should rename `viscous_dissipation_operators.jl` to `viscosity_operators.jl` (or at the least, `viscous_friction_operators.jl`. The functions in `closure_operators.jl` also need to be converted to finite-volume form. I think the implementation of those functions can also be simplified to accept an isotropic viscosity rather than the entire `diffusivities` object. We should also probably wrap all of the closures in their own submodules? Or maybe not... The implementation for tupled closures is also split into the top-level file and `closure_tuples.jl`. We should put the whole thing in `closure_tuples.jl`. What else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1002:1247,simpl,simplified,1247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1002,1,['simpl'],['simplified']
Usability,"``. Broadcasting also works with `AbstractOperations`:. ```julia; julia> d = Field(Face, Center, Center, CPU(), grid); Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (4, 4, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux). julia> dx_c = ∂x(c); Derivative at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ∂xᶠᶜᵃ at (Face, Center, Center) via identity;    └── Field located at (Center, Center, Center). julia> d .= 2 .* dx_c. julia> interior(d); 2×2×1 view(OffsetArray(::Array{Float64,3}, 0:3, 0:3, 0:2), 1:2, 1:2, 1:1) with eltype Float64:; [:, :, 1] =; 4.36713 3.46522; -1.988 4.13932; ```. Under the hood we launch kernels, so broadcasting is multithreaded and works on the GPU as well as the CPU. This is just the beginning I think. This PR only implements in-place broadcasting, but out-of-place (allocating) broadcasting would be useful for analysis of data via `AbstractField`. For this I think we need to define `Base.copy` in addition to `copyto!` (but this is simple since we already have `similar`...) ~~We also need to write a lot more code to make broadcasting robust: for example, we should check that broadcasted objects have the same location. We might also be able to implement interpolation correctly. This PR shows that all of this is possible.~~. This PR implements interpolated broadcasting by transforming `Base.Broadcast.Broadcasted` to `AbstractOperation`. Note: it also defines some new helper functions for `BinaryOperation` that should help with type inference and GPU compilation. This was necessary to get some of the broadcasting tests work (since broadcasting also uses `AbstractOperation`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1596:1780,simpl,simple,1780,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1596,1,['simpl'],['simple']
Usability,"ally we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a draft PR for now because there are some things that need doing:. - [x] Generalize the filter for stretched grids. For now it assumes a regular grid for simplicity, but it's trivial to generalize.; - [x] Optimize the calculation of the coefficient. At the moment I'm creating four extra fields in order to calculate the Smag coefficient: `LM`, `MM` are 3D fields; and `LM_avg` and `MM_avg` are 1D or 2D. What I'm doing is to first calculate $L_{ij} M_{ij}$ and $M_{ij} M_{ij}$ pointwise, and then `LM_avg` and `MM_avg` receive their averages. We should be able to calculate everything without needing `LM`, `MM` are 3D fields, I just couldn't figure out how yet :); - [ ] Write docs; - [x] Write tests; - [x] Validate that model is working as intended. CC @glwagner @simone-silvestri @xkykai @whitleyv . Feel free to add more things to the to-do list that I may have forgotten.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642:2152,simpl,simplicity,2152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642,1,['simpl'],['simplicity']
Usability,"ans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:306; [2] SplitExplicitFreeSurface(FT::DataType; gravitational_acceleration::Float64, kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, NamedTuple{(:grid, :cfl), Tuple{RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:74; [3] top-level scope; @ REPL[10]:1; ```. This seems counter-intuitive to me because we _had_ actually prescribed a `cfl`. We figured that the error was because `substeps` has a default value of 200 so when we also prescribe a `cfl` kwarg then . https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238:2154,intuit,intuitive,2154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238,1,['intuit'],['intuitive']
Usability,"capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution. Criticism welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1301:1983,simpl,simplest,1983,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301,1,['simpl'],['simplest']
Usability,"ch would decouple the grid topology from the boundary conditions (although some boundary conditions will be determined by the grid topology). I think it's a good idea that will pay off in code clarity and ease of use.; 1. Functions such as [`fill_halo_regions!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/BoundaryConditions/fill_halo_regions.jl#L22) will simplify as we no longer need to pass in both a field and boundary conditions, just the field itself.; 2. No need to prepare boundary condition tuples to pass to functions, for example, in [`complete_pressure_correction_step!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/TimeSteppers/TimeSteppers.jl#L177-L183).; 3. Oceananigans has have a pretty deep hierarchy of boundary conditions: BC -> Coordinate BCs -> field BCs -> Solution BCs -> Model BCs. Moving BCs to fields will eliminate the need for solution BCs and model BCs, which will create a simpler hierarchy of just BC -> coordinate BCs -> field BCs. This will make it easier to developers and users to access and interact with boundary conditions, especially as [`ModelBoundaryConditions`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl#L155-L177) can only grow in complexity.; 4. Storing fields in one struct and boundary conditions in another struct feels antithetical to orthogonal design. Another reason to consider having fields carry their boundary conditions around is to avoid having to build more boundary condition machinery, i.e. more [solution_and_model_boundary_conditions.jl](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl) when new fields are added or new models are added (e.g. #605). User API may have to change as well, although I don't think we should get rid of the current `boundary_cond",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606:1336,simpl,simpler,1336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606,1,['simpl'],['simpler']
Usability,"cktrace:; [1] advect_particle; @ C:\Users\hildi\.julia\packages\Oceananigans\kBe5X\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:81 [inlined]. ...; ```. The offending line is https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L81 . which fails because ; https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L79; returns `j = nothing` when `y` is `Flat`. However, I think that in general `advect_particle` is not written with Flat topologies in mind. For example, there are no boundary conditions implemented for the Flat topology. . The ability to do 2D (and 1D) Lagrangian particles would be quite useful. Although, it's not obvious what it means to advect a particle in the Flat direction. Skipping that direction entirely or simply accumulating the displacement in that direction (as I do below) could both be valid in some contexts. (For my original use case I don't care what happens in `y`.). Finally, for this particular simple example, propagating `j = nothing` through `unsafe_trunc` and defining some boundary conditions was sufficient to make the example run. ```; using Oceananigans. Base.unsafe_trunc(::T, ::Nothing) where {T} = nothing; Oceananigans.Models.LagrangianParticleTracking.enforce_boundary_conditions(::Flat, x, xᴸ, xᴿ, Cʳ) = x. NX, NZ = 16, 16; grid = RectilinearGrid(size=(NX,NZ), x=(0,1), z=(0,1), topology=(Periodic, Flat, Bounded)); # initialise some particles at the cell centres; x₀ = reshape(xnodes(grid, Center()) * ones(NZ)', NX * NZ); y₀ = zeros(NX * NZ); z₀ = reshape(ones(NX) * znodes(grid, Center())', NX * NZ); model = NonhydrostaticModel(; grid, particles=LagrangianParticles(x=x₀, y=y₀, z=z₀)); simulation = Simulation(model; Δt=1, stop_iteration=5); run!(simulation); ```; I'm not sure whether propagating `j = nothing` f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3545:2318,simpl,simply,2318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3545,1,['simpl'],['simply']
Usability,"cs. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to test because the feature does not exist yet (such as accurate reduced precision algorithm or nonlinear free surface). Thus we should consider this PR carefully.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:4115,clear,clear,4115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['clear'],['clear']
Usability,"d in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk about how these parameterizations might be implemented in Oceananigans... ## Constant roughness case. For an isotropic grid, _constant roughness length_ case --- a lot of simplification! --- we have to write something like. ```julia; using Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², v)); @inline u_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.u[i, j, k] * speedᶠᶜᶜ(i, j, k, grid, f.u, f.v, f.w); @inline v_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.v[i, j, k] * speedᶜᶠᶜ(i, j, k, grid, f.u, f.v, f.w); @inline w_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.w[i, j, k] * speedᶜᶜᶠ(i, j, k, grid, f.u, f.v, f.w). ϰ = 0.4 # ""Von Karman"" constant; ℓ =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:2605,simpl,simplification,2605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['simpl'],['simplification']
Usability,"d to change the current convention for specifying grid boundary conditions. Fluxes would no longer point in the positive direction but _inwards_ or _outwards_ (in the former case, this means that negative tracer fluxes at the top boundary would lead to a decrease in tracer, eg cooling in the case of temperature). Not hard to implement, but certainly a _major_ breaking change. Another question is where we should _store_ the boundary conditions. Right now boundary conditions are stored in `Field.boundary_conditions for each field`. If we continue with this approach we need to generalize / redesign `FieldBoundaryConditions`. It might make sense to flatten the structure and have boundary conditions for `west, east, south, north, bottom, top[, immersed_boundary_label]`. This has the _potential_ to permit us to specify different boundary conditions on different ""parts"" of the immersed boundary, if we come up with an abstraction for partitioning an immersed boundary. With the two changes above we might have an API that looks something like. ```julia; c_bcs = TracerBoundaryConditions(grid, top = NormalFluxBoundaryCondition(args...),; boundary_1 = NormalFluxBoundaryCondition(args...), boundary_2 = NormalFluxBoundaryCondition(more_args...)); ```. We also may want to change how boundary conditions are implemented. Currently we launch a bunch of 2D kernels to enforce boundary conditions. But enforcing boundary conditions across immersed boundaries either requires a 3D kernel or a 1D kernel that traverses every fluid-solid interface (probably requiring some tedious bookkeeping to generate the iteration). From the software perspective, it's probably simpler to move the enforcement of flux boundary condition inside the 3D interior tendency kernel and evaluate boundary conditions at the same time that interior tendency contributions are evaluated (in other words, replace diffusive fluxes with the specified boundary normal flux when appropriate). cc @whitleyv this affects your work.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720:2690,simpl,simpler,2690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720,1,['simpl'],['simpler']
Usability,"e microbes in an idealized setting. The purposes of this example are to show users how to:; 1. use Lagrangian particle tracking.; 2. define their own custom particle types.; 3. implement interacting particle pairs using KD trees.; 4. write fields and particles to NetCDF.; 5. easily read, analyze, and plot data from NetCDF using GeoData.jl. This example has aided me in figuring out which abstractions are needed for particle tracking in #1091 and are helping me figure out which plotting recipes would be good to implement as part of https://github.com/rafaqz/GeoData.jl/pull/106. This PR in a work-in-progress and depends on #1091. I still need to make it Literate. The example also produces a neat animation of particles being advected (too big to include as a gif) and I'm hoping to expand the data analysis a bit. ![image](https://user-images.githubusercontent.com/20099589/101072675-614b5880-356c-11eb-8537-44e21fa3e8ff.png). ![species_count](https://user-images.githubusercontent.com/20099589/101072466-14678200-356c-11eb-9c36-8c0eda8c3c36.png). # Plotting with GeoData.jl. I think reading data with JLD2 and plotting it can be cumbersome (and makes the examples more complicated than they should be in my opinion). I think once GeoData.jl is a bit more mature I think we should encourage users to use it as it simplifies data analysis and plotting greatly. For example, plotting w and b looks something like (could still be improved of course, contourf might be better). ```julia; anim = @animate for n in 1:Nt; @info ""Plotting idealized diurnal cycle frame $n/$Nt..."". w_plot = plot(w[Ti=n, xC=32], color=:balance, clims=(-0.02, 0.02), aspect_ratio=:auto,; title=""Idealized diurnal cycle: $(prettytime(times[n]))""). b_plot = plot(b[Ti=n, xC=32], color=:thermal, clims=(-5e-4, 4e-4), aspect_ratio=:auto, title=""""). plot(w_plot, b_plot, layout=(2, 1), size=(1600, 900)); end; ```. ![image](https://user-images.githubusercontent.com/20099589/101071345-79ba7380-356a-11eb-9670-463298f7de47.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244:1678,simpl,simplifies,1678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244,1,['simpl'],['simplifies']
Usability,"e) + ∂yᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, v_prime) + ∂zᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, w_prime) \; + ∂xᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, u_prime) + ∂yᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, v_prime) + ∂zᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, w_prime) \; + ∂xᶜᶜᶜ(i, j, k, grid, W)*∂zᶜᶜᶜ(i, j, k, grid, u_prime) + ∂yᶜᶜᶜ(i, j, k, grid, W)*∂zᶜᶜᶜ(i, j, k, grid, v_prime) + ∂zᶜᶜᶜ(i, j, k, grid, W)*∂zᶜᶜᶜ(i, j, k, grid, w_prime)); end . function solve_for_pressure_rapid!(pressure, solver::DistributedFFTBasedPoissonSolver, Δt, U★); rhs = parent(first(solver.storage)); arch = architecture(solver); grid = solver.local_grid. launch!(arch, grid, :xyz, calculate_permuted_pressure_source_term_fft_based_solver_rapid!,; rhs, grid, Δt, U★, solver.input_permutation,). # Solve pressure Poisson equation for pressure, given rhs; solve!(pressure, solver). return pressure; end; ```. I tried to run it on CPU (Oceananigans v0.84.1 & Julia v1.8.4) like (A simple case of Langmuir turbulence case in a shallow water):. ```julia; using Oceananigans; using Printf; using Oceananigans.Units. # Grid; const H = 30; grid = RectilinearGrid(GPU();; size = (100, 100, 48),; halo = (3, 3, 3),; x = (0, 2π*H),; y = (0, 2π*H),; z = (-H, 0)); # Buoyancy; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=2e-4, haline_contraction=8e-4)). # Surface boundary conditions; u₁₀ = 10 ; cᴰ = 1.25e-3 ; ρₐ = 1.225 ; ρₒ = 1026.0 ; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) . # Bottom boundary conditions; z₀ = 0.01; κ = 0.4 ; z₁ = grid.Δzᵃᵃᶠ/2 ; cᴰ = (κ / log(z₁ / z₀))^2 . @inline drag_u(x, y, t, u, v, p) = - p.cᴰ * √(u^2 + v^2) * u; @inline drag_v(x, y, t, u, v, p) = - p.cᴰ * √(u^2 + v^2) * v. drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰ)); drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰ)). u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom = drag_bc_u); v_bcs ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3459:5593,simpl,simple,5593,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459,1,['simpl'],['simple']
Usability,"eady does so nothing changes there.; 2. Everything needed for distributed parallelism will live in the `Oceananigans.Distributed` submodule.; 3. Support for x, y, and z decompositions. In practice, choice of pressure solver may limit which decomposition we can use but they're all supported right now.; 4. Each rank will time step it's own submodel communicating with its neighbors as needed, i.e. in `fill_halo_regions!`. There is no ""master rank"".; 5. Halo communication is implemented by injecting `HaloCommunication` boundary conditions wherever a submodel shares a halo with another rank. This is then dispatched on so no need to modify existing code.; 6. With PR #589 we will be able to easily slide in a `DistributedPressureSolver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590:1404,clear,clear,1404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590,1,['clear'],['clear']
Usability,"ed an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to find a way of lazily loading data from disk with DimensionalData.jl so we can analyze large datasets without loading the complete dataset into memory, but this could come later.; 5. One of the big features of xarray is that together with Dask you can analyze huge datasets that do not fit in memory using many cores quite quickly. This is probably not possible with Julia right now (maybe with Dagger.jl in the future), but it seems that this might be an edge case. Most users will probably be able to get by with lazily loading data from disk?. # Example?. I was thinking what would be a good example would be to showcase this feature. The example could show how to go from math -> setup -> simulation -> analysis -> results. So it would have to be pretty simple but with enough complexity to showcase the power of the framework. So probably no closing of TKE budgets...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493:2759,simpl,simple,2759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493,1,['simpl'],['simple']
Usability,"erating function and so a grid that becomes ever more refined toward the surface was used instead. I think a grid with constant near-surface spacing and bottom-intensified stretching will be useful for boundary layer turbulence experiments, so I thought it was worthwhile to spend a bit more time to come up with something. I thought the hyperbolic generating function was also useful, so I added it to the docstring for `VerticallyStretchedRectilinearGrid` as an example. This PR also fixes a typo in that docstring. Some notes:. I developed a two-parameter stretching function:. ```julia; ## Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. ## Bottom-intensified stretching function ; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). ## Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1); ```. with `refinement` and `stretching` parameters`. Finding a suitable grid requires playing with both these parameters: perhaps counter-intuitively, when the `refinement` is weaker, the `stretching` has to be stronger to obtain a grid that's nearly constantly spaced near the surface. I think a slightly more convenient parameterization would use a ""transition"" parameter (controlling the depth at which the grid transitions from constant spacing to stretched) rather than a stretching parameter (there would also be a small parameter involved to control ""how close"" the spacing would be to constant at the transition depth). However I couldn't figure out how to implement such a parameterization without solving a transcendental equation. The idea I had was to set the slope of `Σ` to a small number at a specified fraction of the domain height `hᵢ` by solving. ```julia; Σ′ = stretching * exp(-stretching * hᵢ) / (1 - exp(-stretching)) = ϵ; ```. for `stretching`. In the above, `ϵ` is a small parameter controlling the smallness of `Σ′` at the normalized height. Both `ϵ` and `hᵢ` are parameters. Aside from being not quite right, there's something a little off abo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1810:1350,intuit,intuitively,1350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1810,1,['intuit'],['intuitively']
Usability,"esults like. ```julia; julia> *((Center, Center, Center), u, u); BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. and. ```julia; julia> tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2);. julia> tke.arg.args[1]; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └── 2; ```. An added benefit is that the `BinaryOperation` object is simpler. This could help compilation as well... Of course, users do want to be able to specify the location of `BinaryOperations` for output. For this we change how `@at` works: now we wrap the entire user-prescribed expression in an interpolation operator that interpolates the result to the user-specified location. If the location of the underlying expression is already at the user-specified location, this is just an identity. But when the underlying operation is a ""stubborn"" `BinaryOperator`, we interpolate:. ```julia; julia> uu = @at (Center, Center, Center) u * u; UnaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; identity at (Center, Center, Center) via ℑxᶜᵃᵃ;    └── * at (Face, Center, Center);       ├── Field located at (Face, Center, Center);       └── Field located at (Face, Center, Center). julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599:4026,simpl,simpler,4026,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599,1,['simpl'],['simpler']
Usability,"existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and put it elsewhere (eg as a global option `overwrite_existing_output` for all output writers in `run!`). This makes a stronger connection between `pickup` and `overwrite_existing`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:2549,usab,usability,2549,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,1,['usab'],['usability']
Usability,"f experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); 22. Physics and numerical implementation; 23. References; 24. Appendix. It will take a few PRs to resolve this issue. It'd be great to incorporate feedback on the plan too before making any moves.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852:1947,guid,guide,1947,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852,2,"['feedback', 'guid']","['feedback', 'guide']"
Usability,"han having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniformly useful to everyone. So by wading into this area, we risk doing a crap job and interfering / hindering at least some people, rather than helping. Anyways, after writing this out I'm a little wary of introducing anything now (maybe actually showing how to integrate workflow management tools into Oceananigans scripts is a better solution). But I thought it would be useful to open this up for discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543:2313,simpl,simply,2313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543,1,['simpl'],['simply']
Usability,"hich accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:3050,simpl,simplifies,3050,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['simpl'],['simplifies']
Usability,"hm described by Makhoul (1982) as CUFFT does not provide cosine transforms for the GPU and does not support FFTs along non-batched dimensions (see https://github.com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:1379,simpl,simplify,1379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['simpl'],['simplify']
Usability,"https://github.com/CliMA/Oceananigans.jl/blob/5b8813da360921c66c2f3ee77021db91bedda1f7/src/Grids/Grids.jl#L81. Shouldn't the size of the `x`-direction, for example, be `Nx + 2 * Hx`? Perhaps we should simply delete this function if it isn't being used. It doesn't exactly make sense since the size of a _field_ depends on its location, and the topology of the grid.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/883:201,simpl,simply,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/883,1,['simpl'],['simply']
Usability,"icle_advection.jl:81 [inlined]. ...; ```. The offending line is https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L81 . which fails because ; https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L79; returns `j = nothing` when `y` is `Flat`. However, I think that in general `advect_particle` is not written with Flat topologies in mind. For example, there are no boundary conditions implemented for the Flat topology. . The ability to do 2D (and 1D) Lagrangian particles would be quite useful. Although, it's not obvious what it means to advect a particle in the Flat direction. Skipping that direction entirely or simply accumulating the displacement in that direction (as I do below) could both be valid in some contexts. (For my original use case I don't care what happens in `y`.). Finally, for this particular simple example, propagating `j = nothing` through `unsafe_trunc` and defining some boundary conditions was sufficient to make the example run. ```; using Oceananigans. Base.unsafe_trunc(::T, ::Nothing) where {T} = nothing; Oceananigans.Models.LagrangianParticleTracking.enforce_boundary_conditions(::Flat, x, xᴸ, xᴿ, Cʳ) = x. NX, NZ = 16, 16; grid = RectilinearGrid(size=(NX,NZ), x=(0,1), z=(0,1), topology=(Periodic, Flat, Bounded)); # initialise some particles at the cell centres; x₀ = reshape(xnodes(grid, Center()) * ones(NZ)', NX * NZ); y₀ = zeros(NX * NZ); z₀ = reshape(ones(NX) * znodes(grid, Center())', NX * NZ); model = NonhydrostaticModel(; grid, particles=LagrangianParticles(x=x₀, y=y₀, z=z₀)); simulation = Simulation(model; Δt=1, stop_iteration=5); run!(simulation); ```; I'm not sure whether propagating `j = nothing` forward is a sensible or desirable thing to do, or if it even works in other cases, but I thought that I'd point out that it works here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3545:2518,simpl,simple,2518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3545,1,['simpl'],['simple']
Usability,"ions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}; ├── underlying_grid: 4×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 3×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Flat y; └── Flat z. julia> c = CenterField(ibg); 4×1×1 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 4×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 3×0×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×1×1 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, 1:1) with eltype Float64 with indices -2:7×1:1×1:1; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, 1.0); 4×1×1 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 4×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 3×0×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×1×1 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, 1:1) with eltype Float64 with indices -2:7×1:1×1:1; └── max=1.0, min=1.0, mean=1.0. julia> mask_immersed_field!(c). julia> ℑxᶠᵃᵃ(3, 1, 1, ibg, c) # Non boundary-aware x-interpolation operator; 0.5. julia> ℑxᶠᶜᶜ(3, 1, 1, ibg, c) # Boundary-aware x-interpolation operator; 1.0. ```. At the moment there is no clear use for the internals of the code as nothing really requires an interpolation across immersed boundary, except for along-isopycnal diffusion and GM, but I find it useful mostly for postprocessing, where interpolation to combine fields in `AbstractOperations` is extensively used. What do people think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3158:3450,clear,clear,3450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3158,1,['clear'],['clear']
Usability,"iters`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpoi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068:1586,simpl,simple,1586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068,1,['simpl'],['simple']
Usability,"l, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=NoFlux, top=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting di",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:2777,simpl,simpler,2777,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['simpl'],['simpler']
Usability,"larCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=2); ├── operand: BinaryOperation at (Cell, Cell, Cell); └── status: time=0.0. julia> dz_two_c = ComputedField(∂z(two_c)); ComputedField located at (Cell, Cell, Face) of Derivative at (Cell, Cell, Face); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (3, 3, 5); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=2); ├── operand: Derivative at (Cell, Cell, Face); └── status: time=0.0. julia> set!(c, (x, y, z) -> rand()); 1×1×2 view(OffsetArray(::Array{Float64,3}, 0:2, 0:2, 0:3), 1:1, 1:1, 1:2) with eltype Float64:; [:, :, 1] =; 0.8753467111937931. [:, :, 2] =; 0.649695162761919. julia> compute!(dz_two_c). julia> two_c.data[1, 1, :]; 4-element OffsetArray(::Array{Float64,1}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 1.7506934223875863; 1.299390325523838; 0.0. julia> interior(dz_two_c); 1×1×3 view(OffsetArray(::Array{Float64,3}, 0:2, 0:2, 0:4), 1:1, 1:1, 1:3) with eltype Float64:; [:, :, 1] =; 1.7506934223875863. [:, :, 2] =; -0.45130309686374837. [:, :, 3] =; -1.299390325523838; ```. The values of `dz_two_c` at the top and bottom boundary simply reflect the interior values of `two_c`. This is not what's expected: the vertical derivative of `2 * c` across boundaries actually depends on the boundary conditions imposed on `c`. This is a tricky issue to resolve. I'm not sure we can determine correct halo region values for computed fields in general. However, we can allow `ComputedField`s to have boundary conditions, like `Field`s currently do. In this case, users may specify boundary conditions on `ComputedField`s and we can reuse existing defaults if boundary conditions are not specified (or we can use `boundary_conditions = nothing` as a default). At the very least, this will ensure that `ComputedField`s are correct across periodic boundaries and at best users who need correct boundary conditions imposed on `ComputedField`s can provide them.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1130:2489,simpl,simply,2489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1130,1,['simpl'],['simply']
Usability,"le{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w),Tuple{SimpleForcing{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,var""#45#48"",Nothing},typeof(Oceananigans.Forcing.zeroforcing),SimpleForcing{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Face,var""#46#49"",Nothing}}},Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3}}},Nothing},Nothing}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Models/show_models.jl:5; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/700:9071,Simpl,SimpleForcing,9071,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/700,2,['Simpl'],['SimpleForcing']
Usability,"m the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want to rerun the simulation from a checkpoint, 2 potential options would be available:. 1. The model runs from the latest checkpoint, and continues writing into the most recent output file once it catches up to the latest unsaved iteration. Note that since the model is running from the checkpoint the saved iterations which the model is running at could be in earlier parts than the most recent output. But the simulation should know that and only starts writing into the latest part once it catches up to the latest saved iteration.; 2. I specify a part number that is larger than all the previous output files, and the simulation picks up from the checkpoint and writes into the new part number. This could mean that there are repetitive iterations saved when examining all output files (new and old). 1) is potentially the most important and common use case, but 2) might not be an unreasonable usage as well. However in the current implementation neither can be achieved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399:2605,user experience,user experience,2605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399,1,['user experience'],['user experience']
Usability,"model file; end. sim.output_writers[:fields] = JLD2OutputWriter(; model,; (; ω, speed);; # Save to `/data/simulations` based on parameters:; filename=datadir(""simulations"", savename(d, ""jld2"")),; schedule=TimeInterval(Δt * 3),; init=init_jld2!; ); ```. However, I get an error from `tag!`:; ```julia; ┌ Warning: Initialization of /Users/mcranmer/Documents/oceananigans_interpret/data/simulations/initial_condition=random_seed=0_stop_time=10.0_timestepper=RungeKutta3_Δt=0.2_Δx=0.00781.jld2 failed because MethodError: MethodError: no method matching tag!(::JLD2.JLDFile{JLD2.MmapIO}); │ Closest candidates are:; │ tag!(!Matched::AbstractDict{K, T}; gitpath, force, source, storepatch) where {K, T} at ~/.julia/packages/DrWatson/I8SbQ/src/saving_tools.jl:200; ```. Do you have any recommendations for using DrWatson.jl with Oceananigans.JL? Maybe there's something basic I'm missing here about saving data files. Thanks!; Miles. <details><summary>Full script</summary>. ```julia; using DrWatson; @quickactivate ""Learning Oceananigans.jl"". using Oceananigans; using Statistics; using Random. function makesim(d::Dict); @unpack size,; extent,; topology,; architecture,; timestepper,; advection,; closure,; Δt,; stop_time,; Δx,; initial_condition,; seed = d. actual_size = (size..., 1). grid = RectilinearGrid(; size, extent, topology); model = NonhydrostaticModel(; grid, timestepper, advection, closure). # Initial conditions:; rng = MersenneTwister(seed); u, v = if initial_condition == ""random""; u = rand(rng, actual_size...); v = rand(rng, actual_size...); u .-= mean(u); v .-= mean(v); u, v; else; error(""Unknown initial condition: $initial_condition""); end. set!(model; u=u, v=v). sim = Simulation(model; Δt, stop_time); sim.callbacks[:progress] = Callback(; s -> @info ""Iteration $(iteration(s)) at time $(time(s))"", IterationInterval(100); ). ω, speed = begin; u, v, _ = model.velocities; ω = ∂x(v) - ∂y(u); speed = sqrt(u^2 + v^2); ω, speed; end. function init_jld2!(file, model); tag!(file) # T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2829:1652,Learn,Learning,1652,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2829,1,['Learn'],['Learning']
Usability,"monstrate this bug in [this `horizontal_diffusion.jl` script](https://github.com/hdrake/HorizontalConvection/blob/bf2c917e43a6198a55061a46b2097b6b4a9dda3b/horizontal_diffusion.jl), in which we turn off advection in the `horizontal_convection.jl` example and numerically integrate the solution to equilibrium. We compare timeseries of the volume-integrated buoyancy dissipation rates calculated online versus those calculated offline (as in the `horizontal_convection.jl` example). The results show that the online calculation correctly asymptotes to the numerical solution of the equilibrium boundary value problem while the offline calculation is erroneous and effectively yields a Nusselt number that is more than 6 times too high. ![equilibration_ratio](https://github.com/CliMA/Oceananigans.jl/assets/12971166/1f79e7eb-b361-4ea0-aa76-a81d6049c25a). The bug is also evident by comparing snapshots of the two buoyancy dissipation rate fields. The dissipation rates computed offline clearly do not satisfy the no-flux boundary conditions on the boundaries. <img width=""587"" alt=""Screenshot 2023-08-22 at 12 38 27 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/eee4e10c-432b-413c-8670-aaf47c8b0d0a"">. This bug is present in the live `main` Oceananigans.jl branch (circa `v0.86.0`), as is evident from the movie of the buoyancy dissipation rate field in the [`horizontal_convection.jl` example documentation](https://clima.github.io/OceananigansDocumentation/v0.84.1/generated/horizontal_convection/#Load-saved-output,-process,-visualize) and verified locally. <img width=""519"" alt=""Screenshot 2023-08-22 at 1 13 30 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/c61b002c-5fd5-453d-8809-623e577e54f3"">. I am referring to this as a bug because it is contrary to the expected behavior of halos containing the necessary information for satisfying boundary conditions, as discussed in the horizontal convection documentation example:; https://github.com/CliMA/Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224:1686,clear,clearly,1686,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224,1,['clear'],['clearly']
Usability,"ng Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², v)); @inline u_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.u[i, j, k] * speedᶠᶜᶜ(i, j, k, grid, f.u, f.v, f.w); @inline v_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.v[i, j, k] * speedᶜᶠᶜ(i, j, k, grid, f.u, f.v, f.w); @inline w_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.w[i, j, k] * speedᶜᶜᶠ(i, j, k, grid, f.u, f.v, f.w). ϰ = 0.4 # ""Von Karman"" constant; ℓ = 1e-4 # simply an estimated roughness length; d = minimum_xspacing(grid) / 2 # assuming an isotropic grid, using half cell-width as ""distance to the wall""; cᴰ = (ϰ / log(d / ℓ))^2. u_drag_bc = FluxBoundaryCondition(u_drag, discrete_form=true, parameters=cᴰ); v_drag_bc = FluxBoundaryCondition(v_drag, discrete_form=true, parameters=cᴰ); w_drag_bc = FluxBoundaryCondition(w_drag, discrete_form=true, parameters=cᴰ); ```. Note, this only really makes sense on an isotropic grid and I think to strictly treat anisotropic grids we need to manually construct `ImmersedBoundaryCondition`. Even with the simplifications we've made, it's still a lot of code that has to be repeated every time somebody wants to implemented a drag law on an immersed boundary. So we could easily motivate implementing an abstraction `drag_boundary_conditions` that returns the bcs for `u, v, w`, eg:. ```julia; u_drag_bc, v_drag_bc, w_drag_bc = drag_boundary_conditions(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe om",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:3604,simpl,simply,3604,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['simpl'],['simply']
Usability,"north and south) and z (top and bottom),; # and periodic in x.; #; topology = (Bounded, Bounded, Bounded). grid = RegularCartesianGrid(size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz), topology=topology). # No-slip bottom, free-slip top and side walls through default boundary conditions; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), east = BoundaryCondition(Gradient,0.0)); vbcs = VVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0)); bbcs = TracerBoundaryConditions(grid, west = BoundaryCondition(Value,0.0)); nothing # hide. # ## Model instantiation and initial condition; #; # We use a constant viscosity and diffusivity.; # Set forcing; #fun_forcing(x, y, z, t) = (0.5*(1-erf(abs(sqrt((x-xc)^2+(y-yc)^2+(z-zc)^2)-R)))); fun_dist_to_source(x,y,z,t,a,y₀) = sqrt((x-Lx/2)^2+(y-y₀-a*t)^2+(z+Lz/2)^2); fun_forcing(x, y, z, t,p) = -0.5*(1-erf((fun_dist_to_source(x,y,z,t,p.a,p.y₀)-p.R)/p.δᴸ)). b_forcing = SimpleForcing(fun_forcing, parameters=(a=0.5,y₀=2,R=0.5,δᴸ=0.1)). #parameterized_forcing(x, y, z, t, p) = p.μ * exp(z/p.λ) * cos(p.ω*t); #v_forcing = SimpleForcing(parameterized_forcing, parameters=(μ=42, λ=0.1, ω=π)); forcing = ModelForcing(b=b_forcing). model = IncompressibleModel(; grid = grid,; architecture = CPU(),; boundary_conditions = (u=ubcs, v=vbcs, b=bbcs),; closure = ConstantIsotropicDiffusivity(ν=iRe, κ=iPe),; tracers = :b,; buoyancy = BuoyancyTracer(),; forcing = forcing; ). # Set initial condition; b₀(x, y, z) = 0.0#-0.5 * (1 - erf((y - yᴸ) / δᴸ)). set!(model, b=b₀); nothing # hide. ### Progress diagnostic function; using Oceananigans.Diagnostics, Printf. umax = FieldMaximum(abs, model.velocities.u); vmax = FieldMaximum(abs, model.velocities.v); wmax = FieldMaximum(abs, model.velocities.w). wall_clock = time_ns(). function print_progress(simulation); model = simulation.model. # Print a progress message; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/789:3240,Simpl,SimpleForcing,3240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789,1,['Simpl'],['SimpleForcing']
Usability,"ol, precision::Type, boundary_layer_parameterization::Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity{Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.HyperbolicTangentRiDependentTapering}); @ OceanScalingTests ~/src/OceanScalingTests.jl/src/near_global_simulation.jl:64; [10] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:54 [inlined]; [11] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:78 [inlined]; [12] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:53 [inlined]; [13] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:140 [inlined]; [14] top-level scope; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:32; [15] include; @ ./Base.jl:556 [inlined]; [16] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2664; [17] top-level scope; @ stdin:4; in expression starting at /home/vchuravy/src/OceanScalingTests.jl/src/OceanScalingTests.jl:1; in expression starting at stdin:; ```. Caused by `@eval`. Note that `@eval` uses the current module and not the module the user is calling this function from.; This means we are trying to modify the Oceananigans after it has already been closed. This is imcompatible with precompilation since we are unable to track and restore this modification. My intuition is that you probably just want a dictionary for these kind of globals, maybe even within the model? ; Instead of using global variables. . https://github.com/CliMA/Oceananigans.jl/blob/00f028bb37f13692e24921588aeb8a9150f6dd55/src/Grids/latitude_longitude_grid.jl#L554-L555. The use-case is shown in https://github.com/simone-silvestri/OceanScalingTests.jl/pull/8 where one wants to use `PrecompileTools` to cache important functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3555:7047,intuit,intuition,7047,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555,1,['intuit'],['intuition']
Usability,"only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:6565,simpl,simple,6565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['simpl'],['simple']
Usability,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:3160,simpl,simplified,3160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,3,"['clear', 'simpl']","['clear', 'simplified', 'simplify']"
Usability,"ostatic_prognostic_fields`](https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl#L92-L96) should return also the barotropic velocities when using a split-explicit free surface. ***(3)***. I would like to flatten out the design of the `SplitExplicitFreeSurface` by; - removing the [`SplitExplicitState`](https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L136-L161), and have the barotropic velocities and the mean fields part of the main `free_surface` type and all the remaining fields required for specific timesteppers in the [`timestepper`](https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L259-L260) which at the moment is very simple but can be redesigned to contain all time-stepping specific information; - removing [`SplitExplicitSettings`](https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L253-L256) (I don't know why there is a `settings_kwargs` there but it looks odd and it's probably a sign that this type is not well designed). This leads to a `SplitExplicitFreeSurface` which will look like; ```julia; struct SplitExplicitFreeSurface{H, U, M, FT, K , S, T} <: AbstractFreeSurface{H, FT}; η :: H; barotropic_velocities :: U # A namedtuple with U, V ; filtered_state :: M # A namedtuple with η, U, V averaged throughout the substepping; gravitational_acceleration :: FT; kernel_parameters :: K; substepping :: S # Either `FixedSubstepNumber` or `FixedTimeStepSize`; timestepper :: T # redesigned to contain all auxiliary field and settings necessary to the particular timestepping; end; ```; These changes will not affect the performance nor the functioni",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3873:2412,simpl,simple,2412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3873,1,['simpl'],['simple']
Usability,"ressure::Field{…}, solver::ConjugateGradientPoissonSolver{…}, Δt::Float64, Ũ::@NamedTuple{…}); @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/HPOLD/src/Models/NonhydrostaticModels/solve_for_pressure.jl:89; [16] calculate_pressure_correction!(model::NonhydrostaticModel{…}, Δt::Float64); @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/HPOLD/src/Models/NonhydrostaticModels/pressure_correction.jl:15; [17] set!(model::NonhydrostaticModel{…}; enforce_incompressibility::Bool, kwargs::@Kwargs{…}); @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/HPOLD/src/Models/NonhydrostaticModels/set_nonhydrostatic_model.jl:54; [18] top-level scope; @ ~/code/internal-tide-mixing/test_MWE_conjugate_gradient.jl:28; Some type information was truncated. Use `show(err)` to see complete types. ```. Here's a minimal working example (I tried to make it as minimal as possible, apologies if it's not minimal enough). I set the bottom topography to zero everywhere except for one grid cell, which is set to 0.2. Notably, when I change this value from 0.2 to 0.01, the error no longer appears. It is not clear to me what the issue might be.; ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver. underlying_grid = RectilinearGrid(size=(4, 4, 4), ; x = (0, 1),; y = (0, 1), ; z = [0, 0.2,0.4,0.6, 2],; halo = (2,2,2),; topology = (Oceananigans.Periodic, Oceananigans.Periodic, Oceananigans.Bounded); ); bottom = [0.0 0.0 0.0 0.0;; 0.0 0.0 0.0 0.0;; 0.0 0.0 0.2 0.0;; 0.0 0.0 0.0 0.0]. grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). uᵢ(x, y, z) = 0.1. model = NonhydrostaticModel(;; grid=grid,; pressure_solver = ConjugateGradientPoissonSolver(; grid; preconditioner = fft_poisson_solver(underlying_grid)),; advection = WENO(),; timestepper = :RungeKutta3,; ); set!(model, u=uᵢ); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3896:4394,clear,clear,4394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3896,1,['clear'],['clear']
Usability,rrays v1.13.0; [4d8831e6] OpenSSL v1.4.2; [bac558e1] OrderedCollections v1.6.3; [65ce6f38] PackageExtensionCompat v1.0.2; [69de0a69] Parsers v2.8.1; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [b98c9c47] Pipe v1.3.0; [eebad327] PkgVersion v0.3.3; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.4.1; [91a5bcdd] Plots v1.40.2; [2dfb63ee] PooledArrays v1.4.3; ⌃ [aea7be01] PrecompileTools v1.2.0; [21216c6a] Preferences v1.4.3; [08abe8d2] PrettyTables v2.3.1; [49802e3a] ProgressBars v1.5.1; [94ee1d12] Quaternions v0.7.6; [74087812] Random123 v1.7.0; [e6cf234a] RandomNumbers v1.5.3; [c1ae055f] RealDot v0.1.0; [3cdcf5f2] RecipesBase v1.3.4; [01d81517] RecipesPipeline v0.6.12; [189a3867] Reexport v1.2.2; [05181044] RelocatableFolders v1.0.1; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [6c6a2e73] Scratch v1.2.1; [d496a93d] SeawaterPolynomials v0.3.4; [91c51154] SentinelArrays v1.4.1; [992d4aef] Showoff v1.0.3; [777ac1f9] SimpleBufferStream v1.1.0; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.3.1; [aedffcd0] Static v0.8.10; [0d7ed370] StaticArrayInterface v1.5.0; [90137ffa] StaticArrays v1.9.3; [1e83bf80] StaticArraysCore v1.4.2; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [2913bbd2] StatsBase v0.34.2; [5e0ebb24] Strided v2.0.4; [4db3bf67] StridedViews v0.2.2; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [53d494c1] StructIO v0.3.0; [856f2bd8] StructTypes v1.10.0; [dc5dba14] TZJData v1.1.0+2023d; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.11.1; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [62fd8b95] TensorCore v0.1.1; [f269a46b] TimeZones v1.13.0; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; [3bb67fe8] TranscodingStreams v0.10.4; [9d95972d] TupleTools v1.5.0; [5c2747f8] URIs v1.5.1; [1cfade01] UnicodeFun v0.4.1; [1986cc42] Unitful v1.19.0; [45397f5d] UnitfulLatexify v1.6.3; [013be700] UnsafeAtomics v0.2.1; [d80eeb9a] Unsa,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:5601,Simpl,SimpleBufferStream,5601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Simpl'],['SimpleBufferStream']
Usability,"s eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:1926,clear,clearly,1926,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,1,['clear'],['clearly']
Usability,"s possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:2362,simpl,simplifies,2362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['simpl'],['simplifies']
Usability,"setVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:74; [3] top-level scope; @ REPL[10]:1; ```. This seems counter-intuitive to me because we _had_ actually prescribed a `cfl`. We figured that the error was because `substeps` has a default value of 200 so when we also prescribe a `cfl` kwarg then . https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),; tracer_advection = WENO()). simulation = Simulation(model, Δt=10, stop_time=3600). run!(simulation); ```. spits out . ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; Stacktrace:; [1] calculate_substeps; @ ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl:324 [inlined]; [2] iterate_split_explicit!(free_surface::SplitExplicit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238:2590,intuit,intuitive,2590,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238,1,['intuit'],['intuitive']
Usability,"ss red tape in some ways, rather like ""accepting cookies"" every time we have to visit a website. We don't really think about that anymore, we just click as fast as we can so we can move on with out lives... I think @Sbozzolo might have some idea for how to do this better. More or less I think the gist is that, rather than having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniformly useful to everyone. So by wading into this area, we risk doing a crap job and interf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543:1876,learn,learn,1876,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543,1,['learn'],['learn']
Usability,"t does not work with the tracer equations, yet, and it assumes a Dirichlet-zero boundary condition. The user must give a boolean function to the model, which returns `false` if the point is in the fluid. . This also includes a basic example for steady-state flow around a cylinder in 2D `flow_around_cylinder_lowRe.jl`, such as this:; ![velocity_Re40_dx04_small_paper](https://user-images.githubusercontent.com/67593861/108130156-2f329880-707d-11eb-87db-6d519e2513be.gif); ; The barebones of this implementation is rather old at this point. Even though it has been updated to work with the current set up, I imagine there are things that might still need more updating or have become superfluous. All suggestions are appreciated!. ### Description:; Instead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. In practice, when your boundary conforms to the grids, creating a stair-step like boundary, this becomes much simpler to handle. Here, we replace the tendency terms in `correct_immersed_tendencies.jl` so that when you take the next Runge-Kutta step, you end up with U = 0. . Since this process occurs before the pressure correction, there is a small amount of error that seems to fit with the correction as seen here for various places within the cylinder where it should be zero:; ![Pcorrect_vs_velocity_inside_dx04](https://user-images.githubusercontent.com/67593861/108130321-7ae54200-707d-11eb-9101-273350597d8c.png); ; It would need more testing to truly verify that this is the case, but seems to fit the data so far. ### To Do/ Upcoming:; - Currently working on an arbitrary grid implementation, that can intersect the boundary however it wants. This involves a good amount of interpolation, but it well on the way. This implementation will easily handle Neumann and Dirichlet boundary conditions. It makes more sense for normal and tangential boundary cond",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1368:1277,simpl,simpler,1277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368,1,['simpl'],['simpler']
Usability,"the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`); `U` => `WENO5()` ; `S` => `WENO5(grid = grid)` ; `β` => `WENO5(grid = grid, stretched_smoothness=true)` ; `Z` => `WENO5(grid = grid, stretched_smoothness=true, zweno=true)` . https://user-images.githubusercontent.com/7112768/142819747-4e4083cf-d725-4f1a-bac7-4fb10800ecc7.mp4. https://user-images.githubusercontent.com/7112768/142819755-fec13fb6-684f-4f1a-b7ec-78d9768c4ff7.mp4. Closes #1704",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060:1840,simpl,simple,1840,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060,1,['simpl'],['simple']
Usability,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/295:518,simpl,simply,518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295,1,['simpl'],['simply']
Usability,"undaryGrid`s. This originally popped up in https://github.com/CliMA/Oceananigans.jl/discussions/3423#discussioncomment-8115603 and I dug into it a bit more since then but so far haven't been able to solve it. ```julia; using Oceananigans. grid_base = RectilinearGrid(CPU(), size = (4, 4, 4), extent = (1,1,1)). # The lines immediately below work; using Oceananigans.Grids: boundary_node; boundary_node_ccf = KernelFunctionOperation{Center, Center, Face}(boundary_node, grid_base, Center(), Center(), Face()); c = CenterField(grid_base); compute!(Field(Average(c, condition=(boundary_node_ccf .== true)))). # The last line here doesn't work; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> 1/2)); c_ib = CenterField(grid); compute!(Field(Average(c_ib, condition=(boundary_node_ccf .== true)))); ```. The first computation above (which doesn't use any immersed boundaries) works, although it's odd that I have to set `condition=(boundary_node_ccf .== true)`, since it fails if I simply set `condition=boundary_node_ccf`. However, the last line, which does use `ImmersedBoundaryGrid`s, fails with the following error:. ```; ERROR: LoadError: MethodError: condition_operand(::typeof(identity), ::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:1130,simpl,simply,1130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['simpl'],['simply']
Usability,"user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L160. it's not clear to me what's `c`, `C`, `U`. It takes some amount of digging for me (who, admittedly, am not super familiar with the code) to conclude that `c` is the `tracer` and `U` is the `velocities` tuple. (I'm still not 100% sure what `C` is). I understand that, again, I'm not super familiar with the code, so most Oceananigans developers would understand that module faster than me, but I think it's advantageous to make the code in general more easily understandable for people like me, who aren't experts in the code. . I also understand that that is an incredibly complicated module, with no obvious way to organize it concisely. But I think using more verbose names would make it a lot more clear. So I propose we make variable and function names more verbose there. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751:2146,clear,clear,2146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751,2,['clear'],['clear']
Usability,"ux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:3711,usab,usable,3711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['usab'],['usable']
Usability,"vate implementing an abstraction `drag_boundary_conditions` that returns the bcs for `u, v, w`, eg:. ```julia; u_drag_bc, v_drag_bc, w_drag_bc = drag_boundary_conditions(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes. In terms of a path forward, I think we could simply start with the constant roughness length case, and perhaps make the utility a bit general so that users could also directly specify a drag coefficient if desired. For example in hydrostatic cases we often specify the drag coefficient directly, and we also usually omit the dependence on `w`. There are even more considerations one might consider... for example, in a finite volume model (and in the code above) the distance to the wall is taken as the ""center of the cell"", ie half the cell thickness. But this is not really consistent with the finite volume framework, and better approaches have been proposed (eg see [Nishizawa and Kitamura 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001534)). Note that if we want to compute fluxes across the air-sea interface, it's probably better to use ClimaOcean (tools for building coupled and realistic air-sea, air-ice-sea models) for that. But ClimaOcean is not going to support the algorithmically simpler, yet geometrically more complicated case of computing momentum fluxes into co",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:5309,simpl,simply,5309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['simpl'],['simply']
Usability,"w = - \partial_z p + b + G_w' $$. where $G_w'$ collects the contributions to the vertical momentum tendency other than pressure gradient and buoyancy. Prior to this PR, the kinematic pressure $p$ is decomposed into (note that in this Boussinesq formulation, a hydrostatic component has already been removed from $p$) . $$ p = p_h' + p_n $$. with the hydrostatic anomaly $p_h'$ defined by. $$ p_h' = - \int^0_z b \mathrm{d} z $$. Using the hydrostatic pressure anomaly eliminates buoyancy from the vertical momentum equation, such that. $$ \partial_t w = - \partial_z p_n + G_w' $$. Buoyancy forces enter the dynamics via horizontal gradients of the hydrostatic pressure anomaly. For example, x-gradient of the kinematic pressure becomes. $$ \partial_x p = \partial_x p_h' + \partial_x p_n $$. This decomposition is advantageous for two reasons. First, in a hydrostatic model the vertical momentum equation reduces to the equation for $p_h'$. This means that switching from a hydrostatic to non-hydrostatic model is particularly simple given this decomposition. Second --- and this must be evaluated --- it's possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used bec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:1280,simpl,simple,1280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['simpl'],['simple']
Usability,"x'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations.tracers`) that are named tuples of kernel equations. An example of how this might work while demonstrating hierarchical multiple dispatch is:. ```julia; forcing(i, j, k, grid, F::Function, u, v, w, T, S) = F(grid, u, v, w, T, S, i, j, k); forcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i, j, k, grid, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w, T, S); ). # Note omission of pressure term here; u_eqn(i, j, k, grid, pHY::Nothing, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w T, S); ). linear_u_eqn(i, j, k, grid, etc....) = (fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:2158,simpl,simplest,2158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['simpl'],['simplest']
Usability,"xtent=(Lx, Ly, Lz), topology=topology). # No-slip bottom, free-slip top and side walls through default boundary conditions; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), east = BoundaryCondition(Gradient,0.0)); vbcs = VVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0)); bbcs = TracerBoundaryConditions(grid, west = BoundaryCondition(Value,0.0)); nothing # hide. # ## Model instantiation and initial condition; #; # We use a constant viscosity and diffusivity.; # Set forcing; #fun_forcing(x, y, z, t) = (0.5*(1-erf(abs(sqrt((x-xc)^2+(y-yc)^2+(z-zc)^2)-R)))); fun_dist_to_source(x,y,z,t,a,y₀) = sqrt((x-Lx/2)^2+(y-y₀-a*t)^2+(z+Lz/2)^2); fun_forcing(x, y, z, t,p) = -0.5*(1-erf((fun_dist_to_source(x,y,z,t,p.a,p.y₀)-p.R)/p.δᴸ)). b_forcing = SimpleForcing(fun_forcing, parameters=(a=0.5,y₀=2,R=0.5,δᴸ=0.1)). #parameterized_forcing(x, y, z, t, p) = p.μ * exp(z/p.λ) * cos(p.ω*t); #v_forcing = SimpleForcing(parameterized_forcing, parameters=(μ=42, λ=0.1, ω=π)); forcing = ModelForcing(b=b_forcing). model = IncompressibleModel(; grid = grid,; architecture = CPU(),; boundary_conditions = (u=ubcs, v=vbcs, b=bbcs),; closure = ConstantIsotropicDiffusivity(ν=iRe, κ=iPe),; tracers = :b,; buoyancy = BuoyancyTracer(),; forcing = forcing; ). # Set initial condition; b₀(x, y, z) = 0.0#-0.5 * (1 - erf((y - yᴸ) / δᴸ)). set!(model, b=b₀); nothing # hide. ### Progress diagnostic function; using Oceananigans.Diagnostics, Printf. umax = FieldMaximum(abs, model.velocities.u); vmax = FieldMaximum(abs, model.velocities.v); wmax = FieldMaximum(abs, model.velocities.w). wall_clock = time_ns(). function print_progress(simulation); model = simulation.model. # Print a progress message; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; model.clock.iteration,; prettytime(model.clock.time),; prettytime(wizard.Δt),; umax(), vmax(), wmax(),; prettytime(1e-9 * (time_ns() - wall_clock))",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/789:3390,Simpl,SimpleForcing,3390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789,1,['Simpl'],['SimpleForcing']
Usability,"y linearly extrapolating the interior field across the boundary into the halo region, using. * the specified gradient (for `Gradient` boundary conditions); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solve",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389:1224,simpl,simplification,1224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389,1,['simpl'],['simplification']
Usability,"z-Signature=779b961e8385e6456d63980757c47e35f1c1dd69db925e240032b9055d9a2364&hash=23906dc815e1871c325b937eb48d6c480ea0ae6577d9267f9331fa4191fa7274&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500317300471&tid=spdf-3e1d0343-787e-407e-819c-dd650ee95cad&sid=14dd78682619684b691b33669d091ccbdc9egxrqa&type=client&ua=530652025f020b5652&rr=6e1a8cd34a467c44). This model assumes that the surface wave spectrum is self-similar according to the Phillips spectrum to produce a Stokes drift profile. We're about to do some epic modeling so hold onto your hats --- no, really. In the version of ""theory wave"" that does _not_ account for directional spreading, the Stokes drift profile takes the form. ![image](https://user-images.githubusercontent.com/15271942/155204195-dff6233d-a9b1-411b-a544-a9e106e2fad2.png). Note that we require the _vertical average of the Stokes shear_ for our finite volume model. This can be computed as the difference between the Stokes velocity at the top and bottom of a cell (let's take all the simple wins we can here). This model has two parameters: the wave number at the spectral peak, `k_p`, and the surface Stokes drift `u^S_Phil(0)`. Li et al propose. ![image](https://user-images.githubusercontent.com/15271942/155204117-b111eccb-f94c-4273-9262-7b3e194d6b84.png). and. ![image](https://user-images.githubusercontent.com/15271942/155204435-fe2b2215-ed24-40bf-ac38-cb2902e0e5d3.png). where V^S is the Stokes transport. One possibility is to use a scaling proposed by [Restrepo and McWilliams 1999] (https://journals.ametsoc.org/view/journals/phoc/29/10/1520-0485_1999_029_2523_twdoc_2.0.co_2.xml) (here T^S is Li et al's V^S):. <img width=""530"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155206371-f00fe258-688f-40b3-98c9-6abe83d6a03a.png"">. Note that other aspects of that paper are extremely misleading so read with caution... All of that closes one possible model for equilibrium waves. A second possibility is to ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290:4534,simpl,simple,4534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290,1,['simpl'],['simple']
Usability,"~~This PR adapts `BetaPlane` coriolis implementation for curvilinear grids (following #1371 and [MITgcm docs](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8)).~~. ~~Note that the MITgcm docs specify averaging the Coriolis parameter / planetary vorticity (from corner / vorticity nodes, ffc, to the velocity nodes fcc and cfc). However, because the variation in the planetary vorticity is linear, I think the implementation in this PR is correct for beta planes? @jm-c please advise.~~. I would ~~also~~ like to add a Coriolis term valid for the sphere and hydrostatic models (which amounts to the ""traditional approximation""). ~~I'll do this once #1380 is merged.~~ This PR depends on #1380. Some feedback on what to call this object is certainly welcome! I have preliminary proposed ""`HydrostaticSphericalCoriolis` because it was the first silly thing I could think of. To do:. - [x] Add `HydrostaticSphericalCoriolis` plus unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384:719,feedback,feedback,719,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384,1,['feedback'],['feedback']
Usability,"────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```; ## Possible future improvements. In this PR I also attempted to explore an alternative formulation of the FFT-based preconditioner:. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H Δt) - ∇ʰ H ⋅ ∇ʰ η★ / H,; ```. where `η★` is the current solution in the conjugate gradient iteration. However, this caused the iteration to diverge. Perhaps it would be better to use `ηⁿ`, but I'm not sure. On the right side, `H` is no longer constant but instead is the actual depth `H(x, y)`. I also tried using `H̄` in the denominators above, but this apparently made no difference. # Other changes / improvements. To support this development, this PR implements some improvements to `PreconditionedConjugateGradientSolver`. Previously we would specify the argument `precondition!`, which was supposed to be a function that computed `P * r`, where `P` is often called the ""preconditioner"". Now we specify `preconditioner`, which must define a method. ```julia; precondition!(z, preconditioner, r, args...); ```. This API is more convenient for preconditioners that require some data storage or precomputation and thus must be objects of their own (rather than functions). - In the conjugate gradient loop, we launch broadcasts with `parent(a) .= parent(b)` rather than using Oceananigans internal broadcasting `a .= b`. This is a bit faster and saves some memory allocation.; - The default preconditioner for `PCGImplicitFreeSurface` is now `nothing`.; - We now always precompute and store `GridFittedBottom`, since it's rarely / never desired to compute on the fly and ""only supporting arrays"" simplifies our code.; - The interface for `PreconditionedConjugateGradientSolver` now resembles the interface to `cg` with properties `maxiter`, `abstol`, and `reltol`; - The default `reltol` for the `PCGImplicitFreeSurfaceSolver` is `max(1e-7, 10 * eps(eltype(grid)))`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:6991,simpl,simplifies,6991,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['simpl'],['simplifies']
