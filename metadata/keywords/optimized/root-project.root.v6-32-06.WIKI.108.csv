quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Security,"entify the object and,...Definition TCollection.cxx:437; TCollection::PrintCollectionHeadervirtual void PrintCollectionHeader(Option_t *option) constPrint the collection header.Definition TCollection.cxx:425; TObjectMother of all ROOT objects.Definition TObject.h:41; int; Otherwise override the Print(Option_t *option, Int_t) variant. Remember to declare: using TCollection::Print;; TCollection::Printvoid Print(Option_t *option="""") const overrideDefault print for collections, calls Print(option, 1).Definition TCollection.cxx:476; somewhere close to the method declaration. ; Reimplemented from TCollection.; Definition at line 197 of file TCollection.cxx. ◆ Rehash(). void THashTable::Rehash ; (; Int_t ; newCapacity, . Bool_t ; checkObjValidity = kTRUE . ). Rehash the hashtable. ; If the collision rate becomes too high (i.e. the average size of the linked lists become too long) then lookup efficiency decreases since relatively long lists have to be searched every time. To improve performance rehash the hashtable. This resizes the table to newCapacity slots and refills the table. Use AverageCollisions() to check if you need to rehash. Set checkObjValidity to kFALSE if you know that all objects in the table are still valid (i.e. have not been deleted from the system in the meanwhile). ; Definition at line 365 of file THashTable.cxx. ◆ Remove(). TObject * THashTable::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the hashtable. ; Implements TCollection.; Definition at line 417 of file THashTable.cxx. ◆ RemoveSlow(). TObject * THashTable::RemoveSlow ; (; TObject * ; obj). Remove object from the hashtable without using the hash value. ; Definition at line 442 of file THashTable.cxx. ◆ SetRehashLevel(). void THashTable::SetRehashLevel ; (; Int_t ; rehash). inline . Definition at line 80 of file THashTable.h. ◆ Streamer(). void THashTable::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:27319,hash,hashtable,27319,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hashtable']
Security,"enting an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are ru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:109090,access,access,109090,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['access'],['access']
Security,"entres, which can still be enabled by setting the useAverage parameter of RooPlot::residHist or RooPlot::pullHist to false.; Improved recovery from invalid parameters; When a function in RooFit is undefined (Poisson with negative mean, PDF with negative values, etc), RooFit can now pass information about the “badness” of the violation to the minimiser. The minimiser can use this to compute a gradient to find its way out of the undefined region. This can drastically improve its ability to recover when unstable fit models are used, for example RooPolynomial.; For details, see the RooFit tutorial rf612_recoverFromInvalidParameters.C and arxiv:2012.02746.; Modernised RooDataHist; RooDataHist was partially modernised to improve const-correctness, to reduce side effects as well as its memory footprint, and to make it ready for RooFit’s faster batch evaluations. Derived classes that directly access protected members might need to be updated. This holds especially for direct accesses to _curWeight, _curWeightErrLo, etc, which have been removed. (It doesn’t make sense to write to these members from const functions when the same information can be retrieved using an index access operator of an array.) All similar accesses in derived classes should be replaced by the getters get_curWeight() or better get_wgt(i), which were also supported in ROOT <v6.24. More details on what happened:. Reduced side effects. This code produces undefined behaviour because the side effect of get(i), i.e., loading the new weight into _curWeight is not guaranteed to happen before weight() is called:. processEvent(dataHist.get(i), dataHist.weight()); // Dangerous! Order of evaluation is not guaranteed.; With the modernised interface, one would use:; processEvent(dataHist.get(i), dataHist.weight(i));; To modernise old code, one should replace patterns like h.get(i); h.func() by h.func(i);. One may #define R__SUGGEST_NEW_INTERFACE to switch on deprecation warnings for the functions in question. Similar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:22523,access,accesses,22523,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['access'],['accesses']
Security,"ents TSeqCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, and TSelectorList.; Definition at line 95 of file THashList.cxx. ◆ AddLast() [2/2]. void THashList::AddLast ; (; TObject * ; obj, . Option_t * ; opt . ). overridevirtual . Add object at the end of the list and also store option. ; Storing an option is useful when one wants to change the behaviour of an object a little without having to create a complete new copy of the object. This feature is used, for example, by the Draw() method. It allows the same object to be drawn in different ways. ; Reimplemented from TList.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, and TSelectorList.; Definition at line 110 of file THashList.cxx. ◆ AverageCollisions(). Float_t THashList::AverageCollisions ; (; ); const. Return the average collision rate. ; The higher the number the longer the linked lists in the hashtable, the slower the lookup. If the number is high, or lookup noticeably too slow, perform a Rehash(). ; Definition at line 178 of file THashList.cxx. ◆ Class(). static TClass * THashList::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * THashList::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t THashList::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 72 of file THashList.h. ◆ Clear(). void THashList::Clear ; (; Option_t * ; option = """"). overridevirtual . Remove all objects from the list. ; Does not delete the objects unless the THashList is the owner (set via SetOwner()). ; Implements TCollection.; Reimplemented in TListOfEnums, TListOfEnumsWithLock, TListOfDataMembers, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 189 of file THashList.cxx. ◆ DeclFileName(). static const char * THashList::DeclF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:27678,hash,hashtable,27678,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['hash'],['hashtable']
Security,"ents \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](int j); { return (*fMat)(fRow,j); }. const T & operator[](int j); { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (writt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:7242,access,access,7242,root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,8,['access'],['access']
Security,"entsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches ; static Bool_t_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:29569,validat,validate,29569,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,2,"['access', 'validat']","['access', 'validate']"
Security,"enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; void*fCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContaine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGenCollectionProxy.html:4368,access,accessors,4368,root/html534/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html,3,['access'],['accessors']
Security,"enumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THashList.html:11971,hash,hashlist,11971,root/html602/THashList.html,https://root.cern,https://root.cern/root/html602/THashList.html,2,['hash'],['hashlist']
Security,"enumeration, EUrl scopeType); 898{; 899 // The URL consists of URL for the ""scopeName"", ""#a"" and hashed as MD5 text.; 900 // The text is ""Class::EnumerationEnumeration.; 901 TString md5Enumeration(scopeName);; 902 md5Enumeration.Append(""::"");; 903 md5Enumeration.Append(enumeration);; 904 md5Enumeration.Append(enumeration);; 905 // We make the URL for the scope ""scopeName"".; 906 TString url(UrlGenerator(scopeName, scopeType));; 907 // Then we have to append ""#a"" and the hashed text.; 908 url.Append(""#a"");; 909 url.Append(md5Enumeration.MD5());; 910 return url;; 911}; 912} // namespace; 913 ; 914namespace {; 915enum EMethodKind { kURLforMethod, kURLforStructor };; 916////////////////////////////////////////////////////////////////////////////////; 917/// The function generates URL for any member function (including Constructor/; 918/// Destructor) of ""scopeName"". Doxygen first generates the URL for the scope.; 919/// We do that with the help of ""UrlGenerator"". Then we append ""#a"" and a; 920/// hashed with MD5 text. It consists of:; 921/// ""ReturnType ScopeName::MethodNameMethodName(Method arguments)"".; 922/// For constructor/destructor of a class, the return type is not appended.; 923///; 924/// \param[in] scopeName the name of the class/namespace/struct; 925/// \param[in] methodName the name of the method from the scope; 926/// \param[in] func pointer to the method; 927/// \param[in] methodType enumerator for method or constructor; 928/// \param[in] scopeType enumerator for class/namespace/struct; 929 ; 930static TString GetUrlForMethod(const TString &scopeName, const TString &methodName, TFunction *func,; 931 EMethodKind methodType, EUrl scopeType); 932{; 933 TString md5Text;; 934 if (methodType == kURLforMethod) {; 935 // In the case of method, we append the return type too.; 936 // ""FormatReturnTypeForDoxygen"" modifies the return type with respect to Doxygen's requirement.; 937 md5Text.Append((FormatReturnTypeForDoxygen(scopeName, func)));; 938 if (scopeType == kU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:34700,hash,hashed,34700,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['hash'],['hashed']
Security,"eoElementTable * GetElementTable()Returns material table. Creates it if not existing.Definition TGeoManager.cxx:3624; TGeoManager::SetUserPaintVolumevoid SetUserPaintVolume(TGeoVolume *vol)Definition TGeoManager.h:235; TGeoManager::fNtracksInt_t fNtracksDefinition TGeoManager.h:74; TGeoManager::fHashPNETHashList * fHashPNEhash list of group volumes providing fast searchDefinition TGeoManager.h:138; TGeoManager::IsVisLeavesBool_t IsVisLeaves() constDefinition TGeoManager.h:223; TGeoManager::IsNullStepBool_t IsNullStep() constDefinition TGeoManager.h:408; TGeoManager::GetListOfTracksTObjArray * GetListOfTracks() constDefinition TGeoManager.h:478; TGeoManager::fgVerboseLevelstatic Int_t fgVerboseLevelLock preventing a second geometry to be loaded.Definition TGeoManager.h:51; TGeoManager::IsStartSafeBool_t IsStartSafe() constDefinition TGeoManager.h:395; TGeoManager::Initvoid Init()Initialize manager class.Definition TGeoManager.cxx:416; TGeoManager::InitArrayPNEBool_t InitArrayPNE() constInitialize PNE array for fast access via index and unique-id.Definition TGeoManager.cxx:4214; TGeoManager::fPhysicalNodesTObjArray * fPhysicalNodesDefinition TGeoManager.h:96; TGeoManager::SizeOfvirtual ULong_t SizeOf(const TGeoNode *node, Option_t *option)computes the total size in bytes of the branch starting with node.Definition TGeoManager.cxx:3926; TGeoManager::SetLoopVolumesvoid SetLoopVolumes(Bool_t flag=kTRUE)Definition TGeoManager.h:155; TGeoManager::fUniqueVolumesTObjArray * fUniqueVolumesDefinition TGeoManager.h:129; TGeoManager::fgExportPrecisionstatic UInt_t fgExportPrecisionMaximum number of Xtru vertices.Definition TGeoManager.h:55; TGeoManager::fRegionsTObjArray * fRegionsDefinition TGeoManager.h:109; TGeoManager::Nodevoid Node(const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t *upar, Int_t npar=0)Create a node called <name_nr> pointing to the volume called <name> as daughter of the volume called ...Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:44677,access,access,44677,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['access'],['access']
Security,"eoOpticalSurface.h:27; TGeoPNEntryThe knowledge of the path to the objects that need to be misaligned is essential since there is no ot...Definition TGeoPhysicalNode.h:100; TGeoParallelWorldBase class for a flat parallel geometry.Definition TGeoParallelWorld.h:23; TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; TGeoRegionRegions are groups of volumes having a common set of user tracking cuts.Definition TGeoRegion.h:36; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoSkinSurfaceDefinition TGeoOpticalSurface.h:177; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; TGeoVolumeMultiVolume families.Definition TGeoVolume.h:266; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TVirtualGeoPainterAbstract class for geometry painters.Definition TVirtualGeoPainter.h:32; TVirtualGeoTrackBase class for user-defined track",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:101181,hash,hash,101181,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['hash'],['hash']
Security,"eobject identifier; TStringfObjectsPath! default path for registered objects; Bool_tfReadOnly! indicate if sniffer allowed to change ROOT structures - for instance, read objects from files; TListfRestrictions! list of restrictions for different locations; Bool_tfScanGlobalDir! when enabled (default), scan gROOT for histograms, canvases, open files; TList*fSinfo! last produced streamer info; TStringTNamed::fTitleobject title. private:. static TRootSniffer::(anonymous)kItemField. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSniffer(const char* name, const char* objpath = ""Objects""); constructor. ~TRootSniffer(); destructor. void SetCurrentCallArg(THttpCallArg* arg); set current http arguments, which then used in different process methods; For instance, if user authorized with some user name,; depending from restrictions some objects will be invisible; or user get full access to the element. void Restrict(const char* path, const char* options); Restrict access to the specified location. Hides or provides read-only access to different parts of the hierarchy; Restriction done base on user-name specified with http requests; Options can be specified in URL style (separated with &); Following parameters can be specified:; visible = [all|user(s)] - make item visible for all users or only specified user; hidden = [all|user(s)] - make item hidden from all users or only specified user; readonly = [all|user(s)] - make item read-only for all users or only specified user; allow = [all|user(s)] - make full access for all users or only specified user; allow_method = method(s) - allow method(s) execution even when readonly flag specified for the object; Like make command seen by all but can be executed only by admin; sniff->Restrict(""/CmdReset"",""allow=admin"");; Or fully hide command from guest account; sniff->Restrict(""/CmdRebin"",""hidden=guest"");. Bool_t HasRestriction(const char* item_name); Made fast check if item with specified nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootSniffer.html:10213,access,access,10213,root/html604/TRootSniffer.html,https://root.cern,https://root.cern/root/html604/TRootSniffer.html,1,['access'],['access']
Security,"eometry description.Definition TGeometry.h:39; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THtmlLegacy ROOT documentation system.Definition THtml.h:40; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLinkSpecial TText object used to show hyperlinks.Definition TLink.h:17; TListA doubly linked list.Definition TList.h:38; TMethodArgEach ROOT method (see TMethod) has a linked list of its arguments.Definition TMethodArg.h:36; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMinuitDefinition TMinuit.h:27; TObjectTableThis class registers all instances of TObject and its derived classes in a hash table.Definition TObjectTable.h:35; TObjectMother of all ROOT objects.Definition TObject.h:41; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveA TBox with a bordersize and a shadow option.Definition TPave.h:19; TPostScriptInterface to PostScript.Definition TPostScript.h:20; TROOTROOT top level object description.Definition TROOT.h:94; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRootGuiFactoryThis class is a factory for ROOT GUI components.Definition TRootGuiFactory.h:27; TSignalHandlerDefinition TSysEvtHandler.h:127; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStyleTStyle obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjectTable.html:5627,hash,hash,5627,doc/master/classTObjectTable.html,https://root.cern,https://root.cern/doc/master/classTObjectTable.html,1,['hash'],['hash']
Security,"eping only axes in dim (specifying ndim dimensions). ;  ; THnBase * RebinBase (const Int_t *group) const;  Combine the content of ""group"" neighboring bins for each dimension into a new bin and return the resulting THnBase. ;  ; THnBase * RebinBase (Int_t group) const;  Combine the content of ""group"" neighboring bins into a new bin and return the resulting THnBase. ;  ; void ResetBase (Option_t *option="""");  Clear the histogram. ;  ; void UpdateXStat (const Double_t *x, Double_t w=1.);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions;  THnSparse (const THnSparse &)=delete;  ; THnSparse & operator= (const THnSparse &)=delete;  . Private Attributes; TObjArray fBinContent;  Array of THnSparseArrayChunk. ;  ; TExMap fBins;  ! Filled bins ;  ; TExMap fBinsContinued;  ! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1) ;  ; Int_t fChunkSize;  Number of entries for each chunk. ;  ; THnSparseCompactBinCoord * fCompactCoord;  ! Compact coordinate ;  ; Long64_t fFilledBins;  Number of filled bins. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from THnBase; enum  { kNoInt; , kValidInt; , kInvalidInt; };  ;  Protected Ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:26769,hash,hashes,26769,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,1,['hash'],['hashes']
Security,"epochs to train; TObjArray*fNetworkTObjArray of TObjArrays representing network; TStringfNeuronInputTypename of neuron input calculator class; TStringfNeuronTypename of neuron activation function class; TMVA::TActivation*fOutputactivation function to be used for output layers, depending on estimator; Int_tfRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural data; boolfUseRegulatorzjh; TRandom3*frgenrandom number generator for various uses. private:. TObjArray*fInputLayercache this for fast access; TStringfLayerSpeclayout specification option; vector<TMVA::TNeuron*>fOutputNeuronscache this for fast access; static const Bool_tfgDEBUGdebug flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodANNBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir); standard constructor; Note: Right now it is an option to choose the neuron input function,; but only the input function ""sum"" leads to weight convergence --; otherwise the weights go to nan and lead to an ABORT. MethodANNBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir); construct the Method from the weight file. void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalise",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodANNBase.html:19997,access,access,19997,root/html602/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodANNBase.html,4,['access'],['access']
Security,"epresentation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 50331656,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. root.bin - binary data produced by object streaming with TBufferFile; root.json - ROOT JSON representation for object and objects members; root.xml - ROOT XML representation; root.png - PNG image (if object drawing implemented); root.gif - GIF image; root.jpeg - JPEG image; exe.json - method execution in the object; exe.bin - method execution, return result in binary form; cmd.json - command execution; item.json - item (object) properties, specified on the server; multi.json - perform several requests at once; multi.bin - perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.7.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: “title”.; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all).; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different request methods with TH1 object shown in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:10726,access,access,10726,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,2,"['access', 'authenticat']","['access', 'authentication']"
Security,"eprotectedvirtual . Reimplemented in ROOT::Experimental::RStreamerField.; Definition at line 425 of file RFieldBase.hxx. ◆ GetFieldName(). const std::string & ROOT::Experimental::RFieldBase::GetFieldName ; (; ); const. inline . Definition at line 511 of file RFieldBase.hxx. ◆ GetFieldVersion(). virtual std::uint32_t ROOT::Experimental::RFieldBase::GetFieldVersion ; (; ); const. inlinevirtual . Indicates an evolution of the mapping scheme from C++ type to columns. ; Definition at line 540 of file RFieldBase.hxx. ◆ GetNRepetitions(). std::size_t ROOT::Experimental::RFieldBase::GetNRepetitions ; (; ); const. inline . Definition at line 517 of file RFieldBase.hxx. ◆ GetOnDiskId(). DescriptorId_t ROOT::Experimental::RFieldBase::GetOnDiskId ; (; ); const. inline . Definition at line 527 of file RFieldBase.hxx. ◆ GetOnDiskTypeChecksum(). std::uint32_t ROOT::Experimental::RFieldBase::GetOnDiskTypeChecksum ; (; ); const. inline . Return checksum stored in the field descriptor; only valid after a call to ConnectPageSource(), if the field stored a type checksum. ; Definition at line 549 of file RFieldBase.hxx. ◆ GetOnDiskTypeVersion(). std::uint32_t ROOT::Experimental::RFieldBase::GetOnDiskTypeVersion ; (; ); const. inline . Return the C++ type version stored in the field descriptor; only valid after a call to ConnectPageSource() ; Definition at line 546 of file RFieldBase.hxx. ◆ GetParent(). const RFieldBase * ROOT::Experimental::RFieldBase::GetParent ; (; ); const. inline . Definition at line 518 of file RFieldBase.hxx. ◆ GetPrincipalColumnOf(). static Internal::RColumn * ROOT::Experimental::RFieldBase::GetPrincipalColumnOf ; (; const RFieldBase & ; other). inlinestaticprotected . Fields may need direct access to the principal column of their sub fields, e.g. in RRVecField::ReadBulk. ; Definition at line 408 of file RFieldBase.hxx. ◆ GetQualifiedFieldName(). std::string ROOT::Experimental::RFieldBase::GetQualifiedFieldName ; (; ); const. Returns the field name and parent fiel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:41430,checksum,checksum,41430,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,2,['checksum'],['checksum']
Security,"equal size, meaningful and unique icons, and short meaningful tool tip text. The related buttons should be grouped together by frequency or sequence of use, or importance. Potentially destructive buttons must be separated from them to avoid accidental activation and potentially catastrophic results. Temporarily not available items should be displayed grayed out.; 25.8.6 List Boxes; The purpose of a list box is to display a collection of items from which single or multiple selection can be made. It is always visible, having a scroll bar when the displayed area is not enough to show all items. The choices may be mutually exclusive (a list box with single selection) or not mutually exclusive (a list box with multiple selection). The proper usage of the list boxes is for selecting values, or objects, or setting attributes. You have to create them to display 4 to 8 choices at one time (3 is a required minimum in case of lack of screen space). The list should contain not more than 40 items accessible by scrolling view (vertical scroll bar). If more are required, you should provide a method for using search criteria or scoping the options. The best list boxes use is for textual data or choices. They should be wide enough to display fully all items. When it is not possible, break the long items with ellipsis and provide tool tip that displays the full item text.; The list box widget is represented by TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry classes. Currently entries are simple text strings (TGTextLBEntry). A TGListBox looks a lot like a TGCanvas. It has a TGViewPort containing a TGLBContainer which contains the entries and it also has a vertical scrollbar which becomes visible if there are more items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service classes of the list box. Here is a sample code showing how to create a list box with ten entries:; // list box widget containing 10 entries; int fFirstEntry",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1199542,access,accessible,1199542,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessible']
Security,equested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooRealProxy_effRatio; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsAnaConvPdf::_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBCPEffDecay.html:42234,access,access,42234,root/html534/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html534/RooBCPEffDecay.html,1,['access'],['access']
Security,"equestedname' is expected to be already normalized. ; Definition at line 5771 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5824 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). If options contains 'streamerinfo', run ls on the list of streamerInfos and the list of conversion streamerInfos. ; Reimplemented from TObject.; Definition at line 4258 of file TClass.cxx. ◆ MakeCustomMenuList(). void TClass::MakeCustomMenuList ; (; ). Makes a customizable version of the popup menu list, i.e. ; makes a list of TClassMenuItem objects of methods accessible by context menu. The standard (and different) way consists in having just one element in this list, corresponding to the whole standard list. Once the customizable version is done, one can remove or add elements. ; Definition at line 4283 of file TClass.cxx. ◆ MatchLegacyCheckSum(). Bool_t TClass::MatchLegacyCheckSum ; (; UInt_t ; checksum); const. Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ; Definition at line 6494 of file TClass.cxx. ◆ Move(). void TClass::Move ; (; void * ; arenaFrom, . void * ; arenaTo . ); const. Register the fact that an object was moved from the memory location 'arenaFrom' to the memory location 'arenaTo'. ; Definition at line 4327 of file TClass.cxx. ◆ MoveAddressInRepository(). void TClass::MoveAddressInRepository ; (; const char * ; where, . void * ; oldadd, . void * ; newadd, . const TClass * ; what . ); const. private . Definition at line 337 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:104027,access,accessible,104027,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['access'],['accessible']
Security,"equestedname' is expected to be already normalized. ; Definition at line 5838 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5891 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). If options contains 'streamerinfo', run ls on the list of streamerInfos and the list of conversion streamerInfos. ; Reimplemented from TObject.; Definition at line 4325 of file TClass.cxx. ◆ MakeCustomMenuList(). void TClass::MakeCustomMenuList ; (; ). Makes a customizable version of the popup menu list, i.e. ; makes a list of TClassMenuItem objects of methods accessible by context menu. The standard (and different) way consists in having just one element in this list, corresponding to the whole standard list. Once the customizable version is done, one can remove or add elements. ; Definition at line 4350 of file TClass.cxx. ◆ MatchLegacyCheckSum(). Bool_t TClass::MatchLegacyCheckSum ; (; UInt_t ; checksum); const. Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ; Definition at line 6561 of file TClass.cxx. ◆ Move(). void TClass::Move ; (; void * ; arenaFrom, . void * ; arenaTo . ); const. Register the fact that an object was moved from the memory location 'arenaFrom' to the memory location 'arenaTo'. ; Definition at line 4394 of file TClass.cxx. ◆ MoveAddressInRepository(). void TClass::MoveAddressInRepository ; (; const char * ; where, . void * ; oldadd, . void * ; newadd, . const TClass * ; what . ); const. private . Definition at line 337 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:104028,access,accessible,104028,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['access'],['accessible']
Security,"equests. */; 2224 mg_websocket_connect_handler connect_handler;; 2225 mg_websocket_ready_handler ready_handler;; 2226 mg_websocket_data_handler data_handler;; 2227 mg_websocket_close_handler close_handler;; 2228 ; 2229 /* accepted subprotocols for ws/wss requests. */; 2230 struct mg_websocket_subprotocols *subprotocols;; 2231 ; 2232 /* Handler for authorization requests */; 2233 mg_authorization_handler auth_handler;; 2234 ; 2235 /* User supplied argument for the handler function. */; 2236 void *cbdata;; 2237 ; 2238 /* next handler in a linked list */; 2239 struct mg_handler_info *next;; 2240};; 2241 ; 2242 ; 2243enum {; 2244 CONTEXT_INVALID,; 2245 CONTEXT_SERVER,; 2246 CONTEXT_HTTP_CLIENT,; 2247 CONTEXT_WS_CLIENT; 2248};; 2249 ; 2250 ; 2251struct mg_domain_context {; 2252 SSL_CTX *ssl_ctx; /* SSL context */; 2253 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2254 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2255 int64_t ssl_cert_last_mtime;; 2256 ; 2257 /* Server nonce */; 2258 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2259 unsigned long nonce_count; /* Used nonces, used for authentication */; 2260 ; 2261#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2262 /* linked list of shared lua websockets */; 2263 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2264#endif; 2265 ; 2266 /* Linked list of domains */; 2267 struct mg_domain_context *next;; 2268};; 2269 ; 2270 ; 2271/* Stop flag can be ""volatile"" or require a lock.; 2272 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2273 * states a read operation for int is always atomic. */; 2274#if defined(STOP_FLAG_NEEDS_LOCK); 2275 ; 2276typedef ptrdiff_t volatile stop_flag_t;; 2277 ; 2278static int; 2279STOP_FLAG_IS_ZERO(stop_flag_t *f); 2280{; 2281 stop_flag_t sf = mg_atomic_add(f, 0);; 2282 return (sf == 0);; 2283}; 2284 ; 2285static int; 2286STOP_FLAG_IS_TWO(stop_flag_t *f); 2287{; 2288 stop_flag_t sf = mg_atomic_add(f, 0);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:69937,authenticat,authentication,69937,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['authenticat'],['authentication']
Security,"equests. */; 2225 mg_websocket_connect_handler connect_handler;; 2226 mg_websocket_ready_handler ready_handler;; 2227 mg_websocket_data_handler data_handler;; 2228 mg_websocket_close_handler close_handler;; 2229 ; 2230 /* accepted subprotocols for ws/wss requests. */; 2231 struct mg_websocket_subprotocols *subprotocols;; 2232 ; 2233 /* Handler for authorization requests */; 2234 mg_authorization_handler auth_handler;; 2235 ; 2236 /* User supplied argument for the handler function. */; 2237 void *cbdata;; 2238 ; 2239 /* next handler in a linked list */; 2240 struct mg_handler_info *next;; 2241};; 2242 ; 2243 ; 2244enum {; 2245 CONTEXT_INVALID,; 2246 CONTEXT_SERVER,; 2247 CONTEXT_HTTP_CLIENT,; 2248 CONTEXT_WS_CLIENT; 2249};; 2250 ; 2251 ; 2252struct mg_domain_context {; 2253 SSL_CTX *ssl_ctx; /* SSL context */; 2254 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2255 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2256 int64_t ssl_cert_last_mtime;; 2257 ; 2258 /* Server nonce */; 2259 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2260 unsigned long nonce_count; /* Used nonces, used for authentication */; 2261 ; 2262#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2263 /* linked list of shared lua websockets */; 2264 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2265#endif; 2266 ; 2267 /* Linked list of domains */; 2268 struct mg_domain_context *next;; 2269};; 2270 ; 2271 ; 2272/* Stop flag can be ""volatile"" or require a lock.; 2273 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2274 * states a read operation for int is always atomic. */; 2275#if defined(STOP_FLAG_NEEDS_LOCK); 2276 ; 2277typedef ptrdiff_t volatile stop_flag_t;; 2278 ; 2279static int; 2280STOP_FLAG_IS_ZERO(stop_flag_t *f); 2281{; 2282 stop_flag_t sf = mg_atomic_add(f, 0);; 2283 return (sf == 0);; 2284}; 2285 ; 2286static int; 2287STOP_FLAG_IS_TWO(stop_flag_t *f); 2288{; 2289 stop_flag_t sf = mg_atomic_add(f, 0);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:69969,authenticat,authentication,69969,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['authenticat'],['authentication']
Security,"equires, that application regularly; 482/// calls gSystem->ProcessEvents(). It happens automatically in ROOT interactive shell.; 483/// If milliSec == 0, no timer will be created.; 484/// In this case application should regularly call ProcessRequests() method.; 485///; 486/// Async timer allows to use THttpServer in applications, which does not have explicit; 487/// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; 488/// (like malloc) and can lead to dead locks, especially in multi-threaded applications.; 489 ; 490void THttpServer::SetTimer(Long_t milliSec, Bool_t mode); 491{; 492 if (fTimer) {; 493 fTimer->Stop();; 494 fTimer.reset();; 495 }; 496 if (milliSec > 0) {; 497 if (fOwnThread) {; 498 Error(""SetTimer"", ""Server runs already in special thread, therefore no any timer can be created"");; 499 } else {; 500 fTimer = std::make_unique<THttpTimer>(milliSec, mode, *this);; 501 fTimer->TurnOn();; 502 }; 503 }; 504}; 505 ; 506////////////////////////////////////////////////////////////////////////////////; 507/// Creates special thread to process all requests, directed to http server; 508///; 509/// Should be used with care - only dedicated instance of TRootSniffer is allowed; 510/// By default THttpServer allows to access global lists pointers gROOT or gFile.; 511/// To be on the safe side, all kind of such access performed from the main thread.; 512/// Therefore usage of specialized thread means that no any global pointers will; 513/// be accessible by THttpServer; 514 ; 515void THttpServer::CreateServerThread(); 516{; 517 if (fOwnThread); 518 return;; 519 ; 520 SetTimer(0);; 521 fMainThrdId = 0;; 522 fOwnThread = true;; 523 ; 524 std::thread thrd([this] {; 525 int nempty = 0;; 526 while (fOwnThread && !fTerminated) {; 527 int nprocess = ProcessRequests();; 528 if (nprocess > 0); 529 nempty = 0;; 530 else; 531 nempty++;; 532 if (nempty > 1000) {; 533 nempty = 0;; 534 std::this_thread::sleep_for(std::chrono::milliseconds(1))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:16937,access,access,16937,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['access'],['access']
Security,"er (if not already done). TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occured while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classname will be called ""nameoftree"". The generated code in classname.h includes the following:; - Identification ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:95431,access,access,95431,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['access'],['access']
Security,"er ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TDataSetManager. ◆ StreamerNVirtual(). void TDataSetManagerFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file TDataSetManagerFile.h. ◆ UpdateUsedSpace(). void TDataSetManagerFile::UpdateUsedSpace ; (; ). overrideprotectedvirtual . updates the used space maps ; Reimplemented from TDataSetManager.; Definition at line 1959 of file TDataSetManagerFile.cxx. ◆ WriteDataSet(). Int_t TDataSetManagerFile::WriteDataSet ; (; const char * ; group, . const char * ; user, . const char * ; dsName, . TFileCollection * ; dataset, . UInt_t ; option = 0, . TMD5 * ; checksum = 0 . ). Writes indicated dataset. ; If option has the bit kFileMustExist set, the file must still exist, otherwise the new dataset is not written (returns 3 in this case). If checksum is non-zero the files current checksum is checked against it, if it does not match the file is not written (the function returns 2 in this case, if the file has disappeared it is also not written (i.e. checksum implies the bit kFileMustExist set in option). Returns != 0 for success, 0 for error ; Definition at line 1394 of file TDataSetManagerFile.cxx. Member Data Documentation. ◆ fCacheUpdatePeriod. Int_t TDataSetManagerFile::fCacheUpdatePeriod. private . Definition at line 42 of file TDataSetManagerFile.h. ◆ fDataSetDir. TString TDataSetManagerFile::fDataSetDir. private . Definition at line 33 of file TDataSetManagerFile.h. ◆ fDataSetLockFile. TString TDataSetManagerFile::fDataSetLockFile. private . Definition at line 36 of file TDataSetManagerFile.h. ◆ fIsRemote. Bool_t TDataSetManagerFile::fIsRemote. private . Definition at line 39 of file TDataSetManagerFile.h. ◆ fListFile. TString TDataSetManagerFile::fListFile. private . Definition at line 38 of file TDataSetManagerFile.h. ◆ fLocalCacheDir. TString TDataSetManagerFile::fLocalCacheDir. private . Definition at line 41 of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:34640,checksum,checksum,34640,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,2,['checksum'],['checksum']
Security,"er for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  ►NDetail;  CTBranchProxyBase class for all the proxy object ;  ►CTCollectionProxyInfo;  CAddress;  CEnvironSmall helper to save proxy environment in the event of recursive calls ;  CEnvironBase;  CInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CIteratorsSmall helper to implement the function to create,access and destroy iterators ;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValueSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< bool > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t > >;  CIterators;  ►CTSchemaRuleSet;  CTMatches;  ►NExecutorUtils;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:10564,access,access,10564,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['access'],['access']
Security,"er name and passwd from the ~/.rootnetrc or ~/.netrc files. ; For more info see the version with 4 arguments. This version is maintained for backward compatability reasons. ; Definition at line 878 of file TAuthenticate.cxx. ◆ CheckNetrc() [2/2]. Bool_t TAuthenticate::CheckNetrc ; (; TString & ; user, . TString & ; passwd, . Bool_t & ; pwhash, . Bool_t ; srppwd . ). Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc files. ; First ~/.rootnetrc is tried, after that ~/.netrc. These files will only be used when their access masks are 0600. Returns kTRUE if user and passwd were found for the machine specified in the URL. If kFALSE, user and passwd are """". The boolean pwhash is set to kTRUE if the returned passwd is to be understood as password hash, i.e. if the 'password-hash' keyword is found in the 'machine' lines; not implemented for 'secure' and the .netrc file. The format of these files are:. this is a comment line; machine <machine fqdn> login <user> password <passwd> machine <machine fqdn> login <user> password-hash <passwd>; and in addition ~/.rootnetrc also supports:; secure <machine fqdn> login <user> password <passwd>; <machine fqdn> may be a domain name or contain the wild card '*'.; for the secure protocols. All lines must start in the first column. ; Definition at line 908 of file TAuthenticate.cxx. ◆ CheckProofAuth(). Bool_t TAuthenticate::CheckProofAuth ; (; Int_t ; cSec, . TString & ; det . ). static . Check if the authentication method can be attempted for the client. ; Definition at line 3541 of file TAuthenticate.cxx. ◆ Class(). static TClass * TAuthenticate::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TAuthenticate::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TAuthenticate::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 207 of file TAuthenticate.h. ◆ ClearAuth(). Int_t TAuthent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:23800,password,password,23800,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,2,['password'],"['password', 'password-hash']"
Security,er of daughters. ; Definition at line 54 of file TGeoManager.h. ◆ fgMutex. std::mutex TGeoManager::fgMutex. staticprotected . Definition at line 49 of file TGeoManager.h. ◆ fgNumThreads. Int_t TGeoManager::fgNumThreads = 0. staticprivate . Thread id's map. ; Definition at line 121 of file TGeoManager.h. ◆ fGShapes. TObjArray* TGeoManager::fGShapes. private . Definition at line 97 of file TGeoManager.h. ◆ fgThreadId. TGeoManager::ThreadsMap_t * TGeoManager::fgThreadId = nullptr. staticprivate . Map between thread id's and navigator arrays. ; Definition at line 120 of file TGeoManager.h. ◆ fgVerboseLevel. Int_t TGeoManager::fgVerboseLevel = 1. staticprotected . Lock preventing a second geometry to be loaded. ; Definition at line 51 of file TGeoManager.h. ◆ fGVolumes. TObjArray* TGeoManager::fGVolumes. private . list of runtime shapes ; Definition at line 98 of file TGeoManager.h. ◆ fHashGVolumes. THashList* TGeoManager::fHashGVolumes. private . hash list of volumes providing fast search ; Definition at line 137 of file TGeoManager.h. ◆ fHashPNE. THashList* TGeoManager::fHashPNE. private . hash list of group volumes providing fast search ; Definition at line 138 of file TGeoManager.h. ◆ fHashVolumes. THashList* TGeoManager::fHashVolumes. private . Definition at line 136 of file TGeoManager.h. ◆ fIsGeomCleaning. Bool_t TGeoManager::fIsGeomCleaning. private . flag set when reading geometry ; Definition at line 83 of file TGeoManager.h. ◆ fIsGeomReading. Bool_t TGeoManager::fIsGeomReading. private . Definition at line 82 of file TGeoManager.h. ◆ fIsNodeSelectable. Bool_t TGeoManager::fIsNodeSelectable. private . switch ON/OFF volume activity (default OFF - all volumes active)) ; Definition at line 90 of file TGeoManager.h. ◆ fKeyPNEId. Int_t* TGeoManager::fKeyPNEId. private . Definition at line 142 of file TGeoManager.h. ◆ fLoopVolumes. Bool_t TGeoManager::fLoopVolumes. private . flag that geometry is closed ; Definition at line 80 of file TGeoManager.h. ◆ fMasterVolume. T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:148705,hash,hash,148705,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['hash'],['hash']
Security,"er of signal events (used to compute significance)Definition DataLoader.cxx:402; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kFisher@ kFisherDefinition Types.h:82; TMVA::Types::kPyKeras@ kPyKerasDefinition Types.h:103; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TMVA::Types::kDL@ kDLDefinition Types.h:99; TMVA::Types::kLikelihood@ kLikelihoodDefinition Types.h:79; TMVA::Types::kMLP@ kMLPDefinition Types.h:90; TMacroClass supporting a collection of lines with C++ code.Definition TMacro.h:31; TStringBasic string class.Definition TString.h:139; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::Printvoid Print(Option_t *option="""") const overridePrint a summary of the tree contents.Definition TTree.cxx:7219; c1return c1Definition legend1.C:41; TMVA_Higgs_ClassificationDefinition TMVA_Higgs_Classification.py:1; mTMarker mDefinition textangle.C:8; AuthorLorenzo Moneta ; Definition in file TMVA_Higgs_Classification.C. tutorialstmvaTMVA_Higgs_Classification.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:72907,access,access,72907,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,2,['access'],['access']
Security,"er right one (0.5, 0.5). These coordinates are in NDC. This means that they are independent of the user coordinates system, in particular if you have already drawn for example a histogram in the mother pad. The only thing left is to draw the pad:; root[] spad1->Draw(); If you want more sub-pads, you have to repeat this procedure as many times as necessary.; 9.3.4.2 Dividing a Canvas into Sub-Pads; The manual way of dividing a pad into sub-pads is sometimes very tedious. There is a way to automatically generate horizontal and vertical sub-pads inside a given pad.; root[] pad1->Divide(3,2). Dividing a pad into 6 sub-pads. Dividing a pad into 6 sub-pads. If pad1 is a pad then, it will divide the pad into 3 columns of 2 sub-pads. The generated sub-pads get names pad1_i where the index i=1 to nxm (in our case pad1_1, pad1_2…pad1_6). The names pad1_1etc… correspond to new variables in Cling, so you may use them as soon as the executed method was pad->Divide(). However, in a compiled program, one has to access these objects. Remember that a pad contains other objects and that these objects may themselves be pads. So we can use the GetPrimitive() method:; TPad* pad1_1 = (TPad*)(pad1->GetPrimitive(""pad1_1"")); One question remains. In case one does an automatic divide, how one can set the default margins between pads? This is done by adding two parameters to Divide(), which are the margins in x and y:; root[] pad1->Divide(3,2,0.1,0.1); The margins are here set to 10% of the parent pad width.; 9.3.5 Updating the Pad; For performance reasons, a pad is not updated with every change. For example, changing the coordinates of the pad does not automatically redraw it. Instead, the pad has a “bit-modified” that triggers a redraw. This bit is automatically set by:. Touching the pad with the mouse - for example resizing it with the mouse.; Finishing the execution of a script.; Adding a new primitive or modifying some primitives for example the name and title of an object.; You can also ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:313340,access,access,313340,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"er than `\0', for example). Zero-length; strings are always identical. int CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Compare a string to another string. Returns returns zero if the two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. V.Perev. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. Bool_t MaybeRegexp() const; Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TString.html:10722,hash,hash,10722,root/html530/TString.html,https://root.cern,https://root.cern/root/html530/TString.html,2,['hash'],['hash']
Security,"er than `\0', for example). Zero-length; strings are always identical. int CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Compare a string to another string. Returns returns zero if the two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. TString MD5() const; Return the MD5 digest for this string, in a string representation. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?"". Bool_t MaybeWildcard() const; Returns true if string contains one of the wildcard c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TString.html:11401,hash,hash,11401,root/html534/TString.html,https://root.cern,https://root.cern/root/html534/TString.html,3,['hash'],['hash']
Security,"er the creation of the TBuffer, before any writing is done. Globally this option can be changed using SetGlobalWriteParam(). ; Implements TBuffer.; Definition at line 117 of file TBufferIO.cxx. ◆ Streamer(). void TBufferIO::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TBuffer.; Reimplemented in TBufferJSON, TBufferText, TBufferSQL2, TBufferXML, TMessage, and TBufferSQL. ◆ StreamerNVirtual(). void TBufferIO::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 120 of file TBufferIO.h. ◆ TagStreamerInfo(). void TBufferIO::TagStreamerInfo ; (; TVirtualStreamerInfo * ; info). overridevirtual . Mark the classindex of the current file as using this TStreamerInfo. ; Implements TBuffer.; Reimplemented in TMessage.; Definition at line 350 of file TBufferIO.cxx. ◆ Void_Hash(). static R__ALWAYS_INLINE ULong_t TBufferIO::Void_Hash ; (; const void * ; ptr). inlinestaticprotected . Return hash value for provided object. ; Definition at line 53 of file TBufferIO.h. ◆ WriteClones(). Int_t TBufferIO::WriteClones ; (; TClonesArray * ; a, . Int_t ; nobjects . ). overridevirtual . Interface to TStreamerInfo::WriteBufferClones. ; Implements TBuffer.; Definition at line 385 of file TBufferIO.cxx. ◆ WriteObject() [1/3]. template<class T > . Int_t TBuffer::WriteObject ; (; const T * ; objptr, . Bool_t ; cacheReuse = kTRUE . ). inline . Definition at line 159 of file TBuffer.h. ◆ WriteObject() [2/3]. virtual void TBuffer::WriteObject ; (; const TObject * ; obj, . Bool_t ; cacheReuse . ). virtual . Implements TBuffer. ◆ WriteObject() [3/3]. void TBufferIO::WriteObject ; (; const TObject * ; obj, . Bool_t ; cacheReuse = kTRUE . ). overridevirtual . Write object to I/O buffer. ; Implements TBuffer.; Definition at line 530 of file TBufferIO.cxx. ◆ WriteObjectAny(). Int_t TBufferIO::WriteObjectAny ; (; const void * ; obj, . const TClass * ; ptrClass, . Bool_t ; cacheReuse = kTRUE . ). overridevirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:41889,hash,hash,41889,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['hash'],['hash']
Security,"er with digest methods ;  httpcontrol.CThis program demonstrates simple application control via THttpServer Two histogram are filled within endless loop ;  httpserver.CThis program creates : ;  httptextlog.CThis macro demonstrates custom access and custom drawing for TMsgList class Main motivation for this example - demonstrate how traffic between server and client can be minimized and how one could build custom UI in the browser ;  httptextlog.js;  ► image;  galaxy_image.C Importing an image and manipulating it ;  hist2image.C Create an image from a 2-D histogram and manipulate it ;  hsumanim.C This script is a slightly modified version of hsum.C ;  image2hist.C Create a 2-D histogram from an image ;  img2pad.C Display image in canvas and pad ;  imgconv.C Open rose512.jpg and save it in the following formats: .png, .gif, .xpm and tiff ;  pad2png.C Create a canvas and save as png ;  rose_image.C Display image in a new canvas and pad ;  trans_graph.C Demonstrates how to access and manipulate ARGB pixel values of an image +.. ;  ► io;  copyFiles.C Example of script showing how to copy all objects (including directories) from a source file ;  dirs.C This macro illustrates how to create a hierarchy of directories in a Root file ;  double32.C Tutorial illustrating use and precision of the Double32_t data type You must run this tutorial with ACLIC: a dictionary will be automatically created ;  fildir.C This macro displays the ROOT Directory data structure ;  file.C This macro displays the physical ROOT file structure ;  hadd.C Macro to add histogram files This macro is kept for didactical purposes only: use instead the executable $ROOTSYS/bin/hadd ! ;  importCode.C Example of script showing how to create a ROOT file with subdirectories ;  loopdir.C Example of script to loop on all the objects of a ROOT file directory and print on Postscript all TH1 derived objects ;  mergeSelective.C Merge only part of the content of a set of files ;  readCode.C Example of script showing ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:125870,access,access,125870,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['access'],['access']
Security,"er() [2/2]. const char * TString::GetPointer ; (; ); const. inlineprivate . Definition at line 257 of file TString.h. ◆ GetResizeIncrement(). Ssiz_t TString::GetResizeIncrement ; (; ). static . Definition at line 1576 of file TString.cxx. ◆ Gets(). Bool_t TString::Gets ; (; FILE * ; fp, . Bool_t ; chop = kTRUE . ). Read one line from the stream, including the \n, or until EOF. ; Remove the trailing [\r]\n if chop is true. Returns kTRUE if data was read. ; Definition at line 204 of file Stringio.cxx. ◆ GetShortPointer() [1/2]. char * TString::GetShortPointer ; (; ). inlineprivate . Definition at line 254 of file TString.h. ◆ GetShortPointer() [2/2]. const char * TString::GetShortPointer ; (; ); const. inlineprivate . Definition at line 255 of file TString.h. ◆ GetShortSize(). Ssiz_t TString::GetShortSize ; (; ); const. inlineprivate . Definition at line 244 of file TString.h. ◆ Hash() [1/2]. UInt_t TString::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). static . Calculates hash index from any char string. ; (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/ . Definition at line 850 of file TString.cxx. ◆ Hash() [2/2]. UInt_t TString::Hash ; (; ECaseCompare ; cmp = kExact); const. Return hash value. ; Definition at line 677 of file TString.cxx. ◆ HashCase(). UInt_t TString::HashCase ; (; ); const. private . Return a case-sensitive hash value (endian independent). ; Definition at line 633 of file TString.cxx. ◆ HashFoldCase(). UInt_t TString::HashFoldCase ; (; ); const. private . Return a case-insensitive hash value (endian independent). ; Definition at line 662 of file TString.cxx. ◆ Index() [1/8]. Ssiz_t TString::Index ; (; const char * ; pat, . Ssiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTString.html:33618,hash,hash,33618,doc/v632/classTString.html,https://root.cern,https://root.cern/doc/v632/classTString.html,2,['hash'],['hash']
Security,"er). ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * Before (const TObject *obj) const override;  Returns the object before object obj. ;  ; void Clear (Option_t *option="""") override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the list AND delete all heap based objects. ;  ; TObject * FindObject (const char *name) const override;  Find an object in this list usi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorList.html:3268,access,access,3268,doc/master/classTSelectorList.html,https://root.cern,https://root.cern/doc/master/classTSelectorList.html,1,['access'],['access']
Security,"er). ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; void AddAfter (const TObject *after, TObject *obj) override;  Insert object after object after in the list. ;  ; void AddAt (TObject *obj, Int_t idx) override;  Insert object at position idx in the list. ;  ; void AddBefore (const TObject *before, TObject *obj) override;  Insert object before object before in the list. ;  ; void AddFirst (TObject *obj) override;  Add object at the beginning of the list. ;  ; void AddLast (TObject *obj) override;  Add object at the end of the list. ;  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:3598,access,access,3598,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['access'],['access']
Security,"er). Long64_t GetTotBytes(Option_t* option = """") const; Return total number of bytes in the branch (excluding current buffer); if option =""*"" includes all sub-branches of this branch too. Long64_t GetZipBytes(Option_t* option = """") const; Return total number of zip bytes in the branch; if option =""*"" includes all sub-branches of this branch too. Bool_t IsAutoDelete() const; Return kTRUE if an existing object in a TBranchObject must be deleted. Bool_t IsFolder() const; Return kTRUE if more than one leaf or browsables, kFALSE otherwise. void KeepCircular(Long64_t maxEntries); keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(); Baskets associated to this branch are forced to be in memory.; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; the system that the total size of the imported baskets does not; exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory.; This method may be called to force all baskets of one or more branches; in memory when random access to entries in this branch is required.; See also TTree::LoadBaskets to load all baskets of all branches in memory. void Print(Option_t* option = """") const; Print TBranch parameters. void ReadBasket(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void Refresh(TBranch* b); refresh this branch using new information in b; This function is called by TTree::Refresh. void Reset(Option_t* option = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the address of the branch. void ResetCount(); Static function resetting fgCount. void SetAddress(void* add); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the automatic delete bit. This bit is used by TBranchObject::ReadBasket to decide if an object; referenced by a TBranchObject must be deleted or not before reading; a new ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranch.html:21059,access,access,21059,root/html526/TBranch.html,https://root.cern,https://root.cern/root/html526/TBranch.html,1,['access'],['access']
Security,"er). Long64_t GetTotBytes(Option_t* option = """") const; Return total number of bytes in the branch (excluding current buffer); if option =""*"" includes all sub-branches of this branch too. Long64_t GetZipBytes(Option_t* option = """") const; Return total number of zip bytes in the branch; if option =""*"" includes all sub-branches of this branch too. Bool_t IsAutoDelete() const; Return kTRUE if an existing object in a TBranchObject must be deleted. Bool_t IsFolder() const; Return kTRUE if more than one leaf or browsables, kFALSE otherwise. void KeepCircular(Long64_t maxEntries); keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(); Baskets associated to this branch are forced to be in memory.; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; the system that the total size of the imported baskets does not; exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory.; This method may be called to force all baskets of one or more branches; in memory when random access to entries in this branch is required.; See also TTree::LoadBaskets to load all baskets of all branches in memory. void Print(Option_t* option = """") const; Print TBranch parameters. void ReadBasket(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeavesImpl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves0Impl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves1Impl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves2Impl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void Refresh(TBranch* b); refresh this branch using new information in b; This function is called by TTree::Refresh. void Reset(Option_t* option = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the address of the branch. void ResetCount(); Static function resetting fgCount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBranch.html:24162,access,access,24162,root/html530/TBranch.html,https://root.cern,https://root.cern/root/html530/TBranch.html,1,['access'],['access']
Security,"er). Long64_t GetTotBytes(Option_t* option = """") const; Return total number of bytes in the branch (excluding current buffer); if option =""*"" includes all sub-branches of this branch too. Long64_t GetZipBytes(Option_t* option = """") const; Return total number of zip bytes in the branch; if option =""*"" includes all sub-branches of this branch too. Bool_t IsAutoDelete() const; Return kTRUE if an existing object in a TBranchObject must be deleted. Bool_t IsFolder() const; Return kTRUE if more than one leaf or browsables, kFALSE otherwise. void KeepCircular(Long64_t maxEntries); keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(); Baskets associated to this branch are forced to be in memory.; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; the system that the total size of the imported baskets does not; exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory.; This method may be called to force all baskets of one or more branches; in memory when random access to entries in this branch is required.; See also TTree::LoadBaskets to load all baskets of all branches in memory. void Print(Option_t* option = """") const; Print TBranch parameters. void ReadBasket(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeavesImpl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves0Impl(TBuffer& b); Read zero leaves without the overhead of a loop. void ReadLeaves1Impl(TBuffer& b); Read one leaf without the overhead of a loop. void ReadLeaves2Impl(TBuffer& b); Read two leaves without the overhead of a loop. void FillLeavesImpl(TBuffer& b); Loop on all leaves of this branch to fill Basket buffer. void Refresh(TBranch* b); refresh this branch using new information in b; This function is called by TTree::Refresh. void Reset(Option_t* option = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Rese",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranch.html:21840,access,access,21840,root/html532/TBranch.html,https://root.cern,https://root.cern/root/html532/TBranch.html,4,['access'],['access']
Security,"er). Long64_t GetTotBytes(Option_t* option = """") const; Return total number of bytes in the branch (excluding current buffer); if option =""*"" includes all sub-branches of this branch too. Long64_t GetZipBytes(Option_t* option = """") const; Return total number of zip bytes in the branch; if option =""*"" includes all sub-branches of this branch too. Bool_t IsAutoDelete() const; Return kTRUE if an existing object in a TBranchObject must be deleted. Bool_t IsFolder() const; Return kTRUE if more than one leaf or browsables, kFALSE otherwise. void KeepCircular(Long64_t maxEntries); keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(); Baskets associated to this branch are forced to be in memory.; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; the system that the total size of the imported baskets does not; exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory.; This method may be called to force all baskets of one or more branches; in memory when random access to entries in this branch is required.; See also TTree::LoadBaskets to load all baskets of all branches in memory. void Print(Option_t* option = """") const; Print TBranch parameters. void ReadBasket(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeavesImpl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void Refresh(TBranch* b); refresh this branch using new information in b; This function is called by TTree::Refresh. void Reset(Option_t* option = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the address of the branch. void ResetCount(); Static function resetting fgCount. void SetAddress(void* add); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the automatic delete bit. This bit is used by TBranchObject::ReadBasket to decide if an object; referenced by a TBranchObject must be deleted or not before reading; a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranch.html:22056,access,access,22056,root/html528/TBranch.html,https://root.cern,https://root.cern/root/html528/TBranch.html,1,['access'],['access']
Security,"er, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or contains 'U',; in which case 'newDataSet' is added to the existing dataset (duplications are; ignored, if any).; If 'opts' contains 'V' the dataset files are also verified (if the dataset manager; is configured to allow so). By default the dataset is not verified.; If 'opts' contains 'T' the in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:17263,checksum,checksum,17263,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,12,['checksum'],['checksum']
Security,"er. It keeps track of which columns have been defined, varied or aliased at each point of the computation graph. In many cases, the contents of the different column register instances are the same or only differ by a single extra defined/varied/aliased column. For this reason, in order to avoid unnecessary data duplication, fDefines, fAliases, fVariations and fColumnNames are all shared_ptr<const T> that (whenever possible) are shared across RColumnRegister instances that are part of the same computation graph. If a new column, alias or variation is added between one node and the next, then the new node contains a new instance of a RColumnRegister that shares all data members with the previous instance except for the one data member that needed updating, which is replaced with a new updated instance.; The contents of the collections that keep track of other objects of the computation graph are not owned by the RColumnRegister object. They are registered centrally by the RLoopManager and only accessed via reference in the RColumnRegister. ; Definition at line 68 of file RColumnRegister.hxx. Public Member Functions;  RColumnRegister (ROOT::Detail::RDF::RLoopManager *lm);  ; void AddAlias (std::string_view alias, std::string_view colName);  Add a new alias to the ledger. ;  ; void AddDefine (std::shared_ptr< RDFDetail::RDefineBase > column);  Add a new defined column. ;  ; void AddVariation (std::shared_ptr< RVariationBase > variation);  Register a new systematic variation. ;  ; std::vector< std::string_view > BuildDefineNames () const;  Return the list of the names of defined columns (no aliases). ;  ; ROOT::RDF::RVariationsDescription BuildVariationsDescription () const;  ; std::vector< std::string_view > GenerateColumnNames () const;  Return the list of the names of the defined columns (Defines + Aliases). ;  ; RDFDetail::RDefineBase * GetDefine (std::string_view colName) const;  Return the RDefine for the requested column name, or nullptr. ;  ; RDFDetail::RColumnRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html:1592,access,accessed,1592,doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,1,['access'],['accessed']
Security,"er.h. ◆ fDefaultPageCont. std::string THttpServer::fDefaultPageCont. protected . ! content of default html page ; Definition at line 51 of file THttpServer.h. ◆ fDrawPage. std::string THttpServer::fDrawPage. protected . ! file name for drawing of single element ; Definition at line 52 of file THttpServer.h. ◆ fDrawPageCont. std::string THttpServer::fDrawPageCont. protected . ! content of draw html page ; Definition at line 53 of file THttpServer.h. ◆ fEngines. TList THttpServer::fEngines. protected . ! engines which runs http server ; Definition at line 34 of file THttpServer.h. ◆ fJSROOT. TString THttpServer::fJSROOT. protected . ! location of external JSROOT files ; Definition at line 46 of file THttpServer.h. ◆ fJSROOTSYS. TString THttpServer::fJSROOTSYS. protected . ! location of local JSROOT files ; Definition at line 44 of file THttpServer.h. ◆ fLocations. std::map<std::string, std::string> THttpServer::fLocations. protected . ! list of local directories, which could be accessed via server ; Definition at line 48 of file THttpServer.h. ◆ fMainThrdId. Long_t THttpServer::fMainThrdId {0}. protected . ! id of the thread for processing requests ; Definition at line 38 of file THttpServer.h. ◆ fMutex. std::mutex THttpServer::fMutex. protected . ! mutex to protect list with arguments ; Definition at line 57 of file THttpServer.h. ◆ fOwnThread. Bool_t THttpServer::fOwnThread {kFALSE}. protected . ! true when specialized thread allocated for processing requests ; Definition at line 40 of file THttpServer.h. ◆ fProcessingThrdId. Long_t THttpServer::fProcessingThrdId {0}. protected . ! id of the thread where events are recently processing ; Definition at line 39 of file THttpServer.h. ◆ fSniffer. std::unique_ptr<TRootSniffer> THttpServer::fSniffer. protected . ! sniffer provides access to ROOT objects hierarchy ; Definition at line 36 of file THttpServer.h. ◆ fTerminated. Bool_t THttpServer::fTerminated {kFALSE}. protected . ! termination flag, disables all requests proc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:40952,access,accessed,40952,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['access'],['accessed']
Security,"er::GetVScrollbar ; (; ); const. virtual . returns pointer to vert. scroll bar ; Reimplemented in TGLBContainer.; Definition at line 1753 of file TGCanvas.cxx. ◆ HandleButton(). Bool_t TGContainer::HandleButton ; (; Event_t * ; event). overridevirtual . Handle mouse button event in container. ; Reimplemented from TGCompositeFrame.; Reimplemented in TGLBContainer, TGListTree, TGLVContainer, and TTVLVContainer.; Definition at line 929 of file TGCanvas.cxx. ◆ HandleDNDFinished(). Bool_t TGContainer::HandleDNDFinished ; (; ). inlineoverridevirtual . Reimplemented from TGFrame.; Definition at line 130 of file TGCanvas.h. ◆ HandleDoubleClick(). Bool_t TGContainer::HandleDoubleClick ; (; Event_t * ; event). overridevirtual . Handle double click mouse event. ; Reimplemented from TGCompositeFrame.; Reimplemented in TGLBContainer, and TGListTree.; Definition at line 1098 of file TGCanvas.cxx. ◆ HandleExpose(). Bool_t TGContainer::HandleExpose ; (; Event_t * ; event). overridevirtual . Handle expose events. Do not use double buffer. ; Reimplemented from TGWindow.; Definition at line 903 of file TGCanvas.cxx. ◆ HandleKey(). Bool_t TGContainer::HandleKey ; (; Event_t * ; event). overridevirtual . The key press event handler converts a key press to some line editor action. ; Reimplemented from TGCompositeFrame.; Reimplemented in TGListTree.; Definition at line 1278 of file TGCanvas.cxx. ◆ HandleMotion(). Bool_t TGContainer::HandleMotion ; (; Event_t * ; event). overridevirtual . Handle mouse motion events. ; Reimplemented from TGCompositeFrame.; Reimplemented in TGLBContainer, TGListTree, and TTVLVContainer.; Definition at line 1141 of file TGCanvas.cxx. ◆ Home(). void TGContainer::Home ; (; Bool_t ; select = kFALSE). virtual . Move to upper-left corner of container. ; Reimplemented in TGListTree.; Definition at line 2071 of file TGCanvas.cxx. ◆ InvertSelection(). void TGContainer::InvertSelection ; (; ). virtual . Invert the selection, all selected items become unselected and vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGContainer.html:46286,expose,expose,46286,doc/master/classTGContainer.html,https://root.cern,https://root.cern/doc/master/classTGContainer.html,1,['expose'],['expose']
Security,"er::Tolerance() const; virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. boolExamineMinimum(const ROOT::Minuit2::FunctionMinimum& min); virtual const ROOT::Minuit2::FCNBase*GetFCN() const; virtual const ROOT::Minuit2::ModularFunctionMinimizer*GetMinimizer() const; virtual voidSetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); voidSetMinimizerType(ROOT::Minuit2::EMinimizerType type). private:. ROOT::Minuit2::Minuit2MinimizerMinuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer&); ROOT::Minuit2::Minuit2Minimizer&operator=(const ROOT::Minuit2::Minuit2Minimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDim; intfErrorCode; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char * type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const Minuit2Minimizer &); usually copying is non trivial, so we make this unaccessibl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html:4702,validat,validated,4702,root/html526/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html,1,['validat'],['validated']
Security,er::Tolerance() const; virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. boolExamineMinimum(const ROOT::Minuit2::FunctionMinimum& min); virtual const ROOT::Minuit2::FCNBase*GetFCN() const; virtual const ROOT::Minuit2::ModularFunctionMinimizer*GetMinimizer() const; virtual voidSetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); voidSetMinimizerType(ROOT::Minuit2::EMinimizerType type). private:. ROOT::Minuit2::Minuit2MinimizerMinuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer&); ROOT::Minuit2::Minuit2Minimizer&operator=(const ROOT::Minuit2::Minuit2Minimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDimdimension of the function to be minimized ; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char* type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer& ); usually copying is,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Minuit2__Minuit2Minimizer.html:4679,validat,validated,4679,root/html528/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html528/ROOT__Minuit2__Minuit2Minimizer.html,3,['validat'],['validated']
Security,"erInfo, return the actual type of the object (i.e. ; the type described by this streamerInfo is a base class of the actual type of the object. This routine should only be called if the class described by this StreamerInfo is 'emulated'. ; Implements TVirtualStreamerInfo.; Definition at line 3255 of file TStreamerInfo.cxx. ◆ GetCheckSum() [1/2]. UInt_t TStreamerInfo::GetCheckSum ; (; ); const. inlineoverridevirtual . Implements TVirtualStreamerInfo.; Definition at line 159 of file TStreamerInfo.h. ◆ GetCheckSum() [2/2]. UInt_t TStreamerInfo::GetCheckSum ; (; TClass::ECheckSum ; code); const. Recalculate the checksum of this TStreamerInfo based on its code. ; The class ckecksum is used by the automatic schema evolution algorithm to uniquely identify a class version. The check sum is built from the names/types of base classes and data members. The valid range of code is determined by ECheckSum.; kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. . WARNING; This function must be kept in sync with TClass::GetCheckSum. They are both used to handle backward compatibility and should both return the same values. TStreamerInfo uses the information in TStreamerElement while TClass uses the information from TClass::GetListOfBases and TClass::GetListOfDataMembers. Original algorithm from Victor Perevovchikov (perev.nosp@m.@bnl.nosp@m..gov). ; Definition at line 3298 of file TStreamerInfo.cxx. ◆ GetClass(). TClass * TStreamerInfo::GetClass ; (; ); const. inlineoverridevirtual . Implements TVirtualStreamerInfo.; Definition at line 158 of file TStreamerInfo.h. ◆ GetClassVersion(). Int_t TStreamerInfo::GetClassVersion ; (; ); const. inlineoverridevirtual . Implements TVirtualStreamerInfo.; Definition at line 161 of file TStreamerInfo.h. ◆ GetC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:45076,checksum,checksum,45076,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,2,['checksum'],['checksum']
Security,"erNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static void AuthError (const char *where, Int_t error);  Print error string depending on error code. ;  ; static Bool_t CheckProofAuth (Int_t cSec, TString &det);  Check if the authentication method can be attempted for the client. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t DecodeRSAPublic (const char *rsapubexport, R__rsa_NUMBER &n, R__rsa_NUMBER &d, char **rsassl=nullptr);  Store RSA public keys from export string rsaPubExport. ;  ; static TList * GetAuthInfo ();  Static method returning the list with authentication details. ;  ; static const char * GetAuthMethod (Int_t idx);  Static method returning the method corresponding to idx. ;  ; static Int_t GetAuthMethodIdx (const char *meth);  Static method returning the method index (which can be used to find the method in GetAuthMethod()). ;  ; static Bool_t GetAuthReUse ();  Static method returning the authentication reuse settings. ;  ; static Int_t GetClientProtocol ();  Static method returning supported client protocol. ;  ; static char * GetDefaultDetails (Int_t metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:10365,authenticat,authentication,10365,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"erOfEvents; // Total number of events. EventSelector(TTree * = 0): fNumberOfEvents(0) { }; virtual ~EventSelector() { }. virtual void Init(TTree *tree);; ... The code : fNumberOfEvents(0) after the constructor is another way of initializing a data member. Then we have to count the total number of entries (events in our case) in the tree. This has to be done in TSelector::Process(Long64_t entry). We will print also the current entry number, to see what's happening:; Bool_t EventSelector::Process(Long64_t entry); {; // ... // print some information about the current entry; printf(""Processing Entry number %ld\n"", entry);; // increase the total number of entries; ++fNumberOfEvents;. return kTRUE;; }. And finally, at the end of the process, in TSelector::Terminate(), print the total number of entries:; void EventSelector::Terminate(); {; // ... // print the result; printf(""\nTotal Number of Events: %d\n"", fNumberOfEvents);; }. As you can see, the fNumberOfEvents member is accessed in Process() and Terminate(), hence the reason of making it a data member.; More Complex Task; We want to calculate the sum of all event sizes. For this we need a new data member of type int. Create it - like the other data members in the class declaration. Don't forget to initialize it to 0 in the constructor. You also have to declare the reader variables used to access the tree's data. At the end, the code in EventSelector.h should look like this:; class EventSelector : public TSelector {; public :; Int_t fTotalDataSize; // Sum of data size (in bytes) of all events. // Variables used to access and store the data; TTreeReader fReader; // The tree reader ; TTreeReaderValue<Int_t> fCurrentEventSize; // Size of the current event. EventSelector(TTree * = 0):; fTotalDataSize(0),; fCurrentEventSize(fReader, ""fEventSize"") { }; virtual ~EventSelector() { }. virtual void Init(TTree *tree);; ... Connecting a Tree Branch with the Data Member; As already explained in the Using a Macro to Read a TTree tuto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tselector.html:4884,access,accessed,4884,d/accessing-ttree-tselector.html,https://root.cern,https://root.cern/d/accessing-ttree-tselector.html,1,['access'],['accessed']
Security,"erSize (std::size_t val);  ; void SetCompression (int val);  ; void SetCompression (RCompressionSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; void SetEnablePageChecksums (bool val);  Note that turning off page checksums will also turn off the same page merging optimization (see tuning.md) ;  ; void SetInitialNElementsPerPage (std::size_t val);  ; void SetMaxUnzippedClusterSize (std::size_t val);  ; void SetMaxUnzippedPageSize (std::size_t val);  ; void SetPageBufferBudget (std::size_t val);  ; void SetUseBufferedWrite (bool val);  ; void SetUseDirectIO (bool val);  ; void SetUseImplicitMT (EImplicitMT val);  ; void SetWriteBufferSize (std::size_t val);  . Static Public Attributes; static constexpr std::uint64_t kDefaultMaxKeySize = 0x4000'0000;  . Protected Attributes; std::size_t fApproxZippedClusterSize = 100 * 1000 * 1000;  Approximation of the target compressed cluster size. ;  ; int fCompression {RCompressionSetting::EDefaults::kUseGeneralPurpose};  ; bool fEnablePageChecksums = true;  If set, checksums will be calculated and written for every page. ;  ; std::size_t fInitialNElementsPerPage = 64;  Initially, columns start with a page large enough to hold the given number of elements. ;  ; std::uint64_t fMaxKeySize = kDefaultMaxKeySize;  Specifies the max size of a payload storeable into a single TKey. ;  ; std::size_t fMaxUnzippedClusterSize = 1024 * 1024 * 1024;  Memory limit for committing a cluster: with very high compression ratio, we need a limit on how large the I/O buffer can grow during writing. ;  ; std::size_t fMaxUnzippedPageSize = 1024 * 1024;  Pages can grow only to the given limit in bytes. ;  ; std::size_t fPageBufferBudget = 0;  The maximum size that the sum of all page buffers used for writing into a persistent sink are allowed to use. ;  ; bool fUseBufferedWrite = true;  Whether to use buffered writing (with RPageSinkBuf). ;  ; bool fUseDirectIO = false;  Whether to use Direct I/O for writing. ;  ; EImplicitMT fUseImplicitMT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html:2311,checksum,checksums,2311,doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,1,['checksum'],['checksums']
Security,"erState& operator=(const ROOT::Minuit2::MnUserParameterState& state). const MnGlobalCorrelationCoeff& GlobalCC() const; {return fGlobalCC;}. MnUserCovariance Hessian() const; hessian (inverse of covariance matrix). const std::vector<double>& IntParameters() const; Minuit internal representation. {return fIntParameters;}. const MnUserCovariance& IntCovariance() const; {return fIntCovariance;}. const MnUserTransformation& Trafo() const; transformation internal <-> external. {return fParameters.Trafo();}. bool IsValid() const; {return fValid;}. bool HasCovariance() const; {return fCovarianceValid;}. bool HasGlobalCC() const; {return fGCCValid;}. double Fval() const; {return fFVal;}. double Edm() const; {return fEDM;}. unsigned int NFcn() const; {return fNFcn;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation ; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const string& name, double val, double err); add free Parameter. void Add(const string& name, double val, double err, double , double ); add limited Parameter. void Add(const string& , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& , double ). void SetError(const string& , double ). void SetLimits(const string& , double , double ). void SetUpperLimit(const string& , double ). void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Minuit2__MnUserParameterState.html:5788,access,access,5788,root/html530/ROOT__Minuit2__MnUserParameterState.html,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnUserParameterState.html,1,['access'],['access']
Security,"erTPad * fMother! pointer to mother of the listDefinition TPad.h:105; TPad::SetThetavoid SetTheta(Double_t theta=30) overrideDefinition TPad.h:359; TPad::GetNameconst char * GetName() const overrideReturns name of object.Definition TPad.h:260; TPad::XtoAbsPixelInt_t XtoAbsPixel(Double_t x) const overrideConvert X coordinate to absolute pixel.Definition TPad.cxx:7475; TPad::fGridyBool_t fGridySet to true if grid along Y.Definition TPad.h:101; TPad::SetBBoxY2void SetBBoxY2(const Int_t y) overrideSet bottom of BoundingBox to a value (resize in y direction on bottom)Definition TPad.cxx:7358; TPad::XtoPadDouble_t XtoPad(Double_t x) const overrideConvert x from X to pad.Definition TPad.cxx:3560; TPointDefinition TPoint.h:31; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TViewSee TView3D.Definition TView.h:25; TVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/TCanvas.Definition TVirtualPadPainter.h:19; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualViewer3DAbstract 3D shapes viewer.Definition TVirtualViewer3D.h:34; TWebCanvasBasic TCanvasImp ABI implementation for Web-based Graphics Provides painting of main ROOT classes in ...Definition TWebCanvas.h:35; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; v2@ v2Definition rootcling_impl.cxx:3702; v@ vDefinition rootcling_impl.cxx:3699; v1@ v1Definition rootcling_impl.cxx:3701; Rectangle_tRectangle structure (maps to the X11 XRectangle structure)Definition GuiTypes.h:361; Drawth1 Draw(). graf2dgpadincTPad.h. ROOT master - Reference Guide Generated on Tue Nov 5 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8h_source.html:65534,hash,hash,65534,doc/master/TPad_8h_source.html,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html,1,['hash'],['hash']
Security,"erTargets*/ ); 117{; 118 if (type == Types::kClassification && numberClasses == 2 ) return kTRUE;; 119 if (type == Types::kMulticlass ) return kTRUE;; 120 if (type == Types::kRegression ) return kTRUE;; 121 ; 122 return kFALSE;; 123}; 124 ; 125////////////////////////////////////////////////////////////////////////////////; 126/// default initializations; 127 ; 128void TMVA::MethodDNN::Init() {; 129 Log() << kWARNING; 130 << ""MethodDNN is deprecated and it will be removed in future ROOT version. ""; 131 ""Please use MethodDL ( TMVA::kDL)""; 132 << Endl;; 133 ; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Options to be set in the option string:; 138///; 139/// - LearningRate <float> DNN learning rate parameter.; 140/// - DecayRate <float> Decay rate for learning parameter.; 141/// - TestRate <int> Period of validation set error computation.; 142/// - BatchSize <int> Number of event per batch.; 143///; 144/// - ValidationSize <string> How many events to use for validation. ""0.2""; 145/// or ""20%"" indicates that a fifth of the; 146/// training data should be used. ""100""; 147/// indicates that 100 events should be used.; 148 ; 149void TMVA::MethodDNN::DeclareOptions(); 150{; 151 ; 152 DeclareOptionRef(fLayoutString=""SOFTSIGN|(N+100)*2,LINEAR"",; 153 ""Layout"",; 154 ""Layout of the network."");; 155 ; 156 DeclareOptionRef(fValidationSize = ""20%"", ""ValidationSize"",; 157 ""Part of the training data to use for ""; 158 ""validation. Specify as 0.2 or 20% to use a ""; 159 ""fifth of the data set as validation set. ""; 160 ""Specify as 100 to use exactly 100 events. ""; 161 ""(Default: 20%)"");; 162 ; 163 DeclareOptionRef(fErrorStrategy=""CROSSENTROPY"",; 164 ""ErrorStrategy"",; 165 ""Loss function: Mean squared error (regression)""; 166 "" or cross entropy (binary classification)."");; 167 AddPreDefVal(TString(""CROSSENTROPY""));; 168 AddPreDefVal(TString(""SUMOFSQUARES""));; 169 AddPreDefVal(TString(""MUTUALEXCLUSIVE""));; 170 ; 171 DeclareOptionRef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:4997,validat,validation,4997,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['validat'],['validation']
Security,"erations. They take as input argument the name of a column of the dataset to watch for missing values. Like Filter, they will either keep or discard an entire entry based on whether a condition returns true or false. Specifically:. FilterAvailable: the condition is whether the value of the column is present. If so, the entry is kept. Otherwise if the value is missing the entry is discarded.; FilterMissing: the condition is whether the value of the column is missing. If so, the entry is kept. Otherwise if the value is present the entry is discarded. df = ROOT.RDataFrame(dataset); ; # Anytime an entry from ""col"" is missing, the entire entry will be filtered out; df_available = df.FilterAvailable(""col""); df_available = df_available.Define(""twice"", ""col * 2""); ; # Conversely, if we want to select the entries for which the column has missing; # values, we do the following; df_missingcol = df.FilterMissing(""col""); # Following operations in the same branch of the computation graph clearly; # cannot access that same column, since there would be no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); ROOT::RDataFrame df{dataset};; ; // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");; ; // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; DefaultValueFor; DefaultValueFor creates a node of the computation graph which just forwards the values of the columns necessary for other downstream nodes, when they are available. In case a value of the input column passed to this function is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:83139,access,access,83139,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['access'],['access']
Security,"erator>; 148 KahanSum(Iterator sumBegin, Iterator sumEnd, Iterator carryBegin, Iterator carryEnd) {; 149 assert(std::distance(sumBegin, sumEnd) == N);; 150 assert(std::distance(carryBegin, carryEnd) == N);; 151 std::copy(sumBegin, sumEnd, std::begin(fSum));; 152 std::copy(carryBegin, carryEnd, std::begin(fCarry));; 153 }; 154 ; 155 /// Constructor to create a KahanSum from another KahanSum with a different number of accumulators; 156 template <unsigned int M>; 157 KahanSum(KahanSum<T,M> const& other) {; 158 fSum[0] = other.Sum();; 159 fCarry[0] = other.Carry();; 160 std::fill(std::begin(fSum)+1, std::end(fSum), 0.);; 161 std::fill(std::begin(fCarry)+1, std::end(fCarry), 0.);; 162 }; 163 ; 164 /// Single-element accumulation. Will not vectorise.; 165 void Add(T x) {; 166 auto y = x - fCarry[0];; 167 auto t = fSum[0] + y;; 168 fCarry[0] = (t - fSum[0]) - y;; 169 fSum[0] = t;; 170 }; 171 ; 172 ; 173 /// Accumulate from a range denoted by iterators.; 174 ///; 175 /// This function will auto-vectorise with random-access iterators.; 176 /// \param[in] begin Beginning of a range. Needs to be a random access iterator for automatic; 177 /// vectorisation, because a contiguous block of memory needs to be read.; 178 /// \param[in] end End of the range.; 179 template <class Iterator>; 180 void Add(Iterator begin, Iterator end) {; 181 static_assert(std::is_floating_point<; 182 typename std::remove_reference<decltype(*begin)>::type>::value,; 183 ""Iterator needs to point to floating-point values."");; 184 const std::size_t n = std::distance(begin, end);; 185 ; 186 for (std::size_t i=0; i<n; ++i) {; 187 AddIndexed(*(begin++), i);; 188 }; 189 }; 190 ; 191 ; 192 /// Fill from a container that supports index access.; 193 /// \param[in] inputs Container with index access such as std::vector or array.; 194 template<class Container_t>; 195 void Add(const Container_t& inputs) {; 196 static_assert(std::is_floating_point<typename Container_t::value_type>::value,; 197 ""Container does not hold",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:6862,access,access,6862,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,1,['access'],['access']
Security,"erators defining the beginning and end of an array of four Scalars, to be treated as the x, y, and z components of a unit axis vector, and the angle of rotation. ; Precondition: The first three components are assumed to represent the rotation axis vector and the 4-th the rotation angle. The angle is assumed to be in the range (-pi,pi]. The axis vector is automatically normalized to be a unit vector ; Definition at line 78 of file AxisAngle.h. ◆ AxisAngle() [4/4]. template<class OtherRotation > . constexpr ROOT::Math::AxisAngle::AxisAngle ; (; const OtherRotation & ; r). inlineexplicitconstexpr . Construct from another supported rotation type (see gv_detail::convert ) ; Definition at line 94 of file AxisAngle.h. Member Function Documentation. ◆ Angle(). Scalar ROOT::Math::AxisAngle::Angle ; (; ); const. inline . access to rotation angle ; Definition at line 183 of file AxisAngle.h. ◆ Axis(). AxisVector ROOT::Math::AxisAngle::Axis ; (; ); const. inline . access to rotation axis ; Definition at line 178 of file AxisAngle.h. ◆ Distance(). template<class R > . Scalar ROOT::Math::AxisAngle::Distance ; (; const R & ; r); const. inline . Distance between two rotations. ; Definition at line 288 of file AxisAngle.h. ◆ GetComponents() [1/3]. template<class AnyVector > . void ROOT::Math::AxisAngle::GetComponents ; (; AnyVector & ; axis, . Scalar & ; angle . ); const. inline . Set components into a non-zero vector (x,y,z) and an angle. ; The vector is intended to be a cartesian displacement vector but any vector class assignable from one will work. ; Definition at line 170 of file AxisAngle.h. ◆ GetComponents() [2/3]. template<class IT > . void ROOT::Math::AxisAngle::GetComponents ; (; IT ; begin); const. inline . Get the axis and then the angle into data specified by an iterator begin. ; Definition at line 145 of file AxisAngle.h. ◆ GetComponents() [3/3]. template<class IT > . void ROOT::Math::AxisAngle::GetComponents ; (; IT ; begin, . IT ; end . ); const. inline . Get the axi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1AxisAngle.html:7038,access,access,7038,doc/master/classROOT_1_1Math_1_1AxisAngle.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1AxisAngle.html,1,['access'],['access']
Security,"eredmultiset; , kUnorderedMap = ROOT::kSTLunorderedmap; , ;   kUnorderedMultimap = ROOT::kSTLunorderedmultimap; , kBitset = ROOT::kSTLbitset. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  ;  Protected Member Functions inherited from TClass; TVirtualStreamerInfo * FindStreamerInfo (TObjArray *arr, UInt_t checksum) const;  Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ;  ; void GetMissingDictionariesForBaseClasses (TCollection &result, TCollection &visited, bool recurse);  Verify the base classes always. ;  ; void GetMissingDictionariesForMembers (TCollection &result, TCollection &visited, bool recurse);  Verify the Data Members. ;  ; void GetMissingDictionariesForPairElements (TCollection &result, TCollection &visited, bool recurse);  ; void GetMissingDictionariesWithRecursionCheck (TCollection &result, TCollection &visited, bool recurse);  From the second level of recursion onwards it is different state check. ;  ;  Protected Member Functions inherited from TDictionary; Bool_t UpdateInterpreterStateMarker ();  the Cling ID of the transaction that last updated the object ;  ;  Protected Member Functions inherited from TObject; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQClass.html:39325,checksum,checksum,39325,doc/master/classTQClass.html,https://root.cern,https://root.cern/doc/master/classTQClass.html,2,['checksum'],['checksum']
Security,"erence of obj, in case obj; contains (via via) a pointer to itself. In that case offset must be 1; (default value for offset). void SetReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:40181,hash,hashtable,40181,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,7,['hash'],['hashtable']
Security,"erical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:56640,checksum,checksum,56640,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,8,['checksum'],['checksum']
Security,"erical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; Compute and/or return the class check sum.; The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the informat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:43179,checksum,checksum,43179,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,4,['checksum'],['checksum']
Security,"eriment (e.g. the combined ntuple in ATLAS). The following example code outlines the main steps (you can run it on the result of the tree1.C macro):; from ROOT import TFile. # open the file; myfile = TFile('tree1.root'). # retrieve the ntuple of interest; mychain = myfile.Get('t1'); entries = mychain.GetEntriesFast(). for jentry in xrange(entries):; # get the next tree in the chain and verify; ientry = mychain.LoadTree(jentry); if ientry < 0:; break. # copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; continue. # use the values directly from the tree; nEvent = int(mychain.ev); if nEvent<0:; continue. print(mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py); Access to arrays works the same way as access to single value tree elements, where the size of the array is determined by the number of values actually read from the file. For example:; # loop over array tree element; for d in mychain.mydoubles:; print(d). # direct access into an array tree element; i5 = mychain.myints[5]; 19.1.9.2 Writing a Tree; Writing a ROOT TTree in a Python session is a little convoluted, if only because you will need a C++ class to make sure that data members can be mapped, unless you are working with built-in types. Here is an example for working with the latter only:; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); The use of arrays is needed, because the pointer to the address of the object that is used for filling must be given to the TTree::Branch() call, even though the formal argument is declared a ’void*'. In the case of ROOT objects, similar pointer manipulation is unnecessary, because ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1070129,access,access,1070129,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"eritance); by many other classes (graphics, histograms). It holds all the markers; attributes.; Marker attributes; The marker attributes are:. Marker color.; Marker style.; Marker size. Marker color; The marker color is a color index (integer) pointing in the ROOT color; table.; The marker color of any class inheriting from TAttMarker can ; be changed using the method SetMarkerColor and retrieved using the ; method GetMarkerColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Marker style; The Marker style defines the markers' shape.; The marker style of any class inheriting from TAttMarker can ; be changed using the method SetMarkerStyle and retrieved using the ; method GetMarkerStyle.; The following list gives the currently supported markers (screen ; and PostScript) style. Each marker style is identified by an integer number ; (first column) corresponding to a marker shape (second column) and can be also; accessed via a global name (third column). Marker number Marker shape Marker name; 1 dot kDot; 2 + kPlus; 3 * kStar; 4 o kCircle; 5 x kMultiply; 6 small dot kFullDotSmall; 7 medium dot kFullDotMedium; 8 large scalable dot kFullDotLarge; 9 -->19 dot; 20 full circle kFullCircle; 21 full square kFullSquare; 22 full triangle up kFullTriangleUp; 23 full triangle down kFullTriangleDown; 24 open circle kOpenCircle; 25 open square kOpenSquare; 26 open triangle up kOpenTriangleUp; 27 open diamond kOpenDiamond; 28 open cross kOpenCross; 29 open star kOpenStar; 30 full star kFullStar. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; TMarker marker;; marker.DisplayMarkerTypes();; return c;; }. Marker size; Various marker sizes are shown in the figure below. The default marker size=1; is shown in the top left corner. Marker sizes smaller than 1 can be; specified. The marker size does not refer to any coordinate systems, it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TAttMarker.html:1394,access,accessed,1394,root/html528/TAttMarker.html,https://root.cern,https://root.cern/root/html528/TAttMarker.html,1,['access'],['accessed']
Security,"eritance); by many other classes (graphics, histograms). It holds all the markers; attributes.; Marker attributes; The marker attributes are:. Marker color.; Marker style.; Marker size. Marker color; The marker color is a color index (integer) pointing in the ROOT color; table.; The marker color of any class inheriting from TAttMarker can ; be changed using the method SetMarkerColor and retrieved using the ; method GetMarkerColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Marker style; The Marker style defines the markers' shape.; The marker style of any class inheriting from TAttMarker can ; be changed using the method SetMarkerStyle and retrieved using the ; method GetMarkerStyle.; The following list gives the currently supported markers (screen ; and PostScript) style. Each marker style is identified by an integer number ; (first column) corresponding to a marker shape (second column) and can be also; accessed via a global name (third column). Marker number Marker shape Marker name; 1 dot kDot; 2 + kPlus; 3 * kStar; 4 o kCircle; 5 x kMultiply; 6 small scalable dot kFullDotSmall; 7 medium scalable dot kFullDotMedium; 8 large scalable dot kFullDotLarge; 9 -->19 dot; 20 full circle kFullCircle; 21 full square kFullSquare; 22 full triangle up kFullTriangleUp; 23 full triangle down kFullTriangleDown; 24 open circle kOpenCircle; 25 open square kOpenSquare; 26 open triangle up kOpenTriangleUp; 27 open diamond kOpenDiamond; 28 open cross kOpenCross; 29 open star kOpenStar; 30 full star kFullStar. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; TMarker marker;; marker.DisplayMarkerTypes();; return c;; }. Marker size; Various marker sizes are shown in the figure below. The default marker size=1; is shown in the top left corner. Marker sizes smaller than 1 can be; specified. The marker size does not refer to any coor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAttMarker.html:1394,access,accessed,1394,root/html526/TAttMarker.html,https://root.cern,https://root.cern/root/html526/TAttMarker.html,1,['access'],['accessed']
Security,"erived classes. ;  ; virtual ~TThreadFactory ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWin32ThreadFactory.html:2178,hash,hash,2178,doc/master/classTWin32ThreadFactory.html,https://root.cern,https://root.cern/doc/master/classTWin32ThreadFactory.html,1,['hash'],['hash']
Security,"erlap()), the top volume; 127(containing all geometry tree) must be specified before closing the geometry; 128and must not be positioned - it represents the global reference frame. After; 129building the full geometry tree, the geometry must be closed; 130(see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; 131this process.; 132 ; 133 ; 134 Below is the general scheme of the manager class.; 135 ; 136\image html geom_mgr.jpg; 137 ; 138## An interactive session; 139 ; 140 Provided that a geometry was successfully built and closed (for instance the; 141previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; 142itself to ROOT and the logical/physical structures will become immediately browsable.; 143The ROOT browser will display starting from the geometry folder : the list of; 144transformations and media, the top volume and the top logical node. These last; 145two can be fully expanded, any intermediate volume/node in the browser being subject; 146of direct access context menu operations (right mouse button click). All user; 147utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_frame0.jpg; 166 ; 167#### opt=1; 168 the final leaves (e.g. daughters with no containment) of the branch; 169 starting from volume are drawn down to the current numbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:8748,access,access,8748,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['access'],['access']
Security,"ernal Representation; 560An entry for a filled bin consists of its n-dimensional coordinates and; 561its bin content. The coordinates are compacted to use as few bits as; 562possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; 563use 4 bits for the x representation and 5 bits for the y representation.; 564This is handled by the internal class THnSparseCompactBinCoord.; 565Bin data (content and coordinates) are allocated in chunks of size; 566fChunkSize; this parameter can be set when constructing a THnSparse. Each; 567chunk is represented by an object of class THnSparseArrayChunk.; 568 ; 569Translation from an n-dimensional bin coordinate to the linear index within; 570the chunks is done by GetBin(). It creates a hash from the compacted bin; 571coordinates (the hash of a bin coordinate is the compacted coordinate itself; 572if it takes less than 8 bytes, the size of a Long64_t.; 573This hash is used to lookup the linear index in the TExMap member fBins;; 574the coordinates of the entry fBins points to is compared to the coordinates; 575passed to GetBin(). If they do not match, these two coordinates have the same; 576hash - which is extremely unlikely but (for the case where the compact bin; 577coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; 578contains a chain of linear indexes with the same hash. Iterating through this; 579chain and comparing each bin coordinates with the one passed to GetBin() will; 580retrieve the matching bin.; 581*/; 582 ; 583 ; 584ClassImp(THnSparse);; 585 ; 586////////////////////////////////////////////////////////////////////////////////; 587/// Construct an empty THnSparse.; 588 ; 589THnSparse::THnSparse():; 590 fChunkSize(1024), fFilledBins(0), fCompactCoord(nullptr); 591{; 592 fBinContent.SetOwner();; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Construct a THnSparse with ""dim"" dimensions,; 597/// with chunksize as the size of the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:21616,hash,hash,21616,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['hash'],['hash']
Security,"erpreter with all interpreter extensions disabled, i.e. as “proper” C++ code. No autoloading or synamic lookup will be performed.; A new R__LOAD_LIBRARY(libWhatever) will load libWhatever at parse time. This allows ROOT to resolve symbols from this library very early on. It is a work-around for the following code from ROOT 5:; // ROOT 5:; void func() {; gSystem->Load(""libEvent"");; Event* e = new Event;; }; Instead, write:; // ROOT 6:; R__LOAD_LIBRARY(libEvent); #include ""Event.h"". void func() {; Event* e = new Event;; }; TClass; Introduced new overload for calculating the TClass CheckSum:; UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; which indicates via the ‘isvalid’ boolean whether the checksum could be calculated correctly or not.; TROOT; Implemented new gROOT->GetTutorialsDir() static method to return the actual location of the tutorials directory. This is $ROOTSYS/tutorials when not configuring with –prefix or -Dgnuinstall for CMake.; TColor; Add an enum to access the palette by name.; Add new palettes with 255 colors. Names and colors’ definitions have been taken from here. Except for the kBird palette. These palettes can be accessed with gStyle->SetPalette(num). num can be taken within the following enum:. kDeepSea = 51; kGreyScale = 52; kDarkBodyRadiator = 53; kBlueYellow = 54; kRainBow = 55; kInvertedDarkBodyRadiator = 56; kBird = 57; kCubehelix = 58; kGreenRedViolet = 59; kBlueRedYellow = 60; kOcean = 61; kColorPrintableOnGrey = 62; kAlpine = 63; kAquamarine = 64; kArmy = 65; kAtlantic = 66; kAurora = 67; kAvocado = 68; kBeach = 69; kBlackBody = 70; kBlueGreenYellow = 71; kBrownCyan = 72; kCMYK = 73; kCandy = 74; kCherry = 75; kCoffee = 76; kDarkRainBow = 77; kDarkTerrain = 78; kFall = 79; kFruitPunch = 80; kFuchsia = 81; kGreyYellow = 82; kGreenBrownTerrain = 83; kGreenPink = 84; kIsland = 85; kLake = 86; kLightTemperature = 87; kLightTerrain = 88; kMint = 89; kNeon = 90; kPastel = 91; kPearl = 92; kPigeon = 93; kPlum = 94; kRedBlue ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:5276,access,access,5276,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['access'],['access']
Security,"erride;  Stream an object of class TClassTree. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTree.html:8153,hash,hash,8153,doc/master/classTClassTree.html,https://root.cern,https://root.cern/doc/master/classTClassTree.html,1,['hash'],['hash']
Security,"erride;  Stream an object of class TRotMatrix. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRotMatrix.html:3757,hash,hash,3757,doc/master/classTRotMatrix.html,https://root.cern,https://root.cern/doc/master/classTRotMatrix.html,1,['hash'],['hash']
Security,"ers of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:39992,access,access,39992,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,1,['access'],['access']
Security,"ers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); THashTableIter(const THashTableIter& iter); THashTableIter(const THashTable* ht, Bool_t dir = kIterForward). private:. Int_tNextSlot(); THashTableIter(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 16:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THashTableIter.html:2025,hash,hashtable,2025,root/html604/THashTableIter.html,https://root.cern,https://root.cern/root/html604/THashTableIter.html,2,['hash'],['hashtable']
Security,"ers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); THashTableIter(const THashTableIter& iter); THashTableIter(const THashTable* ht, Bool_t dir = kIterForward). private:. Int_tNextSlot(); THashTableIter(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-30 15:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THashTableIter.html:2025,hash,hashtable,2025,root/html602/THashTableIter.html,https://root.cern,https://root.cern/root/html602/THashTableIter.html,2,['hash'],['hashtable']
Security,"ervalCalculator; virtual ~IntervalCalculator ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:8250,hash,hash,8250,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,2,['hash'],['hash']
Security,"erver like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:20247,access,accessed,20247,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['access'],['accessed']
Security,"es (polar) in float precision; ROOT::Math::RhoZPhiVector vector based on rho,z,phi coordinates (cylindrical) in double precision; ROOT::Math::RhoZPhiVectorF vector based on rho,z,phi coordinates (cylindrical) in float precision; ROOT::Math::RhoEtaPhiVector vector based on rho,eta,phi coordinates (cylindrical using eta instead of z) in double precision; ROOT::Math::RhoEtaPhiVectorF vector based on rho,eta,phi coordinates (cylindrical using eta instead of z) in float precision. 13.12.2.1 Constructors and Assignment; The following declarations are available:; XYZVector v1; //an empty vector (x=0, y=0, z=0); XYZVector v2(1,2,3); //vector with x=1, y=2, z=3;; Polar3DVector v3(1,PI/2,PI); //vector with r=1, theta=PI/2, phi=PI; RhoEtaPHiVector v4(1,2, PI); //vector with rho=1, eta=2, phi=PI; Note that each vector type is constructed by passing its coordinate representation, so a XYZVector(1,2,3) is different from a Polar3DVector(1,2,3). In addition, the vector classes can be constructed by any vector, which implements the accessors x(), y() and z(). This can be another 3D vector based on a different coordinate system type. It can be even any vector of a different package, like the CLHEP HepThreeVector that implements the required signature.; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::HepThreeVector q(1,2,3);; XYZVector v3(q);; 13.12.2.2 Coordinate Accessors; All coordinate accessors are available through the class ROOT::Math::DisplacementVector3D:; //returns cartesian components for the cartesian vector v1; v1.X(); v1.Y(); v1.Z();; //returns cylindrical components for the cartesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2; r2.X(); r2.Y(); r2.Z(); In addition, all the 3 coordinates of the vector can be retrieved with the GetCoordinates method:; double d[3];; //fill d array with (x,y,z) components of v1; v1.GetCoordinates(d);; //fill d array with (r,eta,phi) components of r2; r2.GetCoordinates(d);; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:729543,access,accessors,729543,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessors']
Security,"es Class ReferenceCore ROOT classes » Base ROOT classes. ; A collection of TDataType designed to hold the typedef information and numerical type information. ; The collection is populated on demand.; Besides the built-in types (int, float) a typedef is explicitly added to the collection (and thus visible via ls or Print) only if it is requested explicitly. ; Definition at line 30 of file TListOfTypes.h. Public Member Functions;  TListOfTypes ();  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; TDataType * FindType (const char *name) const;  ;  Public Member Functions inherited from THashTable;  THashTable (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashTable object. ;  ; virtual ~THashTable ();  Delete a hashtable. ;  ; void Add (TObject *obj) override;  Add object to the hash table. ;  ; void AddAll (const TCollection *col) override;  Add all objects from collection col to this collection. ;  ; void AddBefore (const TObject *before, TObject *obj);  Add object to the hash table. ;  ; Float_t AverageCollisions () const;  ; void Clear (Option_t *option="""") override;  Remove all objects from the table. ;  ; Int_t Collisions (const char *name) const;  Returns the number of collisions for an object with a certain name (i.e. ;  ; Int_t Collisions (TObject *obj) const;  Returns the number of collisions for an object (i.e. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the table AND delete all heap based objects. ;  ; Bool_t Empty () const;  ; const TList * GetListForObject (const char *name) const;  Return the TList corresponding to object's name based hash value. ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the TList corres",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfTypes.html:1216,hash,hashtable,1216,doc/master/classTListOfTypes.html,https://root.cern,https://root.cern/doc/master/classTListOfTypes.html,1,['hash'],['hashtable']
Security,"es and Tasks. [ROOT-7426] - Cannot print elements of vector on Mac; [ROOT-7739] - TVectorD times double returns a TH1 on ROOT command line; [ROOT-7825] - wrong value passed to function expecting “const T*&""; [ROOT-7830] - Cling automatic RooFit objects always reloaded from file; [ROOT-7862] - CMake Error: CMake can not determine linker language for target: g2root; [ROOT-7864] - Segfault in __cf_15 and FastCall (c++ exception in a constructor is not propagated to python); [ROOT-7865] - root commandline tools are not executable after installation; [ROOT-7872] - PyROOT: wrong return value when calling a c++ function returning short; [ROOT-7879] - Autoloader (parser?) tries to follow #includes from LinkDef.h; [ROOT-7881] - Uninitialized member access in TFormula => undefined behaviour; [ROOT-7891] - installation instructions for root notebooks incomplete; [ROOT-7892] - Incoherent version of Python when building tmva/pymva; [ROOT-7896] - CMake: visibility inconsistency; [ROOT-7901] - Double-free in TROOT::EndOfProcessCleanups redux; [ROOT-7912] - Failure with -Dbuiltin_davix=ON on 64bit Ubuntu; [ROOT-7916] - pyroot problem with std::vector of enum; [ROOT-7927] - TPluginHandler::CheckForExecPlugin is not thread safe; [ROOT-7935] - Need a better way stop PyROOT from reading .rootlogon.(py|C); [ROOT-7940] - Incorrect handling of LLVM Threading; [ROOT-8003] - Root 6.06 slow to; [ROOT-8015] - cmake not honoring -Dbuiltin_lzma=OFF; [ROOT-8019] - Warning with spaces in the binary name; [ROOT-8031] - TTree auto (read) cache setup during Fill; [ROOT-7776] - Integrate GSL 2.0 in ROOT. Release 6.06/04; Released on May 4, 2016; General. Significant update of the valgrind suppression file to hide intentional lack of delete of some entities at the end of the process.; Resolved several memory leaks. Dictionaries. Add the -noIncludePaths and –noIncludePaths to rootcling and genereflex respectively to avoid storing in the dictionaries the include paths passed with the “-I” switch. ROOT wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:27811,access,access,27811,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['access'],['access']
Security,"es and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0, Int_t signalClass = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: BinarySearchTree.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has bee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__BinarySearchTree.html:7885,access,access,7885,root/html532/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html532/TMVA__BinarySearchTree.html,1,['access'],['access']
Security,"es and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0, Int_t signalClass = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: BinarySearchTree.h 40012 2011-06-27 16:03:11Z stelzer $ » Last generated: 2011-07-04 15:33; This page has bee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__BinarySearchTree.html:7885,access,access,7885,root/html530/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html530/TMVA__BinarySearchTree.html,1,['access'],['access']
Security,"es as well as low-level details such as I/O and parallelization. RDataFrame provides methods to perform most common operations required by ROOT analyses; at the same time, users can just as easily specify custom code that will be executed in the event loop.; RDataFrame is built with a modular and flexible workflow in mind, summarised as follows:. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, CSV files, SQLite files, RNTuples, and it can be extended to custom data formats. From Python, NumPy arrays can be imported into RDataFrame as well.; Transform the dataframe by:; Applying filters. This selects only specific rows of the dataset.; Creating custom columns. Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. Produce results. Actions are used to aggregate data into results. Most actions are lazy, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the crash course to discover more idiomatic and flexible ways to express analyses with RDataFrame. . TTreeReader ROOT::RDataFrame . TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:146;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:11075,access,accessed,11075,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['access'],['accessed']
Security,"es as well as low-level details such as I/O and parallelization. RDataFrame provides methods to perform most common operations required by ROOT analyses; at the same time, users can just as easily specify custom code that will be executed in the event loop.; RDataFrame is built with a modular and flexible workflow in mind, summarised as follows:. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, CSV files, SQLite files, RNTuples, and it can be extended to custom data formats. From Python, NumPy arrays can be imported into RDataFrame as well.; Transform the dataframe by:; Applying filters. This selects only specific rows of the dataset.; Creating custom columns. Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. Produce results. Actions are used to aggregate data into results. Most actions are lazy, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the crash course to discover more idiomatic and flexible ways to express analyses with RDataFrame. . TTreeReader ROOT::RDataFrame . TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:11464,access,accessed,11464,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['access'],['accessed']
Security,"es create a new instance of class T to represent the ""Sum"" object. This method is not thread safe: correct or acceptable behaviours depend on the nature of T and of the merging function. ; Definition at line 312 of file TThreadedObject.hxx. Member Data Documentation. ◆ fDirectories. template<class T > . std::deque<TDirectory*> ROOT::TThreadedObject< T >::fDirectories. private . A TDirectory per slot. ; Definition at line 332 of file TThreadedObject.hxx. ◆ fgMaxSlots. template<class T > . constexpr const TNumSlots ROOT::TThreadedObject< T >::fgMaxSlots {64}. staticconstexpr . The initial number of empty processing slots that a TThreadedObject is constructed with by default. ; Deprecated: TThreadedObject grows as more slots are required. ; Definition at line 155 of file TThreadedObject.hxx. ◆ fIsMerged. template<class T > . bool ROOT::TThreadedObject< T >::fIsMerged. private . Remember if the objects have been merged already. ; Definition at line 335 of file TThreadedObject.hxx. ◆ fModel. template<class T > . std::unique_ptr<T> ROOT::TThreadedObject< T >::fModel. private . Use to store a ""model"" of the object. ; Definition at line 327 of file TThreadedObject.hxx. ◆ fObjPointers. template<class T > . std::deque<std::shared_ptr<T> > ROOT::TThreadedObject< T >::fObjPointers. private . An object pointer per slot. ; Definition at line 329 of file TThreadedObject.hxx. ◆ fSpinMutex. template<class T > . ROOT::TSpinMutex ROOT::TThreadedObject< T >::fSpinMutex. mutableprivate . Protects concurrent access to fThrIDSlotMap, fObjPointers. ; Definition at line 334 of file TThreadedObject.hxx. ◆ fThrIDSlotMap. template<class T > . std::map<std::thread::id, unsigned> ROOT::TThreadedObject< T >::fThrIDSlotMap. private . A mapping between the thread IDs and the slots. ; Definition at line 333 of file TThreadedObject.hxx. core/thread/inc/ROOT/TThreadedObject.hxx. ROOTTThreadedObject. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:38 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html:10689,access,access,10689,doc/v632/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html,1,['access'],['access']
Security,"es for the specified columns. The callable can take any column values as input, similarly to what happens during Filter and Define calls. It must return an RVec of varied values, one for each variation tag, in the same order as the tags. ; [in]inputColumnsthe names of the columns to be passed to the callable. ; [in]variationTagsnames for each of the varied values, e.g. ""up"" and ""down"". ; [in]variationNamea generic name for this set of varied values, e.g. ""ptvariation"". Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for results that depend on any varied quantity, a map/dictionary of varied results can be produced with ROOT::RDF::Experimental::VariationsFor (see the example below).; The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and values for each of the systematic variations that affected the result (via upstream Filters or via direct or indirect dependencies of the column values on some registered variations). The keys will be a composition of variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt. We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""): auto nominal_hx =; df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); .Filter(""pt > k""); .Define(""x"", someFunc, {""pt""}); .Histo1D(""x"");; ; auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; hx[""nominal""].Draw();; hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");; RDataFrame computes all variations as part of a single loop over the data. In particular, this means that I/O and computation of values shared among variations only happen once for all variations. Thus, the event loop run-time ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:149463,access,accessed,149463,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['access'],['accessed']
Security,"es in a pathname. If compatibility is not an issue; 1878/// you can use on Unix directly $XXX. The user must delete returned string.; 1879/// Returns the expanded pathname or 0 in case of error.; 1880/// The user must delete returned string (delete []).; 1881 ; 1882char *TUnixSystem::ExpandPathName(const char *path); 1883{; 1884 TString patbuf = path;; 1885 if (ExpandPathName(patbuf)); 1886 return nullptr;; 1887 return StrDup(patbuf.Data());; 1888}; 1889 ; 1890////////////////////////////////////////////////////////////////////////////////; 1891/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1892 ; 1893int TUnixSystem::Chmod(const char *file, UInt_t mode); 1894{; 1895 return ::chmod(file, mode);; 1896}; 1897 ; 1898////////////////////////////////////////////////////////////////////////////////; 1899/// Set the process file creation mode mask.; 1900 ; 1901int TUnixSystem::Umask(Int_t mask); 1902{; 1903 return ::umask(mask);; 1904}; 1905 ; 1906////////////////////////////////////////////////////////////////////////////////; 1907/// Set a files modification and access times. If actime = 0 it will be; 1908/// set to the modtime. Returns 0 on success and -1 in case of error.; 1909 ; 1910int TUnixSystem::Utime(const char *file, Long_t modtime, Long_t actime); 1911{; 1912 if (!actime); 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location of file ""wfil"" in a search path.; 1923/// The search path is specified as a : separated list of directories.; 1924/// Return value is pointing to wfile for compatibility with; 1925/// Which(const char*,const char*,EAccessMode) version.; 1926 ; 1927const char *TUnixSystem::FindFile(const char *search, TString& wfil, EAccessMode mode); 1928{; 1929 TString show;; 1930 if (gEnv->GetValue(""Root.S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:58591,access,access,58591,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['access'],['access']
Security,"es of the event; int fEventSize; // size (in bytes) of the event; };. The data members of the Particle class describe the particle properties as shown below:; class Particle {; public:; double fPosX,fPosY,fPosZ; // particle position nearest to interaction point; double fMomentum; // particle momentum; double fMomentumPhi; // particle direction (phi); double fMomentumEta; // particle direction (eta); Long64_t fTags[128]; // particle tags; };. The TTree contains a branch event, which in turn contains the branches fParticles and fEventSize. It simply reflects the layout of class EventData. Each TTree entry has one object of type class EventData, which in turn has a collection of particles. Each tree entry can have a different number of particles. There are 200 TTree entries containing a total of 22994 particles.; If you are curious how we generated the TTree: the script is in our git repository.; . ‹ Introductory Tutorials; up; Accessing a TTree With a TBrowser ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/meet-ttree.html:4420,access,access,4420,d/meet-ttree.html,https://root.cern,https://root.cern/d/meet-ttree.html,1,['access'],['access']
Security,"es read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TWebFile(const char* url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. The url; argument must be of the form: http://host.dom.ain/file.root.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. The preferred interface to this; constructor is via TFile::Open(). TWebFile(TUrl url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. Make sure url; is a valid TUrl object.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. ~TWebFile(); Clean",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TWebFile.html:24347,access,accessible,24347,root/html532/TWebFile.html,https://root.cern,https://root.cern/root/html532/TWebFile.html,2,['access'],['accessible']
Security,"es(). void TMVA::DecisionTreeNode::ReadAttributes ; (; void * ; node, . UInt_t ; tmva_Version_Code = 262657 . ). virtual . Implements TMVA::Node.; Definition at line 458 of file DecisionTreeNode.cxx. ◆ ReadContent(). void TMVA::DecisionTreeNode::ReadContent ; (; std::stringstream & ; s). virtual . reading attributes from tree node (well, was used in BinarySearchTree, and somehow I guess someone programmed it such that we need this in this tree too, although we don't..) ; Implements TMVA::Node.; Definition at line 538 of file DecisionTreeNode.cxx. ◆ ReadDataRecord(). Bool_t TMVA::DecisionTreeNode::ReadDataRecord ; (; std::istream & ; is, . UInt_t ; tmva_Version_Code = 262657 . ). virtual . Read the data block. ; Implements TMVA::Node.; Definition at line 272 of file DecisionTreeNode.cxx. ◆ ResetValidationData(). void TMVA::DecisionTreeNode::ResetValidationData ; (; ). temporary stored node values (number of events, etc.) that originate not from the training but from the validation data (used in pruning) ; Definition at line 366 of file DecisionTreeNode.cxx. ◆ SetAlpha(). void TMVA::DecisionTreeNode::SetAlpha ; (; Double_t ; alpha). inline . set the critical point alpha, if traininfo defined ; Definition at line 306 of file DecisionTreeNode.h. ◆ SetAlphaMinSubtree(). void TMVA::DecisionTreeNode::SetAlphaMinSubtree ; (; Double_t ; g). inline . set the minimum alpha in the tree rooted at this node, if traininfo defined ; Definition at line 311 of file DecisionTreeNode.h. ◆ SetCC(). void TMVA::DecisionTreeNode::SetCC ; (; Double_t ; cc). Set CC, if traininfo defined, otherwise Log Fatal. ; Definition at line 404 of file DecisionTreeNode.cxx. ◆ SetCutType(). void TMVA::DecisionTreeNode::SetCutType ; (; Bool_t ; t). inline . set true: if event variable > cutValue ==> signal , false otherwise ; Definition at line 158 of file DecisionTreeNode.h. ◆ SetCutValue(). void TMVA::DecisionTreeNode::SetCutValue ; (; Float_t ; c). inline . set the cut value applied at this node ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html:29523,validat,validation,29523,doc/master/classTMVA_1_1DecisionTreeNode.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html,1,['validat'],['validation']
Security,"es(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(Scalar[] dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:13619,access,access,13619,root/html602/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,4,['access'],['access']
Security,"es); 1241 - `m = 3`; median is drawn as a circle; 1242 ; 1243 - `M = 0`; no mean drawn; 1244 - `M = 1`; mean is drawn as a dashed line; 1245 - `M = 3`; mean is drawn as a circle; 1246 ; 1247 - `w = 0`; no whisker drawn; 1248 - `w = 1`; whisker is drawn to end of distribution.; 1249 - `w = 2`; whisker is drawn to max 1.5*iqr; 1250 ; 1251 - `a = 0`; no anchor drawn; 1252 - `a = 1`; the anchors are drawn; 1253 ; 1254 - `p = 0`; no points drawn; 1255 - `p = 1`; only outliers are drawn; 1256 - `p = 2`; all datapoints are drawn; 1257 - `p = 3`: all datapoints are drawn scattered; 1258 ; 1259 - `h = 0`; no histogram is drawn; 1260 - `h = 1`; histogram at the left or bottom side is drawn; 1261 - `h = 2`; histogram at the right or top side is drawn; 1262 - `h = 3`; histogram at left and right or top and bottom (violin-style) is drawn; 1263 ; 1264 - `z = 0`; no zero indicator line is drawn; 1265 - `z = 1`; zero indicator line is drawn.; 1266 ; 1267As one can see all individual options for both candle and violin plots can be accessed by this; 1268mechanism. In deed the keywords CANDLE(<option-string>) and VIOLIN(<option-string>) have the same; 1269meaning. So you can parametrise an option-string for a candle plot and use the keywords VIOLIN and; 1270vice versa, if you wish.; 1271 ; 1272Using a logarithmic x- or y-axis is possible for candle and violin charts.; 1273 ; 1274\since **ROOT version 6.11/01**; 1275 ; 1276a logarithmic z-axis is possible, too but will only affect violin charts of course.; 1277 ; 1278\anchor HP140a; 1279#### The CANDLE option; 1280 ; 1281<a href=""http://en.wikipedia.org/wiki/Box_plot"">A Candle plot</a> (also known as; 1282a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient; 1283way to describe graphically a data distribution (D) with only five numbers:; 1284 ; 1285 1. The minimum value of the distribution D (bottom or left whisker).; 1286 2. The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:51544,access,accessed,51544,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['access'],['accessed']
Security,"es. ; Definition at line 1440 of file TAuthenticate.cxx. ◆ CheckNetrc() [1/2]. Bool_t TAuthenticate::CheckNetrc ; (; TString & ; user, . TString & ; passwd . ). Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc files. ; For more info see the version with 4 arguments. This version is maintained for backward compatability reasons. ; Definition at line 878 of file TAuthenticate.cxx. ◆ CheckNetrc() [2/2]. Bool_t TAuthenticate::CheckNetrc ; (; TString & ; user, . TString & ; passwd, . Bool_t & ; pwhash, . Bool_t ; srppwd . ). Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc files. ; First ~/.rootnetrc is tried, after that ~/.netrc. These files will only be used when their access masks are 0600. Returns kTRUE if user and passwd were found for the machine specified in the URL. If kFALSE, user and passwd are """". The boolean pwhash is set to kTRUE if the returned passwd is to be understood as password hash, i.e. if the 'password-hash' keyword is found in the 'machine' lines; not implemented for 'secure' and the .netrc file. The format of these files are:. this is a comment line; machine <machine fqdn> login <user> password <passwd> machine <machine fqdn> login <user> password-hash <passwd>; and in addition ~/.rootnetrc also supports:; secure <machine fqdn> login <user> password <passwd>; <machine fqdn> may be a domain name or contain the wild card '*'.; for the secure protocols. All lines must start in the first column. ; Definition at line 908 of file TAuthenticate.cxx. ◆ CheckProofAuth(). Bool_t TAuthenticate::CheckProofAuth ; (; Int_t ; cSec, . TString & ; det . ). static . Check if the authentication method can be attempted for the client. ; Definition at line 3541 of file TAuthenticate.cxx. ◆ Class(). static TClass * TAuthenticate::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TAuthenticate::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Versio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:23602,password,password-hash,23602,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,2,"['password', 'secur']","['password-hash', 'secure']"
Security,"es. ;  ; int SetNonBlock (int fd);  Make descriptor fd non-blocking. ;  ; void SetProgname (const char *name) override;  Set the application name (from command line, argv[0]) and copy it in gProgName. ;  ; int SetSockOpt (int sock, int opt, int val) override;  Set socket option. ;  ; void Sleep (UInt_t milliSec) override;  Sleep milliSec milli seconds. ;  ; void StackTrace () override;  Print a stack trace, if gEnv entry ""Root.Stacktrace"" is unset or 1, and if the image helper functions can be found (see InitImagehlpFunctions()). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Symlink (const char *from, const char *to) override;  Create a symlink from file1 to file2. ;  ; const char * TempDirectory () const override;  Return a user configured or systemwide directory to create temporary files in. ;  ; FILE * TempFileName (TString &base, const char *dir=nullptr, const char *suffix=nullptr) override;  Create a secure temporary file by appending a unique 6 letter string to base. ;  ; int Umask (Int_t mask) override;  Set the process file creation mode mask. ;  ; const char * UnixPathName (const char *unixpathname) override;  Convert a pathname to a unix pathname. ;  ; int Unlink (const char *name) override;  Unlink, i.e. ;  ; int Utime (const char *file, Long_t modtime, Long_t actime) override;  Set a files modification and access times. ;  ; const char * WorkingDirectory () override;  Return the working directory for the default drive. ;  ; const char * WorkingDirectory (char driveletter);  Return working directory for the selected drive driveletter == 0 means return the working durectory for the default drive. ;  ;  Public Member Functions inherited from TSystem;  TSystem (const char *name=""Generic"", const char *title=""Generic System"");  Create a new OS interface. ;  ; virtual ~TSystem ();  Delete the OS interface. ;  ; virtual void AddIncludePath (const char *include",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:13134,secur,secure,13134,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['secur'],['secure']
Security,"es; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsMoment.html:33118,access,access,33118,root/html534/RooAbsMoment.html,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html,1,['access'],['access']
Security,"es; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooListProxy_highSetHigh-side varaition; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooListProxy_lowSetLow-side variation; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/PiecewiseInterpolation.html:35023,access,access,35023,root/html602/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html602/PiecewiseInterpolation.html,2,['access'],['access']
Security,"esentation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnSparse* h, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); voidCalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tComputeIntegral(); virtual voidTNamed::Copy(TObject& named",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THnSparse.html:4697,hash,hash,4697,root/html532/THnSparse.html,https://root.cern,https://root.cern/root/html532/THnSparse.html,1,['hash'],['hash']
Security,"esentation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnSparse* h, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tComputeIntegral(); virtual voidTNamed::Copy(TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:4697,hash,hash,4697,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,2,['hash'],['hash']
Security,"esentation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparse.html:4610,hash,hash,4610,root/html534/THnSparse.html,https://root.cern,https://root.cern/root/html534/THnSparse.html,3,['hash'],['hash']
Security,"essage == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3443}; 3444 ; 3445 ; 3446static void; 3447mg_cry_internal_wrap(const struct mg_connection *conn,; 3448 struct mg_context *ctx,; 3449 const char *func,; 3450 unsigned line,; 3451 const char *fmt,; 3452 ...); 3453{; 3454 va_list ap;; 3455 va_start(ap, fmt);; 3456 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:101774,access,access,101774,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"essage == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3444}; 3445 ; 3446 ; 3447static void; 3448mg_cry_internal_wrap(const struct mg_connection *conn,; 3449 struct mg_context *ctx,; 3450 const char *func,; 3451 unsigned line,; 3452 const char *fmt,; 3453 ...); 3454{; 3455 va_list ap;; 3456 va_start(ap, fmt);; 3457 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:101806,access,access,101806,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"essary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMD5.html:3503,hash,hash,3503,root/html528/TMD5.html,https://root.cern,https://root.cern/root/html528/TMD5.html,3,['hash'],['hash']
Security,"ession::GetNumBitsInt_t GetNumBits(Int_t n) constDefinition THnSparse.cxx:127; THnSparseCoordCompression::SetCoordFromBuffervoid SetCoordFromBuffer(const Char_t *buf_in, Int_t *coord_out) constGiven the compressed coordinate buffer buf_in, calculate (""decompact"") the bin coordinates and return...Definition THnSparse.cxx:205; THnSparseCoordCompression::SetBufferFromCoordULong64_t SetBufferFromCoord(const Int_t *coord_in, Char_t *buf_out) constGiven the cbin coordinates coord_in, calculate (""compact"") the bin coordinates and return them in buf...Definition THnSparse.cxx:233; THnSparseCoordCompression::fBitOffsetsInt_t * fBitOffsetsDefinition THnSparse.cxx:136; THnSparseCoordCompression::GetBufferSizeInt_t GetBufferSize() constDefinition THnSparse.cxx:121; THnSparseCoordCompression::operator=THnSparseCoordCompression & operator=(const THnSparseCoordCompression &other)Set this to other if different.Definition THnSparse.cxx:179; THnSparseCoordCompression::GetHashFromBufferULong64_t GetHashFromBuffer(const Char_t *buf) constCalculate hash from compact bin index.Definition THnSparse.cxx:317; THnSparseCoordCompression::fNdimensionsInt_t fNdimensionsDefinition THnSparse.cxx:134; THnSparseCoordCompression::THnSparseCoordCompressionTHnSparseCoordCompression(Int_t dim, const Int_t *nbins)Initialize a THnSparseCoordCompression object with ""dim"" dimensions and ""bins"" holding the number of ...Definition THnSparse.cxx:149; THnSparseCoordCompression::~THnSparseCoordCompression~THnSparseCoordCompression()destruct a THnSparseCoordCompressionDefinition THnSparse.cxx:195; THnSparseEfficient multidimensional histogram.Definition THnSparse.h:37; THnSparse::GetSparseFractionBinsDouble_t GetSparseFractionBins() constReturn the amount of filled bins over all bins.Definition THnSparse.cxx:854; THnSparse::GetSparseFractionMemDouble_t GetSparseFractionMem() constReturn the amount of used memory over memory that would be used by a non-sparse n-dimensional histogr...Definition THnSparse.cxx:865; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:45603,hash,hash,45603,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['hash'],['hash']
Security,ested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; static RooArgSet_emptySetSupports named argument constructor; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_t_extended; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_first!; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNLLVar.html:39292,access,access,39292,root/html602/RooNLLVar.html,https://root.cern,https://root.cern/root/html602/RooNLLVar.html,2,['access'],['access']
Security,"estonLL::BarlowCache> >_barlowCache; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*_data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html:35198,access,access,35198,root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html,2,['access'],['access']
Security,"et reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections. If port is 0 a port scan will be done to; find a free port. This option is mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:12374,authenticat,authentication,12374,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,1,['authenticat'],['authentication']
Security,"et reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections. If port is 0 a port scan will be done to; find a free port. This option is mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. The opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TServerSocket.html:12687,authenticat,authentication,12687,root/html530/TServerSocket.html,https://root.cern,https://root.cern/root/html530/TServerSocket.html,5,['authenticat'],['authentication']
Security,"et&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); RooCacheManager<vector<double> >(Int_t maxSize = 2); RooCacheManager<vector<double> >(RooAbsArg* owner, Int_t maxSize = 2); RooCacheManager<vector<double> >(const RooCacheManager<vector<double> >& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, vector<double>* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, vector<double>* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<vector<double>*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(nset,0,sterileIndex,isetRangeName). Int_t setObj(const RooArgSet* nset, vector<double>* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double>* obj, const TNamed* isetRangeName = 0). T* getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsColl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCacheManager_vector_double___.html:3019,access,accessed,3019,root/html602/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html602/RooCacheManager_vector_double___.html,2,['access'],['accessed']
Security,"et) overrideWhen the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be ...Definition TUnixSystem.cxx:908; TUnixSystem::UnixUdpServicestatic int UnixUdpService(int port, int backlog)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNameconst char * PrependPathName(const char *dir, TString &name) overrideConcatenate a directory and a file name.Definition TUnixSystem.cxx:1552; TUnixSystem::DispatchTimersBool_t DispatchTimers(Bool_t mode)Handle and dispatch timers.Definition TUnixSystem.cxx:2979; TUnixSystem::IgnoreSignalvoid IgnoreSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:209737,access,access,209737,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,4,['access'],['access']
Security,"et. The 2D histogram has equidistant bins along the X; 117and Y directions. The number of bins along each direction can be change using; 118`SetNpx()` and `SetNpy()`. Each bin is filled with the Z; 119value found via a linear interpolation on the plane defined by the triangle above; 120the (X,Y) coordinates of the bin center.; 121 ; 122The existing (X,Y,Z) points can be randomly scattered.; 123The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then; 124used to define flat planes in (X,Y,Z) over which the interpolation is done to fill; 125the 2D histogram. The 3D triangles int takes build a 3D surface in; 126the form of tessellating triangles at various angles. The triangles found can be; 127drawn in 3D with one of the TGraph2D specific drawing options.; 128 ; 129The histogram generated by the Delaunay interpolation can be accessed using the; 130`GetHistogram()` method.; 131 ; 132The axis settings (title, ranges etc ...) can be changed accessing the axis via; 133the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created; 134at drawing time only. Therefore they should called after the TGraph2D is drawn:; 135 ; 136~~~ {.cpp}; 137 auto g = new TGraph2D();; 138 ; 139 [...]; 140 ; 141 g->Draw(""tri1"");; 142 gPad->Update();; 143 g->GetXaxis()->SetTitle(""X axis title"");; 144~~~; 145 ; 146\anchor G2D02; 147## Examples; 148 ; 149\anchor G2D021; 150### SURF1 Example; 151 ; 152Begin_Macro(source); 153{; 154 auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; 155 Double_t x, y, z, P = 6.;; 156 Int_t np = 200;; 157 auto dt = new TGraph2D();; 158 dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; 159 auto r = new TRandom();; 160 for (Int_t N=0; N<np; N++) {; 161 x = 2*P*(r->Rndm(N))-P;; 162 y = 2*P*(r->Rndm(N))-P;; 163 z = (sin(x)/x)*(sin(y)/y)+0.2;; 164 dt->SetPoint(N,x,y,z);; 165 }; 166 gStyle->SetPalette(1);; 167 dt->Draw(""surf1"");; 168}; 169End_Macro; 170 ; 171\anchor G2D022; 172### Fitting Example; 173 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2D_8cxx_source.html:5533,access,accessing,5533,doc/master/TGraph2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html,1,['access'],['accessing']
Security,"et; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TMutex*fAMtxTo protect async msg queue; list<TXSockBuf*>fAQuelist of asynchronous messages; TSemaphorefASemControl access to conn async msg queue; TSemaphorefAsynProcControl actions while processing async messages; TXSockBuf*fBufCurcurrent read buffer; TStringfBufferContainer for exchanging information; Int_tfByteCurcurrent position in the first buffer; Int_tfByteLeftbytes left in the first buffer; XrdProofConn*fConninstance of the underlying connection module; Bool_tfDontTimeoutIf true wait forever for incoming messages; TXHandler*fHandlerHandler of asynchronous events (input, error); TStringfHostRemote host; Bool_tfIForwardWheter the interrupt should be propagated; intfILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; intfSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t PickUpReady(); Manage asynchronous message. TXSockBuf * PopUpSpare(Int_t sz). void PushBackSpare(). void PostMsg(Int_t type, const char* msg = 0); Post a message into the queue for asynchronous processi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXSocket.html:10767,access,access,10767,root/html528/TXSocket.html,https://root.cern,https://root.cern/root/html528/TXSocket.html,1,['access'],['access']
Security,"et<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRecursiveFraction.html:34847,access,access,34847,root/html602/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html,2,['access'],['access']
Security,"etBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Int_tFindElement(ULong64_t hash, Long64_t key); voidFixCollisions(Int_t index); Bool_tHighWaterMark(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TExMap.html:5471,hash,hash,5471,root/html528/TExMap.html,https://root.cern,https://root.cern/root/html528/TExMap.html,3,['hash'],['hash']
Security,"etDictNorm(). DictFuncPtr_t TClassTable::GetDictNorm ; (; const char * ; cname). static . Given the normalized class name returns the Dictionary() function of a class (uses hash of name). ; Definition at line 717 of file TClassTable.cxx. ◆ GetID(). Version_t TClassTable::GetID ; (; const char * ; cname). static . Returns the ID of a class. ; Definition at line 647 of file TClassTable.cxx. ◆ GetPragmaBits(). Int_t TClassTable::GetPragmaBits ; (; const char * ; name). static . Returns the pragma bits as specified in the LinkDef.h file. ; Definition at line 660 of file TClassTable.cxx. ◆ GetProto(). TProtoClass * TClassTable::GetProto ; (; const char * ; cname). static . Given the class name returns the TClassProto object for the class. ; (uses hash of name). ; Definition at line 742 of file TClassTable.cxx. ◆ GetProtoNorm(). TProtoClass * TClassTable::GetProtoNorm ; (; const char * ; cname). static . Given the class normalized name returns the TClassProto object for the class. ; (uses hash of name). ; Definition at line 770 of file TClassTable.cxx. ◆ Init(). void TClassTable::Init ; (; ). static . Definition at line 390 of file TClassTable.cxx. ◆ IsA(). TClass * TClassTable::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 101 of file TClassTable.h. ◆ Next(). char * TClassTable::Next ; (; ). static . Returns next class from sorted class table. ; Don't use this iterator while modifying the class table. The class table can be modified when making calls like TClass::GetClass(), etc. ; Definition at line 807 of file TClassTable.cxx. ◆ Print(). void TClassTable::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print the class table. ; Before printing the table is sorted alphabetically. Only classes specified in option are listed. The default is to list all classes. Standard wildcarding notation supported. ; Reimplemented from TObject.; Definition at line 328 of file TClassTable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTable.html:18312,hash,hash,18312,doc/master/classTClassTable.html,https://root.cern,https://root.cern/doc/master/classTClassTable.html,1,['hash'],['hash']
Security,"etErrno () const final;  Method returning errno. ;  ; Int_t GetIOVersion () const;  ; Int_t GetNbytesFree () const final;  ; Int_t GetNbytesInfo () const final;  ; Int_t GetNfree () const final;  ; Int_t GetQuerisCounter () const;  ; Long64_t GetSeekFree () const final;  ; Long64_t GetSeekInfo () const final;  ; Long64_t GetSize () const final;  Returns the current file size. ;  ; const char * GetTablesType () const;  ; Int_t GetUseIndexes () const;  ; Bool_t GetUseSuffixes () const;  ; Int_t GetUseTransactions () const;  ; TClass * IsA () const override;  ; Bool_t IsMySQL () const;  checks, if MySQL database ;  ; Bool_t IsODBC () const;  checks, if ODBC driver used for database connection ;  ; Bool_t IsOpen () const final;  return kTRUE if file is opened and can be accessed ;  ; Bool_t IsOracle () const;  checks, if Oracle database ;  ; void MakeFree (Long64_t, Long64_t) final;  Mark unused bytes on the file. ;  ; void MakeProject (const char *, const char *=""*"", Option_t *=""new"") final;  Generate source code necessary to access the objects stored in the file. ;  ; TString MakeSelectQuery (TClass *cl);  Produce SELECT statement which can be used to get all data of class cl in one SELECT statement. ;  ; void Map () final;  ; void Map (Option_t *) final;  List the contents of a file sequentially. ;  ; void Paint (Option_t *="""") final;  Paint all objects in the file. ;  ; void Print (Option_t *="""") const final;  Print all objects in the file. ;  ; Bool_t ReadBuffer (char *, Int_t) final;  Read a buffer from the file. ;  ; Bool_t ReadBuffer (char *, Long64_t, Int_t) final;  Read a buffer from the file at the offset 'pos' in the file. ;  ; void ReadFree () final;  Read the FREE linked list. ;  ; Int_t Recover () final;  Attempt to recover file if not correctly closed. ;  ; Int_t ReOpen (Option_t *mode) final;  Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ;  ; void ResetErrno () const final;  Method resetting the errno. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:12176,access,access,12176,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['access'],['access']
Security,"etFont (const TGFont *font);  Use font, i.e. ;  ; TGFont * GetFont (FontStruct_t font);  Use font, i.e. increases ref count of specified font. ;  ; char ** GetFontFamilies ();  Return information about the font families that are available on the current display. ;  ; TClass * IsA () const override;  ; const char * NameOfFont (TGFont *font);  Given a font, return a textual string identifying it. ;  ; Bool_t ParseFontName (const char *string, FontAttributes_t *fa);  Converts a string into a set of font attributes that can be used to construct a font. ;  ; void Print (Option_t *option="""") const override;  List all fonts in the pool. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGObject;  TGObject ();  ;  TGObject (const TGObject &tgo);  ;  ~TGObject () override;  TGObject destructor. ;  ; TGClient * GetClient () const;  ; Handle_t GetId () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison (TGObjects are equal if they have the same window identifier). ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Write this TGObject to a file using TImage, if filename's extension signals a valid TImage::EImageFileType, as defined by TImage::GetImageFileTypeFromFilename(). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFontPool.html:2582,hash,hash,2582,doc/master/classTGFontPool.html,https://root.cern,https://root.cern/doc/master/classTGFontPool.html,1,['hash'],['hash']
Security,"etUsed (Bool_t flag=kTRUE);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t Z () const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoElementRN.html:5148,hash,hash,5148,doc/master/classTGeoElementRN.html,https://root.cern,https://root.cern/doc/master/classTGeoElementRN.html,1,['hash'],['hash']
Security,"etWeightFileDir() const; { return fFileDir; }. Bool_t IsNormalised() const; are input variables normalised ?. { return fNormalise; }. void SetNormalised(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbose and help flags. { return fVerbose; }. Bool_t Help() const; { return fHelp; }. const TString& GetInternalVarName(Int_t ivar) const; ---------- protected event and tree accessors -----------------------------; names of input variables (if the original names are expressions, they are; transformed into regexps). { return (*fInputVars)[ivar]; }. const TString& GetOriginalVarName(Int_t ivar) const; { return DataInfo().GetVariableInfo(ivar).GetExpression(); }. Bool_t HasTrainingTree() const; { return Data()->GetNTrainingEvents() != 0; }. void MakeClassSpecific(ostream& , const TString& = """") const; ---------- protected auxiliary methods ------------------------------------; make ROOT-independent C++ class for classifier response (classifier-specific implementation). {}. void MakeClassSpecificHeader(ostream& , const TString& = """") const; header and auxiliary classes. {}. Bool_t TxtWeightsOnly() const; if TRUE, write weights only to text files. { return kTRUE; }. Bool_t IsConstructedFromWeightFile() const; access to event information that needs method-specific information. { return fConstructedFromWeightFile; }. ECutOrientation GetCutOrientation() const; { return fCutOrientation; }. Bool_t IgnoreEventsWithNegWeightsInTraining() const; { return fIgnoreNegWeightsInTraining; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBase.html:37653,access,access,37653,root/html534/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBase.html,1,['access'],['access']
Security,"etZfirst (Int_t first);  ; virtual void SetZlast (Int_t last);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBackCompFitter.html:10696,hash,hash,10696,doc/master/classTBackCompFitter.html,https://root.cern,https://root.cern/doc/master/classTBackCompFitter.html,5,['hash'],['hash']
Security,"ete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArray*fAllRules! Array of all rules; UInt_tfCheckSumTarget class checksum; TClassReffClass! Target class pointer (for consistency checking); TStringfClassNameTarget class name; TObjArray*fPersistentRulesArray of the rules that will be embeded in the file; TObjArray*fRemainingRules! Array of non-persisten rules - just for cleanup purposes - owns the elements; Int_tfVersionTarget class version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSchemaRuleSet(). virtual ~TSchemaRuleSet(). Bool_t AddRule(ROOT::TSchemaRule* rule, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll). Bool_t AddRules(ROOT::TSchemaRuleSet* rules, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll). Bool_t HasRuleWithSourceClass(const TString& source) const. const TObjArray* FindRules(const TString& source) const. const TSchemaMatch* FindRules(const TString& source, Int_t version) const. const TSchemaMatch* FindRules(const TString& source, UInt_t checksum) const. const TSchemaMatch* FindRules(const TString& source, Int_t version, UInt_t checksum) const. TClass* GetClass(). UInt_t GetClassCheckSum() const. TString GetClassName() const. Int_t GetClassVersion() const. const TObjArray* GetRules() const. const TObjArray* GetPersistentRules() const. void RemoveRule(ROOT::TSchemaRule* rule). void RemoveRules(TObjArray* rules). void SetClass(TClass* cls). void ls(Option_t* option = """") const. void AsString(TString& out) const. » Last changed: root/core:$Id: TSchemaRuleSet.h 32644 2010-03-17 13:58:28Z pcanal $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__TSchemaRuleSet.html:7076,checksum,checksum,7076,root/html528/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html528/ROOT__TSchemaRuleSet.html,2,['checksum'],['checksum']
Security,"ete; };. protected:. RooLinkedListElem*_curStore!; Int_t_curStoreSize!; Int_t_curStoreUsed!; RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list; list<std::pair<Int_t,RooLinkedListElem*> >_storeList!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0). RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedListElem* createElement(TObject* obj, RooLinkedListElem* elem = 0); cout << ""RooLinkedList::createElem("" << this << "") obj = "" << obj << "" elem = "" << elem << endl ;. void deleteElement(RooLinkedListElem* ). RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'newArg'.; If 'oldArg' is not found in collection kFALSE is returned. TObject* FindObject(const char* name) const; Return pointer to obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinkedList.html:7215,hash,hash-table,7215,root/html532/RooLinkedList.html,https://root.cern,https://root.cern/root/html532/RooLinkedList.html,1,['hash'],['hash-table']
Security,"eted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:16883,checksum,checksum,16883,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,12,['checksum'],['checksum']
Security,"eted or; 191 TTree::ResetBranchAddress is called.; 192 ; 193Note: The pointer p_object must be initialized before calling TTree::Branch; 194- Do either:; 195~~~ {.cpp}; 196 MyDataClass* p_object = nullptr;; 197 tree.Branch(branchname, &p_object);; 198~~~; 199- Or:; 200~~~ {.cpp}; 201 auto p_object = new MyDataClass;; 202 tree.Branch(branchname, &p_object);; 203~~~; 204Whether the pointer is set to zero or not, the ownership of the object; 205is not taken over by the TTree. I.e. even though an object will be allocated; 206by TTree::Branch if the pointer p_object is zero, the object will <b>not</b>; 207be deleted when the TTree is deleted.; 208 ; 209\anchor addingacolumnoftclonesarray; 210## Add a column holding TClonesArray instances; 211 ; 212*It is recommended to use STL containers instead of TClonesArrays*.; 213 ; 214~~~ {.cpp}; 215 // clonesarray is the address of a pointer to a TClonesArray.; 216 auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); 217~~~; 218The TClonesArray is a direct access list of objects of the same class.; 219For example, if the TClonesArray is an array of TTrack objects,; 220this function will create one subbranch for each data member of; 221the object TTrack.; 222 ; 223\anchor fillthetree; 224## Fill the Tree; 225 ; 226A TTree instance is filled with the invocation of the TTree::Fill method:; 227~~~ {.cpp}; 228 tree.Fill(); 229~~~; 230Upon its invocation, a loop on all defined branches takes place that for each branch invokes; 231the TBranch::Fill method.; 232 ; 233\anchor addcoltoexistingtree; 234## Add a column to an already existing Tree; 235 ; 236You may want to add a branch to an existing tree. For example,; 237if one variable in the tree was computed with a certain algorithm,; 238you may want to try another algorithm and compare the results.; 239One solution is to add a new branch, fill it, and save the tree.; 240The code below adds a simple branch to an existing tree.; 241Note the kOverwrite option in the Write",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:10984,access,access,10984,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security,"eter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:16959,access,accessed,16959,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,6,['access'],['accessed']
Security,"eth, . Int_t ; offset, . const char * ; id, . const char * ; token, . TDatime ; expdate = kROOTTZERO, . void * ; ctx = nullptr, . Int_t ; key = 1 . ). Ctor for SecContext object. ; User and host from url = user@host . ; Definition at line 52 of file TRootSecContext.cxx. ◆ TRootSecContext() [2/2]. TRootSecContext::TRootSecContext ; (; const char * ; user, . const char * ; host, . Int_t ; meth, . Int_t ; offset, . const char * ; id, . const char * ; token, . TDatime ; expdate = kROOTTZERO, . void * ; ctx = nullptr, . Int_t ; key = 1 . ). Ctor for SecContext object. ; Definition at line 36 of file TRootSecContext.cxx. ◆ ~TRootSecContext(). TRootSecContext::~TRootSecContext ; (; ). virtual . Dtor: delete (deActivate, local/remote cleanup, list removal) all what is still active. ; Definition at line 67 of file TRootSecContext.cxx. Member Function Documentation. ◆ AsString(). const char * TRootSecContext::AsString ; (; TString & ; out). overridevirtual . Returns short string with relevant information about this security context. ; Reimplemented from TSecContext.; Definition at line 247 of file TRootSecContext.cxx. ◆ Class(). static TClass * TRootSecContext::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TRootSecContext::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TRootSecContext::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 51 of file TRootSecContext.h. ◆ CleanupSecContext(). Bool_t TRootSecContext::CleanupSecContext ; (; Bool_t ; all). overrideprivatevirtual . Ask remote client to cleanup security context 'ctx' If 'all', all sec context with the same host as ctx are cleaned. ; Reimplemented from TSecContext.; Definition at line 113 of file TRootSecContext.cxx. ◆ DeActivate(). void TRootSecContext::DeActivate ; (; Option_t * ; opt = ""CR""). overridevirtual . Set OffSet to -1 and expiring Date to default Remove from t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSecContext.html:14271,secur,security,14271,doc/master/classTRootSecContext.html,https://root.cern,https://root.cern/doc/master/classTRootSecContext.html,1,['secur'],['security']
Security,"ethod / constructor; 222 if (R__unlikely(!fModel)) {; 223 fModel = fSource->GetSharedDescriptorGuard()->CreateModel();; 224 ConnectModel(*fModel);; 225 }; 226 LoadEntry(index, fModel->GetDefaultEntry());; 227 }; 228 /// Fills a user provided entry after checking that the entry has been instantiated from the ntuple model; 229 void LoadEntry(NTupleSize_t index, REntry &entry) { entry.Read(index); }; 230 ; 231 /// Returns an iterator over the entry indices of the RNTuple.; 232 ///; 233 /// **Example: iterate over all entries and print each entry in JSON format**; 234 /// ~~~ {.cpp}; 235 /// #include <ROOT/RNTupleReader.hxx>; 236 /// using ROOT::Experimental::ENTupleShowFormat;; 237 /// using ROOT::Experimental::RNTupleReader;; 238 ///; 239 /// #include <iostream>; 240 ///; 241 /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 242 /// for (auto i : ntuple->GetEntryRange()) {; 243 /// ntuple->Show(i);; 244 /// }; 245 /// ~~~; 246 RNTupleGlobalRange GetEntryRange() { return RNTupleGlobalRange(0, GetNEntries()); }; 247 ; 248 /// Provides access to an individual field that can contain either a scalar value or a collection, e.g.; 249 /// GetView<double>(""particles.pt"") or GetView<std::vector<double>>(""particle""). It can as well be the index; 250 /// field of a collection itself, like GetView<NTupleSize_t>(""particle"").; 251 ///; 252 /// Raises an exception if there is no field with the given name.; 253 ///; 254 /// **Example: iterate over a field named ""pt"" of type `float`**; 255 /// ~~~ {.cpp}; 256 /// #include <ROOT/RNTupleReader.hxx>; 257 /// using ROOT::Experimental::RNTupleReader;; 258 ///; 259 /// #include <iostream>; 260 ///; 261 /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 262 /// auto pt = ntuple->GetView<float>(""pt"");; 263 ///; 264 /// for (auto i : ntuple->GetEntryRange()) {; 265 /// std::cout << i << "": "" << pt(i) << ""\n"";; 266 /// }; 267 /// ~~~; 268 template <typename T>; 269 RNTupleView<T> GetView(std::string_view fie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8hxx_source.html:10799,access,access,10799,doc/master/RNTupleReader_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html,1,['access'],['access']
Security,"ethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365////////////////////////////////////////////////////////////////////////////////; 7366/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7367/// classes in the class hierarchy that overload TObject::Hash do call; 7368/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7369/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7370 ; 7371Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7372{; 7373 return clRef.HasConsistentHashMember();; 7374}; 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:283345,access,access,283345,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['access']
Security,"ethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7419 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7420 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7421 ""TQClass"", ""TGlobal"" };; 7422 ; 7423 if (cname && cname[0]) {; 7424 for (auto cursor : handVerified) {; 7425 if (strcmp(cname, cursor) == 0); 7426 return true;; 7427 }; 7428 }; 7429 return false;; 7430}; 7431 ; 7432////////////////////////////////////////////////////////////////////////////////; 7433/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7434/// classes in the class hierarchy that overload TObject::Hash do call; 7435/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7436/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7437 ; 7438Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7439{; 7440 return clRef.HasConsistentHashMember();; 7441}; 7442 ; 7443////////////////////////////////////////////////////////////////////////////////; 7444/// Return true if we have access to a constructor usable for I/O. This is; 7445/// typically the default constructor but can also be a constructor specifically; 7446/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7447/// argument). In other words, if this routine returns true, TClass::New is; 7448/// guarantee to succeed.; 7449/// To know if the class described by this TClass has a default constructor; 7450/// (public or not), use; 7451/// \code{.cpp}; 7452/// cl->GetProperty() & kClassHasDefaultCtor; 7453/// \endcode; 7454/// To know if the class described by this TClass has a public default; 7455/// constructor use:; 7456/// \code{.cpp}; 7457/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7458/// \endcode; 7459 ; 7460Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7461{; 7462 ; 7463 if (fNew) return kTRUE;; 7464 ; 7465 if (HasInterpreterInfo()) {; 7466 R__LOCKGUARD(gInterpreterMutex);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:286096,access,access,286096,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['access']
Security,"ethod:; Int_t Myclass::Threadstart(){; if(!mTh){; mTh= new TThread(""memberfunction"",; (void(*)(void *))&Thread0,(void*) this);; mTh->Run();; return 0;; }; return 1;; }; Here mTh is a TThread* pointer which is member of Myclassand should be initialized to 0 in the constructor. The TThread constructor is called as when we used a plain C function above, except for the following two differences.; First, the member function Thread0 requires an explicit cast to (void(*) (void *)). This may cause an annoying but harmless compiler warning:; Myclass.cxx:98: warning:; converting from ""void (Myclass::*)(void *)""to ""void *"" ); Strictly speaking, Thread0 must be a static member function to be called from a thread. Some compilers, for example gcc version 2.95.2, may not allow the (void(*) (void*))s cast and just stop if Thread0 is not static. On the other hand, if Thread0 is static, no compiler warnings are generated at all. Because the 'this' pointer is passed in 'arg' in the call to Thread0(void *arg), you have access to the instance of the class even if Thread0 is static. Using the 'this' pointer, non static members can still be read and written from Thread0, as long as you have provided Getter and Setter methods for these members. For example:; Bool_t state = arg->GetRunStatus();; arg->SetRunStatus(state);; Second, the pointer to the current instance of Myclass, i.e. (void*) this, has to be passed as first argument of the threaded function Thread0 (C++ member functions internally expect this pointer as first argument to have access to class members of the same instance). pthreads are made for simple C functions and do not know about Thread0 being a member function of a class. Thus, you have to pass this information by hand, if you want to access all members of the Myclass instance from the Thread0 function.; Note: Method Thread0 cannot be a virtual member function, since the cast of Thread0 to void(*) in the TThread constructor may raise problems with C++ virtual function tabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1115086,access,access,1115086,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ethods of the; 21class/struct/namespace it represents. Conversely, if built through 3. or 1., it does not carry the information which is necessary; 22to ROOT to perform I/O of instances of the class/struct it represents.; 23The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all; 24the three are triggered, modifying the state of the TClass instance.; 25 ; 26In order to retrieve a TClass instance from the type system, a query can be executed as follows through the static; 27TClass::GetClass method:; 28 ; 29~~~ {.cpp}; 30auto myClassTClass_0 = TClass::GetClass(""myClass"");; 31auto myClassTClass_1 = TClass::GetClass<myClass>();; 32auto myClassTClass_2 = TClass::GetClass(myClassTypeInfo);; 33~~~; 34 ; 35The name of classes is crucial for ROOT. A careful procedure of *name normalization* is carried out for; 36each and every class. A *normalized name* is a valid C++ class name.; 37In order to access the name of a class within the ROOT type system, the method TClass::GetName() can be used.; 38*/; 39 ; 40//*-*x7.5 macros/layout_class; 41 ; 42#include ""TClass.h""; 43 ; 44#include ""strlcpy.h""; 45#include ""snprintf.h""; 46#include ""TBaseClass.h""; 47#include ""TBrowser.h""; 48#include ""TBuffer.h""; 49#include ""TClassGenerator.h""; 50#include ""TClassEdit.h""; 51#include ""TClassMenuItem.h""; 52#include ""TClassRef.h""; 53#include ""TClassTable.h""; 54#include ""TDataMember.h""; 55#include ""TDataType.h""; 56#include ""TDatime.h""; 57#include ""TEnum.h""; 58#include ""TError.h""; 59#include ""TExMap.h""; 60#include ""TFunctionTemplate.h""; 61#include ""THashList.h""; 62#include ""TInterpreter.h""; 63#include ""TMemberInspector.h""; 64#include ""TMethod.h""; 65#include ""TMethodArg.h""; 66#include ""TMethodCall.h""; 67#include ""TObjArray.h""; 68#include ""TObjString.h""; 69#include ""TProtoClass.h""; 70#include ""TROOT.h""; 71#include ""TRealData.h""; 72#include ""TCheckHashRecursiveRemoveConsistency.h"" // Private header; 73#include ""TStreamer.h""; 74#include ""TStreamerEl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:2203,access,access,2203,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['access'],['access']
Security,"etrieving the HTTP headers of this file. ; Uses TS3HTTPRequest to generate an HTTP HEAD request which includes the authorization header expected by the S3 server. ; Reimplemented from TWebFile.; Definition at line 287 of file TS3WebFile.cxx. ◆ GetObjectKey(). const TString & TS3WebFile::GetObjectKey ; (; ); const. inline . Definition at line 99 of file TS3WebFile.h. ◆ GetSecretKey(). const TString & TS3WebFile::GetSecretKey ; (; ); const. inline . Definition at line 97 of file TS3WebFile.h. ◆ GetUrl(). const TUrl & TS3WebFile::GetUrl ; (; ); const. inline . Definition at line 100 of file TS3WebFile.h. ◆ IsA(). TClass * TS3WebFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFile.; Definition at line 105 of file TS3WebFile.h. ◆ ParseOptions(). Bool_t TS3WebFile::ParseOptions ; (; Option_t * ; options, . TString & ; accessKey, . TString & ; secretKey, . TString & ; token . ). private . Extracts the S3 authentication key pair (access key and secret key) from the options. ; The authentication credentials can be specified in the options provided to the constructor of this class as a string containing: ""AUTH=<access key>:<secret key>"" and can include other options, for instance ""NOPROXY"" for not using the HTTP proxy for accessing this file's contents. For instance: ""NOPROXY AUTH=F38XYZABCDeFgHiJkLm:V+frt4re7J1euSNFnmaf8wwmI401234E7kzxZ/TTM+"" A security token may be given by the TOKEN option, in order to allow the use of a temporary key pair. ; Definition at line 255 of file TS3WebFile.cxx. ◆ ProcessHttpHeader(). void TS3WebFile::ProcessHttpHeader ; (; const TString & ; headerLine). overrideprotectedvirtual . This method is called by the super-class TWebFile when a HTTP header for this file is retrieved. ; We scan the 'Server' header to detect the type of S3 server this file is hosted on and to determine if it is known to support multi-range HTTP GET requests. Some S3 servers (for instance Amazon's) do not suppor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:53935,authenticat,authentication,53935,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,2,"['access', 'authenticat']","['access', 'authentication']"
Security,"eturn (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(DataMemberInfo_t* info, bool skipChecks = kFALSE); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object of class TListOfDataMembers. void Update(TDictionary* member); Move the member or data member to the expect set of list. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TDictionary* member); Mark 'func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfDataMembers(const TListOfDataMembers& ). TListOfDataMembers& operator=(const TListOfDat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfDataMembers.html:14754,hash,hash,14754,root/html604/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html,1,['hash'],['hash']
Security,"eturns a global/linear bin number.; Int_t bin = h->GetBin(binx, biny, binz);; This global bin is useful to access the bin information independently of the dimension.; 3.3.2 Re-binning. At any time, a histogram can be re-binned via the TH1::Rebin() method. It returns a new histogram with the re-binned contents. If bin errors were stored, they are recomputed during the re-binning.; 3.4 Filling Histograms; A histogram is typically filled with statements like:; h1->Fill(x);; h1->Fill(x,w); // with weight; h2->Fill(x,y);; h2->Fill(x,y,w);; h3->Fill(x,y,z);; h3->Fill(x,y,z,w);; The Fill method computes the bin number corresponding to the given x, y or z argument and increments this bin by the given weight. The Fill() method returns the bin number for 1-D histograms or global bin number for 2-D and 3-D histograms. If TH1::Sumw2() has been called before filling, the sum of squares is also stored. One can increment a bin number directly by calling TH1::AddBinContent(), replace the existing content via TH1::SetBinContent() , and access the bin content of a given bin via TH1::GetBinContent() .; Double_t binContent = h->GetBinContent(bin);; 3.4.1 Automatic Re-binning Option; By default, the number of bins is computed using the range of the axis. You can change this to re-bin automatically by setting the automatic re-binning option:; h->SetBit(TH1::kCanRebin);. Once this is set, the Fill() method will automatically extend the axis range to accommodate the new value specified in the Fill() argument. The used method is to double the bin size until the new value fits in the range, merging bins two by two. The TTree::Draw() method extensively uses this automatic binning option when drawing histograms of variables in TTree with an unknown range. The automatic binning option is supported for 1-D, 2-D and 3-D histograms. During filling, some statistics parameters are incremented to compute the mean value and root mean square with the maximum precision. In case of histograms of type TH1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:77050,access,access,77050,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"eturns number of bytes sent, or -1 in case of error. ;  ; static Int_t SendRSAPublicKey (TSocket *Socket, Int_t key=0);  Receives server RSA Public key Sends local RSA public key encoded. ;  ; static void SetAuthReUse (Bool_t authreuse);  Set global AuthReUse flag. ;  ; static void SetDefaultRSAKeyType (Int_t key);  Static method setting the default type of RSA key. ;  ; static void SetDefaultUser (const char *defaultuser);  Set default user name. ;  ; static void SetGlobalExpDate (TDatime expdate);  Set default expiring date for new validity contexts. ;  ; static void SetGlobalPasswd (const char *passwd);  Set global passwd to be used for authentication to rootd or proofd. ;  ; static void SetGlobalPwHash (Bool_t pwhash);  Set global passwd hash flag to be used for authentication to rootd or proofd. ;  ; static void SetGlobalSRPPwd (Bool_t srppwd);  Set global SRP passwd flag to be used for authentication to rootd or proofd. ;  ; static void SetGlobalUser (const char *user);  Set global user name to be used for authentication to rootd or proofd. ;  ; static void SetGlobusAuthHook (GlobusAuth_t func);  Set Globus authorization function. ;  ; static void SetKrb5AuthHook (Krb5Auth_t func);  Set kerberos5 authorization function. ;  ; static void SetPromptUser (Bool_t promptuser);  Set global PromptUser flag. ;  ; static void SetReadHomeAuthrc (Bool_t readhomeauthrc);  Set flag controlling the reading of $HOME/.rootauthrc. ;  ; static void SetRSAInit (Int_t init=1);  Static method setting RSA initialization flag. ;  ; static Int_t SetRSAPublic (const char *rsapubexport, Int_t klen);  Store RSA public keys from export string rsaPubExport. ;  ; static void SetSecureAuthHook (SecureAuth_t func);  Set secure authorization function. ;  ; static void SetTimeOut (Int_t to);  Set timeout (active if > 0) ;  ; static void Show (Option_t *opt=""S"");  Print info about the authentication sector. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:15467,authenticat,authentication,15467,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"eturns returns zero if the two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. V.Perev. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?"". Bool_t MaybeWildcard() const; Returns true if string contains one of the wildcard characters ""[]*?"". TString& Prepen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TString.html:10931,hash,hash,10931,root/html530/TString.html,https://root.cern,https://root.cern/root/html530/TString.html,2,['hash'],['hash']
Security,"etwork on CPU using batches with size = 100; : ; TMVA_DNN_CPU : [dataset] : Evaluation of TMVA_DNN_CPU on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.0796 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_DNN_CPU.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_DNN_CPU.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_CNN_CPU for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 7 Input = ( 1, 16, 16 ) Batch size = 100 Loss function = C; Layer 0 CONV LAYER: ( W = 16 , H = 16 , D = 10 ) Filter ( W = 3 , H = 3 ) Output = ( 100 , 10 , 10 , 256 ) Activation Function = Relu; Layer 1 BATCH NORM Layer: Input/Output = ( 10 , 256 , 100 ) Norm dim = 10 axis = 1; ; Layer 2 CONV LAYER: ( W = 16 , H = 16 , D = 10 ) Filter ( W = 3 , H = 3 ) Output = ( 100 , 10 , 10 , 256 ) Activation Function = Relu; Layer 3 POOL Layer: ( W = 15 , H = 15 , D = 10 ) Filter ( W = 2 , H = 2 ) Output = ( 100 , 10 , 10 , 225 ) ; Layer 4 RESHAPE Layer Input = ( 10 , 15 , 15 ) Output = ( 1 , 100 , 2250 ) ; Layer 5 DENSE Layer: ( Input = 2250 , Width = 100 ) Output = ( 1 , 100 , 100 ) Activation Function = Relu; Layer 6 DENSE Layer: ( Input = 100 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 1280 events for training and 320 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 13.2274; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 1.28042 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:13992,validat,validation,13992,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['validat'],['validation']
Security,"eveloped in the “Bazaar style”, a term from the book “The Cathedral and the Bazaar” by Eric S. Raymond. It means a liberal, informal development style that heavily relies on the diverse and deep talent of the user community. The result is that physicists developed ROOT for themselves; this made it specific, appropriate, useful, and over time refined and very powerful. The development of ROOT is a continuous conversation between users and developers with the line between the two blurring at times and the users becoming co-developers.; When it comes to storing and mining large amount of data, physics plows the way with its Terabytes, but other fields and industry follow close behind as they acquiring more and more data over time. They are ready to use the true and tested technologies physics has invented. In this way, other fields and industries have found ROOT useful and they have started to use it also.; In the bazaar view, software is released early and frequently to expose it to thousands of eager co-developers to pound on, report bugs, and contribute possible fixes. More users find more bugs, because they stress the program in different ways. By now, after ten years, the age of ROOT is quite mature. Most likely, you will find the features you are looking for, and if you have found a hole, you are encouraged to participate in the dialog and post your suggestion or even implementation on the ROOT forum.; 1.1 The ROOT forum; If you have a question, it is likely that it has been asked, answered, and stored in the ROOT Forum. Please use the search engine to see if your question has already been answered before posting a topic in the Forum.; You can access the ROOT forum at: https://root-forum.cern.ch.; 1.2 Contact Information; Several authors wrote this book and you may see a “change of voice” from one chapter to the next. We felt we could accept this in order to have the expert explain what they know best. If you would like to contribute a chapter or add to a section,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:7744,expose,expose,7744,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['expose'],['expose']
Security,"event every 3; auto d15each3 = d.Range(0, 15, 3);; Note that ranges are not available when multi-threading is enabled. More information on ranges is available here. Executing multiple actions in the same event loop; As a final example let us apply two different cuts on branch ""MET"" and fill two different histograms with the ""pt_v"" of the filtered events. By now, you should be able to easily understand what is happening: RDataFrame d(""treeName"", ""file.root"");; auto h1 = d.Filter(""MET > 10"").Histo1D(""pt_v"");; auto h2 = d.Histo1D(""pt_v"");; h1->Draw(); // event loop is run once here; h2->Draw(""SAME""); // no need to run the event loop again; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; h1TH1F * h1Definition legend1.C:5; RDataFrame executes all above actions by running the event-loop only once. The trick is that actions are not executed at the moment they are called, but they are lazy, i.e. delayed until the moment one of their results is accessed through the smart pointer. At that time, the event loop is triggered and all results are produced simultaneously. Properly exploiting RDataFrame laziness; For yet another example of the difference between the correct and incorrect running of the event-loop, see the following two code snippets. We assume our ROOT file has branches a, b and c.; The correct way - the dataset is only processed once. df_correct = ROOT.RDataFrame(treename, filename);; ; h_a = df_correct.Histo1D(""a""); h_b = df_correct.Histo1D(""b""); h_c = df_correct.Histo1D(""c""); ; h_a_val = h_a.GetValue(); h_b_val = h_b.GetValue(); h_c_val = h_c.GetValue(); ; print(f""How many times was the data set processed? {df_wrong.GetNRuns()} time."") # The answer will be 1 time. ; An incorrect way - the dataset is processed three times. df_incorrect = ROOT.RDataFrame(treename, filename);; ; h_a = df_incorrect.Histo1D(""a""); h_a_val = h_a.GetValue(); ; h_b = df_incorrect.Histo1D(""b""); h_b_val = h_b.GetValue(); ; h_c = df_in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:25694,access,accessed,25694,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['access'],['accessed']
Security,"event every 3; auto d15each3 = d.Range(0, 15, 3);; Note that ranges are not available when multi-threading is enabled. More information on ranges is available here. Executing multiple actions in the same event loop; As a final example let us apply two different cuts on branch ""MET"" and fill two different histograms with the ""pt_v"" of the filtered events. By now, you should be able to easily understand what is happening: RDataFrame d(""treeName"", ""file.root"");; auto h1 = d.Filter(""MET > 10"").Histo1D(""pt_v"");; auto h2 = d.Histo1D(""pt_v"");; h1->Draw(); // event loop is run once here; h2->Draw(""SAME""); // no need to run the event loop again; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; h1TH1F * h1Definition legend1.C:5; RDataFrame executes all above actions by running the event-loop only once. The trick is that actions are not executed at the moment they are called, but they are lazy, i.e. delayed until the moment one of their results is accessed through the smart pointer. At that time, the event loop is triggered and all results are produced simultaneously.; It is therefore good practice to declare all your transformations and actions before accessing their results, allowing RDataFrame to run the loop once and produce all results in one go. Going parallel; Let's say we would like to run the previous examples in parallel on several cores, dividing events fairly between cores. The only modification required to the snippets would be the addition of this line before constructing the main dataframe object: ROOT::EnableImplicitMT();; Simple as that. More details are given below. Working with collections and object selections; RDataFrame reads collections as the special type ROOT::RVec: for example, a column containing an array of floating point numbers can be read as a ROOT::RVecF. C-style arrays (with variable or static size), STL vectors and most other collection types can be read this way.; RVec is a container sim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:25305,access,accessed,25305,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['access'],['accessed']
Security,"evirtual . Definition at line 257 of file TH1.h. ◆ GetBin(). Int_t TH1::GetBin ; (; Int_t ; binx, . Int_t ; biny = 0, . Int_t ; binz = 0 . ); const. virtual . Return Global bin number corresponding to binx,y,z. ; 2-D and 3-D histograms are represented with a one dimensional structure. This has the advantage that all existing functions, such as GetBinContent, GetBinError, GetBinFunction work for all dimensions.; In case of a TH1x, returns binx directly. see TH1::GetBinXYZ for the inverse transformation.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined. For example, assuming a 3-D histogram with binx,biny,binz, the function; Int_t bin = h->GetBin(binx,biny,binz);; returns a global/linearized bin number. This global bin is useful to access the bin information independently of the dimension. ; Reimplemented in TH3, and TH2.; Definition at line 4961 of file TH1.cxx. ◆ GetBinCenter(). Double_t TH1::GetBinCenter ; (; Int_t ; bin); const. virtual . Return bin center for 1D histogram. ; Better to use h1.GetXaxis()->GetBinCenter(bin) ; Definition at line 9141 of file TH1.cxx. ◆ GetBinContent() [1/3]. Double_t TH1::GetBinContent ; (; Int_t ; bin); const. virtual . Return content of bin number bin. ; Implemented in TH1C,S,F,D; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined. For example, assuming a 3-D histogram with binx,biny,binz, the function; Int_t bin = h->GetBin(binx,biny,binz);; returns a global/linearized bin number. This global bin is useful to access the bin information independently o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:147574,access,access,147574,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['access'],['access']
Security,"evirtual . ReturnsTClass describing current object ; Reimplemented from TColorGradient.; Definition at line 113 of file TColorGradient.h. ◆ SetStartEnd(). void TLinearGradient::SetStartEnd ; (; const Point & ; p1, . const Point & ; p2 . ). Set end and start. ; Definition at line 208 of file TColorGradient.cxx. ◆ Streamer(). void TLinearGradient::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TColorGradient. ◆ StreamerNVirtual(). void TLinearGradient::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 113 of file TColorGradient.h. ◆ TColorGradient() [1/3]. TColorGradient::TColorGradient ; (; ). inline . Definition at line 70 of file TColorGradient.h. ◆ TColorGradient() [2/3]. TColorGradient::TColorGradient ; (; Color_t ; newColor, . UInt_t ; nPoints, . const Double_t * ; points, . const Color_t * ; colorIndices, . ECoordinateMode ; mode = kObjectBoundingMode . ). There is no way to validate parameters here, so it's up to user to pass correct arguments. ; Definition at line 71 of file TColorGradient.cxx. ◆ TColorGradient() [3/3]. TColorGradient::TColorGradient ; (; Color_t ; newColor, . UInt_t ; nPoints, . const Double_t * ; points, . const Double_t * ; colors, . ECoordinateMode ; mode = kObjectBoundingMode . ). There is no way to validate parameters here, so it's up to user to pass correct arguments. ; Definition at line 73 of file TColorGradient.cxx. Member Data Documentation. ◆ fEnd. Point TLinearGradient::fEnd. private . Definition at line 111 of file TColorGradient.h. ◆ fStart. Point TLinearGradient::fStart. private . Definition at line 110 of file TColorGradient.h. Libraries for TLinearGradient:. [legend]; The documentation for this class was generated from the following files:; core/base/inc/TColorGradient.h; core/base/src/TColorGradient.cxx. TLinearGradient. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:55 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearGradient.html:23905,validat,validate,23905,doc/master/classTLinearGradient.html,https://root.cern,https://root.cern/doc/master/classTLinearGradient.html,2,['validat'],['validate']
Security,"ew TCanvas(""c"",""Marker colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Color transparency; SetMarkerColorAlpha(), allows to set a transparent color.; In the following example the marker color of the histogram histo; is set to blue with a transparency of 35%. The color kBlue; itself remains fully opaque. . histo->SetMarkerColorAlpha(kBlue, 0.35);. ; The transparency is available on all platforms when the flagOpenGL.CanvasPreferGL is set to 1; in $ROOTSYS/etc/system.rootrc, or on Mac with the Cocoa backend. On the file output; it is visible with PDF, PNG, Gif, JPEG, SVG ... but not PostScript.; Marker style; The Marker style defines the markers' shape.; The marker style of any class inheriting from TAttMarker can; be changed using the method SetMarkerStyle and retrieved using the; method GetMarkerStyle.; The following list gives the currently supported markers (screen; and PostScript) style. Each marker style is identified by an integer number; (first column) corresponding to a marker shape (second column) and can be also; accessed via a global name (third column). Marker number Marker shape Marker name; 1 dot kDot; 2 + kPlus; 3 * kStar; 4 o kCircle; 5 x kMultiply; 6 small dot kFullDotSmall; 7 medium dot kFullDotMedium; 8 large scalable dot kFullDotLarge; 9 -->19 large scalable dot; 20 full circle kFullCircle; 21 full square kFullSquare; 22 full triangle up kFullTriangleUp; 23 full triangle down kFullTriangleDown; 24 open circle kOpenCircle; 25 open square kOpenSquare; 26 open triangle up kOpenTriangleUp; 27 open diamond kOpenDiamond; 28 open cross kOpenCross; 29 full star kFullStar; 30 open star kOpenStar; 31 *; 32 open triangle down; 33 full diamond; 34 full cross. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; TMarker marker;; marker.DisplayMarkerTypes();; return c;; }. Marker size; Various marker sizes are shown in the figure below. The default marker size=1; is shown in the top left corner. Marker sizes smaller than 1 can ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAttMarker.html:1917,access,accessed,1917,root/html534/TAttMarker.html,https://root.cern,https://root.cern/root/html534/TAttMarker.html,1,['access'],['accessed']
Security,"ew TGeoRotation(""r2"",90,0,45,90,45,270);; r2->RegisterYourself();; // create a composite; TGeoCompositeShape *cs = new TGeoCompositeShape(""cs"",; ""((T+T:r1)-(P+P:r1))*B:r2"");; TGeoVolume *comp = new TGeoVolume(""COMP"",cs);; comp->SetLineColor(5);. // put it in the top volume; top->AddNode(comp,1);; mgr->CloseGeometry();; // visualize it with ray tracing; top->Raytrace();. A composite shape example. Composite shapes can be subsequently used for defining volumes. Moreover, these volumes contain other volumes, following the general criteria. Volumes created based on composite shapes cannot be divided.; 18.3.4 Navigation Methods Performed By Shapes; Shapes are named objects and register themselves to the manager class at creation time. This is responsible for their final deletion. Shapes can be created without name if their retrieval by name is no needed. Generally shapes are objects that are useful only at geometry creation stage. The pointer to a shape is in fact needed only when referring to a given volume and it is always accessible at that level. Several volumes may reference a single shape; therefore its deletion is not possible once volumes were defined based on it.; The navigation features related for instance to tracking particles are performed in the following way: Each shape implement its specific algorithms for all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:921393,access,accessible,921393,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessible']
Security,"ew directory dir. dir can be 0 in which case the list; 354/// does not belong to any directory.; 355 ; 356void TEventList::SetDirectory(TDirectory *dir); 357{; 358 if (fDirectory == dir) return;; 359 if (fDirectory) fDirectory->Remove(this);; 360 fDirectory = dir;; 361 if (fDirectory) fDirectory->Append(this);; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Change the name of this TEventList.; 366 ; 367void TEventList::SetName(const char *name); 368{; 369 // TEventLists are named objects in a THashList.; 370 // We must update the hashlist if we change the name; 371 if (fDirectory) fDirectory->Remove(this);; 372 fName = name;; 373 if (fDirectory) fDirectory->Append(this);; 374}; 375 ; 376////////////////////////////////////////////////////////////////////////////////; 377/// Sort list entries in increasing order; 378 ; 379void TEventList::Sort(); 380{; 381 Int_t *index = new Int_t[fN];; 382 Long64_t *newlist = new Long64_t[fSize];; 383 Int_t i,ind;; 384 TMath::Sort(fN,fList,index); //sort in decreasing order; 385 for (i=0;i<fN;i++) {; 386 ind = index[fN-i-1];; 387 newlist[i] = fList[ind];; 388 }; 389 for (i=fN;i<fSize;i++) {; 390 newlist[i] = 0;; 391 }; 392 delete [] index;; 393 delete [] fList;; 394 fList = newlist;; 395}; 396 ; 397////////////////////////////////////////////////////////////////////////////////; 398/// Stream an object of class TEventList.; 399 ; 400void TEventList::Streamer(TBuffer &b); 401{; 402 if (b.IsReading()) {; 403 UInt_t R__s, R__c;; 404 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 405 fDirectory = nullptr;; 406 if (R__v > 1) {; 407 b.ReadClassBuffer(TEventList::Class(), this, R__v, R__s, R__c);; 408 ResetBit(kMustCleanup);; 409 return;; 410 }; 411 //====process old versions before automatic schema evolution; 412 TNamed::Streamer(b);; 413 b >> fN;; 414 b >> fSize;; 415 b >> fDelta;; 416 if (fN) {; 417 Int_t *tlist = new Int_t[fSize];; 418 b.ReadFastArray(tlist,fN);; 419 fList = new ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEventList_8cxx_source.html:11476,hash,hashlist,11476,doc/master/TEventList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html,1,['hash'],['hashlist']
Security,"ew file and open it for writing, if the file already exists the file is not opened. . RECREATE Create a new file, if the file already exists it will be overwritten. . UPDATE Open an existing file for writing. If no file exists, it is created. . READ Open an existing file for reading (default). . NET Used by derived remote file access classes, not a user callable option. . WEB Used by derived remote http access class, not a user callable option. . READ_WITHOUT_GLOBALREGISTRATION Used by TTreeProcessorMT, not a user callable option. . If option = """" (default), READ is assumed. The file can be specified as a URL of the form: file:///user/rdm/bla.root or file:/user/rdm/bla.root; The file can also be a member of an archive, in which case it is specified as: multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip archive or member 1 from the archive. For more on archive file support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any file, i.e. also non ROOT files, using: file.tar?filetype=raw; This is convenient because the many remote file access plugins allow easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and directories. There are no restrictions for the number of levels of directories. A ROOT file is designed such that one can write in the file in pure sequential mode (case of BATCH jobs). In this case, the file may be read sequentially again without using the file index written at the end of the file. In case of a job crash, all the information on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the possibility to delete existing objects and add new ones. When an object is deleted from the file, the freed space is added into the FREE linked list (fFree). The FREE list consists of a chain of consecuti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:49099,access,access,49099,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['access'],['access']
Security,"ew name, RooStringView title, const RooArgSet &vars, const char *wgtVarName=nullptr);  ;  RooVectorDataStore (RooStringView name, RooStringView title, RooAbsDataStore &tds, const RooArgSet &vars, const RooFormulaVar *cutVar, const char *cutRange, std::size_t nStart, std::size_t nStop, const char *wgtVarName=nullptr);  ;  ~RooVectorDataStore () override;  Destructor. ;  ; RooAbsArg * addColumn (RooAbsArg &var, bool adjustRange=true) override;  Add a new column to the data set which holds the pre-calculated values of 'newVar'. ;  ; void append (RooAbsDataStore &other) override;  ; void attachBuffers (const RooArgSet &extObs) override;  ; void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars) override;  Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ;  ; const RooVectorDataStore * cache () const;  ; void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=true) override;  Cache given RooAbsArgs: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ;  ; const RooAbsArg * cacheOwner () override;  ; std::vector< CatVector * > & catStoreList ();  ; bool changeObservableName (const char *from, const char *to) override;  ; RooAbsDataStore * clone (const char *newname=nullptr) const override;  ; RooAbsDataStore * clone (const RooArgSet &vars, const char *newname=nullptr) const override;  ; void dump () override;  ; Int_t fill () override;  Interface function to TTree::Fill. ;  ; virtual const RooArgSet * get () const;  ; const RooArgSet * get (Int_t index) const override;  Load the n-th data point (n='index') into the variables of this dataset, and return a pointer to the RooArgSet that holds them. ;  ; virtual const RooArgSet * get (Int_t index) const=0;  ; RooAbsData::RealSpans getBatches (std::size_t first, std::size_t len) const override;  Return batches of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:2833,access,access,2833,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['access'],['access']
Security,"ew.h. ◆ GetDefaultSize(). TGDimension TGView::GetDefaultSize ; (; ); const. inlineoverridevirtual . std::cout << fWidth << ""x"" << fHeight << std::endl; ; Reimplemented from TGCompositeFrame.; Definition at line 87 of file TGView.h. ◆ GetScrollPosition(). TGLongPosition TGView::GetScrollPosition ; (; ); const. inline . Definition at line 90 of file TGView.h. ◆ GetScrollValue(). TGLongPosition TGView::GetScrollValue ; (; ); const. inline . Definition at line 89 of file TGView.h. ◆ GetViewWhiteGC(). const TGGC & TGView::GetViewWhiteGC ; (; ). inline . Definition at line 103 of file TGView.h. ◆ GetVirtualSize(). TGDimension TGView::GetVirtualSize ; (; ); const. inline . Definition at line 88 of file TGView.h. ◆ HandleButton(). Bool_t TGView::HandleButton ; (; Event_t * ; event). overridevirtual . handle button ; Reimplemented from TGCompositeFrame.; Definition at line 237 of file TGView.cxx. ◆ HandleExpose(). Bool_t TGView::HandleExpose ; (; Event_t * ; event). overridevirtual . Handle expose events. ; Reimplemented from TGWindow.; Definition at line 284 of file TGView.cxx. ◆ IsA(). TClass * TGView::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGCompositeFrame.; Definition at line 105 of file TGView.h. ◆ ItemLayout(). virtual Bool_t TGView::ItemLayout ; (; ). inlineprotectedvirtual . Reimplemented in TGHtml.; Definition at line 51 of file TGView.h. ◆ Layout(). void TGView::Layout ; (; ). overridevirtual . layout view ; Reimplemented from TGCompositeFrame.; Definition at line 346 of file TGView.cxx. ◆ operator=(). TGView & TGView::operator= ; (; const TGView & ; ). privatedelete . ◆ ProcessMessage(). Bool_t TGView::ProcessMessage ; (; Longptr_t ; msg, . Longptr_t ; parm1, . Longptr_t ; parm2 . ). overridevirtual . Process scrollbar messages. ; Reimplemented from TGCompositeFrame.; Definition at line 316 of file TGView.cxx. ◆ ScrollCanvas(). void TGView::ScrollCanvas ; (; Int_t ; newTop, . Int_t ; direction . ). v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGView.html:38259,expose,expose,38259,doc/master/classTGView.html,https://root.cern,https://root.cern/doc/master/classTGView.html,1,['expose'],['expose']
Security,"ewShape, this->GetLayout(), fDevice, fStreamIndx);; 356 return tmp;; 357 }; 358 ; 359 void SetTensorDescriptor();; 360 ; 361 // return slice of tensor; 362 // return slices in the first dimension (if row wise) or last dimension if column wise; 363 // so single event slides; 364 TCudaTensor<AFloat> At(size_t i) const {; 365 Shape_t sliced_shape = (GetLayout() == MemoryLayout::RowMajor); 366 ? Shape_t(fShape.begin() + 1, fShape.end()) :; 367 Shape_t(fShape.begin(), fShape.end() - 1);; 368 ; 369 ; 370 size_t buffsize = (GetLayout() == MemoryLayout::RowMajor) ?; 371 fStrides.front() : fStrides.back();; 372 ; 373 size_t offset = i * buffsize;; 374 ; 375 return TCudaTensor<AFloat>((const_cast<TCudaDeviceBuffer<AFloat>&>(fElementBuffer)).GetSubBuffer(offset, buffsize), sliced_shape, GetLayout());; 376 }; 377 ; 378 ; 379 // element access ( for debugging); 380 TCudaDeviceReference<AFloat> operator()(size_t i, size_t j) const; 381 {; 382 // like this works also for multi-dim tensors; 383 // and consider the tensor as a multidim one; 384 size_t nrows = GetNrows();; 385 size_t ncols = GetNcols();; 386 ; 387 size_t offset = (GetLayout() == MemoryLayout::RowMajor) ?; 388 i * ncols + j : j * nrows + i;; 389 ; 390 AFloat * elementPointer = fElementBuffer.data() + offset;; 391 return TCudaDeviceReference<AFloat>(elementPointer);; 392 }; 393 // element access ( for debugging); 394 TCudaDeviceReference<AFloat> operator()(size_t i, size_t j, size_t k) const; 395 {; 396 // k is B, i is C, j is HW :; 397 assert( fNDim >= 3); // || ( k==0 && fNDim == 2 ) );; 398 //note for larger dimension k is all other dims collapsed !!!; 399 ; 400 size_t offset = (GetLayout() == MemoryLayout::RowMajor) ?; 401 i * fStrides[0] + j * fStrides[1] + k :; 402 i * fStrides[2] + k * fStrides[1] + j;; 403 ; 404 AFloat * elementPointer = fElementBuffer.data() + offset;; 405 ; 406 return TCudaDeviceReference<AFloat>(elementPointer);; 407 }; 408 ; 409 TCudaDeviceReference<AFloat> operator()(size_t i, size_t j, siz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaTensor_8h_source.html:14838,access,access,14838,doc/master/CudaTensor_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaTensor_8h_source.html,1,['access'],['access']
Security,"example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:20057,authenticat,authentication,20057,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,1,['authenticat'],['authentication']
Security,"existing Return -1 in case of error (not found; not created), 0 otherwise. ; Definition at line 534 of file TPackMgr.cxx. ◆ GetEnabledPackages(). void TPackMgr::GetEnabledPackages ; (; TString & ; packlist). Method to get a semi-colon separated list with the names of the enabled packages. ; Definition at line 501 of file TPackMgr.cxx. ◆ GetList(). TList * TPackMgr::GetList ; (; ); const. Get list of available packages Returns a pointer to a TList object, transferring ownership to the caller. ; Definition at line 621 of file TPackMgr.cxx. ◆ GetListOfEnabled(). TList * TPackMgr::GetListOfEnabled ; (; ); const. Get list of enabled packages Returns a pointer to a TList object, transferring ownership to the caller. ; Definition at line 644 of file TPackMgr.cxx. ◆ GetLock(). TLockPath * TPackMgr::GetLock ; (; ). inline . Definition at line 65 of file TPackMgr.h. ◆ GetMD5(). TMD5 * TPackMgr::GetMD5 ; (; const char * ; pack). Get MD5 checksum of the PAR file corresponding to given package Returns a pointer to a TMD5 object, transferring ownership to the caller. ; Definition at line 692 of file TPackMgr.cxx. ◆ GetName(). const char * TPackMgr::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TNamed.; Definition at line 61 of file TPackMgr.h. ◆ GetPackDir(). Int_t TPackMgr::GetPackDir ; (; const char * ; pack, . TString & ; pdir . ). Method to get the path of the dir for package 'pack'. ; Return -1 in case of error (not found), 0 otherwise ; Definition at line 487 of file TPackMgr.cxx. ◆ GetPackMgr(). TPackMgr * TPackMgr::GetPackMgr ; (; const char * ; pack, . TPackMgr * ; packmgr = nullptr . ). static . Get the package manager having 'pack'; priority is given to packmgr, if defined. ; Returns packmgr or nullptr ; Definition at line 912 of file TPackMgr.cxx. ◆ GetParPath(). Int_t TPackMgr::GetParPath ; (; const char * ; pack, .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:18300,checksum,checksum,18300,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['checksum'],['checksum']
Security,"ext.h:42; TAttText::fTextAngleFloat_t fTextAngleText angle.Definition TAttText.h:21; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::fTextFontFont_t fTextFontText font.Definition TAttText.h:25; TAttText::fTextSizeFloat_t fTextSizeText size.Definition TAttText.h:22; TColorThe color creation and management class.Definition TColor.h:21; TColor::GetRedFloat_t GetRed() constDefinition TColor.h:60; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::GetBlueFloat_t GetBlue() constDefinition TColor.h:62; TColor::GetGreenFloat_t GetGreen() constDefinition TColor.h:61; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TExMapIterDefinition TExMap.h:85; TExMapIter::NextBool_t Next(ULong64_t &hash, Long64_t &key, Long64_t &value)Get next entry from TExMap. Returns kFALSE at end of map.Definition TExMap.cxx:412; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGX11::DrawFillAreavoid DrawFillArea(Int_t n, TPoint *xy) overrideFill area described by polygon.Definition TGX11.cxx:589; TGX11::fDisplayvoid * fDisplayPointer to display.Definition TGX11.h:125; TGX11::MakeOpaqueColorsvoid MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors)Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors.Definition TGX11.cxx:2974",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:143410,hash,hash,143410,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['hash'],['hash']
Security,"extColor(kBlue+2);; ; TLatex tex2;; tex2.SetNDC();; tex2.SetTextFont(102);; tex2.SetTextSize(0.07*f);; tex2.SetTextColor(kOrange+3);; ; time_t offset[] = {0, 0, 1325376000, 1341100800};; time_t t[] = {1331150400, 1336417200, 0, 36000};; ; c->SetTopMargin(0); c->SetBottomMargin(0);; c->SetLeftMargin(0); c->SetRightMargin(0);; c->Divide(2, 4, -1, -1);; TLine l;; l.DrawLine(0.5, 0, 0.5, 1.);; ; for(int i = 0; i < 4; ++i){; for(int gmt = 0; gmt < 2; ++gmt){; const char* opt = (gmt ? ""gmt"" : ""local"");; TVirtualPad* p = c->cd(2*i + gmt + 1);; p->SetTopMargin(0); p->SetBottomMargin(0);; p->SetLeftMargin(0); p->SetRightMargin(0);; p->SetFillStyle(4000);; ; TGaxis* ga = new TGaxis (.4, .25, 5., .25, t[i], t[i] + 1, 1, ""t"");; ga->SetTimeFormat(""TGaxis label: #color[2]{%Y-%m-%d %H:%M:%S}"");; ga->SetLabelFont(102);; ga->SetLabelColor(kBlue+2);; ; ga->SetTimeOffset(offset[i], opt);; ga->SetLabelOffset(0.04*f);; ga->SetLabelSize(0.07*f);; ga->SetLineColor(0);; ga->Draw();; ; // Get offset string of axis time format: there is not accessor; // to time format in TGaxis.; // Assumes TAxis use the same format.; TAxis a(10, 0, 1600000000);; a.SetTimeOffset(offset[i], opt);; const char* offsettimeformat = a.GetTimeFormat();; ; char buf[256];; if (offset[i] < t[i]) {; snprintf(buf, 256, ""#splitline{%s, %s}{offset: %ld, option %s}"",; stime(t+i).Data(), stime(t+i, true).Data(), offset[i], opt);; } else {; int h = t[i] / 3600;; int m = (t[i] - 3600 * h) / 60 ;; int s = (t[i] - h * 3600 - m * 60);; snprintf(buf, 256, ""#splitline{%d h %d m %d s}{offset: %s, option %s}"",; h, m, s, stime(offset + i, gmt).Data(), opt);; }; tex1.DrawLatex(.01, .75, buf);; tex2.DrawLatex(.01, .50, offsettimeformat);; time_t t_ = t[i] + offset[i];; snprintf(buf, 256, ""Expecting: #color[2]{%s}"", stime(&t_, gmt, false).Data());; tex3.DrawLatex(.01, .24, buf);; if(i > 0) l.DrawLine(0, 0.95, 1, 0.95);; }; }; }; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/timeonaxis3_8C.html:2234,access,accessor,2234,doc/master/timeonaxis3_8C.html,https://root.cern,https://root.cern/doc/master/timeonaxis3_8C.html,1,['access'],['accessor']
Security,"extColor(kBlue+2);; ; TLatex tex2;; tex2.SetNDC();; tex2.SetTextFont(102);; tex2.SetTextSize(0.07*f);; tex2.SetTextColor(kOrange+3);; ; time_t offset[] = {0, 0, 1325376000, 1341100800};; time_t t[] = {1331150400, 1336417200, 0, 36000};; ; c->SetTopMargin(0); c->SetBottomMargin(0);; c->SetLeftMargin(0); c->SetRightMargin(0);; c->Divide(2, 4, -1, -1);; TLine l;; l.DrawLine(0.5, 0, 0.5, 1.);; ; for(int i = 0; i < 4; ++i){; for(int gmt = 0; gmt < 2; ++gmt){; const char* opt = (gmt ? ""gmt"" : ""local"");; TVirtualPad* p = c->cd(2*i + gmt + 1);; p->SetTopMargin(0); p->SetBottomMargin(0);; p->SetLeftMargin(0); p->SetRightMargin(0);; p->SetFillStyle(4000);; ; TGaxis* ga = new TGaxis (.4, .25, 5., .25, t[i], t[i] + 1, 1, ""t"");; ga->SetTimeFormat(""TGaxis label: #color[2]{%Y-%m-%d %H:%M:%S}"");; ga->SetLabelFont(102);; ga->SetLabelColor(kBlue+2);; ; ga->SetTimeOffset(offset[i], opt);; ga->SetLabelOffset(0.04*f);; ga->SetLabelSize(0.07*f);; ga->SetLineColor(0);; ga->Draw();; ; // Get offset string of axis time format: there is not accessor; // to time format in TGaxis.; // Assumes TAxis use the same format.; TAxis a(10, 0, 1600000000);; a.SetTimeOffset(offset[i], opt);; const char* offsettimeformat = a.GetTimeFormat();; ; char buf[256];; if (offset[i] < t[i]) {; snprintf(buf, 256, ""#splitline{%s, %s}{offset: %ld, option %s}"",; stime(t+i).Data(), stime(t+i, true).Data(), offset[i], opt);; } else {; int h = t[i] / 3600;; int m = (t[i] - 3600 * h) / 60 ;; int s = (t[i] - h * 3600 - m * 60);; snprintf(buf, 256, ""#splitline{%d h %d m %d s}{offset: %s, option %s}"",; h, m, s, stime(offset + i, gmt).Data(), opt);; }; tex1.DrawLatex(.01, .75, buf);; tex2.DrawLatex(.01, .50, offsettimeformat);; time_t t_ = t[i] + offset[i];; snprintf(buf, 256, ""Expecting: #color[2]{%s}"", stime(&t_, gmt, false).Data());; tex3.DrawLatex(.01, .24, buf);; if(i > 0) l.DrawLine(0, 0.95, 1, 0.95);; }; }; }; kOrange@ kOrangeDefinition Rtypes.h:67; TAxis.h; TCanvas.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGaxis.html:29167,access,accessor,29167,doc/master/classTGaxis.html,https://root.cern,https://root.cern/doc/master/classTGaxis.html,1,['access'],['accessor']
Security,"extEntry, TRootIconList, TAxis, TKey, TMapFile, TParticle, TPrimary, TPackMgr, Axis2, TParallelCoordSelect, and TVirtualPad.; Definition at line 488 of file TObject.cxx. ◆ GetUniqueID(). UInt_t TObject::GetUniqueID ; (; ); const. virtual . Return the unique object id. ; Definition at line 462 of file TObject.cxx. ◆ HandleTimer(). Bool_t TObject::HandleTimer ; (; TTimer * ; timer). virtual . Execute action in response of a timer timing out. ; This method must be overridden if an object has to react to timers. ; Reimplemented in TGWindow, TGuiBldDragManager, TSessionViewer, TGraphTime, TGLEventHandler, TGCommandPlugin, TGDNDManager, TGFileContainer, TGPopupMenu, TGScrollBar, TGShutter, TGTextEdit, TGTextEditor, TGTextEntry, TGTextView, TGToolTip, TGHtml, TVirtualPacketizer, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, TProofPlayerLite, and TTreeViewer.; Definition at line 498 of file TObject.cxx. ◆ Hash(). ULong_t TObject::Hash ; (; ); const. virtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:41922,hash,hash,41922,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['hash'],['hash']
Security,"f 'path' is in the managed directory Return kTRUE or kFALSE. ; Definition at line 478 of file TPackMgr.cxx. ◆ IsPackageEnabled(). Bool_t TPackMgr::IsPackageEnabled ; (; const char * ; pack). inline . Definition at line 82 of file TPackMgr.h. ◆ Load() [1/2]. Int_t TPackMgr::Load ; (; const char * ; pack, . const char * ; opts . ). Method to load a package taking an option const char * Return -1 on error, 0 otherwise. ; Definition at line 206 of file TPackMgr.cxx. ◆ Load() [2/2]. Int_t TPackMgr::Load ; (; const char * ; pack, . TList * ; optls = 0 . ). Method to load a package taking an option list Return -1 on error, 0 otherwise. ; Definition at line 220 of file TPackMgr.cxx. ◆ Log(). void TPackMgr::Log ; (; const char * ; msg). private . Wrapper to notofuer / logger. ; Definition at line 73 of file TPackMgr.cxx. ◆ operator=(). TPackMgr & TPackMgr::operator= ; (; const TPackMgr & ; ). private . ◆ ReadMD5(). TMD5 * TPackMgr::ReadMD5 ; (; const char * ; pack). Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ; Returns a pointer to a TMD5 object, transferring ownership to the caller ; Definition at line 708 of file TPackMgr.cxx. ◆ RegisterGlobalPath(). Int_t TPackMgr::RegisterGlobalPath ; (; const char * ; paths). static . Parse one or more paths as possible sources of packages Returns number of paths added; or -1 in case of problems. ; Definition at line 872 of file TPackMgr.cxx. ◆ Remove(). Int_t TPackMgr::Remove ; (; const char * ; pack = 0, . Bool_t ; dolock = kTRUE . ). Remove package 'pack' If 'pack' is null or empty all packages are cleared. ; Definition at line 593 of file TPackMgr.cxx. ◆ SetLogger(). void TPackMgr::SetLogger ; (; TPackMgrLog_t ; logger). inline . Definition at line 67 of file TPackMgr.h. ◆ SetName(). void TPackMgr::SetName ; (; const char * ; name). inlineoverridevirtual . Set the name of the TNamed. ; WARNING: if the object is a member of a THashTable or THashList container the container must be Rehash()'ed after SetName(). F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:21913,checksum,checksum,21913,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['checksum'],['checksum']
Security,"f (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No truncation check for error buffers */; 20031 error->text,; 20032 error->text_buffer_size,; 20033 ""%s"",; 20034 err_msg);; 20035 }; 20036 free_context(ctx);; 20037 pthread_setspecific(sTlsKey, NULL);; 20038 return NULL;; 20039 }; 20040 ; 20041 ; 20042#if !defined(_WIN32) && !defined(__ZEPHYR__); 20043 if (!set_uid_option(ctx)) {; 20044 const char *err_msg = ""Failed to run as configured user"";; 20045 /* Fatal error - abort start. */; 20046 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20047 ; 20048 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20049 mg_snprintf(NULL,; 20050 NULL, /* No truncation check for error buffers */; 20051 error->text,; 20052 error->text_buffer_size,; 20053 ""%s"",; 20054 err_msg);; 20055 }; 20056 free_context(ctx);; 20057 pthread_setspecific(sTlsKey, NULL);; 20058 return NULL;; 20059 }; 20060#endif; 20061 ; 20062 if (!set_acl_option(ctx)) {; 20063 const char *err_msg = ""Failed to setup access control list"";; 20064 /* Fatal error - abort start. */; 20065 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20066 ; 20067 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20068 mg_snprintf(NULL,; 20069 NULL, /* No truncation check for error buffers */; 20070 error->text,; 20071 error->text_buffer_size,; 20072 ""%s"",; 20073 err_msg);; 20074 }; 20075 free_context(ctx);; 20076 pthread_setspecific(sTlsKey, NULL);; 20077 return NULL;; 20078 }; 20079 ; 20080 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20081 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20082 sizeof(pthread_t),; 20083 ctx);; 20084 ; 20085 if (ctx->worker_threadids == NULL) {; 20086 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:599503,access,access,599503,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"f (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,; 20070 NULL, /* No truncation check for error buffers */; 20071 error->text,; 20072 error->text_buffer_size,; 20073 ""%s"",; 20074 err_msg);; 20075 }; 20076 free_context(ctx);; 20077 pthread_setspecific(sTlsKey, NULL);; 20078 return NULL;; 20079 }; 20080 ; 20081 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:599536,access,access,599536,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"f ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TExMap.html:7629,hash,hash,7629,root/html534/TExMap.html,https://root.cern,https://root.cern/root/html534/TExMap.html,2,['hash'],['hash']
Security,"f ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 15:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TExMap.html:8090,hash,hash,8090,root/html604/TExMap.html,https://root.cern,https://root.cern/root/html604/TExMap.html,2,['hash'],['hash']
Security,"f ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-30 14:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TExMap.html:8090,hash,hash,8090,root/html602/TExMap.html,https://root.cern,https://root.cern/root/html602/TExMap.html,2,['hash'],['hash']
Security,"f ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& b); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TExMap.h 34618 2010-07-27 15:52:34Z rdm $ » Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TExMap.html:7541,hash,hash,7541,root/html528/TExMap.html,https://root.cern,https://root.cern/root/html528/TExMap.html,2,['hash'],['hash']
Security,"f ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& b); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TExMap.h 34618 2010-07-27 15:52:34Z rdm $ » Last generated: 2011-07-04 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TExMap.html:7610,hash,hash,7610,root/html530/TExMap.html,https://root.cern,https://root.cern/root/html530/TExMap.html,2,['hash'],['hash']
Security,"f ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& b); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TExMap.h 34618 2010-07-27 15:52:34Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TExMap.html:7610,hash,hash,7610,root/html532/TExMap.html,https://root.cern,https://root.cern/root/html532/TExMap.html,2,['hash'],['hash']
Security,"f (workdata->f_domain == NULL) {; 8576 mg_cry_internal(workdata->conn,; 8577 ""%s: syntax error in authorization file: %s"",; 8578 __func__,; 8579 workdata->buf);; 8580 continue;; 8581 }; 8582 *(char *)(workdata->f_domain) = 0;; 8583 (workdata->f_domain)++;; 8584 ; 8585 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8586 if (workdata->f_ha1 == NULL) {; 8587 mg_cry_internal(workdata->conn,; 8588 ""%s: syntax error in authorization file: %s"",; 8589 __func__,; 8590 workdata->buf);; 8591 continue;; 8592 }; 8593 *(char *)(workdata->f_ha1) = 0;; 8594 (workdata->f_ha1)++;; 8595 ; 8596 if (!strcmp(workdata->ah.user, workdata->f_user); 8597 && !strcmp(workdata->domain, workdata->f_domain)) {; 8598 return check_password(workdata->conn->request_info.request_method,; 8599 workdata->f_ha1,; 8600 workdata->ah.uri,; 8601 workdata->ah.nonce,; 8602 workdata->ah.nc,; 8603 workdata->ah.cnonce,; 8604 workdata->ah.qop,; 8605 workdata->ah.response);; 8606 }; 8607 }; 8608 ; 8609 return is_authorized;; 8610}; 8611 ; 8612 ; 8613/* Authorize against the opened passwords file. Return 1 if authorized. */; 8614static int; 8615authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm); 8616{; 8617 struct read_auth_file_struct workdata;; 8618 char buf[MG_BUF_LEN];; 8619 ; 8620 if (!conn || !conn->dom_ctx) {; 8621 return 0;; 8622 }; 8623 ; 8624 memset(&workdata, 0, sizeof(workdata));; 8625 workdata.conn = conn;; 8626 ; 8627 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8628 return 0;; 8629 }; 8630 ; 8631 if (realm) {; 8632 workdata.domain = realm;; 8633 } else {; 8634 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8635 }; 8636 ; 8637 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8638}; 8639 ; 8640 ; 8641/* Public function to check http digest authentication header */; 8642int; 8643mg_check_digest_access_authentication(struct mg_connection *conn,; 8644 const char *realm,; 8645 const char *filename); 8646{; 8647 struct mg_file fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:248413,password,passwords,248413,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['password'],['passwords']
Security,"f (workdata->f_domain == NULL) {; 8577 mg_cry_internal(workdata->conn,; 8578 ""%s: syntax error in authorization file: %s"",; 8579 __func__,; 8580 workdata->buf);; 8581 continue;; 8582 }; 8583 *(char *)(workdata->f_domain) = 0;; 8584 (workdata->f_domain)++;; 8585 ; 8586 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8587 if (workdata->f_ha1 == NULL) {; 8588 mg_cry_internal(workdata->conn,; 8589 ""%s: syntax error in authorization file: %s"",; 8590 __func__,; 8591 workdata->buf);; 8592 continue;; 8593 }; 8594 *(char *)(workdata->f_ha1) = 0;; 8595 (workdata->f_ha1)++;; 8596 ; 8597 if (!strcmp(workdata->ah.user, workdata->f_user); 8598 && !strcmp(workdata->domain, workdata->f_domain)) {; 8599 return check_password(workdata->conn->request_info.request_method,; 8600 workdata->f_ha1,; 8601 workdata->ah.uri,; 8602 workdata->ah.nonce,; 8603 workdata->ah.nc,; 8604 workdata->ah.cnonce,; 8605 workdata->ah.qop,; 8606 workdata->ah.response);; 8607 }; 8608 }; 8609 ; 8610 return is_authorized;; 8611}; 8612 ; 8613 ; 8614/* Authorize against the opened passwords file. Return 1 if authorized. */; 8615static int; 8616authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm); 8617{; 8618 struct read_auth_file_struct workdata;; 8619 char buf[MG_BUF_LEN];; 8620 ; 8621 if (!conn || !conn->dom_ctx) {; 8622 return 0;; 8623 }; 8624 ; 8625 memset(&workdata, 0, sizeof(workdata));; 8626 workdata.conn = conn;; 8627 ; 8628 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8629 return 0;; 8630 }; 8631 ; 8632 if (realm) {; 8633 workdata.domain = realm;; 8634 } else {; 8635 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8636 }; 8637 ; 8638 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8639}; 8640 ; 8641 ; 8642/* Public function to check http digest authentication header */; 8643int; 8644mg_check_digest_access_authentication(struct mg_connection *conn,; 8645 const char *realm,; 8646 const char *filename); 8647{; 8648 struct mg_file fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:248445,password,passwords,248445,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['password'],['passwords']
Security,f RSA key. ; Definition at line 1219 of file TAuthenticate.cxx. ◆ SetDefaultUser(). void TAuthenticate::SetDefaultUser ; (; const char * ; defaultuser). static . Set default user name. ; Definition at line 1357 of file TAuthenticate.cxx. ◆ SetEnvironment(). void TAuthenticate::SetEnvironment ; (; ). private . Set default authentication environment. ; The values are inferred from fSecurity and fDetails. ; Definition at line 681 of file TAuthenticate.cxx. ◆ SetGlobalExpDate(). void TAuthenticate::SetGlobalExpDate ; (; TDatime ; expdate). static . Set default expiring date for new validity contexts. ; Definition at line 1349 of file TAuthenticate.cxx. ◆ SetGlobalPasswd(). void TAuthenticate::SetGlobalPasswd ; (; const char * ; passwd). static . Set global passwd to be used for authentication to rootd or proofd. ; Definition at line 1309 of file TAuthenticate.cxx. ◆ SetGlobalPwHash(). void TAuthenticate::SetGlobalPwHash ; (; Bool_t ; pwhash). static . Set global passwd hash flag to be used for authentication to rootd or proofd. ; Definition at line 1323 of file TAuthenticate.cxx. ◆ SetGlobalSRPPwd(). void TAuthenticate::SetGlobalSRPPwd ; (; Bool_t ; srppwd). static . Set global SRP passwd flag to be used for authentication to rootd or proofd. ; Definition at line 1331 of file TAuthenticate.cxx. ◆ SetGlobalUser(). void TAuthenticate::SetGlobalUser ; (; const char * ; user). static . Set global user name to be used for authentication to rootd or proofd. ; Definition at line 1295 of file TAuthenticate.cxx. ◆ SetGlobusAuthHook(). void TAuthenticate::SetGlobusAuthHook ; (; GlobusAuth_t ; func). static . Set Globus authorization function. ; Automatically called when libGlobusAuth is loaded. ; Definition at line 1411 of file TAuthenticate.cxx. ◆ SetKrb5AuthHook(). void TAuthenticate::SetKrb5AuthHook ; (; Krb5Auth_t ; func). static . Set kerberos5 authorization function. ; Automatically called when libKrb5Auth is loaded. ; Definition at line 1402 of file TAuthenticate.cxx. ◆ Se,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:38638,hash,hash,38638,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,2,"['authenticat', 'hash']","['authentication', 'hash']"
Security,"f a different package, like the CLHEP HepThreeVector that implements the required signature.; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::HepThreeVector q(1,2,3);; XYZVector v3(q);; 13.12.2.2 Coordinate Accessors; All coordinate accessors are available through the class ROOT::Math::DisplacementVector3D:; //returns cartesian components for the cartesian vector v1; v1.X(); v1.Y(); v1.Z();; //returns cylindrical components for the cartesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2; r2.X(); r2.Y(); r2.Z(); In addition, all the 3 coordinates of the vector can be retrieved with the GetCoordinates method:; double d[3];; //fill d array with (x,y,z) components of v1; v1.GetCoordinates(d);; //fill d array with (r,eta,phi) components of r2; r2.GetCoordinates(d);; std::vector vc(3);; //fill std::vector with (x,y,z) components of v1; v1.GetCoordinates(vc.begin(),vc.end());; See the reference documentation of ROOT::Math::DisplacementVector3D for more details on all the coordinate accessors.; 13.12.2.3 Setter Methods; One can set only all the three coordinates via:; v1.SetCoordinates(c1,c2,c3); // (x,y,z) for a XYZVector; r2.SetCoordinates(c1,c2,c3); // r,theta,phi for a Polar3DVector; r2.SetXYZ(x,y,z); // 3 cartesian components for Polar3DVector; Single coordinate setter methods are available for the basic vector coordinates, like SetX() for a XYZVector or SetR() for a polar vector. Attempting to do a SetX() on a polar vector will not compile.; XYZVector v1;; v1.SetX(1); //OK setting x for a Cartesian vector; Polar3DVector v2;; v2.SetX(1); //ERROR: cannot set X for a Polar vector.; //Method will not compile; v2.SetR(1); //OK setting r for a Polar vector; In addition, there are setter methods from C arrays or iterator; double d[3] = {1.,2.,3.};; XYZVector v;; // set (x,y,z) components of v using values from d; v.SetCoordinates(d);; or, for example, from an std::vector using the iterator; std::vector w(3);; // ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:730726,access,accessors,730726,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessors']
Security,"f all members |; Public Member Functions |; Static Public Member Functions |; List of all members ; ROOT::Experimental::RField< T, typename > Class Template Referencefinal. ; template<typename T, typename = void>; class ROOT::Experimental::RField< T, typename >Classes with dictionaries that can be inspected by TClass. ; Definition at line 241 of file RField.hxx. Public Member Functions;  RField (RField &&other)=default;  ;  RField (std::string_view name);  ;  ~RField () final=default;  ; RField & operator= (RField &&other)=default;  ;  Public Member Functions inherited from ROOT::Experimental::RClassField;  RClassField (RClassField &&other)=default;  ;  RClassField (std::string_view fieldName, std::string_view className);  ;  ~RClassField () override=default;  ; void AcceptVisitor (Detail::RFieldVisitor &visitor) const final;  ; size_t GetAlignment () const final;  As a rule of thumb, the alignment is equal to the size of the type. ;  ; std::uint32_t GetTypeChecksum () const final;  Return the current TClass reported checksum of this class. Only valid if kTraitTypeChecksum is set. ;  ; std::uint32_t GetTypeVersion () const final;  Indicates an evolution of the C++ type itself. ;  ; size_t GetValueSize () const final;  The number of bytes taken by a value of the appropriate type. ;  ; RClassField & operator= (RClassField &&other)=default;  ; std::vector< RValue > SplitValue (const RValue &value) const final;  Creates the list of direct child values given a value for this field. ;  ;  Public Member Functions inherited from ROOT::Experimental::RFieldBase;  RFieldBase (const RFieldBase &)=delete;  ;  RFieldBase (RFieldBase &&)=default;  ;  RFieldBase (std::string_view name, std::string_view type, ENTupleStructure structure, bool isSimple, std::size_t nRepetitions=0);  The constructor creates the underlying column objects and connects them to either a sink or a source. ;  ; virtual ~RFieldBase ()=default;  ; RSchemaIterator begin ();  ; RConstSchemaIterator begin () const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html:1196,checksum,checksum,1196,doc/master/classROOT_1_1Experimental_1_1RField.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html,1,['checksum'],['checksum']
Security,"f boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table.; - If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). This function returns the number of selected entries. It returns -1; if an error occurs. Drawing expressions using arrays and array elements. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equivalent. For variable size arrays (and TClonesArray) the range; of the first dimension is recalculated for each entry of the tree. TTree::Draw also now properly handling operations involving 2 or more arrays. Le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:65372,access,access,65372,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['access'],['access']
Security,"f boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table.; - If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). This function returns the number of selected entries. It returns -1; if an error occurs. Drawing expressions using arrays and array elements. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equivalent. For variable size arrays (and TClonesArray) the range; of the first dimension is recalculated for each entry of the tree.; You can also specify the index as an expression of any other variables from the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:67198,access,access,67198,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,2,['access'],['access']
Security,"f collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashTable.html:10777,hash,hash,10777,root/html528/THashTable.html,https://root.cern,https://root.cern/root/html528/THashTable.html,6,['hash'],['hash']
Security,"f contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCollection; 13#define ROOT_TCollection; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TCollection //; 19// //; 20// Collection abstract base class. This class inherits from TObject //; 21// because we want to be able to have collections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:1759,access,access,1759,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['access'],['access']
Security,"f file DecisionTree.cxx. ◆ BuildTree(). UInt_t TMVA::DecisionTree::BuildTree ; (; const EventConstList & ; eventSample, . DecisionTreeNode * ; node = nullptr . ). building the decision tree by recursively calling the splitting of one (root-) node into two daughter nodes (returns the number of nodes) ; Definition at line 377 of file DecisionTree.cxx. ◆ CheckEvent(). Double_t TMVA::DecisionTree::CheckEvent ; (; const TMVA::Event * ; e, . Bool_t ; UseYesNoLeaf = kFALSE . ); const. the event e is put into the decision tree (starting at the root node) and the output is NodeType (signal) or (background) of the final node (basket) in which the given events ends up. ; I.e. the result of the classification if the event for this decision tree. ; Definition at line 2690 of file DecisionTree.cxx. ◆ CheckEventWithPrunedTree(). void TMVA::DecisionTree::CheckEventWithPrunedTree ; (; const TMVA::Event * ; e); const. pass a single validation event through a pruned decision tree on the way down the tree, fill in all the ""intermediate"" information that would normally be there from training. ; Definition at line 1085 of file DecisionTree.cxx. ◆ Class(). static TClass * TMVA::DecisionTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::DecisionTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::DecisionTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 243 of file DecisionTree.h. ◆ ClassName(). virtual const char * TMVA::DecisionTree::ClassName ; (; ); const. inlinevirtual . Implements TMVA::BinaryTree.; Definition at line 98 of file DecisionTree.h. ◆ CleanTree(). UInt_t TMVA::DecisionTree::CleanTree ; (; DecisionTreeNode * ; node = nullptr). remove those last splits that result in two leaf nodes that are both of the type (i.e. ; both signal or both background) this of course is only a reasonable thing to do when you use ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:16349,validat,validation,16349,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['validat'],['validation']
Security,"f file TClassEdit.cxx. ◆ IsArtificial(). bool TClassEdit::IsArtificial ; (; std::string_view ; name). inline . Definition at line 159 of file TClassEdit.h. ◆ IsDefAlloc() [1/2]. bool TClassEdit::IsDefAlloc ; (; const char * ; alloc, . const char * ; classname . ). return whether or not 'allocname' is the STL default allocator for type 'classname' ; Definition at line 621 of file TClassEdit.cxx. ◆ IsDefAlloc() [2/2]. bool TClassEdit::IsDefAlloc ; (; const char * ; alloc, . const char * ; keyclassname, . const char * ; valueclassname . ). return whether or not 'allocname' is the STL default allocator for a key of type 'keyclassname' and a value of type 'valueclassname' ; Definition at line 670 of file TClassEdit.cxx. ◆ IsDefComp(). bool TClassEdit::IsDefComp ; (; const char * ; comp, . const char * ; classname . ). return whether or not 'compare' is the STL default comparator for type 'classname' ; Definition at line 821 of file TClassEdit.cxx. ◆ IsDefHash(). bool TClassEdit::IsDefHash ; (; const char * ; hashname, . const char * ; classname . ). return whether or not 'hashname' is the STL default hash for type 'classname' ; Definition at line 839 of file TClassEdit.cxx. ◆ IsDefPred(). bool TClassEdit::IsDefPred ; (; const char * ; predname, . const char * ; classname . ). return whether or not 'predname' is the STL default predicate for type 'classname' ; Definition at line 830 of file TClassEdit.cxx. ◆ IsInterpreterDetail(). bool TClassEdit::IsInterpreterDetail ; (; const char * ; type). Return true if the type is one the interpreter details which are only forward declared (ClassInfo_t etc..) ; Definition at line 1322 of file TClassEdit.cxx. ◆ IsStdArray(). bool TClassEdit::IsStdArray ; (; std::string_view ; name). inline . Definition at line 183 of file TClassEdit.h. ◆ IsStdClass(). bool TClassEdit::IsStdClass ; (; const char * ; type). return true if the class belongs to the std namespace ; Definition at line 1418 of file TClassEdit.cxx. ◆ IsStdPair(). bool TClassE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTClassEdit.html:11622,hash,hashname,11622,doc/master/namespaceTClassEdit.html,https://root.cern,https://root.cern/doc/master/namespaceTClassEdit.html,1,['hash'],['hashname']
Security,"f file TMath.h. ◆ GhbarCUncertainty(). constexpr Double_t TMath::GhbarCUncertainty ; (; ). constexpr . \( \frac{G}{\hbar C} \) uncertainty. ; Definition at line 166 of file TMath.h. ◆ Gn(). constexpr Double_t TMath::Gn ; (; ). constexpr . Standard acceleration of gravity in \( m s^{-2} \). ; Definition at line 174 of file TMath.h. ◆ GnUncertainty(). constexpr Double_t TMath::GnUncertainty ; (; ). constexpr . Standard acceleration of gravity uncertainty. ; Definition at line 181 of file TMath.h. ◆ GUncertainty(). constexpr Double_t TMath::GUncertainty ; (; ). constexpr . Gravitational constant uncertainty. ; Definition at line 150 of file TMath.h. ◆ H(). constexpr Double_t TMath::H ; (; ). constexpr . Planck's constant in \( J s \): \( h \). ; Definition at line 188 of file TMath.h. ◆ Hash() [1/2]. ULong_t TMath::Hash ; (; const char * ; str). Definition at line 1416 of file TMath.cxx. ◆ Hash() [2/2]. ULong_t TMath::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). Calculates hash index from any char string. ; Based on pre-calculated table of 256 specially selected numbers. These numbers are selected in such a way, that for string length == 4 (integer number) the hash is unambiguous, i.e. from hash value we can recalculate input (no degeneration).; The quality of hash method is good enough, that ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N) tested by <R>, <R*R>, <Ri*Ri+1> gives the same result as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*)); V.Perev; This function is kept for back compatibility. The code previously in this function has been moved to the static function TString::Hash . Definition at line 1408 of file TMath.cxx. ◆ Hbar(). constexpr Double_t TMath::Hbar ; (; ). constexpr . \( \hbar \) in \( J s \): \( \hbar = \frac{h}{2\pi} \) ; Definition at line 211 of file TMath.h. ◆ Hbarcgs(). constexpr Double_t TMath::Hbarcgs ; (; ). c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:46745,hash,hash,46745,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['hash'],['hash']
Security,"f file TProofMgr.h. ◆ More(). virtual void TProofMgr::More ; (; const char * ; , . const char * ; = 0, . const char * ; = 0 . ). inlinevirtual . Definition at line 116 of file TProofMgr.h. ◆ operator=(). TProofMgr & TProofMgr::operator= ; (; const TProofMgr & ; ). private . ◆ Ping(). Int_t TProofMgr::Ping ; (; const char * ; url, . Bool_t ; checkxrd = kFALSE . ). static . Non-blocking check for a PROOF (or Xrootd, if checkxrd) service at 'url' Return 0 if a XProofd (or Xrootd, if checkxrd) daemon is listening at 'url' -1 if nothing is listening on the port (connection cannot be open) 1 if something is listening but not XProofd (or not Xrootd, if checkxrd) ; Definition at line 631 of file TProofMgr.cxx. ◆ PutFile(). virtual Int_t TProofMgr::PutFile ; (; const char * ; , . const char * ; , . const char * ; = 0 . ). inlinevirtual . Definition at line 123 of file TProofMgr.h. ◆ QuerySessions(). TList * TProofMgr::QuerySessions ; (; Option_t * ; opt = ""S""). virtual . Get list of sessions accessible to this manager. ; Definition at line 229 of file TProofMgr.cxx. ◆ ReadBuffer() [1/2]. virtual TObjString * TProofMgr::ReadBuffer ; (; const char * ; , . const char * ;  . ). inlinevirtual . Reimplemented in TProofMgrLite.; Definition at line 99 of file TProofMgr.h. ◆ ReadBuffer() [2/2]. virtual TObjString * TProofMgr::ReadBuffer ; (; const char * ; , . Long64_t ; , . Int_t ;  . ). inlinevirtual . Reimplemented in TProofMgrLite.; Definition at line 97 of file TProofMgr.h. ◆ ReplaceSubdirs(). void TProofMgr::ReplaceSubdirs ; (; const char * ; fn, . TString & ; fdst, . TList & ; dirph . ). staticprivate . Parse file name extracting the directory subcomponents in dirs, stored as TObjStrings. ; Definition at line 745 of file TProofMgr.cxx. ◆ Reset(). Int_t TProofMgr::Reset ; (; Bool_t ; hard = kFALSE, . const char * ; usr = 0 . ). virtual . Send a cleanup request for the sessions associated with the current user. ; Not supported. ; Definition at line 307 of file TProofMgr.cxx. ◆ Rm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofMgr.html:24518,access,accessible,24518,doc/master/classTProofMgr.html,https://root.cern,https://root.cern/doc/master/classTProofMgr.html,1,['access'],['accessible']
Security,"f function, eg. sin -> TMath::Sin; *-* - function from cling environment, eg. TMath::BreitWigner(x,y,z); *-* * first check if function exists, and has same number of arguments, then accept it and set as found.; *-* If all functors after iteration are matched with corresponding action,; *-* it inputs C++ code of formula into cling, and sets flag that formula is ready to evaluate.; -. void SetPredefinedParamNames(). const TObject* GetLinearPart(Int_t i) const; Return linear part. void AddVariable(const TString& name, Double_t value = 0); -; *-* Adds variable to known variables, and reprocess formula.; -. void AddVariables(const TString* vars, const Int_t size); -; *-* Adds multiple variables.; *-* First argument is an array of pairs<TString,Double>, where; *-* first argument is name of variable,; *-* second argument represents value.; *-* size - number of variables passed in first argument; -. void SetName(const char* name); Set the name of the formula. We need to allow the list of function to; properly handle the hashes. void SetVariables(const pair<TString,Double_t>* vars, const Int_t size); -; *-* Sets multiple variables.; *-* First argument is an array of pairs<TString,Double>, where; *-* first argument is name of variable,; *-* second argument represents value.; *-* size - number of variables passed in first argument; -. Double_t GetVariable(const char* name) const; -; *-* Returns variable value.; -. Int_t GetVarNumber(const char* name) const; -; *-* Returns variable number (positon in array) given its name; -. TString GetVarName(Int_t ivar) const; -; *-* Returns variable name given its position in the array; -. void SetVariable(const TString& name, Double_t value); -; *-* Sets variable value.; -. void DoAddParameter(const TString& name, Double_t value, bool processFormula); -; *-* Adds parameter to known parameters.; *-* User should use SetParameter, because parameters are added during initialization part,; *-* and after that adding new will be pointless.; -. In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFormula.html:15474,hash,hashes,15474,root/html604/TFormula.html,https://root.cern,https://root.cern/root/html604/TFormula.html,1,['hash'],['hashes']
Security,"f internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:12104,validat,validation,12104,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,2,['validat'],['validation']
Security,"f ncolors = 100 and colors=0, a Solar palette is used.; 2869/// if ncolors = 101 and colors=0, a South West palette is used.; 2870/// if ncolors = 102 and colors=0, a Starry Night palette is used.; 2871/// if ncolors = 103 and colors=0, a Sunset palette is used.; 2872/// if ncolors = 104 and colors=0, a Temperature Map palette is used.; 2873/// if ncolors = 105 and colors=0, a Thermometer palette is used.; 2874/// if ncolors = 106 and colors=0, a Valentine palette is used.; 2875/// if ncolors = 107 and colors=0, a Visible Spectrum palette is used.; 2876/// if ncolors = 108 and colors=0, a Water Melon palette is used.; 2877/// if ncolors = 109 and colors=0, a Cool palette is used.; 2878/// if ncolors = 110 and colors=0, a Copper palette is used.; 2879/// if ncolors = 111 and colors=0, a Gist Earth palette is used.; 2880/// if ncolors = 112 and colors=0, a Viridis palette is used.; 2881/// if ncolors = 113 and colors=0, a Cividis palette is used.; 2882/// ~~~; 2883/// These palettes can also be accessed by names:; 2884/// ~~~ {.cpp}; 2885/// kDeepSea=51, kGreyScale=52, kDarkBodyRadiator=53,; 2886/// kBlueYellow= 54, kRainBow=55, kInvertedDarkBodyRadiator=56,; 2887/// kBird=57, kCubehelix=58, kGreenRedViolet=59,; 2888/// kBlueRedYellow=60, kOcean=61, kColorPrintableOnGrey=62,; 2889/// kAlpine=63, kAquamarine=64, kArmy=65,; 2890/// kAtlantic=66, kAurora=67, kAvocado=68,; 2891/// kBeach=69, kBlackBody=70, kBlueGreenYellow=71,; 2892/// kBrownCyan=72, kCMYK=73, kCandy=74,; 2893/// kCherry=75, kCoffee=76, kDarkRainBow=77,; 2894/// kDarkTerrain=78, kFall=79, kFruitPunch=80,; 2895/// kFuchsia=81, kGreyYellow=82, kGreenBrownTerrain=83,; 2896/// kGreenPink=84, kIsland=85, kLake=86,; 2897/// kLightTemperature=87, kLightTerrain=88, kMint=89,; 2898/// kNeon=90, kPastel=91, kPearl=92,; 2899/// kPigeon=93, kPlum=94, kRedBlue=95,; 2900/// kRose=96, kRust=97, kSandyTerrain=98,; 2901/// kSienna=99, kSolar=100, kSouthWest=101,; 2902/// kStarryNight=102, kSunset=103, kTemperatureMap=104,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:107524,access,accessed,107524,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['access'],['accessed']
Security,"f non-zero, at least this many more exposes ;  ; Int_t fFormat;  Next fields only used by kClientMessageEvent. ;  ; Handle_t fHandle;  general resource handle (used for atoms or windows) ;  ; UInt_t fHeight;  width and height of exposed area ;  ; Bool_t fSendEvent;  true if event came from SendEvent ;  ; UInt_t fState;  key or button mask ;  ; Time_t fTime;  time event event occurred in ms ;  ; EGEventType fType;  of event (see EGEventType) ;  ; Longptr_t fUser [5];  5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ;  ; UInt_t fWidth;  ; Window_t fWindow;  window reported event is relative to ;  ; Int_t fX;  ; Int_t fXRoot;  ; Int_t fY;  pointer x, y coordinates in event window ;  ; Int_t fYRoot;  coordinates relative to root ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCode. UInt_t Event_t::fCode. key or button code ; Definition at line 180 of file GuiTypes.h. ◆ fCount. Int_t Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t Event_t::fTime. time event event occurred in ms ; Definition at line 177 of file GuiTypes.h. ◆ fType. EGEventType Event_t::fType. of event (see EGEventType) ; Definition at line 175 of file GuiTypes.h. ◆ fUser. Longptr_t Event_t::fUser[5]. 5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ; [1] and [2] may",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structEvent__t.html:1339,expose,exposes,1339,doc/master/structEvent__t.html,https://root.cern,https://root.cern/doc/master/structEvent__t.html,1,['expose'],['exposes']
Security,"f overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunctionTemplate* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfFunctionTemplates(const TListOfFunctionTemplates& ). TListOfFunctionTemplates& operator=(const TListOfFunctionTemplates& ). » Author: Philippe Canal Aug 2013 » ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctionTemplates.html:14505,hash,hash,14505,root/html602/TListOfFunctionTemplates.html,https://root.cern,https://root.cern/root/html602/TListOfFunctionTemplates.html,4,['hash'],['hash']
Security,"f pointers. Int_t ReadSequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& h). void ReadUShort(UShort_t& h). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& ll). void ReadLon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferFile.html:46779,hash,hashtable,46779,root/html528/TBufferFile.html,https://root.cern,https://root.cern/root/html528/TBufferFile.html,2,['hash'],['hashtable']
Security,"f spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; event weight is used no matter what. void SetIsTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. void SetIgnoreNegWeightsInTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. Bool_t IsDynamic() const; accessors. {return fDynamic; }. Double_t GetOriginalWeight() const; { return fWeight; }. Double_t GetBoostWeight() const; { return TMath::Max(Double_t(0.0001),fBoostWeight); }. UInt_t GetClass() const; { return fClass; }. std::vector<Float_t>& GetValues(); For a detailed explanation, please see the heading ""Avoid Duplication in const and Non-const Member Function,"" on p. 23, in Item 3 ""Use const whenever possible,"" in Effective C++, 3d ed by Scott Meyers, ISBN-13: 9780321334879.; http://stackoverflow.com/questions/123758/how-do-i-remove-code-duplication-between-similar-const-and-non-const-member-func. Float_t GetTarget(UInt_t itgt) const; { return fTargets.at(itgt); }. std::vector<Float_t>& GetTargets(); { return fTargets; }. const std::vector<Float_t>& GetTargets() const; { return fTargets; }. std::vector<Float_t>& GetSpectators(); { return fSpectators; }. const std::vector<Float_t>& GetSpectators() const; { return fSpectators; }. void SetWeight(Double_t w); { fWeight=w; }. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Event.html:5422,access,accessors,5422,root/html602/TMVA__Event.html,https://root.cern,https://root.cern/root/html602/TMVA__Event.html,2,['access'],['accessors']
Security,"f streamer infos and also; 1375/// information about the success of the operation.; 1376 ; 1377TFile::InfoListRet TFile::GetStreamerInfoListImpl(bool lookupSICache); 1378{; 1379 ROOT::Internal::RConcurrentHashColl::HashValue hash;; 1380 ; 1381 if (fIsPcmFile) return {nullptr, 1, hash}; // No schema evolution for ROOT PCM files.; 1382 ; 1383 TList *list = nullptr;; 1384 if (fSeekInfo) {; 1385 TDirectory::TContext ctxt(this); // gFile and gDirectory used in ReadObj; 1386 auto key = std::make_unique<TKey>(this);; 1387 std::vector<char> buffer(fNbytesInfo+1);; 1388 auto buf = buffer.data();; 1389 Seek(fSeekInfo); // NOLINT: silence clang-tidy warnings; 1390 if (ReadBuffer(buf,fNbytesInfo)) { // NOLINT: silence clang-tidy warnings; 1391 // ReadBuffer returns kTRUE in case of failure.; 1392 Warning(""GetRecordHeader"",""%s: failed to read the StreamerInfo data from disk."",; 1393 GetName());; 1394 return {nullptr, 1, hash};; 1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:49752,hash,hash,49752,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,4,['hash'],"['hash', 'hashes']"
Security,"f the histogram.; The Mean; The Mean is illustrated with the same mechanism as used for candle plots. Usually a circle is used.; Whiskers; The whiskers are illustrated by the same mechanism as used for candle plots. There is only one difference. When using the simple whisker definition (w=1) and the zero indicator line (z=1), then the whiskers will be forced to be solid (usually hashed); Points; The points are illustrated by the same mechanism as used for candle plots. E.g. VIOLIN2 uses better whisker definition (w=2) and outliers (p=1).; Other options; It is possible to combine all options of candle or violin plots with each other. E.g. a violin plot including a box-plot.; How to use the violin-plots drawing option; There are two predefined violin-plot representations:; ""VIOLINX1"": Standard violin (histogram, mean, whisker over full distribution, zero indicator line); ""VIOLINX2"": Line VIOLINX1 both with better whisker definition + outliers. A solid fill style is recommended for this plot (as opposed to a hollow or hashed style).; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; Int_t nx(6), ny(40);; double xmin(0.0), xmax(+6.0), ymin(0.0), ymax(+4.0);; auto hviolin = new TH2F(""hviolin"", ""Option VIOLIN example"", nx, xmin, xmax, ny, ymin, ymax);; TF1 f1(""f1"", ""gaus"", +0,0 +4.0);; double x,y;; for (Int_t iBin=1; iBin<hviolin->GetNbinsX(); ++iBin) {; double xc = hviolin->GetXaxis()->GetBinCenter(iBin);; f1.SetParameters(1, 2.0+TMath::Sin(1.0+xc), 0.2+0.1*(xc-xmin)/xmax);; for(Int_t i=0; i<10000; ++i){; x = xc;; y = f1.GetRandom();; hviolin->Fill(x, y);; }; }; hviolin->SetFillColor(kGray);; hviolin->SetMarkerStyle(20);; hviolin->SetMarkerSize(0.5);; hviolin->Draw(""VIOLIN"");; c1->Update();; }; kGray@ kGrayDefinition Rtypes.h:65; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TF1::GetRandomvirtual Double_t GetRandom(TRandom *rng=nullptr, Option_t *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:71072,hash,hashed,71072,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['hash'],['hashed']
Security,"f the list and also store option. ;  ; void AddLast (TObject *obj) override;  Add object at the end of the list. ;  ; void AddLast (TObject *obj, Option_t *opt) override;  Add object at the end of the list and also store option. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; void Clear (Option_t *option="""") override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the list AND delete all heap based objects. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:2862,hash,hash,2862,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['hash'],['hash']
Security,"f the schema rules if any.Definition TClass.cxx:1999; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1957; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDatime::GetDateTimestatic void GetDateTime(UInt_t datetime, Int_t &date, Int_t &time)Static function that returns the date and time.Definition TDati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:202968,access,access,202968,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['access'],['access']
Security,"f the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTitle(label, label); return h; ; data = merge_histos(""data""); twtb = merge_histos(""twtb""); singletop = merge_histos(""singletop""); wjets = merge_histos(""wjets""); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pad; c = ROOT.TCanvas(""c"", """", 600, 600); pad = ROOT.TPad(""upper_pad"", """", 0, 0, 1, 1); pad.SetTickx(False); pad.SetTicky(False); pad.Draw(); pad.cd(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); wjets.Scale(1.1) # Corrected normalization derived from a validation region; for h, color in zip(; [wjets, twtb, singletop],; [(222, 90, 106), (155, 152, 204), (208, 240, 193)]):; h.SetLineWidth(1); h.SetLineColor(1); h.SetFillColor(ROOT.TColor.GetColor(*color)); stack.Add(h); stack.Draw(""HIST""); stack.GetXaxis().SetTitle(""m_{W(l#nu)+b} [GeV]""); stack.GetYaxis().SetTitle(""Events""); stack.GetYaxis().SetLabelSize(0.04); stack.GetYaxis().SetTitleSize(0.045); stack.GetXaxis().SetLabelSize(0.04); stack.GetXaxis().SetTitleSize(0.045); stack.SetMinimum(0); stack.SetMaximum(5000 * lumi_scale); stack.GetYaxis().ChangeLabel(1, -1, 0); ; # Draw data; data.SetMarkerStyle(20); data.SetMarkerSize(1.2); data.SetLineWidth(2); data.SetLineColor(ROOT.kBlack); data.Draw(""E SAME""); ; # Add legend; legend = ROOT.TLegend(0.60, 0.65, 0.92, 0.92); legend.SetTextFont(42); legend.SetFillStyle(0); legend.SetBorderSize(0); legend.SetTextSize(0.035); legend.SetTextAlign(32); legend.AddEntry(data, ""Data"" ,""lep""); legend.AddEntry(singletop, ""Single top + jet"", ""f""); legend.AddEntry(twtb, ""t#bar{t},Wt,t#bar{b}"", ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:9272,validat,validation,9272,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['validat'],['validation']
Security,"f the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:37843,access,access,37843,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['access'],['access']
Security,"f the underlying object.Definition TH1.cxx:2752; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; int; Note that this method cannot be expected to yield reliable results when using weighted histograms (because the likelihood computation will be incorrect). ; Definition at line 42 of file TBinomialEfficiencyFitter.h. Public Member Functions;  TBinomialEfficiencyFitter ();  default constructor ;  ;  TBinomialEfficiencyFitter (const TH1 *numerator, const TH1 *denominator);  Constructor. ;  ;  ~TBinomialEfficiencyFitter () override;  destructor ;  ; Double_t EvaluateFCN (const Double_t *par);  ; TFitResultPtr Fit (TF1 *f1, Option_t *option="""");  Carry out the fit of the given function to the given histograms. ;  ; ROOT::Fit::Fitter * GetFitter ();  Provide access to the underlying fitter object. ;  ; TClass * IsA () const override;  ; void Set (const TH1 *numerator, const TH1 *denominator);  Initialize with a new set of inputs. ;  ; void SetPrecision (Double_t epsilon);  Set the required integration precision, see TF1::Integral() ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html:4563,access,access,4563,doc/master/classTBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html,1,['access'],['access']
Security,"f this variable is set, we ask that proxy to route our; requests HTTP(S) requests to the file server. In addition, you can also use the 'options' argument to provide the access key; and secret key to be used for authentication purposes for this file by using a; string of the form ""AUTH=myAccessKey:mySecretkey"". This may be useful to; open several files hosted by different providers in the same program/macro,; where the environemntal variables solution is not convenient (see below). If you need to specify both NOPROXY and AUTH separate them by ' '; (blank), for instance:; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"". Examples:; TFile* f1 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f2 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");. If there is no authentication information in the 'options' argument; (i.e. not AUTH=""...."") the values of the environmental variables; S3_ACCESS_KEY and S3_SECRET_KEY (if set) are expected to contain; the access key id and the secret access key, respectively. You have; been provided with these credentials by your S3 service provider. If neither the AUTH information is provided in the 'options' argument; nor the environmental variables are set, we try to open the file; without providing any authentication information to the server. This; is useful when the file is set an access control that allows for; any unidentified user to read the file. Bool_t ParseOptions(Option_t* options, TString& accessKey, TString& secretKey); Extracts the S3 authentication key pair (access key and secret key); from the options. The authentication credentials can be specified in; the options provided to the constructor of this class as a string; containing: ""AUTH=<access key>:<secret key>"" and can include other; options, for instance ""NOPROXY"" f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:29002,authenticat,authentication,29002,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,3,['authenticat'],['authentication']
Security,"f variable given a variable given a name return -1 if variable is not found ;  ; virtual std::string VariableName (unsigned int ivar) const;  get name of variables (override if minimizer support storing of variable names) return an empty string if variable is not found ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Attributes; std::vector< double > fCovar;  ; unsigned int fDim;  ; std::vector< double > fErrors;  ; TLinearFitter * fFitter;  ; double fMinVal;  ; unsigned int fNFree;  ; const ROOT::Math::IMultiGradFunction * fObjFunc;  ; std::vector< double > fParams;  ; bool fRobust;  return reference to the objective function virtual const ROOT::Math::IGenFunction & Function() const; ;  . Additional Inherited Members;  Protected Attributes inherited from ROOT::Math::Minimizer; MinimizerOptions fOptions;  minimizer options ;  ; int fStatus = -1;  status of minimizer ;  ; bool fValidError = false;  flag to control if errors have been validated (Hesse has been run in case of Minuit) ;  . #include <TLinearMinimizer.h>. Inheritance diagram for TLinearMinimizer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TLinearMinimizer() [1/2]. TLinearMinimizer::TLinearMinimizer ; (; int ; type = 0). Default constructor. ; Definition at line 70 of file TLinearMinimizer.cxx. ◆ TLinearMinimizer() [2/2]. TLinearMinimizer::TLinearMinimizer ; (; const char * ; type). Constructor from a char * (used by PM) ; Definition at line 82 of file TLinearMinimizer.cxx. ◆ ~TLinearMinimizer(). TLinearMinimizer::~TLinearMinimizer ; (; ). override . Destructor (no operations) ; Definition at line 100 of file TLinearMinimizer.cxx. Member Function Documentation. ◆ Class(). static TClass * TLinearMinimizer::Class ; (; ). static . ReturnsTClass describing this class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearMinimizer.html:11201,validat,validated,11201,doc/master/classTLinearMinimizer.html,https://root.cern,https://root.cern/doc/master/classTLinearMinimizer.html,1,['validat'],['validated']
Security,f variations of an input pdf ;  ; file  rf504_simwstool.py;   Organization and simultaneous fits: using RooSimWSTool to construct a simultaneous pdf that is built of variations of an input pdf ;  ; file  rf505_asciicfg.C;   Organisation and simultaneous fits: reading and writing ASCII configuration files ;  ; file  rf505_asciicfg.py;   Organization and simultaneous fits: reading and writing ASCII configuration files ;  ; file  rf506_msgservice.C;   Organisation and simultaneous fits: tuning and customizing the RooFit message logging facility ;  ; file  rf506_msgservice.py;   Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ;  ; file  rf508_listsetmanip.C;   Organization and simultaneous fits: RooArgSet and RooArgList tools and tricks ;  ; file  rf508_listsetmanip.py;   'ORGANIZATION AND SIMULTANEOUS FITS' RooFit tutorial macro #508 ;  ; file  rf509_wsinteractive.C;   Organization and simultaneous fits: easy interactive access to workspace contents - CINT to CLING code migration ;  ; file  rf509_wsinteractive.py;   Organization and simultaneous fits: easy interactive access to workspace contents - CINT to CLING code migration ;  ; file  rf510_wsnamedsets.C;   Organization and simultaneous fits: working with named parameter sets and parameter snapshots in workspaces ;  ; file  rf510_wsnamedsets.py;   'ORGANIZATION AND SIMULTANEOUS FITS' RooFit tutorial macro #510 ;  ; file  rf511_wsfactory_basic.C;   Organization and simultaneous fits: basic use of the 'object factory' associated with a workspace to rapidly build pdfs functions and their parameter components ;  ; file  rf511_wsfactory_basic.py;   Organization and simultaneous fits: basic use of the 'object factory' associated with a workspace to rapidly build pdfs functions and their parameter components ;  ; file  rf512_wsfactory_oper.C;   Organization and simultaneous fits: operator expressions and expression-based basic pdfs in the workspace factory syntax ;  ; file,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:13810,access,access,13810,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['access'],['access']
Security,"f you know what you ""; 1255 ""are doing; note that you risk associating wrong TTree entries of the friend with those of the main TTree!"";; 1256 Error(""AddFriend"", msg, reshuffledTreeName, friendTree.GetName());; 1257 return false;; 1258 }; 1259 return true;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Add a TFriendElement to the list of friends.; 1264///; 1265/// This function:; 1266/// - opens a file if filename is specified; 1267/// - reads a Tree with name treename from the file (current directory); 1268/// - adds the Tree to the list of friends; 1269/// see other AddFriend functions; 1270///; 1271/// A TFriendElement TF describes a TTree object TF in a file.; 1272/// When a TFriendElement TF is added to the list of friends of an; 1273/// existing TTree T, any variable from TF can be referenced in a query; 1274/// to T.; 1275///; 1276/// A tree keeps a list of friends. In the context of a tree (or a chain),; 1277/// friendship means unrestricted access to the friends data. In this way; 1278/// it is much like adding another branch to the tree without taking the risk; 1279/// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; 1280/// method. The tree in the diagram below has two friends (friend_tree1 and; 1281/// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; 1282///; 1283/// \image html ttree_friend1.png; 1284///; 1285/// The AddFriend method has two parameters, the first is the tree name and the; 1286/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1291/// If the friend tree has the same name as the original tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:45713,access,access,45713,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security,"f(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; w.Import(model); ; ; # Create and fill workspace; # ------------------------------------------------; ; ; # Create a workspace named 'w'; # With CINT w could exports its contents to; # a same-name C++ namespace in CINT 'namespace w'.; # but self does not work anymore in CLING.; # so self tutorial is an example on how to; # change the code; w = ROOT.RooWorkspace(""w"", True); ; # Fill workspace with pdf and data in a separate function; fillWorkspace(w); ; # Print workspace contents; w.Print(); ; # self does not work anymore with CLING; # use normal workspace functionality; ; # Use workspace contents; # ----------------------------------------------; ; # Old syntax to use the name space prefix operator to access the workspace contents; #; # d = w.model.generate(w.x,1000); # r = w.model.fitTo(*d); ; # use normal workspace methods; model = w[""model""]; x = w[""x""]; ; d = model.generate({x}, 1000); r = model.fitTo(d, PrintLevel=-1); ; # old syntax to access the variable x; # frame = w.x.frame(); ; frame = x.frame(); d.plotOn(frame); ; # OLD syntax to omit x.; # NB: The 'w.' prefix can be omitted if namespace w is imported in local namespace; # in the usual C++ way; #; # using namespace w; # model.plotOn(frame); # model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # correct syntax; bkg = w[""bkg""]; model.plotOn(frame); model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf509_wsinteractive.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf509__wsinteractive_8py.html:2547,access,access,2547,doc/master/rf509__wsinteractive_8py.html,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html,1,['access'],['access']
Security,"f, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; virtual Long64_t GetSeekFree () const;  ; virtual Long64_t GetSeekInfo () const;  ; const TList * GetStreamerInfoCache ();  Returns the cached list of StreamerInfos used in this file. ;  ; virtual TList * GetStreamerInfoList () final;  Read the list of TStreamerInfo objects written to this file. ;  ; Int_t GetVersion () const;  ; virtual void IncrementProcessIDs ();  ; virtual Bool_t IsArchive () const;  ; Bool_t IsBinary () const;  ; virtual Bool_t IsOpen () const;  Returns kTRUE in case file is open and kFALSE if file is not open. ;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual void MakeFree (Long64_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Int_t len);  Read a buffer from the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Long64_t pos, Int_t len);  Read a buffer from the file at the offset 'pos' in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual Bool_t ReadBuffers (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  Read the nbuf blocks described in arrays pos and len. ;  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html:6853,access,access,6853,doc/v632/classROOT_1_1TBufferMergerFile.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html,5,['access'],['access']
Security,"f, sizeof(workdata->buf), filep) != NULL) {; 8519 l = strlen(workdata->buf);; 8520 while (l > 0) {; 8521 if (isspace((unsigned char)workdata->buf[l - 1]); 8522 || iscntrl((unsigned char)workdata->buf[l - 1])) {; 8523 l--;; 8524 workdata->buf[l] = 0;; 8525 } else; 8526 break;; 8527 }; 8528 if (l < 1) {; 8529 continue;; 8530 }; 8531 ; 8532 workdata->f_user = workdata->buf;; 8533 ; 8534 if (workdata->f_user[0] == ':') {; 8535 /* user names may not contain a ':' and may not be empty,; 8536 * so lines starting with ':' may be used for a special purpose; 8537 */; 8538 if (workdata->f_user[1] == '#') {; 8539 /* :# is a comment */; 8540 continue;; 8541 } else if (!strncmp(workdata->f_user + 1, ""include="", 8)) {; 8542 if (mg_fopen(workdata->conn,; 8543 workdata->f_user + 9,; 8544 MG_FOPEN_MODE_READ,; 8545 &fp)) {; 8546 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8547 (void)mg_fclose(; 8548 &fp.access); /* ignore error on read only file */; 8549 ; 8550 /* No need to continue processing files once we have a; 8551 * match, since nothing will reset it back; 8552 * to 0.; 8553 */; 8554 if (is_authorized) {; 8555 return is_authorized;; 8556 }; 8557 } else {; 8558 mg_cry_internal(workdata->conn,; 8559 ""%s: cannot open authorization file: %s"",; 8560 __func__,; 8561 workdata->buf);; 8562 }; 8563 continue;; 8564 }; 8565 /* everything is invalid for the moment (might change in the; 8566 * future) */; 8567 mg_cry_internal(workdata->conn,; 8568 ""%s: syntax error in authorization file: %s"",; 8569 __func__,; 8570 workdata->buf);; 8571 continue;; 8572 }; 8573 ; 8574 workdata->f_domain = strchr(workdata->f_user, ':');; 8575 if (workdata->f_domain == NULL) {; 8576 mg_cry_internal(workdata->conn,; 8577 ""%s: syntax error in authorization file: %s"",; 8578 __func__,; 8579 workdata->buf);; 8580 continue;; 8581 }; 8582 *(char *)(workdata->f_domain) = 0;; 8583 (workdata->f_domain)++;; 8584 ; 8585 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8586 if (workdata->f_ha1 == NULL) {; 8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:246631,access,access,246631,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"f, sizeof(workdata->buf), filep) != NULL) {; 8520 l = strlen(workdata->buf);; 8521 while (l > 0) {; 8522 if (isspace((unsigned char)workdata->buf[l - 1]); 8523 || iscntrl((unsigned char)workdata->buf[l - 1])) {; 8524 l--;; 8525 workdata->buf[l] = 0;; 8526 } else; 8527 break;; 8528 }; 8529 if (l < 1) {; 8530 continue;; 8531 }; 8532 ; 8533 workdata->f_user = workdata->buf;; 8534 ; 8535 if (workdata->f_user[0] == ':') {; 8536 /* user names may not contain a ':' and may not be empty,; 8537 * so lines starting with ':' may be used for a special purpose; 8538 */; 8539 if (workdata->f_user[1] == '#') {; 8540 /* :# is a comment */; 8541 continue;; 8542 } else if (!strncmp(workdata->f_user + 1, ""include="", 8)) {; 8543 if (mg_fopen(workdata->conn,; 8544 workdata->f_user + 9,; 8545 MG_FOPEN_MODE_READ,; 8546 &fp)) {; 8547 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8548 (void)mg_fclose(; 8549 &fp.access); /* ignore error on read only file */; 8550 ; 8551 /* No need to continue processing files once we have a; 8552 * match, since nothing will reset it back; 8553 * to 0.; 8554 */; 8555 if (is_authorized) {; 8556 return is_authorized;; 8557 }; 8558 } else {; 8559 mg_cry_internal(workdata->conn,; 8560 ""%s: cannot open authorization file: %s"",; 8561 __func__,; 8562 workdata->buf);; 8563 }; 8564 continue;; 8565 }; 8566 /* everything is invalid for the moment (might change in the; 8567 * future) */; 8568 mg_cry_internal(workdata->conn,; 8569 ""%s: syntax error in authorization file: %s"",; 8570 __func__,; 8571 workdata->buf);; 8572 continue;; 8573 }; 8574 ; 8575 workdata->f_domain = strchr(workdata->f_user, ':');; 8576 if (workdata->f_domain == NULL) {; 8577 mg_cry_internal(workdata->conn,; 8578 ""%s: syntax error in authorization file: %s"",; 8579 __func__,; 8580 workdata->buf);; 8581 continue;; 8582 }; 8583 *(char *)(workdata->f_domain) = 0;; 8584 (workdata->f_domain)++;; 8585 ; 8586 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8587 if (workdata->f_ha1 == NULL) {; 8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:246663,access,access,246663,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"fClassPropertyTClassmutableprivate; fClassVersionTClassprivate; fCollectionProxyTClassprivate; fContextMenuTitleTClassprivate; fConversionStreamerInfoTClassmutableprivate; fConvStreamerFuncTClassprivate; fCurrentInfoTClassmutableprivate; fDataTClassprivate; fDeclFileLineTClassprivate; fDeclFileNameTClassprivate; fDeleteTClassprivate; fDeleteArrayTClassprivate; fDestructorTClassprivate; fDirAutoAddTClassprivate; fEnumsTClassprivate; fFuncTemplateTClassprivate; fgClassCountTClassprivatestatic; fgClassTypedefHashTClassprivatestatic; fgDtorOnlyTObjectprivatestatic; fGlobalIsATClassprivate; fgObjectStatTObjectprivatestatic; fHasCustomStreamerMemberTClassprivate; fHasRootPcmInfoTClassprivate; FillBuffer(char *&buffer)TNamedvirtual; fImplFileLineTClassprivate; fImplFileNameTClassprivate; FindClassOrBaseMethodWithId(DeclId_t faddr)TClassprivate; FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constTClass; FindConversionStreamerInfo(const TClass *onfile_cl, UInt_t checksum) constTClass; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; FindStreamerInfo(TObjArray *arr, UInt_t checksum) constTClassprotected; FindStreamerInfo(UInt_t checksum, Bool_t isTransient=kFALSE) constTClass; FindStreamerInfoAbstractEmulated(UInt_t checksum) constTClass; fInstanceCountTClassprivate; fIsATClassprivate; fIsAMethodTClassmutableprivate; fIsOffsetStreamerSetTClassmutableprivate; fIsSyntheticPairTClassprivate; fLastReadInfoTClassmutableprivate; fMergeTClassprivate; fMethodTClassprivate; fNameTNamedprotected; fNewTClassprivate; fNewArrayTClassprivate; fNoInfoOrEmuOrFwdDeclNameRegistryTClassprivatestatic; fObjectVersionRepositoryTClassmutableprivate; fOffsetStreamerTClassmutableprivate; fOnHeapTClassprivate; ForceReload(TClass *oldcl)TClass; fOVRMutexTClassmutableprivate; fPersistentRefTClassprivate; fPropertyTClassmutableprivate; fRealDataTClassprivate; fRefProxyTClassprivate; fResetAfterMergeTClassprivate; fRuntimeProp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:5023,checksum,checksum,5023,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['checksum'],['checksum']
Security,"fErrorCodeerror code of last operation; TStringTSQLStatement::fErrorMsgerror message of last operation; Bool_tTSQLStatement::fErrorOutenable error output ; Int_tfIterationCount! number of iteration; Bool_tfNeedParBind! indicates when parameters bind should be called; Int_tfNumBuffers! number of statement parameters; MYSQL_STMT*fStmt! executed statement; Int_tfWorkingMode! 1 - setting parameters, 2 - retrieving results; static ULong64_tfgAllocSizeLimit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLStatement(MYSQL_STMT* stmt, Bool_t errout = kTRUE); Normal constructor.; Checks if statement contains parameters tags. ~TMySQLStatement(); Destructor. void Close(Option_t* = """"); Close statement. Bool_t Process(); Process statement. Int_t GetNumAffectedRows(); Return number of affected rows after statement is processed. Int_t GetNumParameters(); Return number of statement parameters. Bool_t StoreResult(); Store result of statement processing to access them; via GetInt(), GetDouble() and so on methods. Int_t GetNumFields(); Return number of fields in result set. const char* GetFieldName(Int_t nfield); Returns field name in result set. Bool_t NextResultRow(); Shift cursor to nect row in result set. Bool_t NextIteration(); Increment iteration counter for statement, where parameter can be set.; Statement with parameters of previous iteration; automatically will be applied to database. void FreeBuffers(); Release all buffers, used by statement. void SetBuffersNumber(Int_t n); Allocate buffers for statement parameters/ result fields. const char* ConvertToString(Int_t npar); Convert field value to string. long double ConvertToNumeric(Int_t npar); Convert field to numeric value. Bool_t IsNull(Int_t npar); Checks if field value is null. Int_t GetInt(Int_t npar); Return field value as integer. UInt_t GetUInt(Int_t npar); Return field value as unsigned integer. Long_t GetLong(Int_t npar); Return field value as long integer. Long64_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMySQLStatement.html:9400,access,access,9400,root/html528/TMySQLStatement.html,https://root.cern,https://root.cern/root/html528/TMySQLStatement.html,4,['access'],['access']
Security,"fFree,idcur,idcur-nbytes-1);; 2094 Seek(idcur);; 2095 continue;; 2096 }; 2097 Version_t versionkey;; 2098 frombuf(buffer, &versionkey);; 2099 frombuf(buffer, &objlen);; 2100 frombuf(buffer, &datime);; 2101 frombuf(buffer, &keylen);; 2102 frombuf(buffer, &cycle);; 2103 if (versionkey > 1000) {; 2104 frombuf(buffer, &seekkey);; 2105 frombuf(buffer, &seekpdir);; 2106 } else {; 2107 Int_t skey,sdir;; 2108 frombuf(buffer, &skey); seekkey = (Long64_t)skey;; 2109 frombuf(buffer, &sdir); seekpdir = (Long64_t)sdir;; 2110 }; 2111 frombuf(buffer, &nwhc);; 2112 char *classname = nullptr;; 2113 if (nwhc <= 0 || nwhc > 100) break;; 2114 classname = new char[nwhc+1];; 2115 int i, nwhci = nwhc;; 2116 for (i = 0;i < nwhc; i++) frombuf(buffer, &classname[i]);; 2117 classname[nwhci] = '\0';; 2118 TDatime::GetDateTime(datime, date, time);; 2119 TClass *tclass = TClass::GetClass(classname);; 2120 if (seekpdir == fSeekDir && tclass && !tclass->InheritsFrom(TFile::Class()); 2121 && strcmp(classname,""TBasket"")) {; 2122 key = new TKey(this);; 2123 key->ReadKeyBuffer(bufread);; 2124 if (!strcmp(key->GetName(),""StreamerInfo"")) {; 2125 fSeekInfo = seekkey;; 2126 SafeDelete(fInfoCache);; 2127 fNbytesInfo = nbytes;; 2128 } else {; 2129 AppendKey(key);; 2130 nrecov++;; 2131 SetBit(kRecovered);; 2132 Info(""Recover"", ""%s, recovered key %s:%s at address %lld"",GetName(),key->GetClassName(),key->GetName(),idcur);; 2133 }; 2134 }; 2135 delete [] classname;; 2136 idcur += nbytes;; 2137 }; 2138 if (fWritable) {; 2139 Long64_t max_file_size = Long64_t(kStartBigFile);; 2140 if (max_file_size < fEND) max_file_size = fEND+1000000000;; 2141 TFree *last = (TFree*)fFree->Last();; 2142 if (last) {; 2143 last->AddFree(fFree,fEND,max_file_size);; 2144 } else {; 2145 new TFree(fFree,fEND,max_file_size);; 2146 }; 2147 if (nrecov) Write();; 2148 }; 2149 return nrecov;; 2150}; 2151 ; 2152////////////////////////////////////////////////////////////////////////////////; 2153/// Reopen a file with a different access mode.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:76709,access,access,76709,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['access'],['access']
Security,"fGlobals ()=0;  ; virtual void UpdateListOfMethods (TClass *cl) const =0;  ; virtual void UpdateListOfTypes ()=0;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:26216,hash,hash,26216,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['hash'],['hash']
Security,"fPadPointer! free pointerDefinition TPad.h:113; TPad::GetX2Double_t GetX2() const overrideDefinition TPad.h:241; TPad::CreateToolTipTObject * CreateToolTip(const TBox *b, const char *text, Long_t delayms) overrideCreate a tool tip and return its pointer.Definition TPad.cxx:7091; TPad::kCannotMove@ kCannotMoveFixed position.Definition TPad.h:158; TPad::kClearAfterCR@ kClearAfterCRClear after CR.Definition TPad.h:159; TPad::kHori@ kHoriPad is horizontal.Definition TPad.h:155; TPad::kClipFrame@ kClipFrameClip on frame.Definition TPad.h:156; TPad::kPrintingPS@ kPrintingPSPS Printing.Definition TPad.h:157; TPad::kFraming@ kFramingFrame is requested.Definition TPad.h:154; TPad::GetWNDCDouble_t GetWNDC() const overrideGet width of pad along X in Normalized Coordinates (NDC)Definition TPad.h:215; TPad::Popvoid Pop() overridePop pad to the top of the stack.Definition TPad.cxx:4776; TPad::GetAbsXlowNDCDouble_t GetAbsXlowNDC() const overrideDefinition TPad.h:220; TPad::HashULong_t Hash() const overrideReturn hash value for this object.Definition TPad.h:267; TPad::GetX1Double_t GetX1() const overrideDefinition TPad.h:240; TPad::GetHNDCDouble_t GetHNDC() const overrideGet height of pad along Y in Normalized Coordinates (NDC)Definition TPad.h:217; TPad::fMotherTPad * fMother! pointer to mother of the listDefinition TPad.h:105; TPad::SetThetavoid SetTheta(Double_t theta=30) overrideDefinition TPad.h:359; TPad::GetNameconst char * GetName() const overrideReturns name of object.Definition TPad.h:260; TPad::XtoAbsPixelInt_t XtoAbsPixel(Double_t x) const overrideConvert X coordinate to absolute pixel.Definition TPad.cxx:7475; TPad::fGridyBool_t fGridySet to true if grid along Y.Definition TPad.h:101; TPad::SetBBoxY2void SetBBoxY2(const Int_t y) overrideSet bottom of BoundingBox to a value (resize in y direction on bottom)Definition TPad.cxx:7358; TPad::XtoPadDouble_t XtoPad(Double_t x) const overrideConvert x from X to pad.Definition TPad.cxx:3560; TPointDefinition TPoint.h:31; TQObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8h_source.html:64253,hash,hash,64253,doc/master/TPad_8h_source.html,https://root.cern,https://root.cern/doc/master/TPad_8h_source.html,1,['hash'],['hash']
Security,"fUrlOrgsave original url in case of temp redirection; static TUrlfgProxyglobally set proxy URL. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TWebFile(const char* url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. The url; argument must be of the form: http://host.dom.ain/file.root.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. The preferred interface to this; constructor is via TFile::Open(). TWebFile(TUrl url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. Make sure url; is a valid TUrl object.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. ~TWebFile(); Cleanup. void Init(Bool_t readHeadOnly); Initialize a TWebFile object. void SetMsgReadBuffer1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:23661,access,accessible,23661,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,2,['access'],['accessible']
Security,"fVariableArrangementneeded for MethodCategories, where we can train on other than the main variables; Double_tfWeightevent weight (product of global and individual weights); static Bool_tfgIgnoreNegWeightsInTraining; static Bool_tfgIsTrainingmark if we are in an actual training or ""evaluation/testing"" phase --> ignoreNegWeights only in actual training !. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); Create an Event object.; When the constructor is invoked for the first time, the class static; variable fgTracks is 0 and the TClonesArray fgTracks is created. ~Event(). Event(); constructors. Event(const TMVA::Event& ). explicit Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1.0, Double_t boostweight = 1.0). explicit Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1.0, Double_t boostweight = 1.0). Bool_t IsDynamic() const; accessors. {return fDynamic; }. Double_t GetWeight() const; Double_t GetWeight() const { return fWeight*fBoostWeight; }. Double_t GetOriginalWeight() const; { return fWeight; }. Double_t GetBoostWeight() const; { return TMath::Max(Double_t(0.0001),fBoostWeight); }. UInt_t GetClass() const; { return fClass; }. UInt_t GetNVariables() const. UInt_t GetNTargets() const. UInt_t GetNSpectators() const. Float_t GetValue(UInt_t ivar) const. std::vector<Float_t>& GetValues(); For a detailed explanation, please see the heading ""Avoid Duplication in const and Non-const Member Function,"" on p. 23, in Item 3 ""Use const whenever possible,"" in Effective C++, 3d ed by Scott Meyers, ISBN-13: 9780321334879.; http://stackoverflow.com/questions/123758/how-do-i-remove-code-duplication-between-similar-const-and-non-const-member-func. const std::vector<Float_t>& GetValues() const. Float_t GetTarget(UInt_t itgt) const; { return fTargets.at(itgt); }. std::vector<Float_t>& GetTargets(); { return fTarget",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Event.html:6626,access,accessors,6626,root/html534/TMVA__Event.html,https://root.cern,https://root.cern/root/html534/TMVA__Event.html,1,['access'],['accessors']
Security,"f_StreamerNVirtual_b);  ; virtual void Summary (Float_t &rt, Float_t &cp);  Prints a summary of all benchmarks. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBenchmark.html:2397,hash,hash,2397,doc/master/classTBenchmark.html,https://root.cern,https://root.cern/doc/master/classTBenchmark.html,1,['hash'],['hash']
Security,"face. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](int j); { return (*fMat)(fRow,j); }. const T & operator[](int j); { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7103,access,access,7103,root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,15,['access'],['access']
Security,"fer &ClassDef_StreamerNVirtual_b);  ; void WriteToStream (std::ostream &o) const;  write VariableInfo to stream ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariableInfo.html:2860,hash,hash,2860,doc/master/classTMVA_1_1VariableInfo.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariableInfo.html,1,['hash'],['hash']
Security,"ference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. df029_SQlitePlatformDistribution.C File ReferenceTutorials » Dataframe tutorials. Detailed Description; Use RDataFrame to display data about ROOT downloads. ; In order to display the Platform Distribution of ROOT, we choose to create two TH1F histograms: one that includes all types of platforms, other filtering and classifying them. This procedure is using a lambda expression taking as parameter the values stored in the ""Platform"" column from the database. At the end, the histograms are filled with their specific demand regarding the platform's type.; ; void df029_SQlitePlatformDistribution() {; ; auto rdf = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; ; TH1F hRootPlatform(""hrootPlatform"", ""Platform Distribution"", 7, 0, -1);; TH1F hShortRootPlatform(""hShortRootPlatform"", ""Short Platform Distribution"", 7, 0, -1);; ; auto fillRootPlatform = [&hRootPlatform, &hShortRootPlatform] ( const std::string &platform ) {; TString Platform = platform;; TString Platform_0(Platform(0,5));; TString Platform_1(Platform(0,6));; TString Platform_2(Platform(0,8));; ; if ( Platform.Contains(""win32"") ){; hShortRootPlatform.Fill(Platform_0,1);; } else if ( Platform.Contains(""Linux"") ){; hShortRootPlatform.Fill(Platform_0,1);; } else if ( Platform.Contains(""source"") ){; hShortRootPlatform.Fill(Platform_1,1);; } else if ( Platform.Contains(""macosx64"") ){; hShortRootPlatform.Fill(Platform_2,1);; } else if ( Platform.Contains(""IRIX64"") ){; hShortRootPlatform.Fill(Platform_1,1);; }; ; hRootPlatform.Fill(Platform,1);; };; ; rdf.Foreach( fillRootPlatform, { ""Platform"" } );; ; auto c1 = new TCanvas();; c1->SetLogy(1);; hRootPlatform.GetXaxis()->LabelsOption(""a"");; hRootPlatform.LabelsDeflate(""X"");; hRootPlatform.DrawClone();; ; auto c2 = new TCanvas();; hShortRootPlatform.GetXaxis()->LabelsOption(""a"");; hShortRootPlatform.LabelsDeflate(""X"");; hShort",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df029__SQlitePlatformDistribution_8C.html:866,access,accesslog,866,doc/master/df029__SQlitePlatformDistribution_8C.html,https://root.cern,https://root.cern/doc/master/df029__SQlitePlatformDistribution_8C.html,1,['access'],['accesslog']
Security,"ferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize); Constructor with hashing threshold. If collection size exceeds threshold; a hash table is added. RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'newArg'.; If 'oldArg' is not found in collection kFALSE is returned. TObject* FindObject(const char* name); Return pointer to obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj); Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove all elements",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinkedList.html:6776,hash,hash,6776,root/html526/RooLinkedList.html,https://root.cern,https://root.cern/root/html526/RooLinkedList.html,1,['hash'],['hash']
Security,"ffer &ClassDef_StreamerNVirtual_b);  ; virtual const TTree * tree () const;  ; double weight (Int_t index) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:7348,hash,hash,7348,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,2,['hash'],['hash']
Security,"fficiency & ; rhs). Assignment operator. ; The histograms, statistic option, confidence level, weight and paint styles of rhs are copied to the this TEfficiency object.; Note: - The list of associated functions is not copied. After this operation the list of associated functions is empty. ; Definition at line 3021 of file TEfficiency.cxx. ◆ Paint(). void TEfficiency::Paint ; (; Option_t * ; opt). overridevirtual . Paints this TEfficiency object. ; For details on the possible option see Draw(Option_t*); Note for 1D classes In 1D the TEfficiency uses a TGraphAsymmErrors for drawing The TGraph is created only the first time Paint is used. The user can manipulate the TGraph via the method TEfficiency::GetPaintedGraph() The TGraph creates behing an histogram for the axis. The histogram is created also only the first time. If the axis needs to be updated because in the meantime the class changed use this trick which will trigger a re-calculation of the axis of the graph TEfficiency::GetPaintedGraph()->Set(0); Note that in order to access the painted graph via GetPaintedGraph() you need either to call Paint or better gPad->Update(); ; Reimplemented from TObject.; Definition at line 3081 of file TEfficiency.cxx. ◆ SavePrimitive(). void TEfficiency::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; opt = """" . ). overridevirtual . Have histograms fixed bins along each axis? ; Reimplemented from TObject.; Definition at line 3155 of file TEfficiency.cxx. ◆ SetBetaAlpha(). void TEfficiency::SetBetaAlpha ; (; Double_t ; alpha). Sets the shape parameter α. ; The prior probability of the efficiency is given by the beta distribution: ; \[; f(\varepsilon;\alpha;\beta) = \frac{1}{B(\alpha,\beta)} \varepsilon^{\alpha-1} (1 - \varepsilon)^{\beta-1}; \]. Note: - both shape parameters have to be positive (i.e. > 0) ; Definition at line 3329 of file TEfficiency.cxx. ◆ SetBetaBeta(). void TEfficiency::SetBetaBeta ; (; Double_t ; beta). Sets the shape parameter β. ; The prior probabilit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEfficiency.html:103073,access,access,103073,doc/master/classTEfficiency.html,https://root.cern,https://root.cern/doc/master/classTEfficiency.html,1,['access'],['access']
Security,"fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size; static TSQLFile::ELockingKindskLockBusy; static TSQLFile::ELockingKindskLockFree. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←; TDirectoryFile. ←; TFile. ←; TSQLFile. Function documentation; TSQLFile(); default TSQLFile constructor. TSQLFile(const char* dbname, Option_t* option = ""read"", const char* user = ""user"", const char* pass = ""pass""); Connects to SQL server with provided arguments.; If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. If option = NEW or CREATE create a ROOT tables in database; if the tables already exists connection is; not opened.; = RECREATE create completely new tables. Any existing tables; will be deleted; = UPDATE open an existing database for writing.; If data base open by other TSQLFile instance for writing,; write access will be rejected; = BREAKLOCK Special case when lock was not correctly released; by TSQLFile instance. This may happen if program crashed when; TSQLFile was open with write access mode.; = READ or OPEN open an existing data base for reading. For more details see comments for TFile::TFile() constructor. For a moment TSQLFile does not support TTree objects and subdirectories. void StartLogFile(const char* fname); start logging of all SQL statements in specified file. void StopLogFile(); close logging file. Bool_t IsMySQL() const; checks, if MySQL database. Bool_t IsOracle() const; checks, if Oracle database. Bool_t IsODBC() const; checks, if ODBC driver used for database connection. void SetUseSuffixes(Bool_t on = kTRUE); enable/disable uasge of suffixes in columns names; can be changed before first object is saved into file. void SetArrayLimit(Int_t limit = 20); Defines maximum number of columns for array representation; If array size bigger than limit, array data will be converted to raw format; Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLFile.html:35908,access,access,35908,root/html602/TSQLFile.html,https://root.cern,https://root.cern/root/html602/TSQLFile.html,2,['access'],['access']
Security,"fication JSON file needs to be provided by the user and it describes all necessary samples and; 1462their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the; 1463required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; 1464sample in the ""metadata"" key.; 1465 ; 1466A simple example for the formatting of the specification in the JSON file is the following:; 1467 ; 1468~~~{.cpp}; 1469{; 1470 ""samples"": {; 1471 ""sampleA"": {; 1472 ""trees"": [""tree1"", ""tree2""],; 1473 ""files"": [""file1.root"", ""file2.root""],; 1474 ""metadata"": {; 1475 ""lumi"": 10000.0, ; 1476 ""xsec"": 1.0,; 1477 ""sample_category"" = ""data""; 1478 }; 1479 },; 1480 ""sampleB"": {; 1481 ""trees"": [""tree3"", ""tree4""],; 1482 ""files"": [""file3.root"", ""file4.root""],; 1483 ""metadata"": {; 1484 ""lumi"": 0.5, ; 1485 ""xsec"": 1.5,; 1486 ""sample_category"" = ""MC_background""; 1487 }; 1488 }; 1489 }; 1490}; 1491~~~; 1492 ; 1493The metadata information from the specification file can be then accessed using the DefinePerSample function.; 1494For example, to access luminosity information (stored as a double):; 1495 ; 1496~~~{.python}; 1497df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 1498~~~; 1499 ; 1500or sample_category information (stored as a string):; 1501 ; 1502~~~{.python}; 1503df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); 1504~~~; 1505 ; 1506or directly the filename:; 1507 ; 1508~~~{.python}; 1509df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); 1510~~~; 1511 ; 1512An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; 1513provides a corresponding exemplary JSON file for the dataset specification.; 1514 ; 1515\anchor progressbar; 1516### Adding a progress bar ; 1517 ; 1518A progress bar showing the processed event statistics can be added to any RDataFrame program.; 1519The event statistic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:84755,access,accessed,84755,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['accessed']
Security,"fication JSON file needs to be provided by the user and it describes all necessary samples and; 1502their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the; 1503required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; 1504sample in the ""metadata"" key.; 1505 ; 1506A simple example for the formatting of the specification in the JSON file is the following:; 1507 ; 1508~~~{.cpp}; 1509{; 1510 ""samples"": {; 1511 ""sampleA"": {; 1512 ""trees"": [""tree1"", ""tree2""],; 1513 ""files"": [""file1.root"", ""file2.root""],; 1514 ""metadata"": {; 1515 ""lumi"": 10000.0, ; 1516 ""xsec"": 1.0,; 1517 ""sample_category"" = ""data""; 1518 }; 1519 },; 1520 ""sampleB"": {; 1521 ""trees"": [""tree3"", ""tree4""],; 1522 ""files"": [""file3.root"", ""file4.root""],; 1523 ""metadata"": {; 1524 ""lumi"": 0.5, ; 1525 ""xsec"": 1.5,; 1526 ""sample_category"" = ""MC_background""; 1527 }; 1528 }; 1529 }; 1530}; 1531~~~; 1532 ; 1533The metadata information from the specification file can be then accessed using the DefinePerSample function.; 1534For example, to access luminosity information (stored as a double):; 1535 ; 1536~~~{.python}; 1537df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 1538~~~; 1539 ; 1540or sample_category information (stored as a string):; 1541 ; 1542~~~{.python}; 1543df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); 1544~~~; 1545 ; 1546or directly the filename:; 1547 ; 1548~~~{.python}; 1549df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); 1550~~~; 1551 ; 1552An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; 1553provides a corresponding exemplary JSON file for the dataset specification.; 1554 ; 1555\anchor progressbar; 1556### Adding a progress bar ; 1557 ; 1558A progress bar showing the processed event statistics can be added to any RDataFrame program.; 1559The event statistic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:86435,access,accessed,86435,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['accessed']
Security,ficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoef; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; Roo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealSumPdf.html:40895,access,access,40895,root/html534/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html534/RooRealSumPdf.html,1,['access'],['access']
Security,"fied item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default serv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:7675,access,access,7675,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,2,"['access', 'authenticat']","['access', 'authenticated']"
Security,"fied.; 1413 ///; 1414 /// See above for a more complete description and example usages.; 1415 RResultPtr<RInterface<RLoopManager>> Snapshot(std::string_view treename, std::string_view filename,; 1416 std::initializer_list<std::string> columnList,; 1417 const RSnapshotOptions &options = RSnapshotOptions()); 1418 {; 1419 ColumnNames_t selectedColumns(columnList);; 1420 return Snapshot(treename, filename, selectedColumns, options);; 1421 }; 1422 // clang-format on; 1423 ; 1424 ////////////////////////////////////////////////////////////////////////////; 1425 /// \brief Save selected columns in memory.; 1426 /// \tparam ColumnTypes variadic list of branch/column types.; 1427 /// \param[in] columnList columns to be cached in memory.; 1428 /// \return a `RDataFrame` that wraps the cached dataset.; 1429 ///; 1430 /// This action returns a new `RDataFrame` object, completely detached from; 1431 /// the originating `RDataFrame`. The new dataframe only contains the cached; 1432 /// columns and stores their content in memory for fast, zero-copy subsequent access.; 1433 ///; 1434 /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; 1435 /// fits in memory and that will be accessed many times.; 1436 ///; 1437 /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; 1438 /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; 1439 /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; 1440 /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; 1441 ///; 1442 /// ### Example usage:; 1443 ///; 1444 /// **Types and columns specified:**; 1445 /// ~~~{.cpp}; 1446 /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; 1447 /// ~~~; 1448 ///; 1449 /// **Types inferred and columns specified (this invocation relies on jitting):**; 145",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:80103,access,access,80103,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['access'],['access']
Security,"file RWebWindow.hxx. Constructor & Destructor Documentation. ◆ RWebWindow(). RWebWindow::RWebWindow ; (; ). RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler> ; Definition at line 76 of file RWebWindow.cxx. ◆ ~RWebWindow(). RWebWindow::~RWebWindow ; (; ). RWebWindow destructor Closes all connections and remove window from manager. ; Definition at line 85 of file RWebWindow.cxx. Member Function Documentation. ◆ _CanTrustIn(). bool RWebWindow::_CanTrustIn ; (; std::shared_ptr< WebConn > & ; conn, . const std::string & ; hash, . const std::string & ; ntry, . bool ; remote, . bool ; test_first_time . ). private . Check if provided hash, ntry parameters from the connection request could be accepted. ; Parameters. hash- provided hash value which should match with HMAC hash for generated before connection key ; ntry- connection attempt number provided together with request, must come in increasing order ; remote- boolean flag indicating if request comming from remote (via real http), for local displays like Qt5 or CEF simpler connection rules are applied ; test_first_time- true if hash/ntry tested for the first time, false appears only with websocket when connection accepted by server . Definition at line 513 of file RWebWindow.cxx. ◆ _MakeSendHeader(). std::string RWebWindow::_MakeSendHeader ; (; std::shared_ptr< WebConn > & ; conn, . bool ; txt, . const std::string & ; data, . int ; chid . ). private . Internal method to prepare text part of send data Should be called under locked connection mutex. ; Definition at line 1107 of file RWebWindow.cxx. ◆ AddDisplayHandle(). unsigned RWebWindow::AddDisplayHandle ; (; bool ; headless_mode, . const std::string & ; key, . std::unique_ptr< RWebDisplayHandle > & ; handle . ). private . Add display handle and associated key Key is large random string generated when starting new window When client is connected, key should be supplied to correctly identify it. ; Definition at line 482 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:23009,hash,hash,23009,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,4,['hash'],['hash']
Security,"file RWebWindow.hxx. Constructor & Destructor Documentation. ◆ RWebWindow(). RWebWindow::RWebWindow ; (; ). RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler> ; Definition at line 76 of file RWebWindow.cxx. ◆ ~RWebWindow(). RWebWindow::~RWebWindow ; (; ). RWebWindow destructor Closes all connections and remove window from manager. ; Definition at line 85 of file RWebWindow.cxx. Member Function Documentation. ◆ _CanTrustIn(). bool RWebWindow::_CanTrustIn ; (; std::shared_ptr< WebConn > & ; conn, . const std::string & ; hash, . const std::string & ; ntry, . bool ; remote, . bool ; test_first_time . ). private . Check if provided hash, ntry parameters from the connection request could be accepted. ; Parameters. hash- provided hash value which should match with HMAC hash for generated before connection key ; ntry- connection attempt number provided together with request, must come in increasing order ; remote- boolean flag indicating if request comming from remote (via real http), for local displays like Qt5 or CEF simpler connection rules are applied ; test_first_time- true if hash/ntry tested for the first time, false appears only with websocket when connection accepted by server . Definition at line 514 of file RWebWindow.cxx. ◆ _MakeSendHeader(). std::string RWebWindow::_MakeSendHeader ; (; std::shared_ptr< WebConn > & ; conn, . bool ; txt, . const std::string & ; data, . int ; chid . ). private . Internal method to prepare text part of send data Should be called under locked connection mutex. ; Definition at line 1140 of file RWebWindow.cxx. ◆ AddDisplayHandle(). unsigned RWebWindow::AddDisplayHandle ; (; bool ; headless_mode, . const std::string & ; key, . std::unique_ptr< RWebDisplayHandle > & ; handle . ). private . Add display handle and associated key Key is large random string generated when starting new window When client is connected, key should be supplied to correctly identify it. ; Definition at line 483 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:22612,hash,hash,22612,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,4,['hash'],['hash']
Security,"file RWebWindowsManager.cxx. ◆ ClearServerLocations(). void RWebWindowsManager::ClearServerLocations ; (; ). static . Clear all server locations Does not change configuration of already running HTTP server. ; Definition at line 239 of file RWebWindowsManager.cxx. ◆ CreateServer(). bool RWebWindowsManager::CreateServer ; (; bool ; with_http = false). private . Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP port, which should be used for the server, provide following entry in rootrc file: ; WebGui.HttpPort: 8088; or specify range of http ports, which can be used: WebGui.HttpPortMin: 8800; WebGui.HttpPortMax: 9800; By default range [8800..9800] is used; One also can bind HTTP server socket to loopback address, In that case only connection from localhost will be available: WebGui.HttpLoopback: yes; Or one could specify hostname which should be used for binding of server socket WebGui.HttpBind: hostname | ipaddress; To use secured protocol, following parameter should be specified WebGui.UseHttps: yes; WebGui.ServerCert: sertificate_filename.pem; Alternatively, one can specify unix socket to handle requests: WebGui.UnixSocket: /path/to/unix/socket; WebGui.UnixSocketMode: 0700; Typically one used unix sockets together with server mode like root --web=server:/tmp/root.socket and then redirect it via ssh tunnel (e.g. using rootssh) to client node; All incoming requests processed in THttpServer in timer handler with 10 ms timeout. One may decrease value to improve latency or increase value to minimize CPU load WebGui.HttpTimer: 10; To processing incoming http requests and websockets, THttpServer allocate 10 threads One have to increase this number if more simultaneous connections are expected: WebGui.HttpThrds: 10; One also can configure usage of special thread of processing of http server requests WebGui.HttpThrd: no; Extra threads can be used to send data to different clients via websocket (default no) WebGui.SenderThrd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:9495,secur,secured,9495,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['secur'],['secured']
Security,"file THttpCallArg.h. ◆ SetQuery(). void THttpCallArg::SetQuery ; (; const char * ; q). inline . set request query ; Definition at line 97 of file THttpCallArg.h. ◆ SetRequestHeader(). void THttpCallArg::SetRequestHeader ; (; const char * ; h). inline . set full set of request header ; Definition at line 116 of file THttpCallArg.h. ◆ SetText(). void THttpCallArg::SetText ; (; ). Set content type as ""text/plain"". ; Definition at line 149 of file THttpCallArg.cxx. ◆ SetTextContent(). void THttpCallArg::SetTextContent ; (; std::string && ; txt). Set content type as ""text/plain"" and also assigns content. ; Parameters. txtwill be in undefined state after method call . Definition at line 159 of file THttpCallArg.cxx. ◆ SetTopName(). void THttpCallArg::SetTopName ; (; const char * ; topname). inline . set engine-specific top-name ; Definition at line 83 of file THttpCallArg.h. ◆ SetUserName(). void THttpCallArg::SetUserName ; (; const char * ; n). inline . set name of authenticated user ; Definition at line 94 of file THttpCallArg.h. ◆ SetWSId(). void THttpCallArg::SetWSId ; (; UInt_t ; id). inline . set web-socket id ; Definition at line 104 of file THttpCallArg.h. ◆ SetXml(). void THttpCallArg::SetXml ; (; ). Set content type as ""text/xml"". ; Definition at line 168 of file THttpCallArg.cxx. ◆ SetXmlContent(). void THttpCallArg::SetXmlContent ; (; std::string && ; xml). Set content type as ""text/xml"" and also assigns content. ; Parameters. xmlwill be in undefined state after method call . Definition at line 178 of file THttpCallArg.cxx. ◆ SetZipping(). void THttpCallArg::SetZipping ; (; Int_t ; mode = kZipLarge). inline . Definition at line 218 of file THttpCallArg.h. ◆ Streamer(). void THttpCallArg::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void THttpCallArg::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 253 of file THttpCallArg.h. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpCallArg.html:31200,authenticat,authenticated,31200,doc/master/classTHttpCallArg.html,https://root.cern,https://root.cern/doc/master/classTHttpCallArg.html,1,['authenticat'],['authenticated']
Security,"file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TStringfAuthProtoUsed to specific the auth protocol; TStringfDiskServerCASTOR remote disk server; TStringfInternalPathCASTOR internal path; Bool_tfIsCastortrue if internal path is valid; Bool_tfWrittenTotrue if data has been written to file. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Create a TCastorFile. A TCastorFile is like a normal TNetFile except; that it obtains the remote node (disk server) via the CASTOR API, once; the disk server and the local file path are determined, the file will; be accessed via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root.; The other arguments are the same as for TNetFile and TFile. void FindServerAndPath(); Find the CASTOR disk server and internal file path. Int_t SysClose(Int_t fd); Close currently open file. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server on CASTOR disk server. TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); { fIsCastor = fWrittenTo = kFALSE; }. virtual ~TCastorFile(); { }. » Author: Fons Rademakers 17/09/2003 + Giulia Taurelli 29/06/2006 » Copyright (C) 1995-2006, Rene Brun and Fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TCastorFile.html:24409,access,accessed,24409,root/html530/TCastorFile.html,https://root.cern,https://root.cern/root/html530/TCastorFile.html,2,['access'],['accessed']
Security,"file should be created or overwritten. */; 11751 /* Currently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose failed. This might have different reasons, but a likely; 11781 * one is ""no space on disk"", http 507. */; 11782 conn->status_code = 507;; 11783 }; 11784 ; 11785 /* Create response (status_code has been set before) */; 11786 mg_response_header_start(conn, conn->status_code);; 11787 send_no_cache_header(conn);; 11788 send_additional_header(conn);; 11789 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11790 ; 11791 /* Send all headers - there is no body */; 11792 mg_response_header_send(conn);; 11793}; 11794 ; 11795 ; 11796static void; 11797delete_file(struct mg_connection *conn, const char *path); 11798{; 11799 struct de de;; 11800 memset(&de.file, 0, sizeof(de.file));; 11801 if (!mg_stat(conn, path, &de.file)) {; 11802 /* mg_stat returns 0 if the file does not exist */; 11803 mg_send_http_error(conn,; 11804 404,; 11805 ""Error: Cannot delete file\nFile %s not found"",; 11806 path);; 11807 return;; 11808 }; 11809 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:340784,access,access,340784,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"file should be created or overwritten. */; 11752 /* Currently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose failed. This might have different reasons, but a likely; 11782 * one is ""no space on disk"", http 507. */; 11783 conn->status_code = 507;; 11784 }; 11785 ; 11786 /* Create response (status_code has been set before) */; 11787 mg_response_header_start(conn, conn->status_code);; 11788 send_no_cache_header(conn);; 11789 send_additional_header(conn);; 11790 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11791 ; 11792 /* Send all headers - there is no body */; 11793 mg_response_header_send(conn);; 11794}; 11795 ; 11796 ; 11797static void; 11798delete_file(struct mg_connection *conn, const char *path); 11799{; 11800 struct de de;; 11801 memset(&de.file, 0, sizeof(de.file));; 11802 if (!mg_stat(conn, path, &de.file)) {; 11803 /* mg_stat returns 0 if the file does not exist */; 11804 mg_send_http_error(conn,; 11805 404,; 11806 ""Error: Cannot delete file\nFile %s not found"",; 11807 path);; 11808 return;; 11809 }; 11810 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:340817,access,access,340817,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"filep)) {; 8334#if defined(DEBUG); 8335 /* Don't use mg_cry_internal here, but only a trace, since; 8336 * this is a typical case. It will occur for every directory; 8337 * without a password file. */; 8338 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8339#endif; 8340 }; 8341 }; 8342 }; 8343}; 8344#endif /* NO_FILESYSTEMS */; 8345 ; 8346 ; 8347/* Parsed Authorization header */; 8348struct ah {; 8349 char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;; 8350};; 8351 ; 8352 ; 8353/* Return 1 on success. Always initializes the ah structure. */; 8354static int; 8355parse_auth_header(struct mg_connection *conn,; 8356 char *buf,; 8357 size_t buf_size,; 8358 struct ah *ah); 8359{; 8360 char *name, *value, *s;; 8361 const char *auth_header;; 8362 uint64_t nonce;; 8363 ; 8364 if (!ah || !conn) {; 8365 return 0;; 8366 }; 8367 ; 8368 (void)memset(ah, 0, sizeof(*ah));; 8369 if (((auth_header = mg_get_header(conn, ""Authorization"")) == NULL); 8370 || mg_strncasecmp(auth_header, ""Digest "", 7) != 0) {; 8371 return 0;; 8372 }; 8373 ; 8374 /* Make modifiable copy of the auth header */; 8375 (void)mg_strlcpy(buf, auth_header + 7, buf_size);; 8376 s = buf;; 8377 ; 8378 /* Parse authorization header */; 8379 for (;;) {; 8380 /* Gobble initial spaces */; 8381 while (isspace((unsigned char)*s)) {; 8382 s++;; 8383 }; 8384 name = skip_quoted(&s, ""="", "" "", 0);; 8385 /* Value is either quote-delimited, or ends at first comma or space.; 8386 */; 8387 if (s[0] == '\""') {; 8388 s++;; 8389 value = skip_quoted(&s, ""\"""", "" "", '\\');; 8390 if (s[0] == ',') {; 8391 s++;; 8392 }; 8393 } else {; 8394 value = skip_quoted(&s, "", "", "" "", 0); /* IE uses commas, FF; 8395 * uses spaces */; 8396 }; 8397 if (*name == '\0') {; 8398 break;; 8399 }; 8400 ; 8401 if (!strcmp(name, ""username"")) {; 8402 ah->user = value;; 8403 } else if (!strcmp(name, ""cnonce"")) {; 8404 ah->cnonce = value;; 8405 } else if (!strcmp(name, ""response"")) {; 8406 ah->response = value;; 8407 } else if (!strcmp(name, ""uri"")) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:241694,authoriz,authorization,241694,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['authoriz'],['authorization']
Security,"filep)) {; 8335#if defined(DEBUG); 8336 /* Don't use mg_cry_internal here, but only a trace, since; 8337 * this is a typical case. It will occur for every directory; 8338 * without a password file. */; 8339 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8340#endif; 8341 }; 8342 }; 8343 }; 8344}; 8345#endif /* NO_FILESYSTEMS */; 8346 ; 8347 ; 8348/* Parsed Authorization header */; 8349struct ah {; 8350 char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;; 8351};; 8352 ; 8353 ; 8354/* Return 1 on success. Always initializes the ah structure. */; 8355static int; 8356parse_auth_header(struct mg_connection *conn,; 8357 char *buf,; 8358 size_t buf_size,; 8359 struct ah *ah); 8360{; 8361 char *name, *value, *s;; 8362 const char *auth_header;; 8363 uint64_t nonce;; 8364 ; 8365 if (!ah || !conn) {; 8366 return 0;; 8367 }; 8368 ; 8369 (void)memset(ah, 0, sizeof(*ah));; 8370 if (((auth_header = mg_get_header(conn, ""Authorization"")) == NULL); 8371 || mg_strncasecmp(auth_header, ""Digest "", 7) != 0) {; 8372 return 0;; 8373 }; 8374 ; 8375 /* Make modifiable copy of the auth header */; 8376 (void)mg_strlcpy(buf, auth_header + 7, buf_size);; 8377 s = buf;; 8378 ; 8379 /* Parse authorization header */; 8380 for (;;) {; 8381 /* Gobble initial spaces */; 8382 while (isspace((unsigned char)*s)) {; 8383 s++;; 8384 }; 8385 name = skip_quoted(&s, ""="", "" "", 0);; 8386 /* Value is either quote-delimited, or ends at first comma or space.; 8387 */; 8388 if (s[0] == '\""') {; 8389 s++;; 8390 value = skip_quoted(&s, ""\"""", "" "", '\\');; 8391 if (s[0] == ',') {; 8392 s++;; 8393 }; 8394 } else {; 8395 value = skip_quoted(&s, "", "", "" "", 0); /* IE uses commas, FF; 8396 * uses spaces */; 8397 }; 8398 if (*name == '\0') {; 8399 break;; 8400 }; 8401 ; 8402 if (!strcmp(name, ""username"")) {; 8403 ah->user = value;; 8404 } else if (!strcmp(name, ""cnonce"")) {; 8405 ah->cnonce = value;; 8406 } else if (!strcmp(name, ""response"")) {; 8407 ah->response = value;; 8408 } else if (!strcmp(name, ""uri"")) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:241726,authoriz,authorization,241726,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['authoriz'],['authorization']
Security,"final;  ; const char * DataMemberInfo_Name (DataMemberInfo_t *dminfo) const final;  ; int DataMemberInfo_Next (DataMemberInfo_t *dminfo) const final;  ; Longptr_t DataMemberInfo_Offset (DataMemberInfo_t *dminfo) const final;  ; Long_t DataMemberInfo_Property (DataMemberInfo_t *dminfo) const final;  ; const char * DataMemberInfo_Title (DataMemberInfo_t *dminfo) const final;  ; const char * DataMemberInfo_TypeName (DataMemberInfo_t *dminfo) const final;  ; Long_t DataMemberInfo_TypeProperty (DataMemberInfo_t *dminfo) const final;  ; int DataMemberInfo_TypeSize (DataMemberInfo_t *dminfo) const final;  ; const char * DataMemberInfo_TypeTrueName (DataMemberInfo_t *dminfo) const final;  ; const char * DataMemberInfo_ValidArrayIndex (DataMemberInfo_t *dminfo) const final;  ; Bool_t Declare (const char *code) final;  Declare code to the interpreter, without any of the interpreter actions that could trigger a re-interpretation of the code. ;  ; Int_t DeleteGlobal (void *obj) final;  Delete obj from Cling symbol table so it cannot be accessed anymore. ;  ; Int_t DeleteVariable (const char *name) final;  Undeclare obj called name. ;  ; bool DiagnoseIfInterpreterException (const std::exception &e) const final;  ; int DisplayClass (FILE *fout, const char *name, int base, int start) const final;  ; int DisplayIncludePath (FILE *fout) const final;  Interface to cling function. ;  ; void EndOfLineAction () final;  It calls a ""fantom"" method to synchronize user keyboard input and ROOT prompt line. ;  ; int Evaluate (const char *, TInterpreterValue &) final;  Get the interpreter value corresponding to the statement. ;  ; void Execute (const char *function, const char *params, int *error=nullptr) final;  Execute a global function with arguments params. ;  ; void Execute (TObject *obj, TClass *cl, const char *method, const char *params, Bool_t objectIsConst, int *error=nullptr);  Execute a method from class cl with arguments params. ;  ; void Execute (TObject *obj, TClass *cl, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:11896,access,accessed,11896,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['access'],['accessed']
Security,"fine ROTL64(x,y) rotl64(x,y); 726#define BIG_CONSTANT(x) (x##LLU); 727#endif // !defined(_MSC_VER); 728 ; 729namespace {; 730 ; 731 /////////////////////////////////////////////////////////////////////////////; 732 /// Block read - if your platform needs to do endian-swapping or can only; 733 /// handle aligned reads, do the conversion here; 734 ; 735 R__ALWAYS_INLINE uint64_t getblock(const uint64_t* p, int i); 736 {; 737 return p[i];; 738 }; 739 ; 740 /////////////////////////////////////////////////////////////////////////////; 741 /// Finalization mix - force all bits of a hash block to avalanche; 742 ; 743 R__ALWAYS_INLINE uint64_t fmix(uint64_t k); 744 {; 745 k ^= k >> 33;; 746 k *= BIG_CONSTANT(0xff51afd7ed558ccd);; 747 k ^= k >> 33;; 748 k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);; 749 k ^= k >> 33;; 750 ; 751 return k;; 752 }; 753 ; 754 /////////////////////////////////////////////////////////////////////////////; 755 /// ""key"" is input to be hashed.; 756 /// ""len"" is the number of bytes to hash starting at ""key"".; 757 /// ""seed"" is a hash seed, ""out"" is a buffer (128 bytes) that will receive; 758 /// the results.; 759 ; 760 static void MurmurHash3_x64_128(const void * key, const int len,; 761 const uint32_t seed, uint64_t out[2] ); 762 {; 763 const uint8_t * data = (const uint8_t*)key;; 764 const int nblocks = len / 16;; 765 ; 766 uint64_t h1 = seed;; 767 uint64_t h2 = seed;; 768 ; 769 uint64_t c1 = BIG_CONSTANT(0x87c37b91114253d5);; 770 uint64_t c2 = BIG_CONSTANT(0x4cf5ad432745937f);; 771 ; 772 //----------; 773 // body; 774 ; 775 const uint64_t * blocks = (const uint64_t *)(data);; 776 ; 777 for(int i = 0; i < nblocks; i++); 778 {; 779 uint64_t k1 = getblock(blocks,i*2+0);; 780 uint64_t k2 = getblock(blocks,i*2+1);; 781 ; 782 k1 *= c1; k1 = ROTL64(k1,31); k1 *= c2; h1 ^= k1;; 783 ; 784 h1 = ROTL64(h1,27); h1 += h2; h1 = h1*5+0x52dce729;; 785 ; 786 k2 *= c2; k2 = ROTL64(k2,33); k2 *= c1; h2 ^= k2;; 787 ; 788 h2 = ROTL64(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:22642,hash,hash,22642,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['hash'],['hash']
Security,"finition Reader.cxx:468; TMVA::Reader::BookMVAIMethod * BookMVA(const TString &methodTag, const TString &weightfile)read method name from weight fileDefinition Reader.cxx:368; TMVA::Reader::AddSpectatorvoid AddSpectator(const TString &expression, Float_t *)Add a float spectator or expression to the reader.Definition Reader.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; AuthorAndreas Hoecker ; Definition in file TMVAClassificationCategoryApplication.C. tutorialstmvaTMVAClassificationCategoryApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:10244,access,access,10244,doc/master/TMVAClassificationCategoryApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html,2,['access'],['access']
Security,"finition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:325059,access,accessor,325059,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['accessor']
Security,"finition TClass.cxx:2179; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4394; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6989; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5763; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3489; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7522; TClass::Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:327697,access,accessor,327697,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['accessor']
Security,"finition TH1.h:324; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; c1return c1Definition legend1.C:41; ratioplot2Definition ratioplot2.py:1; . Error options for difference divided by uncertainty and fit residual; The uncertainty that is used in the calculation can be steered by providing options to the option argument. Option Description . errasym Uses calculated asymmetric errors from TH1::GetBinErrorUp/TH1::GetBinErrorLow. Note that you need to set TH1::SetBinErrorOption first . errfunc Uses \( \sqrt{f(x)} \) as the error . The asymmetric error case uses the upper or lower error depending on the relative size of the bin contents, or the bin content and the function value. Access to internal parts; You can access the internal objects that are used to construct the plot via a series of methods. TRatioPlot::GetUpperPad and TRatioPlot::GetLowerPad can be used to draw additional elements on top of the existing ones. TRatioPlot::GetLowerRefGraph returns a reference to the lower pad's graph that is responsible for the range, which enables you to modify the range. Definition at line 43 of file TRatioPlot.h. Public Member Functions;  TRatioPlot ();  TRatioPlot default constructor. ;  ;  TRatioPlot (TH1 *h1, Option_t *option="""", TFitResult *fitres=nullptr);  Constructor for one histogram and a fit. ;  ;  TRatioPlot (TH1 *h1, TH1 *h2, Option_t *option=""pois"");  Constructor for two histograms. ;  ;  TRatioPlot (TH1 *h1, THStack *st, Option_t *option=""pois"");  Constructor which accepts a THStack and a histogram. ;  ;  TRatioPlot (THStack *st, TH1 *h2, Option_t *option=""pois"");  Constructor which accepts a THStack and a histogram. ;  ;  ~TRatioPlot () override;  Destructor. ;  ; void Draw (Option_t *chopt="""") override;  Draws ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRatioPlot.html:6301,access,access,6301,doc/master/classTRatioPlot.html,https://root.cern,https://root.cern/doc/master/classTRatioPlot.html,1,['access'],['access']
Security,"finition at line 125 of file TCling.h. ◆ fParsedPayloadsAddresses. std::set<const char*> TCling::fParsedPayloadsAddresses. private . Definition at line 123 of file TCling.h. ◆ fPayloads. std::set<size_t> TCling::fPayloads. private . Definition at line 122 of file TCling.h. ◆ fPendingRdicts. std::map<std::string, llvm::StringRef> TCling::fPendingRdicts. private . Definition at line 634 of file TCling.h. ◆ fPrevLoadedDynLibInfo. void* TCling::fPrevLoadedDynLibInfo. private . Definition at line 137 of file TCling.h. ◆ fPrompt. char TCling::fPrompt[64]. private . Definition at line 110 of file TCling.h. ◆ fRegisterModuleDyLibs. std::vector<void*> TCling::fRegisterModuleDyLibs. private . Definition at line 138 of file TCling.h. ◆ fRootmapFiles. TObjArray* TCling::fRootmapFiles. private . Definition at line 126 of file TCling.h. ◆ fRootmapLoadPath. TString TCling::fRootmapLoadPath. private . Definition at line 116 of file TCling.h. ◆ fSharedLibs. TString TCling::fSharedLibs. private . Definition at line 113 of file TCling.h. ◆ fSpecialObjectMaps. std::map<SpecialObjectLookupCtx_t, SpecialObjectMap_t> TCling::fSpecialObjectMaps. private . Definition at line 153 of file TCling.h. ◆ fStringHashFunction. std::hash<std::string> TCling::fStringHashFunction. private . Definition at line 124 of file TCling.h. ◆ fTemporaries. std::vector<cling::Value>* TCling::fTemporaries. private . Definition at line 133 of file TCling.h. ◆ fTransactionCount. ULong64_t TCling::fTransactionCount. private . Definition at line 148 of file TCling.h. ◆ fTransactionHeadersMap. std::map<const cling::Transaction*,size_t> TCling::fTransactionHeadersMap. private . Definition at line 120 of file TCling.h. ◆ kNullArgv. constexpr const char* TCling::kNullArgv[] = {nullptr}. staticconstexprprivate . Definition at line 185 of file TCling.h. core/metacling/src/TCling.h; core/metacling/src/TCling.cxx. TCling. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:24 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:147558,hash,hash,147558,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['hash'],['hash']
Security,"finition at line 136 of file RNTupleWriteOptions.hxx. ◆ GetWriteBufferSize(). std::size_t ROOT::Experimental::RNTupleWriteOptions::GetWriteBufferSize ; (; ); const. inline . Definition at line 133 of file RNTupleWriteOptions.hxx. ◆ SetApproxZippedClusterSize(). void ROOT::Experimental::RNTupleWriteOptions::SetApproxZippedClusterSize ; (; std::size_t ; val). Definition at line 53 of file RNTupleWriteOptions.cxx. ◆ SetCompression() [1/2]. void ROOT::Experimental::RNTupleWriteOptions::SetCompression ; (; int ; val). inline . Definition at line 106 of file RNTupleWriteOptions.hxx. ◆ SetCompression() [2/2]. void ROOT::Experimental::RNTupleWriteOptions::SetCompression ; (; RCompressionSetting::EAlgorithm::EValues ; algorithm, . int ; compressionLevel . ). inline . Definition at line 107 of file RNTupleWriteOptions.hxx. ◆ SetEnablePageChecksums(). void ROOT::Experimental::RNTupleWriteOptions::SetEnablePageChecksums ; (; bool ; val). inline . Note that turning off page checksums will also turn off the same page merging optimization (see tuning.md) ; Definition at line 141 of file RNTupleWriteOptions.hxx. ◆ SetInitialNElementsPerPage(). void ROOT::Experimental::RNTupleWriteOptions::SetInitialNElementsPerPage ; (; std::size_t ; val). Definition at line 65 of file RNTupleWriteOptions.cxx. ◆ SetMaxUnzippedClusterSize(). void ROOT::Experimental::RNTupleWriteOptions::SetMaxUnzippedClusterSize ; (; std::size_t ; val). Definition at line 59 of file RNTupleWriteOptions.cxx. ◆ SetMaxUnzippedPageSize(). void ROOT::Experimental::RNTupleWriteOptions::SetMaxUnzippedPageSize ; (; std::size_t ; val). Definition at line 71 of file RNTupleWriteOptions.cxx. ◆ SetPageBufferBudget(). void ROOT::Experimental::RNTupleWriteOptions::SetPageBufferBudget ; (; std::size_t ; val). inline . Definition at line 125 of file RNTupleWriteOptions.hxx. ◆ SetUseBufferedWrite(). void ROOT::Experimental::RNTupleWriteOptions::SetUseBufferedWrite ; (; bool ; val). inline . Definition at line 128 of file RNTupleWrit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html:7269,checksum,checksums,7269,doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,1,['checksum'],['checksums']
Security,"finition at line 7193 of file TClass.cxx. ◆ FindConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const TClass * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7204 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7066 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7036 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4772 of file TClass.cxx. ◆ ForceReload(). void TClass::ForceReload ; (; TClass * ; oldcl). we found at least one equivalent. ; let's force a reload ; Definition at line 1336 of file TClass.cxx. ◆ GetActualClass(). TClass * TClass::GetActualClass ; (; const void * ; object); const. Return a pointer to the real class of the object. ; This is equivalent to object->IsA() when the class has a ClassDef. It is REQUIRED that object is coming from a proper poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:68206,checksum,checksum,68206,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['checksum'],['checksum']
Security,"finition at line 7260 of file TClass.cxx. ◆ FindConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const TClass * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7271 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7133 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7103 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4839 of file TClass.cxx. ◆ ForceReload(). void TClass::ForceReload ; (; TClass * ; oldcl). we found at least one equivalent. ; let's force a reload ; Definition at line 1403 of file TClass.cxx. ◆ GetActualClass(). TClass * TClass::GetActualClass ; (; const void * ; object); const. Return a pointer to the real class of the object. ; This is equivalent to object->IsA() when the class has a ClassDef. It is REQUIRED that object is coming from a proper poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:68207,checksum,checksum,68207,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['checksum'],['checksum']
Security,"finition of the TRef fWebHistogram had been changed the compiled or interpreted function GetWebHistogram() would have been called instead of the Cling script GetWebHistogram.C.; 11.4.6 Array of TRef; When storing multiple TRefs, it is more efficient to use a TRefArray. The efficiency is due to having a single pointer fPID for all TRefs in the array. It has a dynamic compact table of fUniqueIDs. We recommend that you use a TRefArray rather then a collection of TRefs.; Example:. Suppose a TObjArray *mytracks containing a list of Track objects.; Suppose a TRefArray *pions containing pointers to the pion tracks in mytracks. This list is created with statements like: pions->Add(track);; Suppose a TRefArray *muons containing pointers to the muon tracks in mytracks. The 3 arrays mytracks,pions and muons may be written separately.; 11.5 Schema Evolution; Schema evolution is a problem faced by long-lived data. When a schema changes, existing persistent data can become inaccessible unless the system provides a mechanism to access data created with previous versions of the schema. In the lifetime of collaboration, the class definitions (i.e. the schema) are likely to change frequently. Not only can the class itself change, but any of its parent classes or data member classes can change also. This makes the support for schema evolution necessary.; ROOT fully supports schema evolution. The next figure below illustrates some of the scenarios. The ROOT schema evolution. The top half represents different versions of the shared library with the class definitions. These are the in-memory class versions. The bottom half represents data files that contain different versions of the classes. An old version of a shared library and a file with new class definitions - this can be the case when someone has not updated the library and is reading a new file.; Reading a file with a shared library that is missing a class definition (i.e. missing class D).; Reading a file without any class defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:489531,access,access,489531,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"first 10 entries *that pass the; 543preceding filter*.; 544 ; 545Ranges allow ""early quitting"": if all branches of execution of a functional graph reached their `end` value of; 546processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations.; 547 ; 548\anchor custom-columns; 549### Custom columns; 550Custom columns are created by invoking `Define(name, f, columnList)`. As usual, `f` can be any callable object; 551(function, lambda expression, functor class...); it takes the values of the columns listed in `columnList` (a list of; 552strings) as parameters, in the same order as they are listed in `columnList`. `f` must return the value that will be; 553assigned to the temporary column.; 554 ; 555A new variable is created called `name`, accessible as if it was contained in the dataset from subsequent; 556transformations/actions.; 557 ; 558Use cases include:; 559- caching the results of complex calculations for easy and efficient multiple access; 560- extraction of quantities of interest from complex objects; 561- branch aliasing, i.e. changing the name of a branch; 562 ; 563An exception is thrown if the `name` of the new column/branch is already in use for another branch in the TTree.; 564 ; 565It is also possible to specify the quantity to be stored in the new temporary column as a C++ expression with the method; 566`Define(name, expression)`. For example this invocation; 567 ; 568~~~{.cpp}; 569df.Define(""pt"", ""sqrt(px*px + py*py)"");; 570~~~; 571 ; 572will create a new column called ""pt"" the value of which is calculated starting from the columns px and py. The system; 573builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches; 574from the names of the variables specified by the user.; 575 ; 576#### Custom columns as function of slot and entry number; 577 ; 578It is possible to create custom columns also as a function of the processing slot and en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:34369,access,access,34369,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,"first 10 entries *that pass the; 583preceding filter*.; 584 ; 585Ranges allow ""early quitting"": if all branches of execution of a functional graph reached their `end` value of; 586processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations.; 587 ; 588\anchor custom-columns; 589### Custom columns; 590Custom columns are created by invoking `Define(name, f, columnList)`. As usual, `f` can be any callable object; 591(function, lambda expression, functor class...); it takes the values of the columns listed in `columnList` (a list of; 592strings) as parameters, in the same order as they are listed in `columnList`. `f` must return the value that will be; 593assigned to the temporary column.; 594 ; 595A new variable is created called `name`, accessible as if it was contained in the dataset from subsequent; 596transformations/actions.; 597 ; 598Use cases include:; 599- caching the results of complex calculations for easy and efficient multiple access; 600- extraction of quantities of interest from complex objects; 601- branch aliasing, i.e. changing the name of a branch; 602 ; 603An exception is thrown if the `name` of the new column/branch is already in use for another branch in the TTree.; 604 ; 605It is also possible to specify the quantity to be stored in the new temporary column as a C++ expression with the method; 606`Define(name, expression)`. For example this invocation; 607 ; 608~~~{.cpp}; 609df.Define(""pt"", ""sqrt(px*px + py*py)"");; 610~~~; 611 ; 612will create a new column called ""pt"" the value of which is calculated starting from the columns px and py. The system; 613builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches; 614from the names of the variables specified by the user.; 615 ; 616#### Custom columns as function of slot and entry number; 617 ; 618It is possible to create custom columns also as a function of the processing slot and en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:36009,access,access,36009,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsAnaConvPdf::_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDecay.html:41786,access,access,41786,root/html534/RooDecay.html,https://root.cern,https://root.cern/root/html534/RooDecay.html,1,['access'],['access']
Security,"fmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileInfo&operator=(const TFileInfo&); voidParseInput(const char* in). Data Members; public:. enum EStatusBits { kStaged; kCorrupted; kSortWithIndex; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TUrl*fCurrentUrl! current URL to access the file, points to URL; Int_tfIndexIndex to be used when sorting with index; TMD5*fMD5-> md5 digest of the file; TList*fMetaDataListgeneric list of file meta data object(s); Long64_tfSizefile size; TUUID*fUUID-> uuid of the referenced file; TList*fUrlListlist of file URLs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileInfo(const char* url = 0, Long64_t size = -1, const char* uuid = 0, const char* md5 = 0, TObject* meta = 0); Constructor. TFileInfo(const TFileInfo& ); Copy constructor. ~TFileInfo(); Destructor. void ParseInput(const char* in); Parse the input line to extract init information from 'in'; the input; string is tokenized on ' '; the tokens can be prefixed by the following; keys:. url:<url1>,<url2>,... URLs for the file; stored in the order given; sz:<size> size of the file in bytes; md5:<md5_ascii> MD5 sum of the file in ASCII form; uuid:<uuid> UUID of the file. tree:<name>,<entries>,<first>,<last>; meta-information about a tree in the file; the; should be in the form <subdir>/tree-name;'entries' is; the number of entries in the tree; 'fir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFileInfo.html:6431,access,access,6431,root/html534/TFileInfo.html,https://root.cern,https://root.cern/root/html534/TFileInfo.html,1,['access'],['access']
Security,"for (Int_t i = 0; i < 25000; i++) {; 1835 gRandom->Rannor(px,py);; 1836 hcont4->Fill(px-1,5*py);; 1837 hcont4->Fill(2+0.5*px,2*py-10.,0.1);; 1838 }; 1839 hcont4->Draw(""CONT4Z"");; 1840}; 1841End_Macro; 1842 ; 1843The default number of contour levels is 20 equidistant levels and can be changed; 1844with `TH1::SetContour()` or `TStyle::SetNumberContours()`.; 1845 ; 1846\anchor HP16a; 1847#### The LIST option; 1848 ; 1849When option `LIST` is specified together with option; 1850`CONT`, the points used to draw the contours are saved in; 1851`TGraph` objects:; 1852 ; 1853 h->Draw(""CONT LIST"");; 1854 gPad->Update();; 1855 ; 1856The contour are saved in `TGraph` objects once the pad is painted.; 1857Therefore to use this functionality in a macro, `gPad->Update()`; 1858should be performed after the histogram drawing. Once the list is; 1859built, the contours are accessible in the following way:; 1860 ; 1861 TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; 1862 Int_t ncontours = contours->GetSize();; 1863 TList *list = (TList*)contours->At(i);; 1864 ; 1865Where `i` is a contour number, and list contains a list of; 1866`TGraph` objects.; 1867For one given contour, more than one disjoint polyline may be generated.; 1868The number of TGraphs per contour is given by:; 1869 ; 1870 list->GetSize();; 1871 ; 1872To access the first graph in the list one should do:; 1873 ; 1874 TGraph *gr1 = (TGraph*)list->First();; 1875 ; 1876 ; 1877The following example (ContourList.C) shows how to use this functionality.; 1878 ; 1879Begin_Macro(source); 1880../../../tutorials/hist/ContourList.C; 1881End_Macro; 1882 ; 1883\anchor HP16b; 1884#### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options; 1885 ; 1886The following options select the `CONT4` option and are useful for; 1887sky maps or exposure maps (earth.C).; 1888 ; 1889| Option | Description |; 1890|--------------|---------------------------------------------------------------|; 1891| ""AITOFF"" | Draw ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:77796,access,accessible,77796,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['access'],['accessible']
Security,"for SecContext object. ; User and host from url = user@host . ; Definition at line 78 of file TSecContext.cxx. ◆ TSecContext() [3/3]. TSecContext::TSecContext ; (; const char * ; user, . const char * ; host, . Int_t ; meth, . Int_t ; offset, . const char * ; id, . const char * ; token, . TDatime ; expdate = kROOTTZERO, . void * ; ctx = nullptr . ). Ctor for SecContext object. ; Definition at line 42 of file TSecContext.cxx. ◆ ~TSecContext(). TSecContext::~TSecContext ; (; ). virtual . Dtor: delete (deActivate, local/remote cleanup, list removal) all what is still active. ; Definition at line 153 of file TSecContext.cxx. Member Function Documentation. ◆ AddForCleanup(). void TSecContext::AddForCleanup ; (; Int_t ; port, . Int_t ; proto, . Int_t ; type . ). Create a new TSecContextCleanup Internally is added to the list. ; Definition at line 215 of file TSecContext.cxx. ◆ AsString(). const char * TSecContext::AsString ; (; TString & ; out). virtual . Returns short string with relevant information about this security context. ; Reimplemented in TRootSecContext.; Definition at line 313 of file TSecContext.cxx. ◆ Class(). static TClass * TSecContext::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSecContext::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSecContext::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 94 of file TSecContext.h. ◆ Cleanup(). void TSecContext::Cleanup ; (; ). private . Cleanup what is still active. ; Definition at line 160 of file TSecContext.cxx. ◆ CleanupSecContext(). Bool_t TSecContext::CleanupSecContext ; (; Bool_t ; all). privatevirtual . Ask remote client to cleanup security context 'ctx' If 'all', all sec context with the same host as ctx are cleaned. ; Reimplemented in TRootSecContext.; Definition at line 336 of file TSecContext.cxx. ◆ DeActivate(). void TSecContext::DeActivate ; (; Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSecContext.html:13708,secur,security,13708,doc/master/classTSecContext.html,https://root.cern,https://root.cern/doc/master/classTSecContext.html,1,['secur'],['security']
Security,"for a class. ; Definition at line 3798 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3827 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populated with all the defined function and currently instantiated function template. ; Definition at line 3812 of file TClass.cxx. ◆ GetListOfRealData(). TList * TClass::GetListOfRealData ; (; ); const. inline . Definition at line 453 of file TClass.h. ◆ GetListOfUsingDataMembers(). TList * TClass::GetListOfUsingDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of using declarations of a class. ; Definition at line 3786 of file TClass.cxx. ◆ GetMenuItems(). void TClass::GetMenuItems ; (; TList * ; listitems). Returns list of methods accessible by context menu. ; Definition at line 3874 of file TClass.cxx. ◆ GetMenuList(). TList * TClass::GetMenuList ; (; ); const. Return the list of menu items associated with the class. ; Definition at line 4341 of file TClass.cxx. ◆ GetMerge(). ROOT::MergeFunc_t TClass::GetMerge ; (; ); const. Return the wrapper around Merge. ; Definition at line 7431 of file TClass.cxx. ◆ GetMethod(). TMethod * TClass::GetMethod ; (; const char * ; method, . const char * ; params, . Bool_t ; objectIsConst = kFALSE . ). Find the best method (if there is one) matching the parameters. ; The params string must contain argument values, like ""3189, \""aap\"", 1.3"". The function invokes GetClassMethod to search for a possible method in the class itself or in its base classes. Returns 0 in case method is not found. ; Definition at line 4411 of file TClass.cxx. ◆ GetMethodAllAny(). TMethod * TClass::GetMethodAllAny ; (; const char * ; method). Return pointer to method without looking at parameters. ; Does l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:84257,access,accessible,84257,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['access'],['accessible']
Security,"for a class. ; Definition at line 3865 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3894 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populated with all the defined function and currently instantiated function template. ; Definition at line 3879 of file TClass.cxx. ◆ GetListOfRealData(). TList * TClass::GetListOfRealData ; (; ); const. inline . Definition at line 453 of file TClass.h. ◆ GetListOfUsingDataMembers(). TList * TClass::GetListOfUsingDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of using declarations of a class. ; Definition at line 3853 of file TClass.cxx. ◆ GetMenuItems(). void TClass::GetMenuItems ; (; TList * ; listitems). Returns list of methods accessible by context menu. ; Definition at line 3941 of file TClass.cxx. ◆ GetMenuList(). TList * TClass::GetMenuList ; (; ); const. Return the list of menu items associated with the class. ; Definition at line 4408 of file TClass.cxx. ◆ GetMerge(). ROOT::MergeFunc_t TClass::GetMerge ; (; ); const. Return the wrapper around Merge. ; Definition at line 7498 of file TClass.cxx. ◆ GetMethod(). TMethod * TClass::GetMethod ; (; const char * ; method, . const char * ; params, . Bool_t ; objectIsConst = kFALSE . ). Find the best method (if there is one) matching the parameters. ; The params string must contain argument values, like ""3189, \""aap\"", 1.3"". The function invokes GetClassMethod to search for a possible method in the class itself or in its base classes. Returns 0 in case method is not found. ; Definition at line 4478 of file TClass.cxx. ◆ GetMethodAllAny(). TMethod * TClass::GetMethodAllAny ; (; const char * ; method). Return pointer to method without looking at parameters. ; Does l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:84258,access,accessible,84258,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['access'],['accessible']
Security,"for libpng and libbzip2 on the system and adjust FREETYPE_LIBRARIES to include -lpng and -lbzip2. The current solution goes for the minimal configuration. The original request for this update was posted here.; 3D Graphics Libraries; Geometry Libraries; Database Libraries; Networking Libraries; THttpServer; Support of POST HTTP requests. For example, ROOT objects can be send with POST request and used as arguments of objects method execution in exe.bin and exe.json requests. Request and response HTTP headers are now directly accessible in THttpCallArg class; When command is registered with THttpServer::RegisterCommand() method, one could configure additional arguments which should be submitted when command is executed with cmd.json requests; Introduce restriction rules for objects access with THttpServer::Restrict() method. Up to now general read-only flag was applied - either everything read-only or everything is fully accessible. Now one could restrict access to different parts of objects hierarchy or even fully ‘hide’ them from the client. Restriction based on user account name, which is applied when htdigest authentication is configured. One also able to allow execution of selected methods.; Implement multi.bin and multi.json requests. One could request many items with single HTTP request. Let optimize communication between server and client.; With SNIFF tag in ClassDef() comments one could expose different properties, which than exposed by the TRootSniffer to the client with h.json requests. Such possibility ease implementation of client-side code for custom classes.; Allow to bind http port with loopback address. This restrict access to http server only from localhost. One could either specify ‘loopback’ option in constructor: new THttpServer(“http:8080?loopback”) or in clear text specify IP address to which http socket should be bind: new THttpServer(“http:127.0.0.1:8080”) If host has several network interfaces, one could select one for binding: new THttpServer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:18867,access,access,18867,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['access'],['access']
Security,"for the next result row, NextResultRow() method should be called.; Value from each column can be retrieved with the GetInt(), GetDouble(),; GetString() and other methods. There are no strict limitations on which method should be used; to get column values. GetString() can be used as a generic method,; which should always return correct result, but also conversions between most; basic data types are supported. For instance, if a column contains integer; values, GetInt(), GetLong64(), GetDouble() and GetString() methods can be used.; If column has floating point format, GetDouble() and GetString() methods can; be used without loss of precision while GetInt() or GetLong64() will return; only the integer part of the value. One also can test whether; a value is NULL with the IsNull() method. The buffer length specified for a statement in the TSQLServer::Statement() call; will also be used to allocate buffers for column values. Usage of these; buffers is transparent for users and does not limit the number of rows; which can be accessed with one statement. Again, local databases do not work; with buffers inside TSQLStatement at all and ignore this value.; Example of select query:. stmt = serv->Statement(""SELECT * FROM TESTTABLE"", 100);; // process statement; if (stmt->Process()) {; // store result of statement in buffer; stmt->StoreResult();. // display info about selected field; cout << ""NumFields = "" << stmt->GetNumFields() << endl;; for (int n=0;n<stmt->GetNumFields();n++); cout << ""Field "" << n << "" = "" << stmt->GetFieldName(n) << endl;. // extract rows one after another; while (stmt->NextResultRow()) {; Double_t id1 = stmt->GetDouble(0);; UInt_t id2 = stmt->GetUInt(1);; const char* name1 = stmt->GetString(2);; const char* name2 = stmt->GetString(3);; cout << id1 << "" - "" << id2 << "" "" << name1 << "" "" << name2 << endl;; }; }. 4. Working with date/time parameters. The current implementation supports date, time, date&time and timestamp; data (all time intervals are not s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLStatement.html:6960,access,accessed,6960,root/html534/TSQLStatement.html,https://root.cern,https://root.cern/root/html534/TSQLStatement.html,1,['access'],['accessed']
Security,"for the next result row, NextResultRow() method should be called.; Value from each column can be retrieved with the GetInt(), GetDouble(),; GetString() and other methods. There are no strict limitations on which method should be used; to get column values. GetString() can be used as a generic method,; which should always return correct result, but also conversions between most; basic data types are supported. For instance, if a column contains integer; values, GetInt(), GetLong64(), GetDouble() and GetString() methods can be used.; If column has floating point format, GetDouble() and GetString() methods can; be used without loss of precision while GetInt() or GetLong64() will return; only the integer part of the value. One also can test whether; a value is NULL with the IsNull() method. The buffer length specified for a statement in the TSQLServer::Statement() call; will also be used to allocate buffers for column values. Usage of these; buffers is transparent for users and does not limit the number of rows; which can be accessed with one statement. Again, local databases do not work; with buffers inside TSQLStatement at all and ignore this value.; Example of select query:. stmt = serv->Statement(""SELECT * FROM TESTTABLE"", 100);; // process statement; if (stmt->Process()) {; // store result of statement in buffer; stmt->StoreResult();. // display info about selected field; std::cout << ""NumFields = "" << stmt->GetNumFields() << std::endl;; for (int n=0;n<stmt->GetNumFields();n++); std::cout << ""Field "" << n << "" = "" << stmt->GetFieldName(n) << std::endl;. // extract rows one after another; while (stmt->NextResultRow()) {; Double_t id1 = stmt->GetDouble(0);; UInt_t id2 = stmt->GetUInt(1);; const char* name1 = stmt->GetString(2);; const char* name2 = stmt->GetString(3);; std::cout << id1 << "" - "" << id2 << "" "" << name1 << "" "" << name2 << std::endl;; }; }. 4. Working with date/time parameters. The current implementation supports date, time, date&time and timestamp; data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLStatement.html:6984,access,accessed,6984,root/html602/TSQLStatement.html,https://root.cern,https://root.cern/root/html602/TSQLStatement.html,2,['access'],['accessed']
Security,"for the sum of event sizes, you need to add a variable in your macro. We want to histogram the particles' fPosX; the type of the data member should thus be TH1F *. TH1F is a 1 dimensional histogram storing floats for each bin, see the documentation. Don't forget to initialize the histogram pointer to 0, again just like for the event size sum.; Creating the Histogram; You then create the object with new TH1F(""hPosX"", ""Position in X"", 20, -5, 5);; Associate error bars with this histogram (see TH1F::Sumw2()); Filling the Histogram; The goal is to fill the histogram with the value of fPosX from the tree for all particles with a momentum > 40. You will need access to the particles' total momentum and their X position. Each TTree entry has several particles; it's thus easiest to use one TTreeReaderArray each for these Double_t values, for instance TTreeReaderArray particlesMomentum(myReader, ""fParticles.fMomentum"");. The TTreeReaderArray works just like the TTreeReaderValue we have used before, but gives you access to the number of particles using particlesMomentum.GetSize() and the n-th particle using the particlesMomentum[n] operator.; The analysis happens in loops. The outer loop is iterating through the TTree entries, using the TTreeReader::Next() loop - just as before. For each TTree entry, loop over all particles of the TTree entry with a simple for loop. For each particle, check that its momentum is > 40; if it is, fill the histogram (see TH1F::Fill()) with the fPosX value of that particle.; This step involves writing some code (similar to the code you have for the event size). If you get lost (SPOILER ALERT!): the solution is at the end of this page.; Fitting and Drawing the Histogram; Once the histogram is filled, fit it with a pol2 using TH1::Fit(""pol2""). Here ""pol2"" is ROOT's short name for ""polynomial of 2nd degree"", i.e. [0] + [1]x + [2]x*x, aka ""parabola"".; ""Fitting"" means using a function (in this case the pol2) with one or more free parameters ([0]..[2] in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/histogramming.html:3029,access,access,3029,d/histogramming.html,https://root.cern,https://root.cern/d/histogramming.html,1,['access'],['access']
Security,"for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  ►NDetail;  CTBranchProxyBase class for all the proxy object ;  ►CTCollectionProxyInfo;  CAddress;  CEnvironSmall helper to save proxy environment in the event of recursive calls ;  CEnvironBase;  CInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CIteratorsSmall helper to implement the function to create,access and destroy iterators ;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValueSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< bool > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t > >;  CIterators;  ►CTSchemaRuleSet;  CTMatches;  ►NExecutorUtils;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental;  ►NDetail;  CTHistBinIterIterates over the bins of a THist or THistImpl ;  CTHistBinPtrPoints to a histogram bin (or actually a THistBinRef) ;  CTHistBinRefRepresents a bin reference ;  CTHistBinStatConst view on a bin's statistical data ;  CTHistDataA THistImplBase's data, provides accessors to all its statist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:10877,access,accesses,10877,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['access'],['accesses']
Security,"from TObject.; Definition at line 25 of file TDocInfo.cxx. ◆ Hash(). ULong_t TClassDocInfo::Hash ; (; ); const. overridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TClassDocInfo::HashULong_t Hash() const overrideReturn hash value for this object.Definition TDocInfo.cxx:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 31 of file TDocInfo.cxx. ◆ HaveSource(). Bool_t TClassDocInfo::HaveSource ; (; ); const. inline . Definition at line 71 of file TDocInfo.h. ◆ IsA(). TClass * TClassDocInfo::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 100 of file TDocInfo.h. ◆ IsSelected(). Bool_t TClassDocInfo::IsSelected ; (; ); const. inline . Definition at line 70 of file TDocInfo.h. ◆ IsSortable(). Bool_t TClassDocInfo::IsSortable ; (; ); const. inlineoverridevirtual . Reimplement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassDocInfo.html:15336,hash,hash,15336,doc/master/classTClassDocInfo.html,https://root.cern,https://root.cern/doc/master/classTClassDocInfo.html,1,['hash'],['hash']
Security,"frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");. If there is no authentication information in the 'options' argument; (i.e. not AUTH=""...."") the values of the environmental variables; S3_ACCESS_KEY and S3_SECRET_KEY (if set) are expected to contain; the access key id and the secret access key, respectively. You have; been provided with these credentials by your S3 service provider. If neither the AUTH information is provided in the 'options' argument; nor the environmental variables are set, we try to open the file; without providing any authentication information to the server. This; is useful when the file is set an access control that allows for; any unidentified user to read the file. Bool_t ParseOptions(Option_t* options, TString& accessKey, TString& secretKey); Extracts the S3 authentication key pair (access key and secret key); from the options. The authentication credentials can be specified in; the options provided to the constructor of this class as a string; containing: ""AUTH=<access key>:<secret key>"" and can include other; options, for instance ""NOPROXY"" for not using the HTTP proxy for; accessing this file's contents.; For instance:; ""NOPROXY AUTH=F38XYZABCDeFgHiJkLm:V+frt4re7J1euSNFnmaf8wwmI401234E7kzxZ/TTM+"". Int_t GetHead(); Overwrites TWebFile::GetHead() for retrieving the HTTP headers of this; file. Uses TS3HTTPRequest to generate an HTTP HEAD request which includes; the authorization header expected by the S3 server. void SetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); Overwrites TWebFile::SetMsgReadBuffer10() for setting the HTTP GET; request compliant to the authentication mechanism used by the S3; protocol. The GET request must contain an ""Authorization"" header with; the signature of the request, generated using the user's secret access; key. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf). void ProcessHttpHeader(const TString& headerLine); This method is called by the super-class TWebFile when",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:29807,authenticat,authentication,29807,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,9,"['access', 'authenticat']","['access', 'accessing', 'authentication']"
Security,"fsize = 0) const. protected:. virtual voidAdd(TObject* arg, Int_t refCount); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidswapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize); Constructor with hashing threshold. If collection size exceeds threshold; a hash table is added. RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'newAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinkedList.html:6436,hash,hashing,6436,root/html526/RooLinkedList.html,https://root.cern,https://root.cern/root/html526/RooLinkedList.html,1,['hash'],['hashing']
Security,"ftware is furnished to do so, subject to the following conditions:; 11 *; 12 * The above copyright notice including the dates of first publication and; 13 * either this permission notice or a reference to; 14 * http://oss.sgi.com/projects/FreeB/; 15 * shall be included in all copies or substantial portions of the Software.; 16 *; 17 * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS; 18 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; 19 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL; 20 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,; 21 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF; 22 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; 23 * SOFTWARE.; 24 *; 25 * Except as contained in this notice, the name of Silicon Graphics, Inc.; 26 * shall not be used in advertising or otherwise to promote the sale, use or; 27 * other dealings in this Software without prior written authorization from; 28 * Silicon Graphics, Inc.; 29 */; 30/*; 31** Author: Eric Veach, July 1994.; 32**; 33*/; 34 ; 35#include ""gluos.h""; 36#include <stddef.h>; 37#include <assert.h>; 38#include ""mesh.h""; 39#include ""memalloc.h""; 40 ; 41#ifndef TRUE; 42#define TRUE 1; 43#endif; 44#ifndef FALSE; 45#define FALSE 0; 46#endif; 47 ; 48static GLUvertex *allocVertex(); 49{; 50 return (GLUvertex *)memAlloc( sizeof( GLUvertex ));; 51}; 52 ; 53static GLUface *allocFace(); 54{; 55 return (GLUface *)memAlloc( sizeof( GLUface ));; 56}; 57 ; 58/************************ Utility Routines ************************/; 59 ; 60/* MakeEdge creates a new pair of half-edges which form their own loop.; 61 * No vertex or face structures are allocated, but these must be assigned; 62 * before the current edge operation is completed.; 63 */; 64static GLUhalfEdge *MakeEdge( GLUhalfEdge *eNext ); 65{; 66 GLUhalfEdge *e;; 67 GLUhalfEdge *eSym;; 68 GLUhalfEdge *ePrev;; 69 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mesh_8c_source.html:1760,authoriz,authorization,1760,doc/master/mesh_8c_source.html,https://root.cern,https://root.cern/doc/master/mesh_8c_source.html,1,['authoriz'],['authorization']
Security,"func)Set call-back function for new connection.Definition RWebWindow.cxx:1743; ROOT::RWebWindow::IsShownbool IsShown() constReturns true when window was shown at least once.Definition RWebWindow.hxx:369; ROOT::RWebWindow::Syncvoid Sync()Special method to process all internal activity when window runs in separate thread.Definition RWebWindow.cxx:1236; ROOT::RWebWindow::UseServerThreadsvoid UseServerThreads()Let use THttpServer threads to process requests WARNING!!! only for expert use Should be only used wh...Definition RWebWindow.cxx:1667; ROOT::RWebWindow::SetGeometryvoid SetGeometry(unsigned width, unsigned height)Set window geometry. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:262; ROOT::RWebWindow::TerminateROOTvoid TerminateROOT()Terminate ROOT session Tries to correctly close THttpServer, associated with RWebWindowsManager After...Definition RWebWindow.cxx:1893; ROOT::RWebWindow::fUseCurrentDirbool fUseCurrentDir! if window can access local files via currentdir/ path of http serverDefinition RWebWindow.hxx:155; ROOT::RWebWindow::Sendvoid Send(unsigned connid, const std::string &data)Sends data to specified connection.Definition RWebWindow.cxx:1609; ROOT::RWebWindow::Showunsigned Show(const RWebDisplayArgs &args="""")Show window in specified location.Definition RWebWindow.cxx:191; ROOT::RWebWindow::GetServerTHttpServer * GetServer()Return THttpServer instance serving requests to the window.Definition RWebWindow.cxx:181; ROOT::RWebWindow::AddDisplayHandleunsigned AddDisplayHandle(bool headless_mode, const std::string &key, std::unique_ptr< RWebDisplayHandle > &handle)Add display handle and associated key Key is large random string generated when starting new window W...Definition RWebWindow.cxx:482; ROOT::RWebWindow::ConnectionsList_tstd::vector< std::shared_ptr< WebConn > > ConnectionsList_tDefinition RWebWindow.hxx:134; ROOT::RWebWindow::AssignThreadIdvoid AssignThreadId()Assign thread id which has to be used f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:28175,access,access,28175,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['access'],['access']
Security,"func)Set call-back function for new connection.Definition RWebWindow.cxx:1785; ROOT::RWebWindow::IsShownbool IsShown() constReturns true when window was shown at least once.Definition RWebWindow.hxx:372; ROOT::RWebWindow::Syncvoid Sync()Special method to process all internal activity when window runs in separate thread.Definition RWebWindow.cxx:1269; ROOT::RWebWindow::UseServerThreadsvoid UseServerThreads()Let use THttpServer threads to process requests WARNING!!! only for expert use Should be only used wh...Definition RWebWindow.cxx:1709; ROOT::RWebWindow::SetGeometryvoid SetGeometry(unsigned width, unsigned height)Set window geometry. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:265; ROOT::RWebWindow::TerminateROOTvoid TerminateROOT()Terminate ROOT session Tries to correctly close THttpServer, associated with RWebWindowsManager After...Definition RWebWindow.cxx:1935; ROOT::RWebWindow::fUseCurrentDirbool fUseCurrentDir! if window can access local files via currentdir/ path of http serverDefinition RWebWindow.hxx:158; ROOT::RWebWindow::Sendvoid Send(unsigned connid, const std::string &data)Sends data to specified connection.Definition RWebWindow.cxx:1651; ROOT::RWebWindow::Showunsigned Show(const RWebDisplayArgs &args="""")Show window in specified location.Definition RWebWindow.cxx:191; ROOT::RWebWindow::GetServerTHttpServer * GetServer()Return THttpServer instance serving requests to the window.Definition RWebWindow.cxx:181; ROOT::RWebWindow::AddDisplayHandleunsigned AddDisplayHandle(bool headless_mode, const std::string &key, std::unique_ptr< RWebDisplayHandle > &handle)Add display handle and associated key Key is large random string generated when starting new window W...Definition RWebWindow.cxx:483; ROOT::RWebWindow::ConnectionsList_tstd::vector< std::shared_ptr< WebConn > > ConnectionsList_tDefinition RWebWindow.hxx:137; ROOT::RWebWindow::AssignThreadIdvoid AssignThreadId()Assign thread id which has to be used f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:28564,access,access,28564,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['access'],['access']
Security,"function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. TMySQLServer(const TMySQLServer&); TMySQLServer(const char* db, const char* uid, const char* pw); virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMySQLServer.html:1171,password,password,1171,root/html528/TMySQLServer.html,https://root.cern,https://root.cern/root/html528/TMySQLServer.html,4,['password'],['password']
Security,"function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMySQLServer.html:1171,password,password,1171,root/html602/TMySQLServer.html,https://root.cern,https://root.cern/root/html602/TMySQLServer.html,2,['password'],['password']
Security,"function.; Attention, bizarre convention of return value!!. int Unlink(const char* path); Unlink 'path' on the remote server system.; Returns 0 on success, -1 otherwise. Bool_t IsOnline(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Prepare(const char* path, UChar_t opt = 8, UChar_t prio = 0); Issue a prepare request for file defined by 'path'. Int_t Prepare(TCollection* paths, UChar_t opt = 8, UChar_t prio = 0, TString* buf = 0); Issue a prepare request for a list of files defined by 'paths', which must; be of one of the following types: TFileInfo, TUrl, TObjString.; On output, bufout, if defined, points to a buffer form that can be used; with GetPathsInfo.; Return the number of paths found or -1 if any error occured. Bool_t GetPathsInfo(const char* paths, UChar_t* info); Retrieve status of a '\n'-separated list of files in 'paths'.; The information is returned as one UChar_t per file in 'info';; 'info' must be allocated by the caller. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. Int_t Locate(const char* path, TString& endurl); Get end-point url of a file. Info is returned in eurl.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. XrdClientAdmin * GetClientAdmin(const char* url); Checks if an admin for 'url' exists already.; Avoid duplications. TString GetKey(const char* url); Build from uu a unique ID key used in hash tables. void * GetDirPtr() const; { return fDirp; }. virtual ~TXNetSystem(); { }. » Author: Frank Winklmeier, Fabrizio Furano » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id: TXNetSystem.h 30170 2009-09-15 13:35:35Z rdm $ » Last generated: 2010-10-08 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetSystem.html:23350,hash,hash,23350,root/html528/TXNetSystem.html,https://root.cern,https://root.cern/root/html528/TXNetSystem.html,1,['hash'],['hash']
Security,"function.; Attention, bizarre convention of return value!!. int Unlink(const char* path); Unlink 'path' on the remote server system.; Returns 0 on success, -1 otherwise. Bool_t IsOnline(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Prepare(const char* path, UChar_t opt = 8, UChar_t prio = 0); Issue a prepare request for file defined by 'path'. Int_t Prepare(TCollection* paths, UChar_t opt = 8, UChar_t prio = 0, TString* buf = 0); Issue a prepare request for a list of files defined by 'paths', which must; be of one of the following types: TFileInfo, TUrl, TObjString.; On output, bufout, if defined, points to a buffer form that can be used; with GetPathsInfo.; Return the number of paths found or -1 if any error occured. Bool_t GetPathsInfo(const char* paths, UChar_t* info); Retrieve status of a '\n'-separated list of files in 'paths'.; The information is returned as one UChar_t per file in 'info';; 'info' must be allocated by the caller. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. Int_t Locate(const char* path, TString& endurl); Get end-point url of a file. Info is returned in eurl.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. XrdClientAdmin * GetClientAdmin(const char* url); Checks if an admin for 'url' exists already.; Avoid duplications. TString GetKey(const char* url); Build from uu a unique ID key used in hash tables. void * GetDirPtr() const; { return fDirp; }. virtual ~TXNetSystem(); { }. » Author: Frank Winklmeier, Fabrizio Furano » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id: TXNetSystem.h 30170 2009-09-15 13:35:35Z rdm $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXNetSystem.html:23478,hash,hash,23478,root/html530/TXNetSystem.html,https://root.cern,https://root.cern/root/html530/TXNetSystem.html,1,['hash'],['hash']
Security,"functional-chain like approach ;  df001_introduction.py This tutorial illustrates the basic features of the RDataFrame class, a utility which allows to interact with data stored in TTrees following a functional-chain like approach ;  df002_dataModel.C This tutorial shows the possibility to use data models which are more complex than flat ntuples with RDataFrame ;  df002_dataModel.py This tutorial shows the possibility to use data models which are more complex than flat ntuples with RDataFrame ;  df003_profiles.C This tutorial illustrates how to use TProfiles in combination with the RDataFrame ;  df003_profiles.py This tutorial illustrates how to use TProfiles in combination with the RDataFrame ;  df004_cutFlowReport.CThis tutorial shows how to get information about the efficiency of the filters applied ;  df004_cutFlowReport.pyThis tutorial shows how to get information about the efficiency of the filters applied ;  df005_fillAnyObject.C This tutorial shows how to fill any object the class of which exposes a Fill method ;  df006_ranges.C This tutorial shows how to express the concept of ranges when working with the RDataFrame ;  df006_ranges.py This tutorial shows how to express the concept of ranges when working with the RDataFrame ;  df007_snapshot.C This tutorial shows how to write out datasets in ROOT formatusing the RDataFrame ;  df007_snapshot.py This tutorial shows how to write out datasets in ROOT formatusing the RDataFrame ;  df008_createDataSetFromScratch.C This tutorial shows how to create a dataset from scratch with RDataFrame ;  df008_createDataSetFromScratch.py This tutorial shows how to create a dataset from scratch with RDataFrame ;  df009_FromScratchVSTTree.C This tutorial illustrates how simpler it can be to use a RDataFrame to create a dataset with respect to the usage of the TTree interfaces ;  df010_trivialDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df010_trivialDataSource.py This tutorial il",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:98309,expose,exposes,98309,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['expose'],['exposes']
Security,"g &methodTag, Double_t aux=0)evaluates MVA for given set of input variablesDefinition Reader.cxx:630; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(). tutorialstmvaTMVAMulticlassApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlassApplication_8C_source.html:11291,access,access,11291,doc/master/TMVAMulticlassApplication_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlassApplication_8C_source.html,2,['access'],['access']
Security,"g &pat, ECaseCompare cmp=kExact) const;  ; Bool_t Contains (TPRegexp &pat) const;  ; TString Copy () const;  Copy a string. ;  ; Int_t CountChar (Int_t c) const;  Return number of times character c occurs in the string. ;  ; const char * Data () const;  ; Bool_t EndsWith (const char *pat, ECaseCompare cmp=kExact) const;  Return true if string ends with the specified string. ;  ; Bool_t EqualTo (const char *cs, ECaseCompare cmp=kExact) const;  ; Bool_t EqualTo (const TString &st, ECaseCompare cmp=kExact) const;  ; virtual void FillBuffer (char *&buffer) const;  Copy string into I/O buffer. ;  ; Ssiz_t First (char c) const;  Find first occurrence of a character c. ;  ; Ssiz_t First (const char *cs) const;  Find first occurrence of a character in cs. ;  ; void Form (const char *fmt,...);  Formats a string using a printf style format descriptor. ;  ; Bool_t Gets (FILE *fp, Bool_t chop=kTRUE);  Read one line from the stream, including the \n, or until EOF. ;  ; UInt_t Hash (ECaseCompare cmp=kExact) const;  Return hash value. ;  ; Ssiz_t Index (const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) const;  ; Ssiz_t Index (const char *pat, Ssiz_t patlen, Ssiz_t i, ECaseCompare cmp) const;  Search for a string in the TString. ;  ; Ssiz_t Index (const TRegexp &pat, Ssiz_t *ext, Ssiz_t i=0) const;  Find the first occurrence of the regexp in string and return the position, or -1 if there is no match. ;  ; Ssiz_t Index (const TRegexp &pat, Ssiz_t i=0) const;  Find the first occurrence of the regexp in string and return the position, or -1 if there is no match. ;  ; Ssiz_t Index (const TString &s, Ssiz_t i=0, ECaseCompare cmp=kExact) const;  ; Ssiz_t Index (const TString &s, Ssiz_t patlen, Ssiz_t i, ECaseCompare cmp) const;  ; Ssiz_t Index (TPRegexp &pat, Ssiz_t *ext, Ssiz_t i=0) const;  Find the first occurrence of the regexp in string and return the position. ;  ; Ssiz_t Index (TPRegexp &pat, Ssiz_t i=0) const;  Find the first occurrence of the regexp in string and return the p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTString.html:4836,hash,hash,4836,doc/v632/classTString.html,https://root.cern,https://root.cern/doc/v632/classTString.html,2,['hash'],['hash']
Security,"g for the OK to start processing. ; Definition at line 6836 of file TProofServ.cxx. ◆ LogToMaster(). void TProofServ::LogToMaster ; (; Bool_t ; on = kTRUE). inline . Definition at line 322 of file TProofServ.h. ◆ MakePlayer(). void TProofServ::MakePlayer ; (; ). protectedvirtual . Make player instance. ; Definition at line 5883 of file TProofServ.cxx. ◆ MakeQueryResult(). TProofQueryResult * TProofServ::MakeQueryResult ; (; Long64_t ; nentries, . const char * ; opt, . TList * ; inl, . Long64_t ; first, . TDSet * ; dset, . const char * ; selec, . TObject * ; elist . ). private . Create a TProofQueryResult instance for this query. ; Definition at line 3530 of file TProofServ.cxx. ◆ NextQuery(). TProofQueryResult * TProofServ::NextQuery ; (; ). private . Get the next query from the waiting list. ; The query is removed from the list. ; Definition at line 6867 of file TProofServ.cxx. ◆ OldAuthSetup(). Int_t TProofServ::OldAuthSetup ; (; TString & ; conf). private . Setup authentication related stuff for old versions. ; Provided for backward compatibility. ; Definition at line 3492 of file TProofServ.cxx. ◆ Print(). void TProofServ::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print status of slave server. ; Reimplemented from TObject.; Definition at line 2506 of file TProofServ.cxx. ◆ ProcessNext(). void TProofServ::ProcessNext ; (; TString * ; slb = 0). protectedvirtual . process the next query from the queue of submitted jobs. ; to be called on the top master only. ; Definition at line 4416 of file TProofServ.cxx. ◆ QueueQuery(). Int_t TProofServ::QueueQuery ; (; TProofQueryResult * ; pq). private . Add a query to the waiting list Returns the number of queries in the list. ; Definition at line 6856 of file TProofServ.cxx. ◆ ReceiveFile(). Int_t TProofServ::ReceiveFile ; (; const char * ; file, . Bool_t ; bin, . Long64_t ; size . ). Receive a file, either sent by a client or a master server. ; If bin is true it is a binary file, other wise it is an ASCI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:49899,authenticat,authentication,49899,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['authenticat'],['authentication']
Security,"g length.; 636 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 637 const UInt_t *p = (const UInt_t*)Data();; 638 {; 639 while (i--) {; 640#ifndef R__BYTESWAP; 641 UInt_t h = *p++;; 642 Mash(hv, SwapInt(h)); // XOR in the characters.; 643#else; 644 Mash(hv, *p++); // XOR in the characters.; 645#endif; 646 }; 647 }; 648 // XOR in any remaining characters:; 649 if ((i = Length()*sizeof(char)%sizeof(UInt_t)) != 0) {; 650 UInt_t h = 0;; 651 const char* c = (const char*)p;; 652 while (i--); 653 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 654 Mash(hv, h);; 655 }; 656 return hv;; 657}; 658 ; 659////////////////////////////////////////////////////////////////////////////////; 660/// Return a case-insensitive hash value (endian independent).; 661 ; 662UInt_t TString::HashFoldCase() const; 663{; 664 UInt_t hv = (UInt_t)Length(); // Mix in the string length.; 665 UInt_t i = hv;; 666 const unsigned char *p = (const unsigned char*)Data();; 667 while (i--) {; 668 Mash(hv, toupper(*p));; 669 ++p;; 670 }; 671 return hv;; 672}; 673 ; 674////////////////////////////////////////////////////////////////////////////////; 675/// Return hash value.; 676 ; 677UInt_t TString::Hash(ECaseCompare cmp) const; 678{; 679 return (cmp == kExact) ? HashCase() : HashFoldCase();; 680}; 681 ; 682 // MurmurHash3 - a blazingly fast public domain hash!; 683 // See http://code.google.com/p/smhasher/; 684 // There are two versions, one optimized for 32 bit and one for 64 bit.; 685 // They give different hash results!; 686 // We use only the 64 bit version which also works on 32 bit.; 687 ; 688 //-----------------------------------------------------------------------------; 689 // MurmurHash3 was written by Austin Appleby, and is placed in the public; 690 // domain. The author hereby disclaims copyright to this source code.; 691 ; 692 // Note - The x86 and x64 versions do _not_ produce the same results, as the; 693 // algorithms are optimized for their respective platforms. You can still; 694 // compile and r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:19805,hash,hash,19805,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['hash'],['hash']
Security,"g these least significant vectors in the subsequent analysis. On the other hand, in the analysis of real data, these least; significant variables(?) can be used for the pattern; recognition problem of extracting the valid combinations of; coordinates describing a true trajectory from the set of all possible; wrong combinations. The program described here performs this principal components analysis; on a sample of data provided by the user. It computes the covariance; matrix, its eigenvalues ands corresponding eigenvectors and exhibits; the behavior of the principal components (), thus providing; to the user all the means of understanding his data. Principal Components Method. Let's consider a sample of prototypes each being characterized by; variables. . Each prototype is a point, or a; column vector, in a -dimensional pattern space. (1). where each represents the particular value associated with the; -dimension. Those variables are the quantities accessible to the; experimentalist, but are not necessarily the most significant for the; classification purpose. The Principal Components Method consists of applying a; linear transformation to the original variables. This; transformation is described by an orthogonal matrix and is equivalent; to a rotation of the original pattern space into a new set of; coordinate vectors, which hopefully provide easier feature; identification and dimensionality reduction. Let's define the covariance matrix:. (2). and the brackets indicate mean value over the sample of ; prototypes. This matrix is real, positive definite, symmetric, and will; have all its eigenvalues greater then zero. It will now be show that; among the family of all the complete orthonormal bases of the pattern; space, the base formed by the eigenvectors of the covariance matrix; and belonging to the largest eigenvalues, corresponds to the most; significant features of the description of the original prototypes. let the prototypes be expanded on into a set of basis vec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPrincipal.html:3244,access,accessible,3244,root/html528/TPrincipal.html,https://root.cern,https://root.cern/root/html528/TPrincipal.html,4,['access'],['accessible']
Security,"g(""std::string"");; 2059 if (clRefString == this) {; 2060 return;; 2061 }; 2062 ; 2063 // Complain about stl classes ending up here (unique_ptr etc) - except for; 2064 // pair where we will build .first, .second just fine; 2065 // and those for which the user explicitly requested a dictionary.; 2066 if (!isTransient && GetState() != kHasTClassInit; 2067 && TClassEdit::IsStdClass(GetName()); 2068 && !TClassEdit::IsStdPair(GetName())) {; 2069 Error(""BuildRealData"", ""Inspection for %s not supported!"", GetName());; 2070 }; 2071 ; 2072 // The following statement will recursively call; 2073 // all the subclasses of this class.; 2074 fRealData = new TList;; 2075 TBuildRealData brd(pointer, this);; 2076 ; 2077 // CallShowMember will force a call to InheritsFrom, which indirectly; 2078 // calls TClass::GetClass. It forces the loading of new typedefs in; 2079 // case some of them were not yet loaded.; 2080 if ( ! CallShowMembers(pointer, brd, isTransient) ) {; 2081 if ( isTransient ) {; 2082 // This is a transient data member, so it is probably fine to not have; 2083 // access to its content. However let's no mark it as definitively setup,; 2084 // since another class might use this class for a persistent data member and; 2085 // in this case we really want the error message.; 2086 delete fRealData;; 2087 fRealData = nullptr;; 2088 } else {; 2089 Error(""BuildRealData"", ""Cannot find any ShowMembers function for %s!"", GetName());; 2090 }; 2091 }; 2092 ; 2093 // Take this opportunity to build the real data for base classes.; 2094 // In case one base class is abstract, it would not be possible later; 2095 // to create the list of real data for this abstract class.; 2096 TBaseClass* base = nullptr;; 2097 TIter next(GetListOfBases());; 2098 while ((base = (TBaseClass*) next())) {; 2099 if (base->IsSTLContainer()) {; 2100 continue;; 2101 }; 2102 TClass* c = base->GetClassPointer();; 2103 if (c) {; 2104 c->BuildRealData(nullptr, isTransient);; 2105 }; 2106 }; 2107}; 2108 ; 2109///////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:78199,access,access,78199,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['access']
Security,"g(""std::string"");; 2126 if (clRefString == this) {; 2127 return;; 2128 }; 2129 ; 2130 // Complain about stl classes ending up here (unique_ptr etc) - except for; 2131 // pair where we will build .first, .second just fine; 2132 // and those for which the user explicitly requested a dictionary.; 2133 if (!isTransient && GetState() != kHasTClassInit; 2134 && TClassEdit::IsStdClass(GetName()); 2135 && !TClassEdit::IsStdPair(GetName())) {; 2136 Error(""BuildRealData"", ""Inspection for %s not supported!"", GetName());; 2137 }; 2138 ; 2139 // The following statement will recursively call; 2140 // all the subclasses of this class.; 2141 fRealData = new TList;; 2142 TBuildRealData brd(pointer, this);; 2143 ; 2144 // CallShowMember will force a call to InheritsFrom, which indirectly; 2145 // calls TClass::GetClass. It forces the loading of new typedefs in; 2146 // case some of them were not yet loaded.; 2147 if ( ! CallShowMembers(pointer, brd, isTransient) ) {; 2148 if ( isTransient ) {; 2149 // This is a transient data member, so it is probably fine to not have; 2150 // access to its content. However let's no mark it as definitively setup,; 2151 // since another class might use this class for a persistent data member and; 2152 // in this case we really want the error message.; 2153 delete fRealData;; 2154 fRealData = nullptr;; 2155 } else {; 2156 Error(""BuildRealData"", ""Cannot find any ShowMembers function for %s!"", GetName());; 2157 }; 2158 }; 2159 ; 2160 // Take this opportunity to build the real data for base classes.; 2161 // In case one base class is abstract, it would not be possible later; 2162 // to create the list of real data for this abstract class.; 2163 TBaseClass* base = nullptr;; 2164 TIter next(GetListOfBases());; 2165 while ((base = (TBaseClass*) next())) {; 2166 if (base->IsSTLContainer()) {; 2167 continue;; 2168 }; 2169 TClass* c = base->GetClassPointer();; 2170 if (c) {; 2171 c->BuildRealData(nullptr, isTransient);; 2172 }; 2173 }; 2174}; 2175 ; 2176///////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:80950,access,access,80950,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['access']
Security,"g.; 392 ; 393const char *TSchemaRule::GetVersion() const; 394{; 395 return fVersion;; 396}; 397 ; 398 ; 399////////////////////////////////////////////////////////////////////////////////; 400/// Check if given version number is defined in this rule; 401 ; 402Bool_t TSchemaRule::TestVersion( Int_t version ) const; 403{; 404 if( fVersion.IsNull() ); 405 return kFALSE;; 406 ; 407 if( !fVersionVect ); 408 ProcessVersion( fVersion ); // At this point the version string should always be correct; 409 ; 410 if (version == -1) {; 411 version = 1;; 412 }; 413 ; 414 if (fVersionVect); 415 for (auto &it : *fVersionVect); 416 if( version >= it.first && version <= it.second ); 417 return kTRUE;; 418 ; 419 return kFALSE;; 420}; 421 ; 422////////////////////////////////////////////////////////////////////////////////; 423/// Set the checksum string - returns kFALSE if the format is incorrect; 424 ; 425Bool_t TSchemaRule::SetChecksum( const TString& checksum ); 426{; 427 fChecksum = """";; 428 Bool_t ret = ProcessChecksum( checksum );; 429 if( ret ); 430 fChecksum = checksum;; 431 return ret;; 432}; 433 ; 434////////////////////////////////////////////////////////////////////////////////; 435/// Check if given checksum is defined in this rule; 436 ; 437Bool_t TSchemaRule::TestChecksum( UInt_t checksum ) const; 438{; 439 if( fChecksum.IsNull() ); 440 return kFALSE;; 441 ; 442 if( !fChecksumVect ); 443 ProcessChecksum( fChecksum ); // At this point the checksum string should always be correct; 444 ; 445 if (fChecksumVect); 446 for (auto &it : *fChecksumVect); 447 if( checksum == it ); 448 return kTRUE;; 449 ; 450 return kFALSE;; 451}; 452 ; 453////////////////////////////////////////////////////////////////////////////////; 454/// Set the source class of this rule (i.e. the onfile class).; 455 ; 456void TSchemaRule::SetSourceClass( const TString& classname ); 457{; 458 std::string normalizedName;; 459 TClassEdit::GetNormalizedName(normalizedName, classname);; 460 fSourceClass = normaliz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:13826,checksum,checksum,13826,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,6,['checksum'],['checksum']
Security,"g64_tfNPNumber of entries.; auto_ptr<TGLHistPainter>fPainter; const Double_t*fV1V1.; pair<double,double>fV1MinMaxV1 range.; Double_tfV1Rangemax - min.; const Double_t*fV2V2.; pair<double,double>fV2MinMaxV2 range.; Double_tfV2Rangemax - min.; const Double_t*fV3V3.; pair<double,double>fV3MinMaxV3 range.; Double_tfV3Rangemax - min.; const Double_t*fV4V4.; Bool_tfV4IsString; pair<double,double>fV4MinMaxV4 range.; const Double_t*fV5V5.; pair<double,double>fV5MinMaxV5 range.; TAxisfXAxis; TAxisfYAxis; TAxisfZAxis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGL5DDataSet(TTree* inputData); Constructor. Reads data from TTree,; estimates ranges, creates a painter. Int_t DistancetoPrimitive(Int_t px, Int_t py); Check, if the object is under cursor. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Action. char * GetObjectInfo(Int_t px, Int_t py) const; Info for status bar. void Paint(Option_t* option); Paint. TGL5DPainter * GetRealPainter() const; Get access to painter (for GUI-editor). void SelectPoints(Double_t v4Level, Double_t range); ""Select"" sub-range from source data; - remember indices of ""good"" points. UInt_t SelectedSize() const; Size of selected sub-range. Double_t V1(UInt_t ind) const; V1 from sub-range, converted to unit cube. Double_t V2(UInt_t ind) const; V2 from sub-range, converted to unit cube. Double_t V3(UInt_t ind) const; V3 from sub-range, converted to unit cube. TAxis * GetXAxis() const; X axis for plot. TAxis * GetYAxis() const; Y axis for plot. TAxis * GetZAxis() const; Z axis for plot. const Rgl::Range_t & GetXRange() const; V1 range (X). const Rgl::Range_t & GetYRange() const; V2 range (Y). const Rgl::Range_t & GetZRange() const; V3 range (Z). const Rgl::Range_t & GetV4Range() const; V4 range. Double_t V1ToUnitCube(Double_t v1) const; V1 to unit cube. Double_t V2ToUnitCube(Double_t v2) const; V2 to unit cube. Double_t V3ToUnitCube(Double_t v3) const; V3 to unit cube. TGL5DDataSet(TTree* inputData). » A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGL5DDataSet.html:6965,access,access,6965,root/html528/TGL5DDataSet.html,https://root.cern,https://root.cern/root/html528/TGL5DDataSet.html,4,['access'],['access']
Security,"g64_tfSizefile size; TSocket*fSocketsocket for HTTP/1.1 (stays alive between calls); TUrlfUrlOrgsave original url in case of temp redirection; static TUrlfgProxyglobally set proxy URL. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TWebFile(const char* url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. The url; argument must be of the form: http://host.dom.ain/file.root.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. The preferred interface to this; constructor is via TFile::Open(). TWebFile(TUrl url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. Make sure url; is a valid TUrl object.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. ~TWebFile(); Clean",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:23559,access,accessible,23559,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,2,['access'],['accessible']
Security,"g::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealVar.html:39288,access,access,39288,root/html534/RooRealVar.html,https://root.cern,https://root.cern/root/html534/RooRealVar.html,1,['access'],['access']
Security,g::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooObjCacheManager_intCacheMgrManager of cache with integrals; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddModel.html:44190,access,access,44190,root/html602/RooAddModel.html,https://root.cern,https://root.cern/root/html602/RooAddModel.html,2,['access'],['access']
Security,"g>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:19018,access,access,19018,root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"g>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:13167,access,access,13167,root/html526/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"g>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:8338,access,access,8338,root/html526/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"g>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:8211,access,access,8211,root/html526/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"gApplication->Run() will be called If application runs in separate thread, one have to use AssignMainThrd() method to let RWebWindowsManager correctly recognize such situation. ; Definition at line 104 of file RWebWindowsManager.cxx. ◆ IsUseHttpThread(). bool ROOT::RWebWindowsManager::IsUseHttpThread ; (; ); const. inlineprivate . Returns true if http server use special thread for requests processing (default off) ; Definition at line 55 of file RWebWindowsManager.hxx. ◆ IsUseSenderThreads(). bool ROOT::RWebWindowsManager::IsUseSenderThreads ; (; ); const. inlineprivate . Returns true if extra threads to send data via websockets will be used (default off) ; Definition at line 58 of file RWebWindowsManager.hxx. ◆ SetLoopbackMode(). void RWebWindowsManager::SetLoopbackMode ; (; bool ; on = true). static . Set loopback mode for THttpServer used for web widgets By default is on. ; Only local communication via localhost address is possible Disable it only if really necessary - it may open unauthorized access to your application from external nodes!! ; Definition at line 128 of file RWebWindowsManager.cxx. ◆ SetShowCallback(). void ROOT::RWebWindowsManager::SetShowCallback ; (; WebWindowShowCallback_t ; func). inline . Assign show callback which can catch window showing, used by RBrowser. ; Definition at line 90 of file RWebWindowsManager.hxx. ◆ SetUseConnectionKey(). void RWebWindowsManager::SetUseConnectionKey ; (; bool ; on = true). static . Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection) to widget requires unique key Connection key used together with session key to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ; Definition at line 167 of file RWebWindowsManager.cxx. ◆ SetUseSessionKey(). void RWebWindowsManager::SetUseSessionKey ; (; bool ; on = true). static . Enable or disable usage of session key (default on) If enabled, secrete session key used ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:13797,access,access,13797,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['access'],['access']
Security,"gPoor; kImgFast; kImgGood; kImgBest; };. protected:. Bool_tTAttImage::fConstRatiokeep aspect ratio of image on the screen; Bool_tfEditable! kTRUE image can be resized, moved by resizing/moving gPad; ASImage*fGrayImage! gray image; ASImage*fImage! pointer to image structure of original image; UInt_tTAttImage::fImageCompressioncompression [0 .. 100] 0: no compression; TAttImage::EImageQualityTAttImage::fImageQuality*OPTION={GetMethod=""GetImageQuality"";SetMethod=""SetImageQuality"";Items=(kImgDefault=""Default"",kImgPoor=""Poor"",kImgFast=""Fast"",kImgGood=""Good"",kImgBest=""Best"")}*; Bool_tfIsGray! kTRUE if image is gray; Double_tfMaxValue! max value in image; Double_tfMinValue! min value in image; TStringTNamed::fNameobject identifier; Int_tfPaintMode! 1 - fast mode, 0 - low memory slow mode; TImagePaletteTAttImage::fPalettecolor palette for value -> color conversion; TPaletteEditor*TAttImage::fPaletteEditor! GUI to edit the color palette; Bool_tTAttImage::fPaletteEnabled! kTRUE - palette is drawn on the image; TASImage*fScaledImage! temporary scaled and zoomed image produced from original image; TStringTNamed::fTitleobject title; UInt_tfZoomHeight! hight of zoomed image in image pixels; UInt_tfZoomOffX! X - offset for zooming in image pixels; UInt_tfZoomOffY! Y - offset for zooming im image pixels; Int_tfZoomUpdate! kZoom - new zooming required, kZoomOps - other ops in action, kNoZoom - no zooming or ops; UInt_tfZoomWidth! width of zoomed image in image pixels; static Bool_tfgInitglobal flag to init afterimage only once; static THashTable*fgPlugList! hash table containing loaded plugins; static ASVisual*fgVisualpointer to visual structure. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DestroyImage(); Destroy image. void SetDefaults(); Set default parameters. TASImage(); Default image constructor. TASImage(UInt_t w, UInt_t h); Create an empty image. TASImage(const char *file, EImageFileTypes); Create an image object and read fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASImage.html:18634,hash,hash,18634,root/html526/TASImage.html,https://root.cern,https://root.cern/root/html526/TASImage.html,1,['hash'],['hash']
Security,"gPoor; kImgFast; kImgGood; kImgBest; };. protected:. Bool_tTAttImage::fConstRatiokeep aspect ratio of image on the screen; Bool_tfEditable! kTRUE image can be resized, moved by resizing/moving gPad; ASImage*fGrayImage! gray image; ASImage*fImage! pointer to image structure of original image; UInt_tTAttImage::fImageCompressioncompression [0 .. 100] 0: no compression; TAttImage::EImageQualityTAttImage::fImageQuality*OPTION={GetMethod=""GetImageQuality"";SetMethod=""SetImageQuality"";Items=(kImgDefault=""Default"",kImgPoor=""Poor"",kImgFast=""Fast"",kImgGood=""Good"",kImgBest=""Best"")}*; Bool_tfIsGray! kTRUE if image is gray; Double_tfMaxValue! max value in image; Double_tfMinValue! min value in image; TStringTNamed::fNameobject identifier; Int_tfPaintMode! 1 - fast mode, 0 - low memory slow mode; TImagePaletteTAttImage::fPalettecolor palette for value -> color conversion; TPaletteEditor*TAttImage::fPaletteEditor! GUI to edit the color palette; Bool_tTAttImage::fPaletteEnabled! kTRUE - palette is drawn on the image; TASImage*fScaledImage! temporary scaled and zoomed image produced from original image; TStringTNamed::fTitleobject title; UInt_tfZoomHeight! hight of zoomed image in image pixels; UInt_tfZoomOffX! X - offset for zooming in image pixels; UInt_tfZoomOffY! Y - offset for zooming im image pixels; Int_tfZoomUpdate! kZoom - new zooming required, kZoomOps - other ops in action, kNoZoom - no zooming or ops; UInt_tfZoomWidth! width of zoomed image in image pixels; static Bool_tfgInitglobal flag to init afterimage only once; static THashTable*fgPlugList! hash table containing loaded plugins; static ASVisual*fgVisualpointer to visual structure. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DestroyImage(); Destroy image. void SetDefaults(); Set default parameters. TASImage(); Default image constructor. TASImage(UInt_t w, UInt_t h); Create an empty image. TASImage(const char* file, TImage::EImageFileTypes type = kUnknown); Create an i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TASImage.html:18620,hash,hash,18620,root/html528/TASImage.html,https://root.cern,https://root.cern/root/html528/TASImage.html,4,['hash'],['hash']
Security,"gReadaheadSizeReadahead buffer size. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←; TDirectoryFile. ←; TFile. ←; TWebFile. ←. TS3WebFile. Function documentation; TWebFile(const char* url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. The url; argument must be of the form: http://host.dom.ain/file.root.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. The preferred interface to this; constructor is via TFile::Open(). TWebFile(TUrl url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. Make sure url; is a valid TUrl object.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. ~TWebFile(); Cleanup. void Init(Bool_t readHeadOnly); Initialize a TWebFile object. void SetMsgReadBuffer1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebFile.html:25826,access,accessible,25826,root/html602/TWebFile.html,https://root.cern,https://root.cern/root/html602/TWebFile.html,2,['access'],['accessible']
Security,"gService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")); to see these message on stdout. Multi-dimensional convolutions are not supported yet, but will be in the future; as FFTW can calculate them. Installing a copy of FFTW on Linux and compiling ROOT to use it. 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file). If you have root access to your machine and want to make a system installation of FFTW. 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure' followed by 'make install'.; This will install fftw in /usr/local/bin,lib etc... 3) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags '--enable-fftw3' and '--enable-roofit', then run 'make'. If you do not have root access and want to make a private installation of FFTW. 2) Make a private install area for FFTW, e.g. /home/myself/fftw. 3) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure --prefix=/home/myself/fftw' followed by 'make install'.; Substitute /home/myself/fftw with a directory of your choice. This; procedure will install FFTW in the location designated by you. 4) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags; '--enable-fftw3',; '--with-fftw3-incdir=/home/myself/fftw/include',; '--width-fftw3-libdir=/home/myself/fftw/lib' and; '--enable-roofit'; Then run 'make'. Function Members (Methods); public:. RooFFTConvPdf(); RooFFTConvPdf(const RooFFTConvPdf& other, const char* name = 0); RooFFTConvPdf(const char* name, const char* title, R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:3955,access,access,3955,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,5,['access'],['access']
Security,"gService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")); to see these message on stdout. Multi-dimensional convolutions are not supported yet, but will be in the future; as FFTW can calculate them. Installing a copy of FFTW on Linux and compiling ROOT to use it. 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file). If you have root access to your machine and want to make a system installation of FFTW. 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure' followed by 'make install'.; This will install fftw in /usr/local/bin,lib etc... 3) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags '--enable-fftw3' and '--enable-roofit', then run 'make'. If you do not have root access and want to make a private installation of FFTW. 2) Make a private install area for FFTW, e.g. /home/myself/fftw. 3) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure --prefix=/home/myself/fftw' followed by 'make install'.; Substitute /home/myself/fftw with a directory of your choice. This; procedure will install FFTW in the location designated by you. 4) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags; '--enable-fftw3',; '--with-fftw3-incdir=/home/myself/fftw/include',; '--width-fftw3-libdir=/home/myself/fftw/lib' and; '--enable-roofit'; Then run 'make'. Function Members (Methods); public:. virtual~RooFFTConvPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:3955,access,access,3955,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,2,['access'],['access']
Security,"gTCling.h""; 20 ; 21#undef R__DLLEXPORT; 22 ; 23#ifdef __FreeBSD__; 24char* __progname;; 25char** environ;; 26#endif; 27 ; 28#include ""TROOT.h""; 29#include ""TCling.h""; 30 ; 31extern ""C""; 32const char ** *TROOT__GetExtraInterpreterArgs(); 33{; 34 return &TROOT::GetExtraInterpreterArgs();; 35}; 36 ; 37extern ""C""; 38const char *TROOT__GetIncludeDir(); 39{; 40 return TROOT::GetIncludeDir();; 41}; 42 ; 43extern ""C""; 44const char *TROOT__GetEtcDir(); 45{; 46 return TROOT::GetEtcDir();; 47}; 48 ; 49extern ""C""; 50cling::Interpreter *TCling__GetInterpreter(); 51{; 52 static auto triggerInitialization = gROOT;; 53 (void)triggerInitialization;; 54 return (cling::Interpreter *)((TCling *)gCling)->GetInterpreterImpl();; 55}; 56 ; TCling.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT__GetExtraInterpreterArgsconst char *** TROOT__GetExtraInterpreterArgs()Definition rootclingTCling.cxx:32; TROOT__GetEtcDirconst char * TROOT__GetEtcDir()Definition rootclingTCling.cxx:44; TROOT__GetIncludeDirconst char * TROOT__GetIncludeDir()Definition rootclingTCling.cxx:38; TCling__GetInterpretercling::Interpreter * TCling__GetInterpreter()Definition rootclingTCling.cxx:50; rootclingTCling.h. coremetaclingsrcrootclingTCling.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootclingTCling_8cxx_source.html:2182,inject,inject,2182,doc/master/rootclingTCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootclingTCling_8cxx_source.html,1,['inject'],['inject']
Security,"gTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. void*fDirpdirectory handler. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSystem. ←; TWebSystem. Function documentation; TWebSystem(); Create helper class that allows directory access via httpd.; The name must start with '-' to bypass the TSystem singleton check. Int_t MakeDirectory(const char* name); Make a directory via httpd. Not supported. void * OpenDirectory(const char* name); Open a directory via httpd. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp); Free directory via httpd. const char * GetDirEntry(void* dirp); Get directory entry via httpd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Int_t Unlink(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebSystem.html:19799,access,access,19799,root/html602/TWebSystem.html,https://root.cern,https://root.cern/root/html602/TWebSystem.html,1,['access'],['access']
Security,"gWriterDefinition TVirtualMonitoring.h:116; TVirtualMutex.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TVirtualPerfStats.h; gPerfStats#define gPerfStatsDefinition TVirtualPerfStats.h:96; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; R__READ_LOCKGUARD#define R__READ_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:154; O_BINARY#define O_BINARYDefinition civetweb.c:912; snprintf#define snprintfDefinition civetweb.c:1540; ROOT::Detail::TSchemaRuleSet::TMatchesDefinition TSchemaRuleSet.h:29; ROOT::Detail::TSchemaRuleSet::FindRulesconst TMatches FindRules(const TString &source) constReturn all the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::GetRulesconst TObjArray * GetRules() constDefinition TSchemaRuleSet.cxx:417; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; ROOT::Internal::RConcurrentHashColl::Insertbool Insert(const HashValue &hash, RUidColl &&coll) constIf the hash is there, return false.Definition RConcurrentHashColl.cxx:61; ROOT::Internal::RConcurrentHashColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:199296,hash,hash,199296,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['hash'],['hash']
Security,"g_t ms = fNormalTmout;; 58 if (fSlow) {; 59 if (ms < 100); 60 ms = 500;; 61 else if (ms < 500); 62 ms = 3000;; 63 else; 64 ms = 10000;; 65 }; 66 ; 67 SetTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:2716,access,access,2716,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['access'],['access']
Security,"g_view treename, std::string_view filename,; 1416 std::initializer_list<std::string> columnList,; 1417 const RSnapshotOptions &options = RSnapshotOptions()); 1418 {; 1419 ColumnNames_t selectedColumns(columnList);; 1420 return Snapshot(treename, filename, selectedColumns, options);; 1421 }; 1422 // clang-format on; 1423 ; 1424 ////////////////////////////////////////////////////////////////////////////; 1425 /// \brief Save selected columns in memory.; 1426 /// \tparam ColumnTypes variadic list of branch/column types.; 1427 /// \param[in] columnList columns to be cached in memory.; 1428 /// \return a `RDataFrame` that wraps the cached dataset.; 1429 ///; 1430 /// This action returns a new `RDataFrame` object, completely detached from; 1431 /// the originating `RDataFrame`. The new dataframe only contains the cached; 1432 /// columns and stores their content in memory for fast, zero-copy subsequent access.; 1433 ///; 1434 /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; 1435 /// fits in memory and that will be accessed many times.; 1436 ///; 1437 /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; 1438 /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; 1439 /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; 1440 /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; 1441 ///; 1442 /// ### Example usage:; 1443 ///; 1444 /// **Types and columns specified:**; 1445 /// ~~~{.cpp}; 1446 /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; 1447 /// ~~~; 1448 ///; 1449 /// **Types inferred and columns specified (this invocation relies on jitting):**; 1450 /// ~~~{.cpp}; 1451 /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; 1452 /// ~~~; 1453 ///; 1454 /// **Types inferred and columns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:80255,access,accessed,80255,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['access'],['accessed']
Security,"ge (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions.; 18.5 Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that.; 18.5.1 TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; Up",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:971238,access,access,971238,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ge permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii); }. TSocket * GetSocket() const; { return fSocket; }. void put(const char* file, const char* remoteName = 0); standard ftp equivalents... { PutFile(file, remoteName); }. void get(const char* file, const char* localName = 0); { GetFile(file, localName); }. void cd(const char* dir) const; { ChangeDirectory(dir); }. void mkdir(const char* dir) const; { MakeDirectory(dir); }. void rmdir(const char* dir) const; { DeleteDirectory(dir); }. void ls(Option_t* cmd = """") const; { ListDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFTP.html:12536,access,access,12536,root/html528/TFTP.html,https://root.cern,https://root.cern/root/html528/TFTP.html,6,['access'],['access']
Security,"ge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:45632,checksum,checksum,45632,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,6,['checksum'],['checksum']
Security,"ge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:62419,checksum,checksum,62419,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['checksum'],['checksum']
Security,"geometry must be closed (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after this process.; Below is the general scheme of the manager class. An interactive session; Provided that a geometry was successfully built and closed (for instance the previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register itself to ROOT and the logical/physical structures will become immediately browsable. The ROOT browser will display starting from the geometry folder : the list of transformations and media, the top volume and the top logical node. These last two can be fully expanded, any intermediate volume/node in the browser being subject of direct access context menu operations (right mouse button click). All user utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the context menu. Drawing the geometry; Any logical volume can be drawn via TGeoVolume::Draw() member function. This can be directly accessed from the context menu of the volume object directly from the browser. There are several drawing options that can be set with TGeoManager::SetVisOption(Int_t opt) method :; opt=0; only the content of the volume is drawn, N levels down (default N=3). This is the default behavior. The number of levels to be drawn can be changed via TGeoManager::SetVisLevel(Int_t level) method. opt=1; the final leaves (e.g. daughters with no containment) of the branch starting from volume are drawn down to the current number of levels. WARNING : This mode is memory consuming depending of the size of geometry, so drawing from top level within this mode should be handled with care for expensive geometries. In future there will be a limitation on the maximum number of nodes to be visualized. opt=2; only the clicked volume is visualized. This is automatically set by TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method; The current view",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:16121,access,accessed,16121,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['access'],['accessed']
Security,"ger to the file. ;  ; virtual void WriteReal (Float_t r, Bool_t space=kTRUE);  Write a Real number to the file. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTImageDump.html:4830,hash,hash,4830,doc/master/classTImageDump.html,https://root.cern,https://root.cern/doc/master/classTImageDump.html,6,['hash'],['hash']
Security,"ggers the execution of the RDataFrame computation graph. Then retrieves an RMergeableValue object created with the result wrapped by the RResultPtr argument. The user obtains ownership of the mergeable, which in turn holds a copy of the result of the action. The RResultPtr is not destroyed in the process and will still retain (shared) ownership of the original result.; Example usage: using namespace ROOT::Detail::RDF;; ROOT::RDataFrame d(""myTree"", ""file_*.root"");; auto h = d.Histo1D(""Branch_A"");; auto mergeablehisto = GetMergeableValue(h);; d#define d(i)Definition RSha256.hxx:102; ROOT::Detail::RDFDefinition RooAbsDataHelper.h:80. Definition at line 470 of file RResultPtr.hxx. ◆ MakeResultPtr(). template<typename T > . RResultPtr< T > ROOT::Detail::RDF::MakeResultPtr ; (; const std::shared_ptr< T > & ; r, . RLoopManager & ; df, . std::shared_ptr< ROOT::Internal::RDF::RActionBase > ; actionPtr . ). Create a RResultPtr and set its pointer to the corresponding RAction This overload is invoked by non-jitted actions, as they have access to RAction before constructing RResultPtr. ; Definition at line 444 of file RResultPtr.hxx. ◆ MergeValues() [1/3]. template<typename T , typename... Ts> . void ROOT::Detail::RDF::MergeValues ; (; RMergeableValue< T > & ; OutputMergeable, . const RMergeableValue< Ts > &... ; InputMergeables . ). Merge multiple RMergeableValue objects into one. ; Parameters. [in,out]OutputMergeableThe mergeable object where all the information will be aggregated. ; [in]InputMergeablesOther mergeables containing the partial results. This overload modifies the mergeable objects in-place. The ownership is left to the caller. The first argument to the function will get all the values contained in the other arguments merged into itself. This is a convenience overload introduced for the ROOT Python API.; Example usage: // mh1, mh2, mh3 are std::unique_ptr<RMergeableValue<TH1D>>; ROOT::Detail::RDF::MergeValues(*mh1, *mh2, *mh3);; const auto &mergedhisto = mh1->Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Detail_1_1RDF.html:9117,access,access,9117,doc/master/namespaceROOT_1_1Detail_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Detail_1_1RDF.html,1,['access'],['access']
Security,"ggle batch mode.Definition TCanvas.cxx:1957; TCanvas::Deletevoid Delete(Option_t *="""") overrideDelete this object.Definition TCanvas.h:120; TCanvas::UseGLBool_t UseGL() constDefinition TCanvas.h:228; TCanvas::ResizeOpaquevoid ResizeOpaque(Int_t set=1)Set option to resize objects/pads in a canvas.Definition TCanvas.cxx:1759; TCanvas::ToggleToolBarvirtual void ToggleToolBar()Toggle toolbar.Definition TCanvas.cxx:2442; TCanvas::SetRetainedvoid SetRetained(Bool_t retained=kTRUE)Definition TCanvas.h:218; TCanvas::OpaqueResizingBool_t OpaqueResizing() const overrideDefinition TCanvas.h:181; TCanvas::DrawClonePadvirtual TObject * DrawClonePad()Draw a clone of this canvas into the current pad In an interactive session, select the destination/cu...Definition TCanvas.cxx:924; TCanvas::ResetDrawnvoid ResetDrawn()Definition TCanvas.h:192; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::Pickvirtual TPad * Pick(Int_t px, Int_t py, TObjLink *&pickobj)Search for an object at pixel position px,py.Definition TPad.cxx:4657; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TThread<div class=""legacybo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8h_source.html:31508,access,access,31508,doc/master/TCanvas_8h_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8h_source.html,1,['access'],['access']
Security,"gh the connection object. The number of; 747tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; 748doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; 749a batch system. The client object created at the beginning of the application does not automatically know how many cores; 750will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; 751the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks.; 752 ; 753The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional; 754keyword argument `npartitions` when creating the RDataFrame object. This parameter is accepted irrespectively of the; 755backend used:; 756 ; 757~~~{.py}; 758import ROOT; 759 ; 760# Define correct imports and access the distributed RDataFrame appropriate for the; 761# backend used in the analysis; 762RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame; 763 ; 764if __name__ == ""__main__"":; 765 # The `npartitions` optional argument tells the RDataFrame how many tasks are desired; 766 df = RDataFrame(""mytree"",""myfile.root"", npartitions=NPARTITIONS); 767 # Proceed as usual; 768 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 769~~~; 770 ; 771Note that when processing a TTree or TChain dataset, the `npartitions` value should not exceed the number of clusters in; 772the dataset. The number of clusters in a TTree can be retrieved by typing `rootls -lt myfile.root` at a command line.; 773 ; 774### Distributed Snapshot; 775 ; 776The Snapshot operation behaves slightly differently when executed distributedly. First off, it requires the path; 777supplied to the Snapshot call to be accessible from any worker of the cluster and from the client machine (in general; 778it should be provid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:44106,access,access,44106,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,"gh the connection object. The number of; 787tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; 788doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; 789a batch system. The client object created at the beginning of the application does not automatically know how many cores; 790will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; 791the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks.; 792 ; 793The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional; 794keyword argument `npartitions` when creating the RDataFrame object. This parameter is accepted irrespectively of the; 795backend used:; 796 ; 797~~~{.py}; 798import ROOT; 799 ; 800# Define correct imports and access the distributed RDataFrame appropriate for the; 801# backend used in the analysis; 802RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame; 803 ; 804if __name__ == ""__main__"":; 805 # The `npartitions` optional argument tells the RDataFrame how many tasks are desired; 806 df = RDataFrame(""mytree"",""myfile.root"", npartitions=NPARTITIONS); 807 # Proceed as usual; 808 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 809~~~; 810 ; 811Note that when processing a TTree or TChain dataset, the `npartitions` value should not exceed the number of clusters in; 812the dataset. The number of clusters in a TTree can be retrieved by typing `rootls -lt myfile.root` at a command line.; 813 ; 814### Distributed Snapshot; 815 ; 816The Snapshot operation behaves slightly differently when executed distributedly. First off, it requires the path; 817supplied to the Snapshot call to be accessible from any worker of the cluster and from the client machine (in general; 818it should be provid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:45746,access,access,45746,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,"ghtsXMLTo(void* parent) const; add the rules to XML node. void ReadWeightsFromStream(istream& istr); read rules from an std::istream. void ReadWeightsFromXML(void* wghtnode); read rules from XML node. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file (here ntuple). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassRuleCuts(ostream& ) const; print out the rule cuts. void MakeClassLinear(ostream& ) const; print out the linear terms. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodRuleFit(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0). Bool_t UseBoost() const; { return fUseBoost; }. RuleFit* GetRuleFitPtr(); accessors. { return &fRuleFit; }. const RuleFit* GetRuleFitConstPtr() const; { return &fRuleFit; }. TDirectory* GetMethodBaseDir() const; { return BaseDir(); }. const std::vector<TMVA::Event*>& GetTrainingEvents() const; { return fEventSample; }. const std::vector<TMVA::DecisionTree*>& GetForest() const; { return fForest; }. Int_t GetNTrees() const; { return fNTrees; }. Double_t GetTreeEveFrac() const; { return fTreeEveFrac; }. const SeparationBase* GetSeparationBaseConst() const; { return fSepType; }. SeparationBase* GetSeparationBase() const; { return fSepType; }. TMVA::DecisionTree::EPruneMethod GetPruneMethod() const; { return fPruneMethod; }. Double_t GetPruneStrength() const; { return fPruneStrength; }. Double_t GetMinFracNEve() const; { return fMinFracNEve; }. Double_t GetMaxFracNEve() const; { return fMaxFracNEve; }. Int_t GetNCuts() const. { return fNCuts; }. Int_t GetGDNPathSteps() const; { return fGDNPathSteps; }. Double_t GetGDPathStep() const; { return fGDPathStep;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodRuleFit.html:24553,access,accessors,24553,root/html602/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodRuleFit.html,2,['access'],['accessors']
Security,"gister the StreamerInfo in the given slot, change the State of the TClass as appropriate. ;  ; void RemoveStreamerInfo (Int_t slot);  Remove and delete the StreamerInfo in the given slot. ;  ; void ReplaceWith (TClass *newcl) const;  ; void ResetCaches ();  To clean out all caches. ;  ; void ResetClassInfo ();  Make sure that the current ClassInfo is up to date. ;  ; void ResetClassInfo (Long_t tagnum);  Make sure that the current ClassInfo is up to date. ;  ; void ResetInstanceCount ();  ; void ResetMenuList ();  Resets the menu list to it's standard value. ;  ; void SetCanSplit (Int_t splitmode);  Set the splitability of this class: ;  ; void SetCollectionProxy (const ROOT::Detail::TCollectionProxyInfo &);  Create the collection proxy object (and the streamer object) from using the information in the TCollectionProxyInfo. ;  ; void SetContextMenuTitle (const char *title);  Change (i.e. set) the title of the TNamed. ;  ; void SetConvStreamerFunc (ClassConvStreamerFunc_t strm);  Set a wrapper/accessor function around this class custom conversion streamer. ;  ; void SetCurrentStreamerInfo (TVirtualStreamerInfo *info);  Set pointer to current TVirtualStreamerInfo. ;  ; void SetDeclFile (const char *name, Short_t line);  ; void SetDelete (ROOT::DelFunc_t deleteFunc);  Install a new wrapper around 'delete'. ;  ; void SetDeleteArray (ROOT::DelArrFunc_t deleteArrayFunc);  Install a new wrapper around 'delete []'. ;  ; void SetDestructor (ROOT::DesFunc_t destructorFunc);  Install a new wrapper around the destructor. ;  ; void SetDirectoryAutoAdd (ROOT::DirAutoAdd_t dirAutoAddFunc);  Install a new wrapper around the directory auto add function. ;  ; void SetGlobalIsA (IsAGlobalFunc_t);  This function installs a global IsA function for this class. ;  ; void SetImplFileName (const char *implFileName);  ; void SetLastReadInfo (TVirtualStreamerInfo *info);  ; void SetMemberStreamer (const char *name, MemberStreamerFunc_t strm);  Install a new member streamer (p will be copied). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:22764,access,accessor,22764,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['access'],['accessor']
Security,"gly curved distributions. The old default behaviour was to interpolate the curve at the bin centres, which can still be enabled by setting the useAverage parameter of RooPlot::residHist or RooPlot::pullHist to false.; Improved recovery from invalid parameters; When a function in RooFit is undefined (Poisson with negative mean, PDF with negative values, etc), RooFit can now pass information about the “badness” of the violation to the minimiser. The minimiser can use this to compute a gradient to find its way out of the undefined region. This can drastically improve its ability to recover when unstable fit models are used, for example RooPolynomial.; For details, see the RooFit tutorial rf612_recoverFromInvalidParameters.C and arxiv:2012.02746.; Modernised RooDataHist; RooDataHist was partially modernised to improve const-correctness, to reduce side effects as well as its memory footprint, and to make it ready for RooFit’s faster batch evaluations. Derived classes that directly access protected members might need to be updated. This holds especially for direct accesses to _curWeight, _curWeightErrLo, etc, which have been removed. (It doesn’t make sense to write to these members from const functions when the same information can be retrieved using an index access operator of an array.) All similar accesses in derived classes should be replaced by the getters get_curWeight() or better get_wgt(i), which were also supported in ROOT <v6.24. More details on what happened:. Reduced side effects. This code produces undefined behaviour because the side effect of get(i), i.e., loading the new weight into _curWeight is not guaranteed to happen before weight() is called:. processEvent(dataHist.get(i), dataHist.weight()); // Dangerous! Order of evaluation is not guaranteed.; With the modernised interface, one would use:; processEvent(dataHist.get(i), dataHist.weight(i));; To modernise old code, one should replace patterns like h.get(i); h.func() by h.func(i);. One may #define R__SU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:22439,access,access,22439,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['access'],['access']
Security,"gnatures. More...;  ; struct  GetFunctorType< T(F::*)(const T *, const double *) const >;  ; struct  GetFunctorType< T(F::*)(const T *, const double *)>;  ; struct  GetFunctorType< T(F::*)(T *, double *) const >;  ; struct  GetFunctorType< T(F::*)(T *, double *)>;  ; struct  InterpreterMutexRegistrationRAII;  ; struct  ParsingStateRAII;  RAII used to store Parser, Sema, Preprocessor state for recursive parsing. More...;  ; struct  RBaseType;  ; struct  RCast;  ; struct  RCast< T, false, false >;  ; struct  RCast< T, false, true >;  ; class  RConcurrentHashColl;  This class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection of uid (integer) This is used in the handling of the StreamerInfo record in TFile. More...;  ; struct  RDavixFileDes;  ; struct  RecurseCounts;  ; struct  RHashMap;  ; class  RIoUring;  ; class  RRawFile;  The RRawFile provides read-only access to local and remote files. More...;  ; class  RRawFileDavix;  The RRawFileDavix class provides read-only access to remote non-ROOT files. More...;  ; class  RRawFileNetXNG;  The RRawFileNetXNG class provides read-only access to remote files using root/roots protocol. More...;  ; struct  RRawFileNetXNGImpl;  ; class  RRawFileTFile;  The RRawFileTFile wraps an open TFile, but does not take ownership. More...;  ; class  RRawFileUnix;  The RRawFileUnix class uses POSIX calls to read from a mounted file system. More...;  ; class  RRawFileWin;  The RRawFileWin class uses portable C I/O calls to read from a drive. More...;  ; class  RSlotStack;  A thread-safe stack of N indexes (0 to size - 1). More...;  ; struct  RSlotStackRAII;  A RAII object to pop and push slot numbers from a RSlotStack object. More...;  ; class  RStl;  ; class  RTaskArenaWrapper;  Wrapper for tbb::task_arena. More...;  ; class  TArrayCharProxy;  Concrete Implementation of the branch proxy around the data members which are array of char. More...;  ; class  TArrayProxy;  Template for concrete implementation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:1778,access,access,1778,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,2,['access'],['access']
Security,"gned ROOT::RWebWindow::fProtocolConnId {0}. private . ! connection id, which is used for writing protocol ; Definition at line 172 of file RWebWindow.hxx. ◆ fProtocolFileName. std::string ROOT::RWebWindow::fProtocolFileName. private . ! local file where communication protocol will be written ; Definition at line 170 of file RWebWindow.hxx. ◆ fProtocolPrefix. std::string ROOT::RWebWindow::fProtocolPrefix. private . ! prefix for created files names ; Definition at line 173 of file RWebWindow.hxx. ◆ fRequireAuthKey. bool ROOT::RWebWindow::fRequireAuthKey {true}. private . ! defines if authentication key always required when connect to the widget ; Definition at line 146 of file RWebWindow.hxx. ◆ fSendMT. bool ROOT::RWebWindow::fSendMT {false}. private . ! true is special threads should be used for sending data ; Definition at line 145 of file RWebWindow.hxx. ◆ fUseCurrentDir. bool ROOT::RWebWindow::fUseCurrentDir {false}. private . ! if window can access local files via currentdir/ path of http server ; Definition at line 155 of file RWebWindow.hxx. ◆ fUseProcessEvents. bool ROOT::RWebWindow::fUseProcessEvents {false}. private . ! all window functionality will run through process events ; Definition at line 143 of file RWebWindow.hxx. ◆ fUserArgs. std::string ROOT::RWebWindow::fUserArgs. private . ! arbitrary JSON code, which is accessible via conn.getUserArgs() method ; Definition at line 175 of file RWebWindow.hxx. ◆ fUseServerThreads. bool ROOT::RWebWindow::fUseServerThreads {false}. private . ! indicates that server thread is using, no special window thread ; Definition at line 142 of file RWebWindow.hxx. ◆ fWidth. unsigned ROOT::RWebWindow::fWidth {0}. private . Definition at line 166 of file RWebWindow.hxx. ◆ fWindowThrd. std::thread ROOT::RWebWindow::fWindowThrd. private . ! special thread for that window ; Definition at line 163 of file RWebWindow.hxx. ◆ fWSHandler. std::shared_ptr<RWebWindowWSHandler> ROOT::RWebWindow::fWSHandler. private . ! specialize websoc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:59066,access,access,59066,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['access'],['access']
Security,"gned ROOT::RWebWindow::fProtocolConnId {0}. private . ! connection id, which is used for writing protocol ; Definition at line 175 of file RWebWindow.hxx. ◆ fProtocolFileName. std::string ROOT::RWebWindow::fProtocolFileName. private . ! local file where communication protocol will be written ; Definition at line 173 of file RWebWindow.hxx. ◆ fProtocolPrefix. std::string ROOT::RWebWindow::fProtocolPrefix. private . ! prefix for created files names ; Definition at line 176 of file RWebWindow.hxx. ◆ fRequireAuthKey. bool ROOT::RWebWindow::fRequireAuthKey {true}. private . ! defines if authentication key always required when connect to the widget ; Definition at line 149 of file RWebWindow.hxx. ◆ fSendMT. bool ROOT::RWebWindow::fSendMT {false}. private . ! true is special threads should be used for sending data ; Definition at line 148 of file RWebWindow.hxx. ◆ fUseCurrentDir. bool ROOT::RWebWindow::fUseCurrentDir {false}. private . ! if window can access local files via currentdir/ path of http server ; Definition at line 158 of file RWebWindow.hxx. ◆ fUseProcessEvents. bool ROOT::RWebWindow::fUseProcessEvents {false}. private . ! all window functionality will run through process events ; Definition at line 146 of file RWebWindow.hxx. ◆ fUserArgs. std::string ROOT::RWebWindow::fUserArgs. private . ! arbitrary JSON code, which is accessible via conn.getUserArgs() method ; Definition at line 178 of file RWebWindow.hxx. ◆ fUseServerThreads. bool ROOT::RWebWindow::fUseServerThreads {false}. private . ! indicates that server thread is using, no special window thread ; Definition at line 145 of file RWebWindow.hxx. ◆ fWidth. unsigned ROOT::RWebWindow::fWidth {0}. private . Definition at line 169 of file RWebWindow.hxx. ◆ fWindowThrd. std::thread ROOT::RWebWindow::fWindowThrd. private . ! special thread for that window ; Definition at line 166 of file RWebWindow.hxx. ◆ fWSHandler. std::shared_ptr<RWebWindowWSHandler> ROOT::RWebWindow::fWSHandler. private . ! specialize websoc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:57950,access,access,57950,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['access'],['access']
Security,"gned connid=0)Remove master connection - if any.Definition RWebWindow.cxx:344; ROOT::RWebWindow::RemoveEmbedWindowvoid RemoveEmbedWindow(unsigned connid, int channel)Remove RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1909; ROOT::RWebWindow::SetCallBacks_R__DEPRECATED_LATER(""Use GetUrl() to get valid connection URL"") std _R__DEPRECATED_LATER(""Use GetAddr() to get valid connection URL"") std void SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1814; ROOT::RWebWindow::SetRequireAuthKeyvoid SetRequireAuthKey(bool on)Configure if authentication key in connection string is required.Definition RWebWindow.hxx:319; ROOT::RWebWindow::GenerateKeystd::string GenerateKey() constGenerate new unique key for the window.Definition RWebWindow.cxx:612; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:327; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:162; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:307; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Data@ kind_DataDefinition RWebWindow.hxx:127; ROOT::RWebWindow::IsFileDialogMessagestatic bool IsFileDialogMessage(const std::string &msg)Check if this could be the message send by client to start new file dialog If returns true,...Definition RWebWindow.cxx:200",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:44348,access,access,44348,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['access'],['access']
Security,"gned int ivar, double upper); virtual boolSetVariableValue(unsigned int ivar, double val); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector&); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. protected:. static doubleEvaluateFCN(const double* x, double* g); static voidFcn(int&, double*, double& f, double*, int). private:. TFumiliMinimizer(const TFumiliMinimizer&); TFumiliMinimizer&operator=(const TFumiliMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFumiliMinimizer.html:5578,validat,validated,5578,root/html534/TFumiliMinimizer.html,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html,1,['validat'],['validated']
Security,"gnment operator. void SetCoordinates(const ROOT::Math::Cylindrical3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar rho, ROOT::Math::Cylindrical3D<double>::Scalar zz, ROOT::Math::Cylindrical3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar& rho, ROOT::Math::Cylindrical3D<double>::Scalar& zz, ROOT::Math::Cylindrical3D<double>::Scalar& phi) const. get internal data into 3 Scalar numbers ( rho, z , phi). {rho=fRho; zz=fZ; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Rho() const; accessors. { return fRho; }. Scalar Z() const; { return fZ; }. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fRho*std::cos(fPhi); }. Scalar Y() const; { return fRho*std::sin(fPhi); }. Scalar Mag2() const; { return fRho*fRho + fZ*fZ; }. Scalar R() const; { return std::sqrt( Mag2()); }. Scalar Perp2() const; { return fRho*fRho; }. Scalar Theta() const; { return (fRho==0 && fZ==0 ) ? 0 : atan2(fRho,fZ); }. Scalar Eta() const; pseudorapidity - use same implementation as in Cartesian3D. void SetRho(double rho); setters (only for data members). set the rho coordinate value keeping z and phi constant. void SetZ(double zz). set the z coordinate value keeping rho and phi constant. void SetPhi(double phi). set the phi coordinate value keeping rho and z constant. void SetXYZ(ROOT::Math::Cylindrical3D<double>::Scalar xx, ROOT::Math::Cylindrical3D<double>::Scalar yy, ROOT::Math::Cylindrical3D<double>::Scalar zz). set all values using cartesian coordinates. void Scale(double ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Cylindrical3D_double_.html:4387,access,accessors,4387,root/html526/ROOT__Math__Cylindrical3D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Cylindrical3D_double_.html,5,['access'],['accessors']
Security,"gnore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15449 ; 15450 /* If any ACL is se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:455794,access,access,455794,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"gnore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15450 ; 15451 /* If any ACL is se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:455827,access,access,455827,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"gram/macro,; where the environemntal variables solution is not convenient (see below). If you need to specify both NOPROXY and AUTH separate them by ' '; (blank), for instance:; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"". Examples:; TFile* f1 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f2 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");. If there is no authentication information in the 'options' argument; (i.e. not AUTH=""...."") the values of the environmental variables; S3_ACCESS_KEY and S3_SECRET_KEY (if set) are expected to contain; the access key id and the secret access key, respectively. You have; been provided with these credentials by your S3 service provider. If neither the AUTH information is provided in the 'options' argument; nor the environmental variables are set, we try to open the file; without providing any authentication information to the server. This; is useful when the file is set an access control that allows for; any unidentified user to read the file. Bool_t ParseOptions(Option_t* options, TString& accessKey, TString& secretKey); Extracts the S3 authentication key pair (access key and secret key); from the options. The authentication credentials can be specified in; the options provided to the constructor of this class as a string; containing: ""AUTH=<access key>:<secret key>"" and can include other; options, for instance ""NOPROXY"" for not using the HTTP proxy for; accessing this file's contents.; For instance:; ""NOPROXY AUTH=F38XYZABCDeFgHiJkLm:V+frt4re7J1euSNFnmaf8wwmI401234E7kzxZ/TTM+"". Int_t GetHead(); Overwrites TWebFile::GetHead() for retrieving the HTTP headers of this; file. Uses TS3HTTPRequest to generate an HTTP HEAD request which includes; the authorization header expected by the S3 server. void SetMsgReadBuffer10(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:29482,authenticat,authentication,29482,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,3,['authenticat'],['authentication']
Security,"grams are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.6.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.6.2 Regular calls of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.7 Data access from command shell; The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts.; If one starts a server and register an object like for example:; root [1] serv = new THttpServer(""http:8080"");; root [2] TNamed* n1 = new TNamed(""obj"", ""title"");; root [3] serv->Register(""subfolder"", n1);; One could request a JSON representati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:8675,access,access,8675,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['access'],['access']
Security,"grams are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.9 Data access from command shell; The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts.; If one starts a server and register an object like for example:; auto serv = new THttpServer(""http:8080"");; TNamed* n1 = new TNamed(""obj"", ""title"");; serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:12832,access,access,12832,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['access'],['access']
Security,"gs, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id is (statbuf.st_dev << 24) + statbuf.st_ino; Size is the file size; Flags is file type: 0 is regular file, bit 0 set executable,; bit 1 set directory, bit 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:28567,secur,secure,28567,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['secur'],['secure']
Security,"gs. The map uses an open addressing hashing method (linear probing). ; Definition at line 33 of file TExMap.h. Classes; struct  Assoc_t;  . Public Member Functions;  TExMap (const TExMap &map);  Copy constructor. ;  ;  TExMap (Int_t mapSize=100);  Create a TExMap. ;  ;  ~TExMap ();  Delete TExMap. ;  ; void Add (Long64_t key, Long64_t value);  ; void Add (ULong64_t hash, Long64_t key, Long64_t value);  Add an (key,value) pair to the table. The key should be unique. ;  ; void AddAt (UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value);  Add an (key,value) pair to the table. ;  ; Int_t Capacity () const;  ; void Delete (Option_t *opt="""") override;  Delete all entries stored in the TExMap. ;  ; void Expand (Int_t newsize);  Expand the TExMap. ;  ; Int_t GetSize () const;  ; Long64_t GetValue (Long64_t key);  ; Long64_t GetValue (ULong64_t hash, Long64_t key);  Return the value belonging to specified key and hash value. ;  ; Long64_t GetValue (ULong64_t hash, Long64_t key, UInt_t &slot);  Return the value belonging to specified key and hash value. ;  ; TClass * IsA () const override;  ; Long64_t & operator() (Long64_t key);  ; Long64_t & operator() (ULong64_t hash, Long64_t key);  Return a reference to the value belonging to the key with the specified hash value. ;  ; TExMap & operator= (const TExMap &);  Assignment operator. ;  ; void Remove (Long64_t key);  ; void Remove (ULong64_t hash, Long64_t key);  Remove entry with specified key from the TExMap. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExMap.html:1433,hash,hash,1433,doc/master/classTExMap.html,https://root.cern,https://root.cern/doc/master/classTExMap.html,2,['hash'],['hash']
Security,"gs.dropoutProbabilities = fetchValue(block, ""DropConfig"",; 579 std::vector<Double_t>());; 580 ; 581 TString regularization = fetchValue(block, ""Regularization"",; 582 TString (""NONE""));; 583 if (regularization == ""L1"") {; 584 settings.regularization = DNN::ERegularization::kL1;; 585 } else if (regularization == ""L2"") {; 586 settings.regularization = DNN::ERegularization::kL2;; 587 } else {; 588 settings.regularization = DNN::ERegularization::kNone;; 589 }; 590 ; 591 TString strMultithreading = fetchValue(block, ""Multithreading"",; 592 TString (""True""));; 593 if (strMultithreading.BeginsWith (""T"")) {; 594 settings.multithreading = true;; 595 } else {; 596 settings.multithreading = false;; 597 }; 598 ; 599 fTrainingSettings.push_back(settings);; 600 }; 601}; 602 ; 603////////////////////////////////////////////////////////////////////////////////; 604/// Validation of the ValidationSize option. Allowed formats are 20%, 0.2 and; 605/// 100 etc.; 606/// - 20% and 0.2 selects 20% of the training set as validation data.; 607/// - 100 selects 100 events as the validation data.; 608///; 609/// @return number of samples in validation set; 610///; 611 ; 612UInt_t TMVA::MethodDNN::GetNumValidationSamples(); 613{; 614 Int_t nValidationSamples = 0;; 615 UInt_t trainingSetSize = GetEventCollection(Types::kTraining).size();; 616 ; 617 // Parsing + Validation; 618 // --------------------; 619 if (fValidationSize.EndsWith(""%"")) {; 620 // Relative spec. format 20%; 621 TString intValStr = TString(fValidationSize.Strip(TString::kTrailing, '%'));; 622 ; 623 if (intValStr.IsFloat()) {; 624 Double_t valSizeAsDouble = fValidationSize.Atof() / 100.0;; 625 nValidationSamples = GetEventCollection(Types::kTraining).size() * valSizeAsDouble;; 626 } else {; 627 Log() << kFATAL << ""Cannot parse number \"""" << fValidationSize; 628 << ""\"". Expected string like \""20%\"" or \""20.0%\""."" << Endl;; 629 }; 630 } else if (fValidationSize.IsFloat()) {; 631 Double_t valSizeAsDouble = fValidationSize.Atof();; 63",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:20961,validat,validation,20961,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['validat'],['validation']
Security,"gure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel.html"" as default HTML page At the moment only FitPanel is existing. ;  ; void SetPosition (unsigned x, unsigned y);  Set window position. Will be applied if supported by used web display (like CEF or Chromium) ;  ; void SetRequireAuthKey (bool on);  Configure if authentication key in connection string is required. ;  ; void SetUseCurrentDir (bool on=true);  Configure if window can access local files via currentdir/ path of http server. ;  ; void SetUserArgs (const std::string &args);  Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into connectWebWindow({}) Must be set before RWebWindow::Show() method is called. ;  ; unsigned Show (const RWebDisplayArgs &args="""");  Show window in specified location. ;  ; void StartThread ();  Start special thread which will be used by the window to handle all callbacks One has to be sure, that access to global ROOT structures are minimized and protected with ROOT::EnableThreadSafety(); call. ;  ; void StopThread ();  Stop special thread. ;  ; void Sync ();  Special method to process all internal activity when window runs in separate thread. ;  ; void TerminateROOT ();  Terminate ROOT session Tries to correctly close THttpServer, associated with RWebWindowsManager After that exit from process. ;  ; void UseServerThreads ();  Let use THttpServer threads to process requests WARNING!!! only for expert use Should be only used when application provides proper locking and does not block. ;  ; int WaitFor (WebWindowWaitFunc_t check);  Waits until provided check function or lambdas returns non-zero value Check function has following signature: int func(double spent_tm) Waiting will be continued, if function returns zero. ;  ; int WaitForTimed (WebWindowWaitFunc_t check);  Waits until provided check function or lambdas returns non-zero value Check function has followin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:9956,access,access,9956,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['access'],['access']
Security,"h can be held by window ;  ; void SetNativeOnlyConn (bool on=true);  configures that only native (own-created) connections are allowed ;  ; void SetOperationTmout (float tm=50.);  Set timeout for synchronous WebWindow operations. ;  ; void SetPanelName (const std::string &name);  Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel.html"" as default HTML page At the moment only FitPanel is existing. ;  ; void SetPosition (unsigned x, unsigned y);  Set window position. Will be applied if supported by used web display (like CEF or Chromium) ;  ; void SetRequireAuthKey (bool on);  Configure if authentication key in connection string is required. ;  ; void SetUseCurrentDir (bool on=true);  Configure if window can access local files via currentdir/ path of http server. ;  ; void SetUserArgs (const std::string &args);  Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into connectWebWindow({}) Must be set before RWebWindow::Show() method is called. ;  ; unsigned Show (const RWebDisplayArgs &args="""");  Show window in specified location. ;  ; void StartThread ();  Start special thread which will be used by the window to handle all callbacks One has to be sure, that access to global ROOT structures are minimized and protected with ROOT::EnableThreadSafety(); call. ;  ; void StopThread ();  Stop special thread. ;  ; void Sync ();  Special method to process all internal activity when window runs in separate thread. ;  ; void TerminateROOT ();  Terminate ROOT session Tries to correctly close THttpServer, associated with RWebWindowsManager After that exit from process. ;  ; void UseServerThreads ();  Let use THttpServer threads to process requests WARNING!!! only for expert use Should be only used when application provides proper locking and does not block. ;  ; int WaitFor (WebWindowWaitFunc_t check);  Waits until provided check function or lambdas retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:9622,inject,injected,9622,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['inject'],['injected']
Security,"h in multi-thread Snapshot in sub-directory; [#8276] - [DF] Possible use after delete of the functor passed to PassAsVec; [#8071] - Problems compiling root 6.24.00 with gcc 11 on Fedora 34; [#8307] - Issue with RooSimultaneous in 6.24.00 ?; [#8295] - TChain::AddClone failing for sub-branches of branch of type with ClassDef; [#7727] - TChain::CopyAddresses:0 warning in RDataFrame Snapshot of TChain with multiple files with objects; [#6520] - Integer types not available for Bulk API; [#8317] - [DF] Compilation failure when a mutable lambda is passed to Foreach; [#8155] - Error opening remote root file LCG_100; [#8280] - ROOT CMake fails if an external package sets a higher minimum CMake version; [#8281] - ROOT 6.24 fails to compile with GCC 11.1 in C++11 mode; [#8180] - ROOT 6.24 breaks Alice O2 due to symbol confusion with system llvm 11; [#8033] - StreamerElement retrieved from file has incorrect element name for (some) arrays.; [#8022] - TBB exposed in public includes of Thread library; [#7905] - sqrt without std:: in Math/GenVector/PxPyPzE4D.h; [#8196] - TUnuranContDist ctor clones the dpdf but does not use the clone causing a segfault later on; [#8011] - Bug in RooAbsPdf::extendedTerm when expected events is negative; [#8499] - Dict type alias fwd decl: underlying type not fwd declared; [#6454] - ROOT fails to parse <boost/shared_ptr.hpp> at runtime on macOS. Release 6.24/04; Published on August 26, 2021; Bugs and Issues fixed in this release. [#8503] - ranluxpp code is using left shift of negative value -1 which is undefined per the C standard; [#8641] - RooStats::HypoTestInverterResult::FindIndex fails if xvalue == 1; [#8767] - [netxng] Crash in on-exit destruction of an TNetXNGFile object; [#8739] - [DF] Cannot read files that don’t have a .root extension with IMT on; [#8713] - [tree] TTreeCache is turned off when fAutoFlush == 0. Release 6.24/06; Published on September 1, 2021; Bugs and Issues fixed in this release. [#8931] - TDirectory::RegisterGDirectory is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:48861,expose,exposed,48861,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['expose'],['exposed']
Security,"h macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; This 2 functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; int; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Access to TClonesArray.; If a branch (or member) is a TClonesArray (let's say fTracks), you can access the TClonesArray itself by using ->: fTracks->GetLast();; However this will load the full TClonesArray object and its content. To quickly read the size of the TClonesArray use (note the dot): fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been split. To access the content of the TClonesArray, use the [] operator: float px = fTracks[i].fPx; // fPx of the i-th track; Warning:; The variable actually use for access are 'wrapper' around the real data type (to add autoload for example) and hence getting to the data involves the implicit call to a C++ conversion operator. This conversion is automatic in most case. However it is not invoked in a few cases, in particular in variadic function (like printf). So when using printf you should either explicitly cast the value or use any intermediary variable: fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);; Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:33879,access,access,33879,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['access'],['access']
Security,"h object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. RooLinkedListIter iterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE); Sort elements of this list according to their; TObject::Compare() ranking via a simple; bubble sort algorithm. void swapWithNext(RooLinkedListElem* elem); Swap given to elements in the linked list. Auxiliary function for Sort(). void Streamer(TBuffer& b); Custom streaming handling schema evolution w.r.t past implementations. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. » Last changed: Sat Oct 9 06:58:32 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooLinkedList.html:9100,hash,hash,9100,root/html528/RooLinkedList.html,https://root.cern,https://root.cern/root/html528/RooLinkedList.html,1,['hash'],['hash']
Security,"h should be provided for connecting windowDefinition RWebWindow.hxx:153; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:282; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definition RWebWindow.cxx:1915; ROOT::RWebWindow::fWSHandlerstd::shared_ptr< RWebWindowWSHandler > fWSHandler! specialize websocket handler for all incoming connectionsDefinition RWebWindow.hxx:147; ROOT::RWebWindow::StopThreadvoid StopThread()Stop special thread.Definition RWebWindow.cxx:1702; ROOT::RWebWindow::SubmitDatavoid SubmitData(unsigned connid, bool txt, std::string &&data, int chid=1)Internal method to send data.Definition RWebWindow.cxx:1529; ROOT::RWebWindow::HMACstatic std::string HMAC(const std::string &key, const std::string &sessionKey, const char *msg, int msglen)Calculate HMAC checksum for provided key and message Key combained from connection key and session ke...Definition RWebWindow.cxx:1992; ROOT::RWebWindow::~RWebWindow~RWebWindow()RWebWindow destructor Closes all connections and remove window from manager.Definition RWebWindow.cxx:85; ROOT::RWebWindow::EmbedFileDialogstatic bool EmbedFileDialog(const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args)Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tr...Definition RWebWindow.cxx:1977; ROOT::RWebWindow::CloseConnectionvoid CloseConnection(unsigned connid)Close specified connection.Definition RWebWindow.cxx:1447; ROOT::RWebWindow::fPendingConnConnectionsList_t fPendingConn! list of pending connection with pre-assigned keysDefinition RWebWindow.hxx:149; ROOT::RWebWindow::GetConnectionIdunsigned GetConnectionId(int num=0) constReturns connection id for specified connection sequence number Only ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:33149,checksum,checksum,33149,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['checksum'],['checksum']
Security,"h should be provided for connecting windowDefinition RWebWindow.hxx:156; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:285; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definition RWebWindow.cxx:1957; ROOT::RWebWindow::fWSHandlerstd::shared_ptr< RWebWindowWSHandler > fWSHandler! specialize websocket handler for all incoming connectionsDefinition RWebWindow.hxx:150; ROOT::RWebWindow::StopThreadvoid StopThread()Stop special thread.Definition RWebWindow.cxx:1744; ROOT::RWebWindow::SubmitDatavoid SubmitData(unsigned connid, bool txt, std::string &&data, int chid=1)Internal method to send data.Definition RWebWindow.cxx:1571; ROOT::RWebWindow::HMACstatic std::string HMAC(const std::string &key, const std::string &sessionKey, const char *msg, int msglen)Calculate HMAC checksum for provided key and message Key combained from connection key and session ke...Definition RWebWindow.cxx:2034; ROOT::RWebWindow::~RWebWindow~RWebWindow()RWebWindow destructor Closes all connections and remove window from manager.Definition RWebWindow.cxx:85; ROOT::RWebWindow::EmbedFileDialogstatic bool EmbedFileDialog(const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args)Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tr...Definition RWebWindow.cxx:2019; ROOT::RWebWindow::CloseConnectionvoid CloseConnection(unsigned connid)Close specified connection.Definition RWebWindow.cxx:1489; ROOT::RWebWindow::fPendingConnConnectionsList_t fPendingConn! list of pending connection with pre-assigned keysDefinition RWebWindow.hxx:152; ROOT::RWebWindow::GetConnectionIdunsigned GetConnectionId(int num=0) constReturns connection id for specified connection sequence number Only ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:33538,checksum,checksum,33538,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['checksum'],['checksum']
Security,"h starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19498,access,access,19498,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['access'],['access']
Security,"h""; #include ""TMathBase.h""; #include <string_view>; #include ""ROOT/TypeTraits.hxx""; #include ""snprintf.h""; #include <iosfwd>; #include <cstdarg>; #include <cstdio>; #include <cstring>; #include <string>. Include dependency graph for TString.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  TString::LongStr_t;  ; struct  TString::RawStr_t;  ; struct  TString::Rep_t;  ; struct  TString::ShortStr_t;  ; class  TString;  Basic string class. More...;  ; class  TSubString;  A zero length substring is legal. More...;  ; union  TString::UStr_t;  . Namespaces; namespace  llvm;  . Functions; char * Compress (const char *str);  Remove all blanks from the string str. ;  ; int EscChar (const char *src, char *dst, int dstlen, char *specchars, char escchar);  Escape specchars in src with escchar and copy to dst. ;  ; char * Form (const char *fmt,...);  Formats a string in a circular formatting buffer. ;  ; UInt_t Hash (const char *s);  Return a case-sensitive hash value (endian independent). ;  ; UInt_t Hash (const TString &s);  ; UInt_t Hash (const TString *s);  ; Bool_t operator!= (const char *s1, const TString &s2);  ; Bool_t operator!= (const char *s1, const TSubString &s2);  ; Bool_t operator!= (const TString &s1, const char *s2);  ; Bool_t operator!= (const TString &s1, const TString &s2);  ; Bool_t operator!= (const TString &s1, const TSubString &s2);  ; Bool_t operator!= (const TSubString &s1, const char *s2);  ; Bool_t operator!= (const TSubString &s1, const TString &s2);  ; Bool_t operator!= (const TSubString &s1, const TSubString &s2);  ; TString operator+ (char c, const TString &s);  Add string to char. ;  ; TString operator+ (const char *cs, const TString &s);  Use the special concatenation constructor. ;  ; TString operator+ (const TString &s, char c);  Add char to string. ;  ; TString operator+ (const TString &s, const char *cs);  Use the special concatenation constructor. ;  ; TString operator+ (const TString &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8h.html:1223,hash,hash,1223,doc/master/TString_8h.html,https://root.cern,https://root.cern/doc/master/TString_8h.html,1,['hash'],['hash']
Security,"h""; 18 ; 19#include <mutex>; 20#include <map>; 21#include <string>; 22#include <memory>; 23#include <queue>; 24#include <thread>; 25#include <vector>; 26 ; 27class THttpEngine;; 28class THttpTimer;; 29class TRootSniffer;; 30 ; 31class THttpServer : public TNamed {; 32 ; 33protected:; 34 TList fEngines; ///<! engines which runs http server; 35 std::unique_ptr<THttpTimer> fTimer; ///<! timer used to access main thread; 36 std::unique_ptr<TRootSniffer> fSniffer; ///<! sniffer provides access to ROOT objects hierarchy; 37 Bool_t fTerminated{kFALSE}; ///<! termination flag, disables all requests processing; 38 Long_t fMainThrdId{0}; ///<! id of the thread for processing requests; 39 Long_t fProcessingThrdId{0}; ///<! id of the thread where events are recently processing; 40 Bool_t fOwnThread{kFALSE}; ///<! true when specialized thread allocated for processing requests; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8h_source.html:1142,access,access,1142,doc/master/THttpServer_8h_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html,2,['access'],['access']
Security,"h()));; 1079 ; 1080 strKey.Strip(TString::kBoth, ' ');; 1081 strValue.Strip(TString::kBoth, ' ');; 1082 ; 1083 currentBlock.insert(std::make_pair(strKey, strValue));; 1084 }; 1085 }; 1086 return blockKeyValues;; 1087}; 1088 ; 1089////////////////////////////////////////////////////////////////////////////////; 1090/// What kind of analysis type can handle the CNN; 1091Bool_t MethodDL::HasAnalysisType(Types::EAnalysisType type, UInt_t numberClasses, UInt_t /*numberTargets*/); 1092{; 1093 if (type == Types::kClassification && numberClasses == 2) return kTRUE;; 1094 if (type == Types::kMulticlass) return kTRUE;; 1095 if (type == Types::kRegression) return kTRUE;; 1096 ; 1097 return kFALSE;; 1098}; 1099 ; 1100////////////////////////////////////////////////////////////////////////////////; 1101/// Validation of the ValidationSize option. Allowed formats are 20%, 0.2 and; 1102/// 100 etc.; 1103/// - 20% and 0.2 selects 20% of the training set as validation data.; 1104/// - 100 selects 100 events as the validation data.; 1105///; 1106/// @return number of samples in validation set; 1107///; 1108UInt_t TMVA::MethodDL::GetNumValidationSamples(); 1109{; 1110 Int_t nValidationSamples = 0;; 1111 UInt_t trainingSetSize = GetEventCollection(Types::kTraining).size();; 1112 ; 1113 // Parsing + Validation; 1114 // --------------------; 1115 if (fNumValidationString.EndsWith(""%"")) {; 1116 // Relative spec. format 20%; 1117 TString intValStr = TString(fNumValidationString.Strip(TString::kTrailing, '%'));; 1118 ; 1119 if (intValStr.IsFloat()) {; 1120 Double_t valSizeAsDouble = fNumValidationString.Atof() / 100.0;; 1121 nValidationSamples = GetEventCollection(Types::kTraining).size() * valSizeAsDouble;; 1122 } else {; 1123 Log() << kFATAL << ""Cannot parse number \"""" << fNumValidationString; 1124 << ""\"". Expected string like \""20%\"" or \""20.0%\""."" << Endl;; 1125 }; 1126 } else if (fNumValidationString.IsFloat()) {; 1127 Double_t valSizeAsDouble = fNumValidationString.Atof();; 1128 ; 112",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:42230,validat,validation,42230,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['validat'],['validation']
Security,"h. Constructor & Destructor Documentation. ◆ TFile() [1/3]. TFile::TFile ; (; const TFile & ; ). privatedelete . ◆ TFile() [2/3]. TFile::TFile ; (; ). File default Constructor. ; Definition at line 201 of file TFile.cxx. ◆ TFile() [3/3]. TFile::TFile ; (; const char * ; fname1, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault . ). Opens or creates a local ROOT file. ; Parameters. [in]fname1The name of the file ; [in]optionSpecifies the mode in which the file is opened ; [in]ftitleThe title of the file ; [in]compressSpecifies the compression algorithm and level. It is recommended to specify fname1 as ""<file>.root"". The suffix "".root"" will be used by object browsers to automatically identify the file as a ROOT file. If the constructor fails in any way IsZombie() will return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that will take care of opening the files using the correct remote file access plugin. Option Description . NEW or CREATE Create a new file and open it for writing, if the file already exists the file is not opened. . RECREATE Create a new file, if the file already exists it will be overwritten. . UPDATE Open an existing file for writing. If no file exists, it is created. . READ Open an existing file for reading (default). . NET Used by derived remote file access classes, not a user callable option. . WEB Used by derived remote http access class, not a user callable option. . READ_WITHOUT_GLOBALREGISTRATION Used by TTreeProcessorMT, not a user callable option. . If option = """" (default), READ is assumed. The file can be specified as a URL of the form: file:///user/rdm/bla.root or file:/user/rdm/bla.root; The file can also be a member of an archive, in which case it is specified as: multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip archive or membe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:48054,access,access,48054,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['access'],['access']
Security,"h1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionAppli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:153536,validat,validation,153536,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['validat'],['validation']
Security,"h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfDataMembers::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a data member just by name or create it if its not already...Definition TListOfDataMembers.cxx:182; TListOfDataMembers::FindTDictionary * Find(DeclId_t id) constReturn (after creating it if necessary) the TDataMember describing the data member corresponding to t...Definition TListOfDataMembers.cxx:205; TListOfDataMembers::GetClassTClass * GetClass() constDefinition TListOfDataMembers.h:90; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfEnums::FindTEnum * Find(DeclId_t id) constReturn the TEnum corresponding to the Decl 'id' or NULL if it does not exist.Definition TListOfEnums.cxx:179; TListOfEnums::GetTEnum * Get(DeclId_t id, const char *name)Return (after creating it if necessary) the TEnum describing the enum corresponding to the Decl 'id'.Definition TListOfEnums.cxx:205; TListOfEnums::GetClassTClass * GetClass() constDefinition TListOfEnums.h:62; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::GetTFunctionTemplate * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctionTemplates.cxx:253; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:471124,access,access,471124,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['access'],['access']
Security,"h:273; TIter::NextTObject * Next()Definition TCollection.h:251; TIter::Resetvoid Reset()Definition TCollection.h:254; TIter::operator++TIter & operator++()Definition TCollection.h:255; TIter::TIterTIter(TIterator *it)Definition TCollection.h:246; TIter::operator=TIter & operator=(const TIter &rhs)Assigning an TIter to another.Definition TCollection.cxx:789; TIter::TIterTIter(const TCollection *col, Bool_t dir=kIterForward)Definition TCollection.h:244; TIter::fIteratorTIterator * fIteratorDefinition TCollection.h:238; TIteratorIterator abstract base class.Definition TIterator.h:30; TIterator::Resetvirtual void Reset()=0; TIterator::Nextvirtual TObject * Next()=0; TIterator::GetOptionvirtual Option_t * GetOption() constDefinition TIterator.h:40; TIterator::GetCollectionvirtual const TCollection * GetCollection() const =0; TObjectTableThis class registers all instances of TObject and its derived classes in a hash table.Definition TObjectTable.h:35; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TPRegexpDefinition TPRegexp.h:36; TStringBasic string class.Definition TString.h:139; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; ROOT::Internal::ContaineeInheritsFrombool ContaineeInheritsFrom(TClass *cl, TClass *base)Return true if 'cl' inherits from 'base'.Definition TCollection.cxx:831; ROOT::Internal::EmptyCollectionconst TCollection & EmptyCollection()Return an empty collection for use with nullptr TRangeCast.Definition TCollection.cxx:822; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Drawth1 Draw(). corecontincTCollection.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:08 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:26735,hash,hash,26735,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['hash'],['hash']
Security,"h:296; TStyle::SetHistLineStylevoid SetHistLineStyle(Style_t styl=0)Definition TStyle.h:382; TStyle::GetHistFillStyleStyle_t GetHistFillStyle() constDefinition TStyle.h:234; TStyle::GetHistFillColorColor_t GetHistFillColor() constDefinition TStyle.h:232; TStyle::SetHistLineColorvoid SetHistLineColor(Color_t color=1)Definition TStyle.h:380; TStyle::GetHistLineStyleStyle_t GetHistLineStyle() constDefinition TStyle.h:235; TStyle::SetHistFillStylevoid SetHistFillStyle(Style_t styl=0)Definition TStyle.h:381; TStyle::GetHistLineWidthWidth_t GetHistLineWidth() constDefinition TStyle.h:236; TStyle::SetHistLineWidthvoid SetHistLineWidth(Width_t width=1)Definition TStyle.h:383; TSubStringA zero length substring is legal.Definition TString.h:85; TSubString::StringTString & String()Definition TString.h:124; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeCacheUnzipA TTreeCache which exploits parallelized decompression of its own content.Definition TTreeCacheUnzip.h:35; TTreeCacheUnzip::IsParallelUnzipstatic bool IsParallelUnzip()Static function that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:428739,access,access,428739,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['access'],['access']
Security,"h::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. PositionVector2D<CoordSystem, Tag>& SetX(ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); It is physically meaningless to speak of the unit vector corresponding; to a point.; ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. PositionVector2D<CoordSystem, Tag>& SetY(ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:8851,access,access,8851,root/html526/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"h::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const Scalar[] src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:11728,access,access,11728,root/html602/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,2,['access'],['access']
Security,"h::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const; ----- Other fundamental properties -----. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. DisplacementVector2D Unit() const. return unit vector parallel to this. DisplacementVector2D<CoordSystem, Tag>& SetX(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. Displa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:9786,access,access,9786,root/html526/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"h::SMatrix< T, D1, D2, R >::operator> ; (; const SMatrix< T, D1, D2, R2 > & ; rhs); const. element wise comparison ; Definition at line 357 of file SMatrix.icc. ◆ operator>() [3/3]. template<class T , unsigned int D1, unsigned int D2, class R > . bool ROOT::Math::SMatrix< T, D1, D2, R >::operator> ; (; const T & ; rhs); const. element wise comparison ; Definition at line 347 of file SMatrix.icc. ◆ operator[]() [1/2]. template<class T , unsigned int D1, unsigned int D2 = D1, class R = MatRepStd<T, D1, D2>> . SMatrixRow ROOT::Math::SMatrix< T, D1, D2, R >::operator[] ; (; unsigned int ; i). inline . read/write access to matrix element with indices starting from 0 : m[i][j] ; Definition at line 402 of file SMatrix.h. ◆ operator[]() [2/2]. template<class T , unsigned int D1, unsigned int D2 = D1, class R = MatRepStd<T, D1, D2>> . SMatrixRow_const ROOT::Math::SMatrix< T, D1, D2, R >::operator[] ; (; unsigned int ; i); const. inline . read only access to matrix element, with indices starting from 0 : m[i][j] ; Definition at line 398 of file SMatrix.h. ◆ Place_at() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . template<class A , unsigned int D3, unsigned int D4, class R2 > . SMatrix< T, D1, D2, R > & ROOT::Math::SMatrix< T, D1, D2, R >::Place_at ; (; const Expr< A, T, D3, D4, R2 > & ; rhs, . unsigned int ; row, . unsigned int ; col . ). place a matrix expression in this matrix ; Definition at line 564 of file SMatrix.icc. ◆ Place_at() [2/2]. template<class T , unsigned int D1, unsigned int D2, class R > . template<unsigned int D3, unsigned int D4, class R2 > . SMatrix< T, D1, D2, R > & ROOT::Math::SMatrix< T, D1, D2, R >::Place_at ; (; const SMatrix< T, D3, D4, R2 > & ; rhs, . unsigned int ; row, . unsigned int ; col . ). place a matrix in this matrix ; Definition at line 552 of file SMatrix.icc. ◆ Place_in_col() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . template<unsigned int D> . SMatrix< T, D1, D2, R > & ROOT::Math::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:35312,access,access,35312,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,1,['access'],['access']
Security,"h; TPaveText.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom3.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TSystem.h; TView.h; TVirtualGeoPainter.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::GetDzDouble_t GetDz() constDefinition TGeoArb8.h:66; TGeoArb8::SetVertexvirtual void SetVertex(Int_t vnum, Double_t x, Double_t y); TGeoArb8::GetVerticesDouble_t * GetVertices()Definition TGeoArb8.h:71; TGeoAtt::SetVisRaytracevoid SetVisRaytrace(Bool_t flag=kTRUE)Definition TGeoAtt.h:66; TGeoBBoxDefinition TGeoBBox.h:17; TGeoBBox::GetDZvirtual Double_t GetDZ() constDefinition TGeoBBox.h:81; TGeoCompositeShapeComposite shapes are Boolean combinations of two or more shape components.Definition TGeoCompositeShape.h:27; TGeoConeSegDefinition TGeoCone.h:99; TGeoConeSeg::GetPhi1Double_t GetPhi1() constDefinition TGeoCone.h:166; TGeoConeSeg::GetPhi2Double_t GetPhi2() constDefinitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geodemo_8C.html:65775,access,access,65775,doc/master/geodemo_8C.html,https://root.cern,https://root.cern/doc/master/geodemo_8C.html,1,['access'],['access']
Security,"h;  Git branch. ;  ; TString fGitCommit;  Git commit SHA1 of built. ;  ; TString fGitDate;  Date and time when make was run. ;  ; TListOfFunctions * fGlobalFunctions;  List of global functions. ;  ; TListOfDataMembers * fGlobals;  List of global variables. ;  ; TInterpreter * fInterpreter;  Command interpreter. ;  ; Bool_t fInterrupt;  True if macro should be interrupted. ;  ; Bool_t fIsWebDisplay;  True if session uses web widgets. ;  ; Bool_t fIsWebDisplayBatch;  True if web widgets are not displayed. ;  ; TSeqCollection * fMappedFiles;  List of memory mapped files. ;  ; TSeqCollection * fMessageHandlers;  List of message handlers. ;  ; Bool_t fMustClean;  True if object destructor scans canvases. ;  ; TPluginManager * fPluginManager;  Keeps track of plugin library handlers. ;  ; const TObject * fPrimitive;  Currently selected primitive. ;  ; TSeqCollection * fProofs;  List of proof sessions. ;  ; TFolder * fRootFolder;  top level folder //root ;  ; TSeqCollection * fSecContexts;  List of security contexts (TSecContext) ;  ; TVirtualPad * fSelectPad;  Currently selected pad. ;  ; TSeqCollection * fSockets;  List of network sockets. ;  ; TSeqCollection * fSpecials;  List of special objects. ;  ; TSeqCollection * fStreamerInfo;  List of active StreamerInfo classes. ;  ; TSeqCollection * fStyles;  List of styles. ;  ; TSeqCollection * fTasks;  List of tasks. ;  ; Int_t fTimer;  Timer flag. ;  ; TCollection * fTypes;  List of data types definition. ;  ; TProcessUUID * fUUIDs;  Pointer to TProcessID managing TUUIDs. ;  ; TString fVersion;  ROOT version (from CMZ VERSQQ) ex 0.05/01. ;  ; Int_t fVersionCode;  ROOT version code as used in RVersion.h. ;  ; Int_t fVersionDate;  Date of ROOT version (ex 951226) ;  ; Int_t fVersionInt;  ROOT version in integer format (501) ;  ; Int_t fVersionTime;  Time of ROOT version (ex 1152) ;  ; TString fWebDisplay;  If not empty it defines where web graphics should be rendered (cef, qt5, browser...) ;  ;  Protected Attributes inherited ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:36700,secur,security,36700,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['secur'],['security']
Security,"h;; 9957 encoding = ""gzip"";; 9958 ; 9959#if defined(USE_ZLIB); 9960 /* File is already compressed. No ""on the fly"" compression. */; 9961 allow_on_the_fly_compression = 0;; 9962#endif; 9963 } else if ((conn->accept_gzip) && (range_hdr == NULL); 9964 && (filep->stat.size >= MG_FILE_COMPRESSION_SIZE_LIMIT)) {; 9965 struct mg_file_stat file_stat;; 9966 ; 9967 mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), ""%s.gz"", path);; 9968 ; 9969 if (!truncated && mg_stat(conn, gz_path, &file_stat); 9970 && !file_stat.is_directory) {; 9971 file_stat.is_gzipped = 1;; 9972 filep->stat = file_stat;; 9973 cl = (int64_t)filep->stat.size;; 9974 path = gz_path;; 9975 encoding = ""gzip"";; 9976 ; 9977#if defined(USE_ZLIB); 9978 /* File is already compressed. No ""on the fly"" compression. */; 9979 allow_on_the_fly_compression = 0;; 9980#endif; 9981 }; 9982 }; 9983 ; 9984 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 9985 mg_send_http_error(conn,; 9986 500,; 9987 ""Error: Cannot open file\nfopen(%s): %s"",; 9988 path,; 9989 strerror(ERRNO));; 9990 return;; 9991 }; 9992 ; 9993 fclose_on_exec(&filep->access, conn);; 9994 ; 9995 /* If ""Range"" request was made: parse header, send only selected part; 9996 * of the file. */; 9997 r1 = r2 = 0;; 9998 if ((range_hdr != NULL); 9999 && ((n = parse_range_header(range_hdr, &r1, &r2)) > 0) && (r1 >= 0); 10000 && (r2 >= 0)) {; 10001 /* actually, range requests don't play well with a pre-gzipped; 10002 * file (since the range is specified in the uncompressed space) */; 10003 if (filep->stat.is_gzipped) {; 10004 mg_send_http_error(; 10005 conn,; 10006 416, /* 416 = Range Not Satisfiable */; 10007 ""%s"",; 10008 ""Error: Range requests in gzipped files are not supported"");; 10009 (void)mg_fclose(; 10010 &filep->access); /* ignore error on read only file */; 10011 return;; 10012 }; 10013 conn->status_code = 206;; 10014 cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);; 10015 mg_snprintf(conn,; 10016 NULL, /* range buffer is big enough */;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:286387,access,access,286387,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"h;; 9958 encoding = ""gzip"";; 9959 ; 9960#if defined(USE_ZLIB); 9961 /* File is already compressed. No ""on the fly"" compression. */; 9962 allow_on_the_fly_compression = 0;; 9963#endif; 9964 } else if ((conn->accept_gzip) && (range_hdr == NULL); 9965 && (filep->stat.size >= MG_FILE_COMPRESSION_SIZE_LIMIT)) {; 9966 struct mg_file_stat file_stat;; 9967 ; 9968 mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), ""%s.gz"", path);; 9969 ; 9970 if (!truncated && mg_stat(conn, gz_path, &file_stat); 9971 && !file_stat.is_directory) {; 9972 file_stat.is_gzipped = 1;; 9973 filep->stat = file_stat;; 9974 cl = (int64_t)filep->stat.size;; 9975 path = gz_path;; 9976 encoding = ""gzip"";; 9977 ; 9978#if defined(USE_ZLIB); 9979 /* File is already compressed. No ""on the fly"" compression. */; 9980 allow_on_the_fly_compression = 0;; 9981#endif; 9982 }; 9983 }; 9984 ; 9985 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 9986 mg_send_http_error(conn,; 9987 500,; 9988 ""Error: Cannot open file\nfopen(%s): %s"",; 9989 path,; 9990 strerror(ERRNO));; 9991 return;; 9992 }; 9993 ; 9994 fclose_on_exec(&filep->access, conn);; 9995 ; 9996 /* If ""Range"" request was made: parse header, send only selected part; 9997 * of the file. */; 9998 r1 = r2 = 0;; 9999 if ((range_hdr != NULL); 10000 && ((n = parse_range_header(range_hdr, &r1, &r2)) > 0) && (r1 >= 0); 10001 && (r2 >= 0)) {; 10002 /* actually, range requests don't play well with a pre-gzipped; 10003 * file (since the range is specified in the uncompressed space) */; 10004 if (filep->stat.is_gzipped) {; 10005 mg_send_http_error(; 10006 conn,; 10007 416, /* 416 = Range Not Satisfiable */; 10008 ""%s"",; 10009 ""Error: Range requests in gzipped files are not supported"");; 10010 (void)mg_fclose(; 10011 &filep->access); /* ignore error on read only file */; 10012 return;; 10013 }; 10014 conn->status_code = 206;; 10015 cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);; 10016 mg_snprintf(conn,; 10017 NULL, /* range buffer is big enough */",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:286419,access,access,286419,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"hVars = NULL); Get a clone of the markov chain on which this interval is based; as a RooDataHist. You own the returned RooDataHist*. { return fChain->GetAsDataHist(whichVars); }. THnSparse* GetChainAsSparseHist(RooArgSet* whichVars = NULL); Get a clone of the markov chain on which this interval is based; as a THnSparse. You own the returned THnSparse*. { return fChain->GetAsSparseHist(whichVars); }. RooRealVar* GetNLLVar() const; Get a clone of the NLL variable from the markov chain. { return fChain->GetNLLVar(); }. RooRealVar* GetWeightVar() const; Get a clone of the weight variable from the markov chain. { return fChain->GetWeightVar(); }. void SetEpsilon(Double_t epsilon); set the acceptable level or error for Keys interval determination. void SetIntervalType(RooStats::MCMCInterval::IntervalType intervalType); Set the type of interval to find. This will only have an effect for; 1-D intervals. If is more than 1 parameter of interest, then a; ""shortest"" interval will always be used, since it generalizes directly; to N dimensions. { fIntervalType = intervalType; }. enum IntervalType GetIntervalType(); Return the type of this interval. { return fIntervalType; }. void SetLeftSideTailFraction(Double_t a); set the left-side tail fraction for a tail-fraction interval. { fLeftSideTF = a; }. void SetDelta(Double_t delta); kbelasco: The inner-workings of the class really should not be exposed; like this in a comment, but it seems to be the only way to give; the user any control over this process, if he desires it. Set the fraction delta such that; topCutoff (a) is considered == bottomCutoff (b) iff; (TMath::Abs(a - b) < TMath::Abs(fDelta * (a + b)/2)); when determining the confidence interval by Keys. » Last changed: root/roostats:$Id: MCMCInterval.h 34109 2010-06-24 15:00:16Z moneta $ » Last generated: 2010-09-27 22:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__MCMCInterval.html:18383,expose,exposed,18383,root/html528/RooStats__MCMCInterval.html,https://root.cern,https://root.cern/root/html528/RooStats__MCMCInterval.html,1,['expose'],['exposed']
Security,"hVars = NULL); Get a clone of the markov chain on which this interval is based; as a RooDataHist. You own the returned RooDataHist*. { return fChain->GetAsDataHist(whichVars); }. THnSparse* GetChainAsSparseHist(RooArgSet* whichVars = NULL); Get a clone of the markov chain on which this interval is based; as a THnSparse. You own the returned THnSparse*. { return fChain->GetAsSparseHist(whichVars); }. RooRealVar* GetNLLVar() const; Get a clone of the NLL variable from the markov chain. { return fChain->GetNLLVar(); }. RooRealVar* GetWeightVar() const; Get a clone of the weight variable from the markov chain. { return fChain->GetWeightVar(); }. void SetEpsilon(Double_t epsilon); set the acceptable level or error for Keys interval determination. void SetIntervalType(RooStats::MCMCInterval::IntervalType intervalType); Set the type of interval to find. This will only have an effect for; 1-D intervals. If is more than 1 parameter of interest, then a; ""shortest"" interval will always be used, since it generalizes directly; to N dimensions. { fIntervalType = intervalType; }. enum IntervalType GetIntervalType(); Return the type of this interval. { return fIntervalType; }. void SetLeftSideTailFraction(Double_t a); set the left-side tail fraction for a tail-fraction interval. { fLeftSideTF = a; }. void SetDelta(Double_t delta); kbelasco: The inner-workings of the class really should not be exposed; like this in a comment, but it seems to be the only way to give; the user any control over this process, if he desires it. Set the fraction delta such that; topCutoff (a) is considered == bottomCutoff (b) iff; (TMath::Abs(a - b) < TMath::Abs(fDelta * (a + b)/2)); when determining the confidence interval by Keys. » Last changed: root/roostats:$Id: MCMCInterval.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__MCMCInterval.html:18392,expose,exposed,18392,root/html530/RooStats__MCMCInterval.html,https://root.cern,https://root.cern/root/html530/RooStats__MCMCInterval.html,1,['expose'],['exposed']
Security,"hVars = NULL); Get a clone of the markov chain on which this interval is based; as a RooDataHist. You own the returned RooDataHist*. { return fChain->GetAsDataHist(whichVars); }. THnSparse* GetChainAsSparseHist(RooArgSet* whichVars = NULL); Get a clone of the markov chain on which this interval is based; as a THnSparse. You own the returned THnSparse*. { return fChain->GetAsSparseHist(whichVars); }. RooRealVar* GetNLLVar() const; Get a clone of the NLL variable from the markov chain. { return fChain->GetNLLVar(); }. RooRealVar* GetWeightVar() const; Get a clone of the weight variable from the markov chain. { return fChain->GetWeightVar(); }. void SetEpsilon(Double_t epsilon); set the acceptable level or error for Keys interval determination. void SetIntervalType(RooStats::MCMCInterval::IntervalType intervalType); Set the type of interval to find. This will only have an effect for; 1-D intervals. If is more than 1 parameter of interest, then a; ""shortest"" interval will always be used, since it generalizes directly; to N dimensions. { fIntervalType = intervalType; }. enum IntervalType GetIntervalType(); Return the type of this interval. { return fIntervalType; }. void SetLeftSideTailFraction(Double_t a); set the left-side tail fraction for a tail-fraction interval. { fLeftSideTF = a; }. void SetDelta(Double_t delta); kbelasco: The inner-workings of the class really should not be exposed; like this in a comment, but it seems to be the only way to give; the user any control over this process, if he desires it. Set the fraction delta such that; topCutoff (a) is considered == bottomCutoff (b) iff; (TMath::Abs(a - b) < TMath::Abs(fDelta * (a + b)/2)); when determining the confidence interval by Keys. » Last changed: root/roostats:$Id: MCMCInterval.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__MCMCInterval.html:18392,expose,exposed,18392,root/html532/RooStats__MCMCInterval.html,https://root.cern,https://root.cern/root/html532/RooStats__MCMCInterval.html,1,['expose'],['exposed']
Security,"ha);  Copy ctor ... ;  ; virtual ~THostAuth ();  The dtor. ;  ; void Activate ();  ; void AddFirst (Int_t level, const char *details=nullptr);  Add new method in first position If already in the list, set as first method 'level' with authentication 'details'. ;  ; void AddMethod (Int_t level, const char *details=nullptr);  Add method to the list. ;  ; void AsString (TString &out) const;  Return a static string with all info in a serialized form. ;  ; void CountFailure (Int_t level);  Count failures for 'method'. ;  ; void CountSuccess (Int_t level);  Count successes for 'method'. ;  ; TRootSecContext * CreateSecContext (const char *user, const char *host, Int_t meth, Int_t offset, const char *details, const char *token, TDatime expdate=kROOTTZERO, void *ctx=nullptr, Int_t key=-1);  Create a Security context and add it to local list Return pointer to it to be stored in TAuthenticate. ;  ; void DeActivate ();  ; TList * Established () const;  ; const char * GetDetails (Int_t level);  Return authentication details for specified level or """" if the specified level does not exist for this host. ;  ; const char * GetDetailsByIdx (Int_t idx) const;  ; Int_t GetFailure (Int_t idx) const;  ; const char * GetHost () const;  ; Int_t GetMethod (Int_t idx) const;  ; Int_t GetServer () const;  ; Int_t GetSuccess (Int_t idx) const;  ; const char * GetUser () const;  ; Bool_t HasMethod (Int_t level, Int_t *pos=nullptr);  Return kTRUE if method 'level' is in the list. ;  ; TClass * IsA () const override;  ; Bool_t IsActive () const;  ; Int_t NumMethods () const;  ; void Print (Option_t *option="""") const override;  Print object content. ;  ; void PrintEstablished () const;  Print info about established authentication vis-a-vis of this Host. ;  ; void RemoveMethod (Int_t level);  Remove method 'meth' from the list, if there ... ;  ; void ReOrder (Int_t nmet, Int_t *fmet);  Reorder nmet methods according fmet[nmet]. ;  ; void Reset ();  Remove all methods, leaving Active status and list",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHostAuth.html:2159,authenticat,authentication,2159,doc/master/classTHostAuth.html,https://root.cern,https://root.cern/doc/master/classTHostAuth.html,1,['authenticat'],['authentication']
Security,"har *o, Long_t t, const char *d);  ; Int_t Compare (const TObject *o) const override;  Compare abstract method. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classfileDesc.html:1352,hash,hash,1352,doc/master/classfileDesc.html,https://root.cern,https://root.cern/doc/master/classfileDesc.html,1,['hash'],['hash']
Security,"har *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::GetVolumesvirtual TList * GetVolumes(Option_t *) constDefinition TSystem.h:455; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::OpenConnectionvirtual int OpenConnection(const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"")Open a connection to another host.Definition TSystem.cxx:2336; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::IgnoreSignalvirtual void IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE)If ignore is true ignore the specified signal, else restore previous behaviour.Definition TSystem.cxx:593; TSystem::Runvirtual void Run()System event loop.Definition TSystem.cxx:343; TSystem::GetSockOptvirtual int GetSockOpt(int sock, int kind, int *val)Get socket option.Definition TSystem.cxx:2445; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:50671,access,access,50671,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,2,['access'],['access']
Security,"har * ; dsName . ). protected . Checks if the indicated dataset exits. ; Definition at line 1576 of file TDataSetManagerFile.cxx. ◆ ExistsDataSet() [2/2]. Bool_t TDataSetManagerFile::ExistsDataSet ; (; const char * ; uri). overridevirtual . Checks if the indicated dataset exits. ; Reimplemented from TDataSetManager.; Definition at line 1947 of file TDataSetManagerFile.cxx. ◆ FillLsDataSet(). Int_t TDataSetManagerFile::FillLsDataSet ; (; const char * ; group, . const char * ; user, . const char * ; dsname, . TList * ; out, . UInt_t ; option . ). protected . Check for the 'ls.txt' for 'group' and 'user' and fill the path for the ls file in 'out'. ; If 'dsname' is defined, open the file and extract the relevant line. Return 0 on success, -1 on failure ; Definition at line 943 of file TDataSetManagerFile.cxx. ◆ GetDataSet() [1/2]. TFileCollection * TDataSetManagerFile::GetDataSet ; (; const char * ; group, . const char * ; user, . const char * ; dsName, . UInt_t ; option = 0, . TMD5 ** ; checksum = 0 . ). Returns the dataset <dsName> of user <user> in group <group>. ; If checksum is non-zero, it will contain the pointer to a TMD5 sum object with the checksum of the file, has to be deleted by the user. If option has the bi kReadShort set, the shortobject is read, that does not contain the list of files. This is much faster. ; Definition at line 1015 of file TDataSetManagerFile.cxx. ◆ GetDataSet() [2/2]. TFileCollection * TDataSetManagerFile::GetDataSet ; (; const char * ; uri, . const char * ; srv = 0 . ). overridevirtual . Utility function used in various methods for user dataset upload. ; Reimplemented from TDataSetManager.; Definition at line 1874 of file TDataSetManagerFile.cxx. ◆ GetDataSetPath() [1/2]. const char * TDataSetManagerFile::GetDataSetPath ; (; const char * ; group, . const char * ; user, . const char * ; dsName . ). protected . ◆ GetDataSetPath() [2/2]. const char * TDataSetManagerFile::GetDataSetPath ; (; const char * ; group, . const char * ; user, . c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:25399,checksum,checksum,25399,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['checksum'],['checksum']
Security,"har * ; src, . char * ; dst, . int ; dstlen, . char * ; specchars, . char ; escchar . ). Escape specchars in src with escchar and copy to dst. ; Definition at line 2593 of file TString.cxx. ◆ Form(). char * Form ; (; const char * ; fmt, .  ; ... . ). Formats a string in a circular formatting buffer. ; Removes the need to create and delete short lived strings. Don't pass Form() pointers from user code down to ROOT functions as the circular buffer may be overwritten downstream. Use Form() results immediately or use TString::Format() instead. ; Definition at line 2489 of file TString.cxx. ◆ Format(). static char * Format ; (; const char * ; format, . va_list ; ap . ). static . Format a string in a circular formatting buffer (using a printf style format descriptor). ; Definition at line 2442 of file TString.cxx. ◆ Hash(). UInt_t Hash ; (; const char * ; str). Return a case-sensitive hash value (endian independent). ; Definition at line 576 of file TString.cxx. ◆ Mash(). static void Mash ; (; UInt_t & ; hash, . UInt_t ; chars . ). inlinestatic . Utility used by Hash(). ; Definition at line 566 of file TString.cxx. ◆ MemIsEqual(). static int MemIsEqual ; (; const char * ; p, . const char * ; q, . Ssiz_t ; n . ). static . Returns false if strings are not equal. ; Definition at line 885 of file TString.cxx. ◆ operator+() [1/5]. TString operator+ ; (; char ; c, . const TString & ; s . ). Add string to char. ; Definition at line 1557 of file TString.cxx. ◆ operator+() [2/5]. TString operator+ ; (; const char * ; cs, . const TString & ; s . ). Use the special concatenation constructor. ; Definition at line 1533 of file TString.cxx. ◆ operator+() [3/5]. TString operator+ ; (; const TString & ; s, . char ; c . ). Add char to string. ; Definition at line 1549 of file TString.cxx. ◆ operator+() [4/5]. TString operator+ ; (; const TString & ; s, . const char * ; cs . ). Use the special concatenation constructor. ; Definition at line 1525 of file TString.cxx. ◆ operator+() [5/5]. TSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx.html:5209,hash,hash,5209,doc/master/TString_8cxx.html,https://root.cern,https://root.cern/doc/master/TString_8cxx.html,1,['hash'],['hash']
Security,"har * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; TFileInfo & operator= (const TFileInfo &)=delete;  ; void ParseInput (const char *in);  Parse the input line to extract init information from 'in'; the input string is tokenized on ' '; the tokens can be prefixed by the following keys: ;  . Private Attributes; TUrl * fCurrentUrl;  ; Int_t fIndex;  ; TMD5 * fMD5;  ; TList * fMetaDataList;  ; Long64_t fSize;  ; TList * fUrlList;  current URL to access the file, points to URL ;  ; TUUID * fUUID;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TFileInfo.h>. Inheritance diagram for TFileInfo:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EStatusBits. enum TFileInfo::EStatusBits. EnumeratorkStaged ; kCorrupted ; kSortWithIndex . Definition at line 57 of file TFileInfo.h. Constructor & Destructor Documentation. ◆ TFileInfo() [1/2]. TFileInfo::TFileInfo ; (; const char * ; url = nullptr, . Long64_t ; size = -1, . const char * ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileInfo.html:13268,access,access,13268,doc/master/classTFileInfo.html,https://root.cern,https://root.cern/doc/master/classTFileInfo.html,1,['access'],['access']
Security,"har* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TS3HTTPRequest&operator=(const TS3HTTPRequest&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TS3HTTPRequest&SetAccessKey(const TString& accessKey); TS3HTTPRequest&SetAuthKeys(const TString& accessKey, const TString& secretKey); TS3HTTPRequest&SetAuthType(TS3HTTPRequest::EAuthType authType); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); TS3HTTPRequest&SetBucket(const TString& bucket); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); TS3HTTPRequest&SetHost(const TString& host); TS3HTTPRequest&SetObjectKey(const TString& objectKey); static voidTObject::SetObjectStat(Bool_t stat); TS3HTTPRequest&SetSecretKey(const TString& secretKey); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TS3HTTPRequest(); TS3HTTPRequest(const TS3HTTPRequest& m); TS3HTTPRequest(TS3HTTPRequest::EHTTPVerb httpVerb, const TSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3HTTPRequest.html:5004,access,accessKey,5004,root/html602/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html602/TS3HTTPRequest.html,2,['access'],['accessKey']
Security,"har* axisSteering = 0) const. TH2D * CreateErrorMatrixHistogram(const char* histogramName, Bool_t originalAxisBinning, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const. TH2D * CreateHistogramOfMigrations(const TUnfoldBinning* xAxis, const TUnfoldBinning* yAxis, const char* histogramName, Bool_t originalXAxisBinning = kFALSE, Bool_t originalYAxisBinning = kFALSE, const char* histogramTitle = 0); Calculate global bin number . Int_t GetGlobalBinNumber(Double_t x) const. Int_t GetGlobalBinNumber(Double_t x, Double_t y) const. Int_t GetStartBin(void); { return fFirstBin; }. Int_t GetEndBin(void); { return fLastBin; }. void GetBinUnderflowOverflowStatus(Int_t iBin, Int_t* uStatus, Int_t* oStatus) const. void GetBinNeighbours(Int_t globalBin, Int_t axis, Int_t* prev, Double_t* distPrev, Int_t* next, Double_t* distNext) const; access by bin number, given an axis steering . { MAXDIM=32 }. const TUnfoldBinning * GetBinLocation(Int_t binTHxx, const char* axisSteering, Int_t[32] axisBins) const; access distribution properties . Int_t GetDistributionNumberOfBins(void); { return fDistributionSize; }. Int_t GetDistributionDimension(void); { return fAxisList->GetEntriesFast(); }. Double_t GetDistributionAverageBinSize(Int_t axis, Bool_t includeUnderflow, Bool_t includeOverflow) const. TVectorD const * GetDistributionBinning(Int_t axis) const. TString GetDistributionAxisLabel(Int_t axis) const. Double_t GetDistributionBinCenter(Int_t axis, Int_t bin) const. TUnfoldBinning const * ToAxisBins(Int_t globalBin, Int_t* axisBins) const. TString BuildHistogramTitle(const char* histogramName, const char* histogramTitle, const Int_t* axisList) const. Int_t GetTHxxBinning(Int_t maxDim, Int_t* axisBins, Int_t* axisList, const char* axisSteering) const. Int_t GetTHxxBinningSingleNode(Int_t maxDim, Int_t* axisBins, Int_t* axisList, const char* axisSteering) const. const TUnfoldBinning * GetBinLocationRecursive(Int_t& offset, const char* axisSteering, Int_t[3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldBinning.html:17316,access,access,17316,root/html602/TUnfoldBinning.html,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html,2,['access'],['access']
Security,"har* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:23439,access,access,23439,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,12,['access'],['access']
Security,"har* name, const char* title); RooStats::HistFactory::FlexibleInterpVarFlexibleInterpVar(const RooStats::HistFactory::FlexibleInterpVar&, const char*); RooStats::HistFactory::FlexibleInterpVarFlexibleInterpVar(const char* name, const char* title, const RooArgList& _paramList, Double_t nominal, const RooArgList& low, const RooArgList& high); RooStats::HistFactory::FlexibleInterpVarFlexibleInterpVar(const char* name, const char* title, const RooArgList& _paramList, double nominal, vector<double> low, vector<double> high); RooStats::HistFactory::FlexibleInterpVarFlexibleInterpVar(const char* name, const char* title, const RooArgList& _paramList, double nominal, vector<double> low, vector<double> high, vector<int> code); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__FlexibleInterpVar.html:12715,hash,hash,12715,root/html534/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__FlexibleInterpVar.html,3,['hash'],['hash']
Security,"har* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. RooSimWSTool(const RooSimWSTool&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooSimultaneous*executeBuild(const char* simPdfName, RooSimWSTool::ObjBuildConfig& obc, Bool_t verbose = kTRUE); stringmakeSplitName(const RooArgSet& splitCatSet); voidTObject::MakeZombie(); RooSimWSTool::ObjBuildConfig*validateConfig(RooSimWSTool::BuildConfig& bc). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. static Int_tRooPrintable::_nameLength; RooWorkspace*_ws; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimWSTool(RooWorkspace& ws); Constructor of SimWSTool on given workspa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool.html:9961,validat,validateConfig,9961,root/html526/RooSimWSTool.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool.html,1,['validat'],['validateConfig']
Security,"har*) const; unsigned intVariableParameters() const. Data Members; protected:. const ROOT::Minuit2::FCNBase&fFCN; unsigned intfNumCall; ROOT::Minuit2::MnUserParameterStatefState; ROOT::Minuit2::MnStrategyfStrategy; boolfUseGrad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~MnApplication(); { }. FunctionMinimum operator()(unsigned int maxfcn = 0, double tolerance = 0.1). Minimize the function; @param maxfcn : max number of function calls (if = 0) default is used which is set to; 200 + 100 * npar + 5 * npar**2; @param tolerance : value used for terminating iteration procedure.; For example, MIGRAD will stop iterating when edm (expected distance from minimum) will be:; edm < tolerance * 10**-3; Default value of tolerance used is 0.1. const FCNBase& Fcnbase() const; {return fFCN;}. unsigned int NumOfCalls() const; {return fNumCall;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation; via MnUserParameterState; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const char* Name, double val, double err); add free Parameter. void Add(const char* Name, double val, double err, double , double ); add limited Parameter. void Add(const char* , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const char* ); interaction via Name of Parameter. void Release(const char* ). void SetValue(const char* , double ). void SetError(const char* , double ). void SetLimits(const char* , double , double ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Minuit2__MnApplication.html:3429,access,access,3429,root/html528/ROOT__Minuit2__MnApplication.html,https://root.cern,https://root.cern/root/html528/ROOT__Minuit2__MnApplication.html,4,['access'],['access']
Security,"har*) const; unsigned intVariableParameters() const. Data Members; protected:. const ROOT::Minuit2::FCNBase&fFCN; unsigned intfNumCall; ROOT::Minuit2::MnUserParameterStatefState; ROOT::Minuit2::MnStrategyfStrategy; boolfUseGrad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~MnApplication(); { }. FunctionMinimum operator()(unsigned int maxfcn = 0, double tolerance = 0.1). Minimize the function; @param maxfcn : max number of function calls (if = 0) default is used which is set to; 200 + 100 * npar + 5 * npar**2; @param tolerance : value used for terminating iteration procedure.; For example, MIGRAD will stop iterating when edm (expected distance from minimum) will be:; edm < tolerance * 10**-3; Default value of tolerance used is 0.1. const FCNBase& Fcnbase() const; {return fFCN;}. unsigned int NumOfCalls() const; {return fNumCall;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation; via MnUserParameterState; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const char* Name, double val, double err); add free Parameter. void Add(const char* Name, double val, double err, double , double ); add limited Parameter. void Add(const char* , double ); add const Parameter. void Fix(unsigned int); interaction via external number of Parameter. void Release(unsigned int). void SetValue(unsigned int, double). void SetError(unsigned int, double). void SetLimits(unsigned int, double, double). void RemoveLimits(unsigned int). double Value(unsigned int). double Error(unsigned int). void Fix(const char*); interaction via Name of Parameter. void Release(const char*). void SetValue(const char*, double). void SetError(const char*, double). void SetLimits(const char*, double, double). void RemoveLimits(const char*). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__MnApplication.html:3429,access,access,3429,root/html526/ROOT__Minuit2__MnApplication.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__MnApplication.html,1,['access'],['access']
Security,"har_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx). protected:. virtual voidDestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); voidReleaseGLCtxIdentity(). private:. static Bool_tComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); static Bool_tComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); TGLScene&operator=(const TGLScene&); TGLScene(const TGLScene&). Data Members; public:. static TGLLockable::ELockTGLLockable::kDrawLock; static TGLLockable::ELockTGLLockable::kModifyLock; static TGLLockable::ELockTGLLockable::kSelectLock; static TGLLockable::ELockTGLLockable::kUnlocked. protected:. Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; TGLClip*TGLSceneBase::fClipScene clipping-plane.; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*fGLCtxIdentity; Bool_tfInSmartRefresh!; Short_tTGLSceneBase::fLODScene-lod.; Float_tfLastLineWidthScale; Float_tfLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; TGLScene::LogicalShapeMap_tfLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; TGLScene::PhysicalShapeMap_tfPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; TGLScene::LogicalShapeMap_tfSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeSta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLScene.html:6654,access,access,6654,root/html602/TGLScene.html,https://root.cern,https://root.cern/root/html602/TGLScene.html,2,['access'],['access']
Security,"hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTable.html:10323,hash,hash,10323,root/html534/THashTable.html,https://root.cern,https://root.cern/root/html534/THashTable.html,3,['hash'],['hash']
Security,"hash value (endian independent).; 575 ; 576UInt_t Hash(const char *str); 577{; 578 UInt_t len = str ? strlen(str) : 0;; 579 UInt_t hv = len; // Mix in the string length.; 580 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 581 ; 582 if (((ULongptr_t)str)%sizeof(UInt_t) == 0) {; 583 // str is word aligned; 584 const UInt_t *p = (const UInt_t*)str;; 585 ; 586 while (i--) {; 587#ifndef R__BYTESWAP; 588 UInt_t h = *p++;; 589 Mash(hv, SwapInt(h));; 590#else; 591 Mash(hv, *p++); // XOR in the characters.; 592#endif; 593 }; 594 ; 595 // XOR in any remaining characters:; 596 if ((i = len*sizeof(char)%sizeof(UInt_t)) != 0) {; 597 UInt_t h = 0;; 598 const char* c = (const char*)p;; 599 while (i--); 600 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 601 Mash(hv, h);; 602 }; 603 } else {; 604 // str is not word aligned; 605 UInt_t h;; 606 const unsigned char *p = (const unsigned char*)str;; 607 ; 608 while (i--) {; 609 memcpy(&h, p, sizeof(UInt_t));; 610#ifndef R__BYTESWAP; 611 Mash(hv, SwapInt(h));; 612#else; 613 Mash(hv, h);; 614#endif; 615 p += sizeof(UInt_t);; 616 }; 617 ; 618 // XOR in any remaining characters:; 619 if ((i = len*sizeof(char)%sizeof(UInt_t)) != 0) {; 620 h = 0;; 621 const char* c = (const char*)p;; 622 while (i--); 623 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 624 Mash(hv, h);; 625 }; 626 }; 627 return hv;; 628}; 629 ; 630////////////////////////////////////////////////////////////////////////////////; 631/// Return a case-sensitive hash value (endian independent).; 632 ; 633UInt_t TString::HashCase() const; 634{; 635 UInt_t hv = (UInt_t)Length(); // Mix in the string length.; 636 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 637 const UInt_t *p = (const UInt_t*)Data();; 638 {; 639 while (i--) {; 640#ifndef R__BYTESWAP; 641 UInt_t h = *p++;; 642 Mash(hv, SwapInt(h)); // XOR in the characters.; 643#else; 644 Mash(hv, *p++); // XOR in the characters.; 645#endif; 646 }; 647 }; 648 // XOR in any remaining characters:; 649 if ((i = Length()*sizeof(char)%sizeof(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:18538,hash,hash,18538,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['hash'],['hash']
Security,"hat can be used to execute a C++ command when some event happens in a pad.Definition TExec.h:26; TExec::SetActionvirtual void SetAction(const char *action)Definition TExec.h:37; where actionCommand is a string containing a C++ instruction. Examples: myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be automatically executed. In the function/script being executed, one or more of the following actions can be executed:. load a file containing the referenced object. This function typically looks in the file catalog (GRID).; compute a pointer to the referenced object and communicate this pointer back to the calling function TRef::GetObject via: TRef::SetStaticObject(object).; TRef::SetStaticObjectstatic void SetStaticObject(TObject *obj)Static function to set the object found on the Action on Demand function.Definition TRef.cxx:478; When the TExec is called, it has access to the dereferencing TRef by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this"" before the call to TExec). This can be useful for accessing the TRef's fUniqueID. As soon as an object is returned to GetObject, the fUniqueID of the TRef is set to the fUniqueID of the referenced object. At the next call to GetObject, the pointer stored in fPid:fObjects[fUniqueID] will be returned directly.; An example of action on demand is shown in $ROOTSYS/test/Event.h with the member: TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.GetObject(), the function GetObject will automatically invoke a script GetWebHistogram.C via the interpreter.; An example of a GetWebHistogram.C script is shown below void GetWebHistogram() {; TFile *f= TFile::Open(""http://root.cern/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetStaticObject(h6);; }; f#define f(i)Definition RSha256.hxx:104; gDirectory#define gDirectoryDefinition TDirectory.h:384; TFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:7355,access,access,7355,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,1,['access'],['access']
Security,"he Double_t argument det is supplied, the matrix determinant is calculated. A.InvertFast(&det); TMatrixX; like Invert but for matrices i =(6x6)a faster but less accurate Cramer algorithm is used. A.Rank1Update(v,alpha); TMatrixX; Perform with vector v a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu^T\). A.RandomizePD(alpha,beta,seed)`; TMatrixX; \(A_{ij} = (\beta-\alpha)\bigcup(0,1)+\alpha\) a random symmetric positive-definite matrix is generated with elements uniformly distributed between \(\alpha\) and \(\beta\). Output TMatrixX indicates that the returned matrix is of the same type as A, being TMatrixD, TMatrixDSym or TMatrixDSparse. Next table shows miscellaneous operations for TMatrixD. Format; Output; Description. A.Rank1Update(v1,v2,alpha); TMatrixD; Perform with vector v1 and v2, a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu2^T\). 14.5 Matrix Views; Another way to access matrix elements is through the matrix-view classes, TMatrixDRow, TMatrixDColumn, TMatrixDDiag and TMatrixDSub (each has also a const version which is obtained by simply appending const to the class name). These classes create a reference to the underlying matrix, so no memory management is involved. The next table shows how the classes access different parts of the matrix:. class; view. TMatrixDRow const(X,i) TMatrixDRow(X,i); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & & & & \\; x_{i0} & ... & x_{ij} & ... & x_{in} \\; & & & & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDColumn const(X,j) TMatrixDColumn(X,j); \[ \left(\begin{array}{ccccc}; x_{00} & & x_{0j} & & x_{0n} \\; & & ... & & \\; & & x_{ij} & & \\; & & ... & & \\; x_{n0} & & x_{nj} & & x_{nn}; \end{array}\right)\]. TMatrixDDiag const(X) TMatrixDDiag(X); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & ... & & & \\; & & ... & & \\; & & & ... & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDSub const(X,i,l,j,k) TMatrixDSub(X,i,l,j,k); \[ \left(\begin{array}{ccccc}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:783799,access,access,783799,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"he TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:46670,access,access,46670,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,1,['access'],['access']
Security,"he TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClass.html:47127,access,access,47127,root/html532/TClass.html,https://root.cern,https://root.cern/root/html532/TClass.html,2,['access'],['access']
Security,"he TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:45924,access,access,45924,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,1,['access'],['access']
Security,"he chi2 distribution of the fits.; If arr is NULL, the generated histograms are added to the list of objects in the current directory. It is the user's responsibility to delete these histograms.; Example: Assume a 2-d histogram h2 Root > h2->FitSlicesX(); produces 4 TH1D histograms; with h2_0 containing parameter 0(Constant) for a Gaus fit; of each bin in Y projected along X; with h2_1 containing parameter 1(Mean) for a gaus fit; with h2_2 containing parameter 2(StdDev) for a gaus fit; with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit; ; Root > h2->FitSlicesX(0,15,22,10);; same as above, but only for bins 15 to 22 along Y; and only for bins in Y for which the corresponding projection; along X has more than cut bins filled.; a#define a(i)Definition RSha256.hxx:99; X#define X(type, name); TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; NOTE: To access the generated histograms in the current directory, do eg: TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");; gDirectory#define gDirectoryDefinition TDirectory.h:384. Definition at line 1016 of file TH2.cxx. ◆ FitSlicesY(). void TH2::FitSlicesY ; (; TF1 * ; f1 = nullptr, . Int_t ; firstxbin = 0, . Int_t ; lastxbin = -1, . Int_t ; cut = 0, . Option_t * ; option = ""QNR"", . TObjArray * ; arr = nullptr . ). virtual . Project slices along Y in case of a 2-D histogram, then fit each slice with function f1 and make a histogram for each fit parameter Only bins along X between firstxbin and lastxbin are considered. ; By default (firstxbin == 0, lastxbin == -1), all bins in x including over- and underflows are taken into account. If f1=0, a gaussian is assumed Before invoking this function, one can set a subrange to be fitted along Y via f1->SetRange(ymin,ymax) The argument option (default=""QNR"") can be used to change the fit options.; ""Q"" means Quiet mode; ""N"" means do not show the result of the fit; ""R"" means fit the function in the specified function range; ""G2"" ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:76804,access,access,76804,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['access'],['access']
Security,"he class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6846; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::BypassStreamervoid BypassStreamer(Bool_t bypass=kTRUE)When the kBypassStreamer bit is set, the automatically generated Streamer can cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:403659,checksum,checksum,403659,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['checksum'],['checksum']
Security,"he clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt). Options may be :; - 0 - default (no bombing); - 1 - cartesian coordinates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; - TGeoVolume::SetVisibility() : set volume visibility.; - TGeoVolume::VisibleDaughters() : set daughters visibility.; All these actions automatically updates the current view if any. --- Checking the geometry. Several checking methods are accessible from the volume context menu. They; generally apply only to the visible parts of the drawn geometry in order to; ease geometry checking, and their implementation is in the TGeoChecker class; from the painting package. 1. Checking a given point.; Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; This method is drawing the daughters of the volume containing the point one; level down, printing the path to the deepest physical node holding this point.; It also computes the closest distance to any boundary. The point will be drawn; in red. /*. */. 2. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and; it will draw this volume with current visualization settings. Random points; are generated in the bounding box of the top drawn volume. The points are; classified and drawn with the color of their deepest container. Only points; in visible nodes will be drawn. /*. */. 3. Raytracing.; Can be called from TGeoVol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:9802,access,accessible,9802,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['access'],['accessible']
Security,"he correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:24012,access,access,24012,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['access'],['access']
Security,"he file system and still access the branch files. The ROOT file will be connected only when necessary. If called by TBranch::Fill (via TBasket::WriteFile), the file will be created with the option ""recreate"". If called by TBranch::GetEntry (via TBranch::GetBasket), the file will be opened in read mode. To open a file in ""update"" mode or with a certain compression level, use TBranch::SetFile(TFile *file). ; Definition at line 2908 of file TBranch.cxx. ◆ SetFile() [2/2]. void TBranch::SetFile ; (; TFile * ; file = nullptr). virtual . Set file where this branch writes/reads its buffers. ; By default the branch buffers reside in the file where the Tree was created. If the file name where the tree was created is an absolute path name or an URL (e.g. or root://host/...) and if the fname is not an absolute path name or an URL then the path of the tree file is prepended to fname to make the branch file relative to the tree file. In this case one can move the tree + all branch files to a different location in the file system and still access the branch files. The ROOT file will be connected only when necessary. If called by TBranch::Fill (via TBasket::WriteFile), the file will be created with the option ""recreate"". If called by TBranch::GetEntry (via TBranch::GetBasket), the file will be opened in read mode. To open a file in ""update"" mode or with a certain compression level, use TBranch::SetFile(TFile *file). ; Definition at line 2863 of file TBranch.cxx. ◆ SetFirstEntry(). void TBranch::SetFirstEntry ; (; Long64_t ; entry). virtual . set the first entry number (case of TBranchSTL) ; Definition at line 3279 of file TBranch.cxx. ◆ SetIOFeatures(). void TBranch::SetIOFeatures ; (; TIOFeatures & ; features). inline . Definition at line 283 of file TBranch.h. ◆ SetMakeClass(). bool TBranch::SetMakeClass ; (; bool ; decomposeObj = true). virtual . Set the branch in a mode where the object are decomposed (Also known as MakeClass mode). ; Return whether the setting was possible (i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:65242,access,access,65242,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['access'],['access']
Security,"he left of the menu bar with 4 pixels distance in between, the Help menu - will be laid out to the right.; The menu classes provide a very flexible menu system: you can enable, disable, add or remove menu items dynamically. The method HideEntry(menuID) hides the menu entry (the entry will not be shown in the popup menu). To enable a hidden entry you should call EnableEntry(menuID) method. By default all entries are enabled. The method DisableEntry(menuID) helps you to disable a menu entry - it will appear in sunken relieve. The DeleteEntry(menuID) method will delete the specified entry from the menu.; A few words about the menu design. A menu should be kept consistent and simple. All related items need to be in a popup menu. The cascade menus should be used judiciously. Try to limit them to one, maximum two levels.; There are some rules for naming the menu objects:. Define unique names within a menu; Use capitalized one-word names allowing the quick scan of the menu; Define unique access key for any menu item; Indicate by ellipsis (…) after the title with no space when a menu item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every application success and depends of three main factors:. number of presented items in the menu; how often the menu is used; how often the menu contents may change. 25.8.5 Toolbar. A toolbar (TGToolBar) is a composite frame that contains TGPictureButtonobjects. It provides an easy and fast access to most frequently used commands or options across multiple application screens. Also, it invokes easily a sub application within an application. All its functions can be obtained by application menus. It is located horizontally at the top of the main window just below the menu bar. All other subtask and sub-feature bars are positioned along sides of window.; // toolbar icon files; const char *xpms[] = {; ""x_pic.xpm"",; ""y_pic.xpm"",; ""z_pic.xpm"",; 0; };; // toolbar tool tip text; const char *tips[] = {; ""X Settin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1194420,access,access,1194420,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"he log file to the very end.; This allows to ""hide"" useful debug messages during normal operations; while preserving the possibility to have them in case of problems. void HandleException(Int_t sig); Exception handler: we do not try to recover here, just exit. Int_t HandleDataSets(TMessage* mess, TString* slb = 0); Handle here requests about datasets. void HandleSubmerger(TMessage* mess); Handle a message of type kPROOF_SUBMERGER. void HandleFork(TMessage* mess); Cloning itself via fork. Not implemented. Int_t Fork(); Fork a child.; If successful, return 0 in the child process and the child pid in the parent; process. The child pid is registered for reaping.; Return <0 in the parent process in case of failure. void ResolveKeywords(TString& fname, const char* path = 0); Replace <ord>, <user>, <u>, <group>, <stag>, <qnum> and <file> placeholders in fname. Int_t GetSessionStatus(); Return the status of this session:; 0 idle; 1 running; 2 being terminated (currently unused); 3 queued; 4 idle timed-out (not set in here but in TIdleTOTimer::Notify); This is typically run in the reader thread, so access needs to be protected. Int_t UpdateSessionStatus(Int_t xst = -1); Update the session status in the relevant file. The status is taken from; GetSessionStatus() unless xst >= 0, in which case xst is used.; Return 0 on success, -errno if the file could not be opened. Bool_t IsIdle(); Return the idle status. void SetIdle(Bool_t st = kTRUE); Change the idle status. Bool_t IsWaiting(); Return kTRUE if the session is waiting for the OK to start processing. Int_t WaitingQueries(); Return the number of waiting queries. Int_t QueueQuery(TProofQueryResult* pq); Add a query to the waiting list; Returns the number of queries in the list. TProofQueryResult * NextQuery(); Get the next query from the waiting list.; The query is removed from the list. Int_t CleanupWaitingQueries(Bool_t del = kTRUE, TList* qls = 0); Cleanup the waiting queries list. The objects are deleted if 'del' is true.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:29645,access,access,29645,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['access'],['access']
Security,"he object. For example, to; set the labels size on the palette axis do:. hist->GetZaxis()->SetLabelSize(). WARNING: The palette axis is always drawn vertically.; Setting the color palette; To change the color palette TStyle::SetPalette should be used, eg:. gStyle->SetPalette(ncolors,colors);. For example the option ""COL"" draws a 2D histogram with cells; represented by a box filled with a color index which is a function; of the cell content.; If the cell content is N, the color index used will be the color number; in colors[N], etc. If the maximum cell content is greater than; ncolors, all cell contents are scaled to ncolors.; If ncolors <= 0, a default palette (see below) of 50 colors is; defined. This palette is recommended for pads, labels ...; if ncolors == 1 && colors == 0, then a Pretty Palette with a; Spectrum Violet->Red is created with 50 colors. That's the default rain bow; palette. Other prefined palettes with 255 colors are available when colors == 0.; The following value of ncolors give access to:. if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used. If ncolors > 0 && colors == 0, the default palette is used; with a maximum of ncolors.; The default palette defines:. index 0 to 9 : shades of grey; index 10 to 19 : shades of brown; index 20 to 29 : shades of blue; index 30 to 39 : shades of red; index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item ""colors"" in the ""VIEW"" menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; TColor::SetRGB().; Drawing a sub-range of a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:64359,access,access,64359,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,3,['access'],['access']
Security,"he rules that are about the given 'source' class. ; User has to delete the returned array ; Definition at line 289 of file TSchemaRuleSet.cxx. ◆ FindRules() [2/4]. const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules ; (; const TString & ; source, . Int_t ; version . ); const. Return all the rules that applies to the specified version of the given 'source' class. ; User has to delete the returned array ; Definition at line 328 of file TSchemaRuleSet.cxx. ◆ FindRules() [3/4]. const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules ; (; const TString & ; source, . Int_t ; version, . UInt_t ; checksum . ); const. Return all the rules that applies to the specified version OR checksum of the given 'source' class. ; User has to delete the returned array ; Definition at line 368 of file TSchemaRuleSet.cxx. ◆ FindRules() [4/4]. const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules ; (; const TString & ; source, . UInt_t ; checksum . ); const. Return all the rules that applies to the specified checksum of the given 'source' class. ; User has to delete the returned array ; Definition at line 348 of file TSchemaRuleSet.cxx. ◆ GetClass(). TClass * TSchemaRuleSet::GetClass ; (; ). Definition at line 386 of file TSchemaRuleSet.cxx. ◆ GetClassCheckSum(). UInt_t TSchemaRuleSet::GetClassCheckSum ; (; ); const. Definition at line 393 of file TSchemaRuleSet.cxx. ◆ GetClassName(). TString TSchemaRuleSet::GetClassName ; (; ); const. Definition at line 403 of file TSchemaRuleSet.cxx. ◆ GetClassVersion(). Int_t TSchemaRuleSet::GetClassVersion ; (; ); const. Definition at line 410 of file TSchemaRuleSet.cxx. ◆ GetPersistentRules(). const TObjArray * TSchemaRuleSet::GetPersistentRules ; (; ); const. Definition at line 424 of file TSchemaRuleSet.cxx. ◆ GetRules(). const TObjArray * TSchemaRuleSet::GetRules ; (; ); const. Definition at line 417 of file TSchemaRuleSet.cxx. ◆ HasRuleWithSourceClass(). Bool_t TSchemaRuleSet::HasRuleWithSourceClass ; (; const TString & ; source); const. Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html:15967,checksum,checksum,15967,doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html,1,['checksum'],['checksum']
Security,"he string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <THashList.h>. Inheritance diagram for THashList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ THashList() [1/3]. THashList::THashList ; (; const THashList & ; ). privatedelete . ◆ THashList() [2/3]. THashList::THashList ; (; Int_t ; capacity = TCollection::kInitHashTableCapacity, . Int_t ; rehash = 0 . ). Create a THashList object. ; Capacity is the initial hashtable capacity (i.e. number of slots), by default kInitHashTableCapacity = 17, and rehash is the value at which a rehash will be triggered. I.e. when the average size of the linked lists at a slot becomes longer than rehash then the hashtable will be resized and refilled to reduce the collision rate to about 1. The higher the collision rate, i.e. the longer the linked lists, the longer lookup will take. If rehash=0 the table will NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!! If the name of an object in the HashList is modified, The hashlist must be Rehashed ; Definition at line 43 of file THashList.cxx. ◆ THashList() [3/3]. THashList::THashList ; (; TObject * ; parent, . Int_t ; capacity = TCollection::kInitHashTableCapacity, . Int_t ; rehash = 0 . ). For backward compatibility only. Use other ctor. ; Definition at line 51 of file THashList.cxx. ◆ ~THashList(). THashList::~THashList ; (; ). virtual . Delete a hashlist. ; Objects are not deleted un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:22574,hash,hashtable,22574,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['hash'],['hashtable']
Security,"he two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. int CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Compare a string to another string. Returns returns zero if the two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. V.Perev. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TString.html:10562,hash,hash,10562,root/html530/TString.html,https://root.cern,https://root.cern/root/html530/TString.html,2,['hash'],['hash']
Security,"he two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. int CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Compare a string to another string. Returns returns zero if the two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. TString MD5() const; Return the MD5 digest for this string, in a string representation. Bool_t MaybeRegexp() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TString.html:11241,hash,hash,11241,root/html534/TString.html,https://root.cern,https://root.cern/root/html534/TString.html,3,['hash'],['hash']
Security,"he url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. The preferred interface to this; constructor is via TFile::Open(). TWebFile(TUrl url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. Make sure url; is a valid TUrl object.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. ~TWebFile(); Cleanup. void Init(Bool_t readHeadOnly); Initialize a TWebFile object. void SetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); Set GET command for use by ReadBuffer(s)10(), handle redirection if; needed. Give full URL so Apache's virtual hosts solution works. void CheckProxy(); Check if shell var ""http_proxy"" has been set and should be used. Bool_t IsOpen() const; A TWebFile that has been correctly constructed is always considered open. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:24427,access,accessible,24427,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,6,['access'],['accessible']
Security,"he wrapped object and allow to call its methods. ;  ; void SetAtSlot (unsigned i, std::shared_ptr< T > v);  Set the value of a particular slot. ;  ; std::unique_ptr< T > SnapshotMerge (TThreadedObjectUtils::MergeFunctionType< T > mergeFunction=TThreadedObjectUtils::MergeTObjects< T >);  Merge all the thread private objects. ;  . Static Public Attributes; static constexpr const TNumSlots fgMaxSlots {64};  The initial number of empty processing slots that a TThreadedObject is constructed with by default. ;  . Private Member Functions; unsigned GetThisSlotNumber ();  Get the slot number for this threadID, make a slot if needed. ;  . Private Attributes; std::deque< TDirectory * > fDirectories;  A TDirectory per slot. ;  ; bool fIsMerged: 1;  Remember if the objects have been merged already. ;  ; std::unique_ptr< T > fModel;  Use to store a ""model"" of the object. ;  ; std::deque< std::shared_ptr< T > > fObjPointers;  An object pointer per slot. ;  ; ROOT::TSpinMutex fSpinMutex;  Protects concurrent access to fThrIDSlotMap, fObjPointers. ;  ; std::map< std::thread::id, unsigned > fThrIDSlotMap;  A mapping between the thread IDs and the slots. ;  . #include <ROOT/TThreadedObject.hxx>; Constructor & Destructor Documentation. ◆ TThreadedObject() [1/3]. template<class T > . ROOT::TThreadedObject< T >::TThreadedObject ; (; const TThreadedObject< T > & ; ). delete . ◆ TThreadedObject() [2/3]. template<class T > . template<class... ARGS> . ROOT::TThreadedObject< T >::TThreadedObject ; (; TNumSlots ; initSlots, . ARGS &&... ; args . ). inline . Construct the TThreadedObject with initSlots empty slots and the ""model"" of the thread private objects. ; Parameters. initSlotsSet the initial number of slots of the TThreadedObject. . Template Parameters. ARGSArguments' class type of the constructor of T . Parameters. argsvariadic arguments. This form of the constructor is useful to manually pre-set the content of a given number of slots when used in combination with TThreadedObject::SetA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html:3281,access,access,3281,doc/v632/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html,2,['access'],['access']
Security,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCategory::getIndex() const; virtual const char*RooAbsCategory::getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*RooAbsArg::getObservables(const RooAbsData* data) const; RooArgSet*RooAbsArg::getObservables(const RooAbsData& data) const; RooArgSet*RooAbsArg::getObservables(const RooArgSet& set, Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinningCategory.html:5495,hash,hash,5495,root/html534/RooBinningCategory.html,https://root.cern,https://root.cern/root/html534/RooBinningCategory.html,13,['hash'],['hash']
Security,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tgetIndex() const; virtual const char*getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*RooAbsArg::getObservables(const RooAbsData* data) const; RooArgSet*RooAbsArg::getObservables(const RooAbsData& data) const; RooArgSet*RooAbsArg::getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:5610,hash,hash,5610,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,3,['hash'],['hash']
Security,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*RooAbsArg::getObservables(const RooAbsData* data) const; RooArgSet*RooAbsArg::getObservables(const RooAbsData& data) const; RooArgSet*RooAbsArg::getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; RooArgSet*RooAbsArg::getObservables(const RooArgSet* depList, Bool_t val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:5389,hash,hash,5389,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,6,['hash'],['hash']
Security,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tRooAbsCategoryLValue::getBin(const char* rangeName = 0) const; virtual Int_tRooAbsCategoryLValue::getBin(const RooAbsBinning*) const; virtual list<std::string>RooAbsCategoryLValue::getBinningNames() const; virtual const RooAbsBinning*RooAbsCategoryLValue::getBinningPtr(const char*) const; virtual Double_tRooAbsCategoryLValue::getBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCategory::getIndex() const; virtual cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSuperCategory.html:5920,hash,hash,5920,root/html534/RooSuperCategory.html,https://root.cern,https://root.cern/root/html534/RooSuperCategory.html,1,['hash'],['hash']
Security,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tRooAbsCategoryLValue::getBin(const char* rangeName = 0) const; virtual Int_tRooAbsCategoryLValue::getBin(const RooAbsBinning*) const; virtual list<std::string>RooAbsCategoryLValue::getBinningNames() const; virtual const RooAbsBinning*RooAbsCategoryLValue::getBinningPtr(const char*) const; virtual Double_tRooAbsCategoryLValue::getBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tgetIndex() const; virtual const char*getLabel(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:5627,hash,hash,5627,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,1,['hash'],['hash']
Security,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tRooAbsCategoryLValue::getBin(const char* rangeName = 0) const; virtual Int_tRooAbsCategoryLValue::getBin(const RooAbsBinning*) const; virtual list<string>RooAbsCategoryLValue::getBinningNames() const; virtual const RooAbsBinning*RooAbsCategoryLValue::getBinningPtr(const char*) const; virtual Double_tRooAbsCategoryLValue::getBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCategory::getIndex() const; virtual const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSuperCategory.html:5738,hash,hash,5738,root/html602/RooSuperCategory.html,https://root.cern,https://root.cern/root/html602/RooSuperCategory.html,2,['hash'],['hash']
Security,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tRooAbsCategoryLValue::getBin(const char* rangeName = 0) const; virtual Int_tRooAbsCategoryLValue::getBin(const RooAbsBinning*) const; virtual list<string>RooAbsCategoryLValue::getBinningNames() const; virtual const RooAbsBinning*RooAbsCategoryLValue::getBinningPtr(const char*) const; virtual Double_tRooAbsCategoryLValue::getBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tgetIndex() const; virtual const char*getLabel() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:5496,hash,hash,5496,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,2,['hash'],['hash']
Security,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<std::string>getBinningNames() const; virtual const RooAbsBinning*getBinningPtr(const char*) const; virtual Double_tgetBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCategory::getIndex() const; virtual const char*RooAbsCategory::getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:5711,hash,hash,5711,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,1,['hash'],['hash']
Security,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<string>getBinningNames() const; virtual const RooAbsBinning*getBinningPtr(const char*) const; virtual Double_tgetBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCategory::getIndex() const; virtual const char*RooAbsCategory::getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:5706,hash,hash,5706,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['hash'],['hash']
Security,"he> >_barlowCache; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*_data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html:33590,access,access,33590,root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,1,['access'],['access']
Security,"heck only for conflicting rules; kCheckAll: check for conflict and check for rule about members that are not in the current class layout.; return kTRUE if the layout is accepted, in which case we take ownership of; the rule object.; return kFALSE if the rule failed one of the test, the rule now needs to be deleted by the caller. void AsString(TString& out) const; Fill the string 'out' with the string representation of the rule. Bool_t HasRuleWithSourceClass(const TString& source) const; Return True if we have any rule whose source class is 'source'. const TObjArray* FindRules(const TString& source) const; Return all the rules that are about the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, Int_t version) const; Return all the rules that applies to the specified version of the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, UInt_t checksum) const; Return all the rules that applies to the specified checksum of the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, Int_t version, UInt_t checksum) const; Return all the rules that applies to the specified version OR checksum of the given 'source' class.; User has to delete the returned array. TClass* GetClass(). UInt_t GetClassCheckSum() const. TString GetClassName() const. Int_t GetClassVersion() const. const TObjArray* GetRules() const. const TObjArray* GetPersistentRules() const. void RemoveRule(ROOT::TSchemaRule* rule); Remove given rule from the set - the rule is not being deleted!. void RemoveRules(TObjArray* rules); remove given array of rules from the set - the rules are not being deleted!. void SetClass(TClass* cls); Set the TClass associated with this rule set. void Streamer(TBuffer& ); Stream an object of class ROOT::TSchemaRuleSet. TSchemaRuleSet(). » Last changed: root/core:$Id$ » Last generated: 2015-03-10 17:1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__TSchemaRuleSet.html:8340,checksum,checksum,8340,root/html534/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html534/ROOT__TSchemaRuleSet.html,2,['checksum'],['checksum']
Security,"heck only for conflicting rules; kCheckAll: check for conflict and check for rule about members that are not in the current class layout.; return kTRUE if the layout is accepted, in which case we take ownership of; the rule object.; return kFALSE if the rule failed one of the test, the rule now needs to be deleted by the caller. void AsString(TString& out) const; Fill the string 'out' with the string representation of the rule. Bool_t HasRuleWithSourceClass(const TString& source) const; Return True if we have any rule whose source class is 'source'. const TObjArray* FindRules(const TString& source) const; Return all the rules that are about the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, Int_t version) const; Return all the rules that applies to the specified version of the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, UInt_t checksum) const; Return all the rules that applies to the specified checksum of the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, Int_t version, UInt_t checksum) const; Return all the rules that applies to the specified version OR checksum of the given 'source' class.; User has to delete the returned array. TClass* GetClass(). UInt_t GetClassCheckSum() const. TString GetClassName() const. Int_t GetClassVersion() const. const TObjArray* GetRules() const. const TObjArray* GetPersistentRules() const. void RemoveRule(ROOT::TSchemaRule* rule); Remove given rule from the set - the rule is not being deleted!. void RemoveRules(TObjArray* rules); remove given array of rules from the set - the rules are not being deleted!. void SetClass(TClass* cls); Set the TClass associated with this rule set. void Streamer(TBuffer& ); Stream an object of class ROOT::TSchemaRuleSet. TSchemaRuleSet(). » Last changed: root/core:$Id$ » Last generated: 2015-06-30 14:2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TSchemaRuleSet.html:8910,checksum,checksum,8910,root/html602/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html602/ROOT__TSchemaRuleSet.html,2,['checksum'],['checksum']
Security,"heck only for conflicting rules; kCheckAll: check for conflict and check for rule about members that are not in the current class layout.; return kTRUE if the layout is accepted, in which case we take ownership of; the rule object.; return kFALSE if the rule failed one of the test, the rule now needs to be deleted by the caller. void AsString(TString& out) const; Fill the string 'out' with the string representation of the rule. Bool_t HasRuleWithSourceClass(const TString& source) const; Return True if we have any rule whose source class is 'source'. const TObjArray* FindRules(const TString& source) const; Return all the rules that are about the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, Int_t version) const; Return all the rules that applies to the specified version of the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, UInt_t checksum) const; Return all the rules that applies to the specified checksum of the given 'source' class.; User has to delete the returned array. const TSchemaMatch* FindRules(const TString& source, Int_t version, UInt_t checksum) const; Return all the rules that applies to the specified version OR checksum of the given 'source' class.; User has to delete the returned array. TClass* GetClass(). UInt_t GetClassCheckSum() const. TString GetClassName() const. Int_t GetClassVersion() const. const TObjArray* GetRules() const. const TObjArray* GetPersistentRules() const. void RemoveRule(ROOT::TSchemaRule* rule); Remove given rule from the set - the rule is not being deleted!. void RemoveRules(TObjArray* rules); remove given array of rules from the set - the rules are not being deleted!. void SetClass(TClass* cls); Set the TClass associated with this rule set. void Streamer(TBuffer& ); Stream an object of class ROOT::TSchemaRuleSet. TSchemaRuleSet(). » Last changed: root/core:$Id$ » Last generated: 2015-09-08 17:4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__TSchemaRuleSet.html:8910,checksum,checksum,8910,root/html604/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html604/ROOT__TSchemaRuleSet.html,2,['checksum'],['checksum']
Security,"hecked. ;  ; void SetShared (Bool_t flag=kTRUE);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTranslation.html:6348,hash,hash,6348,doc/master/classTGeoTranslation.html,https://root.cern,https://root.cern/doc/master/classTGeoTranslation.html,1,['hash'],['hash']
Security,"hed. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error du",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:24258,secur,secure,24258,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,6,['secur'],['secure']
Security,"hemaRuleSet(); ROOT::TSchemaRuleSetTSchemaRuleSet(const ROOT::TSchemaRuleSet&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArray*fAllRules! Array of all rules; UInt_tfCheckSumTarget class checksum; TClassReffClass! Target class pointer (for consistency checking); TStringfClassNameTarget class name; TObjArray*fPersistentRulesArray of the rules that will be embeded in the file; TObjArray*fRemainingRules! Array of non-persisten rules - just for cleanup purposes - owns the elements; Int_tfVersionTarget class version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSchemaRuleSet(). virtual ~TSchemaRuleSet(). Bool_t AddRule(ROOT::TSchemaRule* rule, Bool_t checkConsistency = kTRUE). Bool_t AddRules(ROOT::TSchemaRuleSet* rules, Bool_t checkConsistency = kTRUE). Bool_t HasRuleWithSourceClass(const TString& source) const. const TObjArray* FindRules(const TString& source) const. const TSchemaMatch* FindRules( const TString &source, Int_t version ). const TSchemaMatch* FindRules( const TString &source, UInt_t checksum ). const TSchemaMatch* FindRules(const TString& source, Int_t version, UInt_t checksum) const. TClass* GetClass(). UInt_t GetClassCheckSum() const. TString GetClassName() const. Int_t GetClassVersion() const. const TObjArray* GetRules() const. const TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__TSchemaRuleSet.html:5970,checksum,checksum,5970,root/html526/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html526/ROOT__TSchemaRuleSet.html,1,['checksum'],['checksum']
Security,"hen excluding under-; and overflow bins!. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnSparse* h, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); voidCalculateErrors(Bool_t calc = kT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THnSparse.html:4270,hash,hash,4270,root/html532/THnSparse.html,https://root.cern,https://root.cern/root/html532/THnSparse.html,1,['hash'],['hash']
Security,"hen excluding under-; and overflow bins!. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnSparse* h, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateErrors(Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:4270,hash,hash,4270,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,2,['hash'],['hash']
Security,"hes ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgr! The cache manager; RooSetProxy_cacheObsVariables to be cached; Bool_t_cacheSourceKeep an attached clone of the source in the cache for fast operation; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:34569,access,access,34569,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,1,['access'],['access']
Security,"hes are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The tree in the diagram below has two friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:70699,access,access,70699,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['access']
Security,"hes; RooIntegralMorph::MorphCacheElem*_cacheCurrent morph cache element in use; Bool_t_cacheAlphaIf true, both (x,alpha) are cached; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooIntegralMorph.html:47182,access,access,47182,root/html602/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html602/RooIntegralMorph.html,2,['access'],['access']
Security,"hes; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager; RooSetProxy_cacheObsObservable to be cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedPdf.html:43327,access,access,43327,root/html602/RooCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooCachedPdf.html,2,['access'],['access']
Security,"hether the event has passed the selection (true) or not (false). It should perform ""read-only"" operations on the columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column names are used as variable names (e.g. Filter(""x[0] + x[1] > 0"")). This is a convenience feature that comes with a certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event loop. See the paragraph about ""Just-in-time compilation"" below for more information.; RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed in order and the first one returning false causes the event to be discarded and triggers the processing of the next entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for each entry: after the first access it simply serves a cached result.; Named filters and cutflow reports; An optional string parameter name can be passed to the Filter() method to create a named filter. Named filters work as usual, but also keep track of how many entries they accept and reject.; Statistics are retrieved through a call to the Report() method:. when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all named filters declared up to that point; when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and refer to the latest event-loop that has been run using the relevant RDataFrame. Ranges; When RDataFrame is not being used in a mult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:28360,access,access,28360,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['access'],['access']
Security,"hether this is okay or not ...; 989 //; 990 // Since this is such an unlikely scenario, let's complain; 991 // about it anyway (The class layout *may* have changed, we; 992 // don't know).; 993 ; 994 // if (this has only base classes) {; 995 // match = kTRUE;; 996 // }; 997 }; 998#endif; 999 } else {; 1000 // The on-file TStreamerInfo's checksum differs from the checksum of a TStreamerInfo on another file.; 1001 ; 1002 match = kFALSE;; 1003 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 1004 ; 1005 // In the case where the read-in TStreamerInfo does not; 1006 // match in the 'current' in memory TStreamerInfo for; 1007 // a non foreign class (we can not get here if this is; 1008 // a foreign class so we do not need to test it),; 1009 // we need to add this one more test since the CINT behaviour; 1010 // with enums changed over time, so verify the checksum ignoring; 1011 // members of type enum. We also used to not count the //[xyz] comment; 1012 // in the checksum, so test for that too.; 1013 if (fCheckSum == info->GetCheckSum(TClass::kCurrentCheckSum); 1014 || info->MatchLegacyCheckSum(fCheckSum); 1015 || GetCheckSum(TClass::kCurrentCheckSum) == info->fCheckSum; 1016 || MatchLegacyCheckSum(info->GetCheckSum()); 1017 || GetCheckSum(TClass::kCurrentCheckSum) == info->GetCheckSum(TClass::kCurrentCheckSum)); 1018 {; 1019 match = kTRUE;; 1020 }; 1021 if (fOldVersion <= 2) {; 1022 // Names of STL base classes was modified in vers==3. Allocators removed; 1023 // (We could be more specific (see test for the same case below); 1024 match = kTRUE;; 1025 }; 1026 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 1027 match = kTRUE;; 1028 }; 1029 }; 1030 }; 1031 if (info->IsBuilt()) {; 1032 SetBit(kCanDelete);; 1033 fNumber = info->GetNumber();; 1034 Int_t nel = fElements->GetEntriesFast();; 1035 TObjArray* elems = info->GetElements();; 1036 TStreamerElement* e1 = 0;; 1037 TStreamerElement* e2 = 0;; 1038 for (Int_t i = 0; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:37759,checksum,checksum,37759,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['checksum'],['checksum']
Security,"his can be found at http://en.cppreference.com/w/cpp/experimental/basic_string_view The implementation provided is extracted from libcxx. Whenever the current compiler and standard library provide an implmentation, it is used.; The type string_view describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero.; This type is used throughout the ROOT code to avoid copying strings when a sub-string is needed and to extent interfaces that uses to take a const char* to take a std::string_view as thus be able to be directly directly passed a TString, a std::string or a std::string_view. Usage example:; // With SetName(std::string_view); std::string str; …; obj.SetName( str );; obj.SetName( {str.data()+pos, len} );; Meta library; Backward Incompatibilities; TIsAProxy’s constructor no longer take the optional and unused 2nd argument which was reserved for a ‘context’. This context was unused in TIsAProxy itself and was not accessible from derived classes.; Interpreter; The new interface TInterpreter::Declare(const char* code) will declare the code to the interpreter with all interpreter extensions disabled, i.e. as “proper” C++ code. No autoloading or synamic lookup will be performed.; A new R__LOAD_LIBRARY(libWhatever) will load libWhatever at parse time. This allows ROOT to resolve symbols from this library very early on. It is a work-around for the following code from ROOT 5:; // ROOT 5:; void func() {; gSystem->Load(""libEvent"");; Event* e = new Event;; }; Instead, write:; // ROOT 6:; R__LOAD_LIBRARY(libEvent); #include ""Event.h"". void func() {; Event* e = new Event;; }; TClass; Introduced new overload for calculating the TClass CheckSum:; UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; which indicates via the ‘isvalid’ boolean whether the checksum could be calculated correctly or not.; TROOT; Implemented new gROOT->GetTutorialsDir() static method to return the actual l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:4140,access,accessible,4140,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['access'],['accessible']
Security,his class . ◆ Class_Version(). static constexpr Version_t TMVA::Event::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 153 of file Event.h. ◆ ClearDynamicVariables(). static void TMVA::Event::ClearDynamicVariables ; (; ). inlinestatic . Definition at line 122 of file Event.h. ◆ CopyVarValues(). void TMVA::Event::CopyVarValues ; (; const Event & ; other). copies only the variable values ; Definition at line 203 of file Event.cxx. ◆ DeclFileName(). static const char * TMVA::Event::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 153 of file Event.h. ◆ GetBoostWeight(). Double_t TMVA::Event::GetBoostWeight ; (; ); const. inline . Definition at line 85 of file Event.h. ◆ GetClass(). UInt_t TMVA::Event::GetClass ; (; ); const. inline . Definition at line 86 of file Event.h. ◆ GetNSpectators(). UInt_t TMVA::Event::GetNSpectators ; (; ); const. accessor to the number of spectators ; Definition at line 335 of file Event.cxx. ◆ GetNTargets(). UInt_t TMVA::Event::GetNTargets ; (; ); const. accessor to the number of targets ; Definition at line 327 of file Event.cxx. ◆ GetNVariables(). UInt_t TMVA::Event::GetNVariables ; (; ); const. accessor to the number of variables ; Definition at line 316 of file Event.cxx. ◆ GetOriginalWeight(). Double_t TMVA::Event::GetOriginalWeight ; (; ); const. inline . Definition at line 84 of file Event.h. ◆ GetSpectator(). Float_t TMVA::Event::GetSpectator ; (; UInt_t ; ivar); const. return spectator content ; Definition at line 261 of file Event.cxx. ◆ GetSpectators() [1/2]. std::vector< Float_t > & TMVA::Event::GetSpectators ; (; ). inline . Definition at line 107 of file Event.h. ◆ GetSpectators() [2/2]. const std::vector< Float_t > & TMVA::Event::GetSpectators ; (; ); const. inline . Definition at line 108 of file Event.h. ◆ GetTarget(). Float_t TMVA::Event::GetTarget ; (; UInt_t ; itgt); const. inline . Definition at line 102 of fi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Event.html:16881,access,accessor,16881,doc/master/classTMVA_1_1Event.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Event.html,1,['access'],['accessor']
Security,"his object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLEmbeddedViewer.html:15822,hash,hash,15822,doc/master/classTGLEmbeddedViewer.html,https://root.cern,https://root.cern/doc/master/classTGLEmbeddedViewer.html,3,['hash'],['hash']
Security,"his; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(Scalar[] dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:15513,access,access,15513,root/html602/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,4,['access'],['access']
Security,"histogram (like COL, SURF, LEGO, CONT etc..).; When a TGraph2D is drawn with one of the 2D histogram drawing option, an intermediate 2D histogram is filled using the Delaunay triangles to interpolate the data set. The 2D histogram has equidistant bins along the X and Y directions. The number of bins along each direction can be change using SetNpx() and SetNpy(). Each bin is filled with the Z value found via a linear interpolation on the plane defined by the triangle above the (X,Y) coordinates of the bin center.; The existing (X,Y,Z) points can be randomly scattered. The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then used to define flat planes in (X,Y,Z) over which the interpolation is done to fill the 2D histogram. The 3D triangles int takes build a 3D surface in the form of tessellating triangles at various angles. The triangles found can be drawn in 3D with one of the TGraph2D specific drawing options.; The histogram generated by the Delaunay interpolation can be accessed using the GetHistogram() method.; The axis settings (title, ranges etc ...) can be changed accessing the axis via the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created at drawing time only. Therefore they should called after the TGraph2D is drawn:; auto g = new TGraph2D();; ; [...]; ; g->Draw(""tri1"");; gPad->Update();; g->GetXaxis()->SetTitle(""X axis title"");; gPad#define gPadDefinition TVirtualPad.h:308. Examples. SURF1 Example; {; auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; Double_t x, y, z, P = 6.;; Int_t np = 200;; auto dt = new TGraph2D();; dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; auto r = new TRandom();; for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(1);; dt->Draw(""surf1"");; }; c#define c(i)Definition RSha256.hxx:101; N#define N; npOption_t Option_t TPoint TPoint const char GetT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2D.html:4041,access,accessed,4041,doc/master/classTGraph2D.html,https://root.cern,https://root.cern/doc/master/classTGraph2D.html,1,['access'],['accessed']
Security,"histograms with different scales in the ""same"" pad ;  xyplot.C Example showing how to produce a plot with an orthogonal axis system centered at (0,0) ;  ► histfactory;  example.C;  example.py;  makeExample.C;  makeQuickModel.py;  ModifyInterpolation.C;  ► html;  MakeTutorials.C;  ► http;  custom.CThis program creates and fills one and two dimensional histogram Macro used to demonstrate usage of custom HTML page in custom.htm One can use plain JavaScript to assign different actions with HTML buttons ;  histfitserver.CThis program demonstrates simultaneous update of histogram and fitted function ;  httpaccess.CThis program demonstrates access control to the THttpServer with digest methods ;  httpcontrol.CThis program demonstrates simple application control via THttpServer Two histogram are filled within endless loop ;  httpserver.CThis program creates : ;  httptextlog.CThis macro demonstrates custom access and custom drawing for TMsgList class Main motivation for this example - demonstrate how traffic between server and client can be minimized and how one could build custom UI in the browser ;  httptextlog.js;  ws.C;  ► image;  galaxy_image.C Importing an image and manipulating it ;  hist2image.C Create an image from a 2-D histogram and manipulate it ;  hsumanim.C This script is a slightly modified version of hsum.C ;  image2hist.C Create a 2-D histogram from an image ;  img2pad.C Display image in canvas and pad ;  imgconv.C Open rose512.jpg and save it in the following formats: .png, .gif, .xpm and tiff ;  pad2png.C Create a canvas and save as png ;  rose_image.C Display image in a new canvas and pad ;  trans_graph.C Demonstrates how to access and manipulate ARGB pixel values of an image +.. ;  ► io;  copyFiles.C Example of script showing how to copy all objects (including directories) from a source file ;  dirs.C This macro illustrates how to create a hierarchy of directories in a Root file ;  double32.C Tutorial illustrating use and precision of the Double32_t data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:126852,access,access,126852,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['access'],['access']
Security,"histograms with different scales in the ""same"" pad ;  xyplot.C Example showing how to produce a plot with an orthogonal axis system centered at (0,0) ;  ► histfactory;  example.C;  example.py;  makeExample.C;  makeQuickModel.py;  ModifyInterpolation.C;  ► html;  MakeTutorials.C;  ► http;  custom.CThis program creates and fills one and two dimensional histogram Macro used to demonstrate usage of custom HTML page in custom.htm One can use plain JavaScript to assign different actions with HTML buttons ;  histfitserver.CThis program demonstrates simultaneous update of histogram and fitted function ;  httpaccess.CThis program demonstrates access control to the THttpServer with digest methods ;  httpcontrol.CThis program demonstrates simple application control via THttpServer Two histogram are filled within endless loop ;  httpserver.CThis program creates : ;  httptextlog.CThis macro demonstrates custom access and custom drawing for TMsgList class Main motivation for this example - demonstrate how traffic between server and client can be minimized and how one could build custom UI in the browser ;  httptextlog.js;  ► image;  galaxy_image.C Importing an image and manipulating it ;  hist2image.C Create an image from a 2-D histogram and manipulate it ;  hsumanim.C This script is a slightly modified version of hsum.C ;  image2hist.C Create a 2-D histogram from an image ;  img2pad.C Display image in canvas and pad ;  imgconv.C Open rose512.jpg and save it in the following formats: .png, .gif, .xpm and tiff ;  pad2png.C Create a canvas and save as png ;  rose_image.C Display image in a new canvas and pad ;  trans_graph.C Demonstrates how to access and manipulate ARGB pixel values of an image +.. ;  ► io;  copyFiles.C Example of script showing how to copy all objects (including directories) from a source file ;  dirs.C This macro illustrates how to create a hierarchy of directories in a Root file ;  double32.C Tutorial illustrating use and precision of the Double32_t data type Yo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:126892,access,access,126892,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['access'],['access']
Security,"hod TWebFile::SetProxy(). Basic authentication (AuthType Basic) is supported. The user name and passwd can be specified in the url like this: http://username:mypasswd@pcsalo.cern.ch/files/aap.root If the file specified in the URL does not exist or is not accessible the kZombie bit will be set in the TWebFile object. Use IsZombie() to see if the file is accessible. The preferred interface to this constructor is via TFile::Open(). ; Definition at line 146 of file TWebFile.cxx. ◆ TWebFile() [3/3]. TWebFile::TWebFile ; (; TUrl ; url, . Option_t * ; opt = """" . ). Create a Web file object. ; A web file is the same as a read-only TFile except that it is being read via a HTTP server. Make sure url is a valid TUrl object. The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell variable. The proxy can be specified as (in sh, or equivalent csh): export http_proxy=http://pcsalo.cern.ch:3128 The proxy can also be specified via the static method TWebFile::SetProxy(). Basic authentication (AuthType Basic) is supported. The user name and passwd can be specified in the url like this: http://username:mypasswd@pcsalo.cern.ch/files/aap.root If the file specified in the URL does not exist or is not accessible the kZombie bit will be set in the TWebFile object. Use IsZombie() to see if the file is accessible. ; Definition at line 181 of file TWebFile.cxx. ◆ ~TWebFile(). TWebFile::~TWebFile ; (; ). virtual . Cleanup. ; Definition at line 199 of file TWebFile.cxx. Member Function Documentation. ◆ BasicAuthentication(). TString TWebFile::BasicAuthentication ; (; ). protectedvirtual . Return basic authentication scheme, to be added to the request. ; Definition at line 1385 of file TWebFile.cxx. ◆ CheckProxy(). void TWebFile::CheckProxy ; (; ). protectedvirtual . Check if shell var ""http_proxy"" has been set and should be used. ; Definition at line 353 of file TWebFile.cxx. ◆ Class(). static TClass * TWebFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:45165,authenticat,authentication,45165,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['authenticat'],['authentication']
Security,"hod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tTGenCollectionProxy::fCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tTGenCollectionProxy::fConstructContainer accessors: block construct; map<string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tTGenCollectionProxy::fDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*TGenCollectionProxy::fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tTGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::fFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::fFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::fFunctionDeleteIterator; TVirtualCollectionProxy::DeleteTwoIterators_tTGenCollectionProxy::fFunctionDeleteTwoIterators; TVirtualCollectionProxy::Next_tTGenCollectionProxy::fFunctionNextIterator; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextContainer accessors: generic iteration: next; TClass*TGenCollectionProxy::fOnFileClassOn file class; Bool_tTGenCollectionProxy::fPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; TGenCollectionProxy::Proxies_tTGenCollectionProxy::fProxyKeptOptimization: Keep proxies once they were created; TGenCollectionProxy::Proxies_tTGenCollectionProxy::fProxyListStack of recursive proxies; TObjArray*TGenCollectio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEmulatedCollectionProxy.html:5451,access,accessors,5451,root/html602/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TEmulatedCollectionProxy.html,12,['access'],['accessors']
Security,"hod returning the RSA public keys. ;  ; static THostAuth * HasHostAuth (const char *host, const char *user, Option_t *opt=""R"");  Checks if a THostAuth with exact match for {host,user} exists in the fgAuthInfo list If opt = ""P"" use ProofAuthInfo list instead Returns pointer to it or 0. ;  ; static void InitRandom ();  Initialize random machine using seed from /dev/urandom (or current time if /dev/urandom not available). ;  ; static void MergeHostAuthList (TList *Std, TList *New, Option_t *Opt="""");  Tool for updating fgAuthInfo or fgProofAuthInfo 'nin' contains list of last input information through (re)reading of a rootauthrc-alike file. ;  ; static char * PromptPasswd (const char *prompt=""Password: "");  Static method to prompt for the user's passwd to be used for authentication to rootd or proofd. ;  ; static char * PromptUser (const char *remote);  Static method to prompt for the user name to be used for authentication to rootd or proofd. ;  ; static Int_t ReadRootAuthrc ();  Read authentication directives from $ROOTAUTHRC, $HOME/.rootauthrc or <Root_etc_dir>/system.rootauthrc and create related THostAuth objects. ;  ; static void RemoveHostAuth (THostAuth *ha, Option_t *opt="""");  Remove THostAuth instance from the list. ;  ; static Int_t SecureRecv (TSocket *Socket, Int_t dec, Int_t KeyType, char **Out);  Receive str from sock and decode it using key indicated by key type Return number of received bytes or -1 in case of error. ;  ; static Int_t SecureSend (TSocket *Socket, Int_t enc, Int_t KeyType, const char *In);  Encode null terminated str using the session private key indicated by enc and sends it over the network Returns number of bytes sent, or -1 in case of error. ;  ; static Int_t SendRSAPublicKey (TSocket *Socket, Int_t key=0);  Receives server RSA Public key Sends local RSA public key encoded. ;  ; static void SetAuthReUse (Bool_t authreuse);  Set global AuthReUse flag. ;  ; static void SetDefaultRSAKeyType (Int_t key);  Static method setting the default ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:13787,authenticat,authentication,13787,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"hodWithId ; (; DeclId_t ; faddr). private . Find a method with decl id in this class or its bases. ; Definition at line 4440 of file TClass.cxx. ◆ FindConversionStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const char * ; onfile_classname, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ; Definition at line 7193 of file TClass.cxx. ◆ FindConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const TClass * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7204 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7066 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7036 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4772 of file TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:67766,checksum,checksum,67766,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['checksum'],['checksum']
Security,"hodWithId ; (; DeclId_t ; faddr). private . Find a method with decl id in this class or its bases. ; Definition at line 4507 of file TClass.cxx. ◆ FindConversionStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const char * ; onfile_classname, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ; Definition at line 7260 of file TClass.cxx. ◆ FindConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const TClass * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7271 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7133 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7103 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4839 of file TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:67767,checksum,checksum,67767,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['checksum'],['checksum']
Security,"horization function. Automatically called when; libKrb5Auth is loaded. void SetGlobusAuthHook(GlobusAuth_t func); Set Globus authorization function. Automatically called when; libGlobusAuth is loaded. Int_t SshError(const char* errfile); SSH error parsing: returns; 0 : no error or fatal; 1 : should retry (eg 'connection closed by remote host'). Int_t SshAuth(TString& user); SSH client authentication code. const char * GetSshUser(TString user) const; Method returning the user to be used for the ssh login.; Looks first at SSH.Login and finally at env USER.; If SSH.LoginPrompt is set to 'yes' it prompts for the 'login name'. Bool_t CheckHost(const char* Host, const char* host); Check if 'host' matches 'href':; this means either equal or ""containing"" it, even with wild cards *; in the first field (in the case 'href' is a name, ie not IP address); Returns kTRUE if the two matches. Int_t RfioAuth(TString& user); UidGid client authentication code.; Returns 0 in case authentication failed; 1 in case of success; <0 in case of system error. Int_t ClearAuth(TString& user, TString& passwd, Bool_t& pwhash); UsrPwd client authentication code.; Returns 0 in case authentication failed; 1 in case of success. THostAuth * GetHostAuth(const char* host, const char* user = """", Option_t* opt = ""R"", Int_t* Exact = 0); Sets fUser=user and search fgAuthInfo for the entry pertaining to; (host,user), setting fHostAuth accordingly.; If opt = ""P"" use fgProofAuthInfo list instead; If no entry is found fHostAuth is not changed. THostAuth * HasHostAuth(const char* host, const char* user, Option_t* opt = ""R""); Checks if a THostAuth with exact match for {host,user} exists; in the fgAuthInfo list; If opt = ""P"" use ProofAuthInfo list instead; Returns pointer to it or 0. void FileExpand(const char* fin, FILE* ftmp); Expands include directives found in fexp files; The expanded, temporary file, is pointed to by 'ftmp'; and should be already open. To be called recursively. char * GetDefaultDetails(Int_t me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:17421,authenticat,authentication,17421,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,"hould be identified; non-sensitivity of the algorithm to continuous background; non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them; resolution, decomposition of doublets and multiplets. The algorithm should be able to recognise close positioned peaks.; ability to identify peaks with different sigma. References:; [1] M.A. Mariscotti: A method for identification of peaks in the presence of background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2] M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; [3] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376 (1996), 451. Examples of peak searching method; SearchHighRes function provides users with the possibility to vary the input parameters and with the access to the output deconvolved data in the destination spectrum. Based on the output data one can tune the parameters. Example 8 - Src.C; ; #include <TSpectrum2.h>; ; void Src(); {; const Int_t nbinsx = 64;; const Int_t nbinsy = 64;; std::vector<Double_t *> source(nbinsx), dest(nbinsx);; for (Int_t i = 0; i < nbinsx; i++) {; source[i] = new Double_t[nbinsy];; dest[i] = new Double_t[nbinsy];; }; TString dir = gROOT->GetTutorialDir();; TString file = dir + ""/spectrum/TSpectrum2.root"";; TFile *f = TFile::Open(file.Data());; gStyle->SetOptStat(0);; auto search = (TH2F *)f->Get(""search4"");; TSpectrum2 s;; for (Int_t i = 0; i < nbinsx; i++) {; for (Int_t j = 0; j < nbinsy; j++) {; source[i][j] = search->GetBinContent(i + 1, j + 1);; }; }; Int_t nfound = s.SearchHighRes(source.data(), dest.data(), nbinsx, nbinsy, 2, 5, kTRUE, 3, kFALSE, 3);; printf(""Found %d candidate peaks\n"", nfound);; Double_t *PositionX = s.GetPositionX();; Double_t *PositionY = s.GetP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2.html:36961,access,access,36961,doc/master/classTSpectrum2.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2.html,1,['access'],['access']
Security,"hows how to use the `@pythonization` decorator to add extra; 5## behaviour to C++ user classes that are used from Python via PyROOT.; 6##; 7## \macro_code; 8## \macro_output; 9##; 10## \date November 2021; 11## \author Enric Tejedor; 12 ; 13import ROOT; 14from ROOT import pythonization; 15 ; 16# Let's first define a new C++ class. In this tutorial, we will see how we can; 17# ""pythonize"" this class, i.e. how we can add some extra behaviour to it to; 18# make it more pythonic or easier to use from Python.; 19#; 20# Note: In this example, the class is defined dynamically for demonstration; 21# purposes, but it could also be a C++ class defined in some library or header.; 22# For more information about loading C++ user code to be used from Python with; 23# PyROOT, please see:; 24# https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; 25ROOT.gInterpreter.Declare('''; 26class MyClass {};; 27'''); 28 ; 29# Next, we define a pythonizor function: the function that will be responsible; 30# for injecting new behaviour in our C++ class `MyClass`.; 31#; 32# To convert a given Python function into a pythonizor, we need to decorate it; 33# with the @pythonization decorator. Such decorator allows us to define which; 34# which class we want to pythonize by providing its class name and its; 35# namespace (if the latter is not specified, it defaults to the global; 36# namespace, i.e. '::').; 37#; 38# The decorated function - the pythonizor - must accept either one or two; 39# parameters:; 40# 1. The class to be pythonized (proxy object where new behaviour can be; 41# injected); 42# 2. The fully-qualified name of that class (optional).; 43#; 44# Let's see all this with a simple example. Suppose I would like to define how; 45# `MyClass` objects are represented as a string in Python (i.e. what would be; 46# shown when I print that object). For that purpose, I can define the following; 47# pythonizor function. There are two important things to b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html:1356,inject,injecting,1356,doc/master/pyroot002__pythonizationDecorator_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html,1,['inject'],['injecting']
Security,"hr resource. For example, we don't use; http://mybucket.s3.amazonaws.com/path/to/my/file but instead; http://s3.amazonaws.com/mybucket/path/to/my/file so the HTTP request; will be of the form ""GET /mybucket/path/to/my/file HTTP/1.1""; Also note that the path must include the leading '/'. TString MakeHostHeader() const; Returns the 'Host' header to include in the HTTP request. TString MakeDateHeader() const; Returns the date header for this HTTP request. TString MakeAuthPrefix() const; Returns the authentication prefix. TString MakeAuthHeader(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns the authentication header for this HTTP request. TString GetRequest(TS3HTTPRequest::EHTTPVerb httpVerb, Bool_t appendCRLF = kTRUE); Returns the HTTP request ready to be sent to the server. TS3HTTPRequest& SetHost(const TString& host). TS3HTTPRequest& SetBucket(const TString& bucket). TS3HTTPRequest& SetObjectKey(const TString& objectKey). TS3HTTPRequest& SetAuthKeys(const TString& accessKey, const TString& secretKey). TS3HTTPRequest& SetAuthType(TS3HTTPRequest::EAuthType authType). TS3HTTPRequest& SetAccessKey(const TString& accessKey). TS3HTTPRequest& SetSecretKey(const TString& secretKey). virtual ~TS3HTTPRequest(); { }. EHTTPVerb GetHTTPVerb() const; { return fVerb; }. const TString& GetHost() const; { return fHost; }. const TString& GetBucket() const; { return fBucket; }. const TString& GetObjectKey() const; { return fObjectKey; }. const TString& GetTimeStamp() const; { return fTimeStamp; }. const TString& GetAccessKey() const; { return fAccessKey; }. const TString& GetSecretKey() const; { return fSecretKey; }. TString GetAuthType() const; { return fAuthType; }. » Author: Fabio Hernandez 30/01/2013 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3HTTPRequest.html:9779,access,accessKey,9779,root/html534/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html534/TS3HTTPRequest.html,1,['access'],['accessKey']
Security,"hr resource. For example, we don't use; http://mybucket.s3.amazonaws.com/path/to/my/file but instead; http://s3.amazonaws.com/mybucket/path/to/my/file so the HTTP request; will be of the form ""GET /mybucket/path/to/my/file HTTP/1.1""; Also note that the path must include the leading '/'. TString MakeHostHeader() const; Returns the 'Host' header to include in the HTTP request. TString MakeDateHeader() const; Returns the date header for this HTTP request. TString MakeAuthPrefix() const; Returns the authentication prefix. TString MakeAuthHeader(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns the authentication header for this HTTP request. TString GetRequest(TS3HTTPRequest::EHTTPVerb httpVerb, Bool_t appendCRLF = kTRUE); Returns the HTTP request ready to be sent to the server. TS3HTTPRequest& SetHost(const TString& host). TS3HTTPRequest& SetBucket(const TString& bucket). TS3HTTPRequest& SetObjectKey(const TString& objectKey). TS3HTTPRequest& SetAuthKeys(const TString& accessKey, const TString& secretKey). TS3HTTPRequest& SetAuthType(TS3HTTPRequest::EAuthType authType). TS3HTTPRequest& SetAccessKey(const TString& accessKey). TS3HTTPRequest& SetSecretKey(const TString& secretKey). virtual ~TS3HTTPRequest(); { }. EHTTPVerb GetHTTPVerb() const; { return fVerb; }. const TString& GetHost() const; { return fHost; }. const TString& GetBucket() const; { return fBucket; }. const TString& GetObjectKey() const; { return fObjectKey; }. const TString& GetTimeStamp() const; { return fTimeStamp; }. const TString& GetAccessKey() const; { return fAccessKey; }. const TString& GetSecretKey() const; { return fSecretKey; }. TString GetAuthType() const; { return fAuthType; }. » Author: Fabio Hernandez 30/01/2013 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TS3HTTPRequest.html:10505,access,accessKey,10505,root/html604/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html604/TS3HTTPRequest.html,1,['access'],['accessKey']
Security,"hr resource. For example, we don't use; http://mybucket.s3.amazonaws.com/path/to/my/file but instead; http://s3.amazonaws.com/mybucket/path/to/my/file so the HTTP request; will be of the form ""GET /mybucket/path/to/my/file HTTP/1.1""; Also note that the path must include the leading '/'. TString MakeHostHeader() const; Returns the 'Host' header to include in the HTTP request. TString MakeDateHeader() const; Returns the date header for this HTTP request. TString MakeAuthPrefix() const; Returns the authentication prefix. TString MakeAuthHeader(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns the authentication header for this HTTP request. TString GetRequest(TS3HTTPRequest::EHTTPVerb httpVerb, Bool_t appendCRLF = kTRUE); Returns the HTTP request ready to be sent to the server. TS3HTTPRequest& SetHost(const TString& host). TS3HTTPRequest& SetBucket(const TString& bucket). TS3HTTPRequest& SetObjectKey(const TString& objectKey). TS3HTTPRequest& SetAuthKeys(const TString& accessKey, const TString& secretKey). TS3HTTPRequest& SetAuthType(TS3HTTPRequest::EAuthType authType). TS3HTTPRequest& SetAccessKey(const TString& accessKey). TS3HTTPRequest& SetSecretKey(const TString& secretKey). virtual ~TS3HTTPRequest(); { }. EHTTPVerb GetHTTPVerb() const; { return fVerb; }. const TString& GetHost() const; { return fHost; }. const TString& GetBucket() const; { return fBucket; }. const TString& GetObjectKey() const; { return fObjectKey; }. const TString& GetTimeStamp() const; { return fTimeStamp; }. const TString& GetAccessKey() const; { return fAccessKey; }. const TString& GetSecretKey() const; { return fSecretKey; }. TString GetAuthType() const; { return fAuthType; }. » Author: Fabio Hernandez 30/01/2013 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3HTTPRequest.html:10505,access,accessKey,10505,root/html602/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html602/TS3HTTPRequest.html,1,['access'],['accessKey']
Security,"hrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ THashTable() [1/2]. THashTable::THashTable ; (; const THashTable & ; ). privatedelete . ◆ THashTable() [2/2]. THashTable::THashTable ; (; Int_t ; capacity = TCollection::kInitHashTableCapacity, . Int_t ; rehashlevel = 0 . ). Create a THashTable object. ; Capacity is the initial hashtable capacity (i.e. number of slots), by default kInitHashTableCapacity = 17, and rehashlevel is the value at which a rehash will be triggered. I.e. when the average size of the linked lists at a slot becomes longer than rehashlevel then the hashtable will be resized and refilled to reduce the collision rate to about 1. The higher the collision rate, i.e. the longer the linked lists, the longer lookup will take. If rehashlevel=0 the table will NOT automatically be rehashed. Use Rehash() for manual rehashing. ; Definition at line 43 of file THashTable.cxx. ◆ ~THashTable(). THashTable::~THashTable ; (; ). virtual . Delete a hashtable. ; Objects are not deleted unless the THashTable is the owner (set via SetOwner()). ; Definition at line 65 of file THashTable.cxx. Member Function Documentation. ◆ Add(). void THashTable::Add ; (; TObject * ; obj). overridevirtual . Add object to the hash table. ; Its position in the table will be determined by the value returned by its Hash() function. ; Implements TCollection.; Definition at line 92 of file THashTable.cxx. ◆ AddAll(). void THashTable::AddAll ; (; const TCollection * ; col). overridevirtual . Add all objects from collection col to this collection. ; Implemented for more efficient rehashing. ; Reimplemented from TCollection.; Definition at line 138 of file THashTable.cxx. ◆ AddBefore(). void THashTable::AddBefore ; (; const TObject * ; before, . TObject * ; obj . ). Add object to the hash table. ; Its position in the table will be determined by the value returned by its Hash() function. If and only if 'before' is in the same bucket as obj, obj is added in fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:17066,hash,hashtable,17066,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hashtable']
Security,"hrono::time_point<std::chrono::system_clock>. private . Definition at line 60 of file RWebWindow.hxx. Member Enumeration Documentation. ◆ EQueueEntryKind. enum ROOT::RWebWindow::EQueueEntryKind. private . Enumeratorkind_None ; kind_Connect ; kind_Data ; kind_Disconnect . Definition at line 124 of file RWebWindow.hxx. Constructor & Destructor Documentation. ◆ RWebWindow(). RWebWindow::RWebWindow ; (; ). RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler> ; Definition at line 76 of file RWebWindow.cxx. ◆ ~RWebWindow(). RWebWindow::~RWebWindow ; (; ). RWebWindow destructor Closes all connections and remove window from manager. ; Definition at line 85 of file RWebWindow.cxx. Member Function Documentation. ◆ _CanTrustIn(). bool RWebWindow::_CanTrustIn ; (; std::shared_ptr< WebConn > & ; conn, . const std::string & ; hash, . const std::string & ; ntry, . bool ; remote, . bool ; test_first_time . ). private . Check if provided hash, ntry parameters from the connection request could be accepted. ; Parameters. hash- provided hash value which should match with HMAC hash for generated before connection key ; ntry- connection attempt number provided together with request, must come in increasing order ; remote- boolean flag indicating if request comming from remote (via real http), for local displays like Qt5 or CEF simpler connection rules are applied ; test_first_time- true if hash/ntry tested for the first time, false appears only with websocket when connection accepted by server . Definition at line 513 of file RWebWindow.cxx. ◆ _MakeSendHeader(). std::string RWebWindow::_MakeSendHeader ; (; std::shared_ptr< WebConn > & ; conn, . bool ; txt, . const std::string & ; data, . int ; chid . ). private . Internal method to prepare text part of send data Should be called under locked connection mutex. ; Definition at line 1107 of file RWebWindow.cxx. ◆ AddDisplayHandle(). unsigned RWebWindow::AddDisplayHandle ; (; bool ; headless_mode, . co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:22926,hash,hash,22926,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['hash'],['hash']
Security,"hrono::time_point<std::chrono::system_clock>. private . Definition at line 62 of file RWebWindow.hxx. Member Enumeration Documentation. ◆ EQueueEntryKind. enum ROOT::RWebWindow::EQueueEntryKind. private . Enumeratorkind_None ; kind_Connect ; kind_Data ; kind_Disconnect . Definition at line 127 of file RWebWindow.hxx. Constructor & Destructor Documentation. ◆ RWebWindow(). RWebWindow::RWebWindow ; (; ). RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler> ; Definition at line 76 of file RWebWindow.cxx. ◆ ~RWebWindow(). RWebWindow::~RWebWindow ; (; ). RWebWindow destructor Closes all connections and remove window from manager. ; Definition at line 85 of file RWebWindow.cxx. Member Function Documentation. ◆ _CanTrustIn(). bool RWebWindow::_CanTrustIn ; (; std::shared_ptr< WebConn > & ; conn, . const std::string & ; hash, . const std::string & ; ntry, . bool ; remote, . bool ; test_first_time . ). private . Check if provided hash, ntry parameters from the connection request could be accepted. ; Parameters. hash- provided hash value which should match with HMAC hash for generated before connection key ; ntry- connection attempt number provided together with request, must come in increasing order ; remote- boolean flag indicating if request comming from remote (via real http), for local displays like Qt5 or CEF simpler connection rules are applied ; test_first_time- true if hash/ntry tested for the first time, false appears only with websocket when connection accepted by server . Definition at line 514 of file RWebWindow.cxx. ◆ _MakeSendHeader(). std::string RWebWindow::_MakeSendHeader ; (; std::shared_ptr< WebConn > & ; conn, . bool ; txt, . const std::string & ; data, . int ; chid . ). private . Internal method to prepare text part of send data Should be called under locked connection mutex. ; Definition at line 1140 of file RWebWindow.cxx. ◆ AddDisplayHandle(). unsigned RWebWindow::AddDisplayHandle ; (; bool ; headless_mode, . co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:22529,hash,hash,22529,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['hash'],['hash']
Security,"hrough the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__BinarySearchTree.html:7858,access,access,7858,root/html534/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html534/TMVA__BinarySearchTree.html,1,['access'],['access']
Security,"hrough the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__BinarySearchTree.html:7682,access,access,7682,root/html604/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html,1,['access'],['access']
Security,"hrough the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__BinarySearchTree.html:7674,access,access,7674,root/html602/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html602/TMVA__BinarySearchTree.html,1,['access'],['access']
Security,"hrough the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: BinarySearchTree.h 37399 2010-12-08 15:22:07Z evt $ » Last generated: 2010-12-08 16:56; This page has been au",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__BinarySearchTree.html:7839,access,access,7839,root/html528/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html528/TMVA__BinarySearchTree.html,1,['access'],['access']
Security,"http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address “http://localhost:8080” in any modern browser (IE9, Firefox, Chrome, Opera) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a snapshot (frozen copy) of such server, running in tutorials/http/httpserver.C macro from ROOT tutorial.; <iframe width=“800” height=“500” src=“https://root.cern.ch/js/3.6/httpserver.C/?layout=simple&item=Canvases/c1”> ; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following parameters are supported:. thrds=N - number of threads used by the civetweb (default is 5); top=name - configure top name, visible in the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain; loopback - bind specified port to loopback 127.0.0.1 address; debug - enable debug mode, server always returns html page with request info. If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does not starts with slash /, than top-name folder /Objects/ will be prepended. At any time one could unregister objects:; serv->Unregister(gr);; THttpServer does not take ownership over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be reg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:2185,authenticat,authentication,2185,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,2,['authenticat'],['authentication']
Security,hxx. ◆ GetDefaultEntry() [1/2]. ROOT::Experimental::REntry & ROOT::Experimental::RNTupleModel::GetDefaultEntry ; (; ). Definition at line 426 of file RNTupleModel.cxx. ◆ GetDefaultEntry() [2/2]. const ROOT::Experimental::REntry & ROOT::Experimental::RNTupleModel::GetDefaultEntry ; (; ); const. Definition at line 432 of file RNTupleModel.cxx. ◆ GetDescription(). const std::string & ROOT::Experimental::RNTupleModel::GetDescription ; (; ); const. inline . Definition at line 386 of file RNTupleModel.hxx. ◆ GetModelId(). std::uint64_t ROOT::Experimental::RNTupleModel::GetModelId ; (; ); const. inline . Definition at line 365 of file RNTupleModel.hxx. ◆ GetMutableField(). ROOT::Experimental::RFieldBase & ROOT::Experimental::RNTupleModel::GetMutableField ; (; std::string_view ; fieldName). Definition at line 406 of file RNTupleModel.cxx. ◆ GetMutableFieldZero(). ROOT::Experimental::RFieldZero & ROOT::Experimental::RNTupleModel::GetMutableFieldZero ; (; ). Mutable access to the root field is used to make adjustments to the fields. ; Definition at line 399 of file RNTupleModel.cxx. ◆ GetRegisteredSubfields(). const std::unordered_set< std::string > & ROOT::Experimental::RNTupleModel::GetRegisteredSubfields ; (; ); const. inline . Get the (qualified) names of subfields that have been registered to be included in entries from this model. ; Definition at line 390 of file RNTupleModel.hxx. ◆ GetSchemaId(). std::uint64_t ROOT::Experimental::RNTupleModel::GetSchemaId ; (; ); const. inline . Definition at line 366 of file RNTupleModel.hxx. ◆ GetToken(). ROOT::Experimental::REntry::RFieldToken ROOT::Experimental::RNTupleModel::GetToken ; (; std::string_view ; fieldName); const. Creates a token to be used in REntry methods to address a field present in the entry. ; Definition at line 470 of file RNTupleModel.cxx. ◆ IsBare(). bool ROOT::Experimental::RNTupleModel::IsBare ; (; ); const. inline . Definition at line 364 of file RNTupleModel.hxx. ◆ IsFrozen(). bool ROOT::Experimental::RNT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html:14900,access,access,14900,doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,1,['access'],['access']
Security,"hys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3443}; 3444 ; 3445 ; 3446static void; 3447mg_cry_internal_wrap(const struct mg_connection *conn,; 3448 struct mg_context *ctx,; 3449 const char *func,; 3450 unsigned line,; 3451 const char *fmt,; 3452 ...); 3453{; 3454 va_list ap;; 3455 va_start(ap, fmt);; 3456 if (!conn && ctx) {; 3457 struct m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:101807,access,access,101807,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"hys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3444}; 3445 ; 3446 ; 3447static void; 3448mg_cry_internal_wrap(const struct mg_connection *conn,; 3449 struct mg_context *ctx,; 3450 const char *func,; 3451 unsigned line,; 3452 const char *fmt,; 3453 ...); 3454{; 3455 va_list ap;; 3456 va_start(ap, fmt);; 3457 if (!conn && ctx) {; 3458 struct m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:101839,access,access,101839,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"i (M &m) const;  obtain the inverse of the decomposed matrix L ;  ; template<typename G > ; bool Invert (G *m) const;  place the inverse into m ;  ; template<class M > ; bool Invert (M &m) const;  place the inverse into m ;  ; bool ok () const;  returns true if decomposition was successful ;  ;  operator bool () const;  returns true if decomposition was successful ;  ; template<class V > ; bool Solve (V &rhs) const;  solves a linear system for the given right hand side ;  . Private Attributes; F fL [N *(N+1)/2];  lower triangular matrix L ;  ; bool fOk;  flag indicating a successful decomposition ;  . #include <Math/CholeskyDecomp.h>; Constructor & Destructor Documentation. ◆ CholeskyDecomp() [1/2]. template<class F , unsigned N> . template<class M > . ROOT::Math::CholeskyDecomp< F, N >::CholeskyDecomp ; (; const M & ; m). inline . perform a Cholesky decomposition ; perform a Cholesky decomposition of a symmetric positive definite matrix m; this is the constructor to uses with an SMatrix (and objects that behave like an SMatrix in terms of using operator()(int i, int j) for access to elements) ; Definition at line 94 of file CholeskyDecomp.h. ◆ CholeskyDecomp() [2/2]. template<class F , unsigned N> . template<typename G > . ROOT::Math::CholeskyDecomp< F, N >::CholeskyDecomp ; (; G * ; m). inline . perform a Cholesky decomposition ; perform a Cholesky decomposition of a symmetric positive definite matrix m; this is the constructor to use in special applications where plain arrays are used; NOTE: the matrix is given in packed representation, matrix element m(i,j) (j <= i) is supposed to be in array element (i * (i + 1)) / 2 + j ; Definition at line 112 of file CholeskyDecomp.h. Member Function Documentation. ◆ getL() [1/2]. template<class F , unsigned N> . template<typename G > . bool ROOT::Math::CholeskyDecomp< F, N >::getL ; (; G * ; m); const. inline . obtain the decomposed matrix L ; Returnsif the decomposition was successful; NOTE: the matrix is given in packed re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1CholeskyDecomp.html:3171,access,access,3171,doc/master/classROOT_1_1Math_1_1CholeskyDecomp.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1CholeskyDecomp.html,1,['access'],['access']
Security,"i(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHtml.html:33698,expose,expose,33698,root/html528/TGHtml.html,https://root.cern,https://root.cern/root/html528/TGHtml.html,6,['expose'],['expose']
Security,"i> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); Creates URI for the dataset manger in the form '[[/dsGroup/]dsUser/]dsName[#dsObjPath]',; The optional dsObjPath can be in the form [subdir/]objname]'. Bool_t ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); Parses a (relative) URI that describes a DataSet on the cluster.; The input 'uri' should be in the form '[[/group/]user/]dsname[#[subdir/]objname]',; where 'objname' is the name of the object (e.g. the tree name) and the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManager.html:13954,checksum,checksum,13954,root/html528/TDataSetManager.html,https://root.cern,https://root.cern/root/html528/TDataSetManager.html,6,['checksum'],['checksum']
Security,"iagCounts for all channels. More...;  ; class  RLogScopedDiagCount;  Object to count the number of warnings and errors emitted by a section of code, after construction of this type. More...;  ; class  RLogScopedVerbosity;  Change the verbosity level (global or specific to the RLogChannel passed to the constructor) for the lifetime of this object. More...;  ; class  RMapField;  Template specializations for C++ std::[unordered_][multi]map. More...;  ; class  RMenuItems;  List of items for object context menu. More...;  ; class  RNTupleChainProcessor;  Processor specializiation for vertically concatenated RNTuples (chains). More...;  ; class  RNTupleClusterRange;  Used to loop over entries of collections in a single cluster. More...;  ; class  RNTupleCollectionView;  A view for a collection, that can itself generate new ntuple views for its nested fields. More...;  ; class  RNTupleDescriptor;  The on-storage meta-data of an ntuple. More...;  ; class  RNTupleDirectAccessView;  A view variant that provides direct access to the I/O buffers. More...;  ; class  RNTupleDS;  The RDataSource implementation for RNTuple. More...;  ; class  RNTupleFillContext;  A context for filling entries (data) into clusters of an RNTuple. More...;  ; class  RNTupleFillStatus;  A status object after filling an entry. More...;  ; class  RNTupleFormatter;  Contains helper functions for RNTupleReader::PrintInfo() and RPrintSchemaVisitor::VisitField() More...;  ; class  RNTupleGlobalRange;  Used to loop over indexes (entries or collections) between start and end. More...;  ; class  RNTupleImporter;  Converts a TTree into an RNTuple. More...;  ; class  RNTupleInspector;  Inspect on-disk and storage-related information of an RNTuple. More...;  ; struct  RNTupleLocator;  Generic information about the physical location of data. More...;  ; struct  RNTupleLocatorObject64;  RNTupleLocator payload that is common for object stores using 64bit location information. More...;  ; class  RNTupleModel;  The RNT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html:18062,access,access,18062,doc/master/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html,1,['access'],['access']
Security,"iagram for THashList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ THashList() [1/3]. THashList::THashList ; (; const THashList & ; ). privatedelete . ◆ THashList() [2/3]. THashList::THashList ; (; Int_t ; capacity = TCollection::kInitHashTableCapacity, . Int_t ; rehash = 0 . ). Create a THashList object. ; Capacity is the initial hashtable capacity (i.e. number of slots), by default kInitHashTableCapacity = 17, and rehash is the value at which a rehash will be triggered. I.e. when the average size of the linked lists at a slot becomes longer than rehash then the hashtable will be resized and refilled to reduce the collision rate to about 1. The higher the collision rate, i.e. the longer the linked lists, the longer lookup will take. If rehash=0 the table will NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!! If the name of an object in the HashList is modified, The hashlist must be Rehashed ; Definition at line 43 of file THashList.cxx. ◆ THashList() [3/3]. THashList::THashList ; (; TObject * ; parent, . Int_t ; capacity = TCollection::kInitHashTableCapacity, . Int_t ; rehash = 0 . ). For backward compatibility only. Use other ctor. ; Definition at line 51 of file THashList.cxx. ◆ ~THashList(). THashList::~THashList ; (; ). virtual . Delete a hashlist. ; Objects are not deleted unless the THashList is the owner (set via SetOwner()). ; Definition at line 60 of file THashList.cxx. Member Function Documentation. ◆ AddAfter() [1/2]. void THashList::AddAfter ; (; const TObject * ; after, . TObject * ; obj . ). overridevirtual . Insert object after object after in the list. ; Implements TSeqCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, and TSelectorList.; Definition at line 143 of file THashList.cxx. ◆ AddAfter() [2/2]. void THashList::AddAfter ; (; TObjLink * ; after",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:23149,hash,hashlist,23149,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['hash'],['hashlist']
Security,ial macro #802 ;  rf803_mcstudy_addons2.C 'VALIDATION AND MC STUDIES' RooFit tutorial macro #803 ;  rf804_mcstudy_constr.C 'VALIDATION AND MC STUDIES' RooFit tutorial macro #804 ;  rf901_numintconfig.C 'NUMERIC ALGORITHM TUNING' RooFit tutorial macro #901 ;  rf901_numintconfig.py;  rf902_numgenconfig.C 'NUMERIC ALGORITHM TUNING' RooFit tutorial macro #902 ;  rf902_numgenconfig.py;  rf903_numintcache.C 'NUMERIC ALGORITHM TUNING' RooFit tutorial macro #903 ;  rf903_numintcache.py;  ► roostats;  CreateExampleFile.C;  FourBinInstructional.C This example is a generalization of the on/off problem ;  HybridInstructional.C Example demonstrating usage of HybridCalcultor ;  HybridOriginalDemo.C Example on how to use the HybridCalculatorOriginal class ;  HybridStandardForm.C A hypothesis testing example based on number counting with background uncertainty ;  IntervalExamples.C Example showing confidence intervals with four techniques ;  JeffreysPriorDemo.C tutorial demonstrating and validates the RooJeffreysPrior class ;  ModelInspector.CRooStats Model Inspector ;  MultivariateGaussianTest.C Comparison of MCMC and PLC in a multi-variate gaussian problem ;  NuMuToNuE_Oscillation.cxx;  NuMuToNuE_Oscillation.h;  OneSidedFrequentistUpperLimitWithBands.C OneSidedFrequentistUpperLimitWithBands ;  rs101_limitexample.C 'Limit Example' RooStats tutorial macro #101 This tutorial shows an example of creating a simple model for a number counting experiment with uncertainty on both the background rate and signal efficiency ;  rs102_hypotestwithshapes.C rs102_hypotestwithshapes for RooStats project ;  rs301_splot.C SPlot tutorial ;  rs401c_FeldmanCousins.C Produces an interval on the mean signal in a number counting experiment with known background using the Feldman-Cousins technique ;  rs401d_FeldmanCousins.C 'Neutrino Oscillation Example from Feldman & Cousins' ;  rs601_HLFactoryexample.C 'High Level Factory Example' RooStats tutorial macro #601 ;  rs602_HLFactoryCombinationexample.C 'Hig,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:159060,validat,validates,159060,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['validat'],['validates']
Security,"ial values and before actual fit is performed. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2MCSModule.html:3234,hash,hash,3234,doc/master/classRooChi2MCSModule.html,https://root.cern,https://root.cern/doc/master/classRooChi2MCSModule.html,3,['hash'],['hash']
Security,"ialGradient (const Point &center, Double_t radius);  Set radial gradient. ;  ; void SetStartEndR1R2 (const Point &p1, Double_t r1, const Point &p2, Double_t r2);  Set start and end R1 and R2. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  TColorGradient ();  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Color_t *colorIndices, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Double_t *colors, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  Public Member Functions inherited from TColorGradient;  TColorGradient ();  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Color_t *colorIndices, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Double_t *colors, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ; Double_t GetColorAlpha (UInt_t indx) const;  Return alpha parameter of selected color. ;  ; const Double_t * GetColorPositions () const;  Get color positions. ;  ; const Double_t * GetColors () const;  Get colors. ;  ; ECoordinateMode GetCoordinateMode () const;  Get coordinate mode. ;  ; SizeType_t GetNumberOfSteps () const;  Get number of steps. ;  ; void ResetColor (UInt_t nPoints, const Double_t *points, const Color_t *colorIndices);  Reset color. ;  ; void ResetColor (UInt_t nPoints, const Double_t *points, const Double_t *colorIndices);  Reset color. ;  ; void SetColorAlpha (UInt_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRadialGradient.html:2730,validat,validate,2730,doc/master/classTRadialGradient.html,https://root.cern,https://root.cern/doc/master/classTRadialGradient.html,1,['validat'],['validate']
Security,"ialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random starting parameters. void ReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); copy parameters. void GenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); generate adjacent parameters. std::vector<Double_t> GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); generate adjacent parameters. void GenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); generate new temperature. Bool_t ShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature); result checker. void SetDefaultScale(); setting of default scale. Double_t GenerateMaxTemperature(vector<Double_t>& parameters); maximum temperature. Double_t Minimize(vector<Double_t>& parameters); minimisation algorithm. SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges). void SetMaxCalls(Int_t mc); accessors. { fMaxCalls = mc; }. void SetInitTemp(Double_t it); { fInitialTemperature = it; }. void SetMinTemp(Double_t min); { fMinTemperature = min; }. void SetAccuracy(Double_t eps); { fEps = eps; }. void SetTemperatureScale(Double_t scale); { fTemperatureScale = scale; }. void SetAdaptiveSpeed(Double_t speed); { fAdaptiveSpeed = speed; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk » Copyright (c) 2008: *; » Last changed: root/tmva $Id: SimulatedAnnealing.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__SimulatedAnnealing.html:4368,access,accessors,4368,root/html530/TMVA__SimulatedAnnealing.html,https://root.cern,https://root.cern/root/html530/TMVA__SimulatedAnnealing.html,1,['access'],['accessors']
Security,"ialisation called by all constructors. ~MethodCFMlpANN( void ); destructor. void Train( void ); training of the Clement-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input variables. void NN_ava(Double_t* ); auxiliary functions. Double_t NN_fonc(Int_t , Double_t ) const; activation function. void ReadWeightsFromStream(istream& istr); read back the weight from the training from file (stream). Int_t DataInterface(Double_t* , Double_t* , Int_t* , Int_t* , Int_t* , Int_t* , Double_t* , Int_t* , Int_t* ); data interface function. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); read weights from xml file. void PrintWeights(ostream& o) const; write the weights of the neural net. TMVA::MethodCFMlpANN* This( void ); static pointer to this object (required for external functions. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific classifier response for header. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". Double_t GetData(Int_t isel, Int_t ivar) const; data accessors for external functions. { return (*fData)(isel, ivar); }. Int_t GetClass(Int_t ivar) const; { return (*fClass)[ivar]; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodCFMlpANN.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html:23734,access,accessors,23734,root/html528/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html,1,['access'],['accessors']
Security,"ializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFoam.html:15830,access,access,15830,root/html528/TFoam.html,https://root.cern,https://root.cern/root/html528/TFoam.html,6,['access'],['access']
Security,"ian function with mean and sigma. ;  ; constexpr Double_t TMath::Gcgs ();  \( cm^{3} g^{-1} s^{-2} \) ;  ; template<typename Iterator > ; Double_t TMath::GeomMean (Iterator first, Iterator last);  Returns the geometric mean of an array defined by the iterators. ;  ; template<typename T > ; Double_t TMath::GeomMean (Long64_t n, const T *a);  Returns the geometric mean of an array a of size n. ;  ; constexpr Double_t TMath::GhbarC ();  \( \frac{G}{\hbar C} \) in \( (GeV/c^{2})^{-2} \) ;  ; constexpr Double_t TMath::GhbarCUncertainty ();  \( \frac{G}{\hbar C} \) uncertainty. ;  ; constexpr Double_t TMath::Gn ();  Standard acceleration of gravity in \( m s^{-2} \). ;  ; constexpr Double_t TMath::GnUncertainty ();  Standard acceleration of gravity uncertainty. ;  ; constexpr Double_t TMath::GUncertainty ();  Gravitational constant uncertainty. ;  ; constexpr Double_t TMath::H ();  Planck's constant in \( J s \): \( h \). ;  ; ULong_t TMath::Hash (const char *str);  ; ULong_t TMath::Hash (const void *txt, Int_t ntxt);  Calculates hash index from any char string. ;  ; constexpr Double_t TMath::Hbar ();  \( \hbar \) in \( J s \): \( \hbar = \frac{h}{2\pi} \) ;  ; constexpr Double_t TMath::Hbarcgs ();  \( erg s \) ;  ; constexpr Double_t TMath::HbarUncertainty ();  \( \hbar \) uncertainty. ;  ; constexpr Double_t TMath::HC ();  \( hc \) in \( J m \) ;  ; constexpr Double_t TMath::HCcgs ();  \( erg cm \) ;  ; constexpr Double_t TMath::Hcgs ();  \( erg s \) ;  ; constexpr Double_t TMath::HUncertainty ();  Planck's constant uncertainty. ;  ; Double_t TMath::Hypot (Double_t x, Double_t y);  Returns sqrt(x*x + y*y) ;  ; Long_t TMath::Hypot (Long_t x, Long_t y);  Returns sqrt(x*x + y*y) ;  ; Double_t TMath::Infinity ();  Returns an infinity as defined by the IEEE standard. ;  ; constexpr Double_t TMath::InvPi ();  \( \frac{1.}{\pi}\) ;  ; template<typename T > ; Bool_t TMath::IsInside (T xp, T yp, Int_t np, T *x, T *y);  Function which returns kTRUE if point xp,yp lies inside the p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h.html:8661,hash,hash,8661,doc/master/TMath_8h.html,https://root.cern,https://root.cern/doc/master/TMath_8h.html,1,['hash'],['hash']
Security,"ibTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedReal.html:36504,access,access,36504,root/html602/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedReal.html,6,['access'],['access']
Security,"ibraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTable.html:9485,hash,hash,9485,root/html534/THashTable.html,https://root.cern,https://root.cern/root/html534/THashTable.html,3,['hash'],['hash']
Security,"ibutes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:42657,access,access,42657,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,80,['access'],['access']
Security,"ic Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TDCacheFile.h>. Inheritance diagram for TDCacheFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EOnErrorAction. enum TDCacheFile::EOnErrorAction. Note: This must be kept in sync with values #defined in dcap.h. . EnumeratorkOnErrorRetry ; kOnErrorFail ; kOnErrorDefault . Definition at line 61 of file TDCacheFile.h. Constructor & Destructor Documentation. ◆ TDCacheFile() [1/2]. TDCacheFile::TDCacheFile ; (; ). inlineprivate . Definition at line 31 of file TDCacheFile.h. ◆ TDCacheFile() [2/2]. TDCacheFile::TDCacheFile ; (; const char * ; path, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault . ). Create a dCache file object. ; A dCache file is the same as a TFile except that it is being accessed via a dCache server. The url argument must be of the form: dcache:/pnfs/<path>/<file>.root or dcap://<nodename.org>/<path>/<file>.root. If the file specified in the URL does not exist, is not accessable or can not be created the kZombie bit will be set in the TDCacheFile object. Use IsZombie() to see if the file is accessable. For a description of the option and other arguments see the TFile ctor. The preferred interface to this constructor is via TFile::Open(). ; Definition at line 71 of file TDCacheFile.cxx. ◆ ~TDCacheFile(). TDCacheFile::~TDCacheFile ; (; ). override . Close and cleanup dCache file. ; Definition at line 202 of file TDCacheFile.cxx. Member Function Documentation. ◆ CheckFile(). Bool_t TDCacheFile::CheckFile ; (; const char * ; path, . const char * ; location = 0 . ). static . CheckFile() returns kTRUE on success and kFALSE on failure. ; In case the file exists but is not cached, CheckFile() returns kFALSE and errno is set to EAGAIN. ; Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:43236,access,accessed,43236,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['access'],['accessed']
Security,"ic TDocParser::(anonymous)kClassDoc_Written; static TDocParser::EDocContextkDocClass; static TDocParser::EDocContextkDocFunc; static TDocParser::EDocContextkIgnore; static TDocParser::EDocContextkNumDocContexts. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDocParser(TClassDocOutput& docOutput, TClass* cl); Constructor called for parsing class sources. TDocParser(TDocOutput& docOutput); constructor called for parsing text files with Convert(). ~TDocParser(); destructor, checking whether all methods have been found for gDebug > 3. void AddClassMethodsRecursively(TBaseClass* bc); Add accessible (i.e. non-private) methods of base class bc; and its base classes' methods to methodNames.; If bc==0, we add fCurrentClass's methods (and also private functions). void AddClassDataMembersRecursively(TBaseClass* bc); Add data members of fCurrentClass and of bc to datamembers, recursively.; Real data members are in idx 0..2 (public, protected, private access),; enum constants in idx 3..5. void AnchorFromLine(const TString& line, TString& anchor); Create an anchor from the given line, by hashing it and; convertig the hash into a custom base64 string. void Convert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); Parse text file ""in"", add links etc, and write output to ""out"".; If ""isCode"", ""in"" is assumed to be C++ code. void DecorateKeywords(ostream& out, const char* text); Expand keywords in text, writing to out. void DecorateKeywords(TString& text); Find keywords in line and create URLs around them. Escape characters with a; special meaning for HTML. Protect ""Begin_Html""/""End_Html"" pairs, and set the; parsing context. Evaluate sequences like a::b->c.; Skip regions where directives are active. void DecrementMethodCount(const char* name); reduce method count for method called name,; removing it from fMethodCounts once the count reaches 0. void DeleteDirectiveOutput() const; Delete output genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDocParser.html:12860,access,access,12860,root/html602/TDocParser.html,https://root.cern,https://root.cern/root/html602/TDocParser.html,2,['access'],['access']
Security,"ic TGenVectorProxy {; 191public:; 192 // Standard Destructor; 193 TGenListProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 194 {; 195 }; 196 // Standard Destructor; 197 ~TGenListProxy() override; 198 {; 199 }; 200 // Return the address of the value at index 'idx'; 201 void* At(UInt_t idx) override; 202 {; 203 if ( fEnv && fEnv->fObject ) {; 204 switch( idx ) {; 205 case 0:; 206 fEnv->fIdx = idx;; 207 return fEnv->fStart = fFirst.invoke(fEnv);; 208 default: {; 209 fEnv->fIdx = idx - fEnv->fIdx;; 210 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 211 void* result = fNext.invoke(fEnv);; 212 fEnv->fIdx = idx;; 213 return result;; 214 }; 215 }; 216 }; 217 Fatal(""TGenListProxy"",""At> Logic error - no proxy object set."");; 218 return nullptr;; 219 }; 220};; 221 ; 222/**; 223\class TGenSetProxy; 224\ingroup IO; 225Localoptimization class.; 226 ; 227Collection proxies get copied. On copy we switch the type of the; 228proxy to the concrete STL type. The concrete types are optimized; 229for element access.; 230*/; 231 ; 232class TGenSetProxy : public TGenVectorProxy {; 233public:; 234 // Standard Destructor; 235 TGenSetProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 236 {; 237 }; 238 // Standard Destructor; 239 ~TGenSetProxy() override; 240 {; 241 }; 242 // Return the address of the value at index 'idx'; 243 void* At(UInt_t idx) override; 244 {; 245 if ( fEnv && fEnv->fObject ) {; 246 if ( fEnv->fUseTemp ) {; 247 return (((char*)fEnv->fTemp)+idx*fValDiff);; 248 }; 249 switch( idx ) {; 250 case 0:; 251 fEnv->fIdx = idx;; 252 return fEnv->fStart = fFirst.invoke(fEnv);; 253 default: {; 254 fEnv->fIdx = idx - fEnv->fIdx;; 255 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 256 void* result = fNext.invoke(fEnv);; 257 fEnv->fIdx = idx;; 258 return result;; 259 }; 260 }; 261 }; 262 Fatal(""TGenSetProxy"",""At> Logic error - no proxy object set."");; 263 return nullptr;; 264 }; 265};; 266 ; 267/**; 268\class TGenMapProxy; 269\ingroup IO; 270Localoptim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:6556,access,access,6556,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['access'],['access']
Security,"ic TObject::(anonymous)TObject::kZombie. protected:. Bool_tTAttImage::fConstRatiokeep aspect ratio of image on the screen; Bool_tfEditable! kTRUE image can be resized, moved by resizing/moving gPad; ASImage*fGrayImage! gray image; ASImage*fImage! pointer to image structure of original image; UInt_tTAttImage::fImageCompressioncompression [0 .. 100] 0: no compression; TAttImage::EImageQualityTAttImage::fImageQuality*OPTION={GetMethod=""GetImageQuality"";SetMethod=""SetImageQuality"";Items=(kImgDefault=""Default"",kImgPoor=""Poor"",kImgFast=""Fast"",kImgGood=""Good"",kImgBest=""Best"")}*; Bool_tfIsGray! kTRUE if image is gray; Double_tfMaxValue! max value in image; Double_tfMinValue! min value in image; TStringTNamed::fNameobject identifier; Int_tfPaintMode! 1 - fast mode, 0 - low memory slow mode; TImagePaletteTAttImage::fPalettecolor palette for value -> color conversion; TPaletteEditor*TAttImage::fPaletteEditor! GUI to edit the color palette; Bool_tTAttImage::fPaletteEnabled! kTRUE - palette is drawn on the image; TASImage*fScaledImage! temporary scaled and zoomed image produced from original image; TStringTNamed::fTitleobject title; UInt_tfZoomHeight! hight of zoomed image in image pixels; UInt_tfZoomOffX! X - offset for zooming in image pixels; UInt_tfZoomOffY! Y - offset for zooming im image pixels; Int_tfZoomUpdate! kZoom - new zooming required, kZoomOps - other ops in action, kNoZoom - no zooming or ops; UInt_tfZoomWidth! width of zoomed image in image pixels; static Bool_tfgInitglobal flag to init afterimage only once; static THashTable*fgPlugList! hash table containing loaded plugins; static ASVisual*fgVisualpointer to visual structure. private:. static TASImage::(anonymous)kNoZoom; static TASImage::(anonymous)kReadWritePNG; static TASImage::(anonymous)kReadWriteVector; static TASImage::(anonymous)kZoom; static TASImage::(anonymous)kZoomOps. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DestroyImage(); Destroy image. void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TASImage.html:20782,hash,hash,20782,root/html602/TASImage.html,https://root.cern,https://root.cern/root/html602/TASImage.html,2,['hash'],['hash']
Security,"ic const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextContainer accessors: generic iteration: next; TClass*TGenCollectionProxy::fOnFileClassOn file class; Bool_tTGenCollectionProxy::fPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >TGenCollectionProxy::fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >TGenCollectionProxy::fProxyListStack of recursive proxies; TObjArray*TGenCollectionProxy::fReadMemberWiseArray of bundle of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEmulatedCollectionProxy.html:4784,access,accessors,4784,root/html528/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TEmulatedCollectionProxy.html,18,['access'],['accessors']
Security,"ic const Int_t fgIteratorArenaSize = 16;  The size of a small buffer that can be allocated on the stack to store iterator-specific information. ;  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:11404,access,accessors,11404,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,2,['access'],['accessors']
Security,"ic help message]; : InputLayout: ""1|1|7"" [The Layout of the input]; : BatchLayout: ""1|128|7"" [The Layout of the batch]; : Layout: ""DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,MaxEpochs=20,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,ADAM_beta1=0.9,ADAM_beta2=0.999,ADAM_eps=1.E-7,DropConfig=0.0+0.0+0.0+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'm_jj' <---> Output : variable 'm_jj'; : Input : variable 'm_jjj' <---> Output : variable 'm_jjj'; : Input : variable 'm_lv' <---> Output : variable 'm_lv'; : Input : variable 'm_jlv' <---> Output : variable 'm_jlv'; : Input : variable 'm_bb' <---> Output : variable 'm_bb'; : Input : variable 'm_wbb' <---> Output : variable 'm_wbb'; : Input : variable 'm_wwbb' <---> Output : variable 'm_wwbb'; : Will now use the CPU architecture with BLAS and IMT support !; Model: ""sequential""; __________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:13078,validat,validation,13078,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['validat'],['validation']
Security,"ic help message]; : InputLayout: ""1|1|7"" [The Layout of the input]; : BatchLayout: ""1|128|7"" [The Layout of the batch]; : Layout: ""DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|64|TANH,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,MaxEpochs=30,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,ADAM_beta1=0.9,ADAM_beta2=0.999,ADAM_eps=1.E-7,DropConfig=0.0+0.0+0.0+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'm_jj' <---> Output : variable 'm_jj'; : Input : variable 'm_jjj' <---> Output : variable 'm_jjj'; : Input : variable 'm_lv' <---> Output : variable 'm_lv'; : Input : variable 'm_jlv' <---> Output : variable 'm_jlv'; : Input : variable 'm_bb' <---> Output : variable 'm_bb'; : Input : variable 'm_wbb' <---> Output : variable 'm_wbb'; : Input : variable 'm_wwbb' <---> Output : variable 'm_wwbb'; : Will now use the CPU architecture with BLAS and IMT support !; Model: ""sequential""; __________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:13065,validat,validation,13065,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['validat'],['validation']
Security,"ic map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealSumPdf.html:39792,validat,validate,39792,root/html534/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html534/RooRealSumPdf.html,1,['validat'],['validate']
Security,"ic:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. TString_bnameName of the binning specification to be used to perform the mapping; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooRealProxy_inputVarInput variable that is mapped; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinningCategory.html:21431,access,access,21431,root/html534/RooBinningCategory.html,https://root.cern,https://root.cern/root/html534/RooBinningCategory.html,1,['access'],['access']
Security,"ical3D & operator=(const ROOT::Math::Cylindrical3D<double>& v). assignment operator. void SetCoordinates(const Scalar[] src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(Scalar[] dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar rho, ROOT::Math::Cylindrical3D<double>::Scalar zz, ROOT::Math::Cylindrical3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar& rho, ROOT::Math::Cylindrical3D<double>::Scalar& zz, ROOT::Math::Cylindrical3D<double>::Scalar& phi) const. get internal data into 3 Scalar numbers ( rho, z , phi). {rho=fRho; zz=fZ; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Rho() const; accessors. { return fRho; }. Scalar Z() const; { return fZ; }. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fRho*std::cos(fPhi); }. Scalar Y() const; { return fRho*std::sin(fPhi); }. Scalar Mag2() const; { return fRho*fRho + fZ*fZ; }. Scalar R() const; { return std::sqrt( Mag2()); }. Scalar Perp2() const; { return fRho*fRho; }. Scalar Theta() const; { return (fRho==0 && fZ==0 ) ? 0 : atan2(fRho,fZ); }. Scalar Eta() const; pseudorapidity - use same implementation as in Cartesian3D. void SetRho(double rho); setters (only for data members). set the rho coordinate value keeping z and phi constant. void SetZ(double zz). set the z coordinate value keeping rho and phi constant. void SetPhi(double phi). set the phi coordinate value keeping rho and z constant. void SetXYZ(ROOT::Math::Cylindrical3D<double>::Scalar x, ROOT::Math::Cylindrical3D<double>::Scalar y, ROOT::Math::Cylindrical3D<double>::Scalar z). set all values using cartesian coordinates. void Scale(double a).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Cylindrical3D_Double32_t_.html:3914,access,accessors,3914,root/html602/ROOT__Math__Cylindrical3D_Double32_t_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Cylindrical3D_Double32_t_.html,4,['access'],['accessors']
Security,"ically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. And when the tree is retrieved, the trees on the friends list are; also retrieved and the friendship restored.; When a tree is deleted, the elements of the friend list are also deleted.; It is possible to declare a friend tree that has the same internal; structure (same branches and leaves) as the original tree, and compare the; same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:39342,access,access,39342,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['access'],['access']
Security,"ically relevant peaks should be identified.; non-sensitivity of the algorithm to continuous background.; ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of Double_tts and multiplets. The algorithm should be able to recognise close positioned peaks.; ability to identify peaks with different sigma. Fig. 27 An example of one-dimensional synthetic spectrum with found peaks denoted by markers.; References:. M.A. Mariscotti: A method for identification of peaks in the presence of background and its application to spectrum analysis. NIM 50 (1967), 309-320.; M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376 (1996), 451. Examples of peak searching method:; The SearchHighRes function provides users with the possibility to vary the input parameters and with the access to the output deconvolved data in the destination spectrum. Based on the output data one can tune the parameters. Example 15 - script SearchHR1.C:; One-dimensional spectrum with found peaks denoted by markers, 3 iterations steps in the deconvolution.; Script:; ; void SearchHR1() {; Double_t fPositionX[100];; Double_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; const Int_t nbins = 1024;; Double_t xmin = 0;; Double_t xmax = nbins;; Double_t a;; Double_t source[nbins], dest[nbins];; gROOT->ForceStyle();; ; TString dir = gROOT->GetTutorialDir();; TString file = dir+""/spectrum/TSpectrum.root"";; TFile *f = new TFile(file.Data());; TH1F *h = (TH1F*) f->Get(""back2"");; h->SetTitle(""High resolution peak searching, number of iterations = 3"");; h->GetXaxis()->SetRange(1,nbins);; TH1F *d = new TH1F(""d"","""",nbins,xmin,xmax);; h->Draw(""L"");; ; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; ; h->Draw(""L"");; ; TSpectrum *s = ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum.html:58594,access,access,58594,doc/master/classTSpectrum.html,https://root.cern,https://root.cern/doc/master/classTSpectrum.html,1,['access'],['access']
Security,"ically updated at each frame in order to get the animation effect.; The option provided to all track-drawing methods can trigger different track selections:; default:A track (or all primary tracks) drawn without daughters; /D: Track and first level descendents only are drawn; /*: Track and all descendents are drawn; /Ntype: All tracks having name=type are drawn; Generally several options can be concatenated in the same string (E.g. ""/D /Npion-"").; For animating tracks, additional options can be added:; /G:Geometry animate. Generally when drawing or animating tracks, one has to first perform a normal drawing of the geometry as convenient. The tracks will be drawn over the geometry. The geometry itself will be animated (camera moving and rotating in order to ""catch"" the majority of current track segments.); /S:Save all frames in gif format in the current folder. This option allows creating a movie based on individual frames. Checking the Geometry; Several checking methods are accessible from the context menu of volume objects or of the manager class. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the TGeoChecker class. The checking package contains an overlap checker and several utility methods that generally have visualization outputs. The Overlap Checker; An overlap is any region in the Euclidian space being contained by more than one positioned volume. Due to the containment scheme used by the modeller, all points inside a volume have to be also contained by the mother therefore are overlapping in that sense. This category of overlaps is ignored due to the fact that any such point is treated as belonging to the deepest node in the hierarchy. Extruding volumes; A volume containment region is in fact the result of the subtraction of all daughters. On the other hand, there are two other categories of overlaps that are considered illegal since they lead to unpredictable results dur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:98647,access,accessible,98647,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['access'],['accessible']
Security,"ication code. ;  ; Int_t GenRSAKeys ();  Generate a valid pair of private/public RSA keys to protect for authentication token exchange. ;  ; Bool_t GetPwHash () const;  ; char * GetRandString (Int_t Opt, Int_t Len);  Allocates and fills a 0 terminated buffer of length len+1 with len random characters. ;  ; Int_t GetRSAKey () const;  ; ESecurity GetSecurity () const;  ; Bool_t GetSRPPwd () const;  ; const char * GetSshUser (TString user) const;  Method returning the user to be used for the ssh login (no longer supported) ;  ; Bool_t GetUserPasswd (TString &user, TString &passwd, Bool_t &pwhash, Bool_t srppwd);  Try to get user name and passwd from several sources. ;  ; Int_t GetVersion () const;  ; Int_t ProofAuthSetup ();  Authentication related stuff setup in TProofServ. ;  ; Int_t RfioAuth (TString &user);  RFIO authentication (no longer supported) ;  ; void SetEnvironment ();  Set default authentication environment. ;  ; Int_t SshAuth (TString &user);  SSH client authentication code (no longer supported) ;  ; Int_t SshError (const char *errfile);  . Static Private Member Functions; static Bool_t CheckHost (const char *Host, const char *host);  Check if 'host' matches 'href': this means either equal or ""containing"" it, even with wild cards * in the first field (in the case 'href' is a name, ie not IP address) Returns kTRUE if the two matches. ;  ; static void FileExpand (const char *fin, FILE *ftmp);  Expands include directives found in fexp files The expanded, temporary file, is pointed to by 'ftmp' and should be already open. ;  ; static Int_t ProofAuthSetup (TSocket *sock, Bool_t client);  Setup of authetication related stuff in PROOF run after a successful authentication. ;  ; static void RemoveSecContext (TRootSecContext *ctx);  Tool for removing SecContext ctx from THostAuth listed in fgAuthInfo or fgProofAuthInfo. ;  . Private Attributes; TString fDetails;  ; THostAuth * fHostAuth;  ; TString fPasswd;  ; TString fProtocol;  ; Bool_t fPwHash;  ; TString fRem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:17968,authenticat,authentication,17968,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"ication).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_CNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:InputLayout=1|16|16:Layout=CONV|10|3|3|1|1|1|1|RELU,BNORM,CONV|10|3|3|1|1|1|1|RELU,MAXPOOL|2|2|1|1,RESHAPE|FLAT,DENSE|100|RELU,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.0:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:InputLayout=1|16|16:Layout=CONV|10|3|3|1|1|1|1|RELU,BNORM,CONV|10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:4393,validat,validation,4393,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['validat'],['validation']
Security,"ice name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:22342,authenticat,authentication,22342,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,5,['authenticat'],['authentication']
Security,"ick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection. private:. THashTable*fTableHash table used to store TPair's. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); TMap ctor. See THashTable for a description of the arguments. ~TMap(); TMap dtor. Objects are not deleted unless the TMap is the; owner (set via SetOwner()). void Add(TObject* obj); This function may not be used (but we need to provide it since it is; a pure virtual in TCollection). Use Add(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMap.html:8868,hash,hashtable,8868,root/html528/TMap.html,https://root.cern,https://root.cern/root/html528/TMap.html,4,['hash'],['hashtable']
Security,"icon picture; TGPopupMenu*fPopupPopup menu associated to the title icon; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMdiTitleIcon(const TGWindow* p, const TGWindow* titlebar, const TGPicture* pic, Int_t w, Int_t h); TGMdiTitleIcon constructor.; the TGMdiTitleIcon is the left icon used also for the MDI; popup menu allowing access to MDI commands as : restore,; move, size, minimize and close. ~TGMdiTitleIcon(); TGMdiTitleIcon destructor. void DoRedraw(); Redraw icon. Bool_t HandleDoubleClick(Event_t* event); Handle double click event on MDI icon (close the window). Bool_t HandleButton(Event_t* event); Handle button event on MDI icon (popup menu). TGPopupMenu * GetPopup() const; { return fPopup; }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-04 16:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGMdiTitleIcon.html:17791,access,access,17791,root/html534/TGMdiTitleIcon.html,https://root.cern,https://root.cern/root/html534/TGMdiTitleIcon.html,1,['access'],['access']
Security,"ictFuncPtr_t dict, Int_t pragmabits);  Add a class to the class table (this is a static function). ;  ; static void Add (TProtoClass *protoClass);  Add a class to the class table (this is a static function). ;  ; static ROOT::TClassAlt * AddAlternate (const char *normname, const char *alternate);  ; static char * At (UInt_t index);  Returns class at index from sorted class table. ;  ; static Bool_t Check (const char *cname, std::string &normname);  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static DictFuncPtr_t GetDict (const char *cname);  Given the class name returns the Dictionary() function of a class (uses hash of name). ;  ; static DictFuncPtr_t GetDict (const std::type_info &info);  Given the std::type_info returns the Dictionary() function of a class (uses hash of std::type_info::name()). ;  ; static DictFuncPtr_t GetDictNorm (const char *cname);  Given the normalized class name returns the Dictionary() function of a class (uses hash of name). ;  ; static Version_t GetID (const char *cname);  Returns the ID of a class. ;  ; static Int_t GetPragmaBits (const char *name);  Returns the pragma bits as specified in the LinkDef.h file. ;  ; static TProtoClass * GetProto (const char *cname);  Given the class name returns the TClassProto object for the class. ;  ; static TProtoClass * GetProtoNorm (const char *cname);  Given the class normalized name returns the TClassProto object for the class. ;  ; static void Init ();  ; static char * Next ();  Returns next class from sorted class table. ;  ; static void PrintTable ();  Print the class table. ;  ; static void Remove (const char *cname);  Remove a class from the class table. ;  ; static void RemoveAlternate (ROOT::TClassAlt *alt);  ; static void Terminate ();  Deletes the class table (this static class function calls the dtor). ;  ;  Static Public Member Functions inherited from TObject; static TClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTable.html:10670,hash,hash,10670,doc/master/classTClassTable.html,https://root.cern,https://root.cern/doc/master/classTClassTable.html,1,['hash'],['hash']
Security,"ictSelectionReader;  ; struct  GetFunctorType;  Internal class used by TF1 for obtaining the type from a functor out of the set of valid operator() signatures. More...;  ; struct  GetFunctorType< T(F::*)(const T *, const double *) const >;  ; struct  GetFunctorType< T(F::*)(const T *, const double *)>;  ; struct  GetFunctorType< T(F::*)(T *, double *) const >;  ; struct  GetFunctorType< T(F::*)(T *, double *)>;  ; struct  InterpreterMutexRegistrationRAII;  ; struct  ParsingStateRAII;  RAII used to store Parser, Sema, Preprocessor state for recursive parsing. More...;  ; struct  RBaseType;  ; struct  RCast;  ; struct  RCast< T, false, false >;  ; struct  RCast< T, false, true >;  ; class  RConcurrentHashColl;  This class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection of uid (integer) This is used in the handling of the StreamerInfo record in TFile. More...;  ; struct  RDavixFileDes;  ; struct  RecurseCounts;  ; struct  RHashMap;  ; class  RIoUring;  ; class  RRawFile;  The RRawFile provides read-only access to local and remote files. More...;  ; class  RRawFileDavix;  The RRawFileDavix class provides read-only access to remote non-ROOT files. More...;  ; class  RRawFileNetXNG;  The RRawFileNetXNG class provides read-only access to remote files using root/roots protocol. More...;  ; struct  RRawFileNetXNGImpl;  ; class  RRawFileTFile;  The RRawFileTFile wraps an open TFile, but does not take ownership. More...;  ; class  RRawFileUnix;  The RRawFileUnix class uses POSIX calls to read from a mounted file system. More...;  ; class  RRawFileWin;  The RRawFileWin class uses portable C I/O calls to read from a drive. More...;  ; class  RSlotStack;  A thread-safe stack of N indexes (0 to size - 1). More...;  ; struct  RSlotStackRAII;  A RAII object to pop and push slot numbers from a RSlotStack object. More...;  ; class  RStl;  ; class  RTaskArenaWrapper;  Wrapper for tbb::task_arena. More...;  ; class  TArrayCharProxy;  Concrete Imp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:1666,access,access,1666,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,2,['access'],['access']
Security,"id GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(Scalar[] dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:13331,access,access,13331,root/html602/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,4,['access'],['access']
Security,"id PrintNeuron(TMVA::TNeuron* neuron) const; print a neuron, for debugging. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); get the mva value generated by the NN. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the NN. const std::vector<Float_t> & GetMulticlassValues(); get the multiclass classification values generated by the NN. void AddWeightsXMLTo(void* parent) const; create XML description of ANN classifier. void ReadWeightsFromXML(void* wghtnode); read MLP from xml weight file. void ReadWeightsFromStream(istream& istr); destroy/clear the network then read it back in from the weights file. const TMVA::Ranking* CreateRanking(); compute ranking of input variables by summing function of weights. void CreateWeightMonitoringHists(const TString& bulkname, vector<TH1*>* hv = 0) const. void WriteMonitoringHistosToFile() const; write histograms to file. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. Bool_t Debug() const; who the hell makes such strange Debug flags that even use ""global pointers"".. void SetActivation(TMVA::TActivation* activation); setters for subclasses. void SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator). void Train(); this will have to be overridden by every subclass. Double_t GetNetworkOutput(); { return GetOutputNeuron()->GetActivationValue(); }. Int_t NumCycles(); accessors. { return fNcycles; }. TNeuron* GetInputNeuron(Int_t index); { return (TNeuron*)fInputLayer->At(index); }. TNeuron* GetOutputNeuron(Int_t index = 0); { return fOutputNeurons.at(index); }. » Author: Andreas Hoecker, Peter Speckmayer, Matt Jachowski, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: MethodANNBase.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodANNBase.html:22344,access,accessors,22344,root/html530/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodANNBase.html,1,['access'],['accessors']
Security,"id SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfoActions::TActionSequence::SequenceGetter_tSequencePtr(*)(TStreamerInfo *info, TVirtualCollectionProxy *collectionProxy, TClass *originalClass) SequenceGetter_tDefinition TStreamerInfoActions.h:185; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetMakeClassInt_t GetMakeClass() constDefinition TTree.h:535; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators.Definition TVirtualCollectionIterators.h:26; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionPtrIteratorsDefinition TVirtualCollectionIterators.h:195; double; int; unsigned int; TStreamerInfoActions::TIDsstd::vector< TIDNode > TIDsDefinition TStreamerInfoActions.h:138; ROOT::RCompressionSetting::EAlgorithm::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:91. treetreeincTBranchElement.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8h_source.html:42154,access,access,42154,doc/master/TBranchElement_8h_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html,1,['access'],['access']
Security,id TSchemaRule::SetTarget ; (; const TString & ; target). Set the target member of this rule (i.e. the in memory data member). ; Definition at line 492 of file TSchemaRule.cxx. ◆ SetTargetClass(). void TSchemaRule::SetTargetClass ; (; const TString & ; classname). Set the target class of this rule (i.e. the in memory class). ; Definition at line 474 of file TSchemaRule.cxx. ◆ SetVersion(). Bool_t TSchemaRule::SetVersion ; (; const TString & ; version). Set the version string - returns kFALSE if the format is incorrect. ; Definition at line 381 of file TSchemaRule.cxx. ◆ Streamer(). void ROOT::TSchemaRule::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void ROOT::TSchemaRule::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 120 of file TSchemaRule.h. ◆ TestChecksum(). Bool_t TSchemaRule::TestChecksum ; (; UInt_t ; checksum); const. Check if given checksum is defined in this rule. ; Definition at line 437 of file TSchemaRule.cxx. ◆ TestVersion(). Bool_t TSchemaRule::TestVersion ; (; Int_t ; version); const. Check if given version number is defined in this rule. ; Definition at line 402 of file TSchemaRule.cxx. Member Data Documentation. ◆ fAttributes. TString ROOT::TSchemaRule::fAttributes. private . Definition at line 118 of file TSchemaRule.h. ◆ fChecksum. TString ROOT::TSchemaRule::fChecksum. private . Source version vector (for searching purposes) ; Definition at line 103 of file TSchemaRule.h. ◆ fChecksumVect. std::vector<UInt_t>* ROOT::TSchemaRule::fChecksumVect. mutableprivate . Definition at line 104 of file TSchemaRule.h. ◆ fCode. TString ROOT::TSchemaRule::fCode. private . Includes vector. ; Definition at line 113 of file TSchemaRule.h. ◆ fEmbed. Bool_t ROOT::TSchemaRule::fEmbed. private . Definition at line 114 of file TSchemaRule.h. ◆ fInclude. TString ROOT::TSchemaRule::fInclude. private . Source data member vector (for sear,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:27116,checksum,checksum,27116,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,2,['checksum'],['checksum']
Security,"id) const overrideDefinition TStreamerInfo.h:166; TStreamerInfo::GetLengthInt_t GetLength(Int_t id) constDefinition TStreamerInfo.h:176; TStreamerInfo::TStreamerInfoTStreamerInfo(const TStreamerInfo &)=delete; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInfo::ReadBufferClonesInt_t ReadBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset)Read for TClonesArray.Definition TStreamerInfoReadBuffer.cxx:1749; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStreamerElementReal(Int_t i, Int_t j) constObsolete: this routine is obsolete and should not longer be used.Definition TStreamerInfo.cxx:4316; TStreamerInfo::fClassTClass * fClass!pointer to classDefinition TStreamerInfo.h:99; TStreamerInfo::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TStreamerInfo.cxx:3270; TStreamerInfo::~TStreamerInfo~TStreamerInfo() overrideTStreamerInfo dtor.Definition TStreamerInfo.cxx:211; TStreamerInfo::fCompOptTCompInfo ** fCompOpt![fNdata]Definition TStreamerInfo.h:97; TStreamerInfo::SetClassVersionvoid SetClassVersion(Int_t vers) overrideDefinition TStreamerInfo.h:220; TStreamerInfo::TagFilevoid TagFile(TFile *fFile) overrideMark the classindex of the current file as using this TStreamerInfo.Definition TStreamerInfo.cxx:5377; TStreamerInfo::GetReadTextActionsTStreamerInfoActions::TActionSequence * GetReadTextActions()Definition TStreamerInfo.h:169; TStreamerInfo::GetNewTypeInt_t GetNewType(Int_t id) constDefinition TStreamerInfo.h:178; TStreamerInfo::GetOffsetInt_t GetOffset(Int_t id) const overrideDefinition TStreamerInfo.h:180; TStreamerInfo::SetClassvoid SetClass(TClass *cl) overrideReplace the TClass this streamerInfo is pointin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8h_source.html:33369,checksum,checksum,33369,doc/master/TStreamerInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html,3,['checksum'],['checksum']
Security,"id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TSocket * CreateAuthSocket (const char *url, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server. ;  ; static TSocket * CreateAuthSocket (const char *user, const char *host, Int_t port, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ;  ; static const char * DeclFileName ();  ; static Int_t GetClientProtocol ();  Static method returning supported client protocol. ;  ; static ULong64_t GetSocketBytesRecv ();  Get total number of bytes received via all sockets. ;  ; static ULong64_t GetSocketBytesSent ();  Get total number of bytes sent via all sockets. ;  ; static void NetError (const char *where, Int_t error);  Print error string depending on error code. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:13968,authenticat,authenticates,13968,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['authenticat'],['authenticates']
Security,"idateto validate the parse context; TStringfValidateErrorparse error; TStringfValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TXMLParser(); Cleanup. void SetValidate(Bool_t val = kTRUE); The parser will validate the xml file if val = true. void SetReplaceEntities(Bool_t val = kTRUE); The parser will replace/expand entities. void ReleaseUnderlying(); To release any existing document. void OnValidateError(const TString& message); This function is called when an error from the parser has occured.; Message is the parse error. void OnValidateWarning(const TString& message); This function is called when a warning from the parser has occured.; Message is the parse error. const char * GetParseCodeMessage(Int_t parseCode) const; Returns the parse code message. void InitializeContext(); Initialize parser parameters, such as, disactivate non-standards libxml1; features, on/off validation, clear error and warning messages. void StopParser(); Stops parsing. void SetParseCode(Int_t code); Set the parse code:; 0: Parse succesfull; -1: Attempt to parse a second file while a parse is in progress; -2: Parse context is not created; -3: An error occured while parsing file; -4: A fatal error occured while parsing file; -5: Document is not well-formed. void SetStopOnError(Bool_t stop = kTRUE); Set parser stops in case of error:; stop = true, stops on error; stop = false, continue parsing on error... TXMLParser& operator=(const TXMLParser& ). Bool_t GetValidate() const; { return fValidate; }. Bool_t GetReplaceEntities() const; { return fReplaceEntities; }. Int_t ParseFile(const char* filename). Int_t ParseBuffer(const char* contents, Int_t len). Int_t GetParseCode() const; { return fParseCode; }. Bool_t GetStopOnError() const; { return fStopError; }. const char * GetValidateError() const; { return fValidateError; }. const char * GetVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLParser.html:10882,validat,validation,10882,root/html528/TXMLParser.html,https://root.cern,https://root.cern/root/html528/TXMLParser.html,3,['validat'],['validation']
Security,"idateto validate the parse context; TStringfValidateErrorparse error; TStringfValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TXMLParser(); Cleanup. void SetValidate(Bool_t val = kTRUE); The parser will validate the xml file if val = true. void SetReplaceEntities(Bool_t val = kTRUE); The parser will replace/expand entities. void ReleaseUnderlying(); To release any existing document. void OnValidateError(const TString& message); This function is called when an error from the parser has occured.; Message is the parse error. void OnValidateWarning(const TString& message); This function is called when a warning from the parser has occured.; Message is the parse error. const char * GetParseCodeMessage(Int_t parseCode) const; Returns the parse code message. void InitializeContext(); Initialize parser parameters, such as, disactivate non-standards libxml1; features, on/off validation, clear error and warning messages. void StopParser(); Stops parsing. void SetParseCode(Int_t code); Set the parse code:; 0: Parse successful; -1: Attempt to parse a second file while a parse is in progress; -2: Parse context is not created; -3: An error occured while parsing file; -4: A fatal error occured while parsing file; -5: Document is not well-formed. void SetStopOnError(Bool_t stop = kTRUE); Set parser stops in case of error:; stop = true, stops on error; stop = false, continue parsing on error... TXMLParser& operator=(const TXMLParser& ). Bool_t GetValidate() const; { return fValidate; }. Bool_t GetReplaceEntities() const; { return fReplaceEntities; }. Int_t ParseFile(const char* filename). Int_t ParseBuffer(const char* contents, Int_t len). Int_t GetParseCode() const; { return fParseCode; }. Bool_t GetStopOnError() const; { return fStopError; }. const char * GetValidateError() const; { return fValidateError; }. const char * GetVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXMLParser.html:10970,validat,validation,10970,root/html534/TXMLParser.html,https://root.cern,https://root.cern/root/html534/TXMLParser.html,1,['validat'],['validation']
Security,"ide ; .  . Loading...; Searching...; No Matches. hsimpleReader.C File ReferenceTutorials » Tree tutorials. Detailed Description; TTreeReader simplest example. ; Read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; auto myHist = new TH1F(""h1"",""ntuple"",100,-4,4);; ; // Open the file containing the tree.; auto myFile = TFile::Open(""hsimple.root"");; if (!myFile || myFile->IsZombie()) {; return;; }; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }; TFile.h; TH1F.h; TTreeReaderValue.h; TTreeReader.h; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; AuthorAnders Eie, 2013 ; Definition in file hsimpleReader.C. tutorialstreehsimpleReader.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimpleReader_8C.html:1126,access,access,1126,doc/master/hsimpleReader_8C.html,https://root.cern,https://root.cern/doc/master/hsimpleReader_8C.html,1,['access'],['access']
Security,"ide alternative; scan methods or to extend some collection kinds. Bool_t IsDrawableClass(TClass* cl); return true if object can be drawn. void ScanHierarchy(const char* topname, const char* path, TRootSnifferStore* store); scan ROOT hierarchy with provided store object. void * FindInHierarchy(const char* path, TClass** cl = 0, TDataMember** member = 0, Int_t* chld = 0); Search element with specified path; Returns pointer on element; Optionally one could obtain element class, member description; and number of childs. When chld!=0, not only element is searched,; but also number of childs are counted. When member!=0, any object; will be scanned for its data members (disregard of extra options). TObject * FindTObjectInHierarchy(const char* path); Search element in hierarchy, derived from TObject. ULong_t GetStreamerInfoHash(); Returns hash value for streamer infos; At the moment - just number of items in streamer infos list. ULong_t GetItemHash(const char* itemname); Get hash function for specified item; used to detect any changes in the specified object. Bool_t CanDrawItem(const char* path); Method verifies if object can be drawn. Bool_t CanExploreItem(const char* path); Method returns true when object has childs or; one could try to expand item. void CreateMemFile(); Creates TMemFile instance, which used for objects streaming; One could not use TBufferFile directly,; while one also require streamer infos list. Bool_t ProduceJson(const char* path, const char* options, TString& res); produce JSON data for specified item; For object conversion TBufferJSON is used. Bool_t ProduceXml(const char* path, const char* options, TString& res); produce XML data for specified item; For object conversion TBufferXML is used. TString DecodeUrlOptionValue(const char* value, Bool_t remove_quotes = kTRUE); method replaces all kind of special symbols, which could appear in URL options. Bool_t ProduceExe(const char* path, const char* options, TString& res, Bool_t astxt = kFALSE); execute co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootSniffer.html:10438,hash,hash,10438,root/html602/TRootSniffer.html,https://root.cern,https://root.cern/root/html602/TRootSniffer.html,1,['hash'],['hash']
Security,"ideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::SetBarWidthvirtual void SetBarWidth(Float_t width=0.5)Set the width of bars as fraction of the bin width for drawing mode ""B"".Definition TH1.h:365; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TLegend::AddEntryTLegendEntry * AddEntry(const TObject *obj, const char *label="""", Option_t *option=""lpf"")Add a new entry to this legend.Definition TLegend.cxx:320; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; . To control the bar width (default is the bin width) TH1::SetBarWidth() should be used.; To control the bar offset (default is 0) TH1::SetBarOffset() should be used.; These two parameters are useful when several histograms are plotted using the option SAME. They allow to plot the histograms next to each other. The SCATter plot option (legacy draw option); AttentionUse of option SCAT has been deprecated. It was the default drawing option for 2D and 3D histograms. The new default option is COL (heat-map).; For each cell (i,j) a number of points proportional to the cell content is drawn. A maximum of kNMAX points per cell is drawn. If the maximum is above kNMAX contents ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:36871,access,access,36871,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,2,['access'],['access']
Security,"ided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleButton(Event_t* event); Handle mouse button 'event'. Bool_t HandleDoubleClick(Event_t* event); Handle mouse double click 'event'. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify 'event' - a window resize/movement. Bool_t HandleExpose(Event_t* event); Handle window expose 'event' - show. Bool_t HandleKey(Event_t* event); Handle keyboard 'event'. Bool_t HandleMotion(Event_t* event); Handle mouse motion 'event'. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Method to handle action TGLViewer::kDragCameraRotate. Bool_t HandleTimer(TTimer* t); If mouse delay timer times out emit signal. void StartMouseTimer(); Start mouse timer in single-shot mode. void StopMouseTimer(); Make sure mouse timers are not running. void ClearMouseOver(); Clear mouse-over state and emit mouse-over signals.; Current overlay element is also told the mouse has left. void Repaint(); Handle window expose 'event' - show. void PopupContextMenu(TGLPhysicalShape* pshp, Event_t* event, Int_t gx, Int_t gy); Popup context menu. void TriggerTooltip(const char* text); Trigger display of tooltip. void RemoveTooltip(); Hide the tooltip. void SetMouseOverSelectDelay(Int_t ms); Set delay of mouse-over probe (highlight). void SetMouseOverTooltipDelay(Int_t ms); Set delay of tooltip timer. Int_t ControlValue(Int_t v); { return fViewerCentricControls ? -v : v; }. Int_t GetTooltipPixelTolerance() const; { return fTooltipPixelTolerance; }. void SetTooltipPixelTolerance(Int_t t); { fTooltipPixelTolerance = t; }. Int_t GetSecSelType() const; { return fSecSelType; }. void SetSecSelType(Int_t t); { fSecSelType = t; }. Bool_t GetDoInternalSelection() const; { return fDoInternalSelection; }. void SetDoInternalSelection(Bool_t x); { fDoInternalSelection = x; }. Bool_t GetArcBall() const; { return fArcBall; }. void SetArcBall(Bool_t a); { fArcBall = a; }. » Author: Bertrand Bellenot 29/01/2008 » Copy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLEventHandler.html:14124,expose,expose,14124,root/html534/TGLEventHandler.html,https://root.cern,https://root.cern/root/html534/TGLEventHandler.html,1,['expose'],['expose']
Security,"ided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleButton(Event_t* event); Handle mouse button 'event'. Bool_t HandleDoubleClick(Event_t* event); Handle mouse double click 'event'. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify 'event' - a window resize/movement. Bool_t HandleExpose(Event_t* event); Handle window expose 'event' - show. Bool_t HandleKey(Event_t* event); Handle keyboard 'event'. Bool_t HandleMotion(Event_t* event); Handle mouse motion 'event'. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Method to handle action TGLViewer::kDragCameraRotate. Bool_t HandleTimer(TTimer* t); If mouse delay timer times out emit signal. void StartMouseTimer(); Start mouse timer in single-shot mode. void StopMouseTimer(); Make sure mouse timers are not running. void ClearMouseOver(); Clear mouse-over state and emit mouse-over signals.; Current overlay element is also told the mouse has left. void Repaint(); Handle window expose 'event' - show. void PopupContextMenu(TGLPhysicalShape* pshp, Event_t* event, Int_t gx, Int_t gy); Popup context menu. void TriggerTooltip(const char* text); Trigger display of tooltip. void RemoveTooltip(); Hide the tooltip. void SetMouseOverSelectDelay(Int_t ms); Set delay of mouse-over probe (highlight). void SetMouseOverTooltipDelay(Int_t ms); Set delay of tooltip timer. Int_t ControlValue(Int_t v); { return fViewerCentricControls ? -v : v; }. Int_t GetTooltipPixelTolerance() const; { return fTooltipPixelTolerance; }. void SetTooltipPixelTolerance(Int_t t); { fTooltipPixelTolerance = t; }. Int_t GetSecSelType() const; { return fSecSelType; }. void SetSecSelType(Int_t t); { fSecSelType = t; }. Bool_t GetDoInternalSelection() const; { return fDoInternalSelection; }. void SetDoInternalSelection(Bool_t x); { fDoInternalSelection = x; }. » Author: Bertrand Bellenot 29/01/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLEventHan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLEventHandler.html:13968,expose,expose,13968,root/html528/TGLEventHandler.html,https://root.cern,https://root.cern/root/html528/TGLEventHandler.html,3,['expose'],['expose']
Security,"ided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleButton(Event_t* event); Handle mouse button 'event'. Bool_t HandleDoubleClick(Event_t* event); Handle mouse double click 'event'. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify 'event' - a window resize/movement. Bool_t HandleExpose(Event_t* event); Handle window expose 'event' - show. Bool_t HandleKey(Event_t* event); Handle keyboard 'event'. Bool_t HandleMotion(Event_t* event); Handle mouse motion 'event'. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Method to handle action TGLViewer::kDragCameraRotate. Bool_t HandleTimer(TTimer* t); If mouse delay timer times out emit signal. void StartMouseTimer(); Start mouse timer in single-shot mode. void StopMouseTimer(); Make sure mouse timers are not running. void ClearMouseOver(); Clear mouse-over state and emit mouse-over signals.; Current overlay element is also told the mouse has left. void Repaint(); Handle window expose 'event' - show. void PopupContextMenu(TGLPhysicalShape* pshp, Event_t* event, Int_t gx, Int_t gy); Popup context menu. void TriggerTooltip(const char* text); Trigger display of tooltip. void RemoveTooltip(); Hide the tooltip. void SetMouseOverSelectDelay(Int_t ms); Set delay of mouse-over probe (highlight). void SetMouseOverTooltipDelay(Int_t ms); Set delay of tooltip timer. Int_t ControlValue(Int_t v); { return fViewerCentricControls ? -v : v; }. TGLEventHandler(TGWindow* w, TObject* obj). Int_t GetTooltipPixelTolerance() const; { return fTooltipPixelTolerance; }. void SetTooltipPixelTolerance(Int_t t); { fTooltipPixelTolerance = t; }. Int_t GetSecSelType() const; { return fSecSelType; }. void SetSecSelType(Int_t t); { fSecSelType = t; }. Bool_t GetDoInternalSelection() const; { return fDoInternalSelection; }. void SetDoInternalSelection(Bool_t x); { fDoInternalSelection = x; }. Bool_t GetArcBall() const; { return fArcBall; }. void SetArcBall(Bool_t a); { fArcBall = a; }. »",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLEventHandler.html:14658,expose,expose,14658,root/html602/TGLEventHandler.html,https://root.cern,https://root.cern/root/html602/TGLEventHandler.html,2,['expose'],['expose']
Security,"idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TExMap.html:8071,hash,hash,8071,root/html534/TExMap.html,https://root.cern,https://root.cern/root/html534/TExMap.html,4,['hash'],['hash']
Security,"idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 15:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TExMap.html:8532,hash,hash,8532,root/html604/TExMap.html,https://root.cern,https://root.cern/root/html604/TExMap.html,4,['hash'],['hash']
Security,"idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-30 14:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TExMap.html:8532,hash,hash,8532,root/html602/TExMap.html,https://root.cern,https://root.cern/root/html602/TExMap.html,4,['hash'],['hash']
Security,"id Print (Option_t *opt="""") const override;  This method must be overridden when a class wants to print itself. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPerfAnalysis_1_1TFileInfo.html:1529,hash,hash,1529,doc/master/classTProofPerfAnalysis_1_1TFileInfo.html,https://root.cern,https://root.cern/doc/master/classTProofPerfAnalysis_1_1TFileInfo.html,1,['hash'],['hash']
Security,"id SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the strin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:12610,access,accessible,12610,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,2,['access'],['accessible']
Security,"id Subtract (const TEntryList *elist);  Remove all the entries of this entry list, that are contained in elist. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:13954,hash,hash,13954,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['hash'],['hash']
Security,"ied dataset is processed.; The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet. Available options (to be .or.ed): kPrint print the dataset content kQuotaUpdate update quotas kExport use export naming kList get a list of dataset names; NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. ; Definition at line 577 of file TDataSetManagerFile.cxx. ◆ CheckLocalCache(). Int_t TDataSetManagerFile::CheckLocalCache ; (; const char * ; group, . const char * ; user, . const char * ; dsName = ""ls"", . UInt_t ; option = 0 . ). private . Check if the local cache information for group, user, dsName is up-to-date If not, make the relevant updates Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. ; Definition at line 1085 of file TDataSetManagerFile.cxx. ◆ ChecksumDataSet(). Int_t TDataSetManagerFile::ChecksumDataSet ; (; const char * ; path, . const char * ; md5path, . TString & ; checksum . ). protected . Calculate the checksum of the indicated dataset at 'path' and save it to the appropriate file 'md5path'. ; The MD5 string is returned in 'md5sum'. Return 0 on success, -1 on error. ; Definition at line 1512 of file TDataSetManagerFile.cxx. ◆ Class(). static TClass * TDataSetManagerFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDataSetManagerFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDataSetManagerFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file TDataSetManagerFile.h. ◆ ClearCache(). Int_t TDataSetManagerFile::ClearCache ; (; const char * ; uri = 0). overridevirtual . Clear cached information matching uri. ; Reimplemented from TDataSetManager.; Definition at line 1253 of file TDataSetManagerFile.cxx. ◆ CreateLsFile(). Int_t TDataSetManagerFile::CreateLsFile ; (; const char * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:22667,checksum,checksum,22667,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['checksum'],['checksum']
Security,"ied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenericPdf.html:40813,access,access,40813,root/html534/RooGenericPdf.html,https://root.cern,https://root.cern/root/html534/RooGenericPdf.html,1,['access'],['access']
Security,"ied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TArrayD_limits; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_nBins; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParametricStepFunction.html:42872,access,access,42872,root/html602/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html602/RooParametricStepFunction.html,2,['access'],['access']
Security,"ient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealMPFE.html:36533,access,access,36533,root/html602/RooRealMPFE.html,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html,2,['access'],['access']
Security,ients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsAnaConvPdf::_modelOriginal model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBCPGenDecay.html:43830,access,access,43830,root/html602/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html602/RooBCPGenDecay.html,2,['access'],['access']
Security,"ierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TString::kBoth@ kBothDefinition TString.h:276; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TUUID::Streamervirtual void Streamer(TBuffer &); bool; int; unsigned int; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::DirAutoAdd_tvoid(* DirAutoAdd_t)(void *, TDirectory *)Definition Rtypes.h:119; ROOT::kExactMatch@ kExactMatchDefinition TDictionary.h:162; slashTCanvas * slash()Definition slash.C:1; Drawth1 Draw(); mTMarker mDefinition textangle.C:8. corebasesrcTDirectory.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:06 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:72806,access,access,72806,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,2,['access'],['access']
Security,"iewer on this TTree. TTree* GetTreeHeader(TProof* proof); Returns a tree header containing the branches' structure of the dataset. Bool_t ElementsValid(); Check if all elements are valid. Int_t Remove(TDSetElement* elem, Bool_t deleteElem = kTRUE); Remove TDSetElement 'elem' from the list.; Return 0 on success, -1 if the element is not in the list. void Validate(); Validate the TDSet by opening files. void Lookup(Bool_t removeMissing = kFALSE, TList** missingFiles = 0); Resolve the end-point URL for the current elements of this data set; If the removeMissing option is set to kTRUE, remove the TDSetElements; that can not be located.; The method returns the list of removed TDSetElements in *listOfMissingFiles; if the latter is defined (the list must be created outside). void SetLookedUp(); Flag all the elements as looked-up, so to avoid opening the files; if the functionality is not supported. void Validate(TDSet* dset); Validate the TDSet against another TDSet.; Only validates elements in common from input TDSet. void Streamer(TBuffer& ); Stream an object of class TDSet. void SetWriteV3(Bool_t on = kTRUE); Set/Reset the 'OldStreamer' bit in this instance and its elements.; Needed for backward compatibility in talking to old client / masters. void SetEntryList(TObject* aList); Set entry (or event) list for this data set. void SplitEntryList(); Splits the main entry (or event) list into sub-lists for the elements of; thet data set. Int_t GetNumOfFiles(); Return the number of files in the dataset. TDSetElement& operator=(const TDSet& ). const char * GetObjName() const; { return GetTitle(); }. const char * GetDirectory() const. TObject * GetEntryList() const; { return fEntryList; }. TDSet(const TDSet& ). Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Bool_t IsTree() const; { return fIsTree; }. Bool_t IsValid() const; { return !fType.IsNull(); }. const char * GetType() const; { return fType;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDSet.html:15639,validat,validates,15639,root/html534/TDSet.html,https://root.cern,https://root.cern/root/html534/TDSet.html,3,['validat'],['validates']
Security,"iewer on this TTree. TTree* GetTreeHeader(TProof* proof); Returns a tree header containing the branches' structure of the dataset. Bool_t ElementsValid(); Check if all elements are valid. Int_t Remove(TDSetElement* elem, Bool_t deleteElem = kTRUE); Remove TDSetElement 'elem' from the list.; Return 0 on success, -1 if the element is not in the list. void Validate(); Validate the TDSet by opening files. void Lookup(Bool_t removeMissing = kFALSE, TList** missingFiles = 0); Resolve the end-point URL for the current elements of this data set; If the removeMissing option is set to kTRUE, remove the TDSetElements; that can not be located.; The method returns the list of removed TDSetElements in *listOfMissingFiles; if the latter is defined (the list must be created outside). void SetLookedUp(); Flag all the elements as looked-up, so to avoid opening the files; if the functionality is not supported. void Validate(TDSet* dset); Validate the TDSet against another TDSet.; Only validates elements in common from input TDSet. void Streamer(TBuffer& b); Stream an object of class TDSet. void SetWriteV3(Bool_t on = kTRUE); Set/Reset the 'OldStreamer' bit in this instance and its elements.; Needed for backward compatibility in talking to old client / masters. void SetEntryList(TObject* aList); Set entry (or event) list for this data set. void SplitEntryList(); Splits the main entry (or event) list into sub-lists for the elements of; thet data set. Int_t GetNumOfFiles(); Return the number of files in the dataset. TDSetElement& operator=(const TDSet& ). const char * GetObjName() const; { return GetTitle(); }. const char * GetDirectory() const. TObject * GetEntryList() const; { return fEntryList; }. TDSet(const TDSet& ). Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Bool_t IsTree() const; { return fIsTree; }. Bool_t IsValid() const; { return !fType.IsNull(); }. const char * GetType() const; { return fType",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDSet.html:15039,validat,validates,15039,root/html528/TDSet.html,https://root.cern,https://root.cern/root/html528/TDSet.html,3,['validat'],['validates']
Security,"if an actual check on the staged status (via TFileStager) is done; 0 check that the file is staged using TFileStager; 1 do not hard check the staged status; (example: use fopt = -101 to check the staged status of all the files, or fopt = 110; to re-check the stage status of all the files marked as staged). If 'dbg' is true, some information about the ongoing operations is reguraly; printed; this can be useful when processing very large datasets, an operation; which can take a very long time. If maxfiles > 0, select for processing a maximum of 'filesmax' files (but if fopt is 1 or 2; all files marked as 'staged' are still open or touched). Return code; kTRUE the file appears newly staged; kFALSE otherwise. changed is true if the fileinfo is modified; touched is true if the file is open and read; disappeared is true if the file is marked staged but actually not staged. void ProcessFile(TFileInfo* fileInfo, Int_t sopt, Bool_t checkstg, Bool_t doall, TFileStager* stager, Bool_t createStager, const char* stageopts, Bool_t dbg, Bool_t& changed, Bool_t& opened); Locate, stage, or fully validate file ""fileInfo"". Int_t ScanFile(TFileInfo* fileinfo, Bool_t notify); Open the file described by 'fileinfo' to extract the relevant meta-information.; Return 0 if OK, -2 if the file cannot be open, -1 if it is corrupted. Int_t FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); Navigate the directory 'd' (and its subdirectories) looking for TTree objects.; Fill in the relevant metadata information in 'fi'. The name of the TFileInfoMeta; metadata entry will be ""/dir1/dir2/.../tree_name"".; Return 0 on success, -1 if any problem happens (object found in keys cannot be read,; for example). TList * ParseDataSetSrvMaps(const TString& srvmaps); Create a server mapping list from the content of 'srvmaps'; Return the list (owned by the caller) or 0 if no valid info could be found). TList * GetDataSetSrvMaps(); Static getter for server mapping list. Bool_t CheckDataSetSrvMaps(TU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDataSetManager.html:22578,validat,validate,22578,root/html534/TDataSetManager.html,https://root.cern,https://root.cern/root/html534/TDataSetManager.html,3,['validat'],['validate']
Security,"if this rule is valid. void SetCode(const TString& code); Set the source code of this rule. TString GetCode() const; Get the source code of this rule. Bool_t HasTarget(const TString& target) const; Return true if one of the rule's data member target is 'target'. Bool_t HasSource(const TString& source) const; Return true if one of the rule's data member source is 'source'. void SetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr); Set the pointer to the function to be run for the rule (if it is a read rule). void SetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr); Set the pointer to the function to be run for the rule (if it is a raw read rule). void SetRuleType(ROOT::TSchemaRule::RuleType_t type); Set the type of the rule. Bool_t IsAliasRule() const; Return kTRUE if the rule is a strict renaming of one of the data member of the class. Bool_t IsRenameRule() const; Return kTRUE if the rule is a strict renaming of the class to a new name. Bool_t Conflicts(const ROOT::TSchemaRule* rule) const; Check if this rule conflicts with the given one. Bool_t ProcessVersion(const TString& version) const; Check if specified version string is correct and build version vector. Bool_t ProcessChecksum(const TString& checksum) const; Check if specified checksum string is correct and build checksum vector. void ProcessList(TObjArray* array, const TString& list); Split the list as a comma separated list into a TObjArray of TObjString. void ProcessDeclaration(TObjArray* array, const TString& list); Split the list as a declaration into as a TObjArray of TNamed(name,type). ReadFuncPtr_t GetReadFunctionPointer() const. ReadRawFuncPtr_t GetReadRawFunctionPointer() const. RuleType_t GetRuleType() const. » Last changed: root/core:$Id: TSchemaRule.h 27938 2009-03-26 09:53:23Z pcanal $ » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__TSchemaRule.html:10722,checksum,checksum,10722,root/html526/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html526/ROOT__TSchemaRule.html,3,['checksum'],['checksum']
Security,"if you do have the permission, you risk loosing the original tree with an unsuccessful attempt to save the modification. Since trees are usually large, adding a branch could extend it over the 2GB limit. In this case, the attempt to write the tree fails, and the original data is may also be corrupted. In addition, adding a branch to a tree enlarges the tree and increases the amount of memory needed to read an entry, and therefore decreases the performance. For these reasons, ROOT offers the concept of friends for trees (and chains). We encourage you to use TTree::AddFriend rather than adding a branch manually.; 12.16.2 TTree::AddFriend; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The TTree (tree) below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend’s variables were in the original tree. To specify which tree to use in the Draw method, use the syntax:; <treeName>.<branchname>.<varname>; If the variablename is enough to identify uniquely the variable, you can leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable “var” in the TTree tree versus variable v1 inTTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:570085,access,access,570085,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"iffer.Definition THttpServer.cxx:1463; THttpServer::SetJSROOTvoid SetJSROOT(const char *location)Set location of JSROOT to use with the server.Definition THttpServer.cxx:355; THttpServer::fMutexstd::mutex fMutex! mutex to protect list with argumentsDefinition THttpServer.h:57; THttpServer::fDefaultPagestd::string fDefaultPage! file name for default page nameDefinition THttpServer.h:50; THttpServer::UnregisterWSvoid UnregisterWS(std::shared_ptr< THttpWSHandler > ws)Unregister WS handler.Definition THttpServer.cxx:1272; THttpServer::GetMimeTypestatic const char * GetMimeType(const char *path)Guess mime type base on file extension.Definition THttpServer.cxx:1479; THttpServer::GetSnifferTRootSniffer * GetSniffer() constreturns pointer on objects snifferDefinition THttpServer.h:89; THttpServer::ReplaceJSROOTLinksvoid ReplaceJSROOTLinks(std::shared_ptr< THttpCallArg > &arg, const std::string &version="""")Replaces all references like ""jsrootsys/..."" or other pre-configured pathes.Definition THttpServer.cxx:847; THttpServer::fTerminatedBool_t fTerminated! termination flag, disables all requests processingDefinition THttpServer.h:37; THttpServer::SetTopNamevoid SetTopName(const char *top)set name of top item in objects hierarchyDefinition THttpServer.h:127; THttpServer::Restrictvoid Restrict(const char *path, const char *options)Restrict access to specified object.Definition THttpServer.cxx:1386; THttpTimerDefinition THttpServer.cxx:42; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TRootSnifferSniffer of ROOT objects, data provider for THttpServer.Definition TRootSniffer.h:115; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; bool. nethttpincTHttpServer.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:46 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8h_source.html:20896,access,access,20896,doc/master/THttpServer_8h_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html,1,['access'],['access']
Security,"ific lists of THostAuth fro proof; static Bool_tfgPwHashkTRUE if fgPasswd is a passwd hash; static Int_tfgRSAInit; static Int_tfgRSAKeyDefault type of RSA key to be tried; static rsa_KEYfgRSAPriKey; static rsa_KEY_exportfgRSAPubExport[2]; static rsa_KEYfgRSAPubKey; static Bool_tfgReadHomeAuthrckTRUE to look for $HOME/.rootauthrc; static TStringfgRootAuthrcPath to last rootauthrc-like file read; static Bool_tfgSRPPwdkTRUE if fgPasswd is a SRP passwd; static SecureAuth_tfgSecAuthHook; static TStringfgUser; static Bool_tfgUsrPwdCryptkTRUE if encryption for UsrPwd is required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAuthenticate(TSocket* sock, const char* remote, const char* proto, const char* user = """"); Create authentication object. void CatchTimeOut(); Called in connection with a timer timeout. Bool_t Authenticate(); Authenticate to remote rootd or proofd server. Return kTRUE if; authentication succeeded. void SetEnvironment(); Set default authentication environment. The values are inferred; from fSecurity and fDetails. Bool_t GetUserPasswd(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from several sources. Bool_t CheckNetrc(TString& user, TString& passwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. For more info see the version with 4 arguments.; This version is maintained for backward compatability reasons. Bool_t CheckNetrc(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. First ~/.rootnetrc is tried, after that ~/.netrc.; These files will only be used when their access masks are 0600.; Returns kTRUE if user and passwd were found for the machine; specified in the URL. If kFALSE, user and passwd are """".; If srppwd == kTRUE then a SRP ('secure') pwd is searched for in; the files.; The boolean pwhash is set to kTRUE if the returned passwd is to; be un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:11430,authenticat,authentication,11430,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,"ight long term solution or not. Whether it is or not depend on the I/O on whether the default template argument might change or not and whether they (should) affect the on disk layout (for STL containers, we do know they do not). ; Definition at line 2852 of file TClingUtils.cxx. ◆ BeginsWith(). bool ROOT::TMetaUtils::BeginsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5088 of file TClingUtils.cxx. ◆ CheckConstructor(). ROOT::TMetaUtils::EIOCtorCategory ROOT::TMetaUtils::CheckConstructor ; (; const clang::CXXRecordDecl * ; cl, . const RConstructorType & ; ioctortype, . const cling::Interpreter & ; interp . ). Check if class has constructor of provided type - either default or with single argument. ; Definition at line 1079 of file TClingUtils.cxx. ◆ CheckDefaultConstructor(). bool ROOT::TMetaUtils::CheckDefaultConstructor ; (; const clang::CXXRecordDecl * ; cl, . const cling::Interpreter & ; interp . ). Checks if default constructor exists and accessible. ; Definition at line 999 of file TClingUtils.cxx. ◆ CheckIOConstructor(). ROOT::TMetaUtils::EIOCtorCategory ROOT::TMetaUtils::CheckIOConstructor ; (; const clang::CXXRecordDecl * ; cl, . const char * ; typeOfArg, . const clang::CXXRecordDecl * ; expectedArgType, . const cling::Interpreter & ; interp . ). Checks IO constructor - must be public and with specified argument. ; Definition at line 1019 of file TClingUtils.cxx. ◆ CheckPublicFuncWithProto(). bool ROOT::TMetaUtils::CheckPublicFuncWithProto ; (; clang::CXXRecordDecl const * ; cl, . char const * ; methodname, . char const * ; proto, . const cling::Interpreter & ; interp, . bool ; diagnose . ). Return true, if the function (defined by the name and prototype) exists and is public. ; Definition at line 1202 of file TClingUtils.cxx. ◆ ClassInfo__HasMethod(). const clang::FunctionDecl * ROOT::TMetaUtils::ClassInfo__HasMethod ; (; const clang::DeclContext * ; cl, . char const * ; name, . const cling::Interpre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html:21154,access,accessible,21154,doc/v632/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html,1,['access'],['accessible']
Security,"ight long term solution or not. Whether it is or not depend on the I/O on whether the default template argument might change or not and whether they (should) affect the on disk layout (for STL containers, we do know they do not). ; Definition at line 2892 of file TClingUtils.cxx. ◆ BeginsWith(). bool ROOT::TMetaUtils::BeginsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5135 of file TClingUtils.cxx. ◆ CheckConstructor(). ROOT::TMetaUtils::EIOCtorCategory ROOT::TMetaUtils::CheckConstructor ; (; const clang::CXXRecordDecl * ; cl, . const RConstructorType & ; ioctortype, . const cling::Interpreter & ; interp . ). Check if class has constructor of provided type - either default or with single argument. ; Definition at line 1119 of file TClingUtils.cxx. ◆ CheckDefaultConstructor(). bool ROOT::TMetaUtils::CheckDefaultConstructor ; (; const clang::CXXRecordDecl * ; cl, . const cling::Interpreter & ; interp . ). Checks if default constructor exists and accessible. ; Definition at line 1039 of file TClingUtils.cxx. ◆ CheckIOConstructor(). ROOT::TMetaUtils::EIOCtorCategory ROOT::TMetaUtils::CheckIOConstructor ; (; const clang::CXXRecordDecl * ; cl, . const char * ; typeOfArg, . const clang::CXXRecordDecl * ; expectedArgType, . const cling::Interpreter & ; interp . ). Checks IO constructor - must be public and with specified argument. ; Definition at line 1059 of file TClingUtils.cxx. ◆ CheckPublicFuncWithProto(). bool ROOT::TMetaUtils::CheckPublicFuncWithProto ; (; clang::CXXRecordDecl const * ; cl, . char const * ; methodname, . char const * ; proto, . const cling::Interpreter & ; interp, . bool ; diagnose . ). Return true, if the function (defined by the name and prototype) exists and is public. ; Definition at line 1242 of file TClingUtils.cxx. ◆ ClassInfo__HasMethod(). const clang::FunctionDecl * ROOT::TMetaUtils::ClassInfo__HasMethod ; (; const clang::DeclContext * ; cl, . char const * ; name, . const cling::Interpr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html:21150,access,accessible,21150,doc/master/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html,1,['access'],['accessible']
Security,"ightsFromStream(istream& istr); read the state of the method from an input stream. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return the MVA value (range [-1;1]) that classifies the; event.according to the majority vote from the total number of; decision trees; In the literature I found that people actually use the; weighted majority vote (using the boost weights) .. However I; did not see any improvement in doing so :(; --> this is currently switched off. void WriteMonitoringHistosToFile( void ); here we could write some histograms created during the processing; to the output file. vector< Double_t > GetVariableImportance(); return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); return the variable importance. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void ReadWeightsFromXML(void* ); {}. const std::vector<TMVA::IMethod*>& GetCommittee() const; accessors. { return fCommittee; }. const std::vector<Double_t>& GetBoostWeights() const; { return fBoostWeights; }. std::vector<IMethod*>& GetCommittee(); accessors. { return fCommittee; }. std::vector<Double_t>& GetBoostWeights(); { return fBoostWeights; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodCommittee.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCommittee.html:20998,access,accessors,20998,root/html528/TMVA__MethodCommittee.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCommittee.html,2,['access'],['accessors']
Security,"ight ; kInfoLastChanged ; kInfoLastGenerated ; kNumSourceInfos . Definition at line 54 of file TDocParser.h. Constructor & Destructor Documentation. ◆ TDocParser() [1/2]. TDocParser::TDocParser ; (; TClassDocOutput & ; docOutput, . TClass * ; cl . ). Constructor called for parsing class sources. ; Definition at line 150 of file TDocParser.cxx. ◆ TDocParser() [2/2]. TDocParser::TDocParser ; (; TDocOutput & ; docOutput). constructor called for parsing text files with Convert() ; Definition at line 190 of file TDocParser.cxx. ◆ ~TDocParser(). TDocParser::~TDocParser ; (; ). override . destructor, checking whether all methods have been found for gDebug > 3 ; Definition at line 211 of file TDocParser.cxx. Member Function Documentation. ◆ AddClassDataMembersRecursively(). void TDocParser::AddClassDataMembersRecursively ; (; TBaseClass * ; bc). protected . Add data members of fCurrentClass and of bc to datamembers, recursively. ; Real data members are in idx 0..2 (public, protected, private access), enum constants in idx 3..5. ; Definition at line 306 of file TDocParser.cxx. ◆ AddClassMethodsRecursively(). void TDocParser::AddClassMethodsRecursively ; (; TBaseClass * ; bc). protected . Add accessible (i.e. ; non-private) methods of base class bc and its base classes' methods to methodNames. If bc==0, we add fCurrentClass's methods (and also private functions). ; Definition at line 235 of file TDocParser.cxx. ◆ AnchorFromLine(). void TDocParser::AnchorFromLine ; (; const TString & ; line, . TString & ; anchor . ). static . Create an anchor from the given line, by hashing it and convertig the hash into a custom base64 string. ; Definition at line 381 of file TDocParser.cxx. ◆ Class(). static TClass * TDocParser::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDocParser::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDocParser::Class_Version ; (; ). inlinestaticconstexpr .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDocParser.html:18931,access,access,18931,doc/master/classTDocParser.html,https://root.cern,https://root.cern/doc/master/classTDocParser.html,1,['access'],['access']
Security,"ignal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; Int_tTClass::GetClassSize() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQClass.html:6700,checksum,checksum,6700,root/html534/TQClass.html,https://root.cern,https://root.cern/root/html534/TQClass.html,1,['checksum'],['checksum']
Security,"ignature of the member function; * @modifiers_mask When matching, do not compare the listed modifiers; * @return reflection information of the function member. this overloading is unfortunate but I can't include Type.h here. * FunctionMemberSize will return the number of function members of; * this type; * @return number of function members. void GenerateDict(Reflex::DictionaryGenerator& generator) const. * GenerateDict will produce the dictionary information of this type; * @param generator a reference to the dictionary generator instance. bool HasBase(const Reflex::Type& cl) const. * HasBase will check whether this class has a base class given; * as argument; * @param cl the base-class to check for; * @return the Base info if it is found, an empty base otherwise (can be tested for bool). bool IsPrivate() const. * IsPrivate will check if the scope access is private; * @return true if scope access is private. bool IsProtected() const. * IsProtected will check if the scope access is protected; * @return true if scope access is protected. bool IsPublic() const. * IsPublic will check if the scope access is public; * @return true if scope access is public. Member LookupMember(const string& nam) const. * LookupMember will lookup a member in the current scope; * @param nam the string representation of the member to lookup; * @return if a matching member is found return it, otherwise return empty member. Type LookupType(const string& nam) const. * LookupType will lookup a type in the current scope; * @param nam the string representation of the type to lookup; * @return if a matching type is found return it, otherwise return empty type. Scope LookupScope(const string& nam) const. * LookupScope will lookup a scope in the current scope; * @param nam the string representation of the scope to lookup; * @return if a matching scope is found return it, otherwise return empty scope. Member MemberAt(size_t nth, Reflex::EMEMBERQUERY inh = INHERITEDMEMBERS_DEFAULT) const. * MemberAt w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Reflex__Scope.html:14213,access,access,14213,root/html526/Reflex__Scope.html,https://root.cern,https://root.cern/root/html526/Reflex__Scope.html,10,['access'],['access']
Security,"igned int D1, unsigned int D2, class R > . T * ROOT::Math::SMatrix< T, D1, D2, R >::Array. inline . return pointer to internal array ; Definition at line 633 of file SMatrix.icc. ◆ Array() [2/2]. template<class T , unsigned int D1, unsigned int D2, class R > . const T * ROOT::Math::SMatrix< T, D1, D2, R >::Array. inline . return read-only pointer to internal array ; Definition at line 630 of file SMatrix.icc. ◆ At() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . T & ROOT::Math::SMatrix< T, D1, D2, R >::At ; (; unsigned int ; i, . unsigned int ; j . ). inline . read/write access to matrix element with indices starting from 0. ; Function will check index values and it will assert if they are wrong ; Definition at line 660 of file SMatrix.icc. ◆ At() [2/2]. template<class T , unsigned int D1, unsigned int D2, class R > . const T & ROOT::Math::SMatrix< T, D1, D2, R >::At ; (; unsigned int ; i, . unsigned int ; j . ); const. inline . read only access to matrix element, with indices starting from 0. ; Function will check index values and it will assert if they are wrong ; Definition at line 653 of file SMatrix.icc. ◆ begin() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . T * ROOT::Math::SMatrix< T, D1, D2, R >::begin. inline . STL iterator interface. ; Definition at line 670 of file SMatrix.icc. ◆ begin() [2/2]. template<class T , unsigned int D1, unsigned int D2, class R > . const T * ROOT::Math::SMatrix< T, D1, D2, R >::begin. inline . STL const_iterator interface. ; Definition at line 680 of file SMatrix.icc. ◆ Col(). template<class T , unsigned int D1, unsigned int D2, class R > . SVector< T, D1 > ROOT::Math::SMatrix< T, D1, D2, R >::Col ; (; unsigned int ; thecol); const. return a full Matrix column as a vector (copy the content in a new vector) ; Definition at line 590 of file SMatrix.icc. ◆ Det(). template<class T , unsigned int D1, unsigned int D2, class R > . bool ROOT::Math::SMatrix< T, D1, D2, R >::Det ; (; T & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:19371,access,access,19371,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,1,['access'],['access']
Security,"igned int i) constread-only access of vector elements with check on index. Index starts from 0.Definition SVector.icc:596; ROOT::Math::SVector::operator!=bool operator!=(const T &rhs) constelement wise comparisonDefinition SVector.icc:261; ROOT::Math::SVector::SVectorSVector()Default constructor: vector filled with zero values.Definition SVector.icc:53; ROOT::Math::SVector::operator()const T & operator()(unsigned int i) constread-only access of vector elements. Index starts from 0.Definition SVector.icc:585; ROOT::Math::SVector::operator-=SVector< T, D > & operator-=(const T &rhs)self subtraction with a scalarDefinition SVector.icc:400; ROOT::Math::SVector::IsInUsebool IsInUse(const T *p) constFunction to check if a vector is sharing same memory location of the passed pointer This function is ...Definition SVector.icc:628; ROOT::Math::SVector::operator<bool operator<(const T &rhs) constelement wise comparisonDefinition SVector.icc:311; ROOT::Math::SVector::operator[]const T & operator[](unsigned int i) constread-only access of vector elements. Index starts from 0.Definition SVector.icc:582; ROOT::Math::SVector::operator+=SVector< T, D > & operator+=(const T &rhs)self addition with a scalarDefinition SVector.icc:371; ROOT::Math::SVector::operator==bool operator==(const T &rhs) constelement wise comparisonDefinition SVector.icc:230; ROOT::Math::SVector::operator/=SVector< T, D > & operator/=(const T &rhs)self division with a scalarDefinition SVector.icc:465; ROOT::Math::SVector::fArrayT fArray[D]SVector data.Definition SVector.h:333; ROOT::Math::SVector::Printstd::ostream & Print(std::ostream &os) constused by operator<<()Definition SVector.icc:521; ROOT::Math::SVector::enditerator end()STL iterator interface.Definition SVector.icc:556; ROOT::Math::SVector::SetElementsvoid SetElements(InputIterator begin, InputIterator end)set vector elements copying the values iterator size must match vector sizeDefinition SVector.icc:563; ROOT::Math::VecExprExpression wrapper class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SVector_8icc_source.html:24860,access,access,24860,doc/master/SVector_8icc_source.html,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html,1,['access'],['access']
Security,"ike containers or lists of other objects).Definition TCollection.h:189; TCollection::PrintCollectionEntryvirtual void PrintCollectionEntry(TObject *entry, Option_t *option, Int_t recurse) constPrint the collection entry.Definition TCollection.cxx:445; TCollection::IsArgNullBool_t IsArgNull(const char *where, const TObject *obj) constReturns true if object is a null pointer.Definition TCollection.cxx:372; TCollection::NotifyBool_t Notify() override'Notify' all objects in this collection.Definition TCollection.cxx:407; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::kInitHashTableCapacity@ kInitHashTableCapacityDefinition TCollection.h:159; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.cxx:223; TCollection::fgGarbageStackstatic Int_t fgGarbageStackDefinition TCollection.h:137; TCollection::endTIter end() constDefinition TCollection.h:2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:18292,access,accessible,18292,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['access'],['accessible']
Security,"ike so:; @pythonization('FirstClass'); @pythonization('SecondClass', ns='NS'); def pythonizor_for_first_and_second(klass, name):; print('Executed for class ' + name); ; # If we now access both classes, we should see that the pythonizor runs twice.; f = ROOT.FirstClass(); s = ROOT.NS.SecondClass(); ; # So far we have seen how pythonizations can be registered for classes that; # have not been used yet. We have discussed how, in that case, the pythonizor; # functions are executed lazily when their target class/es are used for the; # first time in the application.; # However, it can also happen that our target class/es have already been; # accessed by the time we register a pythonization. In such a scenario, the; # pythonizor is applied immediately (at registration time) to the target; # class/es.; ; # Let's see an example of what was just explained. We will define a new class; # and immediately create an object of that class. We can check how the object; # still does not have a new attribute `pythonized` that we are going to inject; # in the next step.; ROOT.gInterpreter.Declare('''; class MyClass2 {};; '''); o = ROOT.MyClass2(); try:; print(o.pythonized); except AttributeError:; print(""Object has not been pythonized yet!""); ; # After that, we will register a pythonization for `MyClass2`. Since the class; # has already been used, the pythonization will happen right away.; @pythonization('MyClass2'); def pythonizor_for_myclass2(klass):; klass.pythonized = True; ; # Now our object does have the `pythonized` attribute:; print(o.pythonized) # prints True; formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid wind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html:8615,inject,inject,8615,doc/master/pyroot002__pythonizationDecorator_8py.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html,1,['inject'],['inject']
Security,"ikelihoodFCN ();  Destructor (no operations) ;  ; virtual BaseFunction * Clone () const;  clone the function (need to return Base for Windows) ;  ; virtual double DataElement (const double *x, unsigned int i, double *g, double *h=nullptr, bool fullHessian=false) const;  i-th likelihood contribution and its gradient ;  ; virtual void Gradient (const double *x, double *g) const;  ; virtual unsigned int NFitPoints () const;  ; LogLikelihoodFCN & operator= (const LogLikelihoodFCN &rhs);  Assignment operator. ;  ; virtual BaseObjFunction::Type_t Type () const;  get type of fit method function ;  ; void UseSumOfWeightSquare (bool on=true);  ;  Public Member Functions inherited from ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >; virtual const DataType & Data () const;  access to const reference to the data ;  ; std::shared_ptr< DataType > DataPtr () const;  access to data pointer ;  ; virtual bool HasHessian () const;  flag to indicate if can compute Hessian ;  ; virtual const IModelFunction & ModelFunction () const;  access to const reference to the model function ;  ; std::shared_ptr< IModelFunction > ModelFunctionPtr () const;  access to function pointer ;  ;  Public Member Functions inherited from ROOT::Math::BasicFitMethodFunction< DerivFunType >;  BasicFitMethodFunction (int dim, int npoint);  ;  ~BasicFitMethodFunction () override;  Virtual Destructor (no operations) ;  ; virtual bool G2 (const double *, double *) const;  Computes the Second derivatives. ;  ; virtual bool Hessian (const double *x, double *hess) const;  Computes the full Hessian. ;  ; bool IsAGradFCN ();  ; virtual unsigned int NCalls () const;  return the total number of function calls (override if needed) ;  ; unsigned int NDim () const override;  Number of dimension (parameters) . ;  ; virtual unsigned int NPoints () const;  return the number of data points used in evaluating the function ;  ; virtual void ResetNCalls ();  reset number of function calls ;  ; virtual void UpdateNCalls ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1LogLikelihoodFCN.html:2833,access,access,2833,doc/master/classROOT_1_1Fit_1_1LogLikelihoodFCN.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1LogLikelihoodFCN.html,4,['access'],['access']
Security,"ilation should be done debug or opt; Int_tfAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tfBeepDurationUsed by Beep(); Int_tfBeepFreqUsed by Beep(); TStringfBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringfBuildCompilerCompiler used to build this ROOT; TStringfBuildCompilerVersionCompiler version used to build this ROOT; TStringfBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringfBuildNodeDetailed information where ROOT was built; TSeqCollection*fCompiledList of shared libs from compiled macros to be deleted; Bool_tfDoneTrue if eventloop should be finished; TSeqCollection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); TStringfLastErrorStringLast system error message; Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be chec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:15641,access,access,15641,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,3,['access'],['access']
Security,ile An archive file containing multiple sub-files (like a ZIP archive); TArchiveMember An archive member file; TArray Abstract array base class; TArrayC Array of chars; TArrayD Array of doubles; TArrayF Array of floats; TArrayI Array of ints; TArrayL Array of longs; TArrayL64 Array of long64s; TArrayS Array of shorts; TArrow An arrow (line with a arrowhead); TArrowEditor GUI for editing arrow attributes; TAtomicCount ; TAtt3D 3D attributes; TAttAxis Axis attributes; TAttBBox Helper for management of bounding-box information; TAttCanvas Canvas attributes; TAttFill Fill area attributes; TAttFillEditor GUI for editing fill attributes; TAttImage Image attributes; TAttLine Line attributes; TAttLineEditor GUI for editing line attributes; TAttMarker Marker attributes; TAttMarkerEditor GUI for editing marker attributes; TAttPad Pad attributes; TAttParticle Particle definition; TAttText Text attributes; TAttTextEditor GUI for editing text attributes; TAuthenticate Class providing remote authentication service; TAxis Axis class; TAxis3D 3-D ruler painting class; TAxisEditor axis editor; TBRIK TBRIK shape; TBackCompFitter Class providing backward compatibility for fitting by implementing the TVirtualFitter interface; TBase64 Base64 encoding/decoding; TBaseClass Description of a base class; TBasket the TBranch buffers; TBasketSQL the TBranch buffers; TBenchmark ROOT utility to help benchmarking applications; TBinomialEfficiencyFitter Binomial Fitter for the division of two histograms; TBits Bit container; TBits::TReference ; TBonjourBrowser Browse hosts for specific bonjour service type; TBonjourRecord Bonjour information record; TBonjourRegistrar Register Bonjour service; TBonjourResolver Resolve Bonjour to actual IP address and port; TBox Box class; TBranch Branch descriptor; TBranchClones Branch in case of an array of clone objects; TBranchElement Branch in case of an object; TBranchObject Branch in case of an object; TBranchRef to support referenced objects on other branches,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:51558,authenticat,authentication,51558,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,2,['authenticat'],['authentication']
Security,ile An archive file containing multiple sub-files (like a ZIP archive); TArchiveMember An archive member file; TArray Abstract array base class; TArrayC Array of chars; TArrayD Array of doubles; TArrayF Array of floats; TArrayI Array of ints; TArrayL Array of longs; TArrayL64 Array of long64s; TArrayS Array of shorts; TArrow An arrow (line with a arrowhead); TArrowEditor GUI for editing arrow attributes; TAtomicCount ; TAtt3D 3D attributes; TAttAxis Axis attributes; TAttBBox Helper for management of bounding-box information; TAttCanvas Canvas attributes; TAttFill Fill area attributes; TAttFillEditor GUI for editing fill attributes; TAttImage Image attributes; TAttLine Line attributes; TAttLineEditor GUI for editing line attributes; TAttMarker Marker attributes; TAttMarkerEditor GUI for editing marker attributes; TAttPad Pad attributes; TAttParticle Particle definition; TAttText Text attributes; TAttTextEditor GUI for editing text attributes; TAuthenticate Class providing remote authentication service; TAxis Axis class; TAxis3D 3-D ruler painting class; TAxisEditor axis editor; TBRIK TBRIK shape; TBackCompFitter Class providing backward compatibility for fitting by implementing the TVirtualFitter interface; TBase64 Base64 encoding/decoding; TBaseClass Description of a base class; TBasket the TBranch buffers; TBasketSQL the TBranch buffers; TBenchmark ROOT utility to help benchmarking applications; TBinomialEfficiencyFitter Binomial Fitter for the division of two histograms; TBits Bit container; TBits::TReference ; TBox Box class; TBranch Branch descriptor; TBranchClones Branch in case of an array of clone objects; TBranchElement Branch in case of an object; TBranchObject Branch in case of an object; TBranchRef to support referenced objects on other branches; TBranchSTL Branch handling STL collection of pointers; TBrowser ROOT Object Browser; TBrowserImp ABC describing browser implementation protocol; TBrowserPlugin basic plugin description class; TBtree A B-tree; TBtr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:47815,authenticat,authentication,47815,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,3,['authenticat'],['authentication']
Security,"ile TAuthenticate.cxx. ◆ SetGlobalExpDate(). void TAuthenticate::SetGlobalExpDate ; (; TDatime ; expdate). static . Set default expiring date for new validity contexts. ; Definition at line 1349 of file TAuthenticate.cxx. ◆ SetGlobalPasswd(). void TAuthenticate::SetGlobalPasswd ; (; const char * ; passwd). static . Set global passwd to be used for authentication to rootd or proofd. ; Definition at line 1309 of file TAuthenticate.cxx. ◆ SetGlobalPwHash(). void TAuthenticate::SetGlobalPwHash ; (; Bool_t ; pwhash). static . Set global passwd hash flag to be used for authentication to rootd or proofd. ; Definition at line 1323 of file TAuthenticate.cxx. ◆ SetGlobalSRPPwd(). void TAuthenticate::SetGlobalSRPPwd ; (; Bool_t ; srppwd). static . Set global SRP passwd flag to be used for authentication to rootd or proofd. ; Definition at line 1331 of file TAuthenticate.cxx. ◆ SetGlobalUser(). void TAuthenticate::SetGlobalUser ; (; const char * ; user). static . Set global user name to be used for authentication to rootd or proofd. ; Definition at line 1295 of file TAuthenticate.cxx. ◆ SetGlobusAuthHook(). void TAuthenticate::SetGlobusAuthHook ; (; GlobusAuth_t ; func). static . Set Globus authorization function. ; Automatically called when libGlobusAuth is loaded. ; Definition at line 1411 of file TAuthenticate.cxx. ◆ SetKrb5AuthHook(). void TAuthenticate::SetKrb5AuthHook ; (; Krb5Auth_t ; func). static . Set kerberos5 authorization function. ; Automatically called when libKrb5Auth is loaded. ; Definition at line 1402 of file TAuthenticate.cxx. ◆ SetPromptUser(). void TAuthenticate::SetPromptUser ; (; Bool_t ; promptuser). static . Set global PromptUser flag. ; Definition at line 1385 of file TAuthenticate.cxx. ◆ SetReadHomeAuthrc(). void TAuthenticate::SetReadHomeAuthrc ; (; Bool_t ; readhomeauthrc). static . Set flag controlling the reading of $HOME/.rootauthrc. ; In PROOF the administrator may want to switch off private settings. Always true, may only be set false via optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:39095,authenticat,authentication,39095,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"ile TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). If options contains 'streamerinfo', run ls on the list of streamerInfos and the list of conversion streamerInfos. ; Reimplemented from TObject.; Definition at line 4258 of file TClass.cxx. ◆ MakeCustomMenuList(). void TClass::MakeCustomMenuList ; (; ). Makes a customizable version of the popup menu list, i.e. ; makes a list of TClassMenuItem objects of methods accessible by context menu. The standard (and different) way consists in having just one element in this list, corresponding to the whole standard list. Once the customizable version is done, one can remove or add elements. ; Definition at line 4283 of file TClass.cxx. ◆ MatchLegacyCheckSum(). Bool_t TClass::MatchLegacyCheckSum ; (; UInt_t ; checksum); const. Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ; Definition at line 6494 of file TClass.cxx. ◆ Move(). void TClass::Move ; (; void * ; arenaFrom, . void * ; arenaTo . ); const. Register the fact that an object was moved from the memory location 'arenaFrom' to the memory location 'arenaTo'. ; Definition at line 4327 of file TClass.cxx. ◆ MoveAddressInRepository(). void TClass::MoveAddressInRepository ; (; const char * ; where, . void * ; oldadd, . void * ; newadd, . const TClass * ; what . ); const. private . Definition at line 337 of file TClass.cxx. ◆ New() [1/2]. void * TClass::New ; (; ENewType ; defConstructor = kClassNew, . Bool_t ; quiet = kFALSE . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew().; If quiet is true, do no issue a message via Error on case of problems, just return 0.; The constructor actually called here can be customized b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:104408,checksum,checksum,104408,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['checksum'],['checksum']
Security,"ile TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). If options contains 'streamerinfo', run ls on the list of streamerInfos and the list of conversion streamerInfos. ; Reimplemented from TObject.; Definition at line 4325 of file TClass.cxx. ◆ MakeCustomMenuList(). void TClass::MakeCustomMenuList ; (; ). Makes a customizable version of the popup menu list, i.e. ; makes a list of TClassMenuItem objects of methods accessible by context menu. The standard (and different) way consists in having just one element in this list, corresponding to the whole standard list. Once the customizable version is done, one can remove or add elements. ; Definition at line 4350 of file TClass.cxx. ◆ MatchLegacyCheckSum(). Bool_t TClass::MatchLegacyCheckSum ; (; UInt_t ; checksum); const. Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ; Definition at line 6561 of file TClass.cxx. ◆ Move(). void TClass::Move ; (; void * ; arenaFrom, . void * ; arenaTo . ); const. Register the fact that an object was moved from the memory location 'arenaFrom' to the memory location 'arenaTo'. ; Definition at line 4394 of file TClass.cxx. ◆ MoveAddressInRepository(). void TClass::MoveAddressInRepository ; (; const char * ; where, . void * ; oldadd, . void * ; newadd, . const TClass * ; what . ); const. private . Definition at line 337 of file TClass.cxx. ◆ New() [1/2]. void * TClass::New ; (; ENewType ; defConstructor = kClassNew, . Bool_t ; quiet = kFALSE . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew().; If quiet is true, do no issue a message via Error on case of problems, just return 0.; The constructor actually called here can be customized b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:104409,checksum,checksum,104409,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,3,['checksum'],['checksum']
Security,"ile TExMap.h. ◆ Class(). static TClass * TExMap::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TExMap::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TExMap::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file TExMap.h. ◆ DeclFileName(). static const char * TExMap::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 81 of file TExMap.h. ◆ Delete(). void TExMap::Delete ; (; Option_t * ; opt = """"). overridevirtual . Delete all entries stored in the TExMap. ; Reimplemented from TObject.; Definition at line 164 of file TExMap.cxx. ◆ Expand(). void TExMap::Expand ; (; Int_t ; newsize). Expand the TExMap. ; Definition at line 279 of file TExMap.cxx. ◆ FindElement(). Int_t TExMap::FindElement ; (; ULong64_t ; hash, . Long64_t ; key . ). private . Find an entry with specified hash and key in the TExMap. ; Returns the slot of the key or the next empty slot. ; Definition at line 237 of file TExMap.cxx. ◆ FixCollisions(). void TExMap::FixCollisions ; (; Int_t ; index). private . Rehash the map in case an entry has been removed. ; Definition at line 257 of file TExMap.cxx. ◆ GetSize(). Int_t TExMap::GetSize ; (; ); const. inline . Definition at line 71 of file TExMap.h. ◆ GetValue() [1/3]. Long64_t TExMap::GetValue ; (; Long64_t ; key). inline . Definition at line 73 of file TExMap.h. ◆ GetValue() [2/3]. Long64_t TExMap::GetValue ; (; ULong64_t ; hash, . Long64_t ; key . ). Return the value belonging to specified key and hash value. ; If key not found return 0. ; Definition at line 174 of file TExMap.cxx. ◆ GetValue() [3/3]. Long64_t TExMap::GetValue ; (; ULong64_t ; hash, . Long64_t ; key, . UInt_t & ; slot . ). Return the value belonging to specified key and hash value. ; If key not found return 0. In 'slot', return the index of the slot used or the first em",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExMap.html:14388,hash,hash,14388,doc/master/classTExMap.html,https://root.cern,https://root.cern/doc/master/classTExMap.html,1,['hash'],['hash']
Security,ile TListOfEnumsWithLock.cxx. ◆ LastLink(). TObjLink * TListOfEnumsWithLock::LastLink ; (; ); const. overridevirtual . Reimplemented from TList.; Definition at line 284 of file TListOfEnumsWithLock.cxx. ◆ MakeIterator(). TIterator * TListOfEnumsWithLock::MakeIterator ; (; Bool_t ; dir = kIterForward); const. overridevirtual . Return a list iterator. ; Reimplemented from TList.; Definition at line 220 of file TListOfEnumsWithLock.cxx. ◆ operator=(). TListOfEnumsWithLock & TListOfEnumsWithLock::operator= ; (; const TListOfEnumsWithLock & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfEnumsWithLock::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from TListOfEnums.; Definition at line 190 of file TListOfEnumsWithLock.cxx. ◆ Remove() [1/2]. TObject * TListOfEnumsWithLock::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Reimplemented from TListOfEnums.; Definition at line 201 of file TListOfEnumsWithLock.cxx. ◆ Remove() [2/2]. TObject * TListOfEnumsWithLock::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from TListOfEnums.; Definition at line 210 of file TListOfEnumsWithLock.cxx. ◆ Streamer(). void TListOfEnumsWithLock::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TListOfEnums. ◆ StreamerNVirtual(). void TListOfEnumsWithLock::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 80 of file TListOfEnumsWithLock.h. Libraries for TListOfEnumsWithLock:,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnumsWithLock.html:31903,hash,hash,31903,doc/master/classTListOfEnumsWithLock.html,https://root.cern,https://root.cern/doc/master/classTListOfEnumsWithLock.html,1,['hash'],['hash']
Security,"ile TStreamerInfo.h. ◆ InsertArtificialElements(). void TStreamerInfo::InsertArtificialElements ; (; std::vector< const ROOT::TSchemaRule * > & ; rules). private . Insert new members as expressed in the array of TSchemaRule(s). ; Definition at line 4541 of file TStreamerInfo.cxx. ◆ IsA(). TClass * TStreamerInfo::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 254 of file TStreamerInfo.h. ◆ ls(). void TStreamerInfo::ls ; (; Option_t * ; option = """"); const. overridevirtual . List the TStreamerElement list and also the precomputed tables if option contains the string ""incOrig"", also prints the original (non-optimized elements in the list of compiled elements. ; Implements TVirtualStreamerInfo.; Definition at line 4684 of file TStreamerInfo.cxx. ◆ MatchLegacyCheckSum(). Bool_t TStreamerInfo::MatchLegacyCheckSum ; (; UInt_t ; checksum); const. Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ; Definition at line 3270 of file TStreamerInfo.cxx. ◆ New(). void * TStreamerInfo::New ; (; void * ; obj = nullptr). overridevirtual . An emulated object is created at address obj, if obj is null we allocate memory for the object. ; Implements TVirtualStreamerInfo.; Definition at line 4769 of file TStreamerInfo.cxx. ◆ NewArray(). void * TStreamerInfo::NewArray ; (; Long_t ; nElements, . void * ; ary = nullptr . ). overridevirtual . An array of emulated objects is created at address ary, if ary is null, we allocate memory for the array. ; Implements TVirtualStreamerInfo.; Definition at line 4918 of file TStreamerInfo.cxx. ◆ NewInfo(). TVirtualStreamerInfo * TStreamerInfo::NewInfo ; (; TClass * ; cl). inlineoverridevirtual . Implements TVirtualStreamerInfo.; Definition at line 198 of file TStreamerInfo.h. ◆ operator=(). TStreamerInfo & TStreamerInfo::operator= ; (; const TStreamerInfo & ; ). privatedelete . ◆ PrintValue()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:59690,checksum,checksum,59690,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,3,['checksum'],['checksum']
Security,"ileFile stream used to access the archive; Int_tfMemberIndexIndex of sub-file in archive; TStringfMemberNameSub-file name; TObjArray*fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TArchiveFile(); Dtor. Long64_t GetMemberFilePosition() const; Return position in archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char *member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile& operator=(const TArchiveFile& ). Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { return fMembers; }. const char * GetArchiveName() const; { return fArchiveName; }. const char * GetMemberName() const; { return fMemberName; }. Int_t GetMemberIndex() const; { return fMemberIndex; }. » Author: Fons Rademakers ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TArchiveFile.html:6865,access,access,6865,root/html526/TArchiveFile.html,https://root.cern,https://root.cern/root/html526/TArchiveFile.html,1,['access'],['access']
Security,"ileFile stream used to access the archive; Int_tfMemberIndexIndex of sub-file in archive; TStringfMemberNameSub-file name; TObjArray*fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TArchiveFile(); Dtor. Long64_t GetMemberFilePosition() const; Return position in archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char* member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile& operator=(const TArchiveFile& ). Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { return fMembers; }. const char * GetArchiveName() const; { return fArchiveName; }. const char * GetMemberName() const; { return fMemberName; }. Int_t GetMemberIndex() const; { return fMemberIndex; }. » Author: Fons Rademakers ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TArchiveFile.html:6851,access,access,6851,root/html528/TArchiveFile.html,https://root.cern,https://root.cern/root/html528/TArchiveFile.html,4,['access'],['access']
Security,"ileInfo.cxx. ◆ ResetUrl(). void TFileInfo::ResetUrl ; (; ). inline . Definition at line 69 of file TFileInfo.h. ◆ SetCurrentUrl() [1/2]. Bool_t TFileInfo::SetCurrentUrl ; (; const char * ; url). Set 'url' as current URL, if in the list Return kFALSE if not in the list. ; Definition at line 355 of file TFileInfo.cxx. ◆ SetCurrentUrl() [2/2]. Bool_t TFileInfo::SetCurrentUrl ; (; TUrl * ; url). Set 'url' as current URL, if in the list Return kFALSE if not in the list. ; Definition at line 369 of file TFileInfo.cxx. ◆ SetIndex(). void TFileInfo::SetIndex ; (; Int_t ; idx). inline . Definition at line 100 of file TFileInfo.h. ◆ SetSize(). void TFileInfo::SetSize ; (; Long64_t ; size). inline . Definition at line 86 of file TFileInfo.h. ◆ SetUUID(). void TFileInfo::SetUUID ; (; const char * ; uuid). Set the UUID to the value associated to the string 'uuid'. ; This is useful to set the UUID to the one of the ROOT file during verification.; NB: we do not change the name in here, because this would screw up lists of these objects hashed on the name. Those lists need to be rebuild. TFileCollection does that in RemoveDuplicates. ; Definition at line 238 of file TFileInfo.cxx. ◆ Streamer(). void TFileInfo::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFileInfo::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 104 of file TFileInfo.h. Member Data Documentation. ◆ fCurrentUrl. TUrl* TFileInfo::fCurrentUrl. private . Definition at line 42 of file TFileInfo.h. ◆ fIndex. Int_t TFileInfo::fIndex. private . Definition at line 50 of file TFileInfo.h. ◆ fMD5. TMD5* TFileInfo::fMD5. private . Definition at line 47 of file TFileInfo.h. ◆ fMetaDataList. TList* TFileInfo::fMetaDataList. private . Definition at line 48 of file TFileInfo.h. ◆ fSize. Long64_t TFileInfo::fSize. private . Definition at line 45 of file TFileInfo.h. ◆ fUrlList. TList* TFileInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileInfo.html:21692,hash,hashed,21692,doc/master/classTFileInfo.html,https://root.cern,https://root.cern/doc/master/classTFileInfo.html,1,['hash'],['hashed']
Security,"ileName(""s"",; 3789 llvm::cl::desc(""The path to the library of the built dictionary.""),; 3790 llvm::cl::cat(gRootclingOptions));; 3791static llvm::cl::list<std::string>; 3792gOptModuleDependencies(""m"",; 3793 llvm::cl::desc(""The list of dependent modules of the dictionary.""),; 3794 llvm::cl::cat(gRootclingOptions));; 3795static llvm::cl::list<std::string>; 3796gOptExcludePaths(""excludePath"", llvm::cl::ZeroOrMore,; 3797 llvm::cl::desc(""Do not store the <path> in the dictionary.""),; 3798 llvm::cl::cat(gRootclingOptions));; 3799// FIXME: This does not seem to work. We have one use of -inlineInputHeader in; 3800// ROOT and it does not produce the expected result.; 3801static llvm::cl::opt<bool>; 3802gOptInlineInput(""inlineInputHeader"",; 3803 llvm::cl::desc(""Does not generate #include <header> but expands the header content.""),; 3804 llvm::cl::cat(gRootclingOptions));; 3805// FIXME: This is totally the wrong concept. We should not expose an interface; 3806// to be able to tell which component is in the pch and which needs extra; 3807// scaffolding for interactive use. Moreover, some of the ROOT components are; 3808// partially in the pch and this option makes it impossible to express that.; 3809// We should be able to get the list of headers in the pch early and scan; 3810// through them.; 3811static llvm::cl::opt<bool>; 3812gOptWriteEmptyRootPCM(""writeEmptyRootPCM"",; 3813 llvm::cl::Hidden,; 3814 llvm::cl::desc(""Does not include the header files as it assumes they exist in the pch.""),; 3815 llvm::cl::cat(gRootclingOptions));; 3816static llvm::cl::opt<bool>; 3817gOptCheckSelectionSyntax(""selSyntaxOnly"",; 3818 llvm::cl::desc(""Check the selection syntax only.""),; 3819 llvm::cl::cat(gRootclingOptions));; 3820static llvm::cl::opt<bool>; 3821gOptFailOnWarnings(""failOnWarnings"",; 3822 llvm::cl::desc(""Fail if there are warnings.""),; 3823 llvm::cl::cat(gRootclingOptions));; 3824static llvm::cl::opt<bool>; 3825gOptNoIncludePaths(""noIncludePaths"",; 3826 llvm::cl::desc(""Do not store i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:152815,expose,expose,152815,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['expose'],['expose']
Security,"iles hosted not only by Amazon S3 servers but also by other providers implementing the core of the S3 protocol.; The S3 protocol works on top of HTTPS (and HTTP) and imposes that each HTTP request be signed using a specific convention: the request must include an 'Authorization' header which contains the signature of a concatenation of selected request fields. For signing the request, an 'Access Key Id' and a 'Secret Access Key' need to be known. These keys are used by the S3 servers to identify the client and to authenticate the request as genuine.; As an end user, you must know the Access Key and Secret Access Key in order to access each S3 file. They are provided to you by your S3 service provider. Those two keys can be provided to ROOT when initializing an object of this class by two means: a. by using the environmental variables S3_ACCESS_KEY and S3_SECRET_KEY, or b. by specifying them when opening each file.; You can use AWS temporary security credentials (temporary access key and secret access key), but you must also give the associated session token. The token may be set in the S3_SESSION_TOKEN environmental variable, or on open in the TOKEN option.; The first method is convenient if all the S3 files you want to access are hosted by a single provider. The second one is more flexible as it allows you to specify which credentials to use on a per-file basis. See the documentation of the constructor of this class for details on the syntax.; For generating and signing the HTTP request, this class uses TS3HTTPRequest.; For more information on the details of S3 protocol please refer to: ""Amazon Simple Storage Service Developer Guide"": http://docs.amazonwebservices.com/AmazonS3/latest/dev/Welcome.html; ""Amazon Simple Storage Service REST API Reference"" http://docs.amazonwebservices.com/AmazonS3/latest/API/APIRest.html ; Definition at line 68 of file TS3WebFile.h. Public Member Functions;  TS3WebFile (const char *url, Option_t *options="""");  Construct a TS3WebFile obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:1510,secur,security,1510,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,3,"['access', 'secur']","['access', 'security']"
Security,"ility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. int Link(const char* from, const char* to); Create a link from file1 to file2. int Symlink(const char* from, const char* to); Create a symbolic link from file1 to file2. int Unlink(const char* name)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:26018,access,access,26018,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,12,['access'],['access']
Security,"ill use the TMatrixF class family, in the latter case the TMatrixD one;; type - general (TMatrixD), symmetric (TMatrixDSym) or sparse (TMatrixDSparse);; size - number of rows and columns;; index - range start of row and column index. By default these start at zero;; sparse map - this property is only relevant for a sparse matrix. It indicates where elements are unequal zero. 14.2.1 Accessing Properties; The following table shows the methods to access the information about the relevant matrix property:. Method; Descriptions. Int_t GetRowLwb (); row lower-bound index. Int_t GetRowUpb (); row upper-bound index. Int_t GetNrows (); number of rows. Int_t GetColLwb (); column lower-bound index. Int_t GetColUpb (); column upper-bound index. Int_t GetNcols (); number of columns. Int_t GetNoElements (); number of elements, for a dense matrix this equals: fNrows x fNcols. Double_t GetTol (); tolerance number which is used in decomposition operations. Int_t *GetRowIndexArray (); for sparse matrices, access to the row index of fNrows+1 entries. Int_t *GetColIndexArray (); for sparse matrices, access to the column index of fNelems entries. The last two methods in this table are specific to the sparse matrix, which is implemented according to the Harwell-Boeing format. Here, besides the usual shape/size descriptors of the matrix like fNrows, fRowLwb, fNcols and fColLwb, we also store a row index, fRowIndex and column index, fColIndex for the elements unequal zero:. fRowIndex[0,..,fNrows]:; Stores for each row the index range of the elements in the data and column array. fColIndex[0,..,fNelems-1]:; Stores the column number for each data element != 0. The code to print all matrix elements unequal zero would look like:; TMatrixDSparse a;; const Int_t *rIndex = a.GetRowIndexArray();; const Int_t *cIndex = a.GetColIndexArray();; const Double_t *pData = a.GetMatrixArray();; for (Int_t irow = 0; irow < a.getNrows(); irow++) {; const Int_t sIndex = rIndex[irow];; const Int_t eIndex = rInd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:771924,access,access,771924,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ilt within ROOT whenever a GSL library is found in the system. The GSL library and header file location can be specified in the ROOT configure script, by doing:; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; MathMore can be built also a stand-alone library (without requiring ROOT) downloding the tar file from the Web at this link. In this case the library will not contain the dictionary information and therefore cannot be used interactively; More information on the classes and functions present in MathMore is available in the online reference documentation.; 13.3 TMath; In the namespace, TMath, a collection of free functions is provided for the following functionality:. numerical constants (like pi, e, h, etc.);; trigonometric and elementary mathematical functions;; functions to work with arrays and collections (e.g. functions to find min and max of arrays);; statistic functions to work on array of data (e.g. mean and RMS of arrays);; algorithms for binary search/hashing sorting;; special mathematical functions like Bessel, Erf, Gamma, etc.;; statistical functions, like common probability and cumulative (quantile) distributions; geometrical functions. For more details, see the reference documentation of TMath at <http://root.cern.ch/root/htmldoc/TMath.html>.; 13.3.1 Numerical Constants; TMath offers a wide range of constants in the form of inline functions. Notice that they are not defined as C/C++ preprocessor macros. This set of functions includes one or more definitions for the following constants:. Pi.; Base of natural logarithm.; Velocity of light.; Gravitational constant (G).; Standard acceleration of gravity (g).; Standard acceleration of Gravity.; Plank’s contant.; Boltzmann’s and Steffan-Boltzmann’s constants.; Avogadro’s number.; Universal gas constant.; Molecular weight of dry air.; Dry air gas constant.; Euler-Mascheroni Constant.; Elementary charge. 13.3.2 Elementary Functions; A set of miscellaneous elementary mathematical functions is provi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:661078,hash,hashing,661078,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['hash'],['hashing']
Security,ilter ;  ; const TGPicture * fFolder_s;  big folder icon ;  ; const TGPicture * fFolder_t;  small folder icon ;  ; ULong_t fMtime;  directory modification time ;  ; TViewUpdateTimer * fRefresh;  refresh timer ;  ; const TGPicture * fSlink_s;  big symbolic link icon ;  ; const TGPicture * fSlink_t;  small symbolic link icon ;  ; EFSSortMode fSortType;  sorting mode of contents ;  ;  Protected Attributes inherited from TGLVContainer; Int_t * fCpos;  position of sub names ;  ; TGLayoutHints * fItemLayout;  item layout hints ;  ; Int_t * fJmode;  alignment of sub names ;  ; TGLVEntry * fLastActive;  last active item ;  ; TGListView * fListView;  listview which contains this container ;  ; Bool_t fMultiSelect;  true = multiple file selection ;  ; EListViewMode fViewMode;  list view viewing mode ;  ;  Protected Attributes inherited from TGContainer; Bool_t fBdown;  ; TGCanvas * fCanvas;  pointer to canvas ;  ; Bool_t fDragging;  true if in dragging mode ;  ; TGRectangle fExposedRegion;  exposed area ;  ; TString fKeyInput;  keyboard input (buffer) ;  ; TTimer * fKeyTimer;  keyboard timer ;  ; Bool_t fKeyTimerActive;  kTRUE - keyboard timer is active ;  ; TGFrameElement * fLastActiveEl;  last active item ;  ; Bool_t fLastCase;  case sensitivity of last search ;  ; Bool_t fLastDir;  direction of last search ;  ; TString fLastName;  the name of object of last search ;  ; Bool_t fLastSubstring;  substring search option of last search ;  ; const TGWindow * fMsgWindow;  window handling container messages ;  ; Bool_t fOnMouseOver;  kTRUE when mouse pointer is over entry ;  ; Bool_t fScrolling;  kTRUE - when scrolling is ON ;  ; TTimer * fScrollTimer;  autoscroll timer ;  ; Int_t fSelected;  number of selected items ;  ; Int_t fTotal;  total items ;  ; TGViewPort * fViewPort;  container viewport ;  ; Int_t fX0;  ; Int_t fXDND;  ; Int_t fXf;  ; Int_t fXp;  ; Int_t fY0;  corner of rubber band box ;  ; Int_t fYDND;  ; Int_t fYf;  other corner of rubber band box ;  ; Int_t fYp;  prev,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFileContainer.html:36395,expose,exposed,36395,doc/master/classTGFileContainer.html,https://root.cern,https://root.cern/doc/master/classTGFileContainer.html,1,['expose'],['exposed']
Security,"im,ROOT::Fit::UnBinData>(const shared_ptr<ROOT::Fit::UnBinData>& data, const shared_ptr<ROOT::Fit::BasicFCN<ROOT::Math::IGradientFunctionMultiDim,ROOT::Fit::UnBinData>::IModelFunction>& func); voidSetData(const shared_ptr<ROOT::Fit::UnBinData>& data); voidSetModelFunction(const shared_ptr<ROOT::Fit::BasicFCN<ROOT::Math::IGradientFunctionMultiDim,ROOT::Fit::UnBinData>::IModelFunction>& func). Data Members; public:. static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::kLeastSquare; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::kLogLikelihood; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::kUndefined. protected:. shared_ptr<ROOT::Fit::UnBinData>fData; shared_ptr<ROOT::Fit::BasicFCN<ROOT::Math::IGradientFunctionMultiDim,ROOT::Fit::UnBinData>::IModelFunction>fFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; std::shared_ptr<DataType> DataPtr() const; access to data pointer. { return fData; }. std::shared_ptr<IModelFunction> ModelFunctionPtr() const; access to function pointer. { return fFunc; }. void SetData(const shared_ptr<ROOT::Fit::UnBinData>& data); Set the data pointer. { fData = data; }. void SetModelFunction(const shared_ptr<ROOT::Fit::BasicFCN<ROOT::Math::IGradientFunctionMultiDim,ROOT::Fit::UnBinData>::IModelFunction>& func); Set the function pointer. { fFunc = func; }. » Author: L. Moneta 25 Nov 2014 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__BasicFCN_-p0Math__IGradientFunctionMultiDim_-p1UnBinData_.html:5713,access,access,5713,root/html604/ROOT__Fit__BasicFCN_-p0Math__IGradientFunctionMultiDim_-p1UnBinData_.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__BasicFCN_-p0Math__IGradientFunctionMultiDim_-p1UnBinData_.html,2,['access'],['access']
Security,"im; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAllowDirectiveswhether directives are to be interpreted; Bool_tfCheckForMethodwhether to check the current line for a method; TStringfClassDescrTagtag for finding the class description; enum(anonymous)fClassDocStatewhether we found the class description; TStringfCommentcurrent comment; Bool_tfCommentAtBOLat the beginning of the current line, fParseContext contained kComment; TClass*fCurrentClasscurrent class context of sources being parsed; TStringfCurrentFilecurrent source / header file name; TStringfCurrentMethodTagname_idx of the currently parsed method; TStringfCurrentModulecurrent module context of sources being parsed; TListfDataMembers[6]data members (by access, plus enums); Int_tfDirectiveCountindex of directive for current method; TListfDirectiveHandlershandler for doc directives (TDocDirective objects); TDocParser::EDocContextfDocContextcurrent context of parsed sources for documenting; TDocOutput*fDocOutputTDocOutput invoking us; set<UInt_t>fExtraLinesWithAnchorlines that need an additional anchor; TStringfFirstClassDocfirst class-doc found - per file, taken if fLastClassDoc is empty; THtml*fHtmlTHtml object using us; TStringfLastClassDoclast class-doc found - becomes class doc at ClassImp or first method; TStringfLineCommentcurrent line with links and directives for doc; UInt_tfLineNocurrent line number; Long_tfLineNumbersource line number; TStringfLineRawcurrent line; TStringfLineSourcecurrent line with links; TStringfLineStrippedcurrent line without surrounding spaces; map<string,Int_t>fMethodCountsnumber of undocumented overloads; THashListfMethods[3]methods as TMethodWrapper objects (by access); list<UInt_t>fParseContextcurrent context of parsed sources; TClass*fRecentClassrecently seen class context of sources being parsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source inf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDocParser.html:10280,access,access,10280,root/html602/TDocParser.html,https://root.cern,https://root.cern/root/html602/TDocParser.html,4,['access'],['access']
Security,"imer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.6.2 Regular calls of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.7 Data access from command shell; The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts.; If one starts a server and register an object like for example:; root [1] serv = new THttpServer(""http:8080"");; root [2] TNamed* n1 = new TNamed(""obj"", ""title"");; root [3] serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with the command:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; Then, its representation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 50331656,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. root.bin - binary data produced by object streaming with TBufferFile; root.json - ROOT JSON representation for object and objects members; root.xml - ROOT XML representation; root.png - PNG image (if object drawing implemented); root.gif - GIF image; root.jpeg - JPEG image; exe.json - method execution in the object; exe.bin - method execution, return result in binary form; cmd.json - command execution; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:9375,access,access,9375,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['access'],['access']
Security,"imer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.9 Data access from command shell; The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts.; If one starts a server and register an object like for example:; auto serv = new THttpServer(""http:8080"");; TNamed* n1 = new TNamed(""obj"", ""title"");; serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with the command:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; Then, its representation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. Name; Description. root.bin; binary data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:13532,access,access,13532,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['access'],['access']
Security,"import ROOT; 759 ; 760# Define correct imports and access the distributed RDataFrame appropriate for the; 761# backend used in the analysis; 762RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame; 763 ; 764if __name__ == ""__main__"":; 765 # The `npartitions` optional argument tells the RDataFrame how many tasks are desired; 766 df = RDataFrame(""mytree"",""myfile.root"", npartitions=NPARTITIONS); 767 # Proceed as usual; 768 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 769~~~; 770 ; 771Note that when processing a TTree or TChain dataset, the `npartitions` value should not exceed the number of clusters in; 772the dataset. The number of clusters in a TTree can be retrieved by typing `rootls -lt myfile.root` at a command line.; 773 ; 774### Distributed Snapshot; 775 ; 776The Snapshot operation behaves slightly differently when executed distributedly. First off, it requires the path; 777supplied to the Snapshot call to be accessible from any worker of the cluster and from the client machine (in general; 778it should be provided as an absolute path). Another important difference is that `n` separate files will be produced,; 779where `n` is the number of dataset partitions. As with local RDataFrame, the result of a Snapshot on a distributed; 780RDataFrame is another distributed RDataFrame on which we can define a new computation graph and run more distributed; 781computations.; 782 ; 783### Distributed RunGraphs; 784 ; 785Submitting multiple distributed RDataFrame executions is supported through the RunGraphs function. Similarly to its; 786local counterpart, the function expects an iterable of objects representing an RDataFrame action. Each action will be; 787triggered concurrently to send multiple computation graphs to a distributed cluster at the same time:; 788 ; 789~~~{.py}; 790import ROOT; 791RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; 792RunGraphs = ROOT.RDF.Experimental.Distributed.RunGraphs; 793 ; 794# Cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:45027,access,accessible,45027,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['accessible']
Security,"import ROOT; 799 ; 800# Define correct imports and access the distributed RDataFrame appropriate for the; 801# backend used in the analysis; 802RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame; 803 ; 804if __name__ == ""__main__"":; 805 # The `npartitions` optional argument tells the RDataFrame how many tasks are desired; 806 df = RDataFrame(""mytree"",""myfile.root"", npartitions=NPARTITIONS); 807 # Proceed as usual; 808 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 809~~~; 810 ; 811Note that when processing a TTree or TChain dataset, the `npartitions` value should not exceed the number of clusters in; 812the dataset. The number of clusters in a TTree can be retrieved by typing `rootls -lt myfile.root` at a command line.; 813 ; 814### Distributed Snapshot; 815 ; 816The Snapshot operation behaves slightly differently when executed distributedly. First off, it requires the path; 817supplied to the Snapshot call to be accessible from any worker of the cluster and from the client machine (in general; 818it should be provided as an absolute path). Another important difference is that `n` separate files will be produced,; 819where `n` is the number of dataset partitions. As with local RDataFrame, the result of a Snapshot on a distributed; 820RDataFrame is another distributed RDataFrame on which we can define a new computation graph and run more distributed; 821computations.; 822 ; 823### Distributed RunGraphs; 824 ; 825Submitting multiple distributed RDataFrame executions is supported through the RunGraphs function. Similarly to its; 826local counterpart, the function expects an iterable of objects representing an RDataFrame action. Each action will be; 827triggered concurrently to send multiple computation graphs to a distributed cluster at the same time:; 828 ; 829~~~{.py}; 830import ROOT; 831RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; 832RunGraphs = ROOT.RDF.Experimental.Distributed.RunGraphs; 833 ; 834# Cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:46667,access,accessible,46667,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['accessible']
Security,"in Max ]; : -----------------------------------------------------------; : myvar1: 0.089214 0.20183 [ -1.0000 1.0000 ]; : myvar2: -0.090751 0.29609 [ -1.0000 1.0000 ]; : var3: 0.059878 0.21436 [ -1.0000 1.0000 ]; : var4: 0.11587 0.24261 [ -1.0000 1.0000 ]; : -----------------------------------------------------------; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 4 ) Batch size = 100 Loss function = C; Layer 0 DENSE Layer: ( Input = 4 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 2 DENSE Layer: ( Input = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 3 DENSE Layer: ( Input = 128 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity Dropout prob. = 0.5; : Using 1600 events for training and 400 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:46987,validat,validation,46987,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['validat'],['validation']
Security,"in dedicated thread ; Definition at line 144 of file RWebWindow.hxx. ◆ fProtocol. std::string ROOT::RWebWindow::fProtocol. private . ! protocol ; Definition at line 174 of file RWebWindow.hxx. ◆ fProtocolCnt. int ROOT::RWebWindow::fProtocolCnt {-1}. private . ! counter for protocol recording ; Definition at line 171 of file RWebWindow.hxx. ◆ fProtocolConnId. unsigned ROOT::RWebWindow::fProtocolConnId {0}. private . ! connection id, which is used for writing protocol ; Definition at line 172 of file RWebWindow.hxx. ◆ fProtocolFileName. std::string ROOT::RWebWindow::fProtocolFileName. private . ! local file where communication protocol will be written ; Definition at line 170 of file RWebWindow.hxx. ◆ fProtocolPrefix. std::string ROOT::RWebWindow::fProtocolPrefix. private . ! prefix for created files names ; Definition at line 173 of file RWebWindow.hxx. ◆ fRequireAuthKey. bool ROOT::RWebWindow::fRequireAuthKey {true}. private . ! defines if authentication key always required when connect to the widget ; Definition at line 146 of file RWebWindow.hxx. ◆ fSendMT. bool ROOT::RWebWindow::fSendMT {false}. private . ! true is special threads should be used for sending data ; Definition at line 145 of file RWebWindow.hxx. ◆ fUseCurrentDir. bool ROOT::RWebWindow::fUseCurrentDir {false}. private . ! if window can access local files via currentdir/ path of http server ; Definition at line 155 of file RWebWindow.hxx. ◆ fUseProcessEvents. bool ROOT::RWebWindow::fUseProcessEvents {false}. private . ! all window functionality will run through process events ; Definition at line 143 of file RWebWindow.hxx. ◆ fUserArgs. std::string ROOT::RWebWindow::fUserArgs. private . ! arbitrary JSON code, which is accessible via conn.getUserArgs() method ; Definition at line 175 of file RWebWindow.hxx. ◆ fUseServerThreads. bool ROOT::RWebWindow::fUseServerThreads {false}. private . ! indicates that server thread is using, no special window thread ; Definition at line 142 of file RWebWindow.hxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:58696,authenticat,authentication,58696,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['authenticat'],['authentication']
Security,"in dedicated thread ; Definition at line 147 of file RWebWindow.hxx. ◆ fProtocol. std::string ROOT::RWebWindow::fProtocol. private . ! protocol ; Definition at line 177 of file RWebWindow.hxx. ◆ fProtocolCnt. int ROOT::RWebWindow::fProtocolCnt {-1}. private . ! counter for protocol recording ; Definition at line 174 of file RWebWindow.hxx. ◆ fProtocolConnId. unsigned ROOT::RWebWindow::fProtocolConnId {0}. private . ! connection id, which is used for writing protocol ; Definition at line 175 of file RWebWindow.hxx. ◆ fProtocolFileName. std::string ROOT::RWebWindow::fProtocolFileName. private . ! local file where communication protocol will be written ; Definition at line 173 of file RWebWindow.hxx. ◆ fProtocolPrefix. std::string ROOT::RWebWindow::fProtocolPrefix. private . ! prefix for created files names ; Definition at line 176 of file RWebWindow.hxx. ◆ fRequireAuthKey. bool ROOT::RWebWindow::fRequireAuthKey {true}. private . ! defines if authentication key always required when connect to the widget ; Definition at line 149 of file RWebWindow.hxx. ◆ fSendMT. bool ROOT::RWebWindow::fSendMT {false}. private . ! true is special threads should be used for sending data ; Definition at line 148 of file RWebWindow.hxx. ◆ fUseCurrentDir. bool ROOT::RWebWindow::fUseCurrentDir {false}. private . ! if window can access local files via currentdir/ path of http server ; Definition at line 158 of file RWebWindow.hxx. ◆ fUseProcessEvents. bool ROOT::RWebWindow::fUseProcessEvents {false}. private . ! all window functionality will run through process events ; Definition at line 146 of file RWebWindow.hxx. ◆ fUserArgs. std::string ROOT::RWebWindow::fUserArgs. private . ! arbitrary JSON code, which is accessible via conn.getUserArgs() method ; Definition at line 178 of file RWebWindow.hxx. ◆ fUseServerThreads. bool ROOT::RWebWindow::fUseServerThreads {false}. private . ! indicates that server thread is using, no special window thread ; Definition at line 145 of file RWebWindow.hxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:57580,authenticat,authentication,57580,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['authenticat'],['authentication']
Security,"inMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:41172,access,access,41172,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,1,['access'],['access']
Security,"inal input command.Definition TCling.cxx:6754; TCling::LoadLibraryMapInt_t LoadLibraryMap(const char *rootmapfile=nullptr) finalLoad map between class and library.Definition TCling.cxx:5741; TCling::BaseClassInfo_TagnumLongptr_t BaseClassInfo_Tagnum(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8545; TCling::LibraryUnloadedvoid LibraryUnloaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6981; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TEnumThe TEnum class implements the enum type.Definition TEnum.h:33; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::ECheckClassInfoECheckClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplates",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:92450,hash,hash,92450,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['hash'],['hash']
Security,"inalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); Save the partial results of this query to a dedicated file under the user; data directory. The file name has the form; <session_tag>.q<query_seq_num>.root; The file pat and the file are created if not existing already.; Only objects in the outputlist not being TProofOutputFile are saved.; The packets list 'packets' is saved if given.; Trees not attached to any file are attached to the open file.; If 'queryend' is kTRUE evrything is written out (TTrees included).; The actual saving action is controlled by 'force' and by fSavePartialResults; fSaveResultsPerPacket:. fSavePartialResults = kFALSE/kTRUE no-saving/saving; fSaveResultsPerPacket = kFALSE/kTRUE save-per-query/save-per-packet. The function CheckMemUsage sets fSavePa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:17636,access,accessed,17636,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,3,['access'],['accessed']
Security,"inalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF worker.; The return value is -1 in case of error and TSelector::GetStatus(); in case of success. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:16277,access,accessed,16277,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,3,['access'],['accessed']
Security,"inatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >& ); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:11535,access,access,11535,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,4,['access'],['access']
Security,"inatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >& ); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:11536,access,access,11536,root/html534/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,1,['access'],['access']
Security,"inatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >& ); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:11535,access,access,11535,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,4,['access'],['access']
Security,"inatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >& ); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:11536,access,access,11536,root/html534/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,1,['access'],['access']
Security,"indow * GetParent () const;  ; virtual Bool_t HandleExpose (Event_t *event);  ; virtual Bool_t HandleIdleEvent (TGIdleHandler *);  ; Bool_t HandleTimer (TTimer *) override;  Execute action in response of a timer timing out. ;  ; virtual void IconifyWindow ();  iconify window ;  ; virtual Bool_t IsMapped ();  Returns kTRUE if window is mapped on screen, kFALSE otherwise. ;  ; virtual void LowerWindow ();  lower window ;  ; void Print (Option_t *option="""") const override;  Print window id. ;  ; virtual void RaiseWindow ();  raise window ;  ; virtual void RequestFocus ();  request focus ;  ; virtual void SetBackgroundPixmap (Pixmap_t pixmap);  set background pixmap ;  ; virtual void SetName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGObject;  TGObject ();  ;  TGObject (const TGObject &tgo);  ;  ~TGObject () override;  TGObject destructor. ;  ; TGClient * GetClient () const;  ; Handle_t GetId () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison (TGObjects are equal if they have the same window identifier). ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Write this TGObject to a file using TImage, if filename's extension signals a valid TImage::EImageFileType, as defined by TImage::GetImageFileTypeFromFilename(). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveBrowser.html:20033,hash,hash,20033,doc/master/classTEveBrowser.html,https://root.cern,https://root.cern/doc/master/classTEveBrowser.html,10,['hash'],['hash']
Security,"indow_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; TH1D.h; TLeaf.h; TMath.h; TString.h; TVector.h; TXMLEngine.h; Tools.h; TMVA::ClassifierFactory::CreateIMethod * Create(const std::string &name, const TString &job, const TString &title, DataSetInfo &dsi, const TString &option)creates the method if needed based on the method name using the creator function the factory has stor...Definition ClassifierFactory.cxx:89; TMVA::ClassifierFactory::Instancestatic ClassifierFactory & Instance()access to the ClassifierFactory singleton creates the instance if neededDefinition ClassifierFactory.cxx:48; TMVA::Config::SetUseColorvoid SetUseColor(Bool_t uc)Definition Config.h:60; TMVA::Config::SetSilentvoid SetSilent(Bool_t s)Definition Config.h:63; TMVA::ConfigurableDefinition Configurable.h:45; TMVA::Configurable::SetConfigNamevoid SetConfigName(const char *n)Definition Configurable.h:63; TMVA::Configurable::ParseOptionsvirtual void ParseOptions()options parserDefinition Configurable.cxx:124; TMVA::DataSetInfo::AddVariableVariableInfo & AddVariable(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0, char varType='F', Bool_t normalized=kTRUE, void *external=nullptr)add a variable (can be a complex expression) to the set of variables used in the MV analysisDefinition DataSetInfo.cxx:207; TMVA::DataSetManagerClass that contains all the data information.Definition DataSetManager.h:51; TMVA::DataSetManager::AddDataSetInfoDataSetInfo & AddD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Reader_8cxx_source.html:33835,access,access,33835,doc/master/Reader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html,1,['access'],['access']
Security,"ine . Definition at line 69 of file RooLinkedList.h. ◆ Hash(). ULong_t RooLinkedList::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; RooLinkedList::HashULong_t Hash() const overrideReturn hash value for this object.Definition RooLinkedList.h:110; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 110 of file RooLinkedList.h. ◆ IndexOf() [1/2]. Int_t RooLinkedList::IndexOf ; (; const char * ; name); const. Return position of given object in list. ; If object is not contained in list, return -1 ; Definition at line 706 of file RooLinkedList.cxx. ◆ IndexOf() [2/2]. Int_t RooLinkedList::IndexOf ; (; const TObject * ; arg); const. Return position of given object in list. ; If object is not contained in list, return -1 ; Definition at line 690 of file RooLinkedList.cxx. ◆ IsA(). TClass * RooLinkedList::IsA ; (; ); const. inlineoverr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinkedList.html:21453,hash,hash,21453,doc/master/classRooLinkedList.html,https://root.cern,https://root.cern/doc/master/classRooLinkedList.html,1,['hash'],['hash']
Security,"ine 481 of file TUri.cxx. ◆ SetPort(). Bool_t TUri::SetPort ; (; const TString & ; port). Set port component of URI: ; port = *DIGIT. Definition at line 460 of file TUri.cxx. ◆ SetQuery(). Bool_t TUri::SetQuery ; (; const TString & ; query). Set query component of URI: ; query = *( pchar / ""/"" / ""?"" ). Definition at line 298 of file TUri.cxx. ◆ SetRelativePart(). Bool_t TUri::SetRelativePart ; (; const TString & ; relative). Returns kTRUE is string qualifies as relative-part: ; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Definition at line 777 of file TUri.cxx. ◆ SetScheme(). Bool_t TUri::SetScheme ; (; const TString & ; scheme). Set scheme component of URI: ; scheme = ALPHA *( ALPHA / DIGIT / ""+"" / ""-"" / ""."" ). Definition at line 248 of file TUri.cxx. ◆ SetUri(). Bool_t TUri::SetUri ; (; const TString & ; uri). Parse URI and set the member variables accordingly, returns kTRUE if URI validates, and kFALSE otherwise: ; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Definition at line 601 of file TUri.cxx. ◆ SetUserInfo(). Bool_t TUri::SetUserInfo ; (; const TString & ; userinfo). Set userinfo component of URI: ; userinfo = *( unreserved / pct-encoded / sub-delims / "":"" ). Definition at line 405 of file TUri.cxx. ◆ Streamer(). void TUri::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TUri::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 157 of file TUri.h. ◆ Transform(). TUri TUri::Transform ; (; const TUri & ; reference, . const TUri & ; base . ). static . Transform a URI reference into its target URI using given a base URI. ; This is an implementation of the pseudocode in chapter 5.2.2. ; Definition at line 1122 of file TUri.cxx. Friends And Related Symbol Documentation. ◆ operator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUri.html:31775,validat,validates,31775,doc/master/classTUri.html,https://root.cern,https://root.cern/doc/master/classTUri.html,1,['validat'],['validates']
Security,"ine 59 of file TXMLParser.h. ◆ GetParseCodeMessage(). const char * TXMLParser::GetParseCodeMessage ; (; Int_t ; parseCode); const. Returns the parse code message. ; Definition at line 122 of file TXMLParser.cxx. ◆ GetReplaceEntities(). Bool_t TXMLParser::GetReplaceEntities ; (; ); const. inline . Definition at line 53 of file TXMLParser.h. ◆ GetStopOnError(). Bool_t TXMLParser::GetStopOnError ; (; ); const. inline . Definition at line 64 of file TXMLParser.h. ◆ GetValidate(). Bool_t TXMLParser::GetValidate ; (; ); const. inline . Definition at line 50 of file TXMLParser.h. ◆ GetValidateError(). const char * TXMLParser::GetValidateError ; (; ); const. inline . Definition at line 66 of file TXMLParser.h. ◆ GetValidateWarning(). const char * TXMLParser::GetValidateWarning ; (; ); const. inline . Definition at line 67 of file TXMLParser.h. ◆ InitializeContext(). void TXMLParser::InitializeContext ; (; ). protectedvirtual . Initialize parser parameters, such as, disactivate non-standards libxml1 features, on/off validation, clear error and warning messages. ; Definition at line 152 of file TXMLParser.cxx. ◆ IsA(). TClass * TXMLParser::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 69 of file TXMLParser.h. ◆ OnValidateError(). void TXMLParser::OnValidateError ; (; const TString & ; message). protectedvirtual . This function is called when an error from the parser has occurred. ; Message is the parse error. ; Definition at line 105 of file TXMLParser.cxx. ◆ OnValidateWarning(). void TXMLParser::OnValidateWarning ; (; const TString & ; message). protectedvirtual . This function is called when a warning from the parser has occurred. ; Message is the parse error. ; Definition at line 114 of file TXMLParser.cxx. ◆ operator=(). TXMLParser & TXMLParser::operator= ; (; const TXMLParser & ; ). privatedelete . ◆ ParseBuffer(). virtual Int_t TXMLParser::ParseBuffer ; (; const char * ; contents, . I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLParser.html:18914,validat,validation,18914,doc/master/classTXMLParser.html,https://root.cern,https://root.cern/doc/master/classTXMLParser.html,1,['validat'],['validation']
Security,"ine(""b1"", [](ULong64_t entry) -> double { return entry; }, {""rdfentry_""}); .Define(""b2"", [](ULong64_t entry) -> int { return entry * entry; }, {""rdfentry_""}); .Snapshot(treeName, fileName);; }; ; int df001_introduction(); {; ; // We prepare an input tree to run on; auto fileName = ""df001_introduction.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame, a class that; // allows us to interact with the data contained in the tree.; // We select a default column, a *branch* to adopt ROOT jargon, which will; // be looked at if none is specified by the user when dealing with filters; // and actions.; ROOT::RDataFrame d(treeName, fileName, {""b1""});; ; // ## Operations on the dataframe; // We now review some *actions* which can be performed on the data frame.; // Actions can be divided into instant actions (e. g. Foreach()) and lazy; // actions (e. g. Count()), depending on whether they trigger the event; // loop immediately or only when one of the results is accessed for the; // first time. Actions that return ""something"" either return their result; // wrapped in a RResultPtr or in a RDataFrame.; // But first of all, let us define our cut-flow with two lambda; // functions. We can use free functions too.; auto cutb1 = [](double b1) { return b1 < 5.; };; auto cutb1b2 = [](int b2, double b1) { return b2 % 2 && b1 < 4.; };; ; // ### `Count` action; // The `Count` allows to retrieve the number of the entries that passed the; // filters. Here, we show how the automatic selection of the column kicks; // in in case the user specifies none.; auto entries1 = d.Filter(cutb1) // <- no column name specified here!; .Filter(cutb1b2, {""b2"", ""b1""}); .Count();; ; std::cout << *entries1 << "" entries passed all filters"" << std::endl;; ; // Filters can be expressed as strings. The content must be C++ code. The; // name of the variables must be the name of the branches. The code is; // just-in-time compiled.; auto entries",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df001__introduction_8C.html:1685,access,accessed,1685,doc/master/df001__introduction_8C.html,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html,1,['access'],['accessed']
Security,"ineRawcurrent line; TStringfLineSourcecurrent line with links; TStringfLineStrippedcurrent line without surrounding spaces; map<std::string,Int_t>fMethodCountsnumber of undocumented overloads; THashListfMethods[3]methods as TMethodWrapper objects (by access); list<UInt_t>fParseContextcurrent context of parsed sources; TClass*fRecentClassrecently seen class context of sources being parsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source info elements (copyright, last changed, author); static set<std::string>fgKeywordsC++ keywords. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDocParser(TClassDocOutput& docOutput, TClass* cl); Constructor called for parsing class sources. TDocParser(TDocOutput& docOutput); constructor called for parsing text files with Convert(). ~TDocParser(); destructor, checking whether all methods have been found for gDebug > 3. void AddClassMethodsRecursively(TBaseClass* bc); Add accessible (i.e. non-private) methods of base class bc; and its base classes' methods to methodNames.; If bc==0, we add fCurrentClass's methods (and also private functions). void AddClassDataMembersRecursively(TBaseClass* bc); Add data members of fCurrentClass and of bc to datamembers, recursively.; Real data members are in idx 0..2 (public, protected, private access),; enum constants in idx 3..5. void AnchorFromLine(const TString& line, TString& anchor); Create an anchor from the given line, by hashing it and; convertig the hash into a custom base64 string. void Convert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); Parse text file ""in"", add links etc, and write output to ""out"".; If ""isCode"", ""in"" is assumed to be C++ code. void DecorateKeywords(ostream& out, const char* text); Expand keywords in text, writing to out. void DecorateKeywords(TString& text); Find keywords in line and create URLs around them. Escape characte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDocParser.html:11105,access,accessible,11105,root/html528/TDocParser.html,https://root.cern,https://root.cern/root/html528/TDocParser.html,3,['access'],['accessible']
Security,"ined(_MSC_VER); 728 ; 729namespace {; 730 ; 731 /////////////////////////////////////////////////////////////////////////////; 732 /// Block read - if your platform needs to do endian-swapping or can only; 733 /// handle aligned reads, do the conversion here; 734 ; 735 R__ALWAYS_INLINE uint64_t getblock(const uint64_t* p, int i); 736 {; 737 return p[i];; 738 }; 739 ; 740 /////////////////////////////////////////////////////////////////////////////; 741 /// Finalization mix - force all bits of a hash block to avalanche; 742 ; 743 R__ALWAYS_INLINE uint64_t fmix(uint64_t k); 744 {; 745 k ^= k >> 33;; 746 k *= BIG_CONSTANT(0xff51afd7ed558ccd);; 747 k ^= k >> 33;; 748 k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);; 749 k ^= k >> 33;; 750 ; 751 return k;; 752 }; 753 ; 754 /////////////////////////////////////////////////////////////////////////////; 755 /// ""key"" is input to be hashed.; 756 /// ""len"" is the number of bytes to hash starting at ""key"".; 757 /// ""seed"" is a hash seed, ""out"" is a buffer (128 bytes) that will receive; 758 /// the results.; 759 ; 760 static void MurmurHash3_x64_128(const void * key, const int len,; 761 const uint32_t seed, uint64_t out[2] ); 762 {; 763 const uint8_t * data = (const uint8_t*)key;; 764 const int nblocks = len / 16;; 765 ; 766 uint64_t h1 = seed;; 767 uint64_t h2 = seed;; 768 ; 769 uint64_t c1 = BIG_CONSTANT(0x87c37b91114253d5);; 770 uint64_t c2 = BIG_CONSTANT(0x4cf5ad432745937f);; 771 ; 772 //----------; 773 // body; 774 ; 775 const uint64_t * blocks = (const uint64_t *)(data);; 776 ; 777 for(int i = 0; i < nblocks; i++); 778 {; 779 uint64_t k1 = getblock(blocks,i*2+0);; 780 uint64_t k2 = getblock(blocks,i*2+1);; 781 ; 782 k1 *= c1; k1 = ROTL64(k1,31); k1 *= c2; h1 ^= k1;; 783 ; 784 h1 = ROTL64(h1,27); h1 += h2; h1 = h1*5+0x52dce729;; 785 ; 786 k2 *= c2; k2 = ROTL64(k2,33); k2 *= c1; h2 ^= k2;; 787 ; 788 h2 = ROTL64(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;; 789 }; 790 ; 791 //----------; 792 // tail; 793 ; 794 const uint8_t * tail = (const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:22687,hash,hash,22687,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['hash'],['hash']
Security,"inefinalvirtual . Returns the current file size. ; Returns -1 in case the file could not be stat'ed. ; Reimplemented from TFile.; Definition at line 71 of file TXMLFile.h. ◆ GetStreamerInfoListImpl(). TFile::InfoListRet TXMLFile::GetStreamerInfoListImpl ; (; bool ; lookupSICache). finalprotectedvirtual . Read streamerinfo structures from xml format and provide them in the list It is user responsibility to destroy this list. ; Reimplemented from TFile.; Definition at line 715 of file TXMLFile.cxx. ◆ InitXmlFile(). void TXMLFile::InitXmlFile ; (; Bool_t ; create). protected . initialize xml file and correspondent structures identical to TFile::Init() function ; Definition at line 262 of file TXMLFile.cxx. ◆ IsA(). TClass * TXMLFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFile.; Definition at line 140 of file TXMLFile.h. ◆ IsOpen(). Bool_t TXMLFile::IsOpen ; (; ); const. finalvirtual . return kTRUE if file is opened and can be accessed ; Reimplemented from TFile.; Definition at line 363 of file TXMLFile.cxx. ◆ MakeFree(). void TXMLFile::MakeFree ; (; Long64_t ; first, . Long64_t ; last . ). inlinefinalvirtual . Mark unused bytes on the file. ; The list of free segments is in the fFree linked list. When an object is deleted from the file, the freed space is added into the FREE linked list (fFree). The FREE list consists of a chain of consecutive free segments on the file. At the same time, the first 4 bytes of the freed record on the file are overwritten by GAPSIZE where GAPSIZE = -(Number of bytes occupied by the record). ; Reimplemented from TFile.; Definition at line 77 of file TXMLFile.h. ◆ MakeProject(). void TXMLFile::MakeProject ; (; const char * ; dirname, . const char * ; classes = ""*"", . Option_t * ; option = ""new"" . ). inlinefinalvirtual . Generate source code necessary to access the objects stored in the file. ; Generate code in directory dirname for all classes specified in argument classes If",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:56527,access,accessed,56527,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['access'],['accessed']
Security,ing C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.c,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:81557,access,access,81557,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['access'],['access']
Security,"ing HTTP as the transport protocol.; The 'options' argument can contain 'NOPROXY' if you want to bypass the HTTP proxy when retrieving this file's contents. As for any TWebFile-derived object, the URL of the web proxy can be specified by setting an environmental variable 'http_proxy'. If this variable is set, we ask that proxy to route our requests HTTP(S) requests to the file server.; In addition, you can also use the 'options' argument to provide the access key and secret key to be used for authentication purposes for this file by using a string of the form ""AUTH=myAccessKey:mySecretkey"". This may be useful to open several files hosted by different providers in the same program/macro, where the environemntal variables solution is not convenient (see below).; To use AWS temporary security credentials you need to specify the session token. This can be added to the options argument with a string of the form TOKEN=mySessionToken. The temporary access and secret keys must also be available, either via the AUTH option or by environmental variable.; If you need to specify more than one option separate them by ' ' (blank), for instance: ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+""; Examples: TFile* f1 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f2 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f3 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""TOKEN=AQoDYXdzEM///////////wEa8AHEYmCinjD+TsGEjtgKSMAT6wnY"");; If there is no authentication information in the 'options' argument (i.e. not AUTH=""...."") the values of the environmental variables S3_ACCESS_KEY and S3_SECRET_KEY (if set) are expected to contain the access key id and the secret access key, respectively. You have been provided with these credentials by your S3 service provid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:50033,access,access,50033,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['access'],['access']
Security,"ing class std::pair<int,double>'; ; # Note that, to pythonize multiple classes in different namespaces, we can; # stack multiple @pythonization decorators. For example, if we define these; # classes:; ROOT.gInterpreter.Declare('''; class FirstClass {};; namespace NS {; class SecondClass {};; }; '''); ; # We can pythonize both of them with a single pythonizor function like so:; @pythonization('FirstClass'); @pythonization('SecondClass', ns='NS'); def pythonizor_for_first_and_second(klass, name):; print('Executed for class ' + name); ; # If we now access both classes, we should see that the pythonizor runs twice.; f = ROOT.FirstClass(); s = ROOT.NS.SecondClass(); ; # So far we have seen how pythonizations can be registered for classes that; # have not been used yet. We have discussed how, in that case, the pythonizor; # functions are executed lazily when their target class/es are used for the; # first time in the application.; # However, it can also happen that our target class/es have already been; # accessed by the time we register a pythonization. In such a scenario, the; # pythonizor is applied immediately (at registration time) to the target; # class/es.; ; # Let's see an example of what was just explained. We will define a new class; # and immediately create an object of that class. We can check how the object; # still does not have a new attribute `pythonized` that we are going to inject; # in the next step.; ROOT.gInterpreter.Declare('''; class MyClass2 {};; '''); o = ROOT.MyClass2(); try:; print(o.pythonized); except AttributeError:; print(""Object has not been pythonized yet!""); ; # After that, we will register a pythonization for `MyClass2`. Since the class; # has already been used, the pythonization will happen right away.; @pythonization('MyClass2'); def pythonizor_for_myclass2(klass):; klass.pythonized = True; ; # Now our object does have the `pythonized` attribute:; print(o.pythonized) # prints True; formatOption_t Option_t TPoint TPoint const char GetTex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html:8221,access,accessed,8221,doc/master/pyroot002__pythonizationDecorator_8py.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html,1,['access'],['accessed']
Security,"ing class, which; 27holds a reference to the original string and its data, along with; 28the offset and length of the substring. To retrieve the substring; 29as a TString, construct a TString from it, eg:; 30~~~ {.cpp}; 31 root [0] TString s(""hello world""); 32 root [1] TString s2( s(0,5) ); 33 root [2] s2; 34 (class TString)""hello""; 35~~~; 36*/; 37 ; 38#include <ROOT/RConfig.hxx>; 39#include <stdlib.h>; 40#include <ctype.h>; 41#include <list>; 42#include <algorithm>; 43 ; 44#include ""Varargs.h""; 45#include ""strlcpy.h""; 46#include ""TString.h""; 47#include ""TBuffer.h""; 48#include ""TError.h""; 49#include ""Bytes.h""; 50#include ""TClass.h""; 51#include ""TMD5.h""; 52#include ""TObjArray.h""; 53#include ""TObjString.h""; 54#include ""TVirtualMutex.h""; 55#include ""ThreadLocalStorage.h""; 56 ; 57#if defined(R__WIN32); 58#define strtoull _strtoui64; 59#endif; 60 ; 61#ifdef R__GLOBALSTL; 62namespace std { using ::list; }; 63#endif; 64 ; 65ClassImp(TString);; 66 ; 67// Amount to shift hash values to avoid clustering; 68const UInt_t kHashShift = 5;; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71//; 72// In what follows, fCap is the length of the underlying representation; 73// vector. Hence, the capacity for a null terminated string held in this; 74// vector is fCap-1. The variable fSize is the length of the held; 75// string, excluding the terminating null.; 76//; 77// The algorithms make no assumptions about whether internal strings; 78// hold embedded nulls. However, they do assume that any string; 79// passed in as an argument that does not have a length count is null; 80// terminated and therefore has no embedded nulls.; 81//; 82// The internal string is always null terminated.; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// TString default ctor.; 86 ; 87TString::TString(); 88{; 89 Zero();; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:2107,hash,hash,2107,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['hash'],['hash']
Security,"ing matching ""pattern"", or the null substring if there is no such match.Definition TString.cxx:1657; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReadStringstatic TString * ReadString(TBuffer &b, const TClass *clReq)Read TString object from buffer.Definition TString.cxx:1362; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::MaybeRegexpBool_t MaybeRegexp() constReturns true if string contains one of the regexp characters ""^$.[]*+?"".Definition TString.cxx:952; TString::ResizeIncrementstatic Ssiz_t ResizeIncrement(Ssiz_t ri=16)Set default resize increment for all TStrings. Default is 16.Definition TString.cxx:1602; TString::HashCaseUInt_t HashCase() constReturn a case-sensitive hash value (endian independent).Definition TString.cxx:633; TString::IsOctBool_t IsOct() constReturns true if all characters in string are octal digits (0-7).Definition TString.cxx:1924; TString::~TStringvirtual ~TString()Delete a TString.Definition TString.cxx:251; TString::CapacitySsiz_t Capacity() constDefinition TString.h:364; TString::GetMaxWastestatic Ssiz_t GetMaxWaste()Definition TString.cxx:1584; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::AdjustCapacitystatic Ssiz_t AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap)Calculate a nice capacity greater than or equal to newCap.Definition TString.cxx:1220; TString::MD5TString MD5() constReturn the MD5 digest for this string, in a string representation.Definition TString.cxx:940; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::EStripTypeEStripTypeDefinition TString.h:276;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:99268,hash,hash,99268,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['hash'],['hash']
Security,"ing matrix of a given node. . Visualization. This category allows changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button “All” allows viewing all volumes down to the selected depth. “Leaves” will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. “Only” will allow drawing only the edited volume. The check button “Raytrace” will just draw the current selection in solid mode using the ray-tracing algorithm provided by TGeo. . Division. Allows dividing the edited volume according a given pattern. The division axes that are allowed are presented in a radio-button group. The number entries labeled “From”, “Step” and “Nslices” correspond to the divisioning parameters on the selected axis. The range of the division is between start and start+ndiv*step values and its validity is checked upon changing one of the values. NOTE: When changing a value in a number entry by typing a number, press ENTER at the end to validate. This applies for taking into account and validation of any number change in the geometry editors.; 18.11.6 How to Create a Valid Geometry with Geometry Editors. Create a new geometry manager and start the editor as described at the beginning.; Create at least one material from the “Materials” shutter item category. Generally, for creating objects, the interface is always in the TGeoManagerEditor in different categories - one should just provide a name and requested parameters.; Create a shape that will be used for the top volume within the “Shapes” category. For the moment, the shapes that have editors are Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype, Pcon, Torus and Sphere.; Create a medium from one of the existing materials from the “Medium” category. You will notice that some categories as “Volume” and “Medium” are inactive at the beginning because at that time there is no material yet (for making a medium) a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1039380,validat,validate,1039380,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['validat'],['validate']
Security,"ing model : {'optimizer': <class 'torch.optim.adam.Adam'>, 'criterion': BCELoss(), 'train_func': <function fit at 0x7fe43c5d1b80>, 'predict_func': <function predict at 0x7fe43c5d1ca0>}; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 16, 16, 1) 0 ; ; conv2d (Conv2D) (None, 16, 16, 10) 100 ; ; batch_normalization (Batch (None, 16, 16, 10) 40 ; Normalization) ; ; conv2d_1 (Conv2D) (None, 16, 16, 10) 910 ; ; max_pooling2d (MaxPooling2 (None, 15, 15, 10) 0 ; D) ; ; flatten (Flatten) (None, 2250) 0 ; ; dense (Dense) (None, 256) 576256 ; ; dense_1 (Dense) (None, 2) 514 ; ; =================================================================; Total params: 577820 (2.20 MB); Trainable params: 577800 (2.20 MB); Non-trainable params: 20 (80.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; Epoch 1/10; ; 1/13 [=>............................] - ETA: 10s - loss: 0.9275 - accuracy: 0.4600␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 4/13 [========>.....................] - ETA: 0s - loss: 2.4547 - accuracy: 0.4675 ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 7/13 [===============>..............] - ETA: 0s - loss: 1.8505 - accuracy: 0.4886␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 10/13 [======================>.......] - ETA: 0s - loss: 1.5967 - accuracy: 0.5030␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 13/13 [==============================] - ETA: 0s - loss: 1.4175 - accuracy: 0.4922; Epoch 1: val_loss improved from inf to 0.86968, saving model to trained_model_cnn.h5; ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:17779,validat,validation,17779,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['validat'],['validation']
Security,"ing object; 25static TInterpreter *gInterpreterLocal = nullptr; // The real holder of the pointer.; 26 ; 27 ; 28namespace {; 29static struct AddPseudoGlobals {; 30AddPseudoGlobals() {; 31 ; 32 // use special functor to extract pointer on gInterpreterLocal variable; 33 TGlobalMappedFunction::MakeFunctor(""gInterpreter"", ""TInterpreter*"", TInterpreter::Instance, [] {; 34 TInterpreter::Instance();; 35 return (void *) &gInterpreterLocal;; 36 });; 37 ; 38}; 39} gAddPseudoGlobals;; 40}; 41 ; 42 ; 43ClassImp(TInterpreter);; 44 ; 45////////////////////////////////////////////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT = ROOT::GetROOT(); // Make sure gInterpreterLocal is set; 62 if (!getROOT) {; 63 ::Fatal(""TInterpreter::Instance"",""TROOT object is required before accessing a TInterpreter"");; 64 }; 65 }; 66 return gInterpreterLocal;; 67}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; namechar name[80]Definition TGX11.cxx:110; TGlobal.h; gInterpreterLocalstatic TInterpreter * gInterpreterLocalDefinition TInterpreter.cxx:25; gClingTInterpreter * gClingDefinition TInterpreter.cxx:24; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::TInterpreterTInterpreter()Definition TInterpreter.h:135; TInterpreter::Instancestatic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8cxx_source.html:2147,access,accessing,2147,doc/master/TInterpreter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html,1,['access'],['accessing']
Security,"ing the 3D transformation in any rotation and any vector (the Translation class could also be used) ; Definition at line 558 of file Transform3D.h. ◆ GetDecomposition() [2/2]. template<typename T = double> . void ROOT::Math::Impl::Transform3D< T >::GetDecomposition ; (; Rotation3D & ; r, . Vector & ; v . ); const. inline . Get the rotation and translation vector representing the 3D transformation. ; Definition at line 567 of file Transform3D.h. ◆ GetRotation(). template<typename T = double> . template<class AnyRotation > . void ROOT::Math::Impl::Transform3D< T >::GetRotation ; (; AnyRotation & ; r); const. inline . Get the rotation (any type) representing the 3D transformation. ; Definition at line 593 of file Transform3D.h. ◆ GetTransformMatrix(). template<typename T = double> . template<class ForeignMatrix > . void ROOT::Math::Impl::Transform3D< T >::GetTransformMatrix ; (; ForeignMatrix & ; m); const. inline . Get components into a linear algebra matrix of size at least 3x4, which must support operator()(i,j) for write access to elements (0,0) thru (2,3). ; Definition at line 525 of file Transform3D.h. ◆ GetTranslation(). template<typename T = double> . template<class AnyVector > . void ROOT::Math::Impl::Transform3D< T >::GetTranslation ; (; AnyVector & ; v); const. inline . Get the translation representing the 3D transformation in any vector which implements the SetXYZ method. ; Definition at line 607 of file Transform3D.h. ◆ Inverse(). template<typename T = double> . Transform3D< T > ROOT::Math::Impl::Transform3D< T >::Inverse ; (; ); const. inline . Return the inverse of the transformation. ; Definition at line 877 of file Transform3D.h. ◆ Invert() [1/2]. template<typename T = double> . template<typename SCALAR = T, typename std::enable_if< std::is_arithmetic< SCALAR >::value >::type * = nullptr> . void ROOT::Math::Impl::Transform3D< T >::Invert ; (; ). inline . Invert the transformation in place (scalar) ; Definition at line 794 of file Transform3D.h. ◆ Inver",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Impl_1_1Transform3D.html:26550,access,access,26550,doc/master/classROOT_1_1Math_1_1Impl_1_1Transform3D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Impl_1_1Transform3D.html,1,['access'],['access']
Security,"ing the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the indices, corresponding to; children nodes or the parent node:; Suppose, the parent node is stored under the index inode. Then:; Left child index = inode*2+1; Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the follo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDTree_int_double_.html:7100,access,access,7100,root/html528/TKDTree_int_double_.html,https://root.cern,https://root.cern/root/html528/TKDTree_int_double_.html,12,['access'],['access']
Security,"ing& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. First ~/.rootnetrc is tried, after that ~/.netrc.; These files will only be used when their access masks are 0600.; Returns kTRUE if user and passwd were found for the machine; specified in the URL. If kFALSE, user and passwd are """".; If srppwd == kTRUE then a SRP ('secure') pwd is searched for in; the files.; The boolean pwhash is set to kTRUE if the returned passwd is to; be understood as password hash, i.e. if the 'password-hash' keyword; is found in the 'machine' lines; not implemented for 'secure'; and the .netrc file.; The format of these files are:. # this is a comment line; machine <machine fqdn> login <user> password <passwd>; machine <machine fqdn> login <user> password-hash <passwd>. and in addition ~/.rootnetrc also supports:. secure <machine fqdn> login <user> password <passwd>. <machine fqdn> may be a domain name or contain the wild card '*'. for the secure protocols. All lines must start in the first column. const char * GetGlobalUser(); Static method returning the global user. Bool_t GetGlobalPwHash(); Static method returning the global password hash flag. Bool_t GetGlobalSRPPwd(); Static method returning the global SRP password flag. TDatime GetGlobalExpDate(); Static method returning default expiring date for new validity contexts. const char * GetDefaultUser(); Static method returning the default user information. const char * GetKrb5Principal(); Static method returning the principal to be used to init Krb5 tickets. Bool_t GetAuthReUse(); Static method returning the authentication reuse settings. Bool_t GetPromptUser(); Static method returning the prompt user settings. const char * GetAuthMethod(Int_t idx); Static method returning the method corresponding to idx. Int_t GetAuthMethodIdx(const char* meth); Static method returning the method index (which can be used to find; the method in GetAuthMethod()). Returns -1 in case meth is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:12921,secur,secure,12921,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['secur'],['secure']
Security,"ing>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Int_t_coefIdxIndex code of the coefficient; RooRealProxy_convPdfRooAbsAnaConv object implementing our coefficient; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConvCoefVar.html:34922,access,access,34922,root/html602/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html602/RooConvCoefVar.html,2,['access'],['access']
Security,"inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TProofServ; virtual void DeletePlayer ();  Delete player instance. ;  ; virtual Int_t Fork ();  Fork a child. ;  ; Int_t GetSessionStatus ();  Return the status of this session: 0 idle 1 running 2 being terminated (currently unused) 3 queued 4 idle timed-out (not set in here but in TIdleTOTimer::Notify) This is typically run in the reader thread, so access needs to be protected. ;  ; virtual void HandleArchive (TMessage *mess, TString *slb=0);  Handle archive request. ;  ; virtual Int_t HandleCache (TMessage *mess, TString *slb=0);  Handle here all cache and package requests. ;  ; virtual void HandleCheckFile (TMessage *mess, TString *slb=0);  Handle file checking request. ;  ; virtual Int_t HandleDataSets (TMessage *mess, TString *slb=0);  Handle here requests about datasets. ;  ; virtual Int_t HandleLibIncPath (TMessage *mess);  Handle lib, inc search paths modification request. ;  ; virtual void HandleProcess (TMessage *mess, TString *slb=0);  Handle processing request. ;  ; virtual void HandleQueryList (TMessage *mess);  Handle request for list of queries. ;  ; virtual void HandleRemove (TMessage *mess, TString *slb=0);  Handle remove request. ;  ; virtual void HandleRetrieve (TMessage *mess, TString *slb=0);  Handle retr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServLite.html:24102,access,access,24102,doc/master/classTProofServLite.html,https://root.cern,https://root.cern/doc/master/classTProofServLite.html,1,['access'],['access']
Security,"ining the class declaration ; Definition at line 207 of file TAuthenticate.h. ◆ DecodeRSAPublic(). Int_t TAuthenticate::DecodeRSAPublic ; (; const char * ; rsapubexport, . R__rsa_NUMBER & ; n, . R__rsa_NUMBER & ; d, . char ** ; rsassl = nullptr . ). static . Store RSA public keys from export string rsaPubExport. ; Definition at line 2936 of file TAuthenticate.cxx. ◆ FileExpand(). void TAuthenticate::FileExpand ; (; const char * ; fexp, . FILE * ; ftmp . ). staticprivate . Expands include directives found in fexp files The expanded, temporary file, is pointed to by 'ftmp' and should be already open. ; To be called recursively. ; Definition at line 2093 of file TAuthenticate.cxx. ◆ GenRSAKeys(). Int_t TAuthenticate::GenRSAKeys ; (; ). private . Generate a valid pair of private/public RSA keys to protect for authentication token exchange. ; Definition at line 2501 of file TAuthenticate.cxx. ◆ GetAuthInfo(). TList * TAuthenticate::GetAuthInfo ; (; ). static . Static method returning the list with authentication details. ; Definition at line 1236 of file TAuthenticate.cxx. ◆ GetAuthMethod(). const char * TAuthenticate::GetAuthMethod ; (; Int_t ; idx). static . Static method returning the method corresponding to idx. ; Definition at line 1067 of file TAuthenticate.cxx. ◆ GetAuthMethodIdx(). Int_t TAuthenticate::GetAuthMethodIdx ; (; const char * ; meth). static . Static method returning the method index (which can be used to find the method in GetAuthMethod()). ; Returns -1 in case meth is not found. ; Definition at line 1082 of file TAuthenticate.cxx. ◆ GetAuthReUse(). Bool_t TAuthenticate::GetAuthReUse ; (; ). static . Static method returning the authentication reuse settings. ; Definition at line 1051 of file TAuthenticate.cxx. ◆ GetClientProtocol(). Int_t TAuthenticate::GetClientProtocol ; (; ). static . Static method returning supported client protocol. ; Definition at line 3889 of file TAuthenticate.cxx. ◆ GetDefaultDetails(). char * TAuthenticate::GetDefaultDetails",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:26193,authenticat,authentication,26193,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"initial file access mode; param title: title of the file (shown by ROOT browser); param compress: compression level and algorithm; param netopt: TCP window size in bytes (unused); param parallelopen: open asynchronously. ~TNetXNGFile(); Destructor. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Long64_t GetSize() const; Get the file size. Returns -1 in the case that the file could not be; stat'ed. Bool_t IsOpen() const; Check if the file is open. void SetAsyncOpenStatus(TFile::EAsyncOpenStatus status); Set the status of an asynchronous file open. void Close(Option_t* option = """"); Close the file. param option: if == ""R"", all TProcessIDs referenced by this file are; deleted (is this valid in xrootd context?). Int_t ReOpen(Option_t* modestr); Reopen the file with the new access mode. param mode: the new access mode; returns: 0 in case the mode was successfully modified, 1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGFile.html:23999,access,access,23999,root/html534/TNetXNGFile.html,https://root.cern,https://root.cern/root/html534/TNetXNGFile.html,1,['access'],['access']
Security,"inition Rtypes.h:346; TArrayC.h; TArrayF.h; TArrayI.h; TArrayL64.h; TArrayL.h; TArrayS.h; TExMap.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; THnBase.h; THnSparseLTHnSparseT< TArrayL64 > THnSparseLDefinition THnSparse.h:222; THnSparseSTHnSparseT< TArrayS > THnSparseSDefinition THnSparse.h:224; THnSparseFTHnSparseT< TArrayF > THnSparseFDefinition THnSparse.h:221; THnSparseCTHnSparseT< TArrayC > THnSparseCDefinition THnSparse.h:225; THnSparseDTHnSparseT< TArrayD > THnSparseDDefinition THnSparse.h:220; THnSparseITHnSparseT< TArrayI > THnSparseIDefinition THnSparse.h:223; THnSparse_Internal.h; ROOT::Internal::THnBaseBinIterIterator over THnBase bins (internal implementation).Definition THnBase.h:315; TArrayAbstract array base class.Definition TArray.h:31; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH3D3-D histogram with a double per channel (see TH1 documentation)Definition TH3.h:363; THnBaseMultidimensional histogram base.Definition THnBase.h:43; THnBase::AddBinContentvoid AddBinContent(const Int_t *x, Double_t v=1.)Definition THnBase.h:191; THnBase::ProjectionTH1D * Projection(Int_t xDim, Option_t *option="""") constProject all bins into a 1-dimensional histogram, keeping only axis ""xDim"".Definition THnBase.h:226; THnBase::CreateHnAnystatic THnBase * CreateHnAny(const char *name, const char *title, const TH1 *h1, Bool_t sparse, Int_t chunkSize=1024 *16)Create a THn / THnSparse object from a histogram deriving from TH1.Definition THnBase.cxx:323; THnBase::RebinBaseTHnB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8h_source.html:10674,hash,hash,10674,doc/master/THnSparse_8h_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html,1,['hash'],['hash']
Security,"inition RtypesCore.h:46; TFile.h; TH1.h; TH2.h; TProfile.h; TRandom.h; TTree.h; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:621; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TProfileProfile Histogram.Definition TProfile.h:32; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169. PyROOT; The TTree class has several additions for its use from Python, which are also available in its subclasses e.g. TChain and TNtuple.; First, TTree instances are iterable in Python. Therefore, assuming t is a TTree instance, we can do: for entry in t:; x = entry.branch_name; ...; At each iteration, a new entry of the tree will be read. In the code above, entry allows to access the branch values for the current entry. This can be done with the syntax entry.branch_name or, if the branch name is incompatible with Python naming rules, with e.g. ""getattr(entry, '1_branch_name')"".; Please note that iterating in Python can be slow, so only iterate over a tree as described above if performance is not an issue or when dealing with a small dataset. To read and process the entries of a tree in a much faster way, please use ROOT::RDataFrame.; Second, a couple of TTree methods have been modified to facilitate their use from Python: TTree::Branch and TTree::SetBranchAddress.; Regarding TTree::Branch, the following example shows how we can create different types of branches of a TTree. Note that Branch will just link the new branch with a given Python object, so it is still necessary to fill such object with the desired content before calling TTree::Fill. from array import array; import numpy as np; import ROOT; from ROOT import addressof; ; # Basic type branch (float) - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:15156,access,access,15156,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['access'],['access']
Security,"inition RtypesCore.h:46; TFile.h; TH1.h; TH2.h; TProfile.h; TRandom.h; TTree.h; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TProfileProfile Histogram.Definition TProfile.h:32; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169. PyROOT; The TTree class has several additions for its use from Python, which are also available in its subclasses e.g. TChain and TNtuple.; First, TTree instances are iterable in Python. Therefore, assuming t is a TTree instance, we can do: for entry in t:; x = entry.branch_name; ...; At each iteration, a new entry of the tree will be read. In the code above, entry allows to access the branch values for the current entry. This can be done with the syntax entry.branch_name or, if the branch name is incompatible with Python naming rules, with e.g. ""getattr(entry, '1_branch_name')"".; Please note that iterating in Python can be slow, so only iterate over a tree as described above if performance is not an issue or when dealing with a small dataset. To read and process the entries of a tree in a much faster way, please use ROOT::RDataFrame.; Second, a couple of TTree methods have been modified to facilitate their use from Python: TTree::Branch and TTree::SetBranchAddress.; Regarding TTree::Branch, the following example shows how we can create different types of branches of a TTree. Note that Branch will just link the new branch with a given Python object, so it is still necessary to fill such object with the desired content before calling TTree::Fill. from array import array; import numpy as np; import ROOT; from ROOT import addressof; ; # Basic type branch (float) - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:15157,access,access,15157,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['access'],['access']
Security,"inition TCollectionProxyInfo.h:779; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::clearstatic void * clear(void *env)Definition TCollectionProxyInfo.h:775; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Env_tEnviron< Iter_t > Env_tDefinition TCollectionProxyInfo.h:760; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:770; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::objectstatic PCont_t object(void *ptr)Definition TCollectionProxyInfo.h:767; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:761; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Cont_tBitset_t Cont_tDefinition TCollectionProxyInfo.h:757; ROOT::Detail::TCollectionProxyInfo::TypeSmall helper to encapsulate basic data accesses for all STL continers.Definition TCollectionProxyInfo.h:295; ROOT::Detail::TCollectionProxyInfo::Type::fgLargeIteratorstatic const bool fgLargeIteratorDefinition TCollectionProxyInfo.h:359; ROOT::Detail::TCollectionProxyInfo::Type::clearstatic void * clear(void *env)Definition TCollectionProxyInfo.h:314; ROOT::Detail::TCollectionProxyInfo::Type::destructstatic void destruct(void *what, size_t size)Definition TCollectionProxyInfo.h:353; ROOT::Detail::TCollectionProxyInfo::Type::firststatic void * first(void *env)Definition TCollectionProxyInfo.h:318; ROOT::Detail::TCollectionProxyInfo::Type::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:309; ROOT::Detail::TCollectionProxyInfo::Type::Iter_tT::iterator Iter_tDefinition TCollectionProxyInfo.h:297; ROOT::Detail::TCollectionProxyInfo::Type::Cont_tT Cont_tDefinition TCollectionProxyInfo.h:296; ROOT::Detail::TCollectionProxyInfo::Type::PValue_tValue_t * PValue_tDefinition TCollectionProx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:52609,access,accesses,52609,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['access'],['accesses']
Security,"inition at line 104 of file MethodCompositeBase.h. ◆ GetCurrentMethod() [2/2]. MethodBase * TMVA::MethodCompositeBase::GetCurrentMethod ; (; UInt_t ; idx). inlineprotected . Definition at line 105 of file MethodCompositeBase.h. ◆ GetCurrentMethodIndex(). UInt_t TMVA::MethodCompositeBase::GetCurrentMethodIndex ; (; ). inlineprotected . Definition at line 98 of file MethodCompositeBase.h. ◆ GetLastMethod(). IMethod * TMVA::MethodCompositeBase::GetLastMethod ; (; ). inlineprotected . Definition at line 100 of file MethodCompositeBase.h. ◆ GetMethod() [1/2]. TMVA::IMethod * TMVA::MethodCompositeBase::GetMethod ; (; const Int_t ; index); const. protected . accessor by index in vector ; returns pointer to MVA that corresponds to given method index ; Definition at line 104 of file MethodCompositeBase.cxx. ◆ GetMethod() [2/2]. TMVA::IMethod * TMVA::MethodCompositeBase::GetMethod ; (; const TString & ; title); const. protected . accessor by name ; returns pointer to MVA that corresponds to given method title ; Definition at line 89 of file MethodCompositeBase.cxx. ◆ GetMvaValue() [1/3]. Double_t TMVA::MethodBase::GetMvaValue ; (; const TMVA::Event *const ; ev, . Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr . ). Definition at line 201 of file MethodBase.cxx. ◆ GetMvaValue() [2/3]. Double_t TMVA::MethodCompositeBase::GetMvaValue ; (; Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . return composite MVA response ; Implements TMVA::MethodBase.; Definition at line 271 of file MethodCompositeBase.cxx. ◆ GetMvaValue() [3/3]. virtual Double_t TMVA::MethodBase::GetMvaValue ; (; Double_t * ; errLower = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . Implements TMVA::MethodBase. ◆ GetPreviousMethod(). IMethod * TMVA::MethodCompositeBase::GetPreviousMethod ; (; ). inlineprotected . Definition at line 102 of file MethodCompositeBase.h. ◆ IsA(). virtual TClass * TMVA::MethodCompositeBase::IsA ; (; ); const. inlinevirtual . ReturnsTCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCompositeBase.html:31609,access,accessor,31609,doc/master/classTMVA_1_1MethodCompositeBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCompositeBase.html,1,['access'],['accessor']
Security,"initions for the following constants:. Pi.; Base of natural logarithm.; Velocity of light.; Gravitational constant (G).; Standard acceleration of gravity (g).; Standard acceleration of Gravity.; Plank’s contant.; Boltzmann’s and Steffan-Boltzmann’s constants.; Avogadro’s number.; Universal gas constant.; Molecular weight of dry air.; Dry air gas constant.; Euler-Mascheroni Constant.; Elementary charge. 13.3.2 Elementary Functions; A set of miscellaneous elementary mathematical functions is provided along with a set of basic trigonometrical functions. Some of this functions refer to basic mathematical functions like the square root, the power to a number of the calculus of a logarithm, while others are used for number treatment, like rounding.; Although there are some functions that are not in the standard C math library (like Factorial), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions ASin(x), ACos(x) or ATan(x).; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i;; i = TMath::LocMin(10, &v[0]);; std::cout << v[i] << std::endl;; Another example of these functions can be found in $ROOTSYS/tutorials/permute.C.; 13.3.3 Statistic Functions Operating on Arrays.; This set of functions processes arrays to calculate:. Mean.; Median.; Geometrical mean.; Sample Standard Deviation (RMS).; The kth smallest element. These functions, as the array algorithms, have two different interfaces. An old-style one where the size of the array is passed as a first argument followed by a pointer to the array itself and a modern C++-like interface that receives two iterators to it.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:662562,secur,security,662562,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['secur'],['security']
Security,"ink ; (; const char * ; from, . const char * ; to . ). overridevirtual . Create a symlink from file1 to file2. ; Returns 0 when successful, -1 in case of failure. ; Reimplemented from TSystem.; Definition at line 2826 of file TWinNTSystem.cxx. ◆ TempDirectory(). const char * TWinNTSystem::TempDirectory ; (; ); const. overridevirtual . Return a user configured or systemwide directory to create temporary files in. ; Reimplemented from TSystem.; Definition at line 2257 of file TWinNTSystem.cxx. ◆ TempFileName(). FILE * TWinNTSystem::TempFileName ; (; TString & ; base, . const char * ; dir = nullptr, . const char * ; suffix = nullptr . ). overridevirtual . Create a secure temporary file by appending a unique 6 letter string to base. ; The file will be created in a standard (system) directory or in the directory provided in dir. Optionally one can provide suffix append to the final name - like extension "".txt"" or "".html"". The full filename is returned in base and a filepointer is returned for safely writing to the file (this avoids certain security problems). Returns 0 in case of error. ; Reimplemented from TSystem.; Definition at line 2281 of file TWinNTSystem.cxx. ◆ ThreadStub(). static void TWinNTSystem::ThreadStub ; (; void * ; Parameter). inlinestaticprivate . Definition at line 88 of file TWinNTSystem.h. ◆ TimerThread(). void TWinNTSystem::TimerThread ; (; ). private . Special Thread to check asynchronous timers. ; Definition at line 4442 of file TWinNTSystem.cxx. ◆ Umask(). int TWinNTSystem::Umask ; (; Int_t ; mask). overridevirtual . Set the process file creation mode mask. ; Reimplemented from TSystem.; Definition at line 3081 of file TWinNTSystem.cxx. ◆ UnixPathName(). const char * TWinNTSystem::UnixPathName ; (; const char * ; name). overridevirtual . Convert a pathname to a unix pathname. ; E.g. from \user\root to /user/root. General rules for applications creating names for directories and files or processing names supplied by the user include the following:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:73520,secur,security,73520,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['secur'],['security']
Security,"inning of the list. ;  ; void AddFirst (TObject *obj, Option_t *opt) override;  Add object at the beginning of the list and also store option. ;  ; void AddLast (TObject *obj) override;  Add object at the end of the list. ;  ; void AddLast (TObject *obj, Option_t *opt) override;  Add object at the end of the list and also store option. ;  ; void Clear (Option_t *option="""") override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Delete all TDataMember object files. ;  ; TDictionary * Find (DeclId_t id) const;  Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const char *name) const override;  Specialize FindObject to do search for the a data member just by name or create it if its not already in the list. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; TDictionary * Get (DataMemberInfo_t *info, bool skipChecks=kFALSE);  Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ;  ; TDictionary * Get (DeclId_t id);  Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ;  ; TClass * GetClass () const;  ; TClass * IsA () const override;  ; Bool_t IsLoaded () const;  ; void Load ();  Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection. ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void SetClass (TClass *cl);  ; void Stream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:3402,hash,hash,3402,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['hash'],['hash']
Security,"inning!; RooLinTransBinning_binning; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooLinearVar.html:38225,access,access,38225,root/html534/RooLinearVar.html,https://root.cern,https://root.cern/root/html534/RooLinearVar.html,1,['access'],['access']
Security,"ins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Bool_t_showProgressShow progress indication during evaluation if true; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Double_t_sumWeightGlobal sum of weights needed for normalization; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose mes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataWeightedAverage.html:42251,access,access,42251,root/html602/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html602/RooDataWeightedAverage.html,2,['access'],['access']
Security,"insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTestChecksum(UInt_t checksum) const; Bool_tTestVersion(Int_t version) const; ROOT::TSchemaRuleTSchemaRule(); ROOT::TSchemaRuleTSchemaRule(const ROOT::TSchemaRule& rhs); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Bool_tProcessChecksum(const TString& checksum) const; static voidProcessDeclaration(TObjArray* array, const TString& list); static voidProcessList(TObjArray* array, const TString& list); Bool_tProcessVersion(const TString& version) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static ROOT::TSchemaRule::RuleType_tkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static ROOT::TSchemaRule::RuleType_tkReadRawRule; static ROOT::TSchemaRule::RuleType_tkReadRule; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TSchemaRule.html:6520,checksum,checksum,6520,root/html602/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html602/ROOT__TSchemaRule.html,2,['checksum'],['checksum']
Security,"instead of hardcoded color numbers, e.g.:. myObject.SetFillColor(kRed);; myObject.SetFillColor(kYellow-10);; myLine.SetLineColor(kMagenta+2);. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; return w->GetCanvas();; }; Bright and dark colors; The dark and bright color are used to give 3-D effects when drawing various; boxes (see TWbox, TPave, TPaveText, TPaveLabel, etc). The Dark colors have an index = color_index+100; The Bright colors have an index = color_index+150; Two static functions return the bright and dark color number; corresponding to a color index. If the bright or dark color does not; exist, they are created:; ; Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; . Gray scale view of of canvas with colors; One can toggle between a grayscale preview and the regular colored mode using; TCanvas::SetGrayscale(). Note that in grayscale mode, access via RGB; will return grayscale values according to ITU standards (and close to b&w; printer grayscales), while access via HLS returns de-saturated grayscales. The; image below shows the ROOT color wheel in grayscale mode. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; w->GetCanvas()->SetGrayscale();; w->GetCanvas()->Modified();; w->GetCanvas()->Update();; return w->GetCanvas();; }; Color palettes; It is often very useful to represent a variable with a color map. The concept; of ""color palette"" allows to do that. One color palette is active at any time.; This ""current palette"" is set using:. gStyle->SetPalette(...);. This function has two parameters: the number of colors in the palette and an; array of containing the indices of colors in the pallette. The following small; example demonstrates how to define and use the color palette:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; Int_t palette[5];; palette[0] = 15;; palette[1] = 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TColor.html:3270,access,access,3270,root/html528/TColor.html,https://root.cern,https://root.cern/root/html528/TColor.html,4,['access'],['access']
Security,"int nElements, TBuffer& b); voidWriteMap(UInt_t nElements, TBuffer& b). private:. TEmulatedMapProxy&operator=(const TEmulatedMapProxy& rhs). Data Members; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tTGenCollectionProxy::fCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tTGenCollectionProxy::fConstructContainer accessors: block construct; map<string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tTGenCollectionProxy::fDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*TGenCollectionProxy::fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tTGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::fFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::fFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::fFunctionDeleteI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEmulatedMapProxy.html:5379,access,accessors,5379,root/html602/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html602/TEmulatedMapProxy.html,4,['access'],['accessors']
Security,"int thecol) constreturn a full Matrix column as a vector (copy the content in a new vector)Definition SMatrix.icc:590; ROOT::Math::SMatrix::SMatrixSMatrix()Default constructor:Definition SMatrix.icc:72; ROOT::Math::SMatrix::operator-=SMatrix< T, D1, D2, R > & operator-=(const T &rhs)subtraction with a scalarDefinition SMatrix.icc:228; ROOT::Math::SMatrix::applyT apply(unsigned int i) constaccess the parse tree with the index starting from zero and following the C convention for the order ...Definition SMatrix.icc:627; ROOT::Math::SMatrix::Det2bool Det2(T &det) constdeterminant of square Matrix via Dfact.Definition SMatrix.icc:473; ROOT::Math::SMatrix::UpperBlockSVector< T, D1 *(D2+1)/2 > UpperBlock() constreturn the upper Triangular block of the matrices (including the diagonal) as a vector of sizes N = D...Definition SMatrix.icc:797; ROOT::Math::SMatrix::enditerator end()STL iterator interface.Definition SMatrix.icc:675; ROOT::Math::SMatrix::Atconst T & At(unsigned int i, unsigned int j) constread only access to matrix element, with indices starting from 0.Definition SMatrix.icc:653; ROOT::Math::SMatrix::Detbool Det(T &det)determinant of square Matrix via Dfact.Definition SMatrix.icc:466; ROOT::Math::SMatrix::SubColSubVector SubCol(unsigned int thecol, unsigned int row0=0) constreturn a slice of the column as a vector starting at the row value row0 until row0+Dsub.Definition SMatrix.icc:728; ROOT::Math::SMatrix::operator>bool operator>(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:347; ROOT::Math::SMatrix::Printstd::ostream & Print(std::ostream &os) constPrint: used by operator<<()Definition SMatrix.icc:603; ROOT::Math::SMatrix::operator=SMatrix< T, D1, D2, R > & operator=(const M &rhs)Assign from another compatible matrix.Definition SMatrix.icc:155; ROOT::Math::SMatrix::Place_atSMatrix< T, D1, D2, R > & Place_at(const SMatrix< T, D3, D4, R2 > &rhs, unsigned int row, unsigned int col)place a matrix in this matrixDefinition SMatrix.icc:552; ROOT::M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SMatrix_8h_source.html:26662,access,access,26662,doc/master/SMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html,1,['access'],['access']
Security,"intable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooRealProxy_argFunction to calculate in parallel process; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealMPFE.html:31962,validat,validate,31962,root/html532/RooRealMPFE.html,https://root.cern,https://root.cern/root/html532/RooRealMPFE.html,2,"['access', 'validat']","['access', 'validate']"
Security,"intable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Int_tRooAbsString::_lenLength of _value; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStringVar.html:19768,access,access,19768,root/html534/RooStringVar.html,https://root.cern,https://root.cern/root/html534/RooStringVar.html,1,['access'],['access']
Security,"inter (gGeoManager) in order to be fully accessible from external code. The mechanism of handling multiple geometries at the same time will be soon implemented.; TGeoManager is the owner of all geometry objects defined in a session, therefore users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The caching mechanism is triggered by the total number of physical instances of volumes and the cache manager is a client of TGeoManager. The manager class also controls the painter client. This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Rules for building a valid geometry; A given geometry can be built in various ways, but there are mandatory steps that have to be followed in order to be validated by the modeler. There are general rules : volumes needs media and shapes in order to be created, both container and containee volumes must be created before linking them together, and the relative transformation matrix must be provided. All branches must have an upper link point otherwise they will not be considered as part of the geometry. Visibility or tracking properties of volumes can be provided both at build time or after geometry is closed, but global visualization settings (see TGeoPainter class) should not be provided at build time, otherwise the drawing package will be loaded. There is also a list of specific rules : positioned daughters should not extrude their mother or intersect with sisters unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume (containing all geometry tree) must be specified before closing the geometry and must not be positioned - it represents the global refe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:14158,validat,validated,14158,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['validat'],['validated']
Security,"inter to default binning definition; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooErrorVar.html:38123,access,access,38123,root/html534/RooErrorVar.html,https://root.cern,https://root.cern/root/html534/RooErrorVar.html,1,['access'],['access']
Security,"internal condition variable ; Definition at line 287 of file TReentrantRWLock.hxx. ◆ fMutex. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . MutexT ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::fMutex. private . ! RWlock internal mutex ; Definition at line 286 of file TReentrantRWLock.hxx. ◆ fReaderReservation. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . std::atomic<int> ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::fReaderReservation. private . ! A reader wants access ; Definition at line 283 of file TReentrantRWLock.hxx. ◆ fReaders. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . std::atomic<int> ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::fReaders. private . ! Number of readers ; Definition at line 282 of file TReentrantRWLock.hxx. ◆ fRecurseCounts. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . RecurseCountsT ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::fRecurseCounts. private . ! Trackers for re-entry in the lock by the same thread. ; Definition at line 289 of file TReentrantRWLock.hxx. ◆ fWriter. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . std::atomic<bool> ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::fWriter. private . ! Is there a writer? ; Definition at line 285 of file TReentrantRWLock.hxx. ◆ fWriterReservation. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . std::atomic<int> ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::fWriterReservation. private . ! A writer wants access ; Definition at line 284 of file TReentrantRWLock.hxx. core/thread/src/TReentrantRWLock.hxx; core/thread/src/TReentrantRWLock.cxx. ROOTTReentrantRWLock. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:37 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TReentrantRWLock.html:7112,access,access,7112,doc/v632/classROOT_1_1TReentrantRWLock.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TReentrantRWLock.html,1,['access'],['access']
Security,"ion ();  ; TF1 * GetDrawnUpperFunction ();  ; TF1 * GetDrawnLowerFunction ();  ; TGraphErrors * GetDrawnGraph ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDE.html:6879,hash,hash,6879,doc/master/classTKDE.html,https://root.cern,https://root.cern/doc/master/classTKDE.html,1,['hash'],['hash']
Security,"ion ; (; ); const. inline . Definition at line 270 of file MethodDL.h. ◆ GetMulticlassValues(). virtual const std::vector< Float_t > & TMVA::MethodDL::GetMulticlassValues ; (; ). virtual . Reimplemented from TMVA::MethodBase. ◆ GetMvaValue(). Double_t TMVA::MethodDL::GetMvaValue ; (; Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . Implements TMVA::MethodBase.; Definition at line 1772 of file MethodDL.cxx. ◆ GetMvaValues(). std::vector< Double_t > TMVA::MethodDL::GetMvaValues ; (; Long64_t ; firstEvt, . Long64_t ; lastEvt, . Bool_t ; logProgress . ). protectedvirtual . Evaluate the DeepNet on a vector of input values stored in the TMVA Event class Here we will evaluate using a default batch size and the same architecture used for Training. ; Reimplemented from TMVA::MethodBase.; Definition at line 2022 of file MethodDL.cxx. ◆ GetNumValidationSamples(). UInt_t TMVA::MethodDL::GetNumValidationSamples ; (; ). private . parce the validation string and return the number of event data used for validation . ◆ GetOutputFunction(). DNN::EOutputFunction TMVA::MethodDL::GetOutputFunction ; (; ); const. inline . Definition at line 269 of file MethodDL.h. ◆ GetRegressionValues(). virtual const std::vector< Float_t > & TMVA::MethodDL::GetRegressionValues ; (; ). virtual . Reimplemented from TMVA::MethodBase. ◆ GetTrainingSettings() [1/2]. std::vector< TTrainingSettings > & TMVA::MethodDL::GetTrainingSettings ; (; ). inline . Definition at line 281 of file MethodDL.h. ◆ GetTrainingSettings() [2/2]. const std::vector< TTrainingSettings > & TMVA::MethodDL::GetTrainingSettings ; (; ); const. inline . Definition at line 280 of file MethodDL.h. ◆ GetTrainingStrategyString(). TString TMVA::MethodDL::GetTrainingStrategyString ; (; ); const. inline . Definition at line 276 of file MethodDL.h. ◆ GetWeightInitialization(). DNN::EInitialization TMVA::MethodDL::GetWeightInitialization ; (; ); const. inline . Definition at line 268 of file MethodDL.h. ◆ GetWeightIni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:42465,validat,validation,42465,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,2,['validat'],['validation']
Security,"ion at line 197 of file TS3HTTPRequest.cxx. ◆ MakeHostHeader(). TString TS3HTTPRequest::MakeHostHeader ; (; ); const. protected . Returns the 'Host' header to include in the HTTP request. ; Definition at line 189 of file TS3HTTPRequest.cxx. ◆ MakeRequestLine(). TString TS3HTTPRequest::MakeRequestLine ; (; TS3HTTPRequest::EHTTPVerb ; httpVerb); const. protected . Returns the first line of a HTTP request for this object. ; Note that since we don't use the virtual host syntax which is supported by Amazon, we must include the bucket name in thr resource. For example, we don't use http://mybucket.s3.amazonaws.com/path/to/my/file but instead http://s3.amazonaws.com/mybucket/path/to/my/file so the HTTP request will be of the form ""GET /mybucket/path/to/my/file HTTP/1.1"" Also note that the path must include the leading '/'. ; Definition at line 178 of file TS3HTTPRequest.cxx. ◆ MakeTokenHeader(). TString TS3HTTPRequest::MakeTokenHeader ; (; ); const. protected . Returns the session security token header for this HTTP request. ; Definition at line 205 of file TS3HTTPRequest.cxx. ◆ SetAccessKey(). TS3HTTPRequest & TS3HTTPRequest::SetAccessKey ; (; const TString & ; accessKey). inline . Definition at line 145 of file TS3HTTPRequest.h. ◆ SetAuthKeys(). TS3HTTPRequest & TS3HTTPRequest::SetAuthKeys ; (; const TString & ; accessKey, . const TString & ; secretKey . ). inline . Definition at line 132 of file TS3HTTPRequest.h. ◆ SetAuthType(). TS3HTTPRequest & TS3HTTPRequest::SetAuthType ; (; TS3HTTPRequest::EAuthType ; authType). inline . Definition at line 139 of file TS3HTTPRequest.h. ◆ SetBucket(). TS3HTTPRequest & TS3HTTPRequest::SetBucket ; (; const TString & ; bucket). inline . Definition at line 120 of file TS3HTTPRequest.h. ◆ SetHost(). TS3HTTPRequest & TS3HTTPRequest::SetHost ; (; const TString & ; host). inline . Definition at line 114 of file TS3HTTPRequest.h. ◆ SetObjectKey(). TS3HTTPRequest & TS3HTTPRequest::SetObjectKey ; (; const TString & ; objectKey). inline . Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3HTTPRequest.html:17743,secur,security,17743,doc/master/classTS3HTTPRequest.html,https://root.cern,https://root.cern/doc/master/classTS3HTTPRequest.html,1,['secur'],['security']
Security,"ion at line 244 of file TString.h. ◆ Hash() [1/2]. UInt_t TString::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). static . Calculates hash index from any char string. ; (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/ . Definition at line 850 of file TString.cxx. ◆ Hash() [2/2]. UInt_t TString::Hash ; (; ECaseCompare ; cmp = kExact); const. Return hash value. ; Definition at line 677 of file TString.cxx. ◆ HashCase(). UInt_t TString::HashCase ; (; ); const. private . Return a case-sensitive hash value (endian independent). ; Definition at line 633 of file TString.cxx. ◆ HashFoldCase(). UInt_t TString::HashFoldCase ; (; ); const. private . Return a case-insensitive hash value (endian independent). ; Definition at line 662 of file TString.cxx. ◆ Index() [1/8]. Ssiz_t TString::Index ; (; const char * ; pat, . Ssiz_t ; i = 0, . ECaseCompare ; cmp = kExact . ); const. inline . Definition at line 651 of file TString.h. ◆ Index() [2/8]. Ssiz_t TString::Index ; (; const char * ; pattern, . Ssiz_t ; plen, . Ssiz_t ; startIndex, . ECaseCompare ; cmp . ); const. Search for a string in the TString. ; Plen is the length of pattern, startIndex is the index from which to start and cmp selects the type of case-comparison. ; Definition at line 901 of file TString.cxx. ◆ Index() [3/8]. Ssiz_t TString::Index ; (; const TRegexp & ; r, . Ssiz_t * ; extent, . Ssiz_t ; start = 0 . ); const. Find the first occurrence of the regexp in string and return the position, or -1 if there is no match. ; Extent is length of the matched string and start is the offset at which the matching should start. Please, see the Warning in the class documentation above. ; Definition at line 26",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTString.html:34479,hash,hash,34479,doc/v632/classTString.html,https://root.cern,https://root.cern/doc/v632/classTString.html,2,['hash'],['hash']
Security,"ion at line 694 of file TUrl.cxx. ◆ Compare(). Int_t TUrl::Compare ; (; const TObject * ; obj); const. overridevirtual . Compare two urls as strings. ; Reimplemented from TObject.; Definition at line 550 of file TUrl.cxx. ◆ DeclFileName(). static const char * TUrl::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 98 of file TUrl.h. ◆ FindFile(). void TUrl::FindFile ; (; char * ; u, . Bool_t ; stripDoubleSlash = kTRUE . ). private . Find file and optionally anchor and options. ; Definition at line 288 of file TUrl.cxx. ◆ GetAnchor(). const char * TUrl::GetAnchor ; (; ); const. inline . Definition at line 70 of file TUrl.h. ◆ GetFile(). const char * TUrl::GetFile ; (; ); const. inline . Definition at line 69 of file TUrl.h. ◆ GetFileAndOptions(). const char * TUrl::GetFileAndOptions ; (; ); const. Return the file and its options (the string specified behind the ?). ; Convenience function useful when the option is used to pass authentication/access information for the specified file. ; Definition at line 504 of file TUrl.cxx. ◆ GetHost(). const char * TUrl::GetHost ; (; ); const. inline . Definition at line 67 of file TUrl.h. ◆ GetHostFQDN(). const char * TUrl::GetHostFQDN ; (; ); const. Return fully qualified domain name of url host. ; If host cannot be resolved or not valid return the host name as originally specified. ; Definition at line 472 of file TUrl.cxx. ◆ GetIntValueFromOptions(). Int_t TUrl::GetIntValueFromOptions ; (; const char * ; key); const. Return a value for a given key from the URL options as an Int_t, a missing key returns -1. ; Definition at line 672 of file TUrl.cxx. ◆ GetOptions(). const char * TUrl::GetOptions ; (; ); const. inline . Definition at line 71 of file TUrl.h. ◆ GetPasswd(). const char * TUrl::GetPasswd ; (; ); const. inline . Definition at line 66 of file TUrl.h. ◆ GetPort(). Int_t TUrl::GetPort ; (; ); const. inline . Definition at line 78 of file TUrl.h. ◆ GetProtocol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUrl.html:15858,authenticat,authentication,15858,doc/master/classTUrl.html,https://root.cern,https://root.cern/doc/master/classTUrl.html,2,"['access', 'authenticat']","['access', 'authentication']"
Security,"ion from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:174312,access,access,174312,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['access']
Security,"ion from the currently loaded class library.; 4658/// - -1: Assume no class library loaded (emulated class).; 4659///; 4660/// Warning: If we create a new streamer info, whether or not the build; 4661/// optimizes is controlled externally to us by a global variable!; 4662/// Don't call us unless you have set that variable properly; 4663/// with TStreamer::Optimize()!; 4664///; 4665 ; 4666TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4667{; 4668 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4669 ; 4670 // Version 0 is special, it means the currently loaded version.; 4671 // We need to set it at the beginning to be able to guess it correctly.; 4672 ; 4673 if (version == 0); 4674 version = fClassVersion;; 4675 ; 4676 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4677 // guaranteed it was built and compiled.; 4678 if (sinfo && sinfo->GetClassVersion() == version); 4679 return sinfo;; 4680 ; 4681 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4682 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4683 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4684 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4685 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4686 // to indicates they are not yet properly protection against mutli-thread access.; 4687 //; 4688 // However, the use of these functions is rare and mostly done at library loading time which should; 4689 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4690 // on that same TClass object.; 4691 //; 4692 // Summary: need careful review but risk of problem is extremely low.; 4693 ; 4694 R__LOCKGUARD(gInterp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:177063,access,access,177063,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['access']
Security,"ion object has been created.Definition TSystem.cxx:311; TSystem::GetBuildNodevirtual const char * GetBuildNode() constReturn the build node name.Definition TSystem.cxx:3907; TSystem::Umaskvirtual int Umask(Int_t mask)Set the process file creation mode mask.Definition TSystem.cxx:1517; TSystem::SendBufvirtual int SendBuf(int sock, const void *buffer, int length)Send a buffer headed by a length indicator.Definition TSystem.cxx:2427; TSystem::GetServiceByNamevirtual int GetServiceByName(const char *service)Get port # of internet service.Definition TSystem.cxx:2318; TSystem::IsFileInIncludePathvirtual Bool_t IsFileInIncludePath(const char *name, char **fullpath=nullptr)Return true if 'name' is a file that can be found in the ROOT include path or the current directory.Definition TSystem.cxx:966; TSystem::Unloadvirtual void Unload(const char *module)Unload a shared library.Definition TSystem.cxx:2052; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the command line use to make a shared library.Definition TSystem.cxx:3956; TSystem::AnnounceUdpServicevirtual int AnnounceUdpService(int port, int backlog)Announce UDP service.Definition TSystem.cxx:2354; TSystem::fInControlBool_t fInControlDefinition TSystem.h:290; TSystem::fFileHandlerTSeqCollection * fFileHandlerDefinition TSystem.h:296; TSystem::fAclicPropertiesInt_t fAclicPropertiesDefinition TSystem.h:319; TSystem::fMaxrfdInt_t fMaxrfdDefinition TSystem.h:281; TSystem::AddFileHandlervirtual void AddFileHandler(TFileHandler *fh)Add a file handler to the list of system file handlers.Definition TSystem.cxx:554; TSystem::GetLastErrorStringTString & GetLastErrorString()Return the thread local storage for the custom last error message.Definition TSystem.cxx:2102; TSystem::AddLinkedL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:169184,secur,secure,169184,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,['secur'],['secure']
Security,"ion on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing cod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:10767,authenticat,authentication,10767,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['authenticat'],['authentication']
Security,"ion presents all currently supported widgets in ROOT and their most useful methods. All of them can be considered as building blocks for an application, and most of them can be found in dialogs. Provided snippets of the code will give you practical guidelines where and how to use certain widgets. The macro $ROOTSYS/tutorials/gui/guitest.C contains the complete source code. Widgets created by ROOT GUI classes. Any custom widget can be created by sub classing existing widgets. To achieve a better understanding of the widgets’ properties they are separated by their type and their inheritance. As all of them inherit from TGObject and most from TGWidget, these base classes are described first.; 25.5.1 TGObject; TGObject is the base class for all ROOT GUI classes. It inherits from TObject. The two data members of this class contain important information about X11/Win32 window identifier and the connection to the host’s graphics system. Every GUI element, which derives from TGObject has access to the TGClient via the data member fClient of TGObject. TGClient creates the connection with the host’s graphics system and sets up the complete graphics system for all widgets.; 25.5.2 TGWidget; The widgets base class TGWidget is typically used as a mix-in class via multiple inheritances. Its properties are available for all deriving widgets: TGButton, TGComboBox, TGTab, TGColorPalette, TGColorPick, TGDoubleSlider, TGListTree, TGNumberEntry, TGScrollBar, TGShutterItem, TGTextEntry, TGSlider, TGListBox, TGView.; This class has four data members keeping information about the widget id - important for event processing, the window which handles the widget’s events, the widget status flags and the assigned command (if there is any). The general properties of TGWidget are specified by SetFlags(Int_t flags) and ClearFlags(Int_t flags) methods. The status flags are: kWidgetWantFocus, kWidgetHasFocus, and kWidgetIsEnabled. The method Associate(const TGWindow* w) - sets the window which handl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1147415,access,access,1147415,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ion to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:21291,authenticat,authentication,21291,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,5,['authenticat'],['authentication']
Security,"ion(const FCNGradientBase& fcn, const MnUserParameterState& state, const MnStrategy& stra, unsigned int nfcn = 0); constructor from gradient function. virtual ~MnApplication(); { }. FunctionMinimum operator()(unsigned int maxfcn = 0, double tolerance = 0.10000000000000001). Minimize the function; @param maxfcn : max number of function calls (if = 0) default is used which is set to; 200 + 100 * npar + 5 * npar**2; @param tolerance : value used for terminating iteration procedure.; For example, MIGRAD will stop iterating when edm (expected distance from minimum) will be:; edm < tolerance * 10**-3; Default value of tolerance used is 0.1. const FCNBase& Fcnbase() const; {return fFCN;}. unsigned int NumOfCalls() const; {return fNumCall;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation; via MnUserParameterState; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const char* Name, double val, double err); add free Parameter. void Add(const char* Name, double val, double err, double , double ); add limited Parameter. void Add(const char* , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const char* ); interaction via Name of Parameter. void Release(const char* ). void SetValue(const char* , double ). void SetError(const char* , double ). void SetLimits(const char* , double , double ). void RemoveLimits(const char* ). void SetPrecision(double ). double Value(const char* ) const. double Error(const char* ) const. unsigned int Index(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__MnApplication.html:4396,access,access,4396,root/html602/ROOT__Minuit2__MnApplication.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__MnApplication.html,2,['access'],['access']
Security,"ion); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Bool_t_showProgressShow progress indication during evaluation if true; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_sumWeightGlobal sum of weights needed for normalization; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataWeightedAverage.html:36349,access,access,36349,root/html532/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html532/RooDataWeightedAverage.html,1,['access'],['access']
Security,"ion*GetCollection() const; virtual Option_t*TIterator::GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator& aIter) const; Bool_toperator!=(const THashTableIter& aIter) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); THashTableIter&operator=(const THashTableIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTableIter.html:1602,hash,hashtable,1602,root/html534/THashTableIter.html,https://root.cern,https://root.cern/root/html534/THashTableIter.html,1,['hash'],['hashtable']
Security,"ion, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TCondor::EStatekActive; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TCondor::EStatekFree; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TCondor::EStatekSuspended; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetStat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCondor.html:6329,access,accessed,6329,root/html602/TCondor.html,https://root.cern,https://root.cern/root/html602/TCondor.html,2,['access'],['accessed']
Security,"ion, it inputs C++ code of formula into cling, and sets flag that formula is ready to evaluate. . Definition at line 2077 of file TFormula.cxx. ◆ ReInitializeEvalMethod(). void TFormula::ReInitializeEvalMethod ; (; ). private . Re-initialize eval method. ; This function is called by DoEval and DoEvalVector in case of a previous failure or in case of reading from a file ; Definition at line 3467 of file TFormula.cxx. ◆ ReplaceAllNames(). void TFormula::ReplaceAllNames ; (; TString & ; formula, . std::map< TString, TString > & ; substitutions . ). private . Definition at line 405 of file TFormula.cxx. ◆ ReplaceParamName(). void TFormula::ReplaceParamName ; (; TString & ; formula, . const TString & ; oldname, . const TString & ; name . ). protected . Replace in Formula expression the parameter name. ; Definition at line 3020 of file TFormula.cxx. ◆ SetName(). void TFormula::SetName ; (; const char * ; name). overridevirtual . Set the name of the formula. ; We need to allow the list of function to properly handle the hashes. ; Reimplemented from TNamed.; Definition at line 2640 of file TFormula.cxx. ◆ SetParameter() [1/2]. void TFormula::SetParameter ; (; const char * ; name, . Double_t ; value . ). Sets parameter value. ; Definition at line 2893 of file TFormula.cxx. ◆ SetParameter() [2/2]. void TFormula::SetParameter ; (; Int_t ; param, . Double_t ; value . ). Set a parameter given a parameter index. ; The parameter index is by default the alphabetic order given to the parameters, apart if the users has defined explicitly the parameter names. ; Definition at line 2980 of file TFormula.cxx. ◆ SetParameters() [1/2]. void TFormula::SetParameters ; (; const Double_t * ; params). Set a vector of parameters value. ; Order in the vector is by default the alphabetic order given to the parameters apart if the users has defined explicitly the parameter names ; Definition at line 2970 of file TFormula.cxx. ◆ SetParameters() [2/2]. template<typename... Args> . void TFormula::SetPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormula.html:48136,hash,hashes,48136,doc/master/classTFormula.html,https://root.cern,https://root.cern/doc/master/classTFormula.html,1,['hash'],['hashes']
Security,"ion-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunctionTemplate* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfFunctionTemplates(const TListOfFunctionTemplates& ). TListOfFunctionTemplates& operator=(const TListOfFunctionTemplates& ). » Author: Philippe Canal Aug 2013 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last gen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctionTemplates.html:14540,hash,hash,14540,root/html602/TListOfFunctionTemplates.html,https://root.cern,https://root.cern/root/html602/TListOfFunctionTemplates.html,2,['hash'],['hash']
Security,ion: next. ; Definition at line 305 of file TGenCollectionProxy.h. ◆ fOnFileClass. TClass* TGenCollectionProxy::fOnFileClass. protected . On file class. ; Definition at line 322 of file TGenCollectionProxy.h. ◆ fPointers. Bool_t TGenCollectionProxy::fPointers. protected . Flag to indicate if containee has pointers (key or value) ; Definition at line 300 of file TGenCollectionProxy.h. ◆ fProxyKept. Proxies_t TGenCollectionProxy::fProxyKept. protected . Optimization: Keep proxies once they were created. ; Definition at line 318 of file TGenCollectionProxy.h. ◆ fProxyList. Proxies_t TGenCollectionProxy::fProxyList. protected . Stack of recursive proxies. ; Definition at line 317 of file TGenCollectionProxy.h. ◆ fReadMemberWise. TObjArray* TGenCollectionProxy::fReadMemberWise. mutableprotected . Array of bundle of TStreamerInfoActions to stream out (read) ; Definition at line 291 of file TGenCollectionProxy.h. ◆ fResize. Sizing_t TGenCollectionProxy::fResize. protected . Container accessors: resize container. ; Definition at line 303 of file TGenCollectionProxy.h. ◆ fSize. Method TGenCollectionProxy::fSize. protected . Container accessors: size of container. ; Definition at line 302 of file TGenCollectionProxy.h. ◆ fStaged. Staged_t TGenCollectionProxy::fStaged. protected . Optimization: Keep staged array once they were created. ; Definition at line 319 of file TGenCollectionProxy.h. ◆ fSTL_type. int TGenCollectionProxy::fSTL_type. protected . STL container type. ; Definition at line 320 of file TGenCollectionProxy.h. ◆ fTypeinfo. Info_t TGenCollectionProxy::fTypeinfo. protected . Type information. ; Definition at line 321 of file TGenCollectionProxy.h. ◆ fVal. Value* TGenCollectionProxy::fVal. protected . Descriptor of the Value_type. ; Definition at line 312 of file TGenCollectionProxy.h. ◆ fValDiff. int TGenCollectionProxy::fValDiff. protected . Offset between two consecutive value_types (memory layout). ; Definition at line 316 of file TGenCollectionProxy.h. ◆ fValOf,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:30782,access,accessors,30782,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['access'],['accessors']
Security,"ion; 21# purposes, but it could also be a C++ class defined in some library or header.; 22# For more information about loading C++ user code to be used from Python with; 23# PyROOT, please see:; 24# https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; 25ROOT.gInterpreter.Declare('''; 26class MyClass {};; 27'''); 28 ; 29# Next, we define a pythonizor function: the function that will be responsible; 30# for injecting new behaviour in our C++ class `MyClass`.; 31#; 32# To convert a given Python function into a pythonizor, we need to decorate it; 33# with the @pythonization decorator. Such decorator allows us to define which; 34# which class we want to pythonize by providing its class name and its; 35# namespace (if the latter is not specified, it defaults to the global; 36# namespace, i.e. '::').; 37#; 38# The decorated function - the pythonizor - must accept either one or two; 39# parameters:; 40# 1. The class to be pythonized (proxy object where new behaviour can be; 41# injected); 42# 2. The fully-qualified name of that class (optional).; 43#; 44# Let's see all this with a simple example. Suppose I would like to define how; 45# `MyClass` objects are represented as a string in Python (i.e. what would be; 46# shown when I print that object). For that purpose, I can define the following; 47# pythonizor function. There are two important things to be noted here:; 48# - The @pythonization decorator has one argument that specifies our target; 49# class is `MyClass`.; 50# - The pythonizor function `pythonizor_of_myclass` provides and injects a new; 51# implementation for `__str__`, the mechanism that Python provides to define; 52# how to represent objects as strings. This new implementation; 53# always returns the string ""This is a MyClass object"".; 54@pythonization('MyClass'); 55def pythonizor_of_myclass(klass):; 56 klass.__str__ = lambda o : 'This is a MyClass object'; 57 ; 58# Once we have defined our pythonizor function, let's ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html:1932,inject,injected,1932,doc/master/pyroot002__pythonizationDecorator_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html,1,['inject'],['injected']
Security,"ionProxy.h. ◆ fConversionReadMemberWise. std::map<std::string, TObjArray*>* TGenCollectionProxy::fConversionReadMemberWise. mutableprotected . Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ; Definition at line 292 of file TGenCollectionProxy.h. ◆ fCreateEnv. Method0 TGenCollectionProxy::fCreateEnv. protected . Method to allocate an Environment holder. ; Definition at line 310 of file TGenCollectionProxy.h. ◆ fDestruct. Sizing_t TGenCollectionProxy::fDestruct. protected . Container accessors: block destruct. ; Definition at line 307 of file TGenCollectionProxy.h. ◆ fEnv. EnvironBase_t* TGenCollectionProxy::fEnv. protected . Address of the currently proxied object. ; Definition at line 314 of file TGenCollectionProxy.h. ◆ fFeed. Feedfunc_t TGenCollectionProxy::fFeed. protected . Container accessors: block feed. ; Definition at line 308 of file TGenCollectionProxy.h. ◆ fFirst. Method TGenCollectionProxy::fFirst. protected . Container accessors: generic iteration: first. ; Definition at line 304 of file TGenCollectionProxy.h. ◆ fFunctionCopyIterator. CopyIterator_t TGenCollectionProxy::fFunctionCopyIterator. protected . Definition at line 325 of file TGenCollectionProxy.h. ◆ fFunctionCreateIterators. CreateIterators_t TGenCollectionProxy::fFunctionCreateIterators. protected . Definition at line 324 of file TGenCollectionProxy.h. ◆ fFunctionDeleteIterator. DeleteIterator_t TGenCollectionProxy::fFunctionDeleteIterator. protected . Definition at line 327 of file TGenCollectionProxy.h. ◆ fFunctionDeleteTwoIterators. DeleteTwoIterators_t TGenCollectionProxy::fFunctionDeleteTwoIterators. protected . Definition at line 328 of file TGenCollectionProxy.h. ◆ fFunctionNextIterator. Next_t TGenCollectionProxy::fFunctionNextIterator. protected . Definition at line 326 of file TGenCollectionProxy.h. ◆ fKey. Value* TGenCollectionProxy::fKey. protected . Descriptor of the key_type. ; Definition at line 313 of file TGenCollectionProxy.h. ◆ fName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:28543,access,accessors,28543,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['access'],['accessors']
Security,"ionSequence * fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:106; TStreamerInfo::fReadObjectWiseTStreamerInfoActions::TActionSequence * fReadObjectWise! List of read action resulting from the compilation.Definition TStreamerInfo.h:104; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStreamerElementReal(Int_t i, Int_t j) constObsolete: this routine is obsolete and should not longer be used.Definition TStreamerInfo.cxx:4316; TStreamerInfo::IsATClass * IsA() const overrideDefinition TStreamerInfo.h:254; TStreamerInfo::fClassTClass * fClass!pointer to classDefinition TStreamerInfo.h:99; TStreamerInfo::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TStreamerInfo.cxx:3270; TStreamerInfo::~TStreamerInfo~TStreamerInfo() overrideTStreamerInfo dtor.Definition TStreamerInfo.cxx:211; TStreamerInfo::fCompOptTCompInfo ** fCompOpt![fNdata]Definition TStreamerInfo.h:97; TStreamerInfo::TagFilevoid TagFile(TFile *fFile) overrideMark the classindex of the current file as using this TStreamerInfo.Definition TStreamerInfo.cxx:5377; TStreamerInfo::GetNewTypeInt_t GetNewType(Int_t id) constDefinition TStreamerInfo.h:178; TStreamerInfo::SetClassvoid SetClass(TClass *cl) overrideReplace the TClass this streamerInfo is pointing to (belongs to)Definition TStreamerInfo.cxx:5254; TStreamerInfo::fCheckSumUInt_t fCheckSumChecksum of original class.Definition TStreamerInfo.h:88; TStreamerInfo::Streamervoid Streamer(TBuffer &) overrideStream an object of class TStreamerInfo.Definition TStreamerInfo.cxx:5266; TStreamerInfo::GetSizeElementsInt_t GetSize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:283498,checksum,checksum,283498,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,3,['checksum'],['checksum']
Security,"ionSequence*GetWriteMemberWiseActions(Bool_t forCollection); TStreamerInfoActions::TActionSequence*GetWriteObjectWiseActions(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTVirtualStreamerInfo::IsBuilt() const; Bool_tTVirtualStreamerInfo::IsCompiled() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTVirtualStreamerInfo::IsOptimized() const; Int_tTVirtualStreamerInfo::IsRecovered() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; virtual void*New(void* obj = 0); virtual void*NewArray(Long_t nElements, void* ary = 0); virtual TVirtualStreamerInfo*NewInfo(TClass* cl); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); static voidTVirtualStreamerInfo::Optimize(Bool_t opt = kTRUE); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; voidPrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfo.html:6828,checksum,checksum,6828,root/html534/TStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html,1,['checksum'],['checksum']
Security,"ionSequence*GetWriteMemberWiseActions(Bool_t forCollection); TStreamerInfoActions::TActionSequence*GetWriteObjectWiseActions(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTVirtualStreamerInfo::IsBuilt() const; Bool_tTVirtualStreamerInfo::IsCompiled() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTVirtualStreamerInfo::IsOptimized() const; Int_tTVirtualStreamerInfo::IsRecovered() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; virtual void*New(void* obj = 0); virtual void*NewArray(Long_t nElements, void* ary = 0); virtual TVirtualStreamerInfo*NewInfo(TClass* cl); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); static voidTVirtualStreamerInfo::Optimize(Bool_t opt = kTRUE); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; voidPrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_t lenmax = 1000) const; void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStreamerInfo.html:7326,checksum,checksum,7326,root/html602/TStreamerInfo.html,https://root.cern,https://root.cern/root/html602/TStreamerInfo.html,2,['checksum'],['checksum']
Security,"ionTree.cxx. ◆ GetVariableImportance() [2/2]. Double_t TMVA::DecisionTree::GetVariableImportance ; (; UInt_t ; ivar). returns the relative importance of variable ivar ; Definition at line 2766 of file DecisionTree.cxx. ◆ IsA(). virtual TClass * TMVA::DecisionTree::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::BinaryTree.; Definition at line 243 of file DecisionTree.h. ◆ PruneNode(). void TMVA::DecisionTree::PruneNode ; (; TMVA::DecisionTreeNode * ; node). prune away the subtree below the node ; Definition at line 1194 of file DecisionTree.cxx. ◆ PruneNodeInPlace(). void TMVA::DecisionTree::PruneNodeInPlace ; (; TMVA::DecisionTreeNode * ; node). prune a node temporarily (without actually deleting its descendants which allows testing the pruned tree quality for many different pruning stages without ""touching"" the tree. ; Definition at line 1217 of file DecisionTree.cxx. ◆ PruneTree(). Double_t TMVA::DecisionTree::PruneTree ; (; const EventConstList * ; validationSample = nullptr). prune (get rid of internal nodes) the Decision tree to avoid overtraining several different pruning methods can be applied as selected by the variable ""fPruneMethod"". ; Definition at line 964 of file DecisionTree.cxx. ◆ SamplePurity(). Double_t TMVA::DecisionTree::SamplePurity ; (; EventList ; eventSample). private . calculates the purity S/(S+B) of a given event sample ; Definition at line 2722 of file DecisionTree.cxx. ◆ SetAnalysisType(). void TMVA::DecisionTree::SetAnalysisType ; (; Types::EAnalysisType ; t). inline . Definition at line 189 of file DecisionTree.h. ◆ SetMinLinCorrForFisher(). void TMVA::DecisionTree::SetMinLinCorrForFisher ; (; Double_t ; min). inline . Definition at line 192 of file DecisionTree.h. ◆ SetNodePurityLimit(). void TMVA::DecisionTree::SetNodePurityLimit ; (; Double_t ; p). inline . Definition at line 161 of file DecisionTree.h. ◆ SetNVars(). void TMVA::DecisionTree::SetNVars ; (; Int_t ; n). inline . Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:23393,validat,validationSample,23393,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['validat'],['validationSample']
Security,"ionTreeNode*>(p);}. void SetNodeR(Double_t r); the node resubstitution estimate, R(t), for Cost Complexity pruning. { fTrainInfo->fNodeR = r; }. Double_t GetNodeR() const; { return fTrainInfo->fNodeR; }. void SetSubTreeR(Double_t r); the resubstitution estimate, R(T_t), of the tree rooted at this node. { fTrainInfo->fSubTreeR = r; }. Double_t GetSubTreeR() const; { return fTrainInfo->fSubTreeR; }. void SetAlpha(Double_t alpha); R(t) - R(T_t); the critical point alpha = -------------; |~T_t| - 1. { fTrainInfo->fAlpha = alpha; }. Double_t GetAlpha() const; { return fTrainInfo->fAlpha; }. void SetAlphaMinSubtree(Double_t g); the minimum alpha in the tree rooted at this node. { fTrainInfo->fG = g; }. Double_t GetAlphaMinSubtree() const; { return fTrainInfo->fG; }. void SetNTerminal(Int_t n); number of terminal nodes in the subtree rooted here. { fTrainInfo->fNTerminal = n; }. Int_t GetNTerminal() const; { return fTrainInfo->fNTerminal; }. void SetNBValidation(Double_t b); number of background/signal events from the pruning validation sample. { fTrainInfo->fNB = b; }. void SetNSValidation(Double_t s); { fTrainInfo->fNS = s; }. Double_t GetNBValidation() const; { return fTrainInfo->fNB; }. Double_t GetNSValidation() const; { return fTrainInfo->fNS; }. void SetSumTarget(Float_t t); {fTrainInfo->fSumTarget = t; }. void SetSumTarget2(Float_t t2); {fTrainInfo->fSumTarget2 = t2; }. void AddToSumTarget(Float_t t); {fTrainInfo->fSumTarget += t; }. void AddToSumTarget2(Float_t t2); {fTrainInfo->fSumTarget2 += t2; }. Float_t GetSumTarget() const; {return fTrainInfo? fTrainInfo->fSumTarget : -9999;}. Float_t GetSumTarget2() const; {return fTrainInfo? fTrainInfo->fSumTarget2: -9999;}. Bool_t IsTerminal() const; flag indicates whether this node is terminal. { return fIsTerminalNode; }. void SetTerminal(Bool_t s = kTRUE); { fIsTerminalNode = s; }. Double_t GetCC() const; {return (fTrainInfo? fTrainInfo->fCC : -1.);}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Eckha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTreeNode.html:15159,validat,validation,15159,root/html528/TMVA__DecisionTreeNode.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTreeNode.html,6,['validat'],['validation']
Security,"ionUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tTNetSystem::fIsLocalTRUE if the path points to this host; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTNetSystem::fLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSyste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXNetSystem.html:17806,access,access,17806,root/html534/TXNetSystem.html,https://root.cern,https://root.cern/root/html534/TXNetSystem.html,3,['access'],['access']
Security,"ion_t*GetOption() const; TUDPSocket&operator=(const TUDPSocket&). Data Members; public:. enum EStatusBits { kIsUnix; kBrokenConn; };; enum EInterest { kRead; kWrite; };; enum EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressfAddressremote internet address and port #; TBitsfBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tfBytesRecvtotal bytes received over this socket; UInt_tfBytesSenttotal bytes sent using this socket; Int_tfCompressCompression level and algorithm; TTimeStampfLastUsageTime stamp of last usage; TVirtualMutex*fLastUsageMtxProtect last usage setting / reading; TInetAddressfLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolprotocol of remote daemon; TSecContext*fSecContextafter a successful Authenticate call; TUDPSocket::EServiceTypefServTyperemote service type; TStringfServicename of service (matches remote port #); Int_tfSocketsocket descriptor; TStringTNamed::fTitleobject title; TList*fUUIDslist of TProcessIDs already sent through the socket; TStringfUrlneeds this for special authentication options; static ULong64_tfgBytesRecvtotal bytes received by all socket objects; static ULong64_tfgBytesSenttotal bytes sent by all socket objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUDPSocket(TInetAddress address, const char* service); Create a socket. Connect to the named service at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use Is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUDPSocket.html:8899,authenticat,authentication,8899,root/html532/TUDPSocket.html,https://root.cern,https://root.cern/root/html532/TUDPSocket.html,2,['authenticat'],['authentication']
Security,"ion_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; void Init (void);  common initialisation with defaults for the DT-Method ;  . Private Attributes; Bool_t fAutomatic;  use user given prune strength or automatically determined one using a validation sample ;  ; Double_t fDeltaPruneStrength;  step size in pruning, is adjusted according to experience of previous trees ;  ; Double_t fErrorFraction;  ntuple var: misclassification error fraction ;  ; std::vector< Event * > fEventSample;  the training events ;  ; UInt_t fMaxDepth;  max depth ;  ; Int_t fMinNodeEvents;  min number of events in node ;  ; Float_t fMinNodeSize;  min percentage of training events in node ;  ; TString fMinNodeSizeS;  string containing min percentage of training events in node ;  ; Int_t fNCuts;  grid used in cut applied in node splitting ;  ; Double_t fNodePurityLimit;  purity limit for sig/bkg nodes ;  ; Bool_t fPruneBeforeBoost;  ancient variable, only needed for ""CompatibilityOptions"" ;  ; DecisionTree::EPruneMethod fPruneMethod;  method used for pruning ;  ; TString fPruneMethodS;  prune method option String ;  ; Double_t fPruneStrength;  a parameter to set the ""amount"" of pruning..needs to be adjusted ;  ; Bool_t fRandomisedTrees;  choose a random subset of possible cut variables at each node during training ;  ; SeparationBase * fSepType;  the separation used in node splitting ;  ; TString fSepTypeS;  the separation (option string) used in node splitting ;  ; DecisionTree * fTree;  the decision tree ;  ; Int_t fUseNvars;  the number of variables used in the randomised tree splitting ;  ; Bool_t fUsePoissonNvars;  fUseNvars is used as a poisson mea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDT.html:26739,validat,validation,26739,doc/master/classTMVA_1_1MethodDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDT.html,1,['validat'],['validation']
Security,"ions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; int; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Access to TClonesArray.; If a branch (or member) is a TClonesArray (let's say fTracks), you can access the TClonesArray itself by using ->: fTracks->GetLast();; However this will load the full TClonesArray object and its content. To quickly read the size of the TClonesArray use (note the dot): fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been split. To access the content of the TClonesArray, use the [] operator: float px = fTracks[i].fPx; // fPx of the i-th track; Warning:; The variable actually use for access are 'wrapper' around the real data type (to add autoload for example) and hence getting to the data involves the implicit call to a C++ conversion operator. This conversion is automatic in most case. However it is not invoked in a few cases, in particular in variadic function (like printf). So when using printf you should either explicitly cast the value or use any intermediary variable: fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);; Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:34333,access,access,34333,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['access'],['access']
Security,"ions inherited from THashTable;  THashTable (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashTable object. ;  ; virtual ~THashTable ();  Delete a hashtable. ;  ; void Add (TObject *obj) override;  Add object to the hash table. ;  ; void AddAll (const TCollection *col) override;  Add all objects from collection col to this collection. ;  ; void AddBefore (const TObject *before, TObject *obj);  Add object to the hash table. ;  ; Float_t AverageCollisions () const;  ; void Clear (Option_t *option="""") override;  Remove all objects from the table. ;  ; Int_t Collisions (const char *name) const;  Returns the number of collisions for an object with a certain name (i.e. ;  ; Int_t Collisions (TObject *obj) const;  Returns the number of collisions for an object (i.e. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the table AND delete all heap based objects. ;  ; Bool_t Empty () const;  ; const TList * GetListForObject (const char *name) const;  Return the TList corresponding to object's name based hash value. ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the TList corresponding to object's hash value. ;  ; TObject ** GetObjectRef (const TObject *obj) const override;  Return address of pointer to obj. ;  ; Int_t GetRehashLevel () const;  ; Int_t GetSize () const override;  Return the capacity of the collection, i.e. ;  ; TClass * IsA () const override;  ; TIterator * MakeIterator (Bool_t dir=kIterForward) const override;  Returns a hash table iterator. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; void Print (Option_t *option, Int_t recurse) const override;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfTypes.html:2101,hash,hash,2101,doc/master/classTListOfTypes.html,https://root.cern,https://root.cern/doc/master/classTListOfTypes.html,1,['hash'],['hash']
Security,"ions the errors in x willnot be considere.; If errors in x are important, go through minuit (use option ""F"" for polynomial fitting). 5) When fitting a TGraph (i.e. no errors associated with each point),; a correction is applied to the errors on the parameters with the following; formula:; errorp *= sqrt(chisquare/(ndf-1)). Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit which is return by an; automatic conversion of the TFitResultPtr to an integer. One can write in this case; directly:; Int_t fitStatus = h->Fit(myFunc). If the option ""S"" is instead used, TFitResultPtr contains the TFitResult and behaves; as a smart pointer to it. For example one can do:; TFitResultPtr r = h->Fit(myFunc,""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the histogram is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Access to the fit status. The status of the fit can be obtained converting the TFitResultPtr to an integer; indipendently if the fit option ""S"" is used or not:; TFitResultPtr r = h->Fit(myFunc,opt);; Int_t fitStatus = r;. The fitStatus is 0 if the fit is O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph.html:29022,access,access,29022,root/html534/TGraph.html,https://root.cern,https://root.cern/root/html534/TGraph.html,3,['access'],['access']
Security,"ions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TNetFile Class ReferenceInput/Output Library. ; A TNetFile is like a normal TFile except that it reads and writes its data via a rootd server (for more on the rootd daemon see the source files in root/rootd/src/). ; TNetFile file names are in standard URL format with protocol ""root"" or ""roots"". The following are valid TNetFile URL's:; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root of the remote file tree is the user's home directory. Therefore an absolute pathname requires a // after the host or port specifier (see last example). Further the expansion of the standard shell characters, like ~, $, .., are handled as expected. TNetFile (actually TUrl) uses 1094 as default port for rootd.; Connecting to a rootd requires the remote user id and password. TNetFile allows three ways for you to provide your login: Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and TAuthenticate::SetGlobalPasswd(); Getting it from the ~/.netrc file (same file as used by ftp); Command line prompt The different methods will be tried in the order given above. On machines with AFS rootd will authenticate using AFS (if it was compiled with AFS support). If the protocol is specified as ""rootk"" kerberos5 will be used for authentication.; The rootd daemon lives in the directory $ROOTSYS/bin. It can be started either via inetd or by hand from the command line (no need to be super user). ; Definition at line 34 of file TNetFile.h. Public Member Functions;  TNetFile ();  ;  TNetFile (const char *url, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Create a TNetFile object. ;  ; virtual ~TNetFile ();  TNetFile dtor. Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:1181,password,password,1181,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['password'],['password']
Security,"ionsFor ""VariationsFor()"". In between these steps, no other change; 998to the analysis code is required: the presence of systematic variations for certain columns is automatically propagated; 999through filters, defines and actions, and RDataFrame will take these dependencies into account when producing varied; 1000results. \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" is included in header `ROOT/RDFHelpers.hxx`. The compiled C++ programs must include this header; 1001explicitly, this is not required for ROOT macros. ; 1002 ; 1003An example usage of Vary() and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in C++:; 1004 ; 1005~~~{.cpp}; 1006auto nominal_hx =; 1007 df.Vary(""pt"", ""ROOT::RVecD{pt*0.9f, pt*1.1f}"", {""down"", ""up""}); 1008 .Filter(""pt > pt_cut""); 1009 .Define(""x"", someFunc, {""pt""}); 1010 .Histo1D<float>(""x"");; 1011 ; 1012// request the generation of varied results from the nominal_hx; 1013ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1014 ; 1015// the event loop runs here, upon first access to any of the results or varied results:; 1016hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); 1017hx[""pt:down""].Draw(""SAME"");; 1018hx[""pt:up""].Draw(""SAME"");; 1019~~~; 1020 ; 1021A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; 1022as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; 1023this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; 1024to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; 1025""pt:down"", ""pt:up"" in this example). Python usage looks similar.; 1026 ; 1027Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; 1028the resulting histog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:59663,access,access,59663,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,"ion . ). inline . Define a new column that is updated when the input sample changes. ; Parameters. [in]nameThe name of the defined column. ; [in]expressionA C++ callable that computes the new value of the defined column. . Returnsthe first node of the computation graph for which the new quantity is defined.; The signature of the callable passed as second argument should be T(unsigned int slot, const ROOT::RDF::RSampleInfo &id) where:; T is the type of the defined column; slot is a number in the range [0, nThreads) that is different for each processing thread. This can simplify the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; id is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is being processed (see the class docs for more information). DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being processed or to inject a callback into the event loop that is only called when the processing of a new sample starts rather than at every entry.; The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often. Example usage:; ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; df.DefinePerSample(""weightbysample"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; ROOT::RDF::RInterface::DefinePerSampleRInterface< Proxied, DS_t > DefinePerSample(std::string_view name, F expression)Define a new column that is updated when the input sample changes.Definition RInterface.hxx:735; ROOT::RDF::RSampleInfoThis type represents a sample identifier, to be used in conjunction with RDataFrame features such as ...Definition RSampleInfo.hxx:35. Definition at line 735 of file RInterface.hxx. ◆ DefinePerSample() [2/2]. template<typename Proxied , typename DataSource = void> . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:54720,inject,inject,54720,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['inject'],['inject']
Security,"ior-check would start; 336 // saving cpu cycle when each object is inserted in average 1.5 times in a THashList/THashTable.; 337 ; 338 // if ( !fBits & kCheckedHash) {; 339 if (!CheckTObjectHashConsistency()); 340 fBits |= kInconsistent;; 341 // fBits &= kChecked;; 342 //}; 343 return Hash();; 344}; 345 ; 346////////////////////////////////////////////////////////////////////////////////; 347/// @brief Return true is the type of this object is *known* to have an; 348/// inconsistent setup for Hash and RecursiveRemove (i.e. missing call to; 349/// RecursiveRemove in destructor).; 350///; 351/// Note: Since the consistency is only tested for during inserts, this; 352/// routine will return true for object that have never been inserted; 353/// whether or not they have a consistent setup. This has no negative; 354/// side-effect as searching for the object with the right or wrong; 355/// Hash will always yield a not-found answer (Since anyway no hash; 356/// can be guaranteed unique, there is always a check); 357 ; 358inline Bool_t TObject::HasInconsistentHash() const; 359{; 360 return fBits & kInconsistent;; 361}; 362 ; 363// Global bits (can be set for any object and should not be reused).; 364// Only here for backward compatibility reasons.; 365// For detailed description see TObject::EStatusBits above.; 366enum EObjBits {; 367 kCanDelete = TObject::kCanDelete,; 368 kMustCleanup = TObject::kMustCleanup,; 369 kObjInCanvas = TObject::kObjInCanvas,; 370 kIsReferenced = TObject::kIsReferenced,; 371 kHasUUID = TObject::kHasUUID,; 372 kCannotPick = TObject::kCannotPick,; 373 kNoContextMenu = TObject::kNoContextMenu,; 374 kInvalidObject = TObject::kInvalidObject; 375};; 376 ; 377namespace cling {; 378 std::string printValue(TObject *val);; 379}; 380 ; 381namespace ROOT {; 382 ; 383namespace Internal {; 384 bool DeleteChangesMemory();; 385} // Internal; 386 ; 387namespace Detail {; 388 ; 389 ; 390/// @brief Check if the TObject's memory has been deleted.; 391/// @warning This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8h_source.html:15328,hash,hash,15328,doc/master/TObject_8h_source.html,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html,1,['hash'],['hash']
Security,"ious start, so if anyone changed the access rights between; 8439 * two restarts, a new login is required. */; 8440 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8441 /* nonce is from a previous start of the server and no longer valid; 8442 * (replay attack?) */; 8443 return 0;; 8444 }; 8445 /* Check if the nonce is too high, so it has not (yet) been used by the; 8446 * server. */; 8447 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8448 + conn->dom_ctx->nonce_count)) {; 8449 return 0;; 8450 }; 8451#else; 8452 (void)nonce;; 8453#endif; 8454 ; 8455 /* CGI needs it as REMOTE_USER */; 8456 if (ah->user != NULL) {; 8457 conn->request_info.remote_user =; 8458 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8459 } else {; 8460 return 0;; 8461 }; 8462 ; 8463 return 1;; 8464}; 8465 ; 8466 ; 8467static const char *; 8468mg_fgets(char *buf, size_t size, struct mg_file *filep); 8469{; 8470 if (!filep) {; 8471 return NULL;; 8472 }; 8473 ; 8474 if (filep->access.fp != NULL) {; 8475 return fgets(buf, (int)size, filep->access.fp);; 8476 } else {; 8477 return NULL;; 8478 }; 8479}; 8480 ; 8481/* Define the initial recursion depth for procesesing htpasswd files that; 8482 * include other htpasswd; 8483 * (or even the same) files. It is not difficult to provide a file or files; 8484 * s.t. they force civetweb; 8485 * to infinitely recurse and then crash.; 8486 */; 8487#define INITIAL_DEPTH 9; 8488#if INITIAL_DEPTH <= 0; 8489#error Bad INITIAL_DEPTH for recursion, set to at least 1; 8490#endif; 8491 ; 8492#if !defined(NO_FILESYSTEMS); 8493struct read_auth_file_struct {; 8494 struct mg_connection *conn;; 8495 struct ah ah;; 8496 const char *domain;; 8497 char buf[256 + 256 + 40];; 8498 const char *f_user;; 8499 const char *f_domain;; 8500 const char *f_ha1;; 8501};; 8502 ; 8503 ; 8504static int; 8505read_auth_file(struct mg_file *filep,; 8506 struct read_auth_file_struct *workdata,; 8507 int depth); 8508{; 8509 int is_authorized = 0;; 8510 struct mg_file fp;; 8511 size_t l;; 8512 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:244592,access,access,244592,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"ious start, so if anyone changed the access rights between; 8440 * two restarts, a new login is required. */; 8441 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8442 /* nonce is from a previous start of the server and no longer valid; 8443 * (replay attack?) */; 8444 return 0;; 8445 }; 8446 /* Check if the nonce is too high, so it has not (yet) been used by the; 8447 * server. */; 8448 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8449 + conn->dom_ctx->nonce_count)) {; 8450 return 0;; 8451 }; 8452#else; 8453 (void)nonce;; 8454#endif; 8455 ; 8456 /* CGI needs it as REMOTE_USER */; 8457 if (ah->user != NULL) {; 8458 conn->request_info.remote_user =; 8459 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8460 } else {; 8461 return 0;; 8462 }; 8463 ; 8464 return 1;; 8465}; 8466 ; 8467 ; 8468static const char *; 8469mg_fgets(char *buf, size_t size, struct mg_file *filep); 8470{; 8471 if (!filep) {; 8472 return NULL;; 8473 }; 8474 ; 8475 if (filep->access.fp != NULL) {; 8476 return fgets(buf, (int)size, filep->access.fp);; 8477 } else {; 8478 return NULL;; 8479 }; 8480}; 8481 ; 8482/* Define the initial recursion depth for procesesing htpasswd files that; 8483 * include other htpasswd; 8484 * (or even the same) files. It is not difficult to provide a file or files; 8485 * s.t. they force civetweb; 8486 * to infinitely recurse and then crash.; 8487 */; 8488#define INITIAL_DEPTH 9; 8489#if INITIAL_DEPTH <= 0; 8490#error Bad INITIAL_DEPTH for recursion, set to at least 1; 8491#endif; 8492 ; 8493#if !defined(NO_FILESYSTEMS); 8494struct read_auth_file_struct {; 8495 struct mg_connection *conn;; 8496 struct ah ah;; 8497 const char *domain;; 8498 char buf[256 + 256 + 40];; 8499 const char *f_user;; 8500 const char *f_domain;; 8501 const char *f_ha1;; 8502};; 8503 ; 8504 ; 8505static int; 8506read_auth_file(struct mg_file *filep,; 8507 struct read_auth_file_struct *workdata,; 8508 int depth); 8509{; 8510 int is_authorized = 0;; 8511 struct mg_file fp;; 8512 size_t l;; 8513 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:244624,access,access,244624,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"iption; function members; data members; class charts. ROOT; » NET; » NET; » TNetFile. class TNetFile: public TFile. TNetFile. A TNetFile is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:1188,password,password,1188,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,6,['password'],['password']
Security,"ique<TKey>(this);; 1387 std::vector<char> buffer(fNbytesInfo+1);; 1388 auto buf = buffer.data();; 1389 Seek(fSeekInfo); // NOLINT: silence clang-tidy warnings; 1390 if (ReadBuffer(buf,fNbytesInfo)) { // NOLINT: silence clang-tidy warnings; 1391 // ReadBuffer returns kTRUE in case of failure.; 1392 Warning(""GetRecordHeader"",""%s: failed to read the StreamerInfo data from disk."",; 1393 GetName());; 1394 return {nullptr, 1, hash};; 1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////////////////////////////////////////////////////////////////; 1427/// Read the list of TStreamerInfo objects written to this file.; 1428///; 1429/// The function returns a TList. It is the user's responsibility; 1430/// to delete the list created by this function.; 1431///; 1432/// Note the list, in addition to TStreamerInfo object, contains sometimes; 1433/// a TList named 'listOfRules' and containing the schema evolution rules; 1434/// related to the file's content.; 1435///; 1436/// Using",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:50323,hash,hash,50323,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['hash'],['hash']
Security,"ircular(Long64_t maxEntries); 2284{; 2285 Int_t dentries = (Int_t) (fEntries - maxEntries);; 2286 TBasket* basket = (TBasket*) fBaskets.UncheckedAt(0);; 2287 if (basket) basket->MoveEntries(dentries);; 2288 fEntries = maxEntries;; 2289 fEntryNumber = maxEntries;; 2290 //loop on sub branches; 2291 Int_t nb = fBranches.GetEntriesFast();; 2292 for (Int_t i = 0; i < nb; ++i) {; 2293 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 2294 branch->KeepCircular(maxEntries);; 2295 }; 2296}; 2297 ; 2298////////////////////////////////////////////////////////////////////////////////; 2299/// Baskets associated to this branch are forced to be in memory.; 2300/// You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; 2301/// the system that the total size of the imported baskets does not; 2302/// exceed maxmemory bytes.; 2303///; 2304/// The function returns the number of baskets that have been put in memory.; 2305/// This method may be called to force all baskets of one or more branches; 2306/// in memory when random access to entries in this branch is required.; 2307/// See also TTree::LoadBaskets to load all baskets of all branches in memory.; 2308 ; 2309Int_t TBranch::LoadBaskets(); 2310{; 2311 Int_t nimported = 0;; 2312 Int_t nbaskets = fWriteBasket;; 2313 TFile *file = GetFile(0);; 2314 if (!file) return 0;; 2315 TBasket *basket;; 2316 for (Int_t i=0;i<nbaskets;i++) {; 2317 basket = (TBasket*)fBaskets.UncheckedAt(i);; 2318 if (basket) continue;; 2319 basket = GetFreshBasket(i, nullptr);; 2320 if (fBasketBytes[i] == 0) {; 2321 fBasketBytes[i] = basket->ReadBasketBytes(fBasketSeek[i],file);; 2322 }; 2323 Int_t badread = basket->ReadBasketBuffers(fBasketSeek[i],fBasketBytes[i],file);; 2324 if (badread) {; 2325 Error(""Loadbaskets"",""Error while reading basket buffer %d of branch %s"",i,GetName());; 2326 return -1;; 2327 }; 2328 ++fNBaskets;; 2329 fBaskets.AddAt(basket,i);; 2330 nimported++;; 2331 }; 2332 return nimported;; 2333}; 2334 ; 2335//////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:83715,access,access,83715,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['access'],['access']
Security,"irectory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void AssignPoints (Int_t npoints, Double_t *points);  Set fPoints array. ;  ; Bool_t MakeBranch (const char *expr, Bool_t left);  Mutex for thread data access. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TGeoShape * fLeft {nullptr};  ; TGeoMatrix * fLeftMat {nullptr};  ; std::mutex fMutex;  Size for the navigation data array. ;  ; Int_t fNpoints {0};  ; Double_t * fPoints {nullptr};  number of points on the mesh ;  ; TGeoShape * fRight {nullptr};  ; TGeoMatrix * fRightMat {nullptr};  ; std::vector< ThreadData_t * > fThreadData;  array of mesh points ;  ; Int_t fThreadSize {0};  Navigation data per thread. ;  . Private Member Functions;  TGeoBoolNode (const TGeoBoolNode &)=delete;  ; TGeoBoolNode & operator= (const TGeoBoolNode &)=delete;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoBoolNode.h>. Inheritance diagram for TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBoolNode.html:12810,access,access,12810,doc/master/classTGeoBoolNode.html,https://root.cern,https://root.cern/doc/master/classTGeoBoolNode.html,1,['access'],['access']
Security,"ires python >= 2.2. qt. Qt graphics backend, requires libqt >= 4.8. qtgsi; *; GSI's Qt integration, requires libqt >= 4.8. roofit; *; Build the libRooFit advanced fitting package. root7; OFF; ROOT 7 support (read more). roottest; OFF; Include roottest in the test suit, if roottest exists in root or if it is a sibling directory. ruby; OFF; Ruby ROOT bindings, requires ruby >= 1.8. r; OFF; R ROOT bindings, requires R, Rcpp and RInside. rfio; ON; RFIO support, requires libshift from CASTOR >= 1.5.2. rpath; OFF; Set run-time library load path on executables and shared libraries (at installation area). runtime_cxxmodules; OFF; Enable runtime c++ modules. sapdb; ON; MaxDB/SapDB support, requires libsqlod and libsqlrte. shadowpw; ON; Shadow password support. shared; ON; Use shared 3rd party libraries if possible. soversion; OFF; Set version number in sonames (recommended). sqlite; ON; SQLite support, requires libsqlite3. srp; ON; SRP support, requires SRP source tree. ssl; ON; SSL encryption support, requires openssl. tbb; OFF; TBB multi-threading support, requires TBB. table; *; Build libTable contrib library. tcmalloc; OFF; Using the tcmalloc allocator. testing; OFF; Enable test suit of ROOT with CTest. thread; ON; Using thread library (cannot be disabled). tmva; ON; Build TMVA multi variate analysis library. unuran; *; UNURAN - package for generating non-uniform random numbers. vc; *; Vc adds a few new types for portable and intuitive SIMD programming. vdt; ON; VDT adds a set of fast and vectorisable mathematical functions. winrtdebug; OFF; Link against the Windows debug runtime library. xft; ON; Xft support (X11 antialiased fonts). xml; ON; XML parser interface. xrootd; ON; Build xrootd file server and its client (if supported). x11; *; X11 support. The default value for these options are platform dependent. CMake Generators; CMake can generate, in addition to standard makefiles, specific proejcts for various integrated development environments (IDEs) such as Xcode, Ecl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:12382,encrypt,encryption,12382,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['encrypt'],['encryption']
Security,"irtual Bool_t TASImagePlugin::ASImage2File ; (; ASImage * ; ). inlinevirtual . Definition at line 37 of file TASImagePlugin.h. ◆ Class(). static TClass * TASImagePlugin::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TASImagePlugin::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TASImagePlugin::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 39 of file TASImagePlugin.h. ◆ DeclFileName(). static const char * TASImagePlugin::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 39 of file TASImagePlugin.h. ◆ File2ASImage(). virtual ASImage * TASImagePlugin::File2ASImage ; (; const char * ; ). inlinevirtual . Reimplemented in TASPluginGS.; Definition at line 36 of file TASImagePlugin.h. ◆ Hash(). ULong_t TASImagePlugin::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TASImagePlugin::HashULong_t Hash() const overrideReturn hash value for this object.Definition TASImagePlugin.h:32; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImagePlugin.html:12238,hash,hash,12238,doc/master/classTASImagePlugin.html,https://root.cern,https://root.cern/doc/master/classTASImagePlugin.html,1,['hash'],['hash']
Security,"irtual void SetAction(const char *action)Definition TExec.h:37; where actionCommand is a string containing a C++ instruction. Examples: myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be automatically executed. In the function/script being executed, one or more of the following actions can be executed:. load a file containing the referenced object. This function typically looks in the file catalog (GRID).; compute a pointer to the referenced object and communicate this pointer back to the calling function TRef::GetObject via: TRef::SetStaticObject(object).; TRef::SetStaticObjectstatic void SetStaticObject(TObject *obj)Static function to set the object found on the Action on Demand function.Definition TRef.cxx:478; When the TExec is called, it has access to the dereferencing TRef by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this"" before the call to TExec). This can be useful for accessing the TRef's fUniqueID. As soon as an object is returned to GetObject, the fUniqueID of the TRef is set to the fUniqueID of the referenced object. At the next call to GetObject, the pointer stored in fPid:fObjects[fUniqueID] will be returned directly.; An example of action on demand is shown in $ROOTSYS/test/Event.h with the member: TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.GetObject(), the function GetObject will automatically invoke a script GetWebHistogram.C via the interpreter.; An example of a GetWebHistogram.C script is shown below void GetWebHistogram() {; TFile *f= TFile::Open(""http://root.cern/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetStaticObject(h6);; }; f#define f(i)Definition RSha256.hxx:104; gDirectory#define gDirectoryDefinition TDirectory.h:384; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:7510,access,accessing,7510,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,1,['access'],['accessing']
Security,"irtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidRegisterColor(Color_t colorIndex). Data Members; public:. enum ECoordinateMode { kPadMode; kObjectBoundingMode; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; Int_tTColor::fNumberColor number identifier; TStringTNamed::fTitleobject title. private:. vector<Double_t>fColorPositions; vector<Double_t>fColorsRGBA values.; TColorGradient::ECoordinateModefCoordinateMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TColorGradient(). TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); I have no way to validate parameters here, so it's up to user; to pass correct arguments. TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Double_t* colors, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); I have no way to validate parameters here, so it's up to user; to pass correct arguments. void ResetColor(UInt_t nPoints, const Double_t* points, const Color_t* colorIndices). void ResetColor(UInt_t nPoints, const Double_t* points, const Double_t* colorIndices). void SetCoordinateMode(TColorGradient::ECoordinateMode mode). const Double_t * GetColorPositions() const. const Double_t * GetColors() const. void RegisterColor(Color_t colorIndex). TColorGradient(). ECoordinateMode GetCoordinateMode() const. SizeType_t GetNumberOfSteps() const. » Last changed: root/base:$Id$ » Last generated: 2015-03-12 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TColorGradient.html:10137,validat,validate,10137,root/html534/TColorGradient.html,https://root.cern,https://root.cern/root/html534/TColorGradient.html,1,['validat'],['validate']
Security,"irtualStreamerInfo::Optimize ; (; Bool_t ; opt = kTRUE). static . This is a static function. ; Set optimization option. When this option is activated (default), consecutive data members of the same type are merged into an array (faster). Optimization must be off in TTree split mode. ; Definition at line 167 of file TVirtualStreamerInfo.cxx. ◆ ResetIsCompiled(). void TVirtualStreamerInfo::ResetIsCompiled ; (; ). inlineprotected . Definition at line 60 of file TVirtualStreamerInfo.h. ◆ SetCanDelete(). void TVirtualStreamerInfo::SetCanDelete ; (; Bool_t ; opt = kTRUE). static . This is a static function. ; Set object delete option. When this option is activated (default), ReadBuffer automatically delete objects when a data member is a pointer to an object. If your constructor is not presetting pointers to 0, you must call this static function TStreamerInfo::SetCanDelete(kFALSE); ; Definition at line 220 of file TVirtualStreamerInfo.cxx. ◆ SetCheckSum(). virtual void TVirtualStreamerInfo::SetCheckSum ; (; UInt_t ; checksum). pure virtual . Implemented in TStreamerInfo. ◆ SetClass(). virtual void TVirtualStreamerInfo::SetClass ; (; TClass * ; cl). pure virtual . Implemented in TStreamerInfo. ◆ SetClassVersion(). virtual void TVirtualStreamerInfo::SetClassVersion ; (; Int_t ; vers). pure virtual . Implemented in TStreamerInfo. ◆ SetFactory(). void TVirtualStreamerInfo::SetFactory ; (; TVirtualStreamerInfo * ; factory). static . static function: Set the StreamerInfo factory ; Definition at line 228 of file TVirtualStreamerInfo.cxx. ◆ SetIsCompiled(). void TVirtualStreamerInfo::SetIsCompiled ; (; ). inlineprotected . Definition at line 64 of file TVirtualStreamerInfo.h. ◆ SetStreamMemberWise(). Bool_t TVirtualStreamerInfo::SetStreamMemberWise ; (; Bool_t ; enable = kTRUE). static . Set whether the TStreamerInfos will save the collections in ""member-wise"" order whenever possible. ; The default is to store member-wise.; kTRUE indicates member-wise storing; kFALSE indicates ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualStreamerInfo.html:32423,checksum,checksum,32423,doc/master/classTVirtualStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTVirtualStreamerInfo.html,1,['checksum'],['checksum']
Security,irty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooRealProxy_dgamma; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; RooRealProxy_f0; RooRealProxy_f1; RooRealProxy_f2; RooRealProxy_f3; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsAnaConvPdf::_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBDecay.html:43831,access,access,43831,root/html602/RooBDecay.html,https://root.cern,https://root.cern/root/html602/RooBDecay.html,2,['access'],['access']
Security,"is (dimension), we have bins of equal width w Y = 1.5 - (-3.0) 200 = 0.0225.; If you want to create histograms with variable bin widths, ROOT provides another constructor suited for this purpose. Instead of passing the data interval and the number of bins, you have to pass an array (single or double precision) of bin edges. When the histogram has n bins, then there are n+1 distinct edges, so the array you pass must be of size n+1.; const Int_t NBINS = 5;; Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; // Bin 1 corresponds to range [0.0, 0.2]; // Bin 2 corresponds to range [0.2, 0.3] etc... TH1* h = new TH1D(; /* name */ ""h1"",; /* title */ ""Hist with variable bin width"",; /* number of bins */ NBINS,; /* edge array */ edges; );; Each histogram object contains three TAxis objects: fXaxis , fYaxis, and fZaxis, but for one-dimensional histograms only the X-axis is relevant, while for two-dimensional histograms the X-axis and Y-axis are relevant. See the class TAxis for a description of all the access methods. The bin edges are always stored internally in double precision.; You can examine the actual edges / limits of the histogram bins by accessing the axis parameters, like in the example below:; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; 3.3 Bin Numbering; All histogram types support fixed or variable bin sizes. 2-D histograms may have fixed size bins along X and variable size bins along Y or vice-versa. The functions to fill, manipulate, draw, or acce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:74556,access,access,74556,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"is allows recursive list operations during the delete (e.g. during the dtor of an object in this list one can still access the list to search for other not yet deleted objects). ; Implements TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 207 of file THashList.cxx. ◆ FindObject() [1/2]. TObject * THashList::FindObject ; (; const char * ; name); const. overridevirtual . Find object using its name. ; Uses the hash value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from TCollection.; Reimplemented in TListOfEnums, TListOfDataMembers, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, and TListOfFunctionTemplates.; Definition at line 262 of file THashList.cxx. ◆ FindObject() [2/2]. TObject * THashList::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 272 of file THashList.cxx. ◆ GetListForObject() [1/2]. const TList * THashList::GetListForObject ; (; const char * ; name); const. Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ; Definition at line 283 of file THashList.cxx. ◆ GetListForObject() [2/2]. const TList * THashList::GetListForObject ; (; const TObject * ; obj); const. Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ; Definition at line 294 of file THashList.cxx. ◆ IsA(). TClass * THashList::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:30003,hash,hash,30003,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['hash'],['hash']
Security,"is generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name) const; Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index) const; Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Fri Dec 2 14:26:48 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFormula.html:16373,access,accessor,16373,root/html532/RooFormula.html,https://root.cern,https://root.cern/root/html532/RooFormula.html,1,['access'],['accessor']
Security,"is generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name) const; Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index) const; Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Mon Jul 4 15:22:51 2011 » Last generated: 2011-07-04 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFormula.html:16309,access,accessor,16309,root/html530/RooFormula.html,https://root.cern,https://root.cern/root/html530/RooFormula.html,1,['access'],['accessor']
Security,"is generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name) const; Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index) const; Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Sat Oct 9 22:38:42 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFormula.html:16240,access,accessor,16240,root/html528/RooFormula.html,https://root.cern,https://root.cern/root/html528/RooFormula.html,1,['access'],['accessor']
Security,"is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_CNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:InputLayout=1|16|16:Layout=CONV|10|3|3|1|1|1|1|RELU,BNORM,CONV|10|3|3|1|1|1|1|RELU,MAXPOOL|2|2|1|1,RESHAPE|FLAT,DENSE|100|RELU,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.0:Architectu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:4325,validat,validation,4325,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['validat'],['validation']
Security,"is has to be done in TSelector::Process(Long64_t entry). We will print also the current entry number, to see what's happening:; Bool_t EventSelector::Process(Long64_t entry); {; // ... // print some information about the current entry; printf(""Processing Entry number %ld\n"", entry);; // increase the total number of entries; ++fNumberOfEvents;. return kTRUE;; }. And finally, at the end of the process, in TSelector::Terminate(), print the total number of entries:; void EventSelector::Terminate(); {; // ... // print the result; printf(""\nTotal Number of Events: %d\n"", fNumberOfEvents);; }. As you can see, the fNumberOfEvents member is accessed in Process() and Terminate(), hence the reason of making it a data member.; More Complex Task; We want to calculate the sum of all event sizes. For this we need a new data member of type int. Create it - like the other data members in the class declaration. Don't forget to initialize it to 0 in the constructor. You also have to declare the reader variables used to access the tree's data. At the end, the code in EventSelector.h should look like this:; class EventSelector : public TSelector {; public :; Int_t fTotalDataSize; // Sum of data size (in bytes) of all events. // Variables used to access and store the data; TTreeReader fReader; // The tree reader ; TTreeReaderValue<Int_t> fCurrentEventSize; // Size of the current event. EventSelector(TTree * = 0):; fTotalDataSize(0),; fCurrentEventSize(fReader, ""fEventSize"") { }; virtual ~EventSelector() { }. virtual void Init(TTree *tree);; ... Connecting a Tree Branch with the Data Member; As already explained in the Using a Macro to Read a TTree tutorial, here again we have to ""connect"" the TTreeReader to the tree we want to read by calling TTreeReader::SetTree(). This has to be done in the TSelector::Init() method, as shown below:; void EventSelector::Init(TTree *tree); {; //... // Associate the TTreeReader with the tree we want to read; fReader.SetTree(tree);; }. Loading TTree's Data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tselector.html:5260,access,access,5260,d/accessing-ttree-tselector.html,https://root.cern,https://root.cern/d/accessing-ttree-tselector.html,1,['access'],['access']
Security,"is is done by adding two parameters to Divide(), which are the margins in x and y:; root[] pad1->Divide(3,2,0.1,0.1); The margins are here set to 10% of the parent pad width.; 9.3.5 Updating the Pad; For performance reasons, a pad is not updated with every change. For example, changing the coordinates of the pad does not automatically redraw it. Instead, the pad has a “bit-modified” that triggers a redraw. This bit is automatically set by:. Touching the pad with the mouse - for example resizing it with the mouse.; Finishing the execution of a script.; Adding a new primitive or modifying some primitives for example the name and title of an object.; You can also set the “bit-modified” explicitly with the Modified method:; // the pad has changed; root[] pad1->Modified(); // recursively update all modified pads:; root[] c1->Update(); A subsequent call to TCanvas::Update() scans the list of sub-pads and repaints the pads declared modified. In compiled code or in a long macro, you may want to access an object created during the paint process. To do so, you can force the painting with a TCanvas::Update(). For example, a TGraph creates a histogram (TH1) to paint itself. In this case the internal histogram obtained with TGraph::GetHistogram() is created only after the pad is painted. The pad is painted automatically after the script is finished executing or if you force the painting with TPad::Modified() followed by a TCanvas::Update(). Note that it is not necessary to call TPad::Modified() after a call to Draw(). The “bit-modified” is set automatically by Draw(). A note about the “bit-modified” in sub pads: when you want to update a sub pad in your canvas, you need to call pad->Modified() rather than canvas->Modified(), and follow it with a canvas->Update(). If you use canvas->Modified(), followed by a call to canvas->Update(), the sub pad has not been declared modified and it will not be updated. Also note that a call to pad->Update() where pad is a sub pad of canvas, call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:314662,access,access,314662,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"is the; owner (set via SetOwner()). void Add(TObject* obj); This function may not be used (but we need to provide it since it is; a pure virtual in TCollection). Use Add(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMap.html:9480,hash,hash,9480,root/html528/TMap.html,https://root.cern,https://root.cern/root/html528/TMap.html,6,['hash'],['hash']
Security,"is value.; 628 element->SetType(TVirtualStreamerInfo::kNoType);; 629 }; 630 }; 631 ; 632 if ( !wasCompiled && (rules && rules.HasRuleWithSource( element->GetName(), kTRUE )) ) {; 633 needAllocClass = kTRUE;; 634 ; 635 // If this is optimized to re-use TStreamerElement(s) in case of variable renaming,; 636 // then we must revisit the code in TBranchElement::InitInfo that recalculate the; 637 // fID (i.e. the index of the TStreamerElement to be used for streaming).; 638 ; 639 TStreamerElement *cached = element;; 640 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 641 if (element->GetNewType()>0 /* intentionally not including base class for now */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 654 fElements->Add(element);; 655 writecopy->SetBit(TStreamerElement::kWrite);; 656 writecopy->SetNewType( writecopy->GetType() );; 657 writecopy->SetOffset( element->GetOffset() );; 658 // Put the write element after the read element (that does caching).; 659 element = writecopy;; 660 }; 661 cached->SetBit(TStreamerElement::kCache);; 662 cached->SetNewType( cached->GetType() );; 663 }; 664 ; 665 fElements->Add(element);; 666 } // end of member loop; 667 ; 668 // Now add artificial TStreamerElement (i.e. rules that creates new members or set transient members).; 669 InsertArtificialElements(rules);; 670 ; 671 if (needAllocClass) {; 672 TStreamerInfo *infoalloc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:23867,inject,inject,23867,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['inject'],['inject']
Security,"is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:7284,access,access,7284,root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,32,['access'],['access']
Security,"is:; import { httpRequest, draw } from './jsrootsys/modules/core.mjs';; let res = await httpRequest(""your_server/multi.json?number=3"", ""multi"",; ""Files/job1.root/hpx/root.json\nFiles/job1.root/hpxpy/root.json\nFiles/job1.root/hprof/root.json\n"");; for (let n = 0; n < res.length; ++n) {; console.log('Requested element of type', res[n]._typename);; // draw('drawid', res[n], 'hist');; }; Here argument “multi” identifies, that server response should be parsed with parseMulti() function, which correctly interprets JSON code, produced by multi.json request. When sending such request to the server, one should provide list of objects names and not forget “?number=N” parameter in the request URL string.; 1.10 Using unix sockets; Starting from ROOT version 6.28, one can start server with unix socket. Just do:; Just call:; [root] new THttpServer(""socket:/tmp/root.socket""); Name of socket should be unique and not match any existing files.; Most easy way to access THttpServer running via unix socket is to configure ssh tunnel:; [shell] ssh -L 7654:/tmp/root.socket localhost; Once such tunnel is configured one can open following URL in web browser:; [shell] xdg-open http://localhost:7654; 1.11 Websockets supports; Websockets support available starting from ROOT v6.12. Minimal example provided in $ROOTSYS/tutorials/http/ws.C macro.; To work with websockets, subclass of THttpWSHandler should be created and registered to THttpServer:; #include ""THttpWSHandler.h"". class TUserHandler : public THttpWSHandler {; public:; TUserHandler(const char *name, const char *title) : THttpWSHandler(name, title) {}. // provide custom HTML page when open correspondent address; TString GetDefaultPageContent() override { return ""file:ws.htm""; }. Bool_t ProcessWS(THttpCallArg *arg) override;; };; Central method is TUserHandler::ProcessWS(THttpCallArg *arg), where four kinds of websockets events should be handled:. WS_CONNECT - clients attempts to create websockets, return false when refusing connection; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:22553,access,access,22553,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['access'],['access']
Security,"isIrregularAn axis with non-equidistant bins (also known as ""variable binning"") ;  CTAxisLabelsA TAxisGrow that has a label assigned to each bin and a bin width of 1 ;  CTAxisViewCommon view on a TAxis, no matter what its kind ;  CTBufferMergerTBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file ;  CTBufferMergerFile;  CTCanvasA window's topmost TPad ;  ►CTColorA color: Red|Green|Blue|Alpha, or a position in a TPalette ;  CAlpha;  CAutoTagUsed to signal that this color shall be automatically chosen by the drawing routines, by picking a color from the TPad's (or rather its TFrame's) current TPalette ;  CTAlphaThe alpha value of a color: 0 is completely transparent, 1 is completely opaque ;  CTDataFrameROOT's TDataFrame offers a high level interface for analyses of data stored in TTrees ;  ►CTDirectoryKey/value store of objects ;  CToContentType;  CTDirectoryTypeMismatchObjects of this class are thrown to signal that the value known under the given name ;  CTDirectoryUnknownKeyObjects of this class are thrown to signal that no key with that name exists ;  CTDisplayItemBase class for painting data for JS ;  CTDrawableBase class for drawable entities: objects that can be painted on a TPad ;  CTDrawingAttrRefThe TCanvas keep track of TColors, integer and floating point attributes used by the drawing options, making them accessible from other drawing options ;  CTDrawingOptsBaseBase class for drawing options ;  ►CTDrawingOptsBaseNoDefault;  COptsAttrRefArr;  CTextDrawingOpts;  ►CTFileA ROOT file ;  COptions_tOptions for TFile construction ;  CTFilePtrPoints to an object that stores or reads objects in ROOT's binary format ;  CTFillAttrs;  CTFitPanelWeb-based FitPanel prototype ;  CTFitPanelModelStruct ROOT::Experimental::TFitPanelModelModel, used to initialized openui5 FitPanel ;  CTFitResult;  ►CTFrameHolds a user coordinate system with a palette ;  CDrawingOpts;  CTFunction;  CTFutureA TFuture class.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:17999,access,accessible,17999,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['access'],['accessible']
Security,"isation called by all constructors. ~MethodCFMlpANN( void ); destructor. void Train( void ); training of the Clement-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input variables. void NN_ava(Double_t* ); auxiliary functions. Double_t NN_fonc(Int_t , Double_t ) const; activation function. void ReadWeightsFromStream(istream& istr); read back the weight from the training from file (stream). Int_t DataInterface(Double_t* , Double_t* , Int_t* , Int_t* , Int_t* , Int_t* , Double_t* , Int_t* , Int_t* ); data interface function. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); read weights from xml file. void PrintWeights(ostream& o) const; write the weights of the neural net. TMVA::MethodCFMlpANN* This( void ); static pointer to this object (required for external functions. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific classifier response for header. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". Double_t GetData(Int_t isel, Int_t ivar) const; data accessors for external functions. { return (*fData)(isel, ivar); }. Int_t GetClass(Int_t ivar) const; { return (*fClass)[ivar]; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodCFMlpANN.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodCFMlpANN.html:24354,access,accessors,24354,root/html530/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodCFMlpANN.html,1,['access'],['accessors']
Security,"ise comparison ;  ; template<class A > ; bool operator== (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator!= (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; bool operator> (const T &rhs) const;  element wise comparison ;  ; bool operator< (const T &rhs) const;  element wise comparison ;  ; bool operator> (const SVector< T, D > &rhs) const;  element wise comparison ;  ; bool operator< (const SVector< T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator> (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator< (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; const T & operator[] (unsigned int i) const;  read-only access of vector elements. Index starts from 0. ;  ; const T & operator() (unsigned int i) const;  read-only access of vector elements. Index starts from 0. ;  ; const T & At (unsigned int i) const;  read-only access of vector elements with check on index. Index starts from 0. ;  ; T & operator[] (unsigned int i);  read/write access of vector elements. Index starts from 0. ;  ; T & operator() (unsigned int i);  read/write access of vector elements. Index starts from 0. ;  ; T & At (unsigned int i);  read/write access of vector elements with check on index. Index starts from 0. ;  ; SVector< T, D > & operator+= (const T &rhs);  self addition with a scalar ;  ; SVector< T, D > & operator-= (const T &rhs);  self subtraction with a scalar ;  ; SVector< T, D > & operator*= (const T &rhs);  self multiplication with a scalar ;  ; SVector< T, D > & operator/= (const T &rhs);  self division with a scalar ;  ; SVector< T, D > & operator+= (const SVector< T, D > &rhs);  self addition with another vector ;  ; SVector< T, D > & operator-= (const SVector< T, D > &rhs);  self subtraction with another vector ;  ; template<class A > ; SVector< T, D > & operator+= (const VecExpr< A, T, D > &rhs);  self ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html:4991,access,access,4991,doc/master/classROOT_1_1Math_1_1SVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html,1,['access'],['access']
Security,"iseActions(TClass *oldClass, Int_t version) overrideReturn the set of action necessary to stream in this collection member-wise coming from the old value...Definition TGenCollectionProxy.cxx:1747; TGenCollectionProxy::fReadMemberWiseTObjArray * fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read)Definition TGenCollectionProxy.h:291; TGenCollectionProxy::DeleteItemvirtual void DeleteItem(Bool_t force, void *ptr) constCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:1350; TGenCollectionProxy::GetCollectionClassTClass * GetCollectionClass() const overrideReturn a pointer to the TClass representing the container.Definition TGenCollectionProxy.cxx:985; TGenCollectionProxy::fStagedStaged_t fStagedOptimization: Keep staged array once they were created.Definition TGenCollectionProxy.h:319; TGenCollectionProxy::fSizeMethod fSizeContainer accessors: size of container.Definition TGenCollectionProxy.h:302; TGenCollectionProxy::fClearMethod fClearMethod cache for container accessors: clear container.Definition TGenCollectionProxy.h:301; TGenCollectionProxy::fFeedFeedfunc_t fFeedContainer accessors: block feed.Definition TGenCollectionProxy.h:308; TGenCollectionProxy::GetFunctionCreateIteratorsCreateIterators_t GetFunctionCreateIterators(Bool_t read=kTRUE) overrideSee typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena); begin_...Definition TGenCollectionProxy.cxx:1607; TGenCollectionProxy::fValDiffint fValDiffOffset between two consecutive value_types (memory layout).Definition TGenCollectionProxy.h:316; TGenCollectionProxy::ReadBuffervirtual void ReadBuffer(TBuffer &b, void *obj)Definition TGenCollectionProxy.cxx:1419; TGenCollectionProxy::fProxyKeptProxies_t fProxyKeptOptimization: Keep proxies once they were created.Definition TGenCollectionProxy.h:318; TGenCollectionProxy::SizeofUInt_t Sizeof() const overrideReturn the sizeof the collection object.Definition TGenCollectionProxy.cxx:1014; TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:85492,access,accessors,85492,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['access'],['accessors']
Security,"iskId ; (; ); const. inline . Definition at line 527 of file RFieldBase.hxx. ◆ GetOnDiskTypeChecksum(). std::uint32_t ROOT::Experimental::RFieldBase::GetOnDiskTypeChecksum ; (; ); const. inline . Return checksum stored in the field descriptor; only valid after a call to ConnectPageSource(), if the field stored a type checksum. ; Definition at line 549 of file RFieldBase.hxx. ◆ GetOnDiskTypeVersion(). std::uint32_t ROOT::Experimental::RFieldBase::GetOnDiskTypeVersion ; (; ); const. inline . Return the C++ type version stored in the field descriptor; only valid after a call to ConnectPageSource() ; Definition at line 546 of file RFieldBase.hxx. ◆ GetParent(). const RFieldBase * ROOT::Experimental::RFieldBase::GetParent ; (; ); const. inline . Definition at line 518 of file RFieldBase.hxx. ◆ GetPrincipalColumnOf(). static Internal::RColumn * ROOT::Experimental::RFieldBase::GetPrincipalColumnOf ; (; const RFieldBase & ; other). inlinestaticprotected . Fields may need direct access to the principal column of their sub fields, e.g. in RRVecField::ReadBulk. ; Definition at line 408 of file RFieldBase.hxx. ◆ GetQualifiedFieldName(). std::string ROOT::Experimental::RFieldBase::GetQualifiedFieldName ; (; ); const. Returns the field name and parent field names separated by dots (""grandparent.parent.child"") ; Definition at line 570 of file RField.cxx. ◆ GetState(). EState ROOT::Experimental::RFieldBase::GetState ; (; ); const. inline . Definition at line 525 of file RFieldBase.hxx. ◆ GetStructure(). ENTupleStructure ROOT::Experimental::RFieldBase::GetStructure ; (; ); const. inline . Definition at line 516 of file RFieldBase.hxx. ◆ GetSubFields() [1/2]. std::vector< ROOT::Experimental::RFieldBase * > ROOT::Experimental::RFieldBase::GetSubFields ; (; ). Definition at line 1004 of file RField.cxx. ◆ GetSubFields() [2/2]. std::vector< const ROOT::Experimental::RFieldBase * > ROOT::Experimental::RFieldBase::GetSubFields ; (; ); const. Definition at line 1014 of file RField.cxx. ◆ G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:42212,access,access,42212,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['access'],['access']
Security,"isplacement vector of arbitrary type; 116 */; 117 template <class OtherCoords>; 118 DisplacementVector2D & operator=; 119 ( const DisplacementVector2D<OtherCoords, Tag> & v) {; 120 fCoordinates = v.Coordinates();; 121 return *this;; 122 }; 123 ; 124 /**; 125 Assignment operator from a position vector; 126 (not necessarily efficient unless one or the other is Cartesian); 127 */; 128 template <class OtherCoords>; 129 DisplacementVector2D & operator=; 130 ( const PositionVector2D<OtherCoords,Tag> & rhs) {; 131 SetXY(rhs.x(), rhs.y() );; 132 return *this;; 133 }; 134 ; 135 ; 136 /**; 137 Assignment from a foreign 2D vector type, for example, Hep2Vector; 138 Precondition: v must implement methods x() and y(); 139 */; 140 template <class ForeignVector>; 141 DisplacementVector2D & operator= ( const ForeignVector & v) {; 142 SetXY( v.x(), v.y() );; 143 return *this;; 144 }; 145 ; 146 ; 147 // ------ Set, Get, and access coordinate data ------; 148 ; 149 /**; 150 Retrieve a copy of the coordinates object; 151 */; 152 CoordSystem Coordinates() const {; 153 return fCoordinates;; 154 }; 155 ; 156 /**; 157 Set internal data based on 2 Scalar numbers.; 158 These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector; 159 */; 160 DisplacementVector2D<CoordSystem, Tag>& SetCoordinates( Scalar a, Scalar b) {; 161 fCoordinates.SetCoordinates(a, b);; 162 return *this;; 163 }; 164 ; 165 ; 166 /**; 167 get internal data into 2 Scalar numbers.; 168 These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector; 169 */; 170 void GetCoordinates( Scalar& a, Scalar& b) const; 171 { fCoordinates.GetCoordinates(a, b); }; 172 ; 173 ; 174 /**; 175 set the values of the vector from the cartesian components (x,y); 176 (if the vector is held in polar coordinates,; 177 then (x, y) are converted to that form); 178 */; 179 DisplacementVector2D<CoordSystem, Tag>& SetXY (Scalar a, Scalar b) {; 180 fCoordinates.SetXY(a,b);; 181 return *this;; 182 }; 183 ; 184 // ----",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html:4680,access,access,4680,doc/master/GenVector_2DisplacementVector2D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html,1,['access'],['access']
Security,"isplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:22233,access,access,22233,root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,ist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; TIterator*_histObsIter! ; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistPdf.html:40758,access,access,40758,root/html534/RooHistPdf.html,https://root.cern,https://root.cern/root/html534/RooHistPdf.html,1,['access'],['access']
Security,"ist of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formula); virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tAnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFormula.html:2604,access,access,2604,root/html534/TFormula.html,https://root.cern,https://root.cern/root/html534/TFormula.html,2,['access'],['access']
Security,"ist of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions. Function Members (Methods); public:. virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tAnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFormula.html:2604,access,access,2604,root/html602/TFormula.html,https://root.cern,https://root.cern/root/html602/TFormula.html,4,['access'],['access']
Security,"ist of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TApplication; static TList * fgApplications = nullptr;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TRint.h>. Inheritance diagram for TRint:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TRint() [1/2]. TRint::TRint ; (; const TRint & ; ). privatedelete . ◆ TRint() [2/2]. TRint::TRint ; (; const char * ; appClassName, . Int_t * ; argc, . char ** ; argv, . void * ; options = nullptr, . Int_t ; numOptions = 0, . Bool_t ; noLogo = kFALSE, . Bool_t ; exitOnUnknownArgs = kFALSE . ). Create an application environment. ; The TRint environment provides an interface to the WM manager functionality and eventloop via inheritance of TApplication and in addition provides interactive access to the Cling C++ interpreter via the command line. ; Definition at line 171 of file TRint.cxx. ◆ ~TRint(). TRint::~TRint ; (; ). virtual . Destructor. ; Definition at line 316 of file TRint.cxx. Member Function Documentation. ◆ Class(). static TClass * TRint::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TRint::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TRint::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 67 of file TRint.h. ◆ DeclFileName(). static const char * TRint::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 67 of file TRint.h. ◆ ExecLogon(). void TRint::ExecLogon ; (; ). private . Execute logon macro's. ; There are three levels of logon macros that will be executed: the system logon etc/system.roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRint.html:22596,access,access,22596,doc/master/classTRint.html,https://root.cern,https://root.cern/doc/master/classTRint.html,1,['access'],['access']
Security,"ist; TGMdiGeometry MDI Geometry; TGMdiHorizontalWinResizer Horizontal Window Resizer; TGMdiMainFrame MDI main frame; TGMdiMenuBar MDI menu bar; TGMdiTitleBar MDI Title Bar; TGMdiTitleIcon MDI Title Icon; TGMdiVerticalWinResizer Vertical Window Resizer; TGMdiWinResizer Window Resizer; TGMenuBar Menu bar class; TGMenuEntry Menu entry class; TGMenuTitle Menu title class; TGMimeTypes Pool of mime type objects; TGMsgBox A message dialog box; TGNumberEntry Entry field widget for several numeric formats; TGNumberEntryField A text entry field used by a TGNumberEntry; TGNumberEntryLayout Layout manager for number entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider widget abstract ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:83137,password,passwords,83137,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['password'],['passwords']
Security,"istician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:24519,hash,hash,24519,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,6,['hash'],['hash']
Security,istlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; TIterator*_histObsIter!; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:42429,access,access,42429,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,2,['access'],['access']
Security,"istograms in parallel and write them on file ;  mt101_fillNtuples.C Fill n-tuples in distinct workers ;  mt102_readNtuplesFillHistosAndFit.C Read n-tuples in distinct workers, fill histograms, merge them and fit ;  mt103_fillNtupleFromMultipleThreads.C Fill the same TNtuple from different threads ;  mt201_parallelHistoFill.C Parallel fill of a histogram ;  mt301_TTaskGroupSimple.C Shows how to run items of work asynchronously with a TTaskGroup ;  mt302_TTaskGroupNested.C Calculate Fibonacci numbers exploiting nested parallelism through TTaskGroup ;  mt304_fillHistos.CFill histograms in parallel with automatic binning ;  mtbb001_fillHistos.C Fill histograms in parallel and write them on file ;  mtbb101_fillNtuples.C Fill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.C Parallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:138380,authenticat,authentication,138380,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['authenticat'],['authentication']
Security,"istrator may want to switch off private settings. Always true, may only be set false via option to proofd. ; Definition at line 1341 of file TAuthenticate.cxx. ◆ SetRSAInit(). void TAuthenticate::SetRSAInit ; (; Int_t ; init = 1). static . Static method setting RSA initialization flag. ; Definition at line 1228 of file TAuthenticate.cxx. ◆ SetRSAKeyType(). void TAuthenticate::SetRSAKeyType ; (; Int_t ; key). inline . Definition at line 148 of file TAuthenticate.h. ◆ SetRSAPublic(). Int_t TAuthenticate::SetRSAPublic ; (; const char * ; rsaPubExport, . Int_t ; klen . ). static . Store RSA public keys from export string rsaPubExport. ; Returns type of stored key, or -1 is not recognized ; Definition at line 3039 of file TAuthenticate.cxx. ◆ SetSecContext(). void TAuthenticate::SetSecContext ; (; TRootSecContext * ; ctx). inline . Definition at line 149 of file TAuthenticate.h. ◆ SetSecureAuthHook(). void TAuthenticate::SetSecureAuthHook ; (; SecureAuth_t ; func). static . Set secure authorization function. ; Definition at line 1393 of file TAuthenticate.cxx. ◆ SetTimeOut(). void TAuthenticate::SetTimeOut ; (; Int_t ; to). static . Set timeout (active if > 0) ; Definition at line 1369 of file TAuthenticate.cxx. ◆ Show(). void TAuthenticate::Show ; (; Option_t * ; opt = ""S""). static . Print info about the authentication sector. ; If 'opt' contains 's' or 'S' prints information about established TSecContext, else prints information about THostAuth (if 'opt' is 'p' or 'P', prints Proof related information) ; Definition at line 2219 of file TAuthenticate.cxx. ◆ SshAuth(). Int_t TAuthenticate::SshAuth ; (; TString & ; user). private . SSH client authentication code (no longer supported) ; Definition at line 1419 of file TAuthenticate.cxx. ◆ SshError(). Int_t TAuthenticate::SshError ; (; const char * ; errfile). private . ◆ Streamer(). void TAuthenticate::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ Strea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:40988,secur,secure,40988,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,2,"['authoriz', 'secur']","['authorization', 'secure']"
Security,"it 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:28856,secur,security,28856,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['secur'],['security']
Security,"it by calling GetEntryList() function.; See also comments to SetEventList() function of TTree and TChain. If arrays are used in the selection critera, the event entered in the; list are all the event that have at least one element of the array that; satisfy the selection.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of ALL tracks in event with at least one track with; a positive fPy. To select only the elements that did match the original selection; use TEventList::SetReapplyCut.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(kTRUE);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy. Note: Use tree->SetEventList(0) if you do not want use the list as input. How to obtain more info from TTree::Draw. Once TTree::Draw has been called, it is possible to access useful; information still stored in the TTree object via the following functions:; -GetSelectedRows() // return the number of entries accepted by the; //selection expression. In case where no selection; //was specified, returns the number of entries processed.; -GetV1() //returns a pointer to the double array of V1; -GetV2() //returns a pointer to the double array of V2; -GetV3() //returns a pointer to the double array of V3; -GetW() //returns a pointer to the double array of Weights; //where weight equal the result of the selection expression.; where V1,V2,V3 correspond to the expressions in; TTree::Draw(""V1:V2:V3"",selection);. Example:; Root > ntuple->Draw(""py:px"",""pz>4"");; Root > TGraph *gr = new TGraph(ntuple->GetSelectedRows(),; ntuple->GetV2(), ntuple->GetV1());; Root > gr->Draw(""ap""); //draw graph in current pad; creates a TGraph object with a number of points corresponding to the; number of entries selected by the expression ""pz>4"", the x points of the graph; being the px values of the Tree and the y points the py values. Important n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:36582,access,access,36582,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['access'],['access']
Security,"it points ; Definition at line 293 of file FitData.h. ◆ UnWrap(). void ROOT::Fit::FitData::UnWrap ; (; ). inlineprotected . Definition at line 336 of file FitData.h. ◆ VectorPadding(). static constexpr unsigned ROOT::Fit::FitData::VectorPadding ; (; const unsigned ; ). inlinestaticconstexprprotected . If VecCore is not defined, there is no vectorization available and the SIMD vector size will always be one. ; Then, as every number is a multiple of SIMD vector size, the padding will always be zero. ; Definition at line 372 of file FitData.h. Member Data Documentation. ◆ fCoords. std::vector< std::vector< double > > ROOT::Fit::FitData::fCoords. private . This vector stores the vectorizable data: The inner vectors contain the coordinates data fCoords[0] is the vector for the x-coords fCoords[1] is the vector for the y-coords etc. ; The vector of pointers stores the pointers to the first elements of the corresponding elements; If fWrapped is true, fCoords is empty. the data can only be accessed by using fCoordsPtr. ; Definition at line 403 of file FitData.h. ◆ fCoordsPtr. std::vector< const double * > ROOT::Fit::FitData::fCoordsPtr. private . Definition at line 404 of file FitData.h. ◆ fDim. unsigned int ROOT::Fit::FitData::fDim. protected . Definition at line 386 of file FitData.h. ◆ fMaxPoints. unsigned int ROOT::Fit::FitData::fMaxPoints. protected . Definition at line 384 of file FitData.h. ◆ fNPoints. unsigned int ROOT::Fit::FitData::fNPoints. protected . Definition at line 385 of file FitData.h. ◆ fOptions. DataOptions ROOT::Fit::FitData::fOptions. private . Definition at line 380 of file FitData.h. ◆ fpTmpCoordVector. double* ROOT::Fit::FitData::fpTmpCoordVector. private . Definition at line 406 of file FitData.h. ◆ fRange. DataRange ROOT::Fit::FitData::fRange. private . Definition at line 381 of file FitData.h. ◆ fWrapped. bool ROOT::Fit::FitData::fWrapped. protected . Definition at line 376 of file FitData.h. Libraries for ROOT::Fit::FitData:. [legend]; The docum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitData.html:13908,access,accessed,13908,doc/master/classROOT_1_1Fit_1_1FitData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitData.html,1,['access'],['accessed']
Security,"it will be; 1908/// set to the modtime. Returns 0 on success and -1 in case of error.; 1909 ; 1910int TUnixSystem::Utime(const char *file, Long_t modtime, Long_t actime); 1911{; 1912 if (!actime); 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location of file ""wfil"" in a search path.; 1923/// The search path is specified as a : separated list of directories.; 1924/// Return value is pointing to wfile for compatibility with; 1925/// Which(const char*,const char*,EAccessMode) version.; 1926 ; 1927const char *TUnixSystem::FindFile(const char *search, TString& wfil, EAccessMode mode); 1928{; 1929 TString show;; 1930 if (gEnv->GetValue(""Root.ShowPath"", 0)); 1931 show.Form(""Which: %s ="", wfil.Data());; 1932 ; 1933 gSystem->ExpandPathName(wfil);; 1934 ; 1935 if (wfil[0] == '/') {; 1936#if defined(R__SEEK64); 1937 struct stat64 finfo;; 1938 if (access(wfil.Data(), mode) == 0 &&; 1939 stat64(wfil.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1940#else; 1941 struct stat finfo;; 1942 if (access(wfil.Data(), mode) == 0 &&; 1943 stat(wfil.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1944#endif; 1945 if (show != """"); 1946 Printf(""%s %s"", show.Data(), wfil.Data());; 1947 return wfil.Data();; 1948 }; 1949 if (show != """"); 1950 Printf(""%s <not found>"", show.Data());; 1951 wfil = """";; 1952 return nullptr;; 1953 }; 1954 ; 1955 if (!search); 1956 search = ""."";; 1957 ; 1958 TString apwd(gSystem->WorkingDirectory());; 1959 apwd += ""/"";; 1960 for (const char* ptr = search; *ptr;) {; 1961 TString name;; 1962 if (*ptr != '/' && *ptr !='$' && *ptr != '~'); 1963 name = apwd;; 1964 const char* posEndOfPart = strchr(ptr, ':');; 1965 if (posEndOfPart) {; 1966 name.Append(ptr, posEndOfPart - ptr);; 1967 ptr = posEndOfPart + 1; // skip ':'; 1968 } else {; 1969 name.Appe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:59690,access,access,59690,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['access'],['access']
Security,"iteImage (const char *, EImageFileTypes=TImage::kUnknown);  ; virtual void Zoom (UInt_t, UInt_t, UInt_t, UInt_t);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTImage.html:9207,hash,hash,9207,doc/master/classTImage.html,https://root.cern,https://root.cern/doc/master/classTImage.html,1,['hash'],['hash']
Security,"iterator to be incremented and an iterator that points to the end of the collection, respectively. ;  ;  Static Public Attributes inherited from TVirtualCollectionProxy; static const Int_t fgIteratorArenaSize = 16;  The size of a small buffer that can be allocated on the stack to store iterator-specific information. ;  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedMapProxy.html:11400,access,accessors,11400,doc/master/classTEmulatedMapProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedMapProxy.html,1,['access'],['accessors']
Security,ith a double per channel (see TH1 documentation)} ;  CTH2Editor;  CTH2F2-D histogram with a float per channel (see TH1 documentation)} ;  CTH2GLRendering of TH2 and derived classes ;  CTH2I2-D histogram with an int per channel (see TH1 documentation)} ;  CTH2Poly2D Histogram with Polygonal Bins ;  CTH2PolyBinHelper class to represent a bin in the TH2Poly histogram ;  CTH2S2-D histogram with a short per channel (see TH1 documentation) ;  CTH3The 3-D histogram classes derived from the 1-D histogram classes ;  CTH3C3-D histogram with a byte per channel (see TH1 documentation) ;  CTH3D3-D histogram with a double per channel (see TH1 documentation)} ;  CTH3F3-D histogram with a float per channel (see TH1 documentation)} ;  CTH3GLOpenGL renderer class for TH3 ;  CTH3I3-D histogram with an int per channel (see TH1 documentation)} ;  CTH3S3-D histogram with a short per channel (see TH1 documentation) ;  CTHaarMatrixT;  CTHashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject's ;  CTHashTableTHashTable implements a hash table to store TObject's ;  CTHashTableIterIterator of hash table ;  CTHbookBranchHBOOK Branch ;  CTHbookFileThis class is an interface to the Hbook objects in Hbook files ;  CTHbookKeyHBOOK Key ;  CTHbookTreeA wrapper class supporting Hbook ntuples (CWN and RWN) ;  CTHDFSFileReads and writes its data via the HDFS protocols ;  CTHDFSSystemDirectory handler for HDFS (THDFSFile) ;  CTHelixTHelix has two different constructors ;  CTHilbertMatrixT;  CTHilbertMatrixTSym;  CTHistPainterThe histogram painter class ;  CTHistRenderingRegion;  CTHLimitsFinderClass to compute nice axis limits ;  CTHnMultidimensional histogram ;  CTHnBaseMultidimensional histogram base ;  CTHnChainA class to chain together multiple histograms ;  CTHnIterIterator over THnBase bins ;  CTHnSparseEfficient multidimensional histogram ;  CTHnSparseArrayChunkTHnSparseArrayChunk is used internally by THnSparse ;  CTHnSparseTTemplated implemen,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:179475,hash,hash,179475,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['hash'],['hash']
Security,"ith a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4374; TClass::GetIsAProxyTVirtualIsAProxy * GetIsAProxy() constReturn the proxy implementing the IsA functionality.Definition TClass.cxx:2955; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetMergeROOT::MergeFunc_t GetMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7431; TClass::fResetAfterMergeROOT::ResetAfterMergeFunc_t fResetAfterMergeDefinition TClass.h:234; TClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TClass.h:517; TClass::fInstanceCountUInt_t fInstanceCountDefinition TClass.h:217; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:75861,checksum,checksum,75861,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['checksum'],['checksum']
Security,"ith a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4374; TClass::GetIsAProxyTVirtualIsAProxy * GetIsAProxy() constReturn the proxy implementing the IsA functionality.Definition TClass.cxx:2955; TClass::GetMergeROOT::MergeFunc_t GetMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7431; TClass::fResetAfterMergeROOT::ResetAfterMergeFunc_t fResetAfterMergeDefinition TClass.h:234; TClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TClass.h:517; TClass::fInstanceCountUInt_t fInstanceCountDefinition TClass.h:217; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHasRootPcmInfoC++ Property of the class (is abstract, has virtual table, etc.)Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:340301,checksum,checksum,340301,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['checksum'],['checksum']
Security,"ith a library.Definition TClass.cxx:6912; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:7012; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4154; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4350; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4839; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4441; TClass::GetIsAProxyTVirtualIsAProxy * GetIsAProxy() constReturn the proxy implementing the IsA functionality.Definition TClass.cxx:3022; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetMergeROOT::MergeFunc_t GetMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7498; TClass::fResetAfterMergeROOT::ResetAfterMergeFunc_t fResetAfterMergeDefinition TClass.h:234; TClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TClass.h:517; TClass::fInstanceCountUInt_t fInstanceCountDefinition TClass.h:217; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:75689,checksum,checksum,75689,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['checksum'],['checksum']
Security,"ith a library.Definition TClass.cxx:6912; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:7012; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4154; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4350; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4839; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4441; TClass::GetIsAProxyTVirtualIsAProxy * GetIsAProxy() constReturn the proxy implementing the IsA functionality.Definition TClass.cxx:3022; TClass::GetMergeROOT::MergeFunc_t GetMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7498; TClass::fResetAfterMergeROOT::ResetAfterMergeFunc_t fResetAfterMergeDefinition TClass.h:234; TClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TClass.h:517; TClass::fInstanceCountUInt_t fInstanceCountDefinition TClass.h:217; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHasRootPcmInfoC++ Property of the class (is abstract, has virtual table, etc.)Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:342939,checksum,checksum,342939,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['checksum'],['checksum']
Security,"ith labels taken; from the variables in 'vars' and the with range and binning; specified in xlo,xhi and nBins. The dimensions of the arrays xlo,xhi,; nBins should match the number of objects in vars. TH1 * createHistogram(const char *name, RooArgList &vars, const char *tAxisLabel, const RooAbsBinning** bins); Create a 1,2, or 3D-histogram with appropriate scale and labels.; Binning and ranges are taken from the variables themselves and can be changed by; calling their setPlotMin/Max() and setPlotBins() methods. A histogram can be filled; using RooAbsReal::fillHistogram() or RooTreeData::fillHistogram().; The caller takes ownership of the returned object and is responsible for deleting it. Bool_t isJacobianOK(const RooArgSet& depList) const; Interface function to indicate that this lvalue; has a unit or constant jacobian terms with respect to; the observable passed as argument. This default implementation; always returns true (i.e. jacobian is constant). void setVal(Double_t value); Parameter value and error accessors. RooAbsArg& operator=(const RooAbsReal& other). Int_t getBin(const char* rangeName=0); { return getBinning(rangeName).binNumber(getVal()) ; }. Int_t numBins(const char* rangeName=0); { return getBins(rangeName) ; }. Double_t getBinWidth(Int_t i, const char* rangeName=0); { return getBinning(rangeName).binWidth(i) ; }. Double_t volume(const char* rangeName); { return getMax(rangeName)-getMin(rangeName) ; }. const RooAbsBinning* getBinningPtr(const char* rangeName) const; { return &getBinning(rangeName) ; }. Int_t getBin(const RooAbsBinning* ptr); { return ptr->binNumber(getVal()) ; }. Int_t getBin(const RooAbsBinning& binning); { return binning.binNumber(getVal()) ; }. Int_t numBins(const RooAbsBinning& binning); { return binning.numBins() ; }. Double_t getBinWidth(Int_t i, const RooAbsBinning& binning); { return binning.binWidth(i) ; }. Double_t volume(const RooAbsBinning& binning); { return binning.highBound() - binning.lowBound() ; }. const RooAbsBinn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:46630,access,accessors,46630,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,1,['access'],['accessors']
Security,"ith labels taken; from the variables in 'vars' and the with range and binning; specified in xlo,xhi and nBins. The dimensions of the arrays xlo,xhi,; nBins should match the number of objects in vars. TH1 * createHistogram(const char* name, RooArgList& vars, const char* tAxisLabel, const RooAbsBinning** bins); Create a 1,2, or 3D-histogram with appropriate scale and labels.; Binning and ranges are taken from the variables themselves and can be changed by; calling their setPlotMin/Max() and setPlotBins() methods. A histogram can be filled; using RooAbsReal::fillHistogram() or RooTreeData::fillHistogram().; The caller takes ownership of the returned object and is responsible for deleting it. Bool_t isJacobianOK(const RooArgSet& depList) const; Interface function to indicate that this lvalue; has a unit or constant jacobian terms with respect to; the observable passed as argument. This default implementation; always returns true (i.e. jacobian is constant). void setVal(Double_t value); Parameter value and error accessors. RooAbsArg& operator=(const RooAbsReal& other). Int_t getBin(const char* rangeName = 0) const; { return getBinning(rangeName).binNumber(getVal()) ; }. Int_t numBins(const char* rangeName = 0) const; { return getBins(rangeName) ; }. Double_t getBinWidth(Int_t i, const char* rangeName = 0) const; { return getBinning(rangeName).binWidth(i) ; }. Double_t volume(const char* rangeName) const; { return getMax(rangeName)-getMin(rangeName) ; }. const RooAbsBinning* getBinningPtr(const char* rangeName) const; { return &getBinning(rangeName) ; }. Int_t getBin(const RooAbsBinning* ptr) const; { return ptr->binNumber(getVal()) ; }. Int_t getBin(const RooAbsBinning& binning) const; { return binning.binNumber(getVal()) ; }. Int_t numBins(const RooAbsBinning& binning) const; { return binning.numBins() ; }. Double_t getBinWidth(Int_t i, const RooAbsBinning& binning) const; { return binning.binWidth(i) ; }. Double_t volume(const RooAbsBinning& binning) const; { return bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsRealLValue.html:46925,access,accessors,46925,root/html528/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html528/RooAbsRealLValue.html,4,['access'],['accessors']
Security,"ith the default drawing option (`""""`),; 4047/// a cloud of points is drawn and the histogram `htemp` is not filled. For all the other; 4048/// drawing options `htemp` will be filled.; 4049///; 4050/// In all cases `htemp` can be retrieved by calling:; 4051///; 4052/// ~~~ {.cpp}; 4053/// auto htemp = (TH1F*)gPad->GetPrimitive(""htemp""); // 1D; 4054/// auto htemp = (TH2F*)gPad->GetPrimitive(""htemp""); // 2D; 4055/// auto htemp = (TH3F*)gPad->GetPrimitive(""htemp""); // 3D; 4056/// ~~~; 4057///; 4058/// In the two dimensional case (`Draw(""e1;e2"")`), with the default drawing option, the; 4059/// data is filled into a TGraph named `Graph`. This TGraph can be retrieved by; 4060/// calling; 4061///; 4062/// ~~~ {.cpp}; 4063/// auto graph = (TGraph*)gPad->GetPrimitive(""Graph"");; 4064/// ~~~; 4065///; 4066/// For the three and four dimensional cases, with the default drawing option, an unnamed; 4067/// TPolyMarker3D is produced, and therefore cannot be retrieved.; 4068///; 4069/// In all cases `htemp` can be used to access the axes. For instance in the 2D case:; 4070///; 4071/// ~~~ {.cpp}; 4072/// auto htemp = (TH2F*)gPad->GetPrimitive(""htemp"");; 4073/// auto xaxis = htemp->GetXaxis();; 4074/// ~~~; 4075///; 4076/// When the option `""A""` is used (with TGraph painting option) to draw a 2D; 4077/// distribution:; 4078/// ~~~ {.cpp}; 4079/// tree.Draw(""e1:e2"","""",""A*"");; 4080/// ~~~; 4081/// a scatter plot is produced (with stars in that case) but the axis creation is; 4082/// delegated to TGraph and `htemp` is not created.; 4083///; 4084/// ### Saving the result of Draw to a histogram; 4085///; 4086/// If `varexp` contains `>>hnew` (following the variable(s) name(s)),; 4087/// the new histogram called `hnew` is created and it is kept in the current; 4088/// directory (and also the current pad). This works for all dimensions.; 4089///; 4090/// Example:; 4091/// ~~~ {.cpp}; 4092/// tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); 4093/// ~~~; 4094/// will draw `sqrt(x)` and save the histogram as ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:162635,access,access,162635,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security,"itializationsDefinition MethodDL.cxx:432; TMVA::MethodDL::MethodDLMethodDL(const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption)Constructor.Definition MethodDL.cxx:1019; TMVA::MethodDL::TrainDeepNetvoid TrainDeepNet()train of deep neural network using the defined architectureDefinition MethodDL.cxx:1164; TMVA::MethodDL::GetTrainingSettingsconst std::vector< TTrainingSettings > & GetTrainingSettings() constDefinition MethodDL.h:280; TMVA::MethodDL::GetOutputFunctionDNN::EOutputFunction GetOutputFunction() constDefinition MethodDL.h:269; TMVA::MethodDL::ParseDenseLayervoid ParseDenseLayer(DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate dense layer.Definition MethodDL.cxx:583; TMVA::MethodDL::GetNumValidationSamplesUInt_t GetNumValidationSamples()parce the validation string and return the number of event data used for validation; TMVA::MethodDL::GetBatchLayoutStringTString GetBatchLayoutString() constDefinition MethodDL.h:273; TMVA::MethodDL::SetInputWidthvoid SetInputWidth(int inputWidth)Definition MethodDL.h:288; TMVA::MethodDL::ProcessOptionsvoid ProcessOptions()Definition MethodDL.cxx:219; TMVA::MethodDL::fXInputBufferHostBufferImpl_t fXInputBufferDefinition MethodDL.h:207; TMVA::MethodDL::fBatchWidthsize_t fBatchWidthThe width of the batch used to train the deep net.Definition MethodDL.h:184; TMVA::MethodDL::GetInputDepthsize_t GetInputDepth() constDefinition MethodDL.h:255; TMVA::MethodDL::fNetstd::unique_ptr< DeepNetImpl_t > fNetDefinition MethodDL.h:209; TMVA::MethodDL::GetInputLayoutStringTString GetInputLayoutString() constDefinition MethodDL.h:272; TMVA::MethodDL::SetBatchHeightvoid SetBatchHeight(size_t batchHeight)Definition MethodDL.h:293; TMVA::MethodDL::GetInputHeightsize_t GetInputHeight() constDefinition MethodDL.h:256; TMVA::MethodDL::GetArchitectureStringT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:105829,validat,validation,105829,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,['validat'],['validation']
Security,"itialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent); virtual voidUpdateValueClass(const TClass* oldcl, TClass* newcl). private:. TGenCollectionProxy&operator=(const TGenCollectionProxy&); TGenCollectionProxy(). Data Members; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tfCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tfConstructContainer accessors: block construct; map<string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tfDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tfFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tfFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tfFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tfFunctionDeleteIterator; TVirtualCollectionProxy::DeleteTwoIterators_tfFunctionDeleteTwoIterators; TVirtualCollectionProxy::Next_tfFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenCollectionProxy.html:4333,access,accessors,4333,root/html602/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html,4,['access'],['accessors']
Security,"itializeContext(); voidTObject::MakeZombie(); virtual voidTXMLParser::OnValidateError(const TString& message); virtual voidTXMLParser::OnValidateWarning(const TString& message); virtual voidTXMLParser::ReleaseUnderlying(); virtual voidTXMLParser::SetParseCode(Int_t code). private:. TSAXParser(const TSAXParser&); TSAXParser&operator=(const TSAXParser&); virtual Int_tParse(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTXMLParser::fParseCodeto keep track of the errorcodes; Bool_tTXMLParser::fReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTXMLParser::fStopErrorstop when parse error occurs; Bool_tTXMLParser::fValidateto validate the parse context; TStringTXMLParser::fValidateErrorparse error; TStringTXMLParser::fValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. _xmlSAXHandler*fSAXHandlerlibxml2 SAX handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSAXParser(); Create SAX parser. ~TSAXParser(); TSAXParser desctructor. void OnStartDocument(); Emit a signal for OnStartDocument. void OnEndDocument(); Emit a signal for OnEndDocument. void OnStartElement(const char* name, const TList* attr); Emit a signal for OnStarElement, where name is the Element's name and; attribute is a TList of (TObjString*, TObjString *) TPair's.; The TPair's key is the attribute's name and value is the attribute's; value. void OnEndElement(const char* name); Emit a signal for OnEndE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSAXParser.html:10687,validat,validate,10687,root/html528/TSAXParser.html,https://root.cern,https://root.cern/root/html528/TSAXParser.html,4,['validat'],['validate']
Security,"itializes memory storage for cells and begins exploration process from the root cell. The empty cells are allocated/filled using CellFill. The procedure Grow which loops over cells, picks up the cell with the biggest `‘driver integral’', see Computer Physics Communications 152 152 (2003) 55 for explanations, with the help of PeekMax procedure. The chosen cell is split using Divide. Subsequently, the procedure Explore called by the Divide (and by InitCells for the root cell) does the most important job in the FOAM object build-up: it performs a small MC run for each newly allocated daughter cell. Explore calculates how profitable the future split of the cell will be and defines the optimal cell division geometry with the help of Carver or Varedu procedures, for maximum weight or variance optimization respectively. All essential results of the exploration are written into the explored cell object. At the very end of the foam build-up, Finally, MakeActiveList is invoked to create a list of pointers to all active cells, for the purpose of the quick access during the MC generation. The procedure Explore employs MakeAlpha to generate random coordinates inside a given cell with the uniform distribution. The above sequence of the procedure calls is depicted in the following figure:. Definition at line 307 of file TFoam.cxx. ◆ IsA(). TClass * TFoam::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 143 of file TFoam.h. ◆ LinkCells(). void TFoam::LinkCells ; (; void ; ). virtual . Definition at line 1519 of file TFoam.cxx. ◆ MakeActiveList(). void TFoam::MakeActiveList ; (; ). virtual . Internal method used by Initialize. ; It finds out number of active cells fNoAct, creates list of active cell fCellsAct and primary cumulative fPrimAcu. They are used during the MC generation to choose randomly an active cell. ; Definition at line 965 of file TFoam.cxx. ◆ MakeAlpha(). void TFoam::MakeAlpha ; (; )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoam.html:33614,access,access,33614,doc/master/classTFoam.html,https://root.cern,https://root.cern/doc/master/classTFoam.html,1,['access'],['access']
Security,"ition TClass.cxx:557; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:555; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) overrideRemove object from the hashtable.Definition THashTable.cxx:417; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::ClassInfo_HasMethodvirtual Bool_t ClassInfo_HasMethod(ClassInfo_t *, const char *) constDefinition TInterpreter.h:413; TInterpreter::DataMemberInfo_Namevirtual const char * DataMemberInfo_Name(DataMemberInfo_t *) constDefinition TInterpreter.h:469; TInterpreter::DataMemberInfo_TypeNamevirtual const char * DataMemberInfo_TypeName(DataMemberInfo_t *) constDefinition TInterpreter.h:467; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:349609,hash,hash,349609,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['hash'],['hash']
Security,"ition TClass.cxx:624; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:622; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) overrideRemove object from the hashtable.Definition THashTable.cxx:417; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::ClassInfo_HasMethodvirtual Bool_t ClassInfo_HasMethod(ClassInfo_t *, const char *) constDefinition TInterpreter.h:413; TInterpreter::DataMemberInfo_Namevirtual const char * DataMemberInfo_Name(DataMemberInfo_t *) constDefinition TInterpreter.h:469; TInterpreter::DataMemberInfo_TypeNamevirtual const char * DataMemberInfo_TypeName(DataMemberInfo_t *) constDefinition TInterpreter.h:467; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:352247,hash,hash,352247,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['hash'],['hash']
Security,"ition at line 171 of file FitData.h. ◆ InitFromRange(). template<class Iterator > . void ROOT::Fit::FitData::InitFromRange ; (; Iterator ; dataItr). inlineprotected . Definition at line 190 of file FitData.h. ◆ NDim(). unsigned int ROOT::Fit::FitData::NDim ; (; ); const. inline . return coordinate data dimension ; Definition at line 301 of file FitData.h. ◆ NPoints(). unsigned int ROOT::Fit::FitData::NPoints ; (; ); const. inline . return number of fit points ; Definition at line 285 of file FitData.h. ◆ operator=(). FitData & ROOT::Fit::FitData::operator= ; (; const FitData & ; rhs). Definition at line 218 of file FitData.cxx. ◆ Opt() [1/2]. DataOptions & ROOT::Fit::FitData::Opt ; (; ). inline . Definition at line 313 of file FitData.h. ◆ Opt() [2/2]. const DataOptions & ROOT::Fit::FitData::Opt ; (; ); const. inline . access to options ; Definition at line 309 of file FitData.h. ◆ Range(). const DataRange & ROOT::Fit::FitData::Range ; (; ); const. inline . access to range ; Definition at line 321 of file FitData.h. ◆ Size(). unsigned int ROOT::Fit::FitData::Size ; (; ); const. inline . return number of fit points ; Definition at line 293 of file FitData.h. ◆ UnWrap(). void ROOT::Fit::FitData::UnWrap ; (; ). inlineprotected . Definition at line 336 of file FitData.h. ◆ VectorPadding(). static constexpr unsigned ROOT::Fit::FitData::VectorPadding ; (; const unsigned ; ). inlinestaticconstexprprotected . If VecCore is not defined, there is no vectorization available and the SIMD vector size will always be one. ; Then, as every number is a multiple of SIMD vector size, the padding will always be zero. ; Definition at line 372 of file FitData.h. Member Data Documentation. ◆ fCoords. std::vector< std::vector< double > > ROOT::Fit::FitData::fCoords. private . This vector stores the vectorizable data: The inner vectors contain the coordinates data fCoords[0] is the vector for the x-coords fCoords[1] is the vector for the y-coords etc. ; The vector of pointers stores the poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitData.html:12761,access,access,12761,doc/master/classROOT_1_1Fit_1_1FitData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitData.html,1,['access'],['access']
Security,"itle = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE); Constructor. param url: URL of the entry-point server to be contacted; param mode: initial file access mode; param title: title of the file (shown by ROOT browser); param compress: compression level and algorithm; param netopt: TCP window size in bytes (unused); param parallelopen: open asynchronously. ~TNetXNGFile(); Destructor. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Long64_t GetSize() const; Get the file size. Returns -1 in the case that the file could not be; stat'ed. Bool_t IsOpen() const; Check if the file is open. void SetAsyncOpenStatus(TFile::EAsyncOpenStatus status); Set the status of an asynchronous file open. void Close(Option_t* option = """"); Close the file. param option: if == ""R"", all TProcessIDs referenced by this file are; deleted (is this valid in xrootd context?). Int_t ReOpen(Option_t* modestr); Reopen the file with the new access mode. param mode: the new access mode; returns: 0 in case the mode was successfully modified, 1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGFile.html:23966,access,access,23966,root/html534/TNetXNGFile.html,https://root.cern,https://root.cern/root/html534/TNetXNGFile.html,1,['access'],['access']
Security,"itle and its drawing attributes. More...;  ; class  ROOT::Experimental::RAttrBase;  Base class for all attributes, used with RDrawable. More...;  ; class  ROOT::Experimental::RAttrBorder;  Drawing line attributes for different objects. More...;  ; class  ROOT::Experimental::RAttrFill;  Drawing fill attributes for different objects. More...;  ; class  ROOT::Experimental::RAttrFont;  A font attributes, used together with text attributes. More...;  ; class  ROOT::Experimental::RAttrLine;  Drawing line attributes for different objects. More...;  ; class  ROOT::Experimental::RAttrLineEnding;  Attributes for line ending. More...;  ; class  ROOT::Experimental::RAttrMap;  ; class  ROOT::Experimental::RAttrMargins;  A margins attributes. Only relative and pixel coordinates are allowed. More...;  ; class  ROOT::Experimental::RAttrMarker;  A marker attributes. More...;  ; class  ROOT::Experimental::RAttrText;  A text attributes. More...;  ; class  ROOT::Experimental::RAttrValue< T >;  Template class to access single value from drawable or other attributes. More...;  ; class  ROOT::Experimental::RCanvas;  A window's topmost RPad. More...;  ; class  ROOT::Experimental::RCanvasDisplayItem;  class RCanvasDisplayItem More...;  ; class  ROOT::Experimental::Detail::RCheckedMenuItem;  Menu item with check box. More...;  ; class  ROOT::Experimental::RColor;  The color class. More...;  ; class  ROOT::Experimental::RDisplayItem;  Base class for painting data for JS. More...;  ; class  ROOT::Experimental::RDrawable;  Base class for drawable entities: objects that can be painted on a RPad. More...;  ; class  ROOT::Experimental::RDrawableDisplayItem;  Generic display item for RDrawable, just reference drawable itself. More...;  ; class  ROOT::Experimental::RDrawableExecRequest;  Request execution of method of referenced drawable, no reply. More...;  ; class  ROOT::Experimental::RDrawableMenuRequest;  Request menu items for the drawable object. More...;  ; class  ROOT::Experimental::RDrawabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GpadROOT7.html:1846,access,access,1846,doc/master/group__GpadROOT7.html,https://root.cern,https://root.cern/doc/master/group__GpadROOT7.html,1,['access'],['access']
Security,"itle, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. void initializeMinimizer() const. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. MINIMIZER* minimizer(); { return _minimizer ; }. RooAbsReal& nll(); { return const_cast<RooAbsReal&>(_nll.arg()) ; }. void clearAbsMin(); { _absMinValid = kFALSE ; }. Int_t numEval() const; { return _neval ; }. » Last changed: Tue Jun 2 15:33:08 2015 » Last generated: 2015-06-02 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooProfileLL.html:39544,validat,validateAbsMin,39544,root/html604/RooProfileLL.html,https://root.cern,https://root.cern/root/html604/RooProfileLL.html,1,['validat'],['validateAbsMin']
Security,"itle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealSumPdf.html:41472,validat,validate,41472,root/html602/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html,2,['validat'],['validate']
Security,"its { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBinddnBind name; Bool_tfIsConnectedCurrent connection state; LDAP*fLdLDAP handle of current connection; TStringfPasswordPassword. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLDAPServer(const char* host, Int_t port = LDAP_PORT, const char* binddn = 0, const char* password = 0, Int_t version = LDAP_VERSION2); During construction TLDAPServer object tries to connect to the; specified server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLDAPServer.html:6471,password,password,6471,root/html528/TLDAPServer.html,https://root.cern,https://root.cern/root/html528/TLDAPServer.html,3,['password'],['password']
Security,"itten to disk when it is full. Branches, buffers, and leafs, are explained a little later in this chapter, but for now, it is important to realize that each object is not written individually, but rather collected and written a bunch at a time.; This is where the TTree takes advantage of compression and will produce a much smaller file than if the objects were written individually. Since the unit to be compressed is a buffer, and the TTree contains many same-class objects, the header of the objects can be compressed.; The TTree reduces the header of each object, but it still contains the class name. Using compression, the class name of each same-class object has a good chance of being compressed, since the compression algorithm recognizes the bit pattern representing the class name. Using a TTree and compression the header is reduced to about 4 bytes compared to the original 60 bytes. However, if compression is turned off, you will not see these large savings.; The TTree is also used to optimize the data access. A tree uses a hierarchy of branches, and each branch can be read independently from any other branch. Now, assume that Px and Py are data members of the event, and we would like to compute Px2 + Py2 for every event and histogram the result.; If we had saved the million events without a TTree we would have to:. read each event in its entirety into memory; extract the Px and Py from the event; compute the sum of the squares; fill a histogram. We would have to do that a million times! This is very time consuming, and we really do not need to read the entire event, every time. All we need are two little data members (Px and Py). On the other hand, if we use a tree with one branch containing Px and another branch containing Py, we can read all values of Px and Py by only reading the Px and Py branches. This makes the use of the TTree very attractive.; 12.2 A Simple TTree; This script builds a TTree from an ASCII file containing statistics about the staff at CERN. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:521015,access,access,521015,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ity slots and refills the table. Use AverageCollisions() to check if you need to rehash. ; Definition at line 368 of file THashList.cxx. ◆ Remove() [1/2]. TObject * THashList::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Implements TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 378 of file THashList.cxx. ◆ Remove() [2/2]. TObject * THashList::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from TList.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 391 of file THashList.cxx. ◆ Streamer(). void THashList::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates. ◆ StreamerNVirtual(). void THashList::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 72 of file THashList.h. ◆ UseRWLock(). bool THashList::UseRWLock ; (; Bool_t ; enable = true). overridevirtual . Set this collection to use a RW lock upon access, making it thread safe. ; Return the previous state.; Note: To test whether the usage is enabled do: collection->TestBit(TCollection::kUseRWLock); ; Reimplemented from TCollection.; Definition at line 409 of file THashList.cxx. Member Data Documentation. ◆ fTable. THashTable* THashList::fTable. protected . Definition at line 37 of file THashList.h. Libraries for THashList:. [legend]; The documentation for this class was generated from the following files:; core/cont/inc/THashList.h; core/cont/src/THashList.cxx. THashList. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:48 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:33596,access,access,33596,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['access'],['access']
Security,"ivar, const std::string &name, double val, double step, double, double) override;  set upper/lower limited variable (override if minimizer supports them ) ;  ; bool SetLowerLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double lower) override;  set lower limit variable (override if minimizer supports them ) ;  ; bool SetUpperLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double upper) override;  set upper limit variable (override if minimizer supports them ) ;  ; bool SetVariable (unsigned int ivar, const std::string &name, double val, double step) override;  set free variable ;  ; bool SetVariableLimits (unsigned int ivar, double lower, double upper) override;  set the limits of an already existing variable ;  ; bool SetVariableLowerLimit (unsigned int ivar, double lower) override;  set the lower-limit of an already existing variable ;  ; bool SetVariableStepSize (unsigned int ivar, double step) override;  set the step size of an already existing variable ;  ; bool SetVariableUpperLimit (unsigned int ivar, double upper) override;  set the upper-limit of an already existing variable ;  ; bool SetVariableValue (unsigned int ivar, double val) override;  set the value of an existing variable ;  ; bool SetVariableValues (const double *x) override;  set the values of all existing variables (array must be dimensioned to the size of existing parameters) ;  ; virtual const double * StepSizes () const;  accessor methods ;  ; int VariableIndex (const std::string &name) const override;  get index of variable given a variable given a name return -1 if variable is not found ;  ; std::string VariableName (unsigned int ivar) const override;  get name of variables (override if minimizer support storing of variable names) ;  ; const double * X () const override;  return pointer to X values at the minimum ;  ;  Public Member Functions inherited from ROOT::Math::Minimizer;  Minimizer ();  Default constructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BasicMinimizer.html:3868,access,accessor,3868,doc/master/classROOT_1_1Math_1_1BasicMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BasicMinimizer.html,5,['access'],['accessor']
Security,"ivate; fConvStreamerFuncTClassprivate; fCurrentInfoTClassmutableprivate; fDataTClassprivate; fDeclFileLineTClassprivate; fDeclFileNameTClassprivate; fDeleteTClassprivate; fDeleteArrayTClassprivate; fDestructorTClassprivate; fDirAutoAddTClassprivate; fEnumsTClassprivate; fFuncTemplateTClassprivate; fgClassCountTClassprivatestatic; fgClassTypedefHashTClassprivatestatic; fgDtorOnlyTObjectprivatestatic; fGlobalIsATClassprivate; fgObjectStatTObjectprivatestatic; fHasCustomStreamerMemberTClassprivate; fHasRootPcmInfoTClassprivate; FillBuffer(char *&buffer)TNamedvirtual; fImplFileLineTClassprivate; fImplFileNameTClassprivate; FindClassOrBaseMethodWithId(DeclId_t faddr)TClassprivate; FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constTClass; FindConversionStreamerInfo(const TClass *onfile_cl, UInt_t checksum) constTClass; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; FindStreamerInfo(TObjArray *arr, UInt_t checksum) constTClassprotected; FindStreamerInfo(UInt_t checksum, Bool_t isTransient=kFALSE) constTClass; FindStreamerInfoAbstractEmulated(UInt_t checksum) constTClass; fInstanceCountTClassprivate; fIsATClassprivate; fIsAMethodTClassmutableprivate; fIsOffsetStreamerSetTClassmutableprivate; fIsSyntheticPairTClassprivate; fLastReadInfoTClassmutableprivate; fMergeTClassprivate; fMethodTClassprivate; fNameTNamedprotected; fNewTClassprivate; fNewArrayTClassprivate; fNoInfoOrEmuOrFwdDeclNameRegistryTClassprivatestatic; fObjectVersionRepositoryTClassmutableprivate; fOffsetStreamerTClassmutableprivate; fOnHeapTClassprivate; ForceReload(TClass *oldcl)TClass; fOVRMutexTClassmutableprivate; fPersistentRefTClassprivate; fPropertyTClassmutableprivate; fRealDataTClassprivate; fRefProxyTClassprivate; fResetAfterMergeTClassprivate; fRuntimePropertiesTClassmutableprivate; fSchemaRulesTClassprivate; fSharedLibsTClassprivate; fShowMembersTClassprivate; fSizeofTClassprivate; fStateTClassprivate; fStreamerTClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:5188,checksum,checksum,5188,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['checksum'],['checksum']
Security,"ivatevoid DeActivate()De-activate a system event handler.Definition TSysEvtHandler.cxx:46; TSysEvtHandler::Activatevoid Activate()Activate a system event handler.Definition TSysEvtHandler.cxx:32; TSystemDirectoryDescribes an Operating System directory for the browser.Definition TSystemDirectory.h:32; TSystem::Beepvoid Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)Beep for duration milliseconds with a tone of frequency freq.Definition TSystem.cxx:324; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::ConcatFileNamevirtual char * ConcatFileName(const char *dir, const char *name)Concatenate a directory and a file name. User must delete returned string.Definition TSystem.cxx:1071; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version identifier string.Definition TSystem.cxx:3899; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:43234,access,access,43234,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,2,['access'],['access']
Security,"iven string. ;  ; Int_t XTextWidth (const char *string, Int_t numChars=-1) const;  Return text width in pixels. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFont.html:3490,hash,hash,3490,doc/master/classTGFont.html,https://root.cern,https://root.cern/doc/master/classTGFont.html,1,['hash'],['hash']
Security,"iver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; virtual Bool_t HandleContainerButton (Event_t *ev);  Handle mouse button events in the canvas container. ;  ; virtual Bool_t HandleContainerConfigure (Event_t *ev);  Handle configure (i.e. resize) event. ;  ; virtual Bool_t HandleContainerCrossing (Event_t *ev);  Handle enter/leave events. Only leave is activated at the moment. ;  ; virtual Bool_t HandleContainerDoubleClick (Event_t *ev);  Handle mouse button double click events in the canvas container. ;  ; virtual Bool_t HandleContainerExpose (Event_t *ev);  Handle expose events. ;  ; virtual Bool_t HandleContainerKey (Event_t *ev);  Handle keyboard events in the canvas container. ;  ; virtual Bool_t HandleContainerMotion (Event_t *ev);  Handle mouse motion event in the canvas container. ;  ;  Protected Member Functions inherited from TGFrame; void DoRedraw () override;  Redraw the frame. ;  ; virtual void Draw3dRectangle (UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h);  Draw 3D rectangle on the frame border. ;  ; TString GetOptionString () const;  Returns a frame option string - used in SavePrimitive(). ;  ; const TGResourcePool * GetResourcePool () const;  ; void * GetSender () override;  ; virtual void StartGuiBuilding (Bool_t on=kTRUE);  Go into GUI building mode. ;  ;  Protected Member Functions inherited from TGWindow;  TGWindow (const TGWindow &tgw);  ;  TGWindow (Window_t id);  ; TGWindow & operator= (const TGWindow &tgw);  ;  Protected Member Functions inherited from TGObject; TGObject & operator= (const TGO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootEmbeddedCanvas.html:23932,expose,expose,23932,doc/master/classTRootEmbeddedCanvas.html,https://root.cern,https://root.cern/doc/master/classTRootEmbeddedCanvas.html,1,['expose'],['expose']
Security,"ixIdentity();; double a[9] = {1,2,3,4,5,6,7,8,9}; // input matrix data; // create a matrix using the a[] data; SMatrix33 m(a,9); // this will produce the 3x3 matrix; // ( 1 2 3 ); // ( 4 5 6 ); // ( 7 8 9 ); Example to fill a symmetric matrix from an std::vector:; std::vector<double> v(6);; for (int i = 0; i<6; ++i) v[i] = double(i+1);; SMatrixSym3 s(v.begin(),v.end()) // this will produce the; // symmetric matrix; // ( 1 2 4 ); // ( 2 3 5 ); // ( 4 5 6 ); //create a general matrix from a symmetric matrix (the opposite; // will not compile); SMatrix33 m2 = s;; 13.13.2.2 Accessing and Setting Methods; The matrix elements can be set using the operator()(irow,icol), where irow and icol are the row and column indexes or by using the iterator interface. Notice that the indexes start from zero and not from one as in FORTRAN. Furthermore, all the matrix elements can be set also by using the SetElements function passing a generic iterator. The elements can be accessed by the same methods as well as by using the function ROOT::Math::SMatrix::apply. The apply(i) has exactly the same behavior for general and symmetric matrices; in contrast to the iterator access methods which behave differently (it follows the data order).; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m; double x = m(2,1); // return the element in 3; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices; //(note the difference in behavior between apply and the iterators); x = *(m.begin()+4) // return the element (row=2,col=1); x = m.apply(7); // returns again the (row=2,col=1) element; There are methods to place and/or retrieve ROOT::Math::SVector objects as rows or columns in (from) a matrix. In addition one can put (get) a sub-matrix as another ROOT::Math::SMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:757664,access,accessed,757664,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessed']
Security,"ixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction() const; return pointer to used gradient object function (NULL if gradient is not supported). void PrintResult() const; print result of minimization. const double * StepSizes() const; accessor methods. { return &fSteps.front(); }. bool CheckDimension() const. bool CheckObjFunction() const. MinimTransformFunction * CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0). void SetFinalValues(const double* x). void SetMinValue(double val); { fMinVal = val; }. » Author: L. Moneta Oct 2012 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__BasicMinimizer.html:9814,access,accessor,9814,root/html602/ROOT__Math__BasicMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__BasicMinimizer.html,1,['access'],['accessor']
Security,"ixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction() const; return pointer to used gradient object function (NULL if gradient is not supported). void PrintResult() const; print result of minimization. const double * StepSizes() const; accessor methods. { return &fSteps.front(); }. bool CheckDimension() const. bool CheckObjFunction() const. MinimTransformFunction * CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0). void SetFinalValues(const double* x). void SetMinValue(double val); { fMinVal = val; }. » Author: L. Moneta Oct 2012 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:9768,access,accessor,9768,root/html534/ROOT__Math__BasicMinimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html,1,['access'],['accessor']
Security,"ixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction() const; return pointer to used gradient object function (NULL if gradient is not supported). void PrintResult() const; print result of minimization. const double * StepSizes() const; accessor methods. { return &fSteps.front(); }. bool CheckDimension() const. bool CheckObjFunction() const. MinimTransformFunction * CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0). void SetFinalValues(const double* x). void SetMinValue(double val); { fMinVal = val; }. » Author: L. Moneta Oct 2012 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__BasicMinimizer.html:9814,access,accessor,9814,root/html604/ROOT__Math__BasicMinimizer.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__BasicMinimizer.html,1,['access'],['accessor']
Security,"ize = 0) const. protected:. virtual voidAdd(TObject* arg, Int_t refCount); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidswapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0); Constructor with hashing threshold. If collection size exceeds threshold; a hash table is added. RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooLinkedList.html:6426,hash,hashing,6426,root/html528/RooLinkedList.html,https://root.cern,https://root.cern/root/html528/RooLinkedList.html,1,['hash'],['hashing']
Security,"ize = 0) const. protected:. virtual voidAdd(TObject* arg, Int_t refCount); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidswapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0); Constructor with hashing threshold. If collection size exceeds threshold; a hash table is added.; if (htsize>0) {; cout << ""RooLinkedList::ctor htsize="" << htsize << endl ;; }. RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooLinkedList.html:6495,hash,hashing,6495,root/html530/RooLinkedList.html,https://root.cern,https://root.cern/root/html530/RooLinkedList.html,1,['hash'],['hashing']
Security,"ize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Int_tFindElement(ULong64_t hash, Long64_t key); voidFixCollisions(Int_t index); Bool_tHighWaterMark(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(UL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TExMap.html:6166,hash,hash,6166,root/html528/TExMap.html,https://root.cern,https://root.cern/root/html528/TExMap.html,4,['hash'],['hash']
Security,"ize of the array,; otherwise return 0.; The leaf referred to by nelem **MUST** be an int (/I),; If leaf name has the form var[nelem], where nelem is a non-negative integers, then; it is used as the fixed size of the array.; If leaf name has the form of a multi dimension array (e.g. var[nelem][nelem2]); where nelem and nelem2 are non-negative integers) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. TBranch(TBranch* parent, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of another Branch. See documentation for; TBranch::TBranch(TTree *, const char *, void *, const char *, Int_t, Int_t). void Init(const char* name, const char* leaflist, Int_t compress); Initialization routine called from the constructor. This should NOT be made virtual. ~TBranch(); Destructor. void AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); Add the basket to this branch. void AddLastBasket(Long64_t startEntry); Add the start entry of the write basket (not yet created). void Browse(TBrowser* b); Browser interface. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranch.html:15067,access,access,15067,root/html532/TBranch.html,https://root.cern,https://root.cern/root/html532/TBranch.html,4,['access'],['access']
Security,"ize. Increasing the default has the benefit that when reading many small objects the map does not need to be resized too often (the system is always dynamic, even with the default everything will work, only the initial resizing will cost some time). This method can only be called directly after the creation of the TBuffer, before any reading is done. Globally this option can be changed using SetGlobalReadParam(). ; Implements TBuffer.; Definition at line 97 of file TBufferIO.cxx. ◆ SetWriteParam(). void TBufferIO::SetWriteParam ; (; Int_t ; mapsize). overridevirtual . Set the initial size of the hashtable used to store object and class references during writing. ; The default size is TBufferFile::kMapSize. Increasing the default has the benefit that when writing many small objects the hashtable does not get too many collisions (the system is always dynamic, even with the default everything will work, only a large number of collisions will cost performance). For optimal performance hashsize should always be a prime. This method can only be called directly after the creation of the TBuffer, before any writing is done. Globally this option can be changed using SetGlobalWriteParam(). ; Implements TBuffer.; Definition at line 117 of file TBufferIO.cxx. ◆ Streamer(). void TBufferIO::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TBuffer.; Reimplemented in TBufferJSON, TBufferText, TBufferSQL2, TBufferXML, TMessage, and TBufferSQL. ◆ StreamerNVirtual(). void TBufferIO::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 120 of file TBufferIO.h. ◆ TagStreamerInfo(). void TBufferIO::TagStreamerInfo ; (; TVirtualStreamerInfo * ; info). overridevirtual . Mark the classindex of the current file as using this TStreamerInfo. ; Implements TBuffer.; Reimplemented in TMessage.; Definition at line 350 of file TBufferIO.cxx. ◆ Void_Hash(). static R__ALWAYS_INLINE ULong_t TBufferIO::Void_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:40822,hash,hashsize,40822,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['hash'],['hashsize']
Security,"izing object to/from xml. More...;  ; class  TCollectionClassStreamer;  Class streamer object to implement TClassStreamer functionality for I/O emulation. More...;  ; class  TCollectionMemberStreamer;  Class streamer object to implement TMemberStreamer functionality for I/O emulation. More...;  ; class  TCollectionStreamer;  Class streamer object to implement TClassStreamer functionality for I/O emulation. More...;  ; class  TStreamerInfoActions::TConfiguration;  Base class of the Configurations. More...;  ; class  TConvertClonesArrayToProxy;  Small helper to read a TBuffer containing a TClonesArray into any valid collection. More...;  ; class  TDCacheFile;  A TDCacheFile is like a normal TFile except that it may read and write its data via a dCache server (for more on the dCache daemon see http://www-dcache.desy.de/. More...;  ; class  TDirectoryFile;  A ROOT file is structured in Directories (like a file system). More...;  ; class  TDomParser;  DOM stands for the Document Object Model; this is an API for accessing XML or HTML structured documents. More...;  ; class  TEmulatedCollectionProxy;  Streamer around an arbitrary STL like container, which implements basic container functionality. More...;  ; class  TEmulatedMapProxy;  Streamer around a map container. More...;  ; class  TFile;  A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies. More...;  ; class  TFileCacheRead;  A cache when reading files over the network. More...;  ; class  TFileCacheWrite;  A cache when writing files over the network. More...;  ; class  TFileMerger;  This class provides file copy and merging services. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  ; class  TFilePrefetch;  The prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries. More...;  ; class  TFPBlock;  This cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__IO.html:3221,access,accessing,3221,doc/master/group__IO.html,https://root.cern,https://root.cern/doc/master/group__IO.html,1,['access'],['accessing']
Security,"j) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:4461,hash,hash,4461,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['hash'],['hash']
Security,"ject * RooAbsCollection::create ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ DeclFileName(). static const char * RooAbsCollection::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 432 of file RooAbsCollection.h. ◆ defaultPrintContents(). Int_t RooAbsCollection::defaultPrintContents ; (; Option_t * ; opt); const. overridevirtual . Define default RooPrinable print options for given Print() flag string For inline printing only show value of objects, for default print show name,class name value and extras of each object. ; In verbose mode also add object address, argument and title ; Reimplemented from RooPrintable.; Definition at line 1199 of file RooAbsCollection.cxx. ◆ deleteList(). void RooAbsCollection::deleteList ; (; ). protected . Delete contents of the list. ; The RooAbsArg destructor ensures clients and servers can be deleted in any order. Also cleans the hash-map for fast lookups if present. ; Definition at line 194 of file RooAbsCollection.cxx. ◆ dump(). void RooAbsCollection::dump ; (; ); const. Base contents dumper for debugging purposes. ; Definition at line 1278 of file RooAbsCollection.cxx. ◆ empty(). bool RooAbsCollection::empty ; (; ); const. inline . Definition at line 273 of file RooAbsCollection.h. ◆ end(). const_iterator RooAbsCollection::end ; (; ); const. inline . Definition at line 257 of file RooAbsCollection.h. ◆ equals(). bool RooAbsCollection::equals ; (; const RooAbsCollection & ; otherColl); const. Check if this and other collection have identically-named contents. ; Definition at line 887 of file RooAbsCollection.cxx. ◆ find() [1/2]. RooAbsArg * RooAbsCollection::find ; (; const char * ; name); const. Find object with given name in list. ; A null pointer is returned if no object with the given name is found. ; Definition at line 922 of file RooAbsCollection.cxx. ◆ find() [2/2]. RooAbsArg * RooAbsCollection::find ; (; const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:38801,hash,hash-map,38801,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['hash'],['hash-map']
Security,"ject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Unload ();  Mark 'all func' as being unloaded. ;  ; void Unload (TFunctionTemplate *func);  Mark 'func' as being unloaded. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:4024,hash,hash,4024,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,1,['hash'],['hash']
Security,"ject before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLast() const. Int_t IndexOf(const TObject* obj) const. Int_t GetSize() const. TListOfEnumsWithLock(const TListOfEnumsWithLock& ). TListOfEnumsWithLock& operator=(const TListOfEnumsWithLock& ). » Author: Bianca-Cristina Cristescu February 2014 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfEnumsWithLock.html:13570,hash,hash,13570,root/html604/TListOfEnumsWithLock.html,https://root.cern,https://root.cern/root/html604/TListOfEnumsWithLock.html,1,['hash'],['hash']
Security,"ject before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLast() const. Int_t IndexOf(const TObject* obj) const. Int_t GetSize() const. TListOfEnumsWithLock(const TListOfEnumsWithLock& ). TListOfEnumsWithLock& operator=(const TListOfEnumsWithLock& ). » Author: Bianca-Cristina Cristescu February 2014 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-30 15:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnumsWithLock.html:13511,hash,hash,13511,root/html602/TListOfEnumsWithLock.html,https://root.cern,https://root.cern/root/html602/TListOfEnumsWithLock.html,1,['hash'],['hash']
Security,"ject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:3434,checksum,checksum,3434,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['checksum'],['checksum']
Security,"ject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static RooNameReg::(anonymous)kRenamedArg; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooHashTable_htableRepository of registered names; static RooNameReg*_instance; RooLinkedList_list; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNameReg(Int_t hashSize = 31); {}. ~RooNameReg(); Destructor. RooNameReg(const RooNameReg& other); Copy constructor. RooNameReg& instance(); Return reference to singleton instance. void cleanup(); Cleanup function called by atexit() handler installed by RooSentinel; to delete global objects on heap at end of program. const TNamed* constPtr(const char* stringPtr); Return a unique TNamed pointer for given C++ string. const char* constStr(const TNamed* namePtr); Return C++ string corresponding to given TNamed pointer. const TNamed* ptr(const char* stringPtr); Return a unique TNamed pointer for given C++ string. const char* str(const TNamed* ptr); Return C++ string corresponding to given TNamed pointer. const TNamed* known(const char* stringPtr); If the name is already known, return its TNamed pointer. Otherwise return 0 (don't register the name). » Last changed: Sat Jun 20 17:30:21 2015 » Last generated: 2015-06-20 17:30; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooNameReg.html:6685,hash,hashSize,6685,root/html604/RooNameReg.html,https://root.cern,https://root.cern/root/html604/RooNameReg.html,1,['hash'],['hashSize']
Security,"ject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static RooNameReg::(anonymous)kRenamedArg; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooHashTable_htableRepository of registered names; static RooNameReg*_instance; RooLinkedList_list; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNameReg(Int_t hashSize = 31); {}. ~RooNameReg(); Destructor. RooNameReg(const RooNameReg& other); Copy constructor. RooNameReg& instance(); Return reference to singleton instance. void cleanup(); Cleanup function called by atexit() handler installed by RooSentinel; to delete global objects on heap at end of program. const TNamed* constPtr(const char* stringPtr); Return a unique TNamed pointer for given C++ string. const char* constStr(const TNamed* namePtr); Return C++ string corresponding to given TNamed pointer. const TNamed* ptr(const char* stringPtr); Return a unique TNamed pointer for given C++ string. const char* str(const TNamed* ptr); Return C++ string corresponding to given TNamed pointer. const TNamed* known(const char* stringPtr); If the name is already known, return its TNamed pointer. Otherwise return 0 (don't register the name). » Last changed: Tue Jun 30 14:34:22 2015 » Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNameReg.html:6685,hash,hashSize,6685,root/html602/RooNameReg.html,https://root.cern,https://root.cern/root/html602/RooNameReg.html,1,['hash'],['hashSize']
Security,"ject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooLinkedList**_arr! Array of linked lists storing elements in each slot; Int_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name) const; Return the object with given name from the table. RooAbsArg* findArg(const RooAbsArg* arg) const. TObject* find(const TObject* arg) const; Return object with the given pointer from the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHashTable.html:6974,hash,hashMethod,6974,root/html602/RooHashTable.html,https://root.cern,https://root.cern/root/html602/RooHashTable.html,6,['hash'],"['hash', 'hashMethod']"
Security,"ject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooLinkedListElem*RooLinkedList::_first! Link to first element of list; Int_tRooLinkedList::_hashThreshSize threshold for hashing; RooHashTable*RooLinkedList::_htableLink! Hash table by link pointer; RooHashTable*RooLinkedList::_htableName! Hash table by name; RooLinkedListElem*RooLinkedList::_last! Link to last element of list; TStringRooLinkedList::_name; Int_tRooLinkedList::_sizeCurrent size of list; Bool_tRooLinkedList::_useNptr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRefCountList(); Default constructor construct lists with initial hash table size of 17. void Add(TObject* obj, Int_t count); Add object to list with given reference count increment; List takes ownership of object. Bool_t Remove(TObject* obj); Remove object from list and if reference count; reaches zero delete object itself as well. Bool_t RemoveAll(TObject* obj); Remove object from list and delete object itself; regardless of reference count. Int_t refCount(TObject* obj); Return reference count associated with 'obj'. RooRefCountList(). virtual ~RooRefCountList(); {}. void Add(TObject* arg); { Add(arg,1) ; }. » Last changed: Tue Jun 30 14:35:31 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRefCountList.html:7723,hash,hash,7723,root/html602/RooRefCountList.html,https://root.cern,https://root.cern/root/html602/RooRefCountList.html,1,['hash'],['hash']
Security,"ject> and then remove the tag with git tag -d <tag>.; Back in your working directory, tag correctly and then push tags.; Now, you must alert all your developers that, if they have pulled the erroneous tag to their local repository, they will need to remove the tag from their local repository with git -d <tag> and then re-pull from the repository. Otherwise, deleted tags will keep re-appearing in the remote repository and/or users will be unable to pull or push to the remote. Undo the last commit:. Undo the commit:; git reset --soft HEAD^. Do stuff.; Recommit:; git commit -a -m <message> -c ORIG_HEAD. Note that the -c ORIG_HEAD clause causes git to use the meta-data from the previous HEAD (author, etc) with the exception of the commit message. Changing the -c to -C and omitting the -m option will cause git to reuse the commit message too. Recover deleted (committed files). Get a list of all commits with deleted files:; git log --diff-filter=D --summary | less. Find your file and note the SHA1 hash for that commit.; Recover it:; git checkout <commit>^ -- file. Stage selected changes within a file. git add --patch ; Follow the on-screen directions. Tig: a simple and colored text-mode interface for Git; Tig is a command line tool that wraps many Git browse operations (like log, diff, show, status) in a colored text-mode interface based on ncurses. Tig has been written by Jonas Fonseca.; See the full Tig manual for a detailed description.; Obtaining Tig; Tig is available as package from many Linux distributions. On Debian/Ubuntu it is available with the package name tig from the default repositories.; On RHEL-based systems it is available from the additional repository RepoForge.; On OS X it is easily installed via Homebrew:; brew install tig. Tig pager mode; Many git commands can be piped into tig. When tig is invoked this way, it is in pager mode: output will be colored according to the input format, and colored.; For instance it is possible to pipe the differences of o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:15857,hash,hash,15857,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['hash'],['hash']
Security,"jects in this collection.Definition TCollection.cxx:417; TIterDefinition TCollection.h:235; TIter::BeginTIter & Begin()Pointing to the first element of the container.Definition TCollection.cxx:804; TIter::GetCollectionconst TCollection * GetCollection() constDefinition TCollection.h:252; TIter::TIterTIter()Definition TCollection.h:241; TIter::Endstatic TIter End()Pointing to the element after the last - to a nullptr value in our case.Definition TCollection.cxx:814; TIter::operator=TIter & operator=(const TIter &rhs)Assigning an TIter to another.Definition TCollection.cxx:789; TIter::fIteratorTIterator * fIteratorDefinition TCollection.h:238; TIteratorIterator abstract base class.Definition TIterator.h:30; TIterator::Resetvirtual void Reset()=0; TIterator::Nextvirtual TObject * Next()=0; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectTableThis class registers all instances of TObject and its derived classes in a hash table.Definition TObjectTable.h:35; TObjectTable::Addvoid Add(TObject *obj)Add an object to the object table.Definition TObjectTable.cxx:147; TObjectTable::Deletevoid Delete(Option_t *opt="""") overrideDelete all objects stored in the TObjectTable.Definition TObjectTable.cxx:195; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Notifyvirtual Bool_t Notify()This method must be overridden to handle object notification (the base implementation is no-op).Definition TObject.cxx:599; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::kSingleKey@ kSingleKeywrite collection with single keyDefinition TObject.h:91; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::Browsevirtual void Browse(TBrowser *b)Browse object. May be overridden for an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:36666,hash,hash,36666,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['hash'],['hash']
Security,jects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is acti,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataWeightedAverage.html:36863,access,access,36863,root/html534/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html534/RooDataWeightedAverage.html,1,['access'],['access']
Security,"k must be thread-safe); the callable must take an extra unsigned int parameter corresponding to a multi-thread ""processing slot"": this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the callback concurrently but always with different slot numbers.; a value of 0 for everyNEvents indicates the callback must be executed once per slot. For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; std::string progress;; std::mutex bar_mutex;; c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; std::lock_guard<std::mutex> lg(bar_mutex);; progress.push_back('#');; std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; });; std::cout << ""Analysis running..."" << std::endl;; *c; // trigger the event loop by accessing an action's result; std::cout << ""\nDone!"" << std::endl;; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70. Definition at line 364 of file RResultPtr.hxx. ◆ operator bool(). template<typename T > . ROOT::RDF::RResultPtr< T >::operator bool ; (; ); const. inlineexplicit . Definition at line 214 of file RResultPtr.hxx. ◆ operator*(). template<typename T > . T & ROOT::RDF::RResultPtr< T >::operator* ; (; ). inline . Get a pointer to the encapsulated object. ; Triggers event loop and execution of all actions booked in the associated RLoopManager. ; Definition at line 240 of file RResultPtr.hxx. ◆ operator->(). template<typename T > . T * ROOT::RDF::RResultPtr< T >::operator-> ; (; ). inline . Get a pointer to the encapsulated object. ; Ownership is not transferred to the caller. Triggers event loop and execution of all actions booked in the associated RLoopManager. ; Definition at line 249 of file RResultPtr.hxx. ◆ operator=() [1/2]. template<typename T > . RResultPtr & ROOT::RDF::RResultPtr< T >::opera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:13687,access,accessing,13687,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,1,['access'],['accessing']
Security,"k on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws"", 'rdfsampleinfo_.GetD(""sumws"")'); df = df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); ; # We must further apply an MC correction for the ZZ decay due to missing gg->ZZ processes.; ROOT.gInterpreter.Declare(; """"""; float scale(unsigned int slot, const ROOT::RDF::RSampleInfo &id){; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }; """"""; ); ; df = df.DefinePerSample(""scale"", ""scale(rdfslot_, rdfsampleinfo_)""); ; # Select events for the analysis; ROOT.gInterpreter.Declare(; """"""; using ROOT::RVecF;; using ROOT::RVecI;; bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e, const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0); {; for (size_t i = 0; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:1762,access,accessible,1762,doc/master/df106__HiggsToFourLeptons_8py.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html,1,['access'],['accessible']
Security,"k reading. If one thread holds the lock for writing, or is waiting to acquire the lock for writing, other threads must wait to acquire the lock for either reading or writing.; Use a condition variable in conjunction with a mutex lock to automatically block threads until a particular condition is true.; Multithread Safe Levels - a possible classification scheme to describe thread-safety of libraries:. All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data used within a library. The developer must explicitly lock access to objects shared between threads. No other thread can write to a locked object unless it is unlocked. The developer needs to lock local objects. The spirit, if not the letter of this definition, requires the user of the library only to be familiar with the semantic content of the objects in use. Locking access to objects that are being shared due to extra-semantic details of implementation (for example, copy-on-write) should remain the responsibility of the library.; All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data used within the library. The preferred way of providing this protection is to use mutex locks. The library also locks an object before writing to it. The developer is not required to explicitly lock or unlock a class object (static, global or local) to perform a single operation on the object. Note that even multithread safe level II hardly relieves the user of the library from the burden of locking. A thread suffers from deadlock if it is blocked waiting for a condition that will never occur. Typically, this occurs when one thread needs to access a resource that is already locked by another thread, and that other thread is trying to access a resource that has already been locked by the first thread. In this situation, neither thread is able to progress;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1123630,access,access,1123630,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. _xmlParserCtxt*fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfParseCodeto keep track of the errorcodes; Bool_tfReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfStopErrorstop when parse error occurs; Bool_tfValidateto validate the parse context; TStringfValidateErrorparse error; TStringfValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TXMLParser. ←. TDOMParser. TSAXParser. Function documentation; TXMLParser(); Initializes parser variables. ~TXMLParser(); Cleanup. void SetValidate(Bool_t val = kTRUE); The parser will validate the xml file if val = true. void SetReplaceEntities(Bool_t val = kTRUE); The parser will replace/expand entities. void ReleaseUnderlying(); To release any existing document. void OnValidateError(const TString& message); This function is called when an error from the parser has occured.; Message is the parse error. void OnValidateWarning(const TString& message); This function is called when a warning from the parser has occured.; Message is the parse e,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLParser.html:10497,validat,validate,10497,root/html602/TXMLParser.html,https://root.cern,https://root.cern/root/html602/TXMLParser.html,2,['validat'],['validate']
Security,"kClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::IntegrationOneDim::TypeTypeenumeration specifying the integration types.Definition AllIntegrationTypes.h:32; nconst Int_t nDefinition legend1.C:16; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; clangDefinition BaseSelectionRule.h:29; llvmDefinition TString.h:847; ROOT::TVirtualRWMutex::StateDeltaState as returned by GetStateDelta() that can be passed to Restore()Definition TVirtualR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:93785,access,accessing,93785,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['access'],['accessing']
Security,"kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::IsUsingRWLockR__ALWAYS_INLINE Bool_t IsUsingRWLock() constDefinition TCollection.h:212; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectory::TContext::fDirectoryWaitstd::atomic< bool > fDirectoryWaitSet to true during the destructor execution.Definition TDirectory.h:93; TDirectory::TContext::RegisterCurrentDirectoryvoid RegisterCurrentDirectory()Definition TDirectory.cxx:1344; TDirectory::TContext::CdNullvoid CdNull()Set the current directory to null.Definition TDirectory.cxx:133; TDirectory::TContext::~TContext~TContext()Destructor.Definition TDirectory.cxx:143; TDirectory::TContext::fPreviousTContext * fPreviousSet to true if a TDirectory might still access this object.Definition TDirectory.h:94; TDirectory::TContext::fNextTContext * fNextPointer to the next TContext in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:57636,access,access,57636,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['access'],['access']
Security,"kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TRadialGradient ();  ; const Point & GetCenter () const;  Get center. ;  ; const Point & GetEnd () const;  Get end. ;  ; EGradientType GetGradientType () const;  Get gradient type. ;  ; Double_t GetR1 () const;  ; Double_t GetR2 () const;  Get R2. ;  ; Double_t GetRadius () const;  Get radius. ;  ; const Point & GetStart () const;  Get start. ;  ; TClass * IsA () const override;  ; void SetRadialGradient (const Point &center, Double_t radius);  Set radial gradient. ;  ; void SetStartEndR1R2 (const Point &p1, Double_t r1, const Point &p2, Double_t r2);  Set start and end R1 and R2. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  TColorGradient ();  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Color_t *colorIndices, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Double_t *colors, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  Public Member Functions inherited from TColorGradient;  TColorGradient ();  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Color_t *colorIndices, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Double_t *colors, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ; Double_t GetColorAlpha (UIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRadialGradient.html:2168,validat,validate,2168,doc/master/classTRadialGradient.html,https://root.cern,https://root.cern/doc/master/classTRadialGradient.html,1,['validat'],['validate']
Security,"kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:22323,access,access,22323,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,1,['access'],['access']
Security,"kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; static RooCategorySharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:22504,access,access,22504,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,1,['access'],['access']
Security,"kROOTD; static TSocket::EInterestTSocket::kRead; static TSocket::EServiceTypeTSocket::kSOCKD; static TObject::(anonymous)TObject::kSingleKey; static TXSocket::EUrgentMsgTypeTXSocket::kStopProcess; static TSocket::EInterestTSocket::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TInetAddressTSocket::fAddressremote internet address and port #; TBitsTSocket::fBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tTSocket::fBytesRecvtotal bytes received over this socket; UInt_tTSocket::fBytesSenttotal bytes sent using this socket; Int_tTSocket::fCompressCompression level and algorithm; TTimeStampTSocket::fLastUsageTime stamp of last usage; TVirtualMutex*TSocket::fLastUsageMtxProtect last usage setting / reading; TInetAddressTSocket::fLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tTSocket::fRemoteProtocolprotocol of remote daemon; TSecContext*TSocket::fSecContextafter a successful Authenticate call; TSocket::EServiceTypeTSocket::fServTyperemote service type; TStringTSocket::fServicename of service (matches remote port #); Int_tTSocket::fSocketsocket descriptor; Int_tTSocket::fTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. list<Int_t>fClientIDs. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSocket. XrdClientAbsUnsolMsgHandler. ←; TXSocket. ←; TXUnixSocket. Function documentation; TXUnixSocket(const char* u, Int_t psid = -1, Char_t ver = -1, TXHandler* handler = 0, int fd = -1); Constructor. Int_t Reconnect(); Try reconnection after failure",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXUnixSocket.html:11686,authenticat,authentication,11686,root/html602/TXUnixSocket.html,https://root.cern,https://root.cern/root/html602/TXUnixSocket.html,2,['authenticat'],['authentication']
Security,"kROOTFiles; , kROOTFilesMT; , kNoFiles; , kNoFilesMT; , ;   kDataSource; , kDataSourceMT. };  . Private Member Functions; void CleanUpNodes ();  Perform clean-up operations. To be called at the end of each event loop. ;  ; void CleanUpTask (TTreeReader *r, unsigned int slot);  Perform clean-up operations. To be called at the end of each task execution. ;  ; void EvalChildrenCounts ();  Trigger counting of number of children nodes for each node of the functional graph. ;  ; void InitNodes ();  Initialize all nodes of the functional graph before running the event loop. ;  ; void InitNodeSlots (TTreeReader *r, unsigned int slot);  Build TTreeReaderValues for all nodes This method loops over all filters, actions and other booked objects and calls their InitSlot method, to get them ready for running a task. ;  ; void RunAndCheckFilters (unsigned int slot, Long64_t entry);  Execute actions and make sure named filters are called for each event. ;  ; void RunDataSource ();  Run event loop over data accessed through a DataSource, in sequence. ;  ; void RunDataSourceMT ();  Run event loop over data accessed through a DataSource, in parallel. ;  ; void RunEmptySource ();  Run event loop with no source files, in sequence. ;  ; void RunEmptySourceMT ();  Run event loop with no source files, in parallel. ;  ; void RunTreeProcessorMT ();  Run event loop over one or multiple ROOT files, in parallel. ;  ; void RunTreeReader ();  Run event loop over one or multiple ROOT files, in sequence. ;  ; void SetupSampleCallbacks (TTreeReader *r, unsigned int slot);  ; void UpdateSampleInfo (unsigned int slot, const std::pair< ULong64_t, ULong64_t > &range);  ; void UpdateSampleInfo (unsigned int slot, TTreeReader &r);  . Private Attributes; Long64_t fBeginEntry {0};  ; std::vector< RDFInternal::RActionBase * > fBookedActions;  Non-owning pointers to actions to be run. ;  ; std::vector< RDefineBase * > fBookedDefines;  ; std::vector< RFilterBase * > fBookedFilters;  ; std::vector< RFilterBase ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:6656,access,accessed,6656,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['access'],['accessed']
Security,"kRed);; 622 //add it to the list of functions; 623 //use add first because the parameters of the last function will be displayed; 624 pEff->GetListOfFunctions()->AddFirst(f2);; 625 ; 626 pEff->Draw(""AP"");; 627}; 628End_Macro; 629 ; 630\anchor EFF063; 631### VI.3 Draw a TEfficiency object; 632A TEfficiency object can be drawn by calling the usual TEfficiency::Draw method.; 633At the moment drawing is only supported for 1- and 2-dimensional TEfficiency objects.; 634In the 1-dimensional case, you can use the same options as for the TGraphAsymmErrors::Draw; 635method. For 2-dimensional TEfficiency objects, you can pass the same options as; 636for a TH2::Draw object.; 637 ; 638\anchor EFF064; 639### VI.4 TEfficiency object's axis customisation; 640The axes of a TEfficiency object can be accessed and customised by calling the; 641GetPaintedGraph method and then GetXaxis() or GetYaxis() and the corresponding TAxis; 642methods.; 643Note that in order to access the painted graph via GetPaintedGraph(), one should either; 644call Paint or, better, gPad->Update().; 645 ; 646Begin_Macro(source); 647{; 648 //canvas only needed for this documentation; 649 TCanvas* c1 = new TCanvas(""example"","""",600,400);; 650 c1->SetFillStyle(1001);; 651 c1->SetFillColor(kWhite);; 652 c1->Divide(2,1);; 653 ; 654 //create one-dimensional TEfficiency object with fixed bin size; 655 TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; 656 TRandom3 rand3;; 657 ; 658 bool bPassed;; 659 double x;; 660 for(int i=0; i<10000; ++i); 661 {; 662 //simulate events with variable under investigation; 663 x = rand3.Uniform(10);; 664 //check selection: bPassed = DoesEventPassSelection(x); 665 bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; 666 pEff->Fill(bPassed,x);; 667 }; 668 c1->cd(1);; 669 pEff->Draw(""AP"");; 670 c1->cd(2);; 671 pEff->Draw(""AP"");; 672 gPad->Update();; 673 pEff->GetPaintedGraph()->GetXaxis()->SetTitleSize(0.05);; 674 pEff->GetPaintedGraph()->GetXaxis()->SetLabelFont(42);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:28566,access,access,28566,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['access'],['access']
Security,"kReflexNoComment enum valueTClass; kReservedLoading enum valueTClass; kSet enum valueTDictionary; kSingleKey enum valueTObject; kStartWithTObject enum valueTClass; kTObject enum valueTClassprivate; kUnloaded enum valueTClass; kUnloading enum valueTClassprivate; kUnorderedMap enum valueTDictionary; kUnorderedMultimap enum valueTDictionary; kUnorderedMultiset enum valueTDictionary; kUnorderedSet enum valueTDictionary; kVector enum valueTDictionary; kWarned enum valueTClass; kWithTypeDef enum valueTClass; kWriteDelete enum valueTObject; kZombie enum valueTObject; Load(TBuffer &b)TClassstatic; LoadClass(const char *requestedname, Bool_t silent)TClassstatic; LoadClassCustom(const char *requestedname, Bool_t silent)TClassprivatestatic; LoadClassDefault(const char *requestedname, Bool_t silent)TClassprivatestatic; LoadClassInfo() constTClassprivate; ls(Option_t *opt="""") const overrideTClassvirtual; MakeCustomMenuList()TClass; MakeZombie()TObjectinlineprotected; MatchLegacyCheckSum(UInt_t checksum) constTClass; MayNotUse(const char *method) constTObject; Move(void *arenaFrom, void *arenaTo) constTClass; MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constTClassprivate; New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constTClass; New(void *arena, ENewType defConstructor=kClassNew) constTClass; NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constTClass; NewArray(Long_t nElements, void *arena, ENewType defConstructor=kClassNew) constTClass; NewObject(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constTClass; NewObject(void *arena, ENewType defConstructor=kClassNew) constTClass; NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constTClass; NewObjectArray(Long_t nElements, void *arena, ENewType defConstructor=kClassNew) constTClass; Notify()TObjectvirtual; Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constTObject; operator delete(void *ptr)TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:16015,checksum,checksum,16015,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['checksum'],['checksum']
Security,"kStandard; kVerbose; kTreeStructure; };. protected:. map<Int_t,std::pair<const RooArgSet*,const RooArgSet*> >_anaIntMap! Map for analytical integration codes; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedReal.html:32184,validat,validate,32184,root/html532/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedReal.html,2,"['access', 'validat']","['access', 'validate']"
Security,"kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; static TCollection::(anonymous)TCollection::kIsOwner; static TMap::(anonymous)kIsOwnerValue. private:. THashTable*fTableHash table used to store TPair's. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); TMap ctor. See THashTable for a description of the arguments. ~TMap(); TMap dtor. Objects are not deleted unless the TMap is the; owner (set via SetOwner()). void Add(TObject* obj); This function may not be used (but we need to provide it since it is; a pure virtual in TCollection). Use Add(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMap.html:9570,hash,hashtable,9570,root/html602/TMap.html,https://root.cern,https://root.cern/root/html602/TMap.html,2,['hash'],['hashtable']
Security,"kWriteDelete; };. private:. Int_tfRSAKeyType of RSA key used. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object.; User and host from url = user@host . ~TRootSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If globus, cleanup local stuff; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1). Int_t GetRSAKey() const; { return fRSAKey; }. » Author: G. Ganis 08/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootSecContext.html:7334,secur,security,7334,root/html534/TRootSecContext.html,https://root.cern,https://root.cern/root/html534/TRootSecContext.html,2,['secur'],['security']
Security,"ke(Option_t* option, Foption_t& Foption); Decode string choptin and fill fitOption structure. Int_t GetBin(Int_t binx, Int_t biny = 0, Int_t binz = 0) const; Return Global bin number corresponding to binx,y,z. 2-D and 3-D histograms are represented with a one dimensional; structure.; This has the advantage that all existing functions, such as; GetBinContent, GetBinError, GetBinFunction work for all dimensions. In case of a TH1x, returns binx directly.; see TH1::GetBinXYZ for the inverse transformation. Convention for numbering bins. For all histogram types: nbins, xlow, xup; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with binx,biny,binz, the function; Int_t bin = h->GetBin(binx,biny,binz);; returns a global/linearized bin number. This global bin is useful; to access the bin information independently of the dimension. void GetBinXYZ(Int_t binglobal, Int_t& binx, Int_t& biny, Int_t& binz) const; return binx, biny, binz corresponding to the global bin number globalbin; see TH1::GetBin function above. Double_t GetRandom() const; return a random number distributed according the histogram bin contents.; This function checks if the bins integral exists. If not, the integral; is evaluated, normalized to one.; The integral is automatically recomputed if the number of entries; is not the same then when the integral was computed.; NB Only valid for 1-d histograms. Use GetRandom2 or 3 otherwise.; If the histogram has a bin with negative content a NaN is returned. Double_t GetBinContent(Int_t bin) const; Return content of bin number bin. Implemented in TH1C,S,F,D. Convention for numbering bins. For all histogram types: nbins, xlow, xup; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:95924,access,access,95924,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['access'],['access']
Security,"ken = nullptr ;; 546 token_idx = 0 ;; 547 value_idx = 0 ;; 548 }; 549 Set(np) ;; 550 ; 551 // Cleaning; 552 delete [] isTokenToBeSaved ;; 553 delete [] value ;; 554 delete token ;; 555 }; 556 infile.close();; 557 if (fNpoints == 0) {; 558 Warning(""TGraph"", ""No points were found in file %s with the specified input format %s"", filename, format);; 559 return;; 560 }; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Graph default destructor.; 565 ; 566TGraph::~TGraph(); 567{; 568 delete [] fX;; 569 delete [] fY;; 570 if (fFunctions) {; 571 fFunctions->SetBit(kInvalidObject);; 572 //special logic to support the case where the same object is; 573 //added multiple times in fFunctions.; 574 //This case happens when the same object is added with different; 575 //drawing modes; 576 TObject *obj;; 577 while ((obj = fFunctions->First())) {; 578 while (fFunctions->Remove(obj)) { }; 579 delete obj;; 580 }; 581 delete fFunctions;; 582 fFunctions = nullptr; //to avoid accessing a deleted object in RecursiveRemove; 583 }; 584 delete fHistogram;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 588/// Allocate internal data structures for `newsize` points.; 589 ; 590Double_t **TGraph::Allocate(Int_t newsize); 591{; 592 return AllocateArrays(2, newsize);; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Allocate arrays.; 597 ; 598Double_t** TGraph::AllocateArrays(Int_t Narrays, Int_t arraySize); 599{; 600 if (arraySize < 0) {; 601 arraySize = 0;; 602 }; 603 Double_t **newarrays = new Double_t*[Narrays];; 604 if (!arraySize) {; 605 for (Int_t i = 0; i < Narrays; ++i); 606 newarrays[i] = nullptr;; 607 } else {; 608 for (Int_t i = 0; i < Narrays; ++i); 609 newarrays[i] = new Double_t[arraySize];; 610 }; 611 fMaxSize = arraySize;; 612 return newarrays;; 613}; 614 ; 615//////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:18714,access,accessing,18714,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['access'],['accessing']
Security,"kend-dependent, but generically tries to infer how many cores are available in the cluster through the connection object. The number of tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to a batch system. The client object created at the beginning of the application does not automatically know how many cores will be available during distributed execution, since the jobs are submitted to the batch system after the creation of the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks.; The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional keyword argument npartitions when creating the RDataFrame object. This parameter is accepted irrespectively of the backend used:; import ROOT; ; # Define correct imports and access the distributed RDataFrame appropriate for the; # backend used in the analysis; RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame; ; if __name__ == ""__main__"":; # The `npartitions` optional argument tells the RDataFrame how many tasks are desired; df = RDataFrame(""mytree"",""myfile.root"", npartitions=NPARTITIONS); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); Note that when processing a TTree or TChain dataset, the npartitions value should not exceed the number of clusters in the dataset. The number of clusters in a TTree can be retrieved by typing rootls -lt myfile.root at a command line. Distributed Snapshot; The Snapshot operation behaves slightly differently when executed distributedly. First off, it requires the path supplied to the Snapshot call to be accessible from any worker of the cluster and from the client machine (in general it should be provided as an absolute path). Another important difference is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:39683,access,access,39683,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['access'],['access']
Security,"ket or a parallel socket and authenticates to the remote server. ; url: [[proto][p][auth]://][user@]host[:port][/service][?options]; where proto = ""sockd"", ""rootd"", ""proofd"" indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates any remote server session using TServerSocket) [p] = for parallel sockets (forced internally for rootd; ignored for proofd) [auth] = ""up"" or ""k"" to force UsrPwd or Krb5 authentication [port] = is the remote port number [service] = service name used to determine the port (for backward compatibility, specification of port as priority) options = ""m"" or ""s"", when proto=proofd indicates whether we are master or slave (used internally by TSlave); An already opened connection can be used by passing its socket in opensock.; If 'err' is defined, '*err' on return from a failed call contains an error code (see NetErrors.h).; Example:; TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3); creates an authenticated parallel socket of size 3 to a sockd server running on remote machine machine.fq.dn on port 5052; authentication will attempt protocol Kerberos first.; NB: may hang if the remote server is not of the correct type; at present TSocket has no way to find out the type of the remote server automatically; Returns pointer to an authenticated socket or 0 if creation or authentication is unsuccessful. ; Definition at line 1290 of file TSocket.cxx. ◆ CreateAuthSocket() [2/2]. TSocket * TSocket::CreateAuthSocket ; (; const char * ; user, . const char * ; url, . Int_t ; port, . Int_t ; size = 0, . Int_t ; tcpwindowsize = -1, . TSocket * ; opensock = nullptr, . Int_t * ; err = nullptr . ). static . Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ; url: [[proto][p][auth]://]host[/?options]; where proto = ""sockd"", ""rootd"", ""proofd"" indicates the type of remote server if missing ""sockd"" is assumed (""sockd"" indicates any remote server session usin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:24285,authenticat,authenticated,24285,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['authenticat'],['authenticated']
Security,"ketBytesSent ();  Get total number of bytes sent via all sockets. ;  ; static void NetError (const char *where, Int_t error);  Print error string depending on error code. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions;  TServerSocket ();  ;  TServerSocket (const TServerSocket &);  ; Bool_t Authenticate (TSocket *);  Check authentication request from the client on new open connection. ;  ; void operator= (const TServerSocket &);  . Private Attributes; TSeqCollection * fSecContexts;  . Static Private Attributes; static UChar_t fgAcceptOpt = kSrvNoAuth;  ; static SrvClup_t fgSrvAuthClupHook = 0;  ; static SrvAuth_t fgSrvAuthHook = 0;  . Additional Inherited Members;  Protected Types inherited from TSocket; enum  ESocketErrors { kInvalid = -1; , kInvalidStillInList = -2; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSocket;  TSocket ();  ; Bool_t Authenticate (const char *user);  Authenticated the socket with specified user. ;  ; void MarkBrokenConnection ();  Close the socket and mark as due to a broken connection. ;  ; Bool_t RecvProcessIDs (TMessage *mess);  Receive a message containing process ids. ;  ; Bool_t RecvStreamerInfos (TMessage *mess);  Receive a message containing str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTServerSocket.html:16762,authenticat,authentication,16762,doc/master/classTServerSocket.html,https://root.cern,https://root.cern/doc/master/classTServerSocket.html,1,['authenticat'],['authentication']
Security,"key,value) pair to the table. The key should be unique. ;  ; void AddAt (UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value);  Add an (key,value) pair to the table. ;  ; Int_t Capacity () const;  ; void Delete (Option_t *opt="""") override;  Delete all entries stored in the TExMap. ;  ; void Expand (Int_t newsize);  Expand the TExMap. ;  ; Int_t GetSize () const;  ; Long64_t GetValue (Long64_t key);  ; Long64_t GetValue (ULong64_t hash, Long64_t key);  Return the value belonging to specified key and hash value. ;  ; Long64_t GetValue (ULong64_t hash, Long64_t key, UInt_t &slot);  Return the value belonging to specified key and hash value. ;  ; TClass * IsA () const override;  ; Long64_t & operator() (Long64_t key);  ; Long64_t & operator() (ULong64_t hash, Long64_t key);  Return a reference to the value belonging to the key with the specified hash value. ;  ; TExMap & operator= (const TExMap &);  Assignment operator. ;  ; void Remove (Long64_t key);  ; void Remove (ULong64_t hash, Long64_t key);  Remove entry with specified key from the TExMap. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExMap.html:1872,hash,hash,1872,doc/master/classTExMap.html,https://root.cern,https://root.cern/doc/master/classTExMap.html,1,['hash'],['hash']
Security,"kin (Int_t breakin=1);  ; void SetBreakout (Int_t breakout=1);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTask.html:6350,hash,hash,6350,doc/master/classTTask.html,https://root.cern,https://root.cern/doc/master/classTTask.html,1,['hash'],['hash']
Security,"king object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetabeta parameter for AdaBoost algorithm; TStringfAdaBoostR2Lossloss type used in AdaBoostR2 (Linear,Quadratic or Exponential); Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Bool_tfBaggedGradBoostturn bagging in combination with grad boost on/off; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightntuple var: boost weight; vector<double>fBoostWeightsthe weights applied in the individual boosts; Double_tfErrorFractionntuple var: misclassification error fraction; vector<TMVA::Event*>fEventSamplethe training events; Double_tfFValidationEventsfraction of events to use for pruning; vector<TMVA::DecisionTree*,allocator<TMVA::DecisionTree*> >fForestthe collection of decision trees; Int_tfITreentuple var: ith tree; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; TTree*fMonitorNtuplemonitoring ntuple; Int_tfNCutsgrid used in cut applied in node splitting; UInt_tfNNodesMaxmax # of nodes; Int_tfNTreesnumber of decision trees requested; Bool_tfNoNegWeightsInTrainingignore negative event weights in the training; Int_tfNodeMinEventsmin number of events in node; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPruneBeforeBoostflag to prune before boosting; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; Bool_tfRenormByClassindividually re-normalize each event class to the original size after bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBDT.html:20600,validat,validation,20600,root/html528/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html,1,['validat'],['validation']
Security,"known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 374 of file TListOfFunctions.cxx. ◆ MakeIterator(). TIterator * TListOfFunctions::MakeIterator ; (; Bool_t ; dir = kIterForward); const. overridevirtual . Return a list iterator. ; Reimplemented from TList.; Definition at line 451 of file TListOfFunctions.cxx. ◆ MapObject(). void TListOfFunctions::MapObject ; (; TObject * ; obj). private . Add pair<id, object> to the map of functions and their ids. ; Definition at line 51 of file TListOfFunctions.cxx. ◆ operator=(). TListOfFunctions & TListOfFunctions::operator= ; (; const TListOfFunctions & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfFunctions::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from THashList.; Definition at line 328 of file TListOfFunctions.cxx. ◆ Remove() [1/2]. TObject * TListOfFunctions::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Reimplemented from THashList.; Definition at line 341 of file TListOfFunctions.cxx. ◆ Remove() [2/2]. TObject * TListOfFunctions::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from THashList.; Definition at line 357 of file TListOfFunctions.cxx. ◆ Streamer(). void TListOfFunctions::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from THashList. ◆ StreamerNVirtual(). void TListOfFunctions::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 102 of file TList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:33125,hash,hash,33125,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,2,['hash'],['hash']
Security,"l . Delete all entries stored in the TExMap. ; Reimplemented from TObject.; Definition at line 164 of file TExMap.cxx. ◆ Expand(). void TExMap::Expand ; (; Int_t ; newsize). Expand the TExMap. ; Definition at line 279 of file TExMap.cxx. ◆ FindElement(). Int_t TExMap::FindElement ; (; ULong64_t ; hash, . Long64_t ; key . ). private . Find an entry with specified hash and key in the TExMap. ; Returns the slot of the key or the next empty slot. ; Definition at line 237 of file TExMap.cxx. ◆ FixCollisions(). void TExMap::FixCollisions ; (; Int_t ; index). private . Rehash the map in case an entry has been removed. ; Definition at line 257 of file TExMap.cxx. ◆ GetSize(). Int_t TExMap::GetSize ; (; ); const. inline . Definition at line 71 of file TExMap.h. ◆ GetValue() [1/3]. Long64_t TExMap::GetValue ; (; Long64_t ; key). inline . Definition at line 73 of file TExMap.h. ◆ GetValue() [2/3]. Long64_t TExMap::GetValue ; (; ULong64_t ; hash, . Long64_t ; key . ). Return the value belonging to specified key and hash value. ; If key not found return 0. ; Definition at line 174 of file TExMap.cxx. ◆ GetValue() [3/3]. Long64_t TExMap::GetValue ; (; ULong64_t ; hash, . Long64_t ; key, . UInt_t & ; slot . ). Return the value belonging to specified key and hash value. ; If key not found return 0. In 'slot', return the index of the slot used or the first empty slot. (to be used with AddAt). ; Definition at line 197 of file TExMap.cxx. ◆ HighWaterMark(). Bool_t TExMap::HighWaterMark ; (; ). inlineprivate . Definition at line 54 of file TExMap.h. ◆ IsA(). TClass * TExMap::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 81 of file TExMap.h. ◆ operator()() [1/2]. Long64_t & TExMap::operator() ; (; Long64_t ; key). inline . Definition at line 79 of file TExMap.h. ◆ operator()() [2/2]. Long64_t & TExMap::operator() ; (; ULong64_t ; hash, . Long64_t ; key . ). Return a reference to the value belonging to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExMap.html:15042,hash,hash,15042,doc/master/classTExMap.html,https://root.cern,https://root.cern/doc/master/classTExMap.html,1,['hash'],['hash']
Security,"l = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteBuffer(TBuffer& b, void* pointer, const char* info = """"). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TVirtualStreamerInfo*FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; voidGetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); voidGetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); voidTObject::MakeZombie(); Bool_tTDictionary::UpdateInterpreterStateMarker(). private:. static voidConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); TVirtualStreamerInfo*DetermineCurrentStreamerInfo(); TMethod*FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); voidForceReload(TClass* oldcl); Int_tGetBaseClassOffsetRecurse(const TClass* toBase); TMethod*GetClassMethod(Long_t faddr); static DeclIdMap_t*GetDeclIdMap(); static IdMap_t*GetIdMap(); TListOfFunctions*GetMethodList(); static Bool_tHasNoInfoOrEmuOrFwdDeclaredDecl(const char*); voidInit(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, Class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:14915,checksum,checksum,14915,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['checksum'],['checksum']
Security,"l TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TDavixFile.h>. Inheritance diagram for TDavixFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TDavixFile(). TDavixFile::TDavixFile ; (; const char * ; url, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault . ). Open function for TDavixFile. ; TDavixFile supports several options :. GRID_MODE=yes : enable the grid authentication and CA support; CA_CHECK=no : remove all the certificate authority check, this option can create a security vulnerability; S3SECKEY=string : Amazon S3 secret token; S3ACCKEY=string : Amazon S3 access token; S3REGION=string : Amazon S3 region. Optional, if provided, davix will use v4 signatures.; S3TOKEN=string : Amazon STS temporary credentials token. Several parameters can be used if separated with whitespace ; Definition at line 658 of file TDavixFile.cxx. ◆ ~TDavixFile(). TDavixFile::~TDavixFile ; (; ). Definition at line 669 of file TDavixFile.cxx. Member Function Documentation. ◆ Class(). static TClass * TDavixFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDavixFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDavixFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 128 of file TDavixFile.h. ◆ DavixPReadBuffer(). Long64_t TDavixFile::DavixPReadBuffer ; (; Davix_fd * ; fd, . char * ; buf, . Long64_t ; pos, . Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:41976,authenticat,authentication,41976,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,4,"['access', 'authenticat', 'certificate', 'secur']","['access', 'authentication', 'certificate', 'security']"
Security,"l be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void reserve(Int_t nEvt). void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kTRUE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void forceCacheUpdate(). void recalculateCache(const RooArgSet* , Int_t firstEvent, Int_t lastEvent, Int_t stepSize, Bool_t skipZeroWeights). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& ); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:15744,access,access,15744,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,3,['access'],['access']
Security,"l boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableInitialRange(unsigned int, double, double); virtual boolSetVariableLimits(unsigned int ivar, double lower, double upper); virtual boolSetVariableLowerLimit(unsigned int ivar, double lower); virtual boolSetVariableStepSize(unsigned int ivar, double value); virtual boolSetVariableUpperLimit(unsigned int ivar, double upper); virtual boolSetVariableValue(unsigned int ivar, double value); virtual boolSetVariableValues(const double* x); intStatus() const; intStrategy() const; doubleTolerance() const; virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. private:. ROOT::Math::MinimizerMinimizer(const ROOT::Math::Minimizer&); ROOT::Math::Minimizer&operator=(const ROOT::Math::Minimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsfOptionsminimizer options; intfStatusstatus of minimizer; boolfValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minimizer(). Default constructor. {}. virtual ~Minimizer(). Destructor (no operations). {}. Minimizer(const ROOT::Math::Minimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a new free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a new lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Minimizer.html:5095,validat,validated,5095,root/html602/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Minimizer.html,2,['validat'],['validated']
Security,"l boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableValue(unsigned int ivar, double val); virtual boolSetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::GSLSimAnMinimizerGSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer&); ROOT::Math::GSLSimAnMinimizer&operator=(const ROOT::Math::GSLSimAnMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. map<unsigned int,std::pair<double,double> >fBoundsmap specifying the bound using as key the parameter index; unsigned intfDimdimension of the function to be minimized ; doublefMinValminimum values ; vector<std::string>fNames; const ROOT::Math::IMultiGenFunction*fObjFunc; boolfOwnFuncflag to indicate if objective function is managed ; ROOT::Math::GSLSimAnnealingfSolver; vector<double>fSteps; vector<double>fValues; vector<ROOT::Math::EMinimVariableType>fVarTypesvector specifyng the type of variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLSimAnMinimizer(int type = 0). Default constructor. ~GSLSimAnMinimizer(). Destructor (no operat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLSimAnMinimizer.html:4398,validat,validated,4398,root/html526/ROOT__Math__GSLSimAnMinimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLSimAnMinimizer.html,4,['validat'],['validated']
Security,"l classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.14999999999999999); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClassTree.html:13821,access,access,13821,root/html602/TClassTree.html,https://root.cern,https://root.cern/root/html602/TClassTree.html,2,['access'],['access']
Security,"l classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.15); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClassTree.html:13271,access,access,13271,root/html526/TClassTree.html,https://root.cern,https://root.cern/root/html526/TClassTree.html,5,['access'],['access']
Security,"l come as a relief to learn that objects do not move, C++ does not garbage collect, so there is never a danger that a pointer to an object becomes invalid for that reason. However, having created an object, it is the user’s responsibility to ensure that it is deleted when no longer needed, or to pass that responsibility onto to some other object. Failing to do that will result in a memory leak, one of the most common and most hard-to-find C++ bugs.; To send a message to an object via a pointer to it, you need to use the “->” operator e.g.:; root[] my_objptr->Solve();; Although we chose to call our pointer my_objptr, to emphasize that it is a pointer, heap objects are so common in an object-oriented program that pointer names rarely reflect the fact - you have to be careful that you know if you are dealing with an object or its pointer! Fortunately, the compiler won’t tolerate an attempt to do something like:; root[] my_objptr.Solve();; As we have seen, heap objects have to be accessed via pointers, whereas stack objects can be accessed directly. They can also be accessed via pointers:; root[] Quad stack_quad(1.,2.,-3.);; root[] Quad *stack_ptr = &stack_quad;; root[] stack_ptr->Solve();; Here we have a Quad pointer that has been initialized with the address of a stack object. Be very careful if you take the address of stack objects. As we shall see soon, they are deleted automatically, which could leave you with an illegal pointer. Using it will corrupt and may as well crash the program!; It is time to look at the destruction of objects. A destructor is a special C++ function that releases resources for (or destroys) an object of a class. It is the opposite of a constructor that creates the object of a class when it is called. The compiler will provide a destructor that does nothing if none is provided. We will add one to our Quad class so that we can see when it is called. The class names the destructor but with a prefix ~ which is the C++ one’s complement i.e. bit w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:252438,access,accessed,252438,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['access'],['accessed']
Security,"l failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. The opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TServerSocket.html:13436,authenticat,authentication,13436,root/html530/TServerSocket.html,https://root.cern,https://root.cern/root/html530/TServerSocket.html,10,['authenticat'],['authentication']
Security,"l file access mode; param title: title of the file (shown by ROOT browser); param compress: compression level and algorithm; param netopt: TCP window size in bytes (unused); param parallelopen: open asynchronously. ~TNetXNGFile(); Destructor. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Long64_t GetSize() const; Get the file size. Returns -1 in the case that the file could not be; stat'ed. Bool_t IsOpen() const; Check if the file is open. void SetAsyncOpenStatus(TFile::EAsyncOpenStatus status); Set the status of an asynchronous file open. void Close(const Option_t* option = """"); Close the file. param option: if == ""R"", all TProcessIDs referenced by this file are; deleted (is this valid in xrootd context?). Int_t ReOpen(Option_t* modestr); Reopen the file with the new access mode. param mode: the new access mode; returns: 0 in case the mode was successfully modified, 1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetXNGFile.html:25347,access,access,25347,root/html602/TNetXNGFile.html,https://root.cern,https://root.cern/root/html602/TNetXNGFile.html,2,['access'],['access']
Security,"l functions class (global functions are obtained from CINT).Definition TFunction.h:30; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::ECheckClassInfoECheckClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::IntegrationOneDim::TypeTypeenu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:93335,access,access,93335,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['access'],['access']
Security,"l handle this request. All requests; 14235 * handled by a callback have to be considered as requests; 14236 * to a script resource. */; 14237 is_callback_resource = 1;; 14238 is_script_resource = 1;; 14239 is_put_or_delete_request = is_put_or_delete_method(conn);; 14240 } else {; 14241 no_callback_resource:; 14242 ; 14243 /* 5.2.2. No callback is responsible for this request. The URI; 14244 * addresses a file based resource (static content or Lua/cgi; 14245 * scripts in the file system). */; 14246 is_callback_resource = 0;; 14247 interpret_uri(conn,; 14248 path,; 14249 sizeof(path),; 14250 &file.stat,; 14251 &is_found,; 14252 &is_script_resource,; 14253 &is_websocket_request,; 14254 &is_put_or_delete_request,; 14255 &is_template_text_file);; 14256 }; 14257 ; 14258 /* 6. authorization check */; 14259 /* 6.1. a custom authorization handler is installed */; 14260 if (get_request_handler(conn,; 14261 AUTH_HANDLER,; 14262 NULL,; 14263 NULL,; 14264 NULL,; 14265 NULL,; 14266 NULL,; 14267 NULL,; 14268 &auth_handler,; 14269 &auth_callback_data,; 14270 NULL)) {; 14271 if (!auth_handler(conn, auth_callback_data)) {; 14272 ; 14273 /* Callback handler will not be used anymore. Release it */; 14274 release_handler_ref(conn, handler_info);; 14275 ; 14276 return;; 14277 }; 14278 } else if (is_put_or_delete_request && !is_script_resource; 14279 && !is_callback_resource) {; 14280 HTTP1_only;; 14281 /* 6.2. this request is a PUT/DELETE to a real file */; 14282 /* 6.2.1. thus, the server must have real files */; 14283#if defined(NO_FILES); 14284 if (1) {; 14285#else; 14286 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14287#endif; 14288 /* This code path will not be called for request handlers */; 14289 DEBUG_ASSERT(handler_info == NULL);; 14290 ; 14291 /* This server does not have any real files, thus the; 14292 * PUT/DELETE methods are not valid. */; 14293 mg_send_http_error(conn,; 14294 405,; 14295 ""%s method not allowed"",; 14296 conn->request_info.request_method);; 14297 ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:419363,authoriz,authorization,419363,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['authoriz'],['authorization']
Security,"l handle this request. All requests; 14236 * handled by a callback have to be considered as requests; 14237 * to a script resource. */; 14238 is_callback_resource = 1;; 14239 is_script_resource = 1;; 14240 is_put_or_delete_request = is_put_or_delete_method(conn);; 14241 } else {; 14242 no_callback_resource:; 14243 ; 14244 /* 5.2.2. No callback is responsible for this request. The URI; 14245 * addresses a file based resource (static content or Lua/cgi; 14246 * scripts in the file system). */; 14247 is_callback_resource = 0;; 14248 interpret_uri(conn,; 14249 path,; 14250 sizeof(path),; 14251 &file.stat,; 14252 &is_found,; 14253 &is_script_resource,; 14254 &is_websocket_request,; 14255 &is_put_or_delete_request,; 14256 &is_template_text_file);; 14257 }; 14258 ; 14259 /* 6. authorization check */; 14260 /* 6.1. a custom authorization handler is installed */; 14261 if (get_request_handler(conn,; 14262 AUTH_HANDLER,; 14263 NULL,; 14264 NULL,; 14265 NULL,; 14266 NULL,; 14267 NULL,; 14268 NULL,; 14269 &auth_handler,; 14270 &auth_callback_data,; 14271 NULL)) {; 14272 if (!auth_handler(conn, auth_callback_data)) {; 14273 ; 14274 /* Callback handler will not be used anymore. Release it */; 14275 release_handler_ref(conn, handler_info);; 14276 ; 14277 return;; 14278 }; 14279 } else if (is_put_or_delete_request && !is_script_resource; 14280 && !is_callback_resource) {; 14281 HTTP1_only;; 14282 /* 6.2. this request is a PUT/DELETE to a real file */; 14283 /* 6.2.1. thus, the server must have real files */; 14284#if defined(NO_FILES); 14285 if (1) {; 14286#else; 14287 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14288#endif; 14289 /* This code path will not be called for request handlers */; 14290 DEBUG_ASSERT(handler_info == NULL);; 14291 ; 14292 /* This server does not have any real files, thus the; 14293 * PUT/DELETE methods are not valid. */; 14294 mg_send_http_error(conn,; 14295 405,; 14296 ""%s method not allowed"",; 14297 conn->request_info.request_method);; 14298 ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:419396,authoriz,authorization,419396,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['authoriz'],['authorization']
Security,"l implementation detail.; 6578 TList *tlb = ((TClass*)this)->GetListOfBases();; 6579 if (tlb && !GetCollectionProxy() && !TClassEdit::IsStdPair(GetName())) {; 6580 // Loop over bases if not a proxied collection or a pair; 6581 ; 6582 TIter nextBase(tlb);; 6583 ; 6584 TBaseClass *tbc=nullptr;; 6585 while((tbc=(TBaseClass*)nextBase())) {; 6586 name = tbc->GetName();; 6587 Bool_t isSTL = TClassEdit::IsSTLCont(name);; 6588 if (isSTL); 6589 name = TClassEdit::ShortType( name, TClassEdit::kDropStlDefault );; 6590 il = name.Length();; 6591 for (int i=0; i<il; i++) id = id*3+name[i];; 6592 if (code > kNoBaseCheckSum && !isSTL) {; 6593 if (tbc->GetClassPointer() == nullptr) {; 6594 Error(""GetCheckSum"",""Calculating the checksum for (%s) requires the base class (%s) meta information to be available!"",; 6595 GetName(),tbc->GetName());; 6596 isvalid = kFALSE;; 6597 return 0;; 6598 } else; 6599 id = id*3 + tbc->GetClassPointer()->GetCheckSum();; 6600 }; 6601 }/*EndBaseLoop*/; 6602 }; 6603 TList *tlm = ((TClass*)this)->GetListOfDataMembers();; 6604 if (tlm) { // Loop over members; 6605 TIter nextMemb(tlm);; 6606 TDataMember *tdm=nullptr;; 6607 Long_t prop = 0;; 6608 while((tdm=(TDataMember*)nextMemb())) {; 6609 if (!tdm->IsPersistent()) continue;; 6610 // combine properties; 6611 prop = (tdm->Property());; 6612 TDataType* tdt = tdm->GetDataType();; 6613 if (tdt) prop |= tdt->Property();; 6614 ; 6615 if ( prop&kIsStatic) continue;; 6616 name = tdm->GetName(); il = name.Length();; 6617 if ( (code > kNoEnum) && code != kReflex && code != kReflexNoComment && prop&kIsEnum); 6618 id = id*3 + 1;; 6619 ; 6620 int i;; 6621 for (i=0; i<il; i++) id = id*3+name[i];; 6622 ; 6623 if (code > kWithTypeDef || code == kReflexNoComment) {; 6624 type = tdm->GetTrueTypeName();; 6625 // GetTrueTypeName uses GetFullyQualifiedName which already drops; 6626 // the default template parameter, so we no longer need to do this.; 6627 //if (TClassEdit::IsSTLCont(type)); 6628 // type = TClassEdit::ShortType( typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:253429,checksum,checksum,253429,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['checksum'],['checksum']
Security,"l implementation detail.; 6645 TList *tlb = ((TClass*)this)->GetListOfBases();; 6646 if (tlb && !GetCollectionProxy() && !TClassEdit::IsStdPair(GetName())) {; 6647 // Loop over bases if not a proxied collection or a pair; 6648 ; 6649 TIter nextBase(tlb);; 6650 ; 6651 TBaseClass *tbc=nullptr;; 6652 while((tbc=(TBaseClass*)nextBase())) {; 6653 name = tbc->GetName();; 6654 Bool_t isSTL = TClassEdit::IsSTLCont(name);; 6655 if (isSTL); 6656 name = TClassEdit::ShortType( name, TClassEdit::kDropStlDefault );; 6657 il = name.Length();; 6658 for (int i=0; i<il; i++) id = id*3+name[i];; 6659 if (code > kNoBaseCheckSum && !isSTL) {; 6660 if (tbc->GetClassPointer() == nullptr) {; 6661 Error(""GetCheckSum"",""Calculating the checksum for (%s) requires the base class (%s) meta information to be available!"",; 6662 GetName(),tbc->GetName());; 6663 isvalid = kFALSE;; 6664 return 0;; 6665 } else; 6666 id = id*3 + tbc->GetClassPointer()->GetCheckSum();; 6667 }; 6668 }/*EndBaseLoop*/; 6669 }; 6670 TList *tlm = ((TClass*)this)->GetListOfDataMembers();; 6671 if (tlm) { // Loop over members; 6672 TIter nextMemb(tlm);; 6673 TDataMember *tdm=nullptr;; 6674 Long_t prop = 0;; 6675 while((tdm=(TDataMember*)nextMemb())) {; 6676 if (!tdm->IsPersistent()) continue;; 6677 // combine properties; 6678 prop = (tdm->Property());; 6679 TDataType* tdt = tdm->GetDataType();; 6680 if (tdt) prop |= tdt->Property();; 6681 ; 6682 if ( prop&kIsStatic) continue;; 6683 name = tdm->GetName(); il = name.Length();; 6684 if ( (code > kNoEnum) && code != kReflex && code != kReflexNoComment && prop&kIsEnum); 6685 id = id*3 + 1;; 6686 ; 6687 int i;; 6688 for (i=0; i<il; i++) id = id*3+name[i];; 6689 ; 6690 if (code > kWithTypeDef || code == kReflexNoComment) {; 6691 type = tdm->GetTrueTypeName();; 6692 // GetTrueTypeName uses GetFullyQualifiedName which already drops; 6693 // the default template parameter, so we no longer need to do this.; 6694 //if (TClassEdit::IsSTLCont(type)); 6695 // type = TClassEdit::ShortType( typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:256180,checksum,checksum,256180,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['checksum'],['checksum']
Security,"l operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_3_.html:6460,access,access,6460,root/html526/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"l void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TEnv::Lookupvirtual TEnvRec * Lookup(const char *n) constLoop over all resource records and return the one with name.Definition TEnv.cxx:547; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::fInfoMethodInfo_t * fInfoDefinition TFunction.h:36; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition THashList.cxx:378; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::RegisterPrebuiltModulePathvirtual bool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const =0; TInterpreter::HasPCMForLibraryvirtual Bool_t HasPCMForLibrary(const char *libname) const =0; TInterpreter::AutoParsevirtual Int_t AutoParse(const char *cls)=0; TInterpreter::AutoLoadCallBack_tint(* AutoLoadCallBack_t)(const char *)Definition TInterpreter.h:132; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::Declarevirtual Bool_t Declare(const char *code)=0; TInterpreter::GetClassSharedLibsvirtual const char * GetClassSharedLibs(const char *cls, bool skipCore=true)=0; TInterpreter::ECheckCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:468199,hash,hash,468199,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['hash'],['hash']
Security,"l void SetSelectedMenuItem (TClassMenuItem *mi);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveContextMenu.html:4671,hash,hash,4671,doc/master/classTEveContextMenu.html,https://root.cern,https://root.cern/doc/master/classTEveContextMenu.html,1,['hash'],['hash']
Security,"l, TClass* newcl); voidWriteItems(int nElements, TBuffer& b). private:. TEmulatedCollectionProxy&operator=(const TEmulatedCollectionProxy&). Data Members; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tTGenCollectionProxy::fCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tTGenCollectionProxy::fConstructContainer accessors: block construct; map<string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tTGenCollectionProxy::fDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*TGenCollectionProxy::fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tTGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::fFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::fFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::fFunctionDeleteI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEmulatedCollectionProxy.html:4885,access,accessors,4885,root/html602/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TEmulatedCollectionProxy.html,4,['access'],['accessors']
Security,"l-like. { return fSignalReferenceCut; }. void SetSignalReferenceCut(Double_t cut); sets the minimum requirement on the MVA output to declare an event signal-like. { fSignalReferenceCut = cut; }. void SetMethodDir(TDirectory* methodDir); { fBaseDir = fMethodBaseDir = methodDir; }. void SetBaseDir(TDirectory* methodDir); { fBaseDir = methodDir; }. void SetMethodBaseDir(TDirectory* methodDir); { fMethodBaseDir = methodDir; }. UInt_t GetTrainingTMVAVersionCode() const; the TMVA version can be obtained and checked using; if (GetTrainingTMVAVersionCode()>TMVA_VERSION(3,7,2)) {...}; or; if (GetTrainingROOTVersionCode()>ROOT_VERSION(5,15,5)) {...}. { return fTMVATrainingVersion; }. UInt_t GetTrainingROOTVersionCode() const; { return fROOTTrainingVersion; }. TransformationHandler& GetTransformationHandler(); { return fTransformation; }. const TransformationHandler& GetTransformationHandler() const; { return fTransformation; }. DataSetInfo& DataInfo() const; ---------- event accessors ------------------------------------------------; returns reference to data set. { return fDataSetInfo; }. UInt_t GetNEvents() const; event reference and update. { return Data()->GetNEvents(); }. Bool_t IsSignalLike(); ---------- public auxiliary methods ---------------------------------------; this method is used to decide whether an event is signal- or background-like; the reference cut ""xC"" is taken to be where; Int_[-oo,xC] { PDF_S(x) dx } = Int_[xC,+oo] { PDF_B(x) dx }. { return GetMvaValue() > GetSignalReferenceCut() ? kTRUE : kFALSE; }. Bool_t HasMVAPdfs() const; { return fHasMVAPdfs; }. void SetAnalysisType(TMVA::Types::EAnalysisType type); { fAnalysisType = type; }. Types::EAnalysisType GetAnalysisType() const; { return fAnalysisType; }. Bool_t DoRegression() const; { return fAnalysisType == Types::kRegression; }. Bool_t DoMulticlass() const; { return fAnalysisType == Types::kMulticlass; }. void DisableWriting(Bool_t setter); setter method for suppressing writing to XML and writing of st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBase.html:32912,access,accessors,32912,root/html528/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html,1,['access'],['accessors']
Security,"l2-1];; 1335 localArr2[iEl2-1] = localArr2[iEl2];; 1336 localArr2[iEl2] = tmp2;; 1337 }; 1338 }; 1339 }; 1340 ; 1341 for (iEl = 0; iEl < Narr; iEl++) {; 1342 arr2[iEl] = localArr2[iEl];; 1343 }; 1344 delete [] localArr2;; 1345 delete [] localArr1;; 1346}; 1347 ; 1348////////////////////////////////////////////////////////////////////////////////; 1349/// Opposite ordering of the array arr2[] to that of BubbleHigh.; 1350///; 1351/// \author Adrian Bevan (bevan@slac.stanford.edu); 1352 ; 1353void TMath::BubbleLow(Int_t Narr, Double_t *arr1, Int_t *arr2); 1354{; 1355 if (Narr <= 0) return;; 1356 double *localArr1 = new double[Narr];; 1357 int *localArr2 = new int[Narr];; 1358 int iEl;; 1359 int iEl2;; 1360 ; 1361 for (iEl = 0; iEl < Narr; iEl++) {; 1362 localArr1[iEl] = arr1[iEl];; 1363 localArr2[iEl] = iEl;; 1364 }; 1365 ; 1366 for (iEl = 0; iEl < Narr; iEl++) {; 1367 for (iEl2 = Narr-1; iEl2 > iEl; --iEl2) {; 1368 if (localArr1[iEl2-1] > localArr1[iEl2]) {; 1369 double tmp = localArr1[iEl2-1];; 1370 localArr1[iEl2-1] = localArr1[iEl2];; 1371 localArr1[iEl2] = tmp;; 1372 ; 1373 int tmp2 = localArr2[iEl2-1];; 1374 localArr2[iEl2-1] = localArr2[iEl2];; 1375 localArr2[iEl2] = tmp2;; 1376 }; 1377 }; 1378 }; 1379 ; 1380 for (iEl = 0; iEl < Narr; iEl++) {; 1381 arr2[iEl] = localArr2[iEl];; 1382 }; 1383 delete [] localArr2;; 1384 delete [] localArr1;; 1385}; 1386 ; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389/// Calculates hash index from any char string.; 1390/// Based on pre-calculated table of 256 specially selected numbers.; 1391/// These numbers are selected in such a way, that for string; 1392/// length == 4 (integer number) the hash is unambiguous, i.e.; 1393/// from hash value we can recalculate input (no degeneration).; 1394///; 1395/// The quality of hash method is good enough, that; 1396/// ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); 1397/// tested by `<R>`, `<R*R>`, `<Ri*Ri+1>` gives the same resu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:45915,hash,hash,45915,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['hash'],['hash']
Security,"l::ENTupleInfo::kStorageDetails@ kStorageDetails; For use of ENTupleInfo::kMetrics, see EnableMetrics. ; Definition at line 137 of file RNTupleReader.cxx. ◆ RetrieveFieldId(). ROOT::Experimental::DescriptorId_t ROOT::Experimental::RNTupleReader::RetrieveFieldId ; (; std::string_view ; fieldName); const. private . Definition at line 238 of file RNTupleReader.cxx. ◆ Show(). void ROOT::Experimental::RNTupleReader::Show ; (; NTupleSize_t ; index, . std::ostream & ; output = std::cout . ). Shows the values of the i-th entry/row, starting with 0 for the first entry. ; By default, prints the output in JSON format. Uses the visitor pattern to traverse through each field of the given entry. ; Definition at line 208 of file RNTupleReader.cxx. Member Data Documentation. ◆ fCachedDescriptor. std::unique_ptr<RNTupleDescriptor> ROOT::Experimental::RNTupleReader::fCachedDescriptor. private . The ntuple descriptor in the page source is protected by a read-write lock. ; We don't expose that to the users of RNTupleReader::GetDescriptor(). Instead, if descriptor information is needed, we clone the descriptor. Using the descriptor's generation number, we know if the cached descriptor is stale. Retrieving descriptor data from an RNTupleReader is supposed to be for testing and information purposes, not on a hot code path. ; Definition at line 89 of file RNTupleReader.hxx. ◆ fDisplayReader. std::unique_ptr<RNTupleReader> ROOT::Experimental::RNTupleReader::fDisplayReader. private . We use a dedicated on-demand reader for Show() and Scan(). ; Printing data uses all the fields from the full model even if the analysis code uses only a subset of fields. The display reader is a clone of the original reader. ; Definition at line 83 of file RNTupleReader.hxx. ◆ fMetrics. Detail::RNTupleMetrics ROOT::Experimental::RNTupleReader::fMetrics. private . Definition at line 90 of file RNTupleReader.hxx. ◆ fModel. std::unique_ptr<RNTupleModel> ROOT::Experimental::RNTupleReader::fModel. private . Needs to b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:17944,expose,expose,17944,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['expose'],['expose']
Security,"l::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal the objects value. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Special version of readFromStream that disallows reading from stream. void writeToStream(ostream& os, Bool_t compact) const; Special version of writeToStream that disallows reading from stream. RooAbsCategory& dummyBlindState() const; Return reference to internal dummy RooCategory implementation; blinding state switch. Bool_t isHidden() const; If true, hiding mode is active. Double_t getHiddenVal(const RooArgSet* nset = 0) const; Bypass accessor to function value that also works in hidden mode. Double_t getValV(const RooArgSet* nset = 0) const; This is dubious from a C++ point of view, but it blocks the interactive user; from accidentally calling getVal() without explicit cast, which is the whole; point of this class. » Last changed: Tue Mar 10 17:14:00 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsHiddenReal.html:36615,access,accessor,36615,root/html534/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html,1,['access'],['accessor']
Security,"l=nullptr);  Constructor. ;  ;  ~TListOfEnums () override;  Destructor. ;  ; TEnum * Find (DeclId_t id) const;  Return the TEnum corresponding to the Decl 'id' or NULL if it does not exist. ;  ; Bool_t IsLoaded () const;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; Bool_t IsAscending ();  ; TObject * Remove (const TObjLinkPtr_t &lnk);  ; void RemoveLast () override;  Remove the last object of the list. ;  ; virtual void Sort (Bool_t order=kSortAscending);  Sort linked list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TSeqCollection; virtual ~TSeqC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnumsWithLock.html:4940,hash,hash,4940,doc/master/classTListOfEnumsWithLock.html,https://root.cern,https://root.cern/doc/master/classTListOfEnumsWithLock.html,1,['hash'],['hash']
Security,"lDefinition textangle.C:4. Cross Evaluation; Cross evaluation is a special case of k-folds cross validation where the splitting into k folds is computed deterministically. This ensures that the a given event will always end up in the same fold.; In addition all resulting classifiers are saved and can be applied to new data using MethodCrossValidation. One requirement for this to work is a splitting function that is evaluated for each event to determine into what fold it goes (for training/evaluation) or to what classifier (for application). Split Expression; Cross evaluation uses a deterministic split to partition the data into folds called the split expression. The expression can be any valid TFormula as long as all parts used are defined.; For each event the split expression is evaluated to a number and the event is put in the fold corresponding to that number.; It is recommended to always use int([NumFolds]) at the end of the expression.; The split expression has access to all spectators and variables defined in the dataloader. Additionally, the number of folds in the split can be accessed with NumFolds (or numFolds). Example; ""int(fabs([eventID]))%int([NumFolds])"". Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVACrossValidation. ; DataSetInfo : [datasetcv] : Added class ""Signal""; : Add Tree of type Signal with 1000 events; DataSetInfo : [datasetcv] : Added class ""Background""; : Add Tree of type Background with 1000 events; <HEADER> Factory : You are running ROOT Version: 6.33.01, Oct 10, 2023; : ; : _/_/_/_/_/ _| _| _| _| _|_| ; : _/ _|_| _|_| _| _| _| _| ; : _/ _| _| _| _| _| _|_|_|_| ; : _/ _| _| _| _| _| _| ; : _/ _| _| _| _| _| ; : ; : ___________TMVA Version 4.2.1, Feb 5, 2015; : ; : Rebuilding Dataset datasetcv; : Building event vectors for type 2 Signal; : Dataset[datasetcv] : create input formulas for tree ; : Building event vectors for type 2 Background; : Dataset[datasetcv] : create input formu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:1710,access,access,1710,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['access'],['access']
Security,"lDefinition textangle.C:4. Cross Evaluation; Cross evaluation is a special case of k-folds cross validation where the splitting into k folds is computed deterministically. This ensures that the a given event will always end up in the same fold.; In addition all resulting classifiers are saved and can be applied to new data using MethodCrossValidation. One requirement for this to work is a splitting function that is evaluated for each event to determine into what fold it goes (for training/evaluation) or to what classifier (for application). Split Expression; Cross evaluation uses a deterministic split to partition the data into folds called the split expression. The expression can be any valid TFormula as long as all parts used are defined.; For each event the split expression is evaluated to a number and the event is put in the fold corresponding to that number.; It is recommended to always use int([NumFolds]) at the end of the expression.; The split expression has access to all spectators and variables defined in the dataloader. Additionally, the number of folds in the split can be accessed with NumFolds (or numFolds). Example; ""int(fabs([eventID]))%int([NumFolds])"". Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVACrossValidationRegression. ; DataSetInfo : [datasetcvreg] : Added class ""Regression""; : Add Tree TreeR of type Regression with 10000 events; --- TMVACrossValidationRegression: Using input file: ./files/tmva_reg_example.root; : Dataset[datasetcvreg] : Class index : 0 name : Regression; <HEADER> Factory : You are running ROOT Version: 6.33.01, Oct 10, 2023; : ; : _/_/_/_/_/ _| _| _| _| _|_| ; : _/ _|_| _|_| _| _| _| _| ; : _/ _| _| _| _| _| _|_|_|_| ; : _/ _| _| _| _| _| _| ; : _/ _| _| _| _| _| ; : ; : ___________TMVA Version 4.2.1, Feb 5, 2015; : ; : Rebuilding Dataset datasetcvreg; : Building event vectors for type 2 Regression; : Dataset[datasetcvreg] : create input formulas for tree TreeR; <HE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:1736,access,access,1736,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,1,['access'],['access']
Security,"lReport on all booked filters. ; Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 1012 of file RLoopManager.cxx. ◆ Run(). void RLoopManager::Run ; (; bool ; jit = true). Start the event loop with a different mechanism depending on IMT/no IMT, data source/no data source. ; Also perform a few setup and clean-up operations (jit actions if necessary, clear booked actions after the loop...). The jitting phase is skipped if the jit parameter is false (unsafe, use with care). ; Definition at line 889 of file RLoopManager.cxx. ◆ RunAndCheckFilters(). void RLoopManager::RunAndCheckFilters ; (; unsigned int ; slot, . Long64_t ; entry . ). private . Execute actions and make sure named filters are called for each event. ; Named filters must be called even if the analysis logic would not require it, lest they report confusing results. ; Definition at line 708 of file RLoopManager.cxx. ◆ RunDataSource(). void RLoopManager::RunDataSource ; (; ). private . Run event loop over data accessed through a DataSource, in sequence. ; Definition at line 635 of file RLoopManager.cxx. ◆ RunDataSourceMT(). void RLoopManager::RunDataSourceMT ; (; ). private . Run event loop over data accessed through a DataSource, in parallel. ; Definition at line 666 of file RLoopManager.cxx. ◆ RunEmptySource(). void RLoopManager::RunEmptySource ; (; ). private . Run event loop with no source files, in sequence. ; Definition at line 505 of file RLoopManager.cxx. ◆ RunEmptySourceMT(). void RLoopManager::RunEmptySourceMT ; (; ). private . Run event loop with no source files, in parallel. ; Definition at line 458 of file RLoopManager.cxx. ◆ RunTreeProcessorMT(). void RLoopManager::RunTreeProcessorMT ; (; ). private . Run event loop over one or multiple ROOT files, in parallel. ; Definition at line 549 of file RLoopManager.cxx. ◆ RunTreeReader(). void RLoopManager::RunTreeReader ; (; ). private . Run event loop over one or multiple ROOT files, in sequence. ; Definition at line 597 of file RLoopManager.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:24549,access,accessed,24549,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['access'],['accessed']
Security,"lShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2272; TClass::GetCurrentStreamerInfoTVirtualStreamerInfo * GetCurrentStreamerInfo()Definition TClass.h:439; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4908; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2722; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3544; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6561; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetListOfBasesTList * GetListOfBases()Return list ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:251764,checksum,checksum,251764,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,3,['checksum'],['checksum']
Security,"l_b);  ;  Public Member Functions inherited from TWebFile;  TWebFile (const char *url, Option_t *opt="""");  Create a Web file object. ;  ;  TWebFile (TUrl url, Option_t *opt="""");  Create a Web file object. ;  ; virtual ~TWebFile ();  Cleanup. ;  ; void Close (Option_t *option="""") override;  Close a Web file. ;  ; Long64_t GetSize () const override;  Return maximum file size. ;  ; TClass * IsA () const override;  ; Bool_t IsOpen () const override;  A TWebFile that has been correctly constructed is always considered open. ;  ; Bool_t ReadBuffer (char *buf, Int_t len) override;  Read specified byte range from remote file via HTTP daemon. ;  ; Bool_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read specified byte range from remote file via HTTP daemon. ;  ; Bool_t ReadBuffers (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf) override;  Read specified byte ranges from remote file via HTTP daemon. ;  ; Int_t ReOpen (Option_t *mode) override;  Reopen a file with a different access mode, like from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. ;  ; void Seek (Long64_t offset, ERelativeTo pos=kBeg) override;  Set position from where to start reading. ;  ; void Streamer (TBuffer &) override;  Stream a TFile object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TFile;  TFile ();  File default Constructor. ;  ;  TFile (const char *fname, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Opens or creates a local ROOT file. ;  ;  ~TFile () override;  File destructor. ;  ; void Copy (TObject &) const override;  Copy this to obj. ;  ; virtual Bool_t Cp (const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000);  Allows to copy this file to the dst URL. ;  ; virtual TKey * CreateKey (TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize);  Creates key for object and converts data to buffer. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:4084,access,access,4084,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['access'],['access']
Security,"l_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:40578,access,accessor,40578,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,1,['access'],['accessor']
Security,"l_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode==AClean ? (flipAClean() ? ADirty : AClean ) : _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueDirty() const. void clearShapeDirty() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setEx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:39567,access,accessor,39567,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['access'],['accessor']
Security,"l_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode==AClean ? (flipAClean() ? ADirty : AClean ) : _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:40024,access,accessor,40024,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,2,['access'],['accessor']
Security,"l_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Int_tFindElement(ULong64_t hash, Long64_t key); voidFixCollisions(Int_t index); Bool_tHighWaterMark(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TExMap.html:5559,hash,hash,5559,root/html534/TExMap.html,https://root.cern,https://root.cern/root/html534/TExMap.html,1,['hash'],['hash']
Security,"l_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Long64_t&operator()(Long64_t key); Long64_t&operator()(ULong64_t hash, Long64_t key); TExMap&operator=(const TExMap&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemove(Long64_t key); voidRemove(ULong64_t hash, Long64_t key); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TExMap.html:4201,hash,hash,4201,root/html528/TExMap.html,https://root.cern,https://root.cern/root/html528/TExMap.html,1,['hash'],['hash']
Security,"la() constructor; [ROOT-11000] - rootcling fails for Gaudi classes; [ROOT-11001] - unable to create TChain on ROOT file; [ROOT-11005] - ROOT crashes when creating a TCanvas with gDebug=1; [ROOT-11009] - RDataFrame Silent “bugs” with assignment in Filter expressions; [ROOT-11013] - “Impossible code path” in TGenCollectionProxy.cxx when using rootcling; [ROOT-11015] - OpenGL rendering is incorrect for “pgon - pgon”; [ROOT-10830] - vector<string> behaviour in loops in PyROOT 6.20 vs 6.22; [ROOT-9559] - [DF] Treat indexed Friend trees; [ROOT-10832] - Make TH1::GetCumulative account for underflows and overflows; [ROOT-8013] - equalising roofit tutorials for easier digestion; [ROOT-8142] - Provide corrupt line when XML parsing fails; [ROOT-10022] - [DF] Add support for TBranchObjects (e.g. branches containing TH2F); [ROOT-10781] - Performance penalty from RooRealVar not allowing to use hash table on RooLinkedList member; [#6408] - Creating RooDataSet causes SegFault; [#6529] - segfault in RooWorkspace::import; [#6489] - Test Issue; [#6540] - Crash message should point to github; [#6479] - TMVA TMVAGui functions crash in batch mode; [#6553] - TMVA Provide support in MethodPyKeras for tensorflow.keras; [#6403] - [Hist] Bugs in TProfile,TProfile2D::LabelsOption; [#6527] - Double delete error with TTree::ChangeFile and a TFile on the stack; [#6455] - [DF] RDataSource does not early-quit event loops when all Ranges are exhausted; [#6435] - [DF] Jitted Min method breaks with RVec columns; [#6425] - Typo in void TEnv::SetValue(const char *name, double value) implementation; [#6406] - root7 is turned off by default even if the default C++ standard of the compiler is C++14 or above; [#6371] - [DF] Display doesn’t work with non-top-level TTree branches; [#6448] - Disable NDEBUG for PR builds; [#6482] - TClass::GetListOfFunctions() fails to enumerate using decls.; [#6393] - PyROOT cannot call templated ctors on Windows; [#6359] - python: /workspace/build/projects/ROOT-HEAD/src/ROOT/H",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:38539,hash,hash,38539,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['hash'],['hash']
Security,"lable -1 is returned. The opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ); Check authentication request from the client on new; open connection. TServerSocket(); { }. TServerSocket(const TServerSocket& ). void operator=(const TServerSocket& ). Int_t Send(const TMessage& ); { MayNotUse(""Send(const TMessage &)""); return 0; }. Int_t Send(Int_t ); { MayNotUse(""Send(Int_t)""); return 0; }. Int_t Send(Int_t , Int_t ); { MayNotUse(""Send(Int_t, Int_t)""); return 0; }. Int_t Send(const char* , Int_t = kMESS_STRING); { MayNotUse(""Send(const char *, Int_t)""); return 0; }. Int_t SendObject(const TObject* , Int_t = kMESS_OBJECT); { MayNotUse(""SendObject(const TObject *, Int_t)""); return 0; }. Int_t SendRaw(const void* , Int_t , ESendRecvOptions = kDefault); { MayNotUse(""SendRaw(const void *, Int_t, ESendRecvOptions)""); return 0; }. Int_t Recv(TMessage*& ); { MayNotUse(""Recv(TMessage *&)""); return 0; }. Int_t Recv(Int_t& , Int_t& ); { M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TServerSocket.html:14299,authenticat,authentication,14299,root/html530/TServerSocket.html,https://root.cern,https://root.cern/root/html530/TServerSocket.html,10,['authenticat'],['authentication']
Security,lag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dgamma; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; RooRealProxy_f0; RooRealProxy_f1; RooRealProxy_f2; RooRealProxy_f3; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsAnaConvPdf::_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBDecay.html:42102,access,access,42102,root/html534/RooBDecay.html,https://root.cern,https://root.cern/root/html534/RooBDecay.html,1,['access'],['access']
Security,"lar region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.; the current function may be accessed in static C-like functions; when fitting or painting a function. void SetFitResult(const ROOT::Fit::FitResult& result, const Int_t* indpar = 0); Set the result from the fit; parameter values, errors, chi2, etc...; Optionally a pointer to a vector (with size fNpar) of the parameter indices in the FitResult can be passed; This is useful in the case of a combined fit with different functions, and the FitResult contains the global result; By default it is assume that indpar = {0,1,2,....,fNpar-1}. void SetMaximum(Double_t maximum = -1111); Set the maximum value along Y for this function; In case the function is already drawn, set also the maximum in the; helper histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value along Y for this function; In case the function is already drawn, set also the minimum in the; helper histogram. void SetNDF(Int_t ndf); Set the number of degrees of freedom; ndf should be the number of points used in a fit - the number of free parameters. void SetNpx(In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:59947,access,accessed,59947,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['access'],['accessed']
Security,"lass *cl) const;  Make sure all objects in this collection inherit from class cl. ;  ; TIter begin () const;  ; void Browse (TBrowser *b) override;  Browse this collection (called by TBrowser). ;  ; Int_t Capacity () const;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an collection using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TCollection objects. ;  ; Bool_t Contains (const char *name) const;  ; Bool_t Contains (const TObject *obj) const;  ; void Draw (Option_t *option="""") override;  Draw all objects in this collection. ;  ; void Dump () const override;  Dump all objects in this collection. ;  ; TIter end () const;  ; const char * GetName () const override;  Return name of this collection. ;  ; virtual Int_t GetSize () const;  Return the capacity of the collection, i.e. ;  ; virtual Int_t GrowBy (Int_t delta) const;  Increase the collection's capacity by delta slots. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsArgNull (const char *where, const TObject *obj) const;  Returns true if object is a null pointer. ;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsOwner () const;  ; Bool_t IsSortable () const override;  ; R__ALWAYS_INLINE Bool_t IsUsingRWLock () const;  ; void ls (Option_t *option="""") const override;  List (ls) all objects in this collection. ;  ; virtual TIterator * MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRefArray.html:6751,hash,hash,6751,doc/master/classRooRefArray.html,https://root.cern,https://root.cern/doc/master/classRooRefArray.html,4,['hash'],['hash']
Security,"lass * IsA () const override;  ; Bool_t IsValid () const;  ; void LatencyPlot (const char *wrks=0);  Show event processing or MB processing rate plot vs time Create the histograms. ;  ; void PrintFileInfo (const char *fn, const char *opt=""P"", const char *out=0);  Print information for file 'fn' (path including directory) or server 'fn'. ;  ; void PrintFileInfo (Int_t showlast=10, const char *opt="""", const char *out=0);  Print information for all or the slowest showlast workers. ;  ; void PrintWrkInfo (const char *wrk);  Print information for worker 'wn' (ordinal) or on the machine whose ordinal or fqdn matches 'wn'. ;  ; void PrintWrkInfo (Int_t showlast=10);  Print information for all or the slowest showlast workers. ;  ; void RatePlot (const char *wrks=0);  Show event processing or MB processing rate plot vs time. ;  ; void SetDebug (Int_t d=0);  Static setter for the verbosity level. ;  ; Int_t SetSaveResult (const char *file=""results.root"", Option_t *mode=""RECREATE"");  Set save result mode and validate 'file' according to 'mode'. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Summary (Option_t *opt="""", const char *out="""");  Print summary of query. ;  ; void WorkerActivity ();  Measure the worker activity. ;  ; Bool_t WrkInfoOK () const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPerfAnalysis.html:2605,validat,validate,2605,doc/master/classTProofPerfAnalysis.html,https://root.cern,https://root.cern/doc/master/classTProofPerfAnalysis.html,1,['validat'],['validate']
Security,"lass TVirtualStreamerInfo. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void TagFile (TFile *fFile)=0;  ; virtual void Update (const TClass *oldClass, TClass *newClass)=0;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualStreamerInfo.html:6937,hash,hash,6937,doc/master/classTVirtualStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTVirtualStreamerInfo.html,1,['hash'],['hash']
Security,"lass and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-14 16:45; This page has been automatically generated. For comments or sug",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMethodBrowsable.html:10419,access,access,10419,root/html534/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html534/TMethodBrowsable.html,2,['access'],['access']
Security,"lass and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or sug",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMethodBrowsable.html:10913,access,access,10913,root/html604/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html604/TMethodBrowsable.html,2,['access'],['access']
Security,"lass and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-30 15:21; This page has been automatically generated. For comments or sug",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMethodBrowsable.html:10913,access,access,10913,root/html602/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html602/TMethodBrowsable.html,2,['access'],['access']
Security,"lass and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-12-01 01:52; This page h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodBrowsable.html:10331,access,access,10331,root/html528/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html528/TMethodBrowsable.html,2,['access'],['access']
Security,"lass and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:35; This page h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMethodBrowsable.html:10400,access,access,10400,root/html530/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html530/TMethodBrowsable.html,2,['access'],['access']
Security,"lass and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08-16 11:52:09Z rdm $ » Last generated: 2011-11-03 20:20; This page h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMethodBrowsable.html:10400,access,access,10400,root/html532/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html,2,['access'],['access']
Security,"lass defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::EMemberSelection::kNoUsingDecls@ kNoUsingDecls; TDictionary::EMemberSelection::kOnlyUsingDecls@ kOnlyUsingDecls; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TDumpMembersDefinition TClass.cxx:554; TDumpMembers::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overridePrint value of member mname.Definition TClass.cxx:574; TDumpMembers::TDumpMembersTDumpMembers(bool noAddr)Definition TClass.cxx:557; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:555; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:348915,hash,hash,348915,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['hash'],['hash']
Security,"lass defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::EMemberSelection::kNoUsingDecls@ kNoUsingDecls; TDictionary::EMemberSelection::kOnlyUsingDecls@ kOnlyUsingDecls; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TDumpMembersDefinition TClass.cxx:621; TDumpMembers::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overridePrint value of member mname.Definition TClass.cxx:641; TDumpMembers::TDumpMembersTDumpMembers(bool noAddr)Definition TClass.cxx:624; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:622; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:351553,hash,hash,351553,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['hash'],['hash']
Security,"lass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClingCallbacksDefinition TClingCallbacks.h:41; TCling::SuspendAutoLoadingRAIIDefinition TCling.h:602; TCling::SuspendAutoLoadingRAII::~SuspendAutoLoadingRAII~SuspendAutoLoadingRAII()Definition TCling.h:608; TCling::SuspendAutoLoadingRAII::fTClingTCling * fTClingDefinition TCling.h:603; TCling::SuspendAutoLoadingRAII::fOldValuebool fOldValueDefinition TCling.h:604; TCling::SuspendAutoLoadingRAII::SuspendAutoLoadingRAIISuspendAutoLoadingRAII(TCling *tcling)Definition TCling.h:607; TCling::TUniqueStringDefinition TCling.h:611; TCling::TUniqueString::TUniqueStringTUniqueString(const TUniqueString &)=delete; TCling::TUniqueString::Dataconst char * Data()Definition TCling.cxx:1006; TCling::TUniqueString::Appendbool Append(const std::string &str)Append string to the storage if not added already.Definition TCling.cxx:1014; TCling::TUniqueString::TUniqueStringTUniqueString()=delete; TCling::TUniqueString::fHashFuncstd::hash< std::string > fHashFuncDefinition TCling.h:621; TCling::TUniqueString::fLinesHashSetstd::set< size_t > fLinesHashSetDefinition TCling.h:620; TCling::TUniqueString::fContentstd::string fContentDefinition TCling.h:619; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCling::DeepAutoLoadImplstatic Int_t DeepAutoLoadImpl(const char *cls, std::unordered_set< std::string > &visited, bool nameIsNormalized)Definition TCling.cxx:6204; TCling::MethodArgInfo_DefaultValueconst char * MethodArgInfo_DefaultValue(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9296; TCling::ClassInfo_IsScopedEnumbool ClassInfo_IsScopedEnum(ClassInfo_t *info) const finalDefinition TCling.cxx:8302; TCling::TypeInfo_Nameconst char * TypeInfo_Name(TypeInfo_t *) const finalDefinition TCling.cxx:9388; TCling::MethodInfo_InterfaceMethodvoid * MethodInfo_InterfaceMethod(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9050; TClin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:41849,hash,hash,41849,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['hash'],['hash']
Security,"lass is through; TFile::Open, for instance:. TFile* f1 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file""); TFile* f2 = TFile::Open(""gs://storage.googleapis.com/bucket/path/to/my/file""). The specified scheme (i.e. s3, s3http, s3https, ...) determines the underlying; transport protocol to use for downloading the file contents, namely HTTP or HTTPS.; The 's3', 's3https', 'gs' and 'gshttps' schemes imply using HTTPS as the transport; protocol. The 's3http', 'as3' and 'gshttp' schemes imply using HTTP as the transport; protocol. The 'options' argument can contain 'NOPROXY' if you want to bypass; the HTTP proxy when retrieving this file's contents. As for any TWebFile-derived; object, the URL of the web proxy can be specified by setting an environmental; variable 'http_proxy'. If this variable is set, we ask that proxy to route our; requests HTTP(S) requests to the file server. In addition, you can also use the 'options' argument to provide the access key; and secret key to be used for authentication purposes for this file by using a; string of the form ""AUTH=myAccessKey:mySecretkey"". This may be useful to; open several files hosted by different providers in the same program/macro,; where the environemntal variables solution is not convenient (see below). If you need to specify both NOPROXY and AUTH separate them by ' '; (blank), for instance:; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"". Examples:; TFile* f1 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f2 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");. If there is no authentication information in the 'options' argument; (i.e. not AUTH=""...."") the values of the environmental variables; S3_ACCESS_KEY and S3_SECRET_KEY (if set) are expected to contain; the access key id and the secret access k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:28192,access,access,28192,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,6,"['access', 'authenticat']","['access', 'authentication']"
Security,"lass member (or .?).\n""; 1259 "" Specifying '::Member' is optional."");; 1260 Printf("" .help edit : show line editing shortcuts (or .?)"");; 1261 Printf("" .license : show license"");; 1262 Printf("" .libraries : show loaded libraries"");; 1263 Printf("" .ls : list contents of current TDirectory"");; 1264 Printf("" .pwd : show current TDirectory, pad and style"");; 1265 Printf("" .quit (or .exit) : quit ROOT (long form of .q)"");; 1266 Printf("" .R [user@]host[:dir] [-l user] [-d dbg] [script] :\n""; 1267 "" launch process in a remote host"");; 1268 Printf("" .qqq : quit ROOT - mandatory"");; 1269 Printf("" .qqqqq : exit process immediately"");; 1270 Printf("" .qqqqqqq : abort process"");; 1271 Printf("" .which [file] : show path of macro file"");; 1272 Printf("" .![OS_command] : execute OS-specific shell command"");; 1273 Printf("" .!root -? : print ROOT usage (CLI options)"");; 1274 return;; 1275 } else {; 1276 // If the user wants to use the extended "".help scopeName"" command to access; 1277 // the online reference guide, we first check if the command starts correctly.; 1278 if ((!strippedCommand.BeginsWith("".help "")) && (!strippedCommand.BeginsWith("".? ""))) {; 1279 Error(""Help"", ""Unknown command!"");; 1280 return;; 1281 }; 1282 // We remove the command "".help"" or "".?"" from the TString.; 1283 if (strippedCommand.BeginsWith("".? "")) {; 1284 strippedCommand.Remove(0, 3);; 1285 } else {; 1286 strippedCommand.Remove(0, 5);; 1287 }; 1288 // We strip the command line after removing "".help"" or "".?"".; 1289 strippedCommand = strippedCommand.Strip(TString::kBoth);; 1290 ; 1291 if (strippedCommand == ""edit"") {; 1292 Printf(""\n ROOT terminal keyboard shortcuts (GNU-readline style)."");; 1293 #ifdef R__MACOSX; 1294 #define FOOTNOTE "" *""; 1295 Printf(""* Some of these commands might be intercepted by macOS predefined system shortcuts."");; 1296 // https://apple.stackexchange.com/questions/18043/how-can-i-make-ctrlright-left-arrow-stop-changing-desktops-in-lion; 1297 #else; 1298 #define FOOTNOTE """"; 1299 #endif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:50940,access,access,50940,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['access'],['access']
Security,"lass, a utility which allows to interact with data stored in TTrees following a functional-chain like approach.; ; import ROOT; ; def fill_tree(treeName, fileName):; """"""A simple helper function to fill a test tree: this makes the example stand-alone.""""""; df = ROOT.RDataFrame(10); df.Define(""b1"", ""static_cast<double>(rdfentry_)"")\; .Define(""b2"", ""static_cast<int>(rdfentry_ * rdfentry_)"").Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df001_introduction_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operations on the dataframe; # We now review some *actions* which can be performed on the data frame.; # Actions can be divided into instant actions (e. g. Foreach()) and lazy; # actions (e. g. Count()), depending on whether they trigger the event ; # loop immediately or only when one of the results is accessed for the ; # first time. Actions that return ""something"" either return their result ; # wrapped in a RResultPtr or in a RDataFrame.; # But first of all, let us we define now our cut-flow with two strings.; # Filters can be expressed as strings. The content must be C++ code. The; # name of the variables must be the name of the branches. The code is; # just-in-time compiled.; cutb1 = 'b1 < 5.'; cutb1b2 = 'b2 % 2 && b1 < 4.'; ; # `Count` action; # The `Count` allows to retrieve the number of the entries that passed the; # filters. Here we show how the automatic selection of the column kicks; # in in case the user specifies none.; entries1 = d.Filter(cutb1) \; .Filter(cutb1b2) \; .Count();; ; print('{} entries passed all filters'.format(entries1.GetValue())); ; entries2 = d.Filter(""b1 < 5."").Count();; print('{} entries passed all filters'.format(entries2.GetValue())); ; # `Min`, `Max` and `Mean` actions; # These actions allow to retrieve stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df001__introduction_8py.html:1396,access,accessed,1396,doc/master/df001__introduction_8py.html,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html,1,['access'],['accessed']
Security,"lass.h. ◆ ResetMenuList(). void TClass::ResetMenuList ; (; ). Resets the menu list to it's standard value. ; Definition at line 4243 of file TClass.cxx. ◆ SetCanSplit(). void TClass::SetCanSplit ; (; Int_t ; splitmode). Set the splitability of this class: . -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting.; 2: Disallow splitting of the class and splitting of any it's derived classes. . Definition at line 5658 of file TClass.cxx. ◆ SetClassSize(). void TClass::SetClassSize ; (; Int_t ; sizof). inlineprivate . Definition at line 307 of file TClass.h. ◆ SetClassVersion(). void TClass::SetClassVersion ; (; Version_t ; version). private . Private function. ; Set the class version for the 'class' represented by this TClass object. See the public interface: ROOT::ResetClassVersion defined in TClassTable.cxx; Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the I/O should use the TClass checksum to distinguish the layout of the class . Definition at line 5675 of file TClass.cxx. ◆ SetCollectionProxy(). void TClass::SetCollectionProxy ; (; const ROOT::Detail::TCollectionProxyInfo & ; info). Create the collection proxy object (and the streamer object) from using the information in the TCollectionProxyInfo. ; Definition at line 6244 of file TClass.cxx. ◆ SetContextMenuTitle(). void TClass::SetContextMenuTitle ; (; const char * ; title). Change (i.e. set) the title of the TNamed. ; Definition at line 6269 of file TClass.cxx. ◆ SetConvStreamerFunc(). void TClass::SetConvStreamerFunc ; (; ClassConvStreamerFunc_t ; strm). Set a wrapper/accessor function around this class custom conversion streamer. ; Definition at line 6945 of file TClass.cxx. ◆ SetCurrentStreamerInfo(). void TClass::SetCurrentStreamerInfo ; (; TVirtualStreamerInfo * ; info). Set pointer to current T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:114515,checksum,checksum,114515,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['checksum'],['checksum']
Security,"lass.h. ◆ ResetMenuList(). void TClass::ResetMenuList ; (; ). Resets the menu list to it's standard value. ; Definition at line 4310 of file TClass.cxx. ◆ SetCanSplit(). void TClass::SetCanSplit ; (; Int_t ; splitmode). Set the splitability of this class: . -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting.; 2: Disallow splitting of the class and splitting of any it's derived classes. . Definition at line 5725 of file TClass.cxx. ◆ SetClassSize(). void TClass::SetClassSize ; (; Int_t ; sizof). inlineprivate . Definition at line 307 of file TClass.h. ◆ SetClassVersion(). void TClass::SetClassVersion ; (; Version_t ; version). private . Private function. ; Set the class version for the 'class' represented by this TClass object. See the public interface: ROOT::ResetClassVersion defined in TClassTable.cxx; Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the I/O should use the TClass checksum to distinguish the layout of the class . Definition at line 5742 of file TClass.cxx. ◆ SetCollectionProxy(). void TClass::SetCollectionProxy ; (; const ROOT::Detail::TCollectionProxyInfo & ; info). Create the collection proxy object (and the streamer object) from using the information in the TCollectionProxyInfo. ; Definition at line 6311 of file TClass.cxx. ◆ SetContextMenuTitle(). void TClass::SetContextMenuTitle ; (; const char * ; title). Change (i.e. set) the title of the TNamed. ; Definition at line 6336 of file TClass.cxx. ◆ SetConvStreamerFunc(). void TClass::SetConvStreamerFunc ; (; ClassConvStreamerFunc_t ; strm). Set a wrapper/accessor function around this class custom conversion streamer. ; Definition at line 7012 of file TClass.cxx. ◆ SetCurrentStreamerInfo(). void TClass::SetCurrentStreamerInfo ; (; TVirtualStreamerInfo * ; info). Set pointer to current T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:114516,checksum,checksum,114516,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['checksum'],['checksum']
Security,"lassDef_StreamerNVirtual_b);  ; virtual int Symlink (const char *from, const char *to);  Create a symbolic link from file1 to file2. ;  ; virtual void Syslog (ELogLevel level, const char *mess);  Send mess to syslog daemon. ;  ; virtual const char * TempDirectory () const;  Return a user configured or systemwide directory to create temporary files in. ;  ; virtual FILE * TempFileName (TString &base, const char *dir=nullptr, const char *suffix=nullptr);  Create a secure temporary file by appending a unique 6 letter string to base. ;  ; virtual int Umask (Int_t mask);  Set the process file creation mode mask. ;  ; virtual const char * UnixPathName (const char *unixpathname);  Convert from a local pathname to a Unix pathname. ;  ; virtual int Unlink (const char *name);  Unlink, i.e. ;  ; virtual void Unload (const char *module);  Unload a shared library. ;  ; virtual void Unsetenv (const char *name);  Unset environment variable. ;  ; virtual int Utime (const char *file, Long_t modtime, Long_t actime);  Set the a files modification and access times. ;  ; virtual char * Which (const char *search, const char *file, EAccessMode mode=kFileExists);  Find location of file in a search path. ;  ; virtual const char * WorkingDirectory ();  Return working directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheSystem.html:19343,access,access,19343,doc/master/classTDCacheSystem.html,https://root.cern,https://root.cern/doc/master/classTDCacheSystem.html,2,['access'],['access']
Security,"late<class InputIterator > ;  SMatrix (InputIterator begin, unsigned int size, bool triang=false, bool lower=true);  Constructor with STL iterator interface. ;  ;  SMatrix (const SVector< T, D1 *(D2+1)/2 > &v, bool lower=true);  constructor of a symmetrix a matrix from a SVector containing the lower (upper) triangular part. ;  ;  SMatrix (const T &rhs);  Construct from a scalar value (only for size 1 matrices) ;  ; template<class M > ; SMatrix< T, D1, D2, R > & operator= (const M &rhs);  Assign from another compatible matrix. ;  ; SMatrix< T, D1, D2, R > & operator= (const SMatrix< T, D1, D2, R > &rhs);  ; template<class A , class R2 > ; SMatrix< T, D1, D2, R > & operator= (const Expr< A, T, D1, D2, R2 > &rhs);  Assign from a matrix expression. ;  ; SMatrix< T, D1, D2, R > & operator= (SMatrixIdentity);  Assign from an identity matrix. ;  ; SMatrix< T, D1, D2, R > & operator= (const T &rhs);  Assign from a scalar value (only for size 1 matrices) ;  ; — Access functions —; T apply (unsigned int i) const;  access the parse tree with the index starting from zero and following the C convention for the order in accessing the matrix elements. ;  ; const T * Array () const;  return read-only pointer to internal array ;  ; T * Array ();  return pointer to internal array ;  ; — STL-like interface —; The iterators access the matrix element in the order how they are stored in memory.; The C (row-major) convention is used, and in the case of symmetric matrices the iterator spans only the lower diagonal block. For example for a symmetric 3x3 matrices the order of the 6 elements \({a_0,...a_5}\) is: ; \[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \]. iterator begin ();  STL iterator interface. ;  ; iterator end ();  STL iterator interface. ;  ; const_iterator begin () const;  STL const_iterator interface. ;  ; const_iterator end () const;  STL const_iterator interface. ;  ; template<class InputIterator > ; void SetE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:3319,access,access,3319,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,2,['access'],"['access', 'accessing']"
Security,"ld look something like ""data/toymc_%04d.dat""; and should contain one integer field that encodes the sample serial number. When fitting only, data sets may optionally be read from ascii files, using the same file; pattern. Bool_t generateAndFit(Int_t nSamples, Int_t nEvtPerSample = 0, Bool_t keepGenData = kFALSE, const char* asciiFilePat = 0); Generate and fit 'nSamples' samples of 'nEvtPerSample' events.; If keepGenData is set, all generated data sets will be kept in memory and can be accessed; later via genData(). Data sets will be written out is ascii form if the pattern string is supplied.; The pattern, which is a template for sprintf, should look something like ""data/toymc_%04d.dat""; and should contain one integer field that encodes the sample serial number. Bool_t generate(Int_t nSamples, Int_t nEvtPerSample = 0, Bool_t keepGenData = kFALSE, const char* asciiFilePat = 0); Generate 'nSamples' samples of 'nEvtPerSample' events.; If keepGenData is set, all generated data sets will be kept in memory; and can be accessed later via genData(). Data sets will be written out in ascii form if the pattern string is supplied.; The pattern, which is a template for sprintf, should look something like ""data/toymc_%04d.dat""; and should contain one integer field that encodes the sample serial number. Bool_t fit(Int_t nSamples, const char* asciiFilePat); Fit 'nSamples' datasets, which are read from ASCII files. The ascii file pattern, which is a template for sprintf, should look something like ""data/toymc_%04d.dat""; and should contain one integer field that encodes the sample serial number. Bool_t fit(Int_t nSamples, TList& dataSetList); Fit 'nSamples' datasets, as supplied in 'dataSetList'. void resetFitParams(); Reset all fit parameters to the initial model; parameters at the time of the RooMCStudy constructor. RooFitResult* doFit(RooAbsData* genSample); Internal function. Performs actual fit according to specifications. RooFitResult* refit(RooAbsData* genSample = 0); Redo fit ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMCStudy.html:16741,access,accessed,16741,root/html526/RooMCStudy.html,https://root.cern,https://root.cern/root/html526/RooMCStudy.html,1,['access'],['accessed']
Security,"ld potentially result in wrong data being silently read in multi-thread runs when an input TChain contained more than one TTree coming from the same input file. More details are available at #7143.; The start-up time of event loops with large computation graphs with many just-in-time-compiled expressions (e.g. thousands of string Filters and Defines) has been greatly reduced. See the corresponding pull request for more details. The full list of bug fixes for this release is available below.; Distributed computing with RDataFrame; ROOT 6.24 introduces ROOT.RDF.Experimental.Distributed, an experimental python package that enhances RDataFrame with distributed computing capabilities. The new package allows distributing RDataFrame applications through one of the supported distributed backends. The package was designed so that different backends can be easily plugged in. Currently the Apache Spark backend is supported and support for Dask is coming soon. The backend submodules of this package expose their own RDataFrame objects. The only needed change in user code is to substitute ROOT.RDataFrame calls with such backend-specific RDataFrames. For example:; import ROOT. # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # It still accepts the same constructor arguments as traditional RDataFrame; df = RDataFrame(""mytree"",""myfile.root""). # Continue the application with the traditional RDataFrame API; The main goal of this package is to support running any RDataFrame application distributedly. Nonetheless, not all RDataFrame operations currently work with this package. The subset that is currently available is:. AsNumpy; Count; Define; Fill; Filter; Graph; Histo[1,2,3]D; Max; Mean; Min; Profile[1,2,3]D; Snapshot; Sum. with support for more operations coming in the future.; Any distributed RDataFrame backend inherits the dependencies of the underlying software needed to distribute the applications. The Spa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:10976,expose,expose,10976,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['expose'],['expose']
Security,"ldDecl &member, int printError);  GrabIndex returns a static string (so use it or copy it immediately, do not call GrabIndex twice in the same expression) containing the size of the array data member. ;  ; static llvm::cl::OptionCategory gRootclingOptions (""rootcling common options"");  ; bool HasPath (const std::string &name);  Check if file has a path. ;  ; void genreflex::header2outputName (std::string &fileName);  Replace the extension with ""_rflx.cpp"". ;  ; void genreflex::headers2outputsNames (const std::vector< std::string > &headersNames, std::vector< std::string > &ofilesnames);  Get a proper name for the output file. ;  ; static bool IncludeHeaders (const std::vector< std::string > &headers, cling::Interpreter &interpreter);  Includes all given headers in the interpreter. ;  ; bool InheritsFromTObject (const clang::RecordDecl *cl, const cling::Interpreter &interp);  ; bool InheritsFromTSelector (const clang::RecordDecl *cl, const cling::Interpreter &interp);  ; static bool InjectModuleUtilHeader (const char *argv0, TModuleGenerator &modGen, cling::Interpreter &interp, bool umbrella);  Write the extra header injected into the module: umbrella header if (umbrella) else content header. ;  ; int genreflex::invokeManyRootCling (const std::string &verbosity, const std::string &selectionFileName, const std::string &targetLibName, bool multiDict, const std::vector< std::string > &pcmsNames, const std::vector< std::string > &includes, const std::vector< std::string > &preprocDefines, const std::vector< std::string > &preprocUndefines, const std::vector< std::string > &warnings, const std::string &rootmapFileName, const std::string &rootmapLibName, bool interpreteronly, bool doSplit, bool isCxxmodule, bool writeEmptyRootPCM, bool selSyntaxOnly, bool noIncludePaths, bool noGlobalUsingStd, const std::vector< std::string > &headersNames, bool failOnWarnings, bool printRootclingInvocation, const std::string &outputDirName_const="""");  Get the right ofilenames and invoke se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx.html:21271,inject,injected,21271,doc/master/rootcling__impl_8cxx.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html,1,['inject'],['injected']
Security,"le (const char *title) override;  Change (i.e. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:14121,hash,hash,14121,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,3,['hash'],['hash']
Security,"le = df_available.Define(""twice"", ""col * 2""); 1629 ; 1630# Conversely, if we want to select the entries for which the column has missing; 1631# values, we do the following; 1632df_missingcol = df.FilterMissing(""col""); 1633# Following operations in the same branch of the computation graph clearly; 1634# cannot access that same column, since there would be no value to read; 1635df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); 1636\endcode; 1637 ; 1638\code{.cpp}; 1639ROOT::RDataFrame df{dataset};; 1640 ; 1641// Anytime an entry from ""col"" is missing, the entire entry will be filtered out; 1642auto df_available = df.FilterAvailable(""col"");; 1643auto df_twicecol = df_available.Define(""twice"", ""col * 2"");; 1644 ; 1645// Conversely, if we want to select the entries for which the column has missing; 1646// values, we do the following; 1647auto df_missingcol = df.FilterMissing(""col"");; 1648// Following operations in the same branch of the computation graph clearly; 1649// cannot access that same column, since there would be no value to read; 1650auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; 1651\endcode; 1652 ; 1653#### DefaultValueFor; 1654 ; 1655DefaultValueFor creates a node of the computation graph which just forwards the; 1656values of the columns necessary for other downstream nodes, when they are; 1657available. In case a value of the input column passed to this function is not; 1658available, the node will provide the default value passed to this function call; 1659instead. Example:; 1660 ; 1661\code{.py}; 1662df = ROOT.RDataFrame(dataset); 1663# Anytime an entry from ""col"" is missing, the value will be the default one; 1664default_value = ... # Some sensible default value here; 1665df = df.DefaultValueFor(""col"", default_value) ; 1666df = df.Define(""twice"", ""col * 2""); 1667\endcode; 1668 ; 1669\code{.cpp}; 1670ROOT::RDataFrame df{dataset};; 1671// Anytime an entry from ""col"" is missing, the value will be the defaul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:91870,access,access,91870,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,"le = nullptr;; if (getFile) {; // if the argument getFile =1 return the file ""hsimple.root""; // if the file does not exist, it is created; TString fullPath = dir+""hsimple.root"";; if (!gSystem->AccessPathName(fullPath,kFileExists)) {; hfile = TFile::Open(fullPath); //in $ROOTSYS/tutorials; if (hfile) return hfile;; }; //otherwise try $PWD/hsimple.root; if (!gSystem->AccessPathName(""hsimple.root"",kFileExists)) {; hfile = TFile::Open(""hsimple.root""); //in current dir; if (hfile) return hfile;; }; }; //no hsimple.root file found. Must generate it !; //generate hsimple.root in current directory if we have write access; if (gSystem->AccessPathName(""."",kWritePermission)) {; printf(""you must run the script in a directory with write access\n"");; return nullptr;; }; hfile = (TFile*)gROOT->FindObject(filename); if (hfile) hfile->Close();; hfile = new TFile(filename,""RECREATE"",""Demo ROOT file with histograms"");; ; // Create some histograms, a profile histogram and an ntuple; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; hpx->SetFillColor(48);; TH2F *hpxpy = new TH2F(""hpxpy"",""py vs px"",40,-4,4,40,-4,4);; TProfile *hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo ntuple"",""px:py:pz:random:i"");; ; gBenchmark->Start(""hsimple"");; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; c1->SetFillColor(42);; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(6);; c1->GetFrame()->SetBorderMode(-1);; ; ; // Fill histograms randomly; TRandom3 randomNum;; Float_t px, py, pz;; const Int_t kUPDATE = 1000;; for (Int_t i = 0; i < 25000; i++) {; randomNum.Rannor(px,py);; pz = px*px + py*py;; Float_t rnd = randomNum.Rndm();; hpx->Fill(px);; hpxpy->Fill(px,py);; hprof->Fill(px,pz);; ntuple->Fill(px,py,pz,rnd,i);; if (i && (i%kUPDATE) == 0) {; if (i == kUPDATE) hpx->Draw();; c1->Modified();; c1->Update();; if (gSystem->ProcessEvents()); break;; }; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8C.html:1862,access,access,1862,doc/master/hsimple_8C.html,https://root.cern,https://root.cern/doc/master/hsimple_8C.html,1,['access'],['access']
Security,"le Binary search tree including a volume search method. More...;  ; class  BinarySearchTreeNode;  Node for the BinarySearch or Decision Trees. More...;  ; class  BinaryTree;  Base class for BinarySearch and Decision Trees. More...;  ; class  CCPruner;  A helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) More...;  ; class  CCTreeWrapper;  ; class  ClassifierFactory;  This is the MVA factory. More...;  ; class  ClassInfo;  Class that contains all the information of a class. More...;  ; class  Config;  Singleton class for global configuration settings used by TMVA. More...;  ; class  Configurable;  ; class  ConvergenceTest;  Check for convergence. More...;  ; class  CostComplexityPruneTool;  A class to prune a decision tree using the Cost Complexity method. More...;  ; class  CrossEntropy;  Implementation of the CrossEntropy as separation criterion. More...;  ; class  CrossValidation;  Class to perform cross validation, splitting the dataloader into folds. More...;  ; class  CrossValidationFoldResult;  ; class  CrossValidationResult;  Class to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation. More...;  ; class  CvSplit;  ; class  CvSplitKFolds;  ; class  CvSplitKFoldsExpr;  ; class  DataInputHandler;  Class that contains all the data information. More...;  ; class  DataLoader;  ; class  DataSet;  Class that contains all the data information. More...;  ; class  DataSetFactory;  Class that contains all the data information. More...;  ; class  DataSetInfo;  Class that contains all the data information. More...;  ; class  DataSetManager;  Class that contains all the data information. More...;  ; class  DecisionTree;  Implementation of a Decision Tree. More...;  ; class  DecisionTreeNode;  ; struct  DeleteFunctor_t;  ; class  DTNodeTrainingInfo;  ; class  Envelope;  Abstract base class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA.html:1614,validat,validation,1614,doc/master/namespaceTMVA.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html,2,['validat'],['validation']
Security,"le TCollection.cxx. ◆ Rehash(). void THashTable::Rehash ; (; Int_t ; newCapacity, . Bool_t ; checkObjValidity = kTRUE . ). Rehash the hashtable. ; If the collision rate becomes too high (i.e. the average size of the linked lists become too long) then lookup efficiency decreases since relatively long lists have to be searched every time. To improve performance rehash the hashtable. This resizes the table to newCapacity slots and refills the table. Use AverageCollisions() to check if you need to rehash. Set checkObjValidity to kFALSE if you know that all objects in the table are still valid (i.e. have not been deleted from the system in the meanwhile). ; Definition at line 365 of file THashTable.cxx. ◆ Remove(). TObject * THashTable::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the hashtable. ; Implements TCollection.; Definition at line 417 of file THashTable.cxx. ◆ RemoveSlow(). TObject * THashTable::RemoveSlow ; (; TObject * ; obj). Remove object from the hashtable without using the hash value. ; Definition at line 442 of file THashTable.cxx. ◆ SetRehashLevel(). void THashTable::SetRehashLevel ; (; Int_t ; rehash). inline . Definition at line 80 of file THashTable.h. ◆ Streamer(). void THashTable::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TCollection. ◆ StreamerNVirtual(). void THashTable::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 82 of file THashTable.h. Friends And Related Symbol Documentation. ◆ THashTableIter. friend class THashTableIter. friend . Definition at line 37 of file THashTable.h. Member Data Documentation. ◆ fCont. TList** THashTable::fCont. private . Definition at line 40 of file THashTable.h. ◆ fEntries. Int_t THashTable::fEntries. private . Definition at line 41 of file THashTable.h. ◆ fRehashLevel. Int_t THashTable::fRehashLevel. private . Definition at line 43 of file THashTable.h. ◆ fU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:27939,hash,hashtable,27939,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,2,['hash'],"['hash', 'hashtable']"
Security,le TDSet.cxx. ◆ SplitEntryList(). void TDSet::SplitEntryList ; (; ). private . for browsing purposes ; Splits the main entry (or event) list into sub-lists for the elements of thet data set. ; Definition at line 1941 of file TDSet.cxx. ◆ StartViewer(). void TDSet::StartViewer ; (; ). virtual . Start the TTreeViewer on this TTree. ; Definition at line 1520 of file TDSet.cxx. ◆ Streamer(). void TDSet::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TDSet. ; Reimplemented from TObject.; Reimplemented in TDSetProxy.; Definition at line 1813 of file TDSet.cxx. ◆ StreamerNVirtual(). void TDSet::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 262 of file TDSet.h. ◆ Validate() [1/2]. void TDSet::Validate ; (; ). Validate the TDSet by opening files. ; Definition at line 1589 of file TDSet.cxx. ◆ Validate() [2/2]. void TDSet::Validate ; (; TDSet * ; dset). Validate the TDSet against another TDSet. ; Only validates elements in common from input TDSet. ; Definition at line 1668 of file TDSet.cxx. Member Data Documentation. ◆ fCurrent. TDSetElement* TDSet::fCurrent. protected . iterator on fElements ; Definition at line 182 of file TDSet.h. ◆ fDir. TString TDSet::fDir. protected . Definition at line 177 of file TDSet.h. ◆ fElements. THashList* TDSet::fElements. protected . Definition at line 180 of file TDSet.h. ◆ fEntryList. TObject* TDSet::fEntryList. private . Definition at line 168 of file TDSet.h. ◆ fIsTree. Bool_t TDSet::fIsTree. private . Definition at line 167 of file TDSet.h. ◆ fIterator. TIter* TDSet::fIterator. protected . Definition at line 181 of file TDSet.h. ◆ fObjName. TString TDSet::fObjName. protected . Definition at line 179 of file TDSet.h. ◆ fProofChain. TProofChain* TDSet::fProofChain. private . entry (or event) list for processing ; Definition at line 169 of file TDSet.h. ◆ fSrvMaps. TList* TDSet::fSrvMaps. protected . current element ; Definition at line 183 of file TDSet.h. ◆ fSrvMa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSet.html:29947,validat,validates,29947,doc/master/classTDSet.html,https://root.cern,https://root.cern/doc/master/classTDSet.html,1,['validat'],['validates']
Security,"le containing TTrees, TChains, or TNtuples and want to read the contents for use in your analysis code. This is commonly the case when you work with the result of the reconstruction software of your experiment (e.g. the combined ntuple in ATLAS). The following example code outlines the main steps (you can run it on the result of the tree1.C macro):; from ROOT import TFile. # open the file; myfile = TFile('tree1.root'). # retrieve the ntuple of interest; mychain = myfile.Get('t1'); entries = mychain.GetEntriesFast(). for jentry in xrange(entries):; # get the next tree in the chain and verify; ientry = mychain.LoadTree(jentry); if ientry < 0:; break. # copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; continue. # use the values directly from the tree; nEvent = int(mychain.ev); if nEvent<0:; continue. print(mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py); Access to arrays works the same way as access to single value tree elements, where the size of the array is determined by the number of values actually read from the file. For example:; # loop over array tree element; for d in mychain.mydoubles:; print(d). # direct access into an array tree element; i5 = mychain.myints[5]; 19.1.9.2 Writing a Tree; Writing a ROOT TTree in a Python session is a little convoluted, if only because you will need a C++ class to make sure that data members can be mapped, unless you are working with built-in types. Here is an example for working with the latter only:; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); The use of arrays is needed, because the pointer to the address of the object tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1069902,access,access,1069902,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"le precision. The metric used for all the LorentzVector is (-,-,-,+) .; 13.12.4.1 Constructors and Assignment; The following declarations are available:; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; Note that each type of vector is constructed by passing its coordinate representation, so a XYZTVector(1,2,3,4) is different from a PtEtaPhiEVector(1,2,3,4). In addition, the Vector classes can be constructed by any vector, which implements the accessors x(), y(), z() and t().; This can be another ROOT::Math::LorentzVector based on a different coordinate system or any vector of a different package, like the CLHEP HepLorentzVector that implements the required signature.; XYZTVector v1(1,2,3,4);; PtEtaPhiEVector v2(v1);; CLHEP::HepLorentzVector q(1,2,3,4);; XYZTVector v3(q);; 13.12.4.2 Coordinate Accessors; All the same coordinate accessors are available through the interface of ROOT::Math::LorentzVector. For example:; //returns cartesian components for the cartesian vector v1; v1.X(); v1.X(); v1.Z(); v1.T();; //returns cartesian components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); In addition, all 4 vector coordinates can be retrieved with the GetCoordinates method:; double d[4];; //fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e) components of v2; v2.GetCoordinates(d);; std::vector w(4);; //fill std::vector with (x,y,z,t); v1.GetCoordinates(w.begin(),w.end());; //components of v1; To get information on all the coordinate accessors see the ROOT::Math::LorentzVector reference documentation.; 13.12.4.3 Setter Methods; One can set only all the three coordinates via:; //sets the (x,y,z,t) for a XYZTVector; v1.SetCoordinates(c1,c2,c3,c4);; //sets pt,eta,phi,e ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:737370,access,accessors,737370,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessors']
Security,"le single-range requests instead. ; Reimplemented from TWebFile.; Definition at line 346 of file TS3WebFile.cxx. ◆ ReadBuffers(). Bool_t TS3WebFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). overridevirtual . Read the nbuf blocks described in arrays pos and len. ; The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 311 of file TS3WebFile.cxx. ◆ SetAccessKey(). void TS3WebFile::SetAccessKey ; (; const TString & ; accessKey). inlineprotected . Definition at line 83 of file TS3WebFile.h. ◆ SetMsgReadBuffer10(). void TS3WebFile::SetMsgReadBuffer10 ; (; const char * ; redirectLocation = nullptr, . Bool_t ; tempRedirect = kFALSE . ). overrideprotectedvirtual . Overwrites TWebFile::SetMsgReadBuffer10() for setting the HTTP GET request compliant to the authentication mechanism used by the S3 protocol. ; The GET request must contain an ""Authorization"" header with the signature of the request, generated using the user's secret access key. ; Reimplemented from TWebFile.; Definition at line 301 of file TS3WebFile.cxx. ◆ SetSecretKey(). void TS3WebFile::SetSecretKey ; (; const TString & ; secretKey). inlineprotected . Definition at line 84 of file TS3WebFile.h. ◆ Streamer(). void TS3WebFile::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a TFile object. ; Reimplemented from TFile. ◆ StreamerNVirtual(). void TS3WebFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 105 of file TS3WebFile.h. Member Data Documentation. ◆ fS3Request. TS3HTTPRequest TS3WebFile::fS3Request. protected . Definition at line 87 of file TS3WebFile.h. ◆ fUseMultiRange. Bool_t TS3WebFile::fUseMultiRange. protected . Definition at line 88 of file TS3WebFile.h. Libraries for TS3WebFile:. [legend",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:56162,authenticat,authentication,56162,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['authenticat'],['authentication']
Security,"le, to set the labels size on the palette axis do: hist->GetZaxis()->SetLabelSize().; WARNING: The palette axis is always drawn vertically. Setting the color palette; To change the color palette TStyle::SetPalette should be used, eg: gStyle->SetPalette(ncolors,colors);; For example the option COL draws a 2D histogram with cells represented by a box filled with a color index which is a function of the cell content. If the cell content is N, the color index used will be the color number in colors[N], etc. If the maximum cell content is greater than ncolors, all cell contents are scaled to ncolors.; If ncolors <= 0, a default palette (see below) of 50 colors is defined. This palette is recommended for pads, labels ...; if ncolors == 1 && colors == 0, then a Pretty Palette with a Spectrum Violet->Red is created with 50 colors. That's the default rain bow palette.; Other pre-defined palettes with 255 colors are available when colors == 0. The following value of ncolors give access to:; if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used.; If ncolors > 0 && colors == 0, the default palette is used with a maximum of ncolors.; The default palette defines:. index 0 to 9 : shades of grey; index 10 to 19 : shades of brown; index 20 to 29 : shades of blue; index 30 to 39 : shades of red; index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting the item colors in the VIEW menu of the canvas tool bar. The red, green, and blue components of a color can be changed thanks to TColor::SetRGB().; SinceROOT version 6.19/01; As default labels and ticks are d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:109728,access,access,109728,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['access'],['access']
Security,"le->SetPalette(100, MyPalette);; 308~~~; 309 ; 310As only one palette is active, one need to use `TExec` to be able to; 311display plots using different palettes on the same pad.; 312The tutorial multipalette.C illustrates this feature.; 313 ; 314Begin_Macro(source); 315../../../tutorials/graphs/multipalette.C; 316End_Macro; 317 ; 318\since **6.26:**; 319The function `TColor::CreateColorTableFromFile(""filename.txt"")` allows you to create a color; 320palette based on an input ASCII file. In contrast to `TColor::CreateGradientColorTable()`, here; 321the length (spacing) is constant and can not be tuned. There is no gradient being interpolated; 322between adjacent colors. The palette will contain the exact colors stored in the file, that; 323comprises one line per color in the format ""r g b"" as floats.; 324 ; 325\anchor C06; 326## High quality predefined palettes; 327\since **6.04:**; 32863 high quality palettes are predefined with 255 colors each.; 329 ; 330These palettes can be accessed ""by name"" with `gStyle->SetPalette(num)`.; 331`num` can be taken within the following enum:; 332 ; 333~~~ {.cpp}; 334kDeepSea=51, kGreyScale=52, kDarkBodyRadiator=53,; 335kBlueYellow= 54, kRainBow=55, kInvertedDarkBodyRadiator=56,; 336kBird=57, kCubehelix=58, kGreenRedViolet=59,; 337kBlueRedYellow=60, kOcean=61, kColorPrintableOnGrey=62,; 338kAlpine=63, kAquamarine=64, kArmy=65,; 339kAtlantic=66, kAurora=67, kAvocado=68,; 340kBeach=69, kBlackBody=70, kBlueGreenYellow=71,; 341kBrownCyan=72, kCMYK=73, kCandy=74,; 342kCherry=75, kCoffee=76, kDarkRainBow=77,; 343kDarkTerrain=78, kFall=79, kFruitPunch=80,; 344kFuchsia=81, kGreyYellow=82, kGreenBrownTerrain=83,; 345kGreenPink=84, kIsland=85, kLake=86,; 346kLightTemperature=87, kLightTerrain=88, kMint=89,; 347kNeon=90, kPastel=91, kPearl=92,; 348kPigeon=93, kPlum=94, kRedBlue=95,; 349kRose=96, kRust=97, kSandyTerrain=98,; 350kSienna=99, kSolar=100, kSouthWest=101,; 351kStarryNight=102, kSunset=103, kTemperatureMap=104,; 352kThermometer=105, k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:12143,access,accessed,12143,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['access'],['accessed']
Security,"le.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetBarOffsetvirtual void SetBarOffset(Float_t offset=0.25)Set the bar offset as fraction of the bin width for drawing mode ""B"".Definition TH1.h:364; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::SetBarWidthvirtual void SetBarWidth(Float_t width=0.5)Set the width of bars as fraction of the bin width for drawing mode ""B"".Definition TH1.h:365; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TLegend::AddEntryTLegendEntry * AddEntry(const TObject *obj, const char *label="""", Option_t *option=""lpf"")Add a new entry to this legend.Definition TLegend.cxx:320; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; AuthorRene Brun ; Definition in file hbars.C. tutorialshisthbars.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hbars_8C.html:5136,access,access,5136,doc/master/hbars_8C.html,https://root.cern,https://root.cern/doc/master/hbars_8C.html,2,['access'],['access']
Security,"le32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:12330,access,access,12330,root/html526/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"le::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:; canvas->Print(""Example.xml"");; 12 Trees; 12.1 Why Should You Use a Tree?; In the “Input/Output” chapter, we saw how objects can be saved in ROOT files. In case you want to store large quantities of same-class objects, ROOT has designed the TTree and TNtuple classes specifically for that purpose. The TTree class is optimized to reduce disk space and enhance access speed. A TNtuple is a TTree that is limited to only hold floating-point numbers; a TTree on the other hand can hold all kind of data, such as objects or arrays in addition to all the simple types.; When using a TTree, we fill its branch buffers with leaf data and the buffers are written to disk when it is full. Branches, buffers, and leafs, are explained a little later in this chapter, but for now, it is important to realize that each object is not written individually, but rather collected and written a bunch at a time.; This is where the TTree takes advantage of compression and will produce a much smaller file than if the objects were written individually. Since the unit to be compressed is a buffer, and the TTree contains many same-class objects, the header of the objects can be compressed.; The TTree reduces the header of each object, but it still contains the class name. Using compression, the class name of each same-class object has a good chance o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:519706,access,access,519706,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"le::WriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidDeclareOptions(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*fLoggermessage logger; Int_tfNparsnumber of parameters; const vector<TMVA::Interval*>fRangesallowed intervals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t Run(); estimator function interface for fitting. Double_t EstimatorFunction(vector<Double_t>& parameters); estimator function interface for fitting. virtual ~FitterBase(); {}. Double_t Run(). IFitterTarget& GetFitterTarget() const; { return fFitterTarget; }. Int_t GetNpars() const; accessor. { return fNpars; }. const char* GetName() const; remove namespace in name. { return fClassName; }. void DeclareOptions(); need to implement option declaration. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: FitterBase.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__FitterBase.html:7300,access,accessor,7300,root/html530/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html530/TMVA__FitterBase.html,1,['access'],['accessor']
Security,"le; ROOT::TSchemaRule::ReadRawFuncPtr_tfReadRawFuncPtr! Conversion function pointer for readraw rule; ROOT::TSchemaRule::RuleType_tfRuleTypeType of the rule; TStringfSourceSource data member string; TStringfSourceClassSource class; TObjArray*fSourceVect! Source data member vector (for searching purposes); TStringfTargetTarget data mamber string; TStringfTargetClassTarget class, this is the owner of this rule object.; TObjArray*fTargetVect! Target data member vector (for searching purposes); TStringfVersionSource version string; vector<pair<Int_t,Int_t> >*fVersionVect! Source version vector (for searching purposes). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSchemaRule(). virtual ~TSchemaRule(). TSchemaRule(const ROOT::TSchemaRule& rhs). void Clear(Option_t* = """"). Bool_t SetFromRule(const char* rule). const char * GetVersion() const. Bool_t SetVersion(const TString& version). Bool_t TestVersion(Int_t version) const. Bool_t SetChecksum(const TString& checksum). Bool_t TestChecksum(UInt_t checksum) const. void SetSourceClass(const TString& classname). const char * GetSourceClass() const. void SetTargetClass(const TString& classname). const char * GetTargetClass() const. void SetTarget(const TString& target). const TObjArray* GetTarget() const. const char * GetTargetString() const. void SetSource(const TString& source). const TObjArray* GetSource() const. void SetEmbed(Bool_t embed). Bool_t GetEmbed() const. Bool_t IsAliasRule() const. Bool_t IsRenameRule() const. Bool_t IsValid() const. void SetCode(const TString& code). const char * GetCode() const. void SetAttributes(const TString& attributes). const char * GetAttributes() const. Bool_t HasTarget(const TString& target) const. Bool_t HasSource(const TString& source) const. void SetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr). ReadFuncPtr_t GetReadFunctionPointer() const. void SetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr). ReadRawFuncPtr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TSchemaRule.html:9099,checksum,checksum,9099,root/html602/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html602/ROOT__TSchemaRule.html,2,['checksum'],['checksum']
Security,"leName = llvm::sys::path::filename(selected->GetSelFileName()).str();; 751 auto lineno = selected->GetLineNumber();; 752 auto rulesAreCompatible = SelectionRulesUtils::areEqual<ClassSelectionRule>(selected, previouslyMatchingRule, true /*moduloNameOrPattern*/);; 753 if (!rulesAreCompatible){; 754 std::stringstream message;; 755 if (lineno > 1) message << ""Selection file "" << cleanFileName << "", lines ""; 756 << lineno << "" and "" << previouslineno << "". "";; 757 message << ""Attempt to select a class ""<< normName << "" with two rules which have incompatible attributes. ""; 758 << ""The attributes such as transiency might not be correctly propagated to the typesystem of ROOT.\n"";; 759 selected->Print(message);; 760 message << ""Conflicting rule already matched:\n"";; 761 previouslyMatchingRule->Print(message);; 762 ROOT::TMetaUtils::Warning(nullptr,""%s\n"", message.str().c_str());; 763 }; 764 }; 765 }; 766 ; 767 fDeclSelRuleMap[recordDecl->getCanonicalDecl()] = selected;; 768 ; 769 if (!rcrdDeclNotAlreadySelected || fFirstPass); 770 return true;; 771 ; 772 // Before adding the decl to the selected ones, check its access.; 773 // We do not yet support I/O of private or protected classes.; 774 // See ROOT-7450.; 775 // Additionally, private declarations lead to uncompilable code, so just ignore (ROOT-9112).; 776 if (recordDecl->getAccess() == AS_private || recordDecl->getAccess() == AS_protected) {; 777 // Don't warn about types selected by ""everything in that file"".; 778 auto isFileSelection = selected->HasAttributeFileName() &&; 779 selected->HasAttributePattern() &&; 780 ""*"" == selected->GetAttributePattern();; 781 if (!isFileSelection) {; 782 std::string normName;; 783 TMetaUtils::GetNormalizedName(normName,; 784 recordDecl->getASTContext().getTypeDeclType(recordDecl),; 785 fInterpreter,; 786 fNormCtxt);; 787 auto msg = ""Class or struct %s was selected but its dictionary cannot be generated: ""; 788 ""this is a private or protected class and this is not supported. No direct "";",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Scanner_8cxx_source.html:27416,access,access,27416,doc/master/Scanner_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html,1,['access'],['access']
Security,"le_t TPad::GetXlowNDC ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 212 of file TPad.h. ◆ GetY1(). Double_t TPad::GetY1 ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 242 of file TPad.h. ◆ GetY2(). Double_t TPad::GetY2 ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 243 of file TPad.h. ◆ GetYlowNDC(). Double_t TPad::GetYlowNDC ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 213 of file TPad.h. ◆ HasCrosshair(). Bool_t TPad::HasCrosshair ; (; ); const. overridevirtual . Return kTRUE if the crosshair has been activated (via SetCrosshair). ; Implements TVirtualPad.; Definition at line 6642 of file TPad.cxx. ◆ HasFixedAspectRatio(). Bool_t TPad::HasFixedAspectRatio ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 270 of file TPad.h. ◆ Hash(). ULong_t TPad::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:86533,hash,hash,86533,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['hash'],['hash']
Security,"lean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceCalc; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_inlineMode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealMPFE.html:34630,access,access,34630,root/html534/RooRealMPFE.html,https://root.cern,https://root.cern/root/html534/RooRealMPFE.html,1,['access'],['access']
Security,"lean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:43001,access,access,43001,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,1,['access'],['access']
Security,"lean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMoment.html:34841,access,access,34841,root/html602/RooAbsMoment.html,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html,2,['access'],['access']
Security,lean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TMatrixDSym*_corrMat; TMatrixDSym*_covMat; Double_t_d; RooDataSet&_data; vector<vector<Double_t> >_dataPts; vector<TVectorD>_dataPtsR; RooArgSet_dataVars; Bool_t_debug; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; TVectorD*_dx; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_fixedShape; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooNDKeysPdf::BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Double_t_maxWeight; vector<Double_t>_mean; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_nEv,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:44378,access,access,44378,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,2,['access'],['access']
Security,"lean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSyst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:172356,access,accesstime,172356,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['access'],['accesstime']
Security,"leases resources for (or destroys) an object of a class. It is the opposite of a constructor that creates the object of a class when it is called. The compiler will provide a destructor that does nothing if none is provided. We will add one to our Quad class so that we can see when it is called. The class names the destructor but with a prefix ~ which is the C++ one’s complement i.e. bit wise complement, and hence has destruction overtones! We declare it in the .h file and define it in the .cxx file. It does not do much except print out that it has been called (still a useful debug technique despite today’s powerful debuggers!).; Now run root, load the Quad class and create a heap object:; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; To delete the object:; root[] delete my_objptr;; root[] my_objptr = 0;; You should see the print out from its destructor. Setting the pointer to zero afterwards is not strictly necessary (and Cling does it automatically), but the object is no more accessible, and any attempt to use the pointer again will, as has already been stated, cause grief. So much for heap objects, but how are stack objects deleted? In C++, a stack object is deleted as soon as control leaves the innermost compound statement that encloses it. Therefore, it is singularly futile to do something like:; root[] { Quad my_object(1.,2.,-3.); }; Cling does not follow this rule; if you type in the above line, you will not see the destructor message. As explained in the Script lesson, you can load in compound statements, which would be a bit pointless if everything disappeared as soon as it was loaded! Instead, to reset the stack you have to type:; root[] gROOT->Reset();; This sends the Reset message via the global pointer to the ROOT object, which, amongst its many roles, acts as a resource manager. Start ROOT again and type in the following:; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);; root[] Quad *my_objptr = new Quad(4.,5.,-6.);; root[] g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:254070,access,accessible,254070,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessible']
Security,"lection * TROOT::GetListOfProofs ; (; ); const. inline . Definition at line 253 of file TROOT.h. ◆ GetListOfSecContexts(). TSeqCollection * TROOT::GetListOfSecContexts ; (; ); const. inline . Definition at line 252 of file TROOT.h. ◆ GetListOfSockets(). TSeqCollection * TROOT::GetListOfSockets ; (; ); const. inline . Definition at line 239 of file TROOT.h. ◆ GetListOfSpecials(). TSeqCollection * TROOT::GetListOfSpecials ; (; ); const. inline . Definition at line 246 of file TROOT.h. ◆ GetListOfStreamerInfo(). TSeqCollection * TROOT::GetListOfStreamerInfo ; (; ); const. inline . Definition at line 249 of file TROOT.h. ◆ GetListOfStyles(). TSeqCollection * TROOT::GetListOfStyles ; (; ); const. inline . Definition at line 241 of file TROOT.h. ◆ GetListOfTasks(). TSeqCollection * TROOT::GetListOfTasks ; (; ); const. inline . Definition at line 247 of file TROOT.h. ◆ GetListOfTypes(). TCollection * TROOT::GetListOfTypes ; (; Bool_t ; load = kFALSE). Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ; The list is populated on demand. Calling gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the TDataType is not already in the list itself and the type does exist, a new TDataType will be created and added to the list.; Calling gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed through the list (plus the builtins types). ; Definition at line 1865 of file TROOT.cxx. ◆ GetMacroDir(). const TString & TROOT::GetMacroDir ; (; ). static . Get the macro directory in the installation. Static utility function. ; Definition at line 3094 of file TROOT.cxx. ◆ GetMacroPath(). const char * TROOT::GetMacroPath ; (; ). static . Get macro search path. Static utility function. ; Definition at line 2762 of file TROOT.cxx. ◆ GetNclasses(). Int_t TROOT::GetNclasses ; (; ); const. Get number of classes. ; Definition at line 1876 of file TROOT.cxx. ◆ Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:58885,access,access,58885,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,1,['access'],['access']
Security,"lection * TROOT::GetListOfProofs ; (; ); const. inline . Definition at line 253 of file TROOT.h. ◆ GetListOfSecContexts(). TSeqCollection * TROOT::GetListOfSecContexts ; (; ); const. inline . Definition at line 252 of file TROOT.h. ◆ GetListOfSockets(). TSeqCollection * TROOT::GetListOfSockets ; (; ); const. inline . Definition at line 239 of file TROOT.h. ◆ GetListOfSpecials(). TSeqCollection * TROOT::GetListOfSpecials ; (; ); const. inline . Definition at line 246 of file TROOT.h. ◆ GetListOfStreamerInfo(). TSeqCollection * TROOT::GetListOfStreamerInfo ; (; ); const. inline . Definition at line 249 of file TROOT.h. ◆ GetListOfStyles(). TSeqCollection * TROOT::GetListOfStyles ; (; ); const. inline . Definition at line 241 of file TROOT.h. ◆ GetListOfTasks(). TSeqCollection * TROOT::GetListOfTasks ; (; ); const. inline . Definition at line 247 of file TROOT.h. ◆ GetListOfTypes(). TCollection * TROOT::GetListOfTypes ; (; Bool_t ; load = kFALSE). Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ; The list is populated on demand. Calling gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the TDataType is not already in the list itself and the type does exist, a new TDataType will be created and added to the list.; Calling gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed through the list (plus the builtins types). ; Definition at line 1865 of file TROOT.cxx. ◆ GetMacroDir(). const TString & TROOT::GetMacroDir ; (; ). static . Get the macro directory in the installation. Static utility function. ; Definition at line 3098 of file TROOT.cxx. ◆ GetMacroPath(). const char * TROOT::GetMacroPath ; (; ). static . Get macro search path. Static utility function. ; Definition at line 2762 of file TROOT.cxx. ◆ GetNclasses(). Int_t TROOT::GetNclasses ; (; ); const. Get number of classes. ; Definition at line 1876 of file TROOT.cxx. ◆ Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:58854,access,access,58854,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,1,['access'],['access']
Security,"lection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TListOfEnums;  TListOfEnums (TClass *cl=nullptr);  Constructor. ;  ;  ~TListOfEnums () override;  Destructor. ;  ; TEnum * Find (DeclId_t id) const;  Return the TEnum corresponding to the Decl 'id' or NULL if it does not exist. ;  ; Bool_t IsLoaded () const;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; Bool_t IsAscending ();  ; TObject * Remove (const TObjLinkPtr_t &lnk);  ; void RemoveLast () override;  Remove the last object of the list. ;  ; virtual void Sort (Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnumsWithLock.html:4756,hash,hash,4756,doc/master/classTListOfEnumsWithLock.html,https://root.cern,https://root.cern/doc/master/classTListOfEnumsWithLock.html,1,['hash'],['hash']
Security,"lection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. Int_tfInnerLowWaterMarkinner node low water mark; Int_tfInnerMaxIndexmaximum inner node index; Int_tfLeafLowWaterMarkleaf low water mark; Int_tfLeafMaxIndexmaximum leaf index; Int_tfOrderthe order of the tree (should be > 2); Int_tfOrder2order*2+1 (assumes a memory access is; TBtNode*fRootroot node of btree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtree(int order); Create a B-tree of certain order (by default 3). ~TBtree(); Delete B-tree. Objects are not deleted unless the TBtree is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to B-tree. TObject * After(const TObject* obj) const; Cannot use this method since B-tree decides order. TObject * Before(const TObject* obj) const; May not use this method since B-tree decides order. void Clear(Option_t* option = """"); Remove all objects from B-tree. Does NOT delete objects unless the TBtree; is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from B-tree AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name (see object's GetName()).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBtree.html:16905,access,access,16905,root/html602/TBtree.html,https://root.cern,https://root.cern/root/html602/TBtree.html,2,['access'],['access']
Security,"led from SetEntryBase; 171 kExternalLoadTree, ///< User code called LoadTree directly.; 172 kMissingBranchFromTree ///< Missing expected branch when loading new tree; 173 };; 174 ; 175 static constexpr const char *const fgEntryStatusText[kEntryUnknownError + 1] = {; 176 ""valid entry"",; 177 ""the tree does not exist"",; 178 ""the tree entry number does not exist"",; 179 ""cannot access chain element"",; 180 ""problem in opening a chain's file"",; 181 ""problem reading dictionary info from tree"",; 182 ""last entry loop has reached its end"",; 183 ""one of the readers was not successfully initialized"",; 184 ""A friend with TTreeIndex doesn't have an entry for this index"",; 185 ""A branch was not found when switching to the next TTree in the chain"",; 186 ""LoadTree return less than -6, likely a 'newer' error code""};; 187 ; 188 TTreeReader();; 189 ; 190 TTreeReader(TTree *tree, TEntryList *entryList = nullptr, bool warnAboutLongerFriends = true,; 191 const std::vector<std::string> &suppressErrorsForMissingBranches = {});; 192 TTreeReader(const char* keyname, TDirectory* dir, TEntryList* entryList = nullptr);; 193 TTreeReader(const char *keyname, TEntryList *entryList = nullptr) : TTreeReader(keyname, nullptr, entryList) {}; 194 ; 195 ~TTreeReader() override;; 196 ; 197 void SetTree(TTree* tree, TEntryList* entryList = nullptr);; 198 void SetTree(const char* keyname, TEntryList* entryList = nullptr) {; 199 SetTree(keyname, nullptr, entryList);; 200 }; 201 void SetTree(const char* keyname, TDirectory* dir, TEntryList* entryList = nullptr);; 202 ; 203 bool IsChain() const { return TestBit(kBitIsChain); }; 204 ; 205 bool IsInvalid() const { return fLoadTreeStatus == kNoTree; }; 206 ; 207 TTree* GetTree() const { return fTree; }; 208 TEntryList* GetEntryList() const { return fEntryList; }; 209 ; 210 ///\{ \name Entry setters; 211 ; 212 /// Move to the next entry (or index of the TEntryList if that is set).; 213 ///; 214 /// \return false if the previous entry was already the last entry. Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:6562,access,access,6562,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['access'],['access']
Security,"legend]; Constructor & Destructor Documentation. ◆ TImagePlugin(). TImagePlugin::TImagePlugin ; (; const char * ; ext). inline . Definition at line 28 of file TImagePlugin.h. ◆ ~TImagePlugin(). TImagePlugin::~TImagePlugin ; (; ). inlineoverride . Definition at line 29 of file TImagePlugin.h. Member Function Documentation. ◆ Class(). static TClass * TImagePlugin::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TImagePlugin::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TImagePlugin::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 39 of file TImagePlugin.h. ◆ DeclFileName(). static const char * TImagePlugin::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 39 of file TImagePlugin.h. ◆ Hash(). ULong_t TImagePlugin::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TImagePlugin::HashULong_t Hash() const overrideReturn hash value for this object.Definition TImagePlugin.h:37; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTImagePlugin.html:11215,hash,hash,11215,doc/master/classTImagePlugin.html,https://root.cern,https://root.cern/doc/master/classTImagePlugin.html,1,['hash'],['hash']
Security,"lement::ESTLtypeTStreamerElement::kSTLset; static TStreamerElement::ESTLtypeTStreamerElement::kSTLstring; static TStreamerElement::ESTLtypeTStreamerElement::kSTLunorderedmap; static TStreamerElement::ESTLtypeTStreamerElement::kSTLunorderedmultimap; static TStreamerElement::ESTLtypeTStreamerElement::kSTLunorderedmultiset; static TStreamerElement::ESTLtypeTStreamerElement::kSTLunorderedset; static TStreamerElement::ESTLtypeTStreamerElement::kSTLvector; static TObject::(anonymous)TObject::kSingleKey; static TStreamerElement::(anonymous)TStreamerElement::kWholeObject; static TStreamerElement::(anonymous)TStreamerElement::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; UInt_t&fBaseCheckSum!checksum of the base class (used during memberwise streaming); TClass*fBaseClass!pointer to base class; Int_tfBaseVersionversion number of the base class (used during memberwise streaming); TClass*TStreamerElement::fClassObject!pointer to class of object; ClassConvStreamerFunc_tfConvStreamerFunc!Pointer to a wrapper around a custom convertion streamer member function.; TStringfErrorMsg!Error message in case of checksum/version mismatch.; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*fNewBaseClass!pointer to new base class if renamed; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; ClassStreamerFunc_tfStreamerFunc!Pointer to a wrapper around a custom strea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStreamerBase.html:9966,checksum,checksum,9966,root/html604/TStreamerBase.html,https://root.cern,https://root.cern/root/html604/TStreamerBase.html,1,['checksum'],['checksum']
Security,"lementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callbacks instead) and API functions like mg_send_file are not; 165 * available.; 166 * If NO_FILESYSTEM is set, NO_FILES must be set as well.; 167 */; 168#error ""Inconsistent build flags, NO_FILESYSTEMS requires NO_FILES""; 169#endif; 170 ; 171/* DTL -- including winsock2.h works better if lean and mean */; 172#if !defined(WIN32_LEAN_AND_MEAN); 173#define WIN32_LEAN_AND_MEAN; 174#endif; 175 ; 176#if defined(__SYMBIAN32__); 177/* According to https://en.wikipedia.org/wiki/Symbian#History,; 178 * Symbian is no longer maintained since 2014-01-01.; 179 * Support for Symbian has been removed from CivetWeb; 180 */; 181#error ""S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:6591,access,access,6591,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['access'],['access']
Security,"lements with STL iterator interface. ;  ; template<class InputIterator > ; void SetElements (InputIterator begin, unsigned int size, bool triang=false, bool lower=true);  Constructor with STL iterator interface. ;  ; — Operators —; bool operator== (const T &rhs) const;  element wise comparison ;  ; bool operator!= (const T &rhs) const;  element wise comparison ;  ; template<class R2 > ; bool operator== (const SMatrix< T, D1, D2, R2 > &rhs) const;  element wise comparison ;  ; bool operator!= (const SMatrix< T, D1, D2, R > &rhs) const;  element wise comparison ;  ; template<class A , class R2 > ; bool operator== (const Expr< A, T, D1, D2, R2 > &rhs) const;  element wise comparison ;  ; template<class A , class R2 > ; bool operator!= (const Expr< A, T, D1, D2, R2 > &rhs) const;  element wise comparison ;  ; bool operator> (const T &rhs) const;  element wise comparison ;  ; bool operator< (const T &rhs) const;  element wise comparison ;  ; template<class R2 > ; bool operator> (const SMatrix< T, D1, D2, R2 > &rhs) const;  element wise comparison ;  ; template<class R2 > ; bool operator< (const SMatrix< T, D1, D2, R2 > &rhs) const;  element wise comparison ;  ; template<class A , class R2 > ; bool operator> (const Expr< A, T, D1, D2, R2 > &rhs) const;  element wise comparison ;  ; template<class A , class R2 > ; bool operator< (const Expr< A, T, D1, D2, R2 > &rhs) const;  element wise comparison ;  ; const T & operator() (unsigned int i, unsigned int j) const;  read only access to matrix element, with indices starting from 0 ;  ; T & operator() (unsigned int i, unsigned int j);  read/write access to matrix element with indices starting from 0 ;  ; const T & At (unsigned int i, unsigned int j) const;  read only access to matrix element, with indices starting from 0. ;  ; T & At (unsigned int i, unsigned int j);  read/write access to matrix element with indices starting from 0. ;  ; SMatrixRow_const operator[] (unsigned int i) const;  read only access to matrix element, wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:5890,access,access,5890,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,3,['access'],['access']
Security,"len); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, one can access additional information,eg:; TFile f(""myfile.root"");; TList *list = f.GetStreamerInfoList();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the file. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void MakeFree(Long64_t first, Long64_t last); Mark unused bytes on the file.; The list of free segments is in the fFree linked list.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). void Map(); List the contents of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:30602,access,access,30602,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['access'],['access']
Security,"lename of the form:Definition TSystem.cxx:4258; TSystem::ConcatFileNamevirtual char * ConcatFileName(const char *dir, const char *name)Concatenate a directory and a file name. User must delete returned string.Definition TSystem.cxx:1071; TSystem::FindFilevirtual const char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1538; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::GetProcInfovirtual int GetProcInfo(ProcInfo_t *info) constReturns cpu and memory used by this process into the ProcInfo_t structure.Definition TSystem.cxx:2489; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::GetDynamicPathvirtual const char * GetDynamicPath()Return the dynamic path (used to find shared libraries).Definition TSystem.cxx:1795; TSystem::FindDynamicLibraryvirtual const char * FindDynamicLibrary(TString &lib, Bool_t quiet=kFALSE)Find a dynamic library using the system search paths.Definition TSystem.cxx:2034; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:481932,access,access,481932,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['access'],['access']
Security,"lename will be called nameoftree.C; The generated code includes the following:; Identification of the original Tree and Input file name,; Opening the Tree file,; Declaration of Tree variables,; Setting of branches addresses,; A skeleton for the entry loop. To use this function:. Open your Tree file (eg: TFile f(""myfile.root"");); T->MakeCode(""MyAnalysis.C"");. where T is the name of the TTree in file myfile.root and MyAnalysis.C the name of the file created by this function.; NOTE: Since the implementation of this function, a new and better function TTree::MakeClass() has been developed. ; Definition at line 6640 of file TTree.cxx. ◆ MakeProxy(). Int_t TTree::MakeProxy ; (; const char * ; proxyClassname, . const char * ; macrofilename = nullptr, . const char * ; cutfilename = nullptr, . const char * ; option = nullptr, . Int_t ; maxUnrolling = 3 . ). virtual . Generate a skeleton analysis class for this Tree using TBranchProxy. ; TBranchProxy is the base of a class hierarchy implementing an indirect access to the content of the branches of a TTree.; ""proxyClassname"" is expected to be of the form: [path/]fileprefix; The skeleton will then be generated in the file: fileprefix.h; located in the current directory or in 'path/' if it is specified. The class generated will be named 'fileprefix'; ""macrofilename"" and optionally ""cutfilename"" are expected to point to source files which will be included by the generated skeleton. Method of the same name as the file(minus the extension and path) will be called by the generated skeleton's Process method as follow: [if (cutfilename())] htemp->Fill(macrofilename());; ""option"" can be used select some of the optional features during the code generation. The possible options are:. nohist : indicates that the generated ProcessFill should not fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the system 'unroll' classes that are not split. Unrolling a class allows direct access to its data members (this emul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:175146,access,access,175146,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['access']
Security,"ler (protected). ;  ; void MakeZombie ();  . #include <TExMap.h>. Inheritance diagram for TExMap:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TExMap() [1/2]. TExMap::TExMap ; (; Int_t ; mapSize = 100). Create a TExMap. ; Definition at line 32 of file TExMap.cxx. ◆ TExMap() [2/2]. TExMap::TExMap ; (; const TExMap & ; map). Copy constructor. ; Definition at line 53 of file TExMap.cxx. ◆ ~TExMap(). TExMap::~TExMap ; (; ). Delete TExMap. ; Definition at line 80 of file TExMap.cxx. Member Function Documentation. ◆ Add() [1/2]. void TExMap::Add ; (; Long64_t ; key, . Long64_t ; value . ). inline . Definition at line 66 of file TExMap.h. ◆ Add() [2/2]. void TExMap::Add ; (; ULong64_t ; hash, . Long64_t ; key, . Long64_t ; value . ). Add an (key,value) pair to the table. The key should be unique. ; Definition at line 88 of file TExMap.cxx. ◆ AddAt(). void TExMap::AddAt ; (; UInt_t ; slot, . ULong64_t ; hash, . Long64_t ; key, . Long64_t ; value . ). Add an (key,value) pair to the table. ; The key should be unique. If the 'slot' is open, use it to store the value, otherwise revert to Add(hash,key,value) This is usually used in conjunction with GetValue with 3 parameters: if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {; ...; } else {; fMap->AddAt(slot,hash,key,value);; }; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. Definition at line 117 of file TExMap.cxx. ◆ Capacity(). Int_t TExMap::Capacity ; (; ); const. inline . Definition at line 69 of file TExMap.h. ◆ Class(). static TClass * TExMap::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TExMap::Class_Name ; (; ). static . ReturnsName of this cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExMap.html:12593,hash,hash,12593,doc/master/classTExMap.html,https://root.cern,https://root.cern/doc/master/classTExMap.html,1,['hash'],['hash']
Security,"lete;  ; const TNamed * constPtr (const char *stringPtr);  Return a unique TNamed pointer for given C++ string. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNameReg.html:2430,hash,hash,2430,doc/master/classRooNameReg.html,https://root.cern,https://root.cern/doc/master/classRooNameReg.html,1,['hash'],['hash']
Security,"level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). Example:. TSocket::CreateA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:20840,authenticat,authenticates,20840,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,5,['authenticat'],['authenticates']
Security,"le Tolerance () const;  absolute tolerance ;  . Protected Member Functions; bool CheckDimension () const;  ; bool CheckObjFunction () const;  ; MinimTransformFunction * CreateTransformation (std::vector< double > &startValues, const ROOT::Math::IMultiGradFunction *func=nullptr);  ; void SetFinalValues (const double *x, const MinimTransformFunction *func=nullptr);  ; void SetMinValue (double val);  . Private Attributes; std::map< unsigned int, std::pair< double, double > > fBounds;  map specifying the bound using as key the parameter index ;  ; unsigned int fDim;  ; double fMinVal;  ; std::vector< std::string > fNames;  ; const ROOT::Math::IMultiGenFunction * fObjFunc;  ; std::vector< double > fSteps;  ; std::vector< double > fValues;  ; std::vector< ROOT::Math::EMinimVariableType > fVarTypes;  vector specifying the type of variables ;  . Additional Inherited Members;  Protected Attributes inherited from ROOT::Math::Minimizer; MinimizerOptions fOptions;  minimizer options ;  ; int fStatus = -1;  status of minimizer ;  ; bool fValidError = false;  flag to control if errors have been validated (Hesse has been run in case of Minuit) ;  . #include <Math/BasicMinimizer.h>. Inheritance diagram for ROOT::Math::BasicMinimizer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ BasicMinimizer(). ROOT::Math::BasicMinimizer::BasicMinimizer ; (; ). Default constructor. ; Definition at line 43 of file BasicMinimizer.cxx. ◆ ~BasicMinimizer(). ROOT::Math::BasicMinimizer::~BasicMinimizer ; (; ). override . Destructor. ; Definition at line 59 of file BasicMinimizer.cxx. Member Function Documentation. ◆ CheckDimension(). bool ROOT::Math::BasicMinimizer::CheckDimension ; (; ); const. protected . Definition at line 247 of file BasicMinimizer.cxx. ◆ CheckObjFunction(). bool ROOT::Math::BasicMinimizer::CheckObjFunction ; (; ); const. protected . Definition at line 256 of file BasicMinimizer.cxx. ◆ Crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BasicMinimizer.html:11511,validat,validated,11511,doc/master/classROOT_1_1Math_1_1BasicMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BasicMinimizer.html,1,['validat'],['validated']
Security,"lgorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTNamespace for new ROOT classes and functions ;  ►NDetail;  ►NTDF;  CTCustomColumn;  CTCustomColumnBase;  CTFilter;  CTFilterBase;  CTLoopManager;  CTRange;  CTRangeBase;  CTBranchProxyBase class for all the proxy object ;  ►CTCollectionProxyInfo;  CAddress;  CEnvironSmall helper to save proxy environment in the event of recursive calls ;  CEnvironBase;  CInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CIteratorsSmall helper to implement the function to create,access and destroy iterators ;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValueSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< bool > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t > >;  CIterators;  ►CTSchemaRuleSet;  CTMatches;  ►NExecutorUtilsThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental;  ►NDetail;  CTHistBinIterIterates over the bins of a THist or THistImpl ;  CTHistBinPtrPoints to a histogram bin (or actually a THistBinRef) ;  CTHistBinRefRepresents a bin reference ;  CTHistBinS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:11343,access,accesses,11343,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['access'],['accesses']
Security,"libSRPAuth; is loaded. void SetKrb5AuthHook(Krb5Auth_t func); Set kerberos5 authorization function. Automatically called when; libKrb5Auth is loaded. void SetGlobusAuthHook(GlobusAuth_t func); Set Globus authorization function. Automatically called when; libGlobusAuth is loaded. Int_t SshError(const char* errfile); SSH error parsing: returns; 0 : no error or fatal; 1 : should retry (eg 'connection closed by remote host'). Int_t SshAuth(TString& user); SSH client authentication code. const char * GetSshUser(TString user) const; Method returning the user to be used for the ssh login.; Looks first at SSH.Login and finally at env USER.; If SSH.LoginPrompt is set to 'yes' it prompts for the 'login name'. Bool_t CheckHost(const char* Host, const char* host); Check if 'host' matches 'href':; this means either equal or ""containing"" it, even with wild cards *; in the first field (in the case 'href' is a name, ie not IP address); Returns kTRUE if the two matches. Int_t RfioAuth(TString& user); UidGid client authentication code.; Returns 0 in case authentication failed; 1 in case of success; <0 in case of system error. Int_t ClearAuth(TString& user, TString& passwd, Bool_t& pwhash); UsrPwd client authentication code.; Returns 0 in case authentication failed; 1 in case of success. THostAuth * GetHostAuth(const char* host, const char* user = """", Option_t* opt = ""R"", Int_t* Exact = 0); Sets fUser=user and search fgAuthInfo for the entry pertaining to; (host,user), setting fHostAuth accordingly.; If opt = ""P"" use fgProofAuthInfo list instead; If no entry is found fHostAuth is not changed. THostAuth * HasHostAuth(const char* host, const char* user, Option_t* opt = ""R""); Checks if a THostAuth with exact match for {host,user} exists; in the fgAuthInfo list; If opt = ""P"" use ProofAuthInfo list instead; Returns pointer to it or 0. void FileExpand(const char* fin, FILE* ftmp); Expands include directives found in fexp files; The expanded, temporary file, is pointed to by 'ftmp'; and shou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:17381,authenticat,authentication,17381,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,"libocci. pgsql; ON; PostgreSQL support, requires libpq. pythia6; ON; Pythia6 EG support, requires libPythia6. pythia6_nolink; OFF; Delayed linking of Pythia6 library. pythia8; ON; Pythia8 EG support, requires libPythia8. python; ON; Python ROOT bindings, requires python >= 2.2. qt. Qt graphics backend, requires libqt >= 4.8. qtgsi; *; GSI's Qt integration, requires libqt >= 4.8. roofit; *; Build the libRooFit advanced fitting package. root7; OFF; ROOT 7 support (read more). roottest; OFF; Include roottest in the test suit, if roottest exists in root or if it is a sibling directory. ruby; OFF; Ruby ROOT bindings, requires ruby >= 1.8. r; OFF; R ROOT bindings, requires R, Rcpp and RInside. rfio; ON; RFIO support, requires libshift from CASTOR >= 1.5.2. rpath; OFF; Set run-time library load path on executables and shared libraries (at installation area). runtime_cxxmodules; OFF; Enable runtime c++ modules. sapdb; ON; MaxDB/SapDB support, requires libsqlod and libsqlrte. shadowpw; ON; Shadow password support. shared; ON; Use shared 3rd party libraries if possible. soversion; OFF; Set version number in sonames (recommended). sqlite; ON; SQLite support, requires libsqlite3. srp; ON; SRP support, requires SRP source tree. ssl; ON; SSL encryption support, requires openssl. tbb; OFF; TBB multi-threading support, requires TBB. table; *; Build libTable contrib library. tcmalloc; OFF; Using the tcmalloc allocator. testing; OFF; Enable test suit of ROOT with CTest. thread; ON; Using thread library (cannot be disabled). tmva; ON; Build TMVA multi variate analysis library. unuran; *; UNURAN - package for generating non-uniform random numbers. vc; *; Vc adds a few new types for portable and intuitive SIMD programming. vdt; ON; VDT adds a set of fast and vectorisable mathematical functions. winrtdebug; OFF; Link against the Windows debug runtime library. xft; ON; Xft support (X11 antialiased fonts). xml; ON; XML parser interface. xrootd; ON; Build xrootd file server and its client (i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:12137,password,password,12137,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['password'],['password']
Security,"lic Member Functions;  TFileSysRoot (const char *name, TFileSysDB *parent);  ; void GetFullName (TString &fullname, Bool_t asIncluded) const override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THtml::TFileSysDir;  TFileSysDir (const char *name, TFileSysDir *parent);  ; const TList * GetFiles () const;  ; const TList * GetSubDirs () const;  ; void Recurse (TFileSysDB *db, const char *path);  Recursively fill entries by parsing the contents of path. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THtml::TFileSysEntry;  TFileSysEntry (const char *name, TFileSysDir *parent);  ;  ~TFileSysEntry () override;  ; Int_t GetLevel () const;  ; const char * GetName () const override;  Returns name of object. ;  ; TFileSysDir * GetParent () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml_1_1TFileSysRoot.html:1342,hash,hash,1342,doc/master/classTHtml_1_1TFileSysRoot.html,https://root.cern,https://root.cern/doc/master/classTHtml_1_1TFileSysRoot.html,1,['hash'],['hash']
Security,"lic Types; enum  EAuthType { kNoAuth; , kAmazon; , kGoogle; };  ; enum  EHTTPVerb { ;   kGET; , kPOST; , kPUT; , kDELETE; , ;   kHEAD; , kCOPY. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TS3HTTPRequest ();  ;  TS3HTTPRequest (const TS3HTTPRequest &m);  Copy constructor. ;  ;  TS3HTTPRequest (EHTTPVerb httpVerb, const TString &host, const TString &bucket, const TString &objectKey, EAuthType authType, const TString &accessKey, const TString &secretKey);  Default constructor. ;  ; virtual ~TS3HTTPRequest ();  ; const TString & GetAccessKey () const;  ; TString GetAuthType () const;  ; const TString & GetBucket () const;  ; const TString & GetHost () const;  ; EHTTPVerb GetHTTPVerb () const;  ; const TString & GetObjectKey () const;  ; TString GetRequest (TS3HTTPRequest::EHTTPVerb httpVerb, Bool_t appendCRLF=kTRUE);  Returns the HTTP request ready to be sent to the server. ;  ; const TString & GetSecretKey () const;  ; const TString & GetTimeStamp () const;  ; TClass * IsA () const override;  ; TS3HTTPRequest & SetAccessKey (const TString &accessKey);  ; TS3HTTPRequest & SetAuthKeys (const TString &accessKey, const TString &secretKey);  ; TS3HTTPRequest & SetAuthType (TS3HTTPRequest::EAuthType authType);  ; TS3HTTPRequest & SetBucket (const TString &bucket);  ; TS3HTTPRequest & SetHost (const TString &host);  ; TS3HTTPRequest & SetObjectKey (const TString ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3HTTPRequest.html:1425,access,accessKey,1425,doc/master/classTS3HTTPRequest.html,https://root.cern,https://root.cern/doc/master/classTS3HTTPRequest.html,1,['access'],['accessKey']
Security,"licitMT ; (; bool ; enabled). inlinevirtual . Definition at line 621 of file TTree.h. ◆ SetIOFeatures(). ROOT::TIOFeatures TTree::SetIOFeatures ; (; const ROOT::TIOFeatures & ; features). Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ; Returns all the newly-set IO settings. ; Definition at line 9120 of file TTree.cxx. ◆ SetMakeClass(). void TTree::SetMakeClass ; (; Int_t ; make). virtual . Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ; For MakeClass mode 0, the TTree expects the address where the data is stored to be set by either the user or the TTree to the address of a full object through the top level branch. For MakeClass mode 1, this address is expected to point to a numerical type or C-style array (variable or not) of numerical type, representing the primitive data members. The function's primary purpose is to allow the user to access the data directly with numerical type variable rather than having to have the original set of classes (or a reproduction thereof). ; Reimplemented in TChain.; Definition at line 9167 of file TTree.cxx. ◆ SetMaxEntryLoop(). virtual void TTree::SetMaxEntryLoop ; (; Long64_t ; maxev = kMaxEntries). inlinevirtual . Definition at line 623 of file TTree.h. ◆ SetMaxTreeSize(). void TTree::SetMaxTreeSize ; (; Long64_t ; maxsize = 100000000000LL). static . Set the maximum size in bytes of a Tree file (static function). ; The default size is 100000000000LL, ie 100 Gigabytes.; In TTree::Fill, when the file has a size > fgMaxTreeSize, the function closes the current file and starts writing into a new file with a name of the style ""file_1.root"" if the original requested file name was ""file.root"". ; Definition at line 9187 of file TTree.cxx. ◆ SetMaxVirtualSize(). virtual void TTree::SetMaxVirtualSize ; (; Long64_t ; size = 0). inlinevirtual . Definition at line 625 of file TTree.h. ◆ SetName(). void TTree::SetName ; (; const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:214035,access,access,214035,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['access'],['access']
Security,"licitMT ; (; bool ; enabled). inlinevirtual . Definition at line 661 of file TTree.h. ◆ SetIOFeatures(). ROOT::TIOFeatures TTree::SetIOFeatures ; (; const ROOT::TIOFeatures & ; features). Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ; Returns all the newly-set IO settings. ; Definition at line 9130 of file TTree.cxx. ◆ SetMakeClass(). void TTree::SetMakeClass ; (; Int_t ; make). virtual . Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ; For MakeClass mode 0, the TTree expects the address where the data is stored to be set by either the user or the TTree to the address of a full object through the top level branch. For MakeClass mode 1, this address is expected to point to a numerical type or C-style array (variable or not) of numerical type, representing the primitive data members. The function's primary purpose is to allow the user to access the data directly with numerical type variable rather than having to have the original set of classes (or a reproduction thereof). ; Reimplemented in TChain.; Definition at line 9177 of file TTree.cxx. ◆ SetMaxEntryLoop(). virtual void TTree::SetMaxEntryLoop ; (; Long64_t ; maxev = kMaxEntries). inlinevirtual . Definition at line 663 of file TTree.h. ◆ SetMaxTreeSize(). void TTree::SetMaxTreeSize ; (; Long64_t ; maxsize = 100000000000LL). static . Set the maximum size in bytes of a Tree file (static function). ; The default size is 100000000000LL, ie 100 Gigabytes.; In TTree::Fill, when the file has a size > fgMaxTreeSize, the function closes the current file and starts writing into a new file with a name of the style ""file_1.root"" if the original requested file name was ""file.root"". ; Definition at line 9197 of file TTree.cxx. ◆ SetMaxVirtualSize(). virtual void TTree::SetMaxVirtualSize ; (; Long64_t ; size = 0). inlinevirtual . Definition at line 665 of file TTree.h. ◆ SetName(). void TTree::SetName ; (; const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:216660,access,access,216660,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['access'],['access']
Security,"lidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TAuthenticate::ESecuritykKrb5; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TAuthenticate::ESecuritykRfio; static TAuthenticate::ESecuritykSRP; static TAuthenticate::ESecuritykSSH; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfDetailslogon details (method dependent ...); THostAuth*fHostAuthpointer to relevant authentication info; TStringfPasswduser's password; TStringfProtocolremote service (rootd, proofd); Bool_tfPwHashkTRUE if fPasswd is a passwd hash; Int_tfRSAKeyType of RSA key used; TStringfRemoteremote host to which we want to connect; Bool_tfSRPPwdkTRUE if fPasswd is a SRP passwd; TRootSecContext*fSecContextpointer to relevant sec context; TAuthenticate::ESecurityfSecurityactual logon security level; TSocket*fSocketconnection to remote daemon; Int_tfTimeOuttimeout flag; TStringfUseruser to be authenticated; Int_tfVersion0,1,2, ... accordingly to remote daemon version; static TList*fgAuthInfo; static TStringfgAuthMeth[6]; static Bool_tfgAuthReUsekTRUE is ReUse required; static Int_tfgAuthTOif > 0, timeout in sec; static TStringfgDefaultUserDefault user information; static TDatimefgExpDateExpiring date for new security contexts; static GlobusAuth_tfgGlobusAuthHook; static Krb5Auth_tfgKrb5AuthHook; static TStringfgKrb5PrincipalPrincipal for Krb5 ticket; static TDatimefgLastAuthrcTime of last reading of fgRootAuthrc; static Int_tfgLastErrorLast error code processed by AuthError(); static TStringfgPasswd; static TPluginHandler*fgPasswdDialogPasswd dialog GUI plugin; static Int_tfgProcessIDID of the main thread as unique identifier",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAuthenticate.html:9788,authenticat,authentication,9788,root/html602/TAuthenticate.html,https://root.cern,https://root.cern/root/html602/TAuthenticate.html,10,"['authenticat', 'hash', 'password', 'secur']","['authenticated', 'authentication', 'hash', 'password', 'security']"
Security,"lidate the TDSet by opening files. ;  ; void Validate (TDSet *dset);  Validate the TDSet against another TDSet. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSet.html:7527,hash,hash,7527,doc/master/classTDSet.html,https://root.cern,https://root.cern/doc/master/classTDSet.html,2,['hash'],['hash']
Security,"like this should appear:. Figure 2: Example of TBrowser at start-up time; On the left, in the ""ROOT Files"" folder, you can find the ROOT file you have opened and our EventTree. If you see EventTree;1 and EventTree: they are identical. The first one is the tree on disk, the second the one in memory. Click your way through the tree.; Draw the ""fPosZ"" values from the browser. You should obtain a result looking like this:. Figure 3: Distribution of ""fPosZ"" values; This graph is called a histogram: it counts occurrences, combining neighboring values into ""bins"". In this case we have 100 equally sized bins (the ""steps""), ranging from x=-74 to x=102. You can tell that there were about 500 particles with a fPosZ value around -11. Histograms are a very common way to visualize data, e.g. in high energy physics.; Now close the browser, quit and restart ROOT (to make sure everybody starts from the same point).; . ‹ Meet a TTree; up; Using TTree::Draw() to access a TTree ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tbrowser.html:3163,access,access,3163,d/accessing-ttree-tbrowser.html,https://root.cern,https://root.cern/d/accessing-ttree-tbrowser.html,1,['access'],['access']
Security,"lindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const Scalar[] src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11814,access,access,11814,root/html602/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,2,['access'],['access']
Security,"line . add one dim data with only coordinate and values ; Definition at line 254 of file FitData.h. ◆ Append(). void ROOT::Fit::FitData::Append ; (; unsigned int ; newPoints, . unsigned int ; dim = 1 . ). Definition at line 251 of file FitData.cxx. ◆ Coords(). const double * ROOT::Fit::FitData::Coords ; (; unsigned int ; ipoint); const. inline . return a pointer to the coordinates data for the given fit point ; Definition at line 236 of file FitData.h. ◆ GetCoordComponent(). const double * ROOT::Fit::FitData::GetCoordComponent ; (; unsigned int ; ipoint, . unsigned int ; icoord . ); const. inline . returns a single coordinate component of a point. ; This function is threadsafe in contrast to Coords(...) and can easily get vectorized by the compiler in loops running over the ipoint-index. ; Definition at line 219 of file FitData.h. ◆ GetCoordDataPtrs(). const std::vector< const double * > & ROOT::Fit::FitData::GetCoordDataPtrs ; (; ); const. inline . direct access to coord data ptrs ; Definition at line 329 of file FitData.h. ◆ InitCoordsVector(). void ROOT::Fit::FitData::InitCoordsVector ; (; ). inlineprotected . initializer routines to set the corresponding pointers right The vectors must NOT be resized after this initialization without setting the corresponding pointers in the same moment ( has to be an atomic operation in case of multithreading ). ; Definition at line 171 of file FitData.h. ◆ InitFromRange(). template<class Iterator > . void ROOT::Fit::FitData::InitFromRange ; (; Iterator ; dataItr). inlineprotected . Definition at line 190 of file FitData.h. ◆ NDim(). unsigned int ROOT::Fit::FitData::NDim ; (; ); const. inline . return coordinate data dimension ; Definition at line 301 of file FitData.h. ◆ NPoints(). unsigned int ROOT::Fit::FitData::NPoints ; (; ); const. inline . return number of fit points ; Definition at line 285 of file FitData.h. ◆ operator=(). FitData & ROOT::Fit::FitData::operator= ; (; const FitData & ; rhs). Definition at line 218 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitData.html:11380,access,access,11380,doc/master/classROOT_1_1Fit_1_1FitData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitData.html,1,['access'],['access']
Security,"line 100 of file THostAuth.cxx. ◆ CreateSecContext(). TRootSecContext * THostAuth::CreateSecContext ; (; const char * ; user, . const char * ; host, . Int_t ; meth, . Int_t ; offset, . const char * ; details, . const char * ; token, . TDatime ; expdate = kROOTTZERO, . void * ; ctx = nullptr, . Int_t ; key = -1 . ). Create a Security context and add it to local list Return pointer to it to be stored in TAuthenticate. ; Definition at line 723 of file THostAuth.cxx. ◆ DeActivate(). void THostAuth::DeActivate ; (; ). inline . Definition at line 84 of file THostAuth.h. ◆ DeclFileName(). static const char * THostAuth::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 111 of file THostAuth.h. ◆ Established(). TList * THostAuth::Established ; (; ); const. inline . Definition at line 100 of file THostAuth.h. ◆ GetDetails(). const char * THostAuth::GetDetails ; (; Int_t ; level). Return authentication details for specified level or """" if the specified level does not exist for this host. ; Definition at line 371 of file THostAuth.cxx. ◆ GetDetailsByIdx(). const char * THostAuth::GetDetailsByIdx ; (; Int_t ; idx); const. inline . Definition at line 89 of file THostAuth.h. ◆ GetFailure(). Int_t THostAuth::GetFailure ; (; Int_t ; idx); const. inline . Definition at line 81 of file THostAuth.h. ◆ GetHost(). const char * THostAuth::GetHost ; (; ); const. inline . Definition at line 92 of file THostAuth.h. ◆ GetMethod(). Int_t THostAuth::GetMethod ; (; Int_t ; idx); const. inline . Definition at line 70 of file THostAuth.h. ◆ GetServer(). Int_t THostAuth::GetServer ; (; ); const. inline . Definition at line 93 of file THostAuth.h. ◆ GetSuccess(). Int_t THostAuth::GetSuccess ; (; Int_t ; idx); const. inline . Definition at line 82 of file THostAuth.h. ◆ GetUser(). const char * THostAuth::GetUser ; (; ); const. inline . Definition at line 94 of file THostAuth.h. ◆ HasMethod(). Bool_t THostAuth::HasMethod ; (; Int_t ; level",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHostAuth.html:18817,authenticat,authentication,18817,doc/master/classTHostAuth.html,https://root.cern,https://root.cern/doc/master/classTHostAuth.html,1,['authenticat'],['authentication']
Security,"lines(conn, additional_headers);; 10124 }; 10125 ; 10126 /* Send all headers */; 10127 mg_response_header_send(conn);; 10128 ; 10129 if (!is_head_request) {; 10130#if defined(USE_ZLIB); 10131 if (allow_on_the_fly_compression) {; 10132 /* Compress and send */; 10133 send_compressed_data(conn, filep);; 10134 } else; 10135#endif; 10136 {; 10137 /* Send file directly */; 10138 send_file_data(conn, filep, r1, cl);; 10139 }; 10140 }; 10141 (void)mg_fclose(&filep->access); /* ignore error on read only file */; 10142}; 10143 ; 10144 ; 10145int; 10146mg_send_file_body(struct mg_connection *conn, const char *path); 10147{; 10148 struct mg_file file = STRUCT_FILE_INITIALIZER;; 10149 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 10150 return -1;; 10151 }; 10152 fclose_on_exec(&file.access, conn);; 10153 send_file_data(conn, &file, 0, INT64_MAX);; 10154 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 10155 return 0; /* >= 0 for OK */; 10156}; 10157#endif /* NO_FILESYSTEMS */; 10158 ; 10159 ; 10160#if !defined(NO_CACHING); 10161/* Return True if we should reply 304 Not Modified. */; 10162static int; 10163is_not_modified(const struct mg_connection *conn,; 10164 const struct mg_file_stat *filestat); 10165{; 10166 char etag[64];; 10167 const char *ims = mg_get_header(conn, ""If-Modified-Since"");; 10168 const char *inm = mg_get_header(conn, ""If-None-Match"");; 10169 construct_etag(etag, sizeof(etag), filestat);; 10170 ; 10171 return ((inm != NULL) && !mg_strcasecmp(etag, inm)); 10172 || ((ims != NULL); 10173 && (filestat->last_modified <= parse_date_string(ims)));; 10174}; 10175 ; 10176 ; 10177static void; 10178handle_not_modified_static_file_request(struct mg_connection *conn,; 10179 struct mg_file *filep); 10180{; 10181 char lm[64], etag[64];; 10182 ; 10183 if ((conn == NULL) || (filep == NULL)) {; 10184 return;; 10185 }; 10186 ; 10187 gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);; 10188 construct_etag(etag, sizeof(etag), &filep->stat);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:291992,access,access,291992,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"lines(conn, additional_headers);; 10125 }; 10126 ; 10127 /* Send all headers */; 10128 mg_response_header_send(conn);; 10129 ; 10130 if (!is_head_request) {; 10131#if defined(USE_ZLIB); 10132 if (allow_on_the_fly_compression) {; 10133 /* Compress and send */; 10134 send_compressed_data(conn, filep);; 10135 } else; 10136#endif; 10137 {; 10138 /* Send file directly */; 10139 send_file_data(conn, filep, r1, cl);; 10140 }; 10141 }; 10142 (void)mg_fclose(&filep->access); /* ignore error on read only file */; 10143}; 10144 ; 10145 ; 10146int; 10147mg_send_file_body(struct mg_connection *conn, const char *path); 10148{; 10149 struct mg_file file = STRUCT_FILE_INITIALIZER;; 10150 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 10151 return -1;; 10152 }; 10153 fclose_on_exec(&file.access, conn);; 10154 send_file_data(conn, &file, 0, INT64_MAX);; 10155 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 10156 return 0; /* >= 0 for OK */; 10157}; 10158#endif /* NO_FILESYSTEMS */; 10159 ; 10160 ; 10161#if !defined(NO_CACHING); 10162/* Return True if we should reply 304 Not Modified. */; 10163static int; 10164is_not_modified(const struct mg_connection *conn,; 10165 const struct mg_file_stat *filestat); 10166{; 10167 char etag[64];; 10168 const char *ims = mg_get_header(conn, ""If-Modified-Since"");; 10169 const char *inm = mg_get_header(conn, ""If-None-Match"");; 10170 construct_etag(etag, sizeof(etag), filestat);; 10171 ; 10172 return ((inm != NULL) && !mg_strcasecmp(etag, inm)); 10173 || ((ims != NULL); 10174 && (filestat->last_modified <= parse_date_string(ims)));; 10175}; 10176 ; 10177 ; 10178static void; 10179handle_not_modified_static_file_request(struct mg_connection *conn,; 10180 struct mg_file *filep); 10181{; 10182 char lm[64], etag[64];; 10183 ; 10184 if ((conn == NULL) || (filep == NULL)) {; 10185 return;; 10186 }; 10187 ; 10188 gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);; 10189 construct_etag(etag, sizeof(etag), &filep->stat);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:292025,access,access,292025,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"lisions () const;  ; void Clear (Option_t *option="""") override;  Remove all objects from the table. ;  ; Int_t Collisions (const char *name) const;  Returns the number of collisions for an object with a certain name (i.e. ;  ; Int_t Collisions (TObject *obj) const;  Returns the number of collisions for an object (i.e. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the table AND delete all heap based objects. ;  ; Bool_t Empty () const;  ; const TList * GetListForObject (const char *name) const;  Return the TList corresponding to object's name based hash value. ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the TList corresponding to object's hash value. ;  ; TObject ** GetObjectRef (const TObject *obj) const override;  Return address of pointer to obj. ;  ; Int_t GetRehashLevel () const;  ; Int_t GetSize () const override;  Return the capacity of the collection, i.e. ;  ; TClass * IsA () const override;  ; TIterator * MakeIterator (Bool_t dir=kIterForward) const override;  Returns a hash table iterator. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; void Print (Option_t *option, Int_t recurse) const override;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void Rehash (Int_t newCapacity, Bool_t checkObjValidity=kTRUE);  Rehash the hashtable. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the hashtable. ;  ; TObject * RemoveSlow (TObject *obj);  Remove object from the hashtable without using the hash value. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfTypes.html:2569,hash,hash,2569,doc/master/classTListOfTypes.html,https://root.cern,https://root.cern/doc/master/classTListOfTypes.html,1,['hash'],['hash']
Security,"list with authentication details. ;  ; static const char * GetAuthMethod (Int_t idx);  Static method returning the method corresponding to idx. ;  ; static Int_t GetAuthMethodIdx (const char *meth);  Static method returning the method index (which can be used to find the method in GetAuthMethod()). ;  ; static Bool_t GetAuthReUse ();  Static method returning the authentication reuse settings. ;  ; static Int_t GetClientProtocol ();  Static method returning supported client protocol. ;  ; static char * GetDefaultDetails (Int_t method, Int_t opt, const char *user);  Determine default authentication details for method 'sec' and user 'usr'. ;  ; static const char * GetDefaultUser ();  Static method returning the default user information. ;  ; static TDatime GetGlobalExpDate ();  Static method returning default expiring date for new validity contexts. ;  ; static Bool_t GetGlobalPwHash ();  Static method returning the global password hash flag. ;  ; static Bool_t GetGlobalSRPPwd ();  Static method returning the global SRP password flag. ;  ; static const char * GetGlobalUser ();  Static method returning the global user. ;  ; static GlobusAuth_t GetGlobusAuthHook ();  Static method returning the globus authorization hook (no longer supported) ;  ; static THostAuth * GetHostAuth (const char *host, const char *user="""", Option_t *opt=""R"", Int_t *Exact=nullptr);  Sets fUser=user and search fgAuthInfo for the entry pertaining to (host,user), setting fHostAuth accordingly. ;  ; static const char * GetKrb5Principal ();  Static method returning the principal to be used to init Krb5 tickets. ;  ; static Bool_t GetPromptUser ();  Static method returning the prompt user settings. ;  ; static TList * GetProofAuthInfo ();  Static method returning the list with authentication directives to be sent to proof. ;  ; static Int_t GetRSAInit ();  Static method returning the RSA initialization flag. ;  ; static const char * GetRSAPubExport (Int_t key=0);  Static method returning the RSA publi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:11850,password,password,11850,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['password'],['password']
Security,"lit category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. RooCmdArg_conflProtocol; RooCategory*_masterCat; map<RooAbsPdf*,ObjSplitRule>_pdfmap; map<RooAbsCategory*,std::list<const RooCatType*> >_restr; RooArgSet_usedSplitCats. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void print(); Print details of a validated build configuration. ObjBuildConfig(); {}. virtual ~ObjBuildConfig(); {}. » Last changed: Tue Mar 10 17:19:11 2015 » Last generated: 2015-03-10 17:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimWSTool__ObjBuildConfig.html:4398,validat,validated,4398,root/html534/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html534/RooSimWSTool__ObjBuildConfig.html,1,['validat'],['validated']
Security,"livery. Int_t TWebCanvas::fPaletteDelivery {1}. protected . ! colors palette delivery 0:never, 1:once, 2:always, 3:per subpad ; Definition at line 96 of file TWebCanvas.h. ◆ fPrimitivesMerge. Int_t TWebCanvas::fPrimitivesMerge {100}. protected . ! number of PS primitives, which will be merged together ; Definition at line 97 of file TWebCanvas.h. ◆ fProcessingData. Bool_t TWebCanvas::fProcessingData {kFALSE}. protected . ! flag used to prevent blocking methods when process data is invoked ; Definition at line 101 of file TWebCanvas.h. ◆ fReadOnly. Bool_t TWebCanvas::fReadOnly {kFALSE}. protected . !< configured display ; ! in read-only mode canvas cannot be changed from client side ; Definition at line 90 of file TWebCanvas.h. ◆ fStyleDelivery. Int_t TWebCanvas::fStyleDelivery {0}. protected . ! gStyle delivery to clients: 0:never, 1:once, 2:always ; Definition at line 95 of file TWebCanvas.h. ◆ fStyleHash. UInt_t TWebCanvas::fStyleHash {0}. protected . ! last hash of gStyle ; Definition at line 104 of file TWebCanvas.h. ◆ fStyleVersion. Long64_t TWebCanvas::fStyleVersion {0}. protected . ! current gStyle object version, checked every time when new snapshot created ; Definition at line 103 of file TWebCanvas.h. ◆ fTF1UseSave. Int_t TWebCanvas::fTF1UseSave {1}. protected . ! use save buffer for TF1/TF2, 0:off, 1:prefer, 2:force ; Definition at line 107 of file TWebCanvas.h. ◆ fTimer. TWebCanvasTimer* TWebCanvas::fTimer {nullptr}. protected . ! timer to submit control messages ; Definition at line 84 of file TWebCanvas.h. ◆ fUpdatedSignal. UpdatedSignal_t TWebCanvas::fUpdatedSignal. protected . ! signal emitted when canvas updated or state is changed ; Definition at line 111 of file TWebCanvas.h. ◆ fUsedObjs. std::map<TObject *,bool> TWebCanvas::fUsedObjs. protected . ! map of used objects during streaming ; Definition at line 94 of file TWebCanvas.h. ◆ fWebConn. std::vector<WebConn> TWebCanvas::fWebConn. protected . ! connections ; Definition at line 83 of file TWebCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:43831,hash,hash,43831,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['hash'],['hash']
Security,"ll base classes and add only those methods not already in the list (also protected and private ones).; once finished, loop over resulting list and remove all private and protected methods. . Definition at line 3845 of file TClass.cxx. ◆ GetListOfBases(). TList * TClass::GetListOfBases ; (; ). Return list containing the TBaseClass(es) of a class. ; Definition at line 3636 of file TClass.cxx. ◆ GetListOfDataMembers(). TList * TClass::GetListOfDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of a class. ; Definition at line 3770 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3686 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3798 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3827 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:82638,access,access,82638,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['access'],['access']
Security,"ll base classes and add only those methods not already in the list (also protected and private ones).; once finished, loop over resulting list and remove all private and protected methods. . Definition at line 3912 of file TClass.cxx. ◆ GetListOfBases(). TList * TClass::GetListOfBases ; (; ). Return list containing the TBaseClass(es) of a class. ; Definition at line 3703 of file TClass.cxx. ◆ GetListOfDataMembers(). TList * TClass::GetListOfDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of a class. ; Definition at line 3837 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3753 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3865 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3894 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:82639,access,access,82639,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,2,['access'],['access']
Security,"ll be overwritten. . UPDATE Open an existing file for writing. If no file exists, it is created. . READ Open an existing file for reading (default). . NET Used by derived remote file access classes, not a user callable option. . WEB Used by derived remote http access class, not a user callable option. . READ_WITHOUT_GLOBALREGISTRATION Used by TTreeProcessorMT, not a user callable option. . If option = """" (default), READ is assumed. The file can be specified as a URL of the form: file:///user/rdm/bla.root or file:/user/rdm/bla.root; The file can also be a member of an archive, in which case it is specified as: multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip archive or member 1 from the archive. For more on archive file support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any file, i.e. also non ROOT files, using: file.tar?filetype=raw; This is convenient because the many remote file access plugins allow easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and directories. There are no restrictions for the number of levels of directories. A ROOT file is designed such that one can write in the file in pure sequential mode (case of BATCH jobs). In this case, the file may be read sequentially again without using the file index written at the end of the file. In case of a job crash, all the information on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the possibility to delete existing objects and add new ones. When an object is deleted from the file, the freed space is added into the FREE linked list (fFree). The FREE list consists of a chain of consecutive free segments on the file. At the same time, the first 4 bytes of the freed record on the file are overwritten by GAPSIZE where GAPSIZE = -(Numb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:49253,access,access,49253,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,4,['access'],['access']
Security,"ll check index values and it will assert if they are wrong; 365 */; 366 T& At(unsigned int i, unsigned int j);; 367 ; 368 ; 369 // helper class for implementing the m[i][j] operator; 370 ; 371 class SMatrixRow {; 372 public:; 373 SMatrixRow ( SMatrix<T,D1,D2,R> & rhs, unsigned int i ) :; 374 fMat(&rhs), fRow(i); 375 {}; 376 T & operator[](int j) { return (*fMat)(fRow,j); }; 377 private:; 378 SMatrix<T,D1,D2,R> * fMat;; 379 unsigned int fRow;; 380 };; 381 ; 382 class SMatrixRow_const {; 383 public:; 384 SMatrixRow_const ( const SMatrix<T,D1,D2,R> & rhs, unsigned int i ) :; 385 fMat(&rhs), fRow(i); 386 {}; 387 ; 388 const T & operator[](int j) const { return (*fMat)(fRow, j); }; 389 ; 390 private:; 391 const SMatrix<T,D1,D2,R> * fMat;; 392 unsigned int fRow;; 393 };; 394 ; 395 /**; 396 read only access to matrix element, with indices starting from 0 : m[i][j]; 397 */; 398 SMatrixRow_const operator[](unsigned int i) const { return SMatrixRow_const(*this, i); }; 399 /**; 400 read/write access to matrix element with indices starting from 0 : m[i][j]; 401 */; 402 SMatrixRow operator[](unsigned int i) { return SMatrixRow(*this, i); }; 403 ; 404 ; 405 /**; 406 addition with a scalar; 407 */; 408 SMatrix<T,D1,D2,R>&operator+=(const T& rhs);; 409 ; 410 /**; 411 addition with another matrix of any compatible representation; 412 */; 413 template <class R2>; 414 SMatrix<T,D1,D2,R>&operator+=(const SMatrix<T,D1,D2,R2>& rhs);; 415 ; 416 /**; 417 addition with a compatible matrix expression; 418 */; 419 template <class A, class R2>; 420 SMatrix<T,D1,D2,R>& operator+=(const Expr<A,T,D1,D2,R2>& rhs);; 421 ; 422 /**; 423 subtraction with a scalar; 424 */; 425 SMatrix<T,D1,D2,R>& operator-=(const T& rhs);; 426 ; 427 /**; 428 subtraction with another matrix of any compatible representation; 429 */; 430 template <class R2>; 431 SMatrix<T,D1,D2,R>&operator-=(const SMatrix<T,D1,D2,R2>& rhs);; 432 ; 433 /**; 434 subtraction with a compatible matrix expression; 435 */; 436 template <class A, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SMatrix_8h_source.html:13473,access,access,13473,doc/master/SMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html,1,['access'],['access']
Security,"ll necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< bool > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t > >;  CIterators;  ►CTSchemaRuleSet;  CTMatches;  ►NExecutorUtils;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental;  ►NDetail;  CTHistBinIterIterates over the bins of a THist or THistImpl ;  CTHistBinPtrPoints to a histogram bin (or actually a THistBinRef) ;  CTHistBinRefRepresents a bin reference ;  CTHistBinStatConst view on a bin's statistical data ;  CTHistDataA THistImplBase's data, provides accessors to all its statistics ;  CTHistImpl;  CTHistImplBaseInterface class for THistImpl ;  CTHistImplPrecisionAgnosticBaseBase class for THistImplBase that abstracts out the histogram's PRECISION ;  ►NInternal;  CAxisConfigToTypeConverts a TAxisConfig of whatever kind to the corresponding TAxisBase-derived object ;  CAxisConfigToType< TAxisConfig::kEquidistant >;  CAxisConfigToType< TAxisConfig::kGrow >;  CAxisConfigToType< TAxisConfig::kIrregular >;  CAxisConfigToType< TAxisConfig::kLabels >;  CTDirectoryEntry;  CTDrawableBase class for drawable entities: objects that can be painted on a TPad ;  CTFillBinCoordFill coord with low bin edge or center or high bin edge of all axes ;  CTFillBinCoord<-1, COORD, AXES >;  CTFillIterRangeFill range with begin() and end() of all axes, including under/overflow as specified by over ;  CTFillIterRange<-1, AXES >;  CTGetBinCount;  CTGetBinCount< 0, AXES >;  CTGetBinIndex;  CTGetBinIndex< -1, HISTIMPL, AXES, GROW >;  CTHistBufferedFillBase;  CTHistDra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:11854,access,accessors,11854,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['access'],['accessors']
Security,"ll need an environment variable called ROOTSYS, which holds the path of the top ROOT directory.; > echo $ROOTSYS; /opt/root; In the ROOTSYS directory are examples, executables, tutorials, header tutorials files, and, if you opted to download it, the source is here. The directories of special interest to us are bin, tutorials, lib, test, andinclude. The next figure shows the contents of these directories. ROOT framework directories. 1.6.1 $ROOTSYS/bin; The bin directory contains several executables. root; shows the ROOT splash screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe directly. rootcling; is the utility ROOT uses to create a class dictionary for Cling. rmkdepend; a modified version of makedepend that is used by the ROOT build system. root-config; a script returning the needed compile flags and libraries for projects that compile and link with ROOT. proofd; a small daemon used to authenticate a user of ROOT parallel processing capability (PROOF). proofserv; the actual PROOF process, which is started by proofd after a user, has successfully been authenticated. rootd; is the daemon for remote ROOT file access (see the TNetFile). 1.6.2 $ROOTSYS/lib; There are several ways to use ROOT, one way is to run the executable by typing root at the system prompt another way is to link with the ROOT libraries and make the ROOT classes available in your own program.; Here is a short description of the most relevant libraries, the ones marked with a * are only installed when the options specified them. libAsImage is the image manipulation library; libCling is the C++ interpreter (Cling); libCore is the Base classes; libEG is the abstract event generator interface classes; *libEGPythia is the Pythia5 event generator interface; *libEGPythia6 is the Pythia6 event generator interface; libFitPanel contains the GUI used for fitting; libGed contains the GUI used for editing the properties of histogram",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:17408,authenticat,authenticate,17408,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['authenticat'],['authenticate']
Security,"ll; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetFile(); TNetFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:2051,authenticat,authentication,2051,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,4,['authenticat'],['authentication']
Security,"ll; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetSystem(Bool_t ftpowner = kTRUE); TNetSystem(const char* url, Bool_t ftpowner = kTRUE); virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNetSystem.html:2059,authenticat,authentication,2059,root/html530/TNetSystem.html,https://root.cern,https://root.cern/root/html530/TNetSystem.html,3,['authenticat'],['authentication']
Security,"ll; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetSystem(Bool_t ftpowner = kTRUE); TNetSystem(const char* url, Bool_t ftpowner = kTRUE); virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::Anno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetSystem.html:2059,authenticat,authentication,2059,root/html528/TNetSystem.html,https://root.cern,https://root.cern/root/html528/TNetSystem.html,1,['authenticat'],['authentication']
Security,"ll; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetFile.html:2051,authenticat,authentication,2051,root/html602/TNetFile.html,https://root.cern,https://root.cern/root/html602/TNetFile.html,2,['authenticat'],['authentication']
Security,"ll; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetSystem.html:2059,authenticat,authentication,2059,root/html602/TNetSystem.html,https://root.cern,https://root.cern/root/html602/TNetSystem.html,2,['authenticat'],['authentication']
Security,"llHistosAndFit.C Read n-tuples in distinct workers, fill histograms, merge them and fit ;  mt103_fillNtupleFromMultipleThreads.C Fill the same TNtuple from different threads ;  mt201_parallelHistoFill.C Parallel fill of a histogram ;  mt301_TTaskGroupSimple.C Shows how to run items of work asynchronously with a TTaskGroup ;  mt302_TTaskGroupNested.C Calculate Fibonacci numbers exploiting nested parallelism through TTaskGroup ;  mt304_fillHistos.CFill histograms in parallel with automatic binning ;  mtbb001_fillHistos.C Fill histograms in parallel and write them on file ;  mtbb101_fillNtuples.C Fill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.C Parallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:138501,authenticat,authentication,138501,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['authenticat'],['authentication']
Security,"llTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:11105,validat,validationSample,11105,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,2,['validat'],['validationSample']
Security,"llections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWriteCurrentRecurse;; 73 std::atomic<size_t> fReadCurrentRecurse;; 74 std::unordered_multiset<std::thread::id> fReadSet;; 75 std::atomic_flag fSpinLockFlag;; 76 ; 77 void Lock(const TCollection *collection, const char *function);; 78 ; 79 void Unlock();; 80 ; 81 void ReadLock(const TCollection *collection, const char *function);; 82 ; 83 void ReadUnlock();; 84 ; 85 void ConflictReport(std::thread::id holder, const char *accessty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:1900,access,access,1900,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['access'],['access']
Security,"lled in parallel with a multiprocess approach ;  mp_H1_lambdas.C Lambdas used to check and fit the result of the H1 analysis ;  mt001_fillHistos.CFill histograms in parallel and write them on file ;  mt101_fillNtuples.CFill n-tuples in distinct workers ;  mt102_readNtuplesFillHistosAndFit.CRead n-tuples in distinct workers, fill histograms, merge them and fit ;  mt103_fillNtupleFromMultipleThreads.CFill the same TNtuple from different threads ;  mt201_parallelHistoFill.CParallel fill of a histogram ;  mtbb001_fillHistos.CFill histograms in parallel and write them on file ;  mtbb101_fillNtuples.CFill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.CParallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:135411,authenticat,authentication,135411,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['authenticat'],['authentication']
Security,"lled only after fitting and when a minimizer supporting the Hessian calculations is used otherwise an error (false) is returned. ; A new FitResult with the Hessian result will be produced ; Definition at line 530 of file Fitter.cxx. ◆ CalculateMinosErrors(). bool ROOT::Fit::Fitter::CalculateMinosErrors ; (; ). perform an error analysis on the result using MINOS To be called only after fitting and when a minimizer supporting MINOS is used otherwise an error (false) is returned. ; The result will be appended in the fit result class Optionally a vector of parameter indices can be passed for selecting the parameters to analyse using FitConfig::SetMinosErrors ; Definition at line 593 of file Fitter.cxx. ◆ Config() [1/2]. FitConfig & ROOT::Fit::Fitter::Config ; (; ). inline . access to the configuration (non const method) ; Definition at line 427 of file Fitter.h. ◆ Config() [2/2]. const FitConfig & ROOT::Fit::Fitter::Config ; (; ); const. inline . access to the fit configuration (const method) ; Definition at line 422 of file Fitter.h. ◆ DoBinnedLikelihoodFit(). bool ROOT::Fit::Fitter::DoBinnedLikelihoodFit ; (; bool ; extended = true, . const ROOT::EExecutionPolicy & ; executionPolicy = ROOT::EExecutionPolicy::kSequential . ). protected . binned likelihood fit ; Definition at line 360 of file Fitter.cxx. ◆ DoInitMinimizer(). bool ROOT::Fit::Fitter::DoInitMinimizer ; (; ). protected . Definition at line 692 of file Fitter.cxx. ◆ DoLeastSquareFit(). bool ROOT::Fit::Fitter::DoLeastSquareFit ; (; const ROOT::EExecutionPolicy & ; executionPolicy = ROOT::EExecutionPolicy::kSequential). protected . least square fit ; Definition at line 309 of file Fitter.cxx. ◆ DoLinearFit(). bool ROOT::Fit::Fitter::DoLinearFit ; (; ). protected . linear least square fit ; Definition at line 513 of file Fitter.cxx. ◆ DoMinimization() [1/2]. bool ROOT::Fit::Fitter::DoMinimization ; (; const ROOT::Math::IMultiGenFunction * ; chifunc = nullptr). protected . Definition at line 795 of file Fitter.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:18574,access,access,18574,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['access'],['access']
Security,"lling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode).; ; 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:; TKDtree is optimized to minimize memory consumption. Nodes of the TKDTree do not store pointers to the left and right children or to the parent node, but instead there are several 1-d arrays of size fNNodes with information about the nodes. The order of the nodes information in the arrays is described below. It's important to understand it, if one's class needs to store some kind of additional information on the per node basis, for example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on that axis to divide the remaining points approximately in half. The exact algorithm for choosing the division point is described in the next section. The sequence of divisions is recorded in the following arrays: fAxis[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; TKDTree::fValueValue * fValue[fNNodes] nodes cutting valueDefinition TKDTree.h:85; TKDTree::fNNodesInt_t fNNodessize of node arrayDefinition TKDTree.h:78; TKDTree::fAxisUChar_t * fAxis[fNNodes] nodes cutting axisDefinition TKDTree.h:84; Given the index of a node in those arrays, it's easy to find the indices, corresponding to children nodes or the parent node: Suppose, the parent nod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDTree.html:8800,access,access,8800,doc/master/classTKDTree.html,https://root.cern,https://root.cern/doc/master/classTKDTree.html,1,['access'],['access']
Security,"lly created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occured while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:98533,access,access,98533,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['access'],['access']
Security,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_2_.html:4389,access,access,4389,root/html528/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_2_.html,4,['access'],['access']
Security,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_float_2_.html:4389,access,access,4389,root/html526/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_float_2_.html,1,['access'],['access']
Security,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_3_.html:4479,access,access,4479,root/html528/ROOT__Math__SVector_float_3_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_3_.html,4,['access'],['access']
Security,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_float_3_.html:4479,access,access,4479,root/html526/ROOT__Math__SVector_float_3_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_float_3_.html,1,['access'],['access']
Security,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_4_.html:4389,access,access,4389,root/html528/ROOT__Math__SVector_float_4_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_4_.html,4,['access'],['access']
Security,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_float_4_.html:4389,access,access,4389,root/html526/ROOT__Math__SVector_float_4_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_float_4_.html,1,['access'],['access']
Security,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_5_.html:4389,access,access,4389,root/html528/ROOT__Math__SVector_float_5_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_5_.html,4,['access'],['access']
Security,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_float_5_.html:4389,access,access,4389,root/html526/ROOT__Math__SVector_float_5_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_float_5_.html,1,['access'],['access']
Security,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_6_.html:4479,access,access,4479,root/html528/ROOT__Math__SVector_float_6_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_6_.html,4,['access'],['access']
Security,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_float_6_.html:4479,access,access,4479,root/html526/ROOT__Math__SVector_float_6_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_float_6_.html,1,['access'],['access']
Security,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_7_.html:4479,access,access,4479,root/html528/ROOT__Math__SVector_float_7_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_7_.html,4,['access'],['access']
Security,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_float_7_.html:4479,access,access,4479,root/html526/ROOT__Math__SVector_float_7_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_float_7_.html,1,['access'],['access']
Security,"loat,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5756,access,access,5756,root/html602/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,2,['access'],['access']
Security,"loat,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5756,access,access,5756,root/html602/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,2,['access'],['access']
Security,"loat,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5756,access,access,5756,root/html602/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,2,['access'],['access']
Security,"loat,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:5756,access,access,5756,root/html602/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,2,['access'],['access']
Security,"loat,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:5756,access,access,5756,root/html602/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,2,['access'],['access']
Security,"loat,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:5756,access,access,5756,root/html602/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,2,['access'],['access']
Security,"loat_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; qfloat * qDefinition THbookFile.cxx:89; TMath.h; TString.h; HashUInt_t Hash(const TString &s)Definition TString.h:494; TStringBasic string class.Definition TString.h:139; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; ROOT::Math::landau_pdfdouble landau_pdf(double x, double xi=1, double x0=0)Probability density function of the Landau distribution:Definition PdfFuncMathCore.cxx:21; ROOT::Math::fdistribution_cdfdouble fdistribution_cdf(double x, double n, double m, double x0=0)Cumulative distribution function of the F-distribution (lower tail).Definition ProbFuncMathCore.cxx:183; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; c3return c3Definition legend3.C:15; Types.h; F#define F(x, y, z); TMathTMath.Definition TMathBase.h:35; TMath::FDistIDouble_t FDistI(Double_t F, Double_t N, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:117548,hash,hash,117548,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['hash'],['hash']
Security,"locate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). void Resize(size_t nelement). TGenCollectionProxy* Initialize() const; Late initializat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGenCollectionProxy.html:4690,access,accessors,4690,root/html530/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html,3,['access'],['accessors']
Security,"locate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). void Resize(size_t nelement). TGenCollectionProxy* Initialize() const; Late initialization of collection ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenCollectionProxy.html:4688,access,accessors,4688,root/html528/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TGenCollectionProxy.html,3,['access'],['accessors']
Security,"locate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). void Resize(size_t nelement). T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGenCollectionProxy.html:4729,access,accessors,4729,root/html532/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html,3,['access'],['accessors']
Security,"location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidRegisterColor(Color_t colorIndex). Data Members; public:. enum ECoordinateMode { kPadMode; kObjectBoundingMode; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; Int_tTColor::fNumberColor number identifier; TStringTNamed::fTitleobject title. private:. vector<Double_t>fColorPositions; vector<Double_t>fColorsRGBA values.; TColorGradient::ECoordinateModefCoordinateMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TColorGradient(). TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); I have no way to validate parameters here, so it's up to user; to pass correct arguments. TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Double_t* colors, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); I have no way to validate parameters here, so it's up to user; to pass correct arguments. void ResetColor(UInt_t nPoints, const Double_t* points, const Color_t* colorIndices). void ResetColor(UInt_t nPoints, const Double_t* points, const Double_t* colorIndices). void SetCoordinateMode(TColorGradient::ECoordinateMode mode). const Double_t * GetColorPositions() const. const Double_t * GetColors() const. void RegisterColor(Color_t colorIndex). TColorGradient(). ECoordinateMode GetCoordinateMode() const. SizeType_t GetNumberOfSteps() const. » Last changed: root/base:$Id$ » Last generated: 2015-03-12 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TColorGradient.html:10385,validat,validate,10385,root/html534/TColorGradient.html,https://root.cern,https://root.cern/root/html534/TColorGradient.html,1,['validat'],['validate']
Security,"lock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.access.fp = NULL;; 15353 }; 15354 } else {; 15355 fi.access.fp = NULL;; 15356 }; 15357 ; 15358 /* Log is written to a file and/or a callback. If both are not set,; 15359 * executing the rest of the function is pointless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:453863,access,access,453863,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"lock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.access.fp = NULL;; 15354 }; 15355 } else {; 15356 fi.access.fp = NULL;; 15357 }; 15358 ; 15359 /* Log is written to a file and/or a callback. If both are not set,; 15360 * executing the rest of the function is pointless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:453896,access,access,453896,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"log; TSessionOutputFrame Output frame; TSessionQueryFrame Query frame; TSessionServerFrame Server frame; TSessionViewer Session Viewer; TShape Basic shape; TSignalHandler Signal event handler; TSlave PROOF slave server; TSlaveInfo basic info on workers; TSlaveLite PROOF lite worker server; TSlider A user interface slider.; TSliderBox The moving box of a TSlider; TSocket This class implements client sockets; TSortedList A sorted list; TSpectrum Peak Finder, background estimator, Deconvolution; TSpectrum2 Peak Finder, background estimator, Deconvolution for 2-D histograms; TSpectrum2Fit Spectrum2 Fitter using algorithm without matrix inversion and conjugate gradient method for symmetrical matrices (Stiefel-Hestens method); TSpectrum2Painter TSpectrum 3d graphics package; TSpectrum2Transform Spectrum2 Transformer, it calculates classic orthogonal 2D transforms; TSpectrum3 Peak Finder, Background estimator, Markov smoothing and Deconvolution for 3-D histograms; TSpectrumFit Spectrum Fitter using algorithm without matrix inversion and conjugate gradient method for symmetrical matrices (Stiefel-Hestens method); TSpectrumTransform Spectrum Transformer, it calculates classic orthogonal 1D transforms; TSpline Spline base class; TSpline3 Class to create third natural splines; TSpline5 Class to create quintic natural splines; TSplinePoly Spline polynomial terms; TSplinePoly3 Third spline polynomial terms; TSplinePoly5 Quintic spline polynomial terms; TStatus Status class; TStdExceptionHandler C++ exception handler; TStopwatch A stopwatch which times real and cpu time; TStorage Storage manager class; TStreamerArtificial StreamerElement injected by a TSchemaRule. Transient only to preverse forward compatibility.; TStreamerBase Streamer element of type base class; TStreamerBasicPointer Streamer element for a pointer to a basic type; TStreamerBasicType Streamer element for a basic type; TStreamerElement Base class for one element (data member) to be Streamed; TStreamerInfo Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:123182,inject,injected,123182,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['inject'],['injected']
Security,"lone the function (need to return Base for Windows) ;  ; virtual double DataElement (const double *x, unsigned int i, double *g, double *h, bool fullHessian) const;  i-th likelihood element and its gradient ;  ; virtual void Gradient (const double *x, double *g) const;  evaluate gradient ;  ; bool IsWeighted () const;  ; virtual unsigned int NFitPoints () const;  ; PoissonLikelihoodFCN & operator= (const PoissonLikelihoodFCN &rhs);  Assignment operator. ;  ; virtual BaseObjFunction::Type_t Type () const;  Computes the full Hessian. ;  ; void UseSumOfWeights ();  ; void UseSumOfWeightSquare (bool on=true);  ;  Public Member Functions inherited from ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >; virtual const DataType & Data () const;  access to const reference to the data ;  ; std::shared_ptr< DataType > DataPtr () const;  access to data pointer ;  ; virtual bool HasHessian () const;  flag to indicate if can compute Hessian ;  ; virtual const IModelFunction & ModelFunction () const;  access to const reference to the model function ;  ; std::shared_ptr< IModelFunction > ModelFunctionPtr () const;  access to function pointer ;  ;  Public Member Functions inherited from ROOT::Math::BasicFitMethodFunction< DerivFunType >;  BasicFitMethodFunction (int dim, int npoint);  ;  ~BasicFitMethodFunction () override;  Virtual Destructor (no operations) ;  ; virtual bool G2 (const double *, double *) const;  Computes the Second derivatives. ;  ; virtual bool Hessian (const double *x, double *hess) const;  Computes the full Hessian. ;  ; bool IsAGradFCN ();  ; virtual unsigned int NCalls () const;  return the total number of function calls (override if needed) ;  ; unsigned int NDim () const override;  Number of dimension (parameters) . ;  ; virtual unsigned int NPoints () const;  return the number of data points used in evaluating the function ;  ; virtual void ResetNCalls ();  reset number of function calls ;  ; virtual void UpdateNCalls () const;  update number of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1PoissonLikelihoodFCN.html:2941,access,access,2941,doc/master/classROOT_1_1Fit_1_1PoissonLikelihoodFCN.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1PoissonLikelihoodFCN.html,4,['access'],['access']
Security,"lor creation and management class.Definition TColor.h:21; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFileHandlerDefinition TSysEvtHandler.h:65; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGaxisThe axis painter class.Definition TGaxis.h:24; TGeometryTGeometry description.Definition TGeometry.h:39; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THtmlLegacy ROOT documentation system.Definition THtml.h:40; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLinkSpecial TText object used to show hyperlinks.Definition TLink.h:17; TListA doubly linked list.Definition TList.h:38; TMethodArgEach ROOT method (see TMethod) has a linked list of its arguments.Definition TMethodArg.h:36; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMinuitDefinition TMinuit.h:27; TObjectTableThis class registers all instances of TObject and its derived classes in a hash table.Definition TObjectTable.h:35; TObjectMother of all ROOT objects.Definition TObject.h:41; TOrdCollectionOrdered collection.Definition TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjectTable.html:4793,hash,hash,4793,doc/master/classTObjectTable.html,https://root.cern,https://root.cern/doc/master/classTObjectTable.html,1,['hash'],['hash']
Security,"lormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TCanvasThe Canvas class.Definition TCanvas.h:23; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TMVA::ConfigurableDefinition Configurable.h:45; TMVA::CrossValidationClass to perform cross validation, splitting the dataloader into folds.Definition CrossValidation.h:124; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Factory::PrintHelpMessagevoid PrintHelpMessage(const TString &datasetname, const TString &methodTitle="""") constPrint predefined help message of classifier.Definition Factory.cxx:1333; TMVA::Factory::fSilentFileBool_t fSilentFile! used in constructor without fileDefinition Factory.h:217; TMVA::Factory::fCorrelationsBool_t fCorrelations! enable to calculate correlationsDefinition Factory.h:215; TMVA::Factory::IsModelPersistenceBool_t IsModelPersistence() constDefinition Factory.h:152; TMVA::Factory::fOptionsTString fOptions! option string given by construction (presently only ""V"")Definition Factory.h:211; TMVA::Factory::MVectorstd::vector< IMethod * > MVectorDefinition Factory.h:84; TMVA::Factor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:11927,validat,validation,11927,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['validat'],['validation']
Security,"lotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealVar*_yvarY v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooXYChi2Var.html:36257,access,access,36257,root/html530/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html,1,['access'],['access']
Security,"lotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels; static TGLPlotPainter::ESelectionBaseTGLPlotPainter::kHighColorSelectionBase; static TGLPlotPainter::ESelectionBaseTGLPlotPainter::kTrueColorSelectionBase. private:. vector<Int_t>fBinColors; TStringfBinInfoUsed by GetPlotInfo.; list<Rgl::Pad::Tesselation_t>fCapsCaps for all bins.; vector<Double_t>fPolygonTemporary array for polygon's vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return some gl states to original values. void DrawPlot() const; Draw extruded polygons and plot's frame. void DrawExtrusion() const; Extruded part of bins.; GL_QUADS, GL_QUAD_STRIP - have the same time on my laptop, so I use; GL_QUADS and forgot about vertex arrays (can require more memory BTW). void DrawExtrusion(const TGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; Extrude poly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLH2PolyPainter.html:4997,validat,validated,4997,root/html602/TGLH2PolyPainter.html,https://root.cern,https://root.cern/root/html602/TGLH2PolyPainter.html,2,['validat'],['validated']
Security,"lots. ; Definition at line 360 of file TCollection.cxx. ◆ Hash(). ULong_t TCollection::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 186 of file TCollection.h. ◆ IsA(). TClass * TCollection::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TQCommand, TQUndoManager, TQConnection, THashList, THashTable, TList, TMap, TObjArray, TOrdCollection, TRefArray, TSeqCollection, TSortedList, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TGeoNavigatorArray, TGridJobStatusList, and TParallelCoordSelect.; Definition at line 222 of file TCollection.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:24196,hash,hash,24196,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,1,['hash'],['hash']
Security,"lots. ; Definition at line 360 of file TCollection.cxx. ◆ Hash(). ULong_t TCollection::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 186 of file TCollection.h. ◆ IsA(). TClass * TCollection::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TQCommand, TQUndoManager, TQConnection, THashList, THashTable, TList, TMap, TObjArray, TOrdCollection, TRefArray, TSeqCollection, TSortedList, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TGeoNavigatorArray, TGridJobStatusList, and TParallelCoordSelect.; Definition at line 222 of file TCollection.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCollection.html:24197,hash,hash,24197,doc/master/classTCollection.html,https://root.cern,https://root.cern/doc/master/classTCollection.html,1,['hash'],['hash']
Security,"lptr;; 133 ; 134namespace {; 135 ; 136 static constexpr const char kUndeterminedClassInfoName[] = ""<NOT YET DETERMINED FROM fClassInfo>"";; 137 ; 138 class TMmallocDescTemp {; 139 private:; 140 void *fSave;; 141 public:; 142 TMmallocDescTemp(void *value = nullptr) :; 143 fSave(ROOT::Internal::gMmallocDesc) { ROOT::Internal::gMmallocDesc = value; }; 144 ~TMmallocDescTemp() { ROOT::Internal::gMmallocDesc = fSave; }; 145 };; 146 ; 147 // When a new class is created, we need to be able to find; 148 // if there are any existing classes that have the same name; 149 // after any typedefs are expanded. (This only really affects; 150 // template arguments.) To avoid having to search through all classes; 151 // in that case, we keep a hash table mapping from the fully; 152 // typedef-expanded names to the original class names.; 153 // An entry is made in the table only if they are actually different.; 154 //; 155 // In these objects, the TObjString base holds the typedef-expanded; 156 // name (the hash key), and fOrigName holds the original class name; 157 // (the value to which the key maps).; 158 //; 159 class TNameMapNode : public TObjString {; 160 public:; 161 TString fOrigName;; 162 ; 163 TNameMapNode(const char *typedf, const char *orig) :; 164 TObjString (typedf),; 165 fOrigName (orig); 166 {; 167 }; 168 };; 169 ; 170}; 171 ; 172std::atomic<Int_t> TClass::fgClassCount;; 173 ; 174static bool IsFromRootCling() {; 175 // rootcling also uses TCling for generating the dictionary ROOT files.; 176 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 177 return foundSymbol;; 178}; 179 ; 180// Implementation of the TDeclNameRegistry; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// TDeclNameRegistry class constructor.; 184 ; 185TClass::TDeclNameRegistry::TDeclNameRegistry(Int_t verbLevel): fVerbLevel(verbLevel); 186{; 187 // MSVC doesn't support fSpinLock=ATOMIC_FLAG_INIT; in the class definition;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:5867,hash,hash,5867,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['hash'],['hash']
Security,"lready have it; 7218 /////////////////////////////////////////////////////////////////////////////; 7219 ; 7220 TObjArray* arr = nullptr;; 7221 TVirtualStreamerInfo* info = nullptr;; 7222 if (fConversionStreamerInfo.load()) {; 7223 std::map<std::string, TObjArray*>::iterator it;; 7224 ; 7225 R__LOCKGUARD(gInterpreterMutex);; 7226 ; 7227 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7228 ; 7229 if( it != (*fConversionStreamerInfo).end() ) {; 7230 arr = it->second;; 7231 }; 7232 if (arr) {; 7233 info = FindStreamerInfo( arr, checksum );; 7234 }; 7235 }; 7236 ; 7237 if( info ); 7238 return info;; 7239 ; 7240 R__LOCKGUARD(gInterpreterMutex);; 7241 ; 7242 //----------------------------------------------------------------------------; 7243 // Get it from the foreign class; 7244 /////////////////////////////////////////////////////////////////////////////; 7245 ; 7246 info = cl->FindStreamerInfo( checksum );; 7247 ; 7248 if( !info ); 7249 return nullptr;; 7250 ; 7251 //----------------------------------------------------------------------------; 7252 // We have the right info so we need to clone it to create new object with; 7253 // non artificial streamer elements and we should build it for current class; 7254 /////////////////////////////////////////////////////////////////////////////; 7255 ; 7256 int version = info->GetClassVersion();; 7257 info = (TVirtualStreamerInfo*)info->Clone();; 7258 ; 7259 // When cloning the StreamerInfo we record (and thus restore); 7260 // the absolute value of the version, let's restore the sign.; 7261 if (version == -1); 7262 info->SetClassVersion(-1);; 7263 ; 7264 if( !info->BuildFor( this ) ) {; 7265 delete info;; 7266 return nullptr;; 7267 }; 7268 ; 7269 if (!info->IsCompiled()) {; 7270 // Streamer info has not been compiled, but exists.; 7271 // Therefore it was read in from a file and we have to do schema evolution?; 7272 // Or it didn't have a dictionary before, but does now?; 7273 info->BuildOld();; 7274 }; 7275 ; 7276 //--",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:277727,checksum,checksum,277727,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['checksum'],['checksum']
Security,"lready have it; 7285 /////////////////////////////////////////////////////////////////////////////; 7286 ; 7287 TObjArray* arr = nullptr;; 7288 TVirtualStreamerInfo* info = nullptr;; 7289 if (fConversionStreamerInfo.load()) {; 7290 std::map<std::string, TObjArray*>::iterator it;; 7291 ; 7292 R__LOCKGUARD(gInterpreterMutex);; 7293 ; 7294 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7295 ; 7296 if( it != (*fConversionStreamerInfo).end() ) {; 7297 arr = it->second;; 7298 }; 7299 if (arr) {; 7300 info = FindStreamerInfo( arr, checksum );; 7301 }; 7302 }; 7303 ; 7304 if( info ); 7305 return info;; 7306 ; 7307 R__LOCKGUARD(gInterpreterMutex);; 7308 ; 7309 //----------------------------------------------------------------------------; 7310 // Get it from the foreign class; 7311 /////////////////////////////////////////////////////////////////////////////; 7312 ; 7313 info = cl->FindStreamerInfo( checksum );; 7314 ; 7315 if( !info ); 7316 return nullptr;; 7317 ; 7318 //----------------------------------------------------------------------------; 7319 // We have the right info so we need to clone it to create new object with; 7320 // non artificial streamer elements and we should build it for current class; 7321 /////////////////////////////////////////////////////////////////////////////; 7322 ; 7323 int version = info->GetClassVersion();; 7324 info = (TVirtualStreamerInfo*)info->Clone();; 7325 ; 7326 // When cloning the StreamerInfo we record (and thus restore); 7327 // the absolute value of the version, let's restore the sign.; 7328 if (version == -1); 7329 info->SetClassVersion(-1);; 7330 ; 7331 if( !info->BuildFor( this ) ) {; 7332 delete info;; 7333 return nullptr;; 7334 }; 7335 ; 7336 if (!info->IsCompiled()) {; 7337 // Streamer info has not been compiled, but exists.; 7338 // Therefore it was read in from a file and we have to do schema evolution?; 7339 // Or it didn't have a dictionary before, but does now?; 7340 info->BuildOld();; 7341 }; 7342 ; 7343 //--",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:280478,checksum,checksum,280478,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['checksum'],['checksum']
Security,"lready in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionTemplates::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' into this collection.Definition TListOfFunctionTemplates.cxx:356; TListOfFunctionTemplates::Deletevoid Delete(Option_t *option="""") overrideDelete all TFunction object files.Definition TListOfFunctionTemplates.cxx:164; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::GetTFunction * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctions.cxx:262; TListOfFunctions::GetListForObjectvirtual TList * GetListForObject(const char *name) constReturn the set of overloads for this name, collecting all available ones.Definition TListOfFunctions.cxx:230; TListOfFunctions::FindObjectTObject * FindObject(const TObject *obj) const overrideFind object using its hash value (returned by its Hash() member).Definition TListOfFunctions.cxx:443; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::AddFirstvoid AddFirst(TObject *obj) overrideAdd object at the beginning of the list.Definition TList.cxx:98; TMapTMap implements an associative array of (key,value) pairs using a THashTabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:358323,hash,hash,358323,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['hash'],['hash']
Security,"ls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 // other is reading it). To solve the problem, we could use a read-write lock; 1840 // inside the list itself.; 1841 if (load) fGlobalFunctions->Load();; 1842 ; 1843 return fGlobalFunctions;; 1844}; 1845 ; 1846////////////////////////////////////////////////////////////////////////////////; 1847/// Return a dynamic list giving access to all TDataTypes (typedefs); 1848/// currently defined.; 1849///; 1850/// The list is populated on demand. Calling; 1851/// ~~~ {.cpp}; 1852/// gROOT->GetListOfTypes()->FindObject(nameoftype);; 1853/// ~~~; 1854/// will return the TDataType corresponding to 'nameoftype'. If the; 1855/// TDataType is not already in the list itself and the type does exist,; 1856/// a new TDataType will be created and added to the list.; 1857///; 1858/// Calling; 1859/// ~~~ {.cpp}; 1860/// gROOT->GetListOfTypes()->ls(); // or Print(); 1861/// ~~~; 1862/// list only the typedefs that have been previously accessed through the; 1863/// list (plus the builtins types).; 1864 ; 1865TCollection *TROOT::GetListOfTypes(Bool_t /* load */); 1866{; 1867 if (!fInterpreter); 1868 Fatal(""GetListOfTypes"", ""fInterpreter not initialized"");; 1869 ; 1870 return fTypes;; 1871}; 1872 ; 1873////////////////////////////////////////////////////////////////////////////////; 1874/// Get number of classes.; 1875 ; 1876Int_t TROOT::GetNclasses() const; 1877{; 1878 return fClasses->GetSize();; 1879}; 1880 ; 1881////////////////////////////////////////////////////////////////////////////////; 1882/// Get number of types.; 1883 ; 1884Int_t TROOT::GetNtypes() const; 1885{; 1886 return fTypes->GetSize();; 1887}; 1888 ; 1889////////////////////////////////////////////////////////////////////////////////; 1890/// Execute command when system has been idle for idleTimeInSec seconds.; 1891 ; 1892void TROOT::Idle(UInt_t idleTimeInSec, const char *command); 1893{; 1894 if (!fApplication.load",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:71846,access,accessed,71846,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['access'],['accessed']
Security,"lso called a box-plot it makes sense in the very most cases to always draw the box; b = 2; draw a filled box with border; m = 0; no median drawn; m = 1; median is drawn as a line; m = 2; median is drawn with errors (notches); m = 3; median is drawn as a circle; M = 0; no mean drawn; M = 1; mean is drawn as a dashed line; M = 3; mean is drawn as a circle; w = 0; no whisker drawn; w = 1; whisker is drawn to end of distribution.; w = 2; whisker is drawn to max 1.5*iqr; a = 0; no anchor drawn; a = 1; the anchors are drawn; p = 0; no points drawn; p = 1; only outliers are drawn; p = 2; all datapoints are drawn; p = 3: all datapoints are drawn scattered; h = 0; no histogram is drawn; h = 1; histogram at the left or bottom side is drawn; h = 2; histogram at the right or top side is drawn; h = 3; histogram at left and right or top and bottom (violin-style) is drawn; z = 0; no zero indicator line is drawn; z = 1; zero indicator line is drawn. As one can see all individual options for both candle and violin plots can be accessed by this mechanism. In deed the keywords CANDLE(<option-string>) and VIOLIN(<option-string>) have the same meaning. So you can parametrise an option-string for a candle plot and use the keywords VIOLIN and vice versa, if you wish.; Using a logarithmic x- or y-axis is possible for candle and violin charts.; SinceROOT version 6.11/01; a logarithmic z-axis is possible, too but will only affect violin charts of course.; The CANDLE option; A Candle plot (also known as a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient way to describe graphically a data distribution (D) with only five numbers:. The minimum value of the distribution D (bottom or left whisker).; The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom of the box).; The median (M): 50% of the data points in D are less than M.; The upper quartile (Q3): 75% of the data points in D are less than Q3 (top of the box).; The maximum value of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:51286,access,accessed,51286,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['access'],['accessed']
Security,"lt non-exclusive but its entire radio buttons will be mutually exclusive.; TGHButtonGroup and TGVButtonGroup are convenience classes that offer you a thin layer on top of TGButtonGroup. TGHButtonGroup organize button widgets in a group of one horizontal row, TGVButtonGroup in a group of one column. You can also organize buttons in rows and columns using the provided constructor and TGMatrixLayout.; Do not use a radio button to indicate the presence or absence of a state - use a check box instead. To have the check button “Event Status” and to set it as selected we need to write:; TGCheckButton *estat = new TGCheckButton(p, ""Event Status"",1);; estat->SetState(kButtonDown);; Check boxes show the selected choices and any number of them can be selected, including none. Their proper usage is for setting attributes, properties or values; also for data or choices that are discrete, small and fixed in number, not easily remembered. With check boxes all alternatives are visible: it is easy to access and compare choices because they can all be seen together. Each option acts as a switch and can be either “on” or “off”. It is never changed in contents. Checkboxes differ from radio buttons in that they permit selection of more than one alternative. Each box can be switched on or off independently. These buttons can be used alone or grouped in sets. It is good practice to provide default settings for check boxes whenever it is possible. This can be done by:; SetState(EButtonState state); The parameter state can be one of kButtonUp, kButtonDown, kButtonEngaged, kButtonDisabled.; Check boxes can be used to affect other controls. The contents of a list can, for example, be filtered by setting a check box. In any case, use a check box only when both states of a choice are clearly opposite and unambiguous. If opposite states are not clear, it is better to use two radio buttons.; Choice description, i.e. check box label, must be clear, meaningful, fully spelled out, and displayed in mi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1183606,access,access,1183606,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"lt; At the end of the loop, print the sum of all event sizes. This sum shows you the real power of a TTree: even though you can analyze large amounts of data (our example tree with 22MB is tiny!) ROOT needs just a few MB of your RAM, no matter how many events you analyze. Imagine what it would be like if you had to load all data into memory, e.g. using a simple vector!; ... Int_t sizeInMB = totalSize/1024/1024;; printf(""Total size of all events: %d MB\n"", sizeInMB);; }. Running the Macro; To run this macro, simply type .x AnalyzeTree.C and ROOT will execute it. If it finds an error it might be wise to quit ROOT (.q) and try again!; If, for any reason, you don't manage to get it working, you can download a working macro file here: CountEvents.C; Here again, if you are using ROOT via ssh, you have to download the file with wget from your remote directory:; wget http://root-mirror.github.io/training/intro/CountEvents.C; . ‹ TTree and Its Data; up; Histogramming ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:5843,access,access,5843,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['access'],['access']
Security,"ltCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:16874,access,access,16874,root/html526/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"lticlass(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); evaluates the multiclass MVA. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose; }. void SetVerbose(Bool_t v); { fVerbose = v; }. const DataSetInfo& DataInfo() const; { return fDataSetInfo; }. DataSetInfo& DataInfo(); { return fDataSetInfo; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: Reader.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__Reader.html:14916,access,accessors,14916,root/html532/TMVA__Reader.html,https://root.cern,https://root.cern/root/html532/TMVA__Reader.html,1,['access'],['accessors']
Security,"luation of 3200 events: 0.0999 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras_LSTM for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyKeras_LSTM ] :␛[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 2560 training events and 640 validation events; : Training Model Summary; saved recurrent model model_LSTM.h5; Booking Keras model LSTM; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 8234 (32.16 KB); Trainable params: 8234 (32.16 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; Epoch 1/10; ; 1/26 [>.............................] - ETA: 42s - loss: 0.7326 - accuracy: 0.4600␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:21092,validat,validation,21092,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['validat'],['validation']
Security,"luded into objects map. ;  ;  Protected Member Functions inherited from TBuffer;  TBuffer ();  ;  TBuffer (const TBuffer &)=delete;  ; void operator= (const TBuffer &)=delete;  ; Int_t Read (const char *name) override;  Read contents of object with specified name from the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) override;  Write this object to the current directory. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static void * ConvertFromJSONChecked (const char *str, const TClass *expectedClass);  Read objects from JSON, one can reuse existing object. ;  ;  Static Protected Member Functions inherited from TBufferIO; static R__ALWAYS_INLINE ULong_t Void_Hash (const void *ptr);  Return hash value for provided object. ;  . Protected Attributes; Int_t fArrayCompact {0};  ! 0 - no array compression, 1 - exclude leading/trailing zeros, 2 - check value repetition ;  ; TString fArraySepar;  ! depending from compression level, "", "" or "","" ;  ; Int_t fCompact {0};  ! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all ;  ; unsigned fJsonrCnt {0};  ! counter for all objects, used for referencing ;  ; Bool_t fMapAsObject {kFALSE};  ! when true, std::map will be converted into JSON object ;  ; TString fNumericLocale;  ! stored value of setlocale(LC_NUMERIC), which should be recovered at the end ;  ; TString fOutBuffer;  ! main output buffer for json code ;  ; TString * fOutput {nullptr};  ! current output buffer for json code ;  ; TString fSemicolon;  ! depending from compression level, "" : "" or "":"" ;  ; std::vector< const TClass * > fSkipClasses;  ! list of classes, which class info is n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:49317,hash,hash,49317,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['hash'],['hash']
Security,"lue or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:47094,access,accessible,47094,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,6,['access'],['accessible']
Security,"lues"");; 2219 /// ~~~; 2220 ///; 2221 /// \note Differently from other ROOT interfaces, the returned TGraph is not associated to gDirectory; 2222 /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; 2223 /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).; 2224 template <typename X = RDFDetail::RInferredType, typename Y = RDFDetail::RInferredType>; 2225 RResultPtr<::TGraph> Graph(std::string_view x = """", std::string_view y = """"); 2226 {; 2227 auto graph = std::make_shared<::TGraph>();; 2228 const std::vector<std::string_view> columnViews = {x, y};; 2229 const auto userColumns = RDFInternal::AtLeastOneEmptyString(columnViews); 2230 ? ColumnNames_t(); 2231 : ColumnNames_t(columnViews.begin(), columnViews.end());; 2232 ; 2233 const auto validatedColumns = GetValidatedColumnNames(2, userColumns);; 2234 ; 2235 // We build a default name and title based on the input columns; 2236 const auto g_name = validatedColumns[1] + ""_vs_"" + validatedColumns[0];; 2237 const auto g_title = validatedColumns[1] + "" vs "" + validatedColumns[0];; 2238 graph->SetNameTitle(g_name.c_str(), g_title.c_str());; 2239 graph->GetXaxis()->SetTitle(validatedColumns[0].c_str());; 2240 graph->GetYaxis()->SetTitle(validatedColumns[1].c_str());; 2241 ; 2242 return CreateAction<RDFInternal::ActionTags::Graph, X, Y>(validatedColumns, graph, graph, fProxiedPtr);; 2243 }; 2244 ; 2245 ////////////////////////////////////////////////////////////////////////////; 2246 /// \brief Fill and return a TGraphAsymmErrors object (*lazy action*).; 2247 /// \param[in] x The name of the column that will fill the x axis.; 2248 /// \param[in] y The name of the column that will fill the y axis.; 2249 /// \param[in] exl The name of the column of X low errors; 2250 /// \param[in] exh The name of the column of X high errors; 2251 /// \param[in] eyl The name of the column of Y low errors; 2252 /// \param[in] eyh The name o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:125029,validat,validatedColumns,125029,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,5,['validat'],['validatedColumns']
Security,"lution for ROOT PCM files.; 1382 ; 1383 TList *list = nullptr;; 1384 if (fSeekInfo) {; 1385 TDirectory::TContext ctxt(this); // gFile and gDirectory used in ReadObj; 1386 auto key = std::make_unique<TKey>(this);; 1387 std::vector<char> buffer(fNbytesInfo+1);; 1388 auto buf = buffer.data();; 1389 Seek(fSeekInfo); // NOLINT: silence clang-tidy warnings; 1390 if (ReadBuffer(buf,fNbytesInfo)) { // NOLINT: silence clang-tidy warnings; 1391 // ReadBuffer returns kTRUE in case of failure.; 1392 Warning(""GetRecordHeader"",""%s: failed to read the StreamerInfo data from disk."",; 1393 GetName());; 1394 return {nullptr, 1, hash};; 1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////////////////////////////////////////////////////////////////; 1427/// Read the list of TStreamerInfo objects written to this file.; 1428///; 1429/// The function returns a TList. It is the user's responsibility; 1430/// to delete the list created by this function.; 1431///; 1432/// Note the list, in ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:50059,hash,hash,50059,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['hash'],['hash']
Security,"ly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Evaluate profile likelihood by minimizing likelihood w.r.t. ;  ; void initializeMinimizer () const;  ; void validateAbsMin () const;  Check that parameters and likelihood value for 'best fit' are still valid. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the constr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProfileLL.html:48580,validat,validateAbsMin,48580,doc/master/classRooProfileLL.html,https://root.cern,https://root.cern/doc/master/classRooProfileLL.html,1,['validat'],['validateAbsMin']
Security,"ly created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:100538,access,access,100538,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['access'],['access']
Security,"ly futile to do something like:; root[] { Quad my_object(1.,2.,-3.); }; Cling does not follow this rule; if you type in the above line, you will not see the destructor message. As explained in the Script lesson, you can load in compound statements, which would be a bit pointless if everything disappeared as soon as it was loaded! Instead, to reset the stack you have to type:; root[] gROOT->Reset();; This sends the Reset message via the global pointer to the ROOT object, which, amongst its many roles, acts as a resource manager. Start ROOT again and type in the following:; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);; root[] Quad *my_objptr = new Quad(4.,5.,-6.);; root[] gROOT->Reset();; You will see that this deletes the first object but not the second. We have also painted ourselves into a corner, as my_objptr was also on the stack. This command will fail.; root[] my_objptr->Solve();; Cling no longer knows what my_objptr is. This is a great example of a memory leak; the heap object exists but we have lost our way to access it. In general, this is not a problem. If any object will outlive the compound statement in which it was created then a more permanent pointer will point to it, which frequently is part of another heap object. See Resetting the Interpreter Environment in the chapter “Cling the C++ Interpreter”.; 7 The C++ Interpreter Cling. ROOT has a C++ interpreter called cling built in. It is used for the prompt, both C++ and Python. It also serves as a source of information to store C++ objects, and provides the back-end for ROOT’s signal/slot and plug-in mechanisms.; This chapter focuses on the parts of cling that you will encounter while interacting with ROOT.; 7.1 The ROOT Prompt; Start up a ROOT session by typing root at the system prompt.; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:255409,access,access,255409,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ly some matrix types can be analyzed. For instance, TDecompChol will only accept symmetric matrices as defined TMatrixDSym. The assignment operator behaves somewhat different than of most other classes. The following lines will result in an error:; TMatrixD a(3,4);; TMatrixD b(5,6);; b = a;; It required to first resize matrix b to the shape of a.; TMatrixD a(3,4);; TMatrixD b(5,6);; b.ResizeTo(a);; b = a;; 14.2 Matrix Properties; A matrix has five properties, which are all set in the constructor:. precision - float or double. In the first case you will use the TMatrixF class family, in the latter case the TMatrixD one;; type - general (TMatrixD), symmetric (TMatrixDSym) or sparse (TMatrixDSparse);; size - number of rows and columns;; index - range start of row and column index. By default these start at zero;; sparse map - this property is only relevant for a sparse matrix. It indicates where elements are unequal zero. 14.2.1 Accessing Properties; The following table shows the methods to access the information about the relevant matrix property:. Method; Descriptions. Int_t GetRowLwb (); row lower-bound index. Int_t GetRowUpb (); row upper-bound index. Int_t GetNrows (); number of rows. Int_t GetColLwb (); column lower-bound index. Int_t GetColUpb (); column upper-bound index. Int_t GetNcols (); number of columns. Int_t GetNoElements (); number of elements, for a dense matrix this equals: fNrows x fNcols. Double_t GetTol (); tolerance number which is used in decomposition operations. Int_t *GetRowIndexArray (); for sparse matrices, access to the row index of fNrows+1 entries. Int_t *GetColIndexArray (); for sparse matrices, access to the column index of fNelems entries. The last two methods in this table are specific to the sparse matrix, which is implemented according to the Harwell-Boeing format. Here, besides the usual shape/size descriptors of the matrix like fNrows, fRowLwb, fNcols and fColLwb, we also store a row index, fRowIndex and column index, fColIndex fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:771369,access,access,771369,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"lyNLLW2; static RooRealMPFE::MessageCalculate; static RooRealMPFE::MessageCalculateNoOffset; static RooRealMPFE::StateClient; static RooRealMPFE::MessageConstOpt; static RooRealMPFE::MessageEnableOffset; static RooRealMPFE::StateInitialize; static RooRealMPFE::StateInline; static RooRealMPFE::MessageLogEvalError; static RooRealMPFE::MessageRetrieve; static RooRealMPFE::MessageReturnValue; static RooRealMPFE::MessageSendCat; static RooRealMPFE::MessageSendReal; static RooRealMPFE::StateServer; static RooRealMPFE::MessageTerminate; static RooRealMPFE::MessageVerbose; RooRealProxy_argFunction to calculate in parallel process; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_calcInProgress; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; vector<Bool_t>_constChanged! Flags if variable needs update on server-side; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry!; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceCalc; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealMPFE.html:35677,validat,validate,35677,root/html602/RooRealMPFE.html,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html,2,['validat'],['validate']
Security,"lyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TSystem; static const char * StripOffProto (const char *path, const char *proto);  Strip off protocol string from specified path. ;  . #include <TNetFile.h>. Inheritance diagram for TNetSystem:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TNetSystem() [1/3]. TNetSystem::TNetSystem ; (; const TNetSystem & ; ). privatedelete . ◆ TNetSystem() [2/3]. TNetSystem::TNetSystem ; (; Bool_t ; ftpowner = kTRUE). Create helper class that allows directory access via rootd. ; Use ftpowner = TRUE (default) if this instance is responsible for cleaning of the underlying TFTP connection; this allows to have control on the order of the final cleaning. ; Definition at line 798 of file TNetFile.cxx. ◆ TNetSystem() [3/3]. TNetSystem::TNetSystem ; (; const char * ; url, . Bool_t ; ftpowner = kTRUE . ). Create helper class that allows directory access via rootd. ; Use ftpowner = TRUE (default) if this instance is responsible for cleaning of the underlying TFTP connection; this allows to have control on the order of the final cleaning. ; Definition at line 820 of file TNetFile.cxx. ◆ ~TNetSystem(). TNetSystem::~TNetSystem ; (; ). virtual . Destructor. ; Definition at line 936 of file TNetFile.cxx. Member Function Documentation. ◆ AccessPathName(). Bool_t TNetSystem::AccessPathName ; (; const char * ; path, . EAccessMode ; mode . ). overridevirtual . Returns FALSE if one can access a file using the specified access mode. ; Mode is the same as for the Unix access(2) function. Attention, bizarre convention of return value!! ; Reimplemented from TSystem.; Definition at line 1089 of file TNetFile.cxx. ◆ Class(). static TClass * TNetSystem::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TNetSystem::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetSystem.html:34927,access,access,34927,doc/master/classTNetSystem.html,https://root.cern,https://root.cern/doc/master/classTNetSystem.html,1,['access'],['access']
Security,"l ; level, . const char * ; mess . ). overridevirtual . Send mess to syslog daemon. ; Level is the logging level and mess the message that will be written on the log. ; Reimplemented from TSystem.; Definition at line 2654 of file TUnixSystem.cxx. ◆ TempDirectory(). const char * TUnixSystem::TempDirectory ; (; ); const. overridevirtual . Return a user configured or systemwide directory to create temporary files in. ; Reimplemented from TSystem.; Definition at line 1503 of file TUnixSystem.cxx. ◆ TempFileName(). FILE * TUnixSystem::TempFileName ; (; TString & ; base, . const char * ; dir = nullptr, . const char * ; suffix = nullptr . ). overridevirtual . Create a secure temporary file by appending a unique 6 letter string to base. ; The file will be created in a standard (system) directory or in the directory provided in dir. Optionally one can provide suffix append to the final name - like extension "".txt"" or "".html"". The full filename is returned in base and a filepointer is returned for safely writing to the file (this avoids certain security problems). Returns 0 in case of error. ; Reimplemented from TSystem.; Definition at line 1523 of file TUnixSystem.cxx. ◆ Umask(). int TUnixSystem::Umask ; (; Int_t ; mask). overridevirtual . Set the process file creation mode mask. ; Reimplemented from TSystem.; Definition at line 1901 of file TUnixSystem.cxx. ◆ UnixFilestat(). int TUnixSystem::UnixFilestat ; (; const char * ; fpath, . FileStat_t & ; buf . ). staticprotected . Get info about a file. ; Info is returned in the form of a FileStat_t structure (see TSystem.h). The function returns 0 in case of success and 1 if the file could not be stat'ed. ; Definition at line 4039 of file TUnixSystem.cxx. ◆ UnixFSstat(). int TUnixSystem::UnixFSstat ; (; const char * ; path, . Long_t * ; id, . Long_t * ; bsize, . Long_t * ; blocks, . Long_t * ; bfree . ). staticprotected . Get info about a file system: id, bsize, bfree, blocks. ; Id is file system type (machine dependend, see stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:71080,secur,security,71080,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['secur'],['security']
Security,"m ""col"" is missing, the entire entry will be filtered out; df_available = df.FilterAvailable(""col""); df_available = df_available.Define(""twice"", ""col * 2""); ; # Conversely, if we want to select the entries for which the column has missing; # values, we do the following; df_missingcol = df.FilterMissing(""col""); # Following operations in the same branch of the computation graph clearly; # cannot access that same column, since there would be no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); ROOT::RDataFrame df{dataset};; ; // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");; ; // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; DefaultValueFor; DefaultValueFor creates a node of the computation graph which just forwards the values of the columns necessary for other downstream nodes, when they are available. In case a value of the input column passed to this function is not available, the node will provide the default value passed to this function call instead. Example:; df = ROOT.RDataFrame(dataset); # Anytime an entry from ""col"" is missing, the value will be the default one; default_value = ... # Some sensible default value here; df = df.DefaultValueFor(""col"", default_value) ; df = df.Define(""twice"", ""col * 2""); ROOT::RDataFrame df{dataset};; // Anytime an entry from ""col"" is missing, the value will be the default one; constexpr auto default_value = ... // Some sensible default value here; auto df_default = df.DefaultValueFor(""col"", default_value);; auto df_col = df",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:83748,access,access,83748,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['access'],['access']
Security,"m & i );; 88 void ReadWeightsFromXML ( void* wghtnode );; 89 ; 90 // calculate the MVA value (for CUTs this is just a dummy); 91 Double_t GetMvaValue( Double_t* err = nullptr, Double_t* errUpper = nullptr );; 92 ; 93 // write method specific histos to target file; 94 void WriteMonitoringHistosToFile( void ) const;; 95 ; 96 // test the method; 97 void TestClassification();; 98 ; 99 // also overwrite --> not computed for cuts; 100 Double_t GetSeparation ( TH1*, TH1* ) const { return -1; }; 101 Double_t GetSeparation ( PDF* = nullptr, PDF* = nullptr ) const { return -1; }; 102 Double_t GetSignificance( void ) const { return -1; }; 103 Double_t GetmuTransform ( TTree *) { return -1; }; 104 Double_t GetEfficiency ( const TString&, Types::ETreeType, Double_t& );; 105 Double_t GetTrainingEfficiency(const TString& );; 106 ; 107 // rarity distributions (signal or background (default) is uniform in [0,1]); 108 Double_t GetRarity( Double_t, Types::ESBType ) const { return 0; }; 109 ; 110 // accessors for Minuit; 111 Double_t ComputeEstimator( std::vector<Double_t> & );; 112 ; 113 Double_t EstimatorFunction( std::vector<Double_t> & );; 114 Double_t EstimatorFunction( Int_t ievt1, Int_t ievt2 );; 115 ; 116 void SetTestSignalEfficiency( Double_t effS ) { fTestSignalEff = effS; }; 117 ; 118 // retrieve cut values for given signal efficiency; 119 void PrintCuts( Double_t effS ) const;; 120 Double_t GetCuts ( Double_t effS, std::vector<Double_t>& cutMin, std::vector<Double_t>& cutMax ) const;; 121 Double_t GetCuts ( Double_t effS, Double_t* cutMin, Double_t* cutMax ) const;; 122 ; 123 // ranking of input variables (not available for cuts); 124 const Ranking* CreateRanking() { return nullptr; }; 125 ; 126 void DeclareOptions();; 127 void ProcessOptions();; 128 ; 129 // maximum |cut| value; 130 static const Double_t fgMaxAbsCutVal;; 131 ; 132 // no check of options at this place; 133 void CheckSetup() {}; 134 ; 135 protected:; 136 ; 137 // make ROOT-independent C++ class for classifie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8h_source.html:4125,access,accessors,4125,doc/master/MethodCuts_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8h_source.html,1,['access'],['accessors']
Security,"m Inc; BRCM : Broadcom Corp; TYC : Tyco International Ltd; IBM : International Business Machines Corp; AMAT : Applied Materials Inc; C : Citigroup Inc; PFE : Pfizer Inc; HD : Home Depot Inc. We calculate the optimal portfolio for 2.0 and 10.0 .; Food for thought :; We assumed that the stock returns have a Normal distribution . Check this assumption by histogramming the stock returns !; We used for the expected return in the objective function, the flat average over a time period . Investment firms will put significant resources in improving the return prediction .; If you want to trade significant number of shares, several other considerations have to be taken into account :; If you are going to buy, you will drive the price up (so-called ""slippage"") . This can be taken into account by adding terms to the objective (Google for ""slippage optimization""); FTC regulations might have to be added to the inequality constraints. Investment firms do not want to be exposed to the ""market"" as defined by a broad index like the S&P and ""hedge"" this exposure away . A perfect hedge this can be added as an equality constrain, otherwise add an inequality constrain . ; stock daily daily w1 w2; symb return sdv ; GE : 1.001 0.022 0.000 0.134; SUNW : 1.004 0.047 0.676 0.145; QCOM : 1.001 0.039 0.000 0.000; BRCM : 1.003 0.056 0.179 0.035; TYC : 1.001 0.042 0.145 0.069; IBM : 1.001 0.023 0.000 0.096; AMAT : 1.001 0.040 0.000 0.000; C : 1.000 0.023 0.000 0.000; PFE : 1.000 0.019 0.000 0.424; HD : 1.001 0.029 0.000 0.098; ; #include ""Riostream.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TMath.h""; #include ""TTree.h""; #include ""TArrayF.h""; #include ""TH1.h""; #include ""TF1.h""; #include ""TLegend.h""; #include ""TSystem.h""; ; #include ""TMatrixD.h""; #include ""TMatrixDSym.h""; #include ""TVectorD.h""; #include ""TQpProbDens.h""; #include ""TGondzioSolver.h""; ; const Int_t nrStocks = 10;; static const Char_t *stocks[] =; {""GE"",""SUNW"",""QCOM"",""BRCM"",""TYC"",""IBM"",""AMAT"",""C"",""PFE"",""HD""};; ; class TSto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:5034,expose,exposed,5034,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['expose'],['exposed']
Security,"m RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:36746,validat,validate,36746,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,2,['validat'],['validate']
Security,"m RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooSetProxy_depListList of dependents defining dimensions of histogram; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistFunc.html:30031,validat,validate,30031,root/html528/RooHistFunc.html,https://root.cern,https://root.cern/root/html528/RooHistFunc.html,2,['validat'],['validate']
Security,"m RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooListProxy_highSetHigh-side varaition; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; vector<int>_interpCode; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_lowSetLow-side variation; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooRealProxy_nominalThe nominal value; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/PiecewiseInterpolation.html:31082,validat,validate,31082,root/html532/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html532/PiecewiseInterpolation.html,2,"['access', 'validat']","['access', 'validate']"
Security,"m RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Int_t_lenLength of _value; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:19594,access,access,19594,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,1,['access'],['access']
Security,"m columns 1 to 3. Double_t Invert(); Invert matrix.; Copied from ROOT's TMatrixFCramerInv. void Streamer(TBuffer& ); Stream an object of class TEveTrans. void Print(Option_t* option = """") const; Print in reasonable format. void SetFrom(Double_t* carr); Initialize from array. void SetFrom(const TGeoMatrix& mat); Initialize from TGeoMatrix. void SetGeoHMatrix(TGeoHMatrix& mat); Set TGeoHMatrix mat. void SetBuffer3D(TBuffer3D& buff); Fill transformation part TBuffer3D core section. Bool_t IsScale(Double_t low = 0.90000000000000002, Double_t high = 1.1000000000000001) const; Test if the transformation is a scale.; To be used by ROOT TGLObject descendants that potentially need to; use GL_NORMALIZE.; The low/high limits are expected to be squares of acutal limits. Ideally this should be done by the TGLViewer [but is not]. virtual ~TEveTrans(); {}. TEveTrans& operator=(const TEveTrans& t); { SetTrans(t); return *this; }. void operator*=(const TEveTrans& t); { MultRight(t); }. Double_t* Array(); Element access. Double_t* ArrX(). Double_t* ArrY(). Double_t* ArrZ(). Double_t* ArrT(). Double_t operator[](Int_t i) const; { return fM[i]; }. Double_t& operator[](Int_t i); { return fM[i]; }. Double_t CM(Int_t i, Int_t j) const; { return fM[4*j + i]; }. Double_t& CM(Int_t i, Int_t j); { return fM[4*j + i]; }. Double_t operator()(Int_t i, Int_t j) const; { return fM[4*j + i - 5]; }. Double_t& operator()(Int_t i, Int_t j); { return fM[4*j + i - 5]; }. Bool_t GetUseTrans() const; { return fUseTrans; }. void SetUseTrans(Bool_t v); { fUseTrans = v; }. void SetEditRotation(Bool_t x); { fEditRotation = x; }. void SetEditScale(Bool_t x); { fEditScale = x; }. Bool_t GetEditRotation(); { return fEditRotation; }. Bool_t GetEditScale(); { return fEditScale; }. Bool_t GetEditTrans() const; { return fEditTrans; }. void SetEditTrans(Bool_t v); { fEditTrans = v; }. » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:46; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveTrans.html:16833,access,access,16833,root/html604/TEveTrans.html,https://root.cern,https://root.cern/root/html604/TEveTrans.html,1,['access'],['access']
Security,"m columns 1 to 3. Double_t Invert(); Invert matrix.; Copied from ROOT's TMatrixFCramerInv. void Streamer(TBuffer& ); Stream an object of class TEveTrans. void Print(Option_t* option = """") const; Print in reasonable format. void SetFrom(Double_t* carr); Initialize from array. void SetFrom(const TGeoMatrix& mat); Initialize from TGeoMatrix. void SetGeoHMatrix(TGeoHMatrix& mat); Set TGeoHMatrix mat. void SetBuffer3D(TBuffer3D& buff); Fill transformation part TBuffer3D core section. Bool_t IsScale(Double_t low = 0.90000000000000002, Double_t high = 1.1000000000000001) const; Test if the transformation is a scale.; To be used by ROOT TGLObject descendants that potentially need to; use GL_NORMALIZE.; The low/high limits are expected to be squares of acutal limits. Ideally this should be done by the TGLViewer [but is not]. virtual ~TEveTrans(); {}. TEveTrans& operator=(const TEveTrans& t); { SetTrans(t); return *this; }. void operator*=(const TEveTrans& t); { MultRight(t); }. Double_t* Array(); Element access. Double_t* ArrX(). Double_t* ArrY(). Double_t* ArrZ(). Double_t* ArrT(). Double_t operator[](Int_t i) const; { return fM[i]; }. Double_t& operator[](Int_t i); { return fM[i]; }. Double_t CM(Int_t i, Int_t j) const; { return fM[4*j + i]; }. Double_t& CM(Int_t i, Int_t j); { return fM[4*j + i]; }. Double_t operator()(Int_t i, Int_t j) const; { return fM[4*j + i - 5]; }. Double_t& operator()(Int_t i, Int_t j); { return fM[4*j + i - 5]; }. Bool_t GetUseTrans() const; { return fUseTrans; }. void SetUseTrans(Bool_t v); { fUseTrans = v; }. void SetEditRotation(Bool_t x); { fEditRotation = x; }. void SetEditScale(Bool_t x); { fEditScale = x; }. Bool_t GetEditRotation(); { return fEditRotation; }. Bool_t GetEditScale(); { return fEditScale; }. Bool_t GetEditTrans() const; { return fEditTrans; }. void SetEditTrans(Bool_t v); { fEditTrans = v; }. » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:47; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveTrans.html:16833,access,access,16833,root/html602/TEveTrans.html,https://root.cern,https://root.cern/root/html602/TEveTrans.html,1,['access'],['access']
Security,"m export string rsaPubExport. ;  ; static TList * GetAuthInfo ();  Static method returning the list with authentication details. ;  ; static const char * GetAuthMethod (Int_t idx);  Static method returning the method corresponding to idx. ;  ; static Int_t GetAuthMethodIdx (const char *meth);  Static method returning the method index (which can be used to find the method in GetAuthMethod()). ;  ; static Bool_t GetAuthReUse ();  Static method returning the authentication reuse settings. ;  ; static Int_t GetClientProtocol ();  Static method returning supported client protocol. ;  ; static char * GetDefaultDetails (Int_t method, Int_t opt, const char *user);  Determine default authentication details for method 'sec' and user 'usr'. ;  ; static const char * GetDefaultUser ();  Static method returning the default user information. ;  ; static TDatime GetGlobalExpDate ();  Static method returning default expiring date for new validity contexts. ;  ; static Bool_t GetGlobalPwHash ();  Static method returning the global password hash flag. ;  ; static Bool_t GetGlobalSRPPwd ();  Static method returning the global SRP password flag. ;  ; static const char * GetGlobalUser ();  Static method returning the global user. ;  ; static GlobusAuth_t GetGlobusAuthHook ();  Static method returning the globus authorization hook (no longer supported) ;  ; static THostAuth * GetHostAuth (const char *host, const char *user="""", Option_t *opt=""R"", Int_t *Exact=nullptr);  Sets fUser=user and search fgAuthInfo for the entry pertaining to (host,user), setting fHostAuth accordingly. ;  ; static const char * GetKrb5Principal ();  Static method returning the principal to be used to init Krb5 tickets. ;  ; static Bool_t GetPromptUser ();  Static method returning the prompt user settings. ;  ; static TList * GetProofAuthInfo ();  Static method returning the list with authentication directives to be sent to proof. ;  ; static Int_t GetRSAInit ();  Static method returning the RSA initialization flag. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:11751,password,password,11751,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,2,"['hash', 'password']","['hash', 'password']"
Security,"m from container. const TGFrame * GetNextSelected(void** current); Return the next selected item. If the ""current"" pointer is 0, the first; selected item will be returned. void ActivateItem(TGFrameElement* el); Activate item. void DeActivateItem(TGFrameElement* el); DeActivate item. TGPosition GetPagePosition() const; Returns page position. TGDimension GetPageDimension() const; Returns page dimension. void SetPagePosition(const TGPosition& pos); Set page position. void SetPagePosition(Int_t x, Int_t y); Set page position. void SetPageDimension(const TGDimension& dim); Set page dimension. void SetPageDimension(UInt_t w, UInt_t h); Set page dimension. void DoRedraw(); Redraw content of container in the viewport region. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw a region of container in viewport.; x, y, w, h are position and dimension of area to be; redrawn in viewport coordinates. void ClearViewPort(); Clear view port and redraw full content. Bool_t HandleExpose(Event_t* event); Handle expose events. Do not use double buffer. Bool_t HandleButton(Event_t* event); Handle mouse button event in container. const TGPicture * GetObjPicture(TGFrame* f); Retrieve icons associated with class ""name"". Association is made; via the user's ~/.root.mimes file or via $ROOTSYS/etc/root.mimes. void SetDragPixmap(const TGPicture* pic); Set drag window pixmaps and hotpoint. Bool_t HandleDoubleClick(Event_t* event); Handle double click mouse event. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. TGFrame * FindFrameByName(const char* name); Find frame by name. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void OnAutoScroll(); Autoscroll while close to & beyond The Wall. void SearchPattern(); Search for entry which name begins with pattern. void RepeatSearch(); Repeats search. TGFrameElement * FindFr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGContainer.html:26754,expose,expose,26754,root/html534/TGContainer.html,https://root.cern,https://root.cern/root/html534/TGContainer.html,2,['expose'],['expose']
Security,"m is typically filled with statements like: h1->Fill(x);; h1->Fill(x, w); //fill with weight; h2->Fill(x, y); h2->Fill(x, y, w); h3->Fill(x, y, z); h3->Fill(x, y, z, w); wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; or via one of the Fill functions accepting names described above. The Fill functions compute the bin number corresponding to the given x, y or z argument and increment this bin by the given weight. The Fill functions return the bin number for 1-D histograms or global bin number for 2-D and 3-D histograms. If TH1::Sumw2 has been called before filling, the sum of squares of weights is also stored. One can also increment directly a bin number via TH1::AddBinContent or replace the existing content via TH1::SetBinContent. Passing an out-of-range bin to TH1::AddBinContent leads to undefined behavior. To access the bin content of a given bin, do: Double_t binContent = h->GetBinContent(bin);; By default, the bin number is computed using the current axis ranges. If the automatic binning option has been set via h->SetCanExtend(TH1::kAllAxes);; TH1::kAllAxes@ kAllAxesDefinition TH1.h:76; then, the Fill Function will automatically extend the axis range to accomodate the new value specified in the Fill argument. The method used is to double the bin size until the new value fits in the range, merging bins two by two. This automatic binning options is extensively used by the TTree::Draw function when histogramming Tree variables with an unknown range. This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; During filling, some statistics parameters are incremented to compute the mean value and Root Mean Square with the maximum precision.; In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S a check is made that the bin contents do not exceed the maximum positive capacity (127 or 32767). Histograms of all types may have positive or/and n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:11958,access,access,11958,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['access'],['access']
Security,"m of squares of weights. ;  ; void UseCurrentStyle () override;  Copy current attributes from/to current style. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2Poly.html:33957,hash,hash,33957,doc/master/classTProfile2Poly.html,https://root.cern,https://root.cern/doc/master/classTProfile2Poly.html,1,['hash'],['hash']
Security,"m of squares of weights. ;  ; void UseCurrentStyle () override;  Copy current attributes from/to current style. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLTH3Composition.html:34155,hash,hash,34155,doc/master/classTGLTH3Composition.html,https://root.cern,https://root.cern/doc/master/classTGLTH3Composition.html,24,['hash'],['hash']
Security,"m read-only for all users or only specified user; allow = [all|user(s)] - make full access for all users or only specified user; allow_method = method(s) - allow method(s) execution even when readonly flag specified for the object; Like make command seen by all but can be executed only by admin; sniff->Restrict(""/CmdReset"",""allow=admin"");; Or fully hide command from guest account; sniff->Restrict(""/CmdRebin"",""hidden=guest"");. Bool_t HasRestriction(const char* item_name); Made fast check if item with specified name is in restriction list; If returns true, requires precise check with CheckRestriction() method. Int_t WithCurrentUserName(const char* option); return 2 when option match to current user name; return 1 when option==all; return 0 when option does not match user name. Int_t CheckRestriction(const char* item_name); Checked if restriction is applied to the item; full_item_name should have full path to the item. Returns -1 - object invisible, cannot be accessed or listed; 0 - no explicit restrictions, use default; 1 - read-only access; 2 - full access. void ScanObjectMembers(TRootSnifferScanRec& rec, TClass* cl, char* ptr); scan object data members; some members like enum or static members will be excluded. void ScanObjectProperties(TRootSnifferScanRec& rec, TObject* obj); scans object properties; here such fields as _autoload or _icon properties depending on class or object name could be assigned; By default properties, coded in the Class title are scanned. Example:; ClassDef(UserClassName, 1) // class comments *SNIFF* _field1=value _field2=""string value""; Here *SNIFF* mark is important. After it all expressions like field=value are parsed; One could use double quotes to code string values with spaces.; Fields separated from each other with spaces. void ScanObjectChilds(TRootSnifferScanRec& rec, TObject* obj); scans object childs (if any); here one scans collection, branches, trees and so on. void ScanCollection(TRootSnifferScanRec& rec, TCollection* lst, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootSniffer.html:11829,access,accessed,11829,root/html534/TRootSniffer.html,https://root.cern,https://root.cern/root/html534/TRootSniffer.html,3,['access'],"['access', 'accessed']"
Security,"m read-only for all users or only specified user; allow = [all|user(s)] - make full access for all users or only specified user; allow_method = method(s) - allow method(s) execution even when readonly flag specified for the object; Like make command seen by all but can be executed only by admin; sniff->Restrict(""/CmdReset"",""allow=admin"");; Or fully hide command from guest account; sniff->Restrict(""/CmdRebin"",""hidden=guest"");. Bool_t HasRestriction(const char* item_name); Made fast check if item with specified name is in restriction list; If returns true, requires precise check with CheckRestriction() method. Int_t WithCurrentUserName(const char* option); return 2 when option match to current user name; return 1 when option==all; return 0 when option does not match user name. Int_t CheckRestriction(const char* item_name); Checked if restriction is applied to the item; full_item_name should have full path to the item. Returns -1 - object invisible, cannot be accessed or listed; 0 - no explicit restrictions, use default; 1 - read-only access; 2 - full access. void ScanObjectMemebers(TRootSnifferScanRec& rec, TClass* cl, char* ptr, unsigned long cloffset); scan object data members; some members like enum or static members will be excluded. void ScanObjectProperties(TRootSnifferScanRec& rec, TObject* obj); scans object properties; here such fields as _autoload or _icon properties depending on class or object name could be assigned. void ScanObjectChilds(TRootSnifferScanRec& rec, TObject* obj); scans object childs (if any); here one scans collection, branches, trees and so on. void ScanCollection(TRootSnifferScanRec& rec, TCollection* lst, const char* foldername = 0, TCollection* keys_lst = 0); scan collection content. void ScanRoot(TRootSnifferScanRec& rec); scan complete ROOT objects hierarchy; For the moment it includes objects in gROOT directory; and list of canvases and files; Also all registered objects are included.; One could reimplement this method to provide alte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootSniffer.html:11651,access,accessed,11651,root/html604/TRootSniffer.html,https://root.cern,https://root.cern/root/html604/TRootSniffer.html,3,['access'],"['access', 'accessed']"
Security,"m  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TSystem; static const char * StripOffProto (const char *path, const char *proto);  Strip off protocol string from specified path. ;  . #include <TNetFile.h>. Inheritance diagram for TNetSystem:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TNetSystem() [1/3]. TNetSystem::TNetSystem ; (; const TNetSystem & ; ). privatedelete . ◆ TNetSystem() [2/3]. TNetSystem::TNetSystem ; (; Bool_t ; ftpowner = kTRUE). Create helper class that allows directory access via rootd. ; Use ftpowner = TRUE (default) if this instance is responsible for cleaning of the underlying TFTP connection; this allows to have control on the order of the final cleaning. ; Definition at line 798 of file TNetFile.cxx. ◆ TNetSystem() [3/3]. TNetSystem::TNetSystem ; (; const char * ; url, . Bool_t ; ftpowner = kTRUE . ). Create helper class that allows directory access via rootd. ; Use ftpowner = TRUE (default) if this instance is responsible for cleaning of the underlying TFTP connection; this allows to have control on the order of the final cleaning. ; Definition at line 820 of file TNetFile.cxx. ◆ ~TNetSystem(). TNetSystem::~TNetSystem ; (; ). virtual . Destructor. ; Definition at line 936 of file TNetFile.cxx. Member Function Documentation. ◆ AccessPathName(). Bool_t TNetSystem::AccessPathName ; (; const char * ; path, . EAccessMode ; mode . ). overridevirtual . Returns FALSE if one can access a file using the specified access mode. ; Mode is the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetSystem.html:34541,access,access,34541,doc/master/classTNetSystem.html,https://root.cern,https://root.cern/doc/master/classTNetSystem.html,1,['access'],['access']
Security,"m), 0.);; 161 std::fill(std::begin(fCarry)+1, std::end(fCarry), 0.);; 162 }; 163 ; 164 /// Single-element accumulation. Will not vectorise.; 165 void Add(T x) {; 166 auto y = x - fCarry[0];; 167 auto t = fSum[0] + y;; 168 fCarry[0] = (t - fSum[0]) - y;; 169 fSum[0] = t;; 170 }; 171 ; 172 ; 173 /// Accumulate from a range denoted by iterators.; 174 ///; 175 /// This function will auto-vectorise with random-access iterators.; 176 /// \param[in] begin Beginning of a range. Needs to be a random access iterator for automatic; 177 /// vectorisation, because a contiguous block of memory needs to be read.; 178 /// \param[in] end End of the range.; 179 template <class Iterator>; 180 void Add(Iterator begin, Iterator end) {; 181 static_assert(std::is_floating_point<; 182 typename std::remove_reference<decltype(*begin)>::type>::value,; 183 ""Iterator needs to point to floating-point values."");; 184 const std::size_t n = std::distance(begin, end);; 185 ; 186 for (std::size_t i=0; i<n; ++i) {; 187 AddIndexed(*(begin++), i);; 188 }; 189 }; 190 ; 191 ; 192 /// Fill from a container that supports index access.; 193 /// \param[in] inputs Container with index access such as std::vector or array.; 194 template<class Container_t>; 195 void Add(const Container_t& inputs) {; 196 static_assert(std::is_floating_point<typename Container_t::value_type>::value,; 197 ""Container does not hold floating-point values."");; 198 for (std::size_t i=0; i < inputs.size(); ++i) {; 199 AddIndexed(inputs[i], i);; 200 }; 201 }; 202 ; 203 ; 204 /// Iterate over a range and return an instance of a KahanSum.; 205 ///; 206 /// See Add(Iterator,Iterator) for details.; 207 /// \param[in] begin Beginning of a range.; 208 /// \param[in] end End of the range.; 209 /// \param[in] initialValue Optional initial value.; 210 template <class Iterator>; 211 static KahanSum<T, N> Accumulate(Iterator begin, Iterator end,; 212 T initialValue = T{}) {; 213 KahanSum<T, N> theSum(initialValue);; 214 theSum.Add(begin, end);; 215 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:7556,access,access,7556,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,1,['access'],['access']
Security,"m, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMD5.html:4503,checksum,checksum,4503,root/html534/TMD5.html,https://root.cern,https://root.cern/root/html534/TMD5.html,2,['checksum'],['checksum']
Security,"m.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:34353,hash,hash,34353,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,6,['hash'],['hash']
Security,"m::FindDynamicLibrary ; (; TString & ; lib, . Bool_t ; quiet = kFALSE . ). virtual . Find a dynamic library using the system search paths. ; lib will be updated to contain the absolute filename if found. Returns lib if found, or NULL if a library called lib was not found. This function does not open the library. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2034 of file TSystem.cxx. ◆ FindFile(). const char * TSystem::FindFile ; (; const char * ; search, . TString & ; file, . EAccessMode ; mode = kFileExists . ). virtual . Find location of file in a search path. ; Return value points to TString for compatibility with Which(const char *, const char *, EAccessMode). Returns 0 in case file is not found. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1538 of file TSystem.cxx. ◆ FindHelper(). TSystem * TSystem::FindHelper ; (; const char * ; path, . void * ; dirptr = nullptr . ). protected . Create helper TSystem to handle file and directory operations that might be special for remote file access. ; Definition at line 746 of file TSystem.cxx. ◆ FreeDirectory(). void TSystem::FreeDirectory ; (; void * ; dirp). virtual . Free a directory. ; Reimplemented in TDavixSystem, TUnixSystem, TWinNTSystem, TDCacheSystem, TWebSystem, TNetXNGSystem, and TNetSystem.; Definition at line 845 of file TSystem.cxx. ◆ GetAclicMode(). TSystem::EAclicMode TSystem::GetAclicMode ; (; ); const. virtual . AclicMode indicates whether the library should be built in debug mode or optimized. ; The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library . Definition at line 3947 of file TSystem.cxx. ◆ GetAclicProperties(). Int_t TSystem::GetAclicProperties ; (; ); const. virtual . Return the ACLiC properties field. ; See EAclicProperties for details on the semantic of each bit. ; Definition at line 3867 of file TSystem.cxx. ◆ GetBeepDefaults(). void TSystem::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:52855,access,access,52855,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['access'],['access']
Security,"m<float,2> >(const ROOT::Math::SVector<float,2U*(2U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,2>fRep; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5386,access,access,5386,root/html602/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,4,['access'],"['access', 'accessing']"
Security,"m<float,3> >(const ROOT::Math::SVector<float,3U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,3>fRep; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5386,access,access,5386,root/html602/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,4,['access'],"['access', 'accessing']"
Security,"m<float,4> >(const ROOT::Math::SVector<float,4U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,4>fRep; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5386,access,access,5386,root/html602/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,4,['access'],"['access', 'accessing']"
Security,"m<float,5> >(const ROOT::Math::SVector<float,5U*(5U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,5>fRep; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:5386,access,access,5386,root/html602/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,4,['access'],"['access', 'accessing']"
Security,"m<float,6> >(const ROOT::Math::SVector<float,6U*(6U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,6>fRep; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:5386,access,access,5386,root/html602/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,4,['access'],"['access', 'accessing']"
Security,"m<float,7> >(const ROOT::Math::SVector<float,7U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,7>fRep; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:5386,access,access,5386,root/html602/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,4,['access'],"['access', 'accessing']"
Security,"mation about name of data member, its type, and comment field string. It also tries to find the TMethodCall objects responsible for getting/setting a value of it, and gives you pointers to these methods. This gives you a unique possibility to access protected and private (!) data members if only methods for doing that are defined.; These methods could either be specified in a comment field, or found out automatically by ROOT: here's an example: suppose you have a class definition: class MyClass{; private:; Float_t fX1;; ...; public:; void SetX1(Float_t x) {fX1 = x;};; Float_t GetX1() {return fX1;};; ...; }; Float_tfloat Float_tDefinition RtypesCore.h:57; xDouble_t x[n]Definition legend1.C:17; Look at the data member name and method names: a data member name has a prefix letter (f) and has a base name X1 . The methods for getting and setting this value have names which consist of string Get/Set and the same base name. This convention of naming data fields and methods which access them allows TDataMember find this methods by itself completely automatically. To make this description complete, one should know, that names that are automatically recognized may be also: for data fields: either fXXX or fIsXXX; and for getter function GetXXX() or IsXXX() [where XXX is base name].; As an example of using it let's analyse a few lines which get and set a fEditable field in TCanvas: TCanvas *c = new TCanvas(""c""); // create a canvas; TClass *cl = c->IsA(); // get its class description object.; ; TDataMember *dm = cl->GetDataMember(""fEditable""); //This is our data member; ; TMethodCall *getter = dm->GetterMethod(c); //find a method that gets value!; Long_t l; // declare a storage for this value;; ; getter->Execute(c,"""",l); // Get this Value !!!! It will appear in l !!!; ; ; TMethodCall *setter = dm->SetterMethod(c);; setter->Execute(c,""0"",); // Set Value 0 !!!; c#define c(i)Definition RSha256.hxx:101; Long_tlong Long_tDefinition RtypesCore.h:54; TCanvasThe Canvas class.Definition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataMember.html:1734,access,access,1734,doc/master/classTDataMember.html,https://root.cern,https://root.cern/doc/master/classTDataMember.html,1,['access'],['access']
Security,"matrix representation.; 307 In the case of symmetric matrices the size is N*(N+1)/2.; 308 ; 309 */; 310 template<class InputIterator>; 311 void SetElements(InputIterator begin, unsigned int size, bool triang = false, bool lower = true);; 312 ; 313 ; 314 /** @name --- Operators --- */; 315 /// element wise comparison; 316 bool operator==(const T& rhs) const;; 317 /// element wise comparison; 318 bool operator!=(const T& rhs) const;; 319 /// element wise comparison; 320 template <class R2>; 321 bool operator==(const SMatrix<T,D1,D2,R2>& rhs) const;; 322 /// element wise comparison; 323 bool operator!=(const SMatrix<T,D1,D2,R>& rhs) const;; 324 /// element wise comparison; 325 template <class A, class R2>; 326 bool operator==(const Expr<A,T,D1,D2,R2>& rhs) const;; 327 /// element wise comparison; 328 template <class A, class R2>; 329 bool operator!=(const Expr<A,T,D1,D2,R2>& rhs) const;; 330 ; 331 /// element wise comparison; 332 bool operator>(const T& rhs) const;; 333 /// element wise comparison; 334 bool operator<(const T& rhs) const;; 335 /// element wise comparison; 336 template <class R2>; 337 bool operator>(const SMatrix<T,D1,D2,R2>& rhs) const;; 338 /// element wise comparison; 339 template <class R2>; 340 bool operator<(const SMatrix<T,D1,D2,R2>& rhs) const;; 341 /// element wise comparison; 342 template <class A, class R2>; 343 bool operator>(const Expr<A,T,D1,D2,R2>& rhs) const;; 344 /// element wise comparison; 345 template <class A, class R2>; 346 bool operator<(const Expr<A,T,D1,D2,R2>& rhs) const;; 347 ; 348 /**; 349 read only access to matrix element, with indices starting from 0; 350 */; 351 const T& operator()(unsigned int i, unsigned int j) const;; 352 /**; 353 read/write access to matrix element with indices starting from 0; 354 */; 355 T& operator()(unsigned int i, unsigned int j);; 356 ; 357 /**; 358 read only access to matrix element, with indices starting from 0.; 359 Function will check index values and it will assert if they are wrong; 360 */;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SMatrix_8h_source.html:11889,access,access,11889,doc/master/SMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html,3,['access'],['access']
Security,"maxx=0, Int_t binminy=1, Int_t binmaxy=0, Int_t cut=0, Option_t *option=""QNR"")Project slices along Z in case of a 3-D histogram, then fit each slice with function f1 and make a 2-...Definition TH3.cxx:978; TH3::DoProjectProfile2Dvirtual TProfile2D * DoProjectProfile2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool originalRange, bool useUF, bool useOF) constinternal method to project to a 2D Profile called from TH3::Project3DProfileDefinition TH3.cxx:2576; TH3::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH3.cxx:2889; THLimitsFinder::GetLimitsFinderstatic THLimitsFinder * GetLimitsFinder()Return pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:212566,hash,hash,212566,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['hash'],['hash']
Security,"may be “drawn”, which means attached to a pad.; When is the painting done then ? The answer is: when needed. Every object that derives from TObject has a Paint() method. It may be empty, but for graphical objects, this routine contains all the instructions to paint effectively it in the active pad. Since a Pad has the list of objects it owns, it will call successively the Paint() method of each object, thus re-painting the whole pad on the screen. If the object is a sub-pad, its Paint() method will call the Paint() method of the objects attached, recursively calling Paint() for all the objects. Pad painting. In some cases a pad need to be painted during a macro execution. To force the pad painting gPad->Update() (see next section) should be performed.; The list of primitives stored in the pad is also used to pick objects and to interact with them.; 9.3.1 The Global Pad: gPad; When an object is drawn, it is always in the so-called active pad. For every day use, it is comfortable to be able to access the active pad, whatever it is. For that purpose, there is a global pointer, called gPad. It is always pointing to the active pad. If you want to change the fill color of the active pad to blue but you do not know its name, do this.; root[] gPad->SetFillColor(38); To get the list of colors, go to the paragraph “Color and color palettes” or if you have an opened canvas, click on the View menu, selecting the Colors item.; 9.3.1.1 Finding an Object in a Pad; Now that we have a pointer to the active pad, gPad and that we know this pad contains some objects, it is sometimes interesting to access one of those objects. The method GetPrimitive() of TPad, i.e. TPad::GetPrimitive(const char* name) does exactly this. Since most of the objects that a pad contains derive from TObject, they have a name. The following statement will return a pointer to the object myobjectname and put that pointer into the variable obj. As you can see, the type of returned pointer is TObject*.; root[] ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:304353,access,access,304353,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"may execute in a critical section. In other words, the section is not reentrant.; A mutex, or mutual exclusion lock, is a synchronization object with two states locked and unlocked. A mutex is usually used to ensure that only one thread at a time executes some critical section of code. Before entering a critical section, a thread will attempt to lock the mutex, which guards that section. If the mutex is already locked, the thread will block until the mutex is unlocked, at which time it will lock the mutex, execute the critical section, and unlock the mutex upon leaving the critical section.; A semaphore is a synchronization mechanism that starts out initialized to some positive value. A thread may ask to wait on a semaphore in which case the thread blocks until the value of the semaphore is positive. At that time the semaphore count is decremented and the thread continues. When a thread releases semaphore, the semaphore count is incremented. Counting semaphores are useful for coordinating access to a limited pool of some resource.; Readers/Writer Lock - a multiple-reader, single-writer lock is one that allows simultaneous read access by many threads while restricting write access to only one thread at a time. When any thread holds the lock for reading, other threads can also acquire the lock reading. If one thread holds the lock for writing, or is waiting to acquire the lock for writing, other threads must wait to acquire the lock for either reading or writing.; Use a condition variable in conjunction with a mutex lock to automatically block threads until a particular condition is true.; Multithread Safe Levels - a possible classification scheme to describe thread-safety of libraries:. All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data used within a library. The developer must explicitly lock access to objects shared between threads. No other thread can write to a locked o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1122401,access,access,1122401,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"mber Function Documentation. ◆ Cd(). virtual Bool_t TGrid::Cd ; (; const char * ; = """", . Bool_t ; = kFALSE . ). inlinevirtual . Definition at line 90 of file TGrid.h. ◆ Class(). static TClass * TGrid::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGrid::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGrid::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 125 of file TGrid.h. ◆ Command(). virtual TGridResult * TGrid::Command ; (; const char * ; , . Bool_t ; = kFALSE, . UInt_t ; = 2 . ). inlinevirtual . Definition at line 72 of file TGrid.h. ◆ Connect(). TGrid * TGrid::Connect ; (; const char * ; grid, . const char * ; uid = nullptr, . const char * ; pw = nullptr, . const char * ; options = nullptr . ). static . The grid should be of the form: <grid>://<host>[:<port>], e.g.: alien://alice.cern.ch The uid is the username and pw the password that should be used for the connection. ; Depending on the <grid> the shared library (plugin) for the selected system will be loaded. When the connection could not be opened 0 is returned. For AliEn the supported options are: -domain=<domain name> -debug=<debug level from 1 to 10> Example: ""-domain=cern.ch -debug=5"" ; Definition at line 49 of file TGrid.cxx. ◆ DeclFileName(). static const char * TGrid::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 125 of file TGrid.h. ◆ GetGrid(). const char * TGrid::GetGrid ; (; ); const. inline . Definition at line 60 of file TGrid.h. ◆ GetHomeDirectory(). virtual const char * TGrid::GetHomeDirectory ; (; ). inlinevirtual . Definition at line 88 of file TGrid.h. ◆ GetHost(). const char * TGrid::GetHost ; (; ); const. inline . Definition at line 61 of file TGrid.h. ◆ GetJDLGenerator(). virtual TGridJDL * TGrid::GetJDLGenerator ; (; ). inlinevirtual . Definition at line 104 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGrid.html:13181,password,password,13181,doc/master/classTGrid.html,https://root.cern,https://root.cern/doc/master/classTGrid.html,1,['password'],['password']
Security,"mber Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <THashTable.h>. Inheritance diagram for THashTable:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ THashTable() [1/2]. THashTable::THashTable ; (; const THashTable & ; ). privatedelete . ◆ THashTable() [2/2]. THashTable::THashTable ; (; Int_t ; capacity = TCollection::kInitHashTableCapacity, . Int_t ; rehashlevel = 0 . ). Create a THashTable object. ; Capacity is the initial hashtable capacity (i.e. number of slots), by default kInitHashTableCapacity = 17, and rehashlevel is the value at which a rehash will be triggered. I.e. when the average size of the linked lists at a slot becomes longer than rehashlevel then the hashtable will be resized and refilled to reduce the collision rate to about 1. The higher the collision rate, i.e. the longer the linked lists, the longer lookup will take. If rehashlevel=0 the table will NOT automatically be rehashed. Use Rehash() for manual rehashing. ; Definition at line 43 of file THashTable.cxx. ◆ ~THashTable(). THashTable::~THashTable ; (; ). virtual . Delete a hashtable. ; Objects are not deleted unless the THashTable is the owner (set via SetOwner()). ; Definition at line 65 of file THashTable.cxx. Member Function Documentation. ◆ Add(). void THashTable::Add ; (; TObject * ; obj). overridevirtual . Add object to the hash table. ; Its position in the table will be determined by the value returned by its Hash() function. ; Implements TCollection.; Definition at line 92 of file THashTable.cxx. ◆ AddAll(). void THashTable::AddAll ; (; const TCollection * ; col). overridevirtual . Add all objects from collection col to this collection. ; Implemented for more",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:16678,hash,hashtable,16678,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hashtable']
Security,"mber Functions |; Private Attributes |; List of all members ; TClassDocInfo Class Reference. . Definition at line 29 of file TDocInfo.h. Public Member Functions;  TClassDocInfo (TClass *cl, const char *htmlfilename="""", const char *fsdecl="""", const char *fsimpl="""", const char *decl=0, const char *impl=0);  ;  TClassDocInfo (TDictionary *cl, const char *htmlfilename="""", const char *fsdecl="""", const char *fsimpl="""", const char *decl=0, const char *impl=0);  ;  ~TClassDocInfo () override;  ; Int_t Compare (const TObject *obj) const override;  Compare abstract method. ;  ; TDictionary * GetClass () const;  ; const char * GetDeclFileName () const;  ; const char * GetDeclFileSysName () const;  ; const char * GetHtmlFileName () const;  ; const char * GetImplFileName () const;  ; const char * GetImplFileSysName () const;  ; TList & GetListOfTypedefs ();  ; TModuleDocInfo * GetModule () const;  ; const char * GetName () const override;  Returns name of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t HaveSource () const;  ; TClass * IsA () const override;  ; Bool_t IsSelected () const;  ; Bool_t IsSortable () const override;  ; void SetDeclFileName (const char *name);  ; void SetDeclFileSysName (const char *fsname);  ; void SetHtmlFileName (const char *name);  ; void SetImplFileName (const char *name);  ; void SetImplFileSysName (const char *fsname);  ; void SetModule (TModuleDocInfo *module);  ; void SetSelected (Bool_t sel=kTRUE);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassDocInfo.html:1224,hash,hash,1224,doc/master/classTClassDocInfo.html,https://root.cern,https://root.cern/doc/master/classTClassDocInfo.html,1,['hash'],['hash']
Security,"mber Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TAuthenticate Class Reference. . Definition at line 53 of file TAuthenticate.h. Public Types; enum  ESecurity { ;   kClear; , kUnsupported; , kKrb5; , kGlobus; , ;   kSSH; , kRfio. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TAuthenticate (TSocket *sock, const char *remote, const char *proto, const char *user="""");  Create authentication object. ;  ; virtual ~TAuthenticate ();  ; Bool_t Authenticate ();  Authenticate to remote rootd or proofd server. ;  ; Int_t AuthExists (TString User, Int_t method, const char *Options, Int_t *Message, Int_t *Rflag, CheckSecCtx_t funcheck);  Check if we have a valid established sec context in memory Retrieves relevant info and negotiates with server. ;  ; void CatchTimeOut ();  Called in connection with a timer timeout. ;  ; Bool_t CheckNetrc (TString &user, TString &passwd);  Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc files. ;  ; Bool_t CheckNetrc (TString &user, TString &passwd, Bool_t &pwhash, Bool_t srppwd);  Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc files. ;  ; THostAuth * GetHostAuth () const;  ; const char * GetProtocol () const;  ; const char * GetRemoteHost () const;  ; Int_t GetRSAKeyType () const;  ; TRootSecContext * GetSecContext () const;  ; TSocket * GetSock",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:1317,authenticat,authentication,1317,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"mber pointer to the data member/enumerator; 827/// \param[in] scopeType enumerator to the scope type; 828 ; 829static TString; 830GetUrlForDataMember(const TString &scopeName, const TString &dataMemberName, TDataMember *dataMember, EUrl scopeType); 831{; 832 // We first check if the data member is not enumerator.; 833 if (!dataMember->IsEnum()) {; 834 // If we work with data members, we have to append a hashed with MD5 text, consisting of:; 835 // ""Type ClassName::DataMemberNameDataMemberName(arguments)"".; 836 // We first get the type of the data member.; 837 TString md5DataMember(dataMember->GetFullTypeName());; 838 md5DataMember.Append("" "");; 839 // We append the scopeName and ""::"".; 840 md5DataMember.Append(scopeName);; 841 md5DataMember.Append(""::"");; 842 // We append the dataMemberName twice.; 843 md5DataMember.Append(dataMemberName);; 844 md5DataMember.Append(dataMemberName);; 845 // We call UrlGenerator for the scopeName.; 846 TString urlForDataMember = UrlGenerator(scopeName, scopeType);; 847 // Then we append ""#a"" and the hashed text.; 848 urlForDataMember.Append(""#a"");; 849 urlForDataMember.Append(md5DataMember.MD5());; 850 return urlForDataMember;; 851 }; 852 // If the data member is enumerator, then we first have to check if the enumeration is anonymous.; 853 // Doxygen requires different syntax for anonymous enumeration (""scopeName::@1@1"").; 854 // We create a TString with the name of the scope and the enumeration from which the enumerator is.; 855 TString scopeEnumeration = dataMember->GetTrueTypeName();; 856 TString md5EnumClass;; 857 if (scopeEnumeration.Contains(""(unnamed)"")) {; 858 // FIXME: need to investigate the numbering scheme.; 859 md5EnumClass.Append(scopeName);; 860 md5EnumClass.Append(""::@1@1"");; 861 } else {; 862 // If the enumeration is not anonymous we put ""scopeName::Enumeration"" in a TString,; 863 // which will be hashed with MD5 later.; 864 md5EnumClass.Append(scopeEnumeration);; 865 // We extract the part after ""::"" (this is the enum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:31386,hash,hashed,31386,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['hash'],['hashed']
Security,"mbers.h. ◆ IsLoaded(). Bool_t TListOfDataMembers::IsLoaded ; (; ); const. inline . Definition at line 79 of file TListOfDataMembers.h. ◆ Load(). void TListOfDataMembers::Load ; (; ). Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 399 of file TListOfDataMembers.cxx. ◆ MapObject(). void TListOfDataMembers::MapObject ; (; TObject * ; obj). private . Add a pair<id, object> to the map of data members and their ids. ; Definition at line 50 of file TListOfDataMembers.cxx. ◆ operator=(). TListOfDataMembers & TListOfDataMembers::operator= ; (; const TListOfDataMembers & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfDataMembers::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from THashList.; Definition at line 353 of file TListOfDataMembers.cxx. ◆ Remove() [1/2]. TObject * TListOfDataMembers::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Reimplemented from THashList.; Definition at line 366 of file TListOfDataMembers.cxx. ◆ Remove() [2/2]. TObject * TListOfDataMembers::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from THashList.; Definition at line 382 of file TListOfDataMembers.cxx. ◆ SetClass(). void TListOfDataMembers::SetClass ; (; TClass * ; cl). inline . Definition at line 91 of file TListOfDataMembers.h. ◆ Streamer(). void TListOfDataMembers::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TListOfDataMembers. ; Reimplemented from THashList.; Definition at line 484 of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:31691,hash,hash,31691,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,2,['hash'],['hash']
Security,"mbie. private:. Int_tfRSAKeyType of RSA key used. Class Charts. Inheritance Chart:. TObject. ←; TSecContext. ←; TRootSecContext. Function documentation; TRootSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object.; User and host from url = user@host . ~TRootSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If globus, cleanup local stuff; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1). Int_t GetRSAKey() const; { return fRSAKey; }. » Author: G. Ganis 08/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id$ » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootSecContext.html:7826,secur,security,7826,root/html604/TRootSecContext.html,https://root.cern,https://root.cern/root/html604/TRootSecContext.html,2,['secur'],['security']
Security,"mbie. private:. Int_tfRSAKeyType of RSA key used. Class Charts. Inheritance Chart:. TObject. ←; TSecContext. ←; TRootSecContext. Function documentation; TRootSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object.; User and host from url = user@host . ~TRootSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If globus, cleanup local stuff; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1). Int_t GetRSAKey() const; { return fRSAKey; }. » Author: G. Ganis 08/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootSecContext.html:7826,secur,security,7826,root/html602/TRootSecContext.html,https://root.cern,https://root.cern/root/html602/TRootSecContext.html,2,['secur'],['security']
Security,"mbie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meas; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to globa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPullVar.html:34124,validat,validate,34124,root/html602/RooPullVar.html,https://root.cern,https://root.cern/root/html602/RooPullVar.html,4,"['access', 'validat']","['access', 'validate']"
Security,"mcpy(fCoordinates + idx * fSingleCoordinateSize, coordbuf, fSingleCoordinateSize);; 474 fCoordinatesSize += fSingleCoordinateSize;; 475}; 476 ; 477////////////////////////////////////////////////////////////////////////////////; 478/// Turn on support of errors; 479 ; 480void THnSparseArrayChunk::Sumw2(); 481{; 482 if (!fSumw2); 483 fSumw2 = new TArrayD(fContent->GetSize());; 484 // fill the structure with the current content; 485 for (Int_t bin=0; bin < fContent->GetSize(); bin++) {; 486 fSumw2->fArray[bin] = fContent->GetAt(bin);; 487 }; 488 ; 489}; 490 ; 491 ; 492/** \class THnSparse; 493 \ingroup Hist; 494 ; 495Efficient multidimensional histogram.; 496 ; 497Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; 498only a small fraction of bins is filled. A 10-dimensional histogram with 10; 499bins per dimension has 10^10 bins; in a naive implementation this will not; 500fit in memory. THnSparse only allocates memory for the bins that have; 501non-zero bin content instead, drastically reducing both the memory usage; 502and the access time.; 503 ; 504To construct a THnSparse object you must use one of its templated, derived; 505classes:; 506- THnSparseD (typedef for THnSparseT<ArrayD>): bin content held by a Double_t,; 507- THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,; 508- THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,; 509- THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; 510- THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; 511- THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,; 512 ; 513They take name and title, the number of dimensions, and for each dimension; 514the number of bins, the minimal, and the maximal value on the dimension's; 515axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 516 ; 517 Int_t bins[2] = {10, 20};; 518 Double_t xmin[2] = {0., -5.};; 519 Double_t xmax[2] ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:17845,access,access,17845,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['access'],['access']
Security,"me ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TGPicturePool (const TGPicturePool &);  copy constructor ;  ; TGPicturePool & operator= (const TGPicturePool &);  assignment operator ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; const TGClient * fClient;  client for which we keep icon pool ;  ; TString fPath;  icon search path ;  ; THashTable * fPicList;  hash table containing the icons ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGPicture.h>. Inheritance diagram for TGPicturePool:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGPicturePool.html:10071,hash,hash,10071,doc/master/classTGPicturePool.html,https://root.cern,https://root.cern/doc/master/classTGPicturePool.html,1,['hash'],['hash']
Security,me TNtuple from different threads ;  mt201_parallelHistoFill.C Parallel fill of a histogram ;  mt301_TTaskGroupSimple.C Shows how to run items of work asynchronously with a TTaskGroup ;  mt302_TTaskGroupNested.C Calculate Fibonacci numbers exploiting nested parallelism through TTaskGroup ;  mt303_AsyncSimple.C Shows how to run items of work asynchronously with Async ;  mt304_AsyncNested.C Calculate Fibonacci numbers exploiting nested parallelism through Async ;  mt304_fillHistos.CFill histograms in parallel with automatic binning ;  mt305_TFuture.C Shows how to use the Future class of ROOT as a wrapper of std::future ;  mtbb001_fillHistos.C Fill histograms in parallel and write them on file ;  mtbb101_fillNtuples.C Fill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.C Parallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:136084,authenticat,authentication,136084,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['authenticat'],['authentication']
Security,"me());; 1846 }; 1847 next = &fListOfFriends;; 1848 TFriendProxyDescriptor *fpd;; 1849 while ( (fpd = (TFriendProxyDescriptor*)next()) ) {; 1850 fprintf(hf,"",\n %-*s(&fDirector,tree,%d)"",; 1851 fMaxDatamemberType, fpd->GetTitle(), fpd->GetIndex());; 1852 }; 1853 ; 1854 fprintf(hf, ""\n { }\n"");; 1855 ; 1856 // Other functions.; 1857 fprintf(hf,"" ~%s() override;\n"",classname.Data());; 1858 fprintf(hf,"" Int_t Version() const override {return 1;}\n"");; 1859 fprintf(hf,"" void Begin(::TTree *tree) override;\n"");; 1860 fprintf(hf,"" void SlaveBegin(::TTree *tree) override;\n"");; 1861 fprintf(hf,"" void Init(::TTree *tree) override;\n"");; 1862 fprintf(hf,"" bool Notify() override;\n"");; 1863 fprintf(hf,"" bool Process(Long64_t entry) override;\n"");; 1864 fprintf(hf,"" void SlaveTerminate() override;\n"");; 1865 fprintf(hf,"" void Terminate() override;\n"");; 1866 fprintf(hf,""\n"");; 1867 fprintf(hf,"" ClassDefOverride(%s,0);\n"",classname.Data());; 1868 fprintf(hf,""\n\n"");; 1869 ; 1870 fprintf(hf,""//inject the user's code\n"");; 1871 fprintf(hf,""#include \""%s\""\n"",fScript.Data());; 1872 ; 1873 if (cutfilename) {; 1874 fprintf(hf,""#include \""%s\""\n"",fCutScript.Data());; 1875 }; 1876 ; 1877 // Close the class.; 1878 fprintf(hf,""};\n"");; 1879 fprintf(hf,""\n"");; 1880 fprintf(hf,""#endif\n"");; 1881 fprintf(hf,""\n\n"");; 1882 ; 1883 fprintf(hf,""#ifdef __MAKECINT__\n"");; 1884 if (fListOfClasses.LastIndex()>=0) {; 1885 TBranchProxyClassDescriptor *clp;; 1886 next = &fListOfClasses;; 1887 while ( (clp = (TBranchProxyClassDescriptor*)next()) ) {; 1888 fprintf(hf,""#pragma link C++ class %s::%s-;\n"",classname.Data(),clp->GetName());; 1889 if (clp->GetContainerName().Length()) {; 1890 R__AddPragmaForClass(this, clp->GetContainerName());; 1891 }; 1892 }; 1893 next = &fListOfPragmas;; 1894 TObjString *prag;; 1895 while ( (prag = (TObjString*)next()) ) {; 1896 fprintf(hf,""%s"",prag->String().Data());; 1897 }; 1898 }; 1899 fprintf(hf,""#pragma link C++ class %s;\n"",classname.Data());; 1900 fprintf(hf,""#endif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:70952,inject,inject,70952,doc/master/TTreeProxyGenerator_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html,1,['inject'],['inject']
Security,"me(),update);; 6470 update = kFALSE;; 6471 if (acl) {; 6472 if (acl->GetClassVersion() == 0) continue;; 6473 }; 6474 ; 6475 // dm->GetArrayIndex() returns an empty string if it does not; 6476 // applies; 6477 const char * index = dm->GetArrayIndex();; 6478 if (strlen(index)==0); 6479 snprintf(local,100,""%s %s;"",dm->GetFullTypeName(),dm->GetName());; 6480 else; 6481 snprintf(local,100,""%s %s[%s];"",dm->GetFullTypeName(),dm->GetName(),index);; 6482 strlcat(temp,local,10000);; 6483 }; 6484 //fStreamerInfo = temp;; 6485 delete [] temp;; 6486*/; 6487 return nullptr;; 6488}; 6489 ; 6490////////////////////////////////////////////////////////////////////////////////; 6491/// Return true if the checksum passed as argument is one of the checksum; 6492/// value produced by the older checksum calculation algorithm.; 6493 ; 6494Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6495{; 6496 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6497 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6498 }; 6499 return kFALSE;; 6500}; 6501 ; 6502////////////////////////////////////////////////////////////////////////////////; 6503/// Call GetCheckSum with validity check.; 6504 ; 6505UInt_t TClass::GetCheckSum(ECheckSum code) const; 6506{; 6507 bool isvalid;; 6508 return GetCheckSum(code,isvalid);; 6509}; 6510 ; 6511////////////////////////////////////////////////////////////////////////////////; 6512/// Return GetCheckSum(kCurrentCheckSum,isvalid);; 6513 ; 6514UInt_t TClass::GetCheckSum(Bool_t &isvalid) const; 6515{; 6516 return GetCheckSum(kCurrentCheckSum,isvalid);; 6517}; 6518 ; 6519////////////////////////////////////////////////////////////////////////////////; 6520/// Compute and/or return the class check sum.; 6521///; 6522/// isvalid is set to false, if the function is unable to calculate the; 6523/// checksum.; 6524///; 6525/// The class ckecksum is used by the automatic schema evolution algorithm; 6526/// to uniquely identify a class version.; 6527/// The che",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:249212,checksum,checksum,249212,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['checksum'],['checksum']
Security,"me(),update);; 6537 update = kFALSE;; 6538 if (acl) {; 6539 if (acl->GetClassVersion() == 0) continue;; 6540 }; 6541 ; 6542 // dm->GetArrayIndex() returns an empty string if it does not; 6543 // applies; 6544 const char * index = dm->GetArrayIndex();; 6545 if (strlen(index)==0); 6546 snprintf(local,100,""%s %s;"",dm->GetFullTypeName(),dm->GetName());; 6547 else; 6548 snprintf(local,100,""%s %s[%s];"",dm->GetFullTypeName(),dm->GetName(),index);; 6549 strlcat(temp,local,10000);; 6550 }; 6551 //fStreamerInfo = temp;; 6552 delete [] temp;; 6553*/; 6554 return nullptr;; 6555}; 6556 ; 6557////////////////////////////////////////////////////////////////////////////////; 6558/// Return true if the checksum passed as argument is one of the checksum; 6559/// value produced by the older checksum calculation algorithm.; 6560 ; 6561Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6562{; 6563 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6564 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6565 }; 6566 return kFALSE;; 6567}; 6568 ; 6569////////////////////////////////////////////////////////////////////////////////; 6570/// Call GetCheckSum with validity check.; 6571 ; 6572UInt_t TClass::GetCheckSum(ECheckSum code) const; 6573{; 6574 bool isvalid;; 6575 return GetCheckSum(code,isvalid);; 6576}; 6577 ; 6578////////////////////////////////////////////////////////////////////////////////; 6579/// Return GetCheckSum(kCurrentCheckSum,isvalid);; 6580 ; 6581UInt_t TClass::GetCheckSum(Bool_t &isvalid) const; 6582{; 6583 return GetCheckSum(kCurrentCheckSum,isvalid);; 6584}; 6585 ; 6586////////////////////////////////////////////////////////////////////////////////; 6587/// Compute and/or return the class check sum.; 6588///; 6589/// isvalid is set to false, if the function is unable to calculate the; 6590/// checksum.; 6591///; 6592/// The class ckecksum is used by the automatic schema evolution algorithm; 6593/// to uniquely identify a class version.; 6594/// The che",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:251963,checksum,checksum,251963,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['checksum'],['checksum']
Security,"me(). static const char * ROOT::Detail::TSchemaRuleSet::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 76 of file TSchemaRuleSet.h. ◆ FindRules() [1/4]. const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules ; (; const TString & ; source); const. Return all the rules that are about the given 'source' class. ; User has to delete the returned array ; Definition at line 289 of file TSchemaRuleSet.cxx. ◆ FindRules() [2/4]. const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules ; (; const TString & ; source, . Int_t ; version . ); const. Return all the rules that applies to the specified version of the given 'source' class. ; User has to delete the returned array ; Definition at line 328 of file TSchemaRuleSet.cxx. ◆ FindRules() [3/4]. const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules ; (; const TString & ; source, . Int_t ; version, . UInt_t ; checksum . ); const. Return all the rules that applies to the specified version OR checksum of the given 'source' class. ; User has to delete the returned array ; Definition at line 368 of file TSchemaRuleSet.cxx. ◆ FindRules() [4/4]. const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules ; (; const TString & ; source, . UInt_t ; checksum . ); const. Return all the rules that applies to the specified checksum of the given 'source' class. ; User has to delete the returned array ; Definition at line 348 of file TSchemaRuleSet.cxx. ◆ GetClass(). TClass * TSchemaRuleSet::GetClass ; (; ). Definition at line 386 of file TSchemaRuleSet.cxx. ◆ GetClassCheckSum(). UInt_t TSchemaRuleSet::GetClassCheckSum ; (; ); const. Definition at line 393 of file TSchemaRuleSet.cxx. ◆ GetClassName(). TString TSchemaRuleSet::GetClassName ; (; ); const. Definition at line 403 of file TSchemaRuleSet.cxx. ◆ GetClassVersion(). Int_t TSchemaRuleSet::GetClassVersion ; (; ); const. Definition at line 410 of file TSchemaRuleSet.cxx. ◆ GetPersistentRules(). const TObjArray * TSchemaRul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html:15644,checksum,checksum,15644,doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html,1,['checksum'],['checksum']
Security,"me);; 860 md5EnumClass.Append(""::@1@1"");; 861 } else {; 862 // If the enumeration is not anonymous we put ""scopeName::Enumeration"" in a TString,; 863 // which will be hashed with MD5 later.; 864 md5EnumClass.Append(scopeEnumeration);; 865 // We extract the part after ""::"" (this is the enumerator name).; 866 TString enumOnlyName = TClassEdit::GetUnqualifiedName(scopeEnumeration);; 867 // The syntax is ""Class::EnumeratorEnumerator; 868 md5EnumClass.Append(enumOnlyName);; 869 }; 870 // The next part of the URL is hashed ""@ scopeName::EnumeratorEnumerator"".; 871 TString md5Enumerator(""@ "");; 872 md5Enumerator.Append(scopeName);; 873 md5Enumerator.Append(""::"");; 874 md5Enumerator.Append(dataMemberName);; 875 md5Enumerator.Append(dataMemberName);; 876 // We make the URL for the ""scopeName"".; 877 TString url = UrlGenerator(scopeName, scopeType);; 878 // Then we have to append the hashed text for the enumerator.; 879 url.Append(""#a"");; 880 url.Append(md5EnumClass.MD5());; 881 // We append ""a"" and then the next hashed text.; 882 url.Append(""a"");; 883 url.Append(md5Enumerator.MD5());; 884 return url;; 885}; 886} // namespace; 887 ; 888namespace {; 889////////////////////////////////////////////////////////////////////////////////; 890/// The function generates URL for enumeration. The hashed text consist of:; 891/// ""Class::EnumerationEnumeration"".; 892///; 893/// \param[in] scopeName the name of the class/namespace/struct; 894/// \param[in] enumeration the name of the enumeration; 895/// \param[in] scopeType enumerator for class/namespace/struct; 896 ; 897static TString GetUrlForEnumeration(TString scopeName, const TString &enumeration, EUrl scopeType); 898{; 899 // The URL consists of URL for the ""scopeName"", ""#a"" and hashed as MD5 text.; 900 // The text is ""Class::EnumerationEnumeration.; 901 TString md5Enumeration(scopeName);; 902 md5Enumeration.Append(""::"");; 903 md5Enumeration.Append(enumeration);; 904 md5Enumeration.Append(enumeration);; 905 // We make the URL for the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:33068,hash,hashed,33068,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['hash'],['hashed']
Security,"me, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::SetVisibilityvoid SetVisibility(Bool_t vis=kTRUE) overrideset visibility of this volumeDefinition TGeoVolume.cxx:2347; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TGeoVolume::GetShapeTGeoShape * GetShape() constDefinition TGeoVolume.h:190; double; rootgeomTGeoNode * rootgeom()Definition eveGeoBrowser.C:47; End_Macro. TGeoManager - the manager class for the geometry package.; TGeoManager class is embedding all the API needed for building and tracking a geometry. It defines a global pointer (gGeoManager) in order to be fully accessible from external code. The mechanism of handling multiple geometries at the same time will be soon implemented.; TGeoManager is the owner of all geometry objects defined in a session, therefore users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The caching mechanism is triggered by the total number of physical instances of volumes and the cache manager is a client of TGeoManager. The manager class also controls the painter client. This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Rules for building a valid geometry; A given geometry can be built in various ways, but there are mandatory steps",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:13134,access,accessible,13134,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['access'],['accessible']
Security,"me, alternate);; 928 }; 929}; 930 ; 931void ROOT::RemoveClassAlternate(TClassAlt *alt); 932{; 933 // This routine is meant to be called (indirectly) by dlclose so we; 934 // we are guaranteed that the library initialization has completed.; 935 TClassTable::RemoveAlternate(alt);; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Global function to update the version number.; 940/// This is called via the RootClassVersion macro.; 941///; 942/// if cl!=0 and cname==-1, set the new class version if and only is; 943/// greater than the existing one and greater or equal to 2;; 944/// and also ignore the request if fVersionUsed is true.; 945///; 946/// Note on class version number:; 947/// - If no class has been specified, TClass::GetVersion will return -1; 948/// - The Class Version 0 request the whole object to be transient; 949/// - The Class Version 1, unless specify via ClassDef indicates that the; 950/// I/O should use the TClass checksum to distinguish the layout of the class; 951void ROOT::ResetClassVersion(TClass *cl, const char *cname, Short_t newid); 952{; 953 if (cname && cname != (void*)-1 && TClassTable::CheckClassTableInit()) {; 954 TClassTable::NormalizeThenLock guard(cname);; 955 TClassRec *r = TClassTable::FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 956 if (r); 957 r->fId = newid;; 958 }; 959 if (cl) {; 960 if (cl->fVersionUsed) {; 961 // Problem, the reset is called after the first usage!; 962 if (cname!=(void*)-1); 963 Error(""ResetClassVersion"",""Version number of %s can not be changed after first usage!"",; 964 cl->GetName());; 965 } else {; 966 if (newid < 0) {; 967 Error(""SetClassVersion"",""The class version (for %s) must be positive (value %d is ignored)"",cl->GetName(),newid);; 968 }; 969 if (cname==(void*)-1) {; 970 if (cl->fClassVersion<newid && 2<=newid) {; 971 cl->SetClassVersion(newid);; 972 }; 973 } else {; 974 cl->SetClassVersion(newid);; 975 }; 976 }; 977 }; 978}; 979 ; 980 ; 98",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:31024,checksum,checksum,31024,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['checksum'],['checksum']
Security,"me.; Classes that give objects a name should override this method. const char * GetIconName() const; Returns mime type name of object. Used by the TBrowser (via TGMimeTypes; class). Override for class of which you would like to have different; icons for objects of the same class. UInt_t GetUniqueID() const; Return the unique object id. char * GetObjectInfo(Int_t px, Int_t py) const; Returns string containing info about the object at position (px,py).; This method is typically overridden by classes of which the objects; can report peculiarities for different positions.; Returned string will be re-used (lock in MT environment). const char * GetTitle() const; Returns title of object. This default method returns the class title; (i.e. description). Classes that give objects a title should override; this method. Bool_t HandleTimer(TTimer* timer); Execute action in response of a timer timing out. This method; must be overridden if an object has to react to timers. ULong_t Hash() const; Return hash value for this object. Bool_t InheritsFrom(const char* classname) const; Returns kTRUE if object inherits from class ""classname"". Bool_t InheritsFrom(const TClass* cl) const; Returns kTRUE if object inherits from TClass cl. void Inspect() const; Dump contents of this object in a graphics canvas.; Same action as Dump but in a graphical form.; In addition pointers to other objects can be followed. The following picture is the Inspect of a histogram object:. /*; ; */. Bool_t IsFolder() const; Returns kTRUE in case object contains browsable objects (like containers; or lists of other objects). Bool_t IsEqual(const TObject* obj) const; Default equal comparison (objects are equal if they have the same; address in memory). More complicated classes might want to override; this function. void ls(Option_t* option = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump(). Bool_t Notify(); This method must be overridden to han",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObject.html:10753,hash,hash,10753,root/html528/TObject.html,https://root.cern,https://root.cern/root/html528/TObject.html,6,['hash'],['hash']
Security,"med in dedicated thread; 145 bool fSendMT{false}; ///<! true is special threads should be used for sending data; 146 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 147 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 148 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 149 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 150 ConnectionsList_t fConn; ///<! list of all accepted connections; 151 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 152 unsigned fConnLimit{1}; ///<! number of allowed active connections; 153 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 154 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 155 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 156 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 157 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 158 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 159 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:7329,access,access,7329,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['access'],['access']
Security,"med in dedicated thread; 148 bool fSendMT{false}; ///<! true is special threads should be used for sending data; 149 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 150 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 151 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 152 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 153 ConnectionsList_t fConn; ///<! list of all accepted connections; 154 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 155 unsigned fConnLimit{1}; ///<! number of allowed active connections; 156 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 157 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 158 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 159 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 160 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 161 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 162 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:7480,access,access,7480,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['access'],['access']
Security,"med)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 8234 (32.16 KB); Trainable params: 8234 (32.16 KB); Non-trainable params: 0 (0.00 Byte); ________________________________________________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:10874,validat,validation,10874,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['validat'],['validation']
Security,"med)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Running with nthreads = 4; --- RNNClassification : Using input file: time_data_t10_d30.root; number of variables is 300; vars_time0[0]; vars_time0[1]; vars_time0[2]; vars_time0[3]; vars_time0[4]; vars_time0[5]; vars_time0[6]; vars_time0[7]; vars_time0[8]; vars_time0[9]; vars_time0[10]; vars_time0[11]; vars_time0[12]; vars_time0[13]; vars_time0[14]; vars_time0[15]; vars_time0[16]; vars_time0[17]; vars_time0[18]; vars_time0[19]; vars_time0[20]; vars_time0[21]; vars_time0[22]; vars_time0[23]; vars_time0[24]; vars_time0[25]; vars_time0[26]; vars_time0[27]; vars_time0[28]; vars_time0[29",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:6338,validat,validation,6338,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['validat'],['validation']
Security,"member are not split, except for pointers to a TClonesArray. The TClonesArray (pointed to) is split if the split level is greater than two. When the split level is one, the TClonesArray is not split.; If a data member is a pointer to an object, a special branch is created. The branch will be filled by calling the class Streamer function to serialize the object into the branch buffer.; If a data member is an object, the data members of this object are split into branches according to the split-level (i.e. split-level > 2).; Base classes are split when the object is split.; Abstract base classes are never split.; All STL containers are supported. // STL vector of vectors of TAxis*; vector<vector<TAxis *> > fVectAxis;; // STL map of string/vector; map<string,vector<int> > fMapString;; // STL deque of pair; deque<pair<float,float> > fDequePair;. C-structure data members are not supported in split mode.; An object that is not split may be slow to browse.; A STL container that is not split will not be accessible in the browser. 12.10.2 Exempt a Data Member from Splitting; If you are creating a branch with an object and in general you want the data members to be split, but you want to exempt a data member from the split. You can specify this in the comment field of the data member:; class Event : public TObject {; private:; EventHeader fEvtHdr; //|| Don't split the header; 12.10.3 Adding a Branch to Hold a TClonesArray; ROOT has two classes to manage arrays of objects. The TObjArray can manage objects of different classes, and the TClonesArray that specializes in managing objects of the same class (hence the name Clones Array). TClonesArray takes advantage of the constant size of each element when adding the elements to the array. Instead of allocating memory for each new object as it is added, it reuses the memory. Here is an example of the time a TClonesArray can save over a TObjArray. We have 100,000 events, and each has 10,000 tracks, which gives 1,000,000,000 tracks. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:546340,access,accessible,546340,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessible']
Security,"members; data members; class charts. ROOT; » IO; » CASTOR; » TCastorFile. class TCastorFile: public TNetFile. TCastorFile. A TCastorFile is like a normal TNetFile except that it obtains the; remote node (disk server) via the CASTOR API, once the disk server; and the local file path are determined, the file will be accessed; via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root. If Castor 2.1 is used the file names can also be specified; in the following ways:. castor://stager_host:stager_port/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor://stager_host/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor:///castor?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. path is mandatory as parameter but all the other ones are optional. Use ""&rootAuth=<auth_prot_code>"" in the option field to force the; specified authentication protocol when contacting the server, e.g. castor:///castor?path=/castor/cern.ch/user/r/rdm/bla.root; &svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION&rootAuth=3. will try first the globus/GSI protocol; available protocols are; 0: passwd, 1: srp, 2: krb5, 3: globus, 4: ssh, 5 uidgid; The defaul is taken from the env ROOTCASTORAUTH. Function Members (Methods); public:. TCastorFile(); TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TCastorFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TCastorFile.html:1197,authenticat,authentication,1197,root/html530/TCastorFile.html,https://root.cern,https://root.cern/root/html530/TCastorFile.html,2,['authenticat'],['authentication']
Security,"memset to,; 2896 * some fields like size and modification date with values */; 2897 found = mg_stat(conn, path, &(filep->stat));; 2898 ; 2899 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2900 /* file does not exist and will not be created */; 2901 return 0;; 2902 }; 2903 ; 2904#if defined(_WIN32); 2905 {; 2906 wchar_t wbuf[UTF16_PATH_MAX];; 2907 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2908 switch (mode) {; 2909 case MG_FOPEN_MODE_READ:; 2910 filep->access.fp = _wfopen(wbuf, L""rb"");; 2911 break;; 2912 case MG_FOPEN_MODE_WRITE:; 2913 filep->access.fp = _wfopen(wbuf, L""wb"");; 2914 break;; 2915 case MG_FOPEN_MODE_APPEND:; 2916 filep->access.fp = _wfopen(wbuf, L""ab"");; 2917 break;; 2918 }; 2919 }; 2920#else; 2921 /* Linux et al already use unicode. No need to convert. */; 2922 switch (mode) {; 2923 case MG_FOPEN_MODE_READ:; 2924 filep->access.fp = fopen(path, ""r"");; 2925 break;; 2926 case MG_FOPEN_MODE_WRITE:; 2927 filep->access.fp = fopen(path, ""w"");; 2928 break;; 2929 case MG_FOPEN_MODE_APPEND:; 2930 filep->access.fp = fopen(path, ""a"");; 2931 break;; 2932 }; 2933 ; 2934#endif; 2935 if (!found) {; 2936 /* File did not exist before fopen was called.; 2937 * Maybe it has been created now. Get stat info; 2938 * like creation time now. */; 2939 found = mg_stat(conn, path, &(filep->stat));; 2940 (void)found;; 2941 }; 2942 ; 2943 /* return OK if file is opened */; 2944 return (filep->access.fp != NULL);; 2945}; 2946 ; 2947 ; 2948/* return 0 on success, just like fclose */; 2949static int; 2950mg_fclose(struct mg_file_access *fileacc); 2951{; 2952 int ret = -1;; 2953 if (fileacc != NULL) {; 2954 if (fileacc->fp != NULL) {; 2955 ret = fclose(fileacc->fp);; 2956 }; 2957 /* reset all members of fileacc */; 2958 memset(fileacc, 0, sizeof(*fileacc));; 2959 }; 2960 return ret;; 2961}; 2962#endif /* NO_FILESYSTEMS */; 2963 ; 2964 ; 2965static void; 2966mg_strlcpy(char *dst, const char *src, size_t n); 2967{; 2968 for (; *src != '\0' && n > 1; n--) {; 2969 *dst++ = *s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:89538,access,access,89538,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"memset to,; 2897 * some fields like size and modification date with values */; 2898 found = mg_stat(conn, path, &(filep->stat));; 2899 ; 2900 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2901 /* file does not exist and will not be created */; 2902 return 0;; 2903 }; 2904 ; 2905#if defined(_WIN32); 2906 {; 2907 wchar_t wbuf[UTF16_PATH_MAX];; 2908 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2909 switch (mode) {; 2910 case MG_FOPEN_MODE_READ:; 2911 filep->access.fp = _wfopen(wbuf, L""rb"");; 2912 break;; 2913 case MG_FOPEN_MODE_WRITE:; 2914 filep->access.fp = _wfopen(wbuf, L""wb"");; 2915 break;; 2916 case MG_FOPEN_MODE_APPEND:; 2917 filep->access.fp = _wfopen(wbuf, L""ab"");; 2918 break;; 2919 }; 2920 }; 2921#else; 2922 /* Linux et al already use unicode. No need to convert. */; 2923 switch (mode) {; 2924 case MG_FOPEN_MODE_READ:; 2925 filep->access.fp = fopen(path, ""r"");; 2926 break;; 2927 case MG_FOPEN_MODE_WRITE:; 2928 filep->access.fp = fopen(path, ""w"");; 2929 break;; 2930 case MG_FOPEN_MODE_APPEND:; 2931 filep->access.fp = fopen(path, ""a"");; 2932 break;; 2933 }; 2934 ; 2935#endif; 2936 if (!found) {; 2937 /* File did not exist before fopen was called.; 2938 * Maybe it has been created now. Get stat info; 2939 * like creation time now. */; 2940 found = mg_stat(conn, path, &(filep->stat));; 2941 (void)found;; 2942 }; 2943 ; 2944 /* return OK if file is opened */; 2945 return (filep->access.fp != NULL);; 2946}; 2947 ; 2948 ; 2949/* return 0 on success, just like fclose */; 2950static int; 2951mg_fclose(struct mg_file_access *fileacc); 2952{; 2953 int ret = -1;; 2954 if (fileacc != NULL) {; 2955 if (fileacc->fp != NULL) {; 2956 ret = fclose(fileacc->fp);; 2957 }; 2958 /* reset all members of fileacc */; 2959 memset(fileacc, 0, sizeof(*fileacc));; 2960 }; 2961 return ret;; 2962}; 2963#endif /* NO_FILESYSTEMS */; 2964 ; 2965 ; 2966static void; 2967mg_strlcpy(char *dst, const char *src, size_t n); 2968{; 2969 for (; *src != '\0' && n > 1; n--) {; 2970 *dst++ = *s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:89570,access,access,89570,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"ment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . #include <TEmulatedCollectionProxy.h>. Inheritance diagram for TEmulatedCollectionProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Cont_t. typedef std::vector<char> TEmulated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:12700,access,accessors,12700,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,1,['access'],['accessors']
Security,"ment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . #include <TEmulatedMapProxy.h>. Inheritance diagram for TEmulatedMapProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEmulatedMapProxy() [1/2]. TEmulatedMapProxy::T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedMapProxy.html:12838,access,accessors,12838,doc/master/classTEmulatedMapProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedMapProxy.html,1,['access'],['accessors']
Security,"ment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenBitsetProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGenBitsetProxy(). TGenBitsetProxy::TGenBitsetProxy ; (; const TGenCollectionProx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenBitsetProxy.html:10854,access,accessors,10854,doc/master/classTGenBitsetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenBitsetProxy.html,1,['access'],['accessors']
Security,"ment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenListProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGenListProxy(). TGenListProxy::TGenListProxy ; (; const TGenCollectionProxy & ; c)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenListProxy.html:10992,access,accessors,10992,doc/master/classTGenListProxy.html,https://root.cern,https://root.cern/doc/master/classTGenListProxy.html,1,['access'],['accessors']
Security,"ment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenMapProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGenMapProxy(). TGenMapProxy::TGenMapProxy ; (; const TGenCollectionProxy & ; c). in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenMapProxy.html:11426,access,accessors,11426,doc/master/classTGenMapProxy.html,https://root.cern,https://root.cern/doc/master/classTGenMapProxy.html,1,['access'],['accessors']
Security,"ment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenSetProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGenSetProxy(). TGenSetProxy::TGenSetProxy ; (; const TGenCollectionProxy & ; c). in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenSetProxy.html:11187,access,accessors,11187,doc/master/classTGenSetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenSetProxy.html,1,['access'],['accessors']
Security,"ment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenVectorBoolProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGenVectorBoolProxy(). TGenVectorBoolProxy::TGenVectorBoolProxy ; (; const TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenVectorBoolProxy.html:11049,access,accessors,11049,doc/master/classTGenVectorBoolProxy.html,https://root.cern,https://root.cern/doc/master/classTGenVectorBoolProxy.html,1,['access'],['accessors']
Security,"ment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenVectorProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGenVectorProxy(). TGenVectorProxy::TGenVectorProxy ; (; const TGenCollectionProx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenVectorProxy.html:10969,access,accessors,10969,doc/master/classTGenVectorProxy.html,https://root.cern,https://root.cern/doc/master/classTGenVectorProxy.html,1,['access'],['accessors']
Security,"ment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Private Member Functions; TGenCollectionStreamer & operator= (const TGenCollectionStreamer &);  . Additional Inherited Members;  Public Types inherited from TGenCollectionProxy; enum  { kBIT_ISSTRING = 0x20000000; , kBIT_ISTSTRING = 0x40000000; };  ; typedef co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:11343,access,accessors,11343,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['access'],['accessors']
Security,ment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Private Member Functions;  TGenCollectionProxy ();  ; TGenCollectionProxy & operator= (const TGenCollectionProxy &);  . Friends; class TCollectionProxyFactory;  . Additional Inherited Members;  Static Public Attributes inherited from TVirtualCollectionProxy; st,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:11405,access,accessors,11405,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['access'],['accessors']
Security,"ment operator. void SetCoordinates(const ROOT::Math::CylindricalEta3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fRho=src[0]; fEta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fRho; dest[1] = fEta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar rho, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers. { fRho=rho; fEta=eta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& rho, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& phi) const. get internal data into 3 Scalar numbers. {rho=fRho; eta=fEta; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). T Rho() const; accessors. { return fRho; }. T Eta() const; { return fEta; }. T Phi() const; { return fPhi; }. T X() const; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(Double32_t eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). set all values using cartesian coordinates. void Scale(Double32_t a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::Cylindri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__CylindricalEta3D_Double32_t_.html:4921,access,accessors,4921,root/html526/ROOT__Math__CylindricalEta3D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__CylindricalEta3D_Double32_t_.html,5,['access'],['accessors']
Security,"mental::RNTupleModel::RNTupleModelRNTupleModel(const RNTupleModel &)=delete; ROOT::Experimental::RNTupleModel::fSchemaIdstd::uint64_t fSchemaIdModels have a separate schema ID to remember that the clone of a frozen model still has the same sche...Definition RNTupleModel.hxx:213; ROOT::Experimental::RNTupleModel::GetTokenREntry::RFieldToken GetToken(std::string_view fieldName) constCreates a token to be used in REntry methods to address a field present in the entry.Definition RNTupleModel.cxx:470; ROOT::Experimental::RNTupleModel::EnsureNotBarevoid EnsureNotBare() constThrows an RException if fDefaultEntry is nullptr.Definition RNTupleModel.cxx:226; ROOT::Experimental::RNTupleModel::Clonestd::unique_ptr< RNTupleModel > Clone() constDefinition RNTupleModel.cxx:262; ROOT::Experimental::RNTupleModel::EnsureNotFrozenvoid EnsureNotFrozen() constThrows an RException if fFrozen is true.Definition RNTupleModel.cxx:220; ROOT::Experimental::RNTupleModel::GetMutableFieldZeroRFieldZero & GetMutableFieldZero()Mutable access to the root field is used to make adjustments to the fields.Definition RNTupleModel.cxx:399; ROOT::Experimental::RNTupleModel::GetDefaultEntryREntry & GetDefaultEntry()Definition RNTupleModel.cxx:426; ROOT::Experimental::RNTupleModel::EstimateWriteMemoryUsagestd::size_t EstimateWriteMemoryUsage(const RNTupleWriteOptions &options=RNTupleWriteOptions()) constEstimate the memory usage for this model during writing.Definition RNTupleModel.cxx:518; ROOT::Experimental::RNTupleModel::MakeFieldstd::shared_ptr< T > MakeField(const NameWithDescription_t &fieldNameDesc, ArgsT &&...args)Creates a new field given a name or {name, description} pair and a corresponding value that is manage...Definition RNTupleModel.hxx:295; ROOT::Experimental::RNTupleModel::GetRegisteredSubfieldsconst std::unordered_set< std::string > & GetRegisteredSubfields() constGet the (qualified) names of subfields that have been registered to be included in entries from this ...Definition RNTupleModel.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleModel_8hxx_source.html:28115,access,access,28115,doc/master/RNTupleModel_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleModel_8hxx_source.html,1,['access'],['access']
Security,"menting an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierachy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are ru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:99797,access,access,99797,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['access'],['access']
Security,"mepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TS3WebFile. class TS3WebFile: public TWebFile. TS3WebFile. A TS3WebFile is a TWebFile which retrieves the file contents from a; web server implementing the REST API of the Amazon S3 protocol. This; class is meant to be as generic as possible to be used with files; hosted not only by Amazon S3 servers but also by other providers; implementing the core of the S3 protocol. The S3 protocol works on top of HTTPS (and HTTP) and imposes that; each HTTP request be signed using a specific convention: the request; must include an 'Authorization' header which contains the signature; of a concatenation of selected request fields. For signing the; request, an 'Access Key Id' and a 'Secret Access Key' need to be; known. These keys are used by the S3 servers to identify the client; and to authenticate the request as genuine. As an end user, you must know the Access Key and Secret Access Key; in order to access each S3 file. They are provided to you by your S3; service provider. Those two keys can be provided to ROOT when; initializing an object of this class by two means:; a) by using the environmental variables S3_ACCESS_KEY and; S3_SECRET_KEY, or; b) by specifying them when opening each file. The first method is convenient if all the S3 files you want to; access are hosted by a single provider. The second one is more; flexible as it allows you to specify which credentials to use; on a per-file basis. See the documentation of the constructor of; this class for details on the syntax. For generating and signing the HTTP request, this class uses; TS3HTTPRequest. For more information on the details of S3 protocol please refer to:; ""Amazon Simple Storage Service Developer Guide"":; http://docs.amazonwebservices.com/AmazonS3/latest/dev/Welcome.html. ""Amazon S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:1052,authenticat,authenticate,1052,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,2,['authenticat'],['authenticate']
Security,"mer. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:44886,checksum,checksum,44886,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,2,['checksum'],['checksum']
Security,"merElement.h:122; TStreamerElement::IsATClass * IsA() const overrideDefinition TStreamerElement.h:146; TStreamerElement::GetOffsetInt_t GetOffset() constDefinition TStreamerElement.h:119; TStreamerElement::IsBasevirtual Bool_t IsBase() constReturn kTRUE if the element represent a base class.Definition TStreamerElement.cxx:429; TStreamerSTLDefinition TStreamerElement.h:391; TStreamerSTL::Classstatic TClass * Class(); TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::Classstatic TClass * Class(); TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:364988,hash,hash,364988,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['hash'],['hash']
Security,"merInfo *TClass::FindStreamerInfo(UInt_t checksum, Bool_t isTransient) const; 7037{; 7038 TVirtualStreamerInfo *guess = fLastReadInfo;; 7039 if (guess && guess->GetCheckSum() == checksum) {; 7040 return guess;; 7041 } else {; 7042 if (fCheckSum == checksum); 7043 return GetStreamerInfo(0, isTransient);; 7044 ; 7045 R__LOCKGUARD(gInterpreterMutex);; 7046 ; 7047 Int_t ninfos = fStreamerInfo->GetEntriesFast()-1;; 7048 for (Int_t i=-1;i<ninfos;++i) {; 7049 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7050 // so we have to use At and should not use UncheckedAt; 7051 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->UncheckedAt(i);; 7052 if (info && info->GetCheckSum() == checksum) {; 7053 // R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7054 info->BuildOld();; 7055 if (info->IsCompiled()) fLastReadInfo = info;; 7056 return info;; 7057 }; 7058 }; 7059 return nullptr;; 7060 }; 7061}; 7062 ; 7063////////////////////////////////////////////////////////////////////////////////; 7064/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7065 ; 7066TVirtualStreamerInfo *TClass::FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; 7067{; 7068 R__LOCKGUARD(gInterpreterMutex);; 7069 Int_t ninfos = arr->GetEntriesFast()-1;; 7070 for (Int_t i=-1;i<ninfos;i++) {; 7071 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7072 // so we have to use At and should not use UncheckedAt; 7073 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)arr->UncheckedAt(i);; 7074 if (!info) continue;; 7075 if (info->GetCheckSum() == checksum) {; 7076 R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7077 return info;; 7078 }; 7079 }; 7080 return nullptr;; 7081}; 7082 ; 7083////////////////////////////////////////////////////////////////////////////////; 7084/// Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:270841,checksum,checksum,270841,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,3,['checksum'],['checksum']
Security,"merInfo *TClass::FindStreamerInfo(UInt_t checksum, Bool_t isTransient) const; 7104{; 7105 TVirtualStreamerInfo *guess = fLastReadInfo;; 7106 if (guess && guess->GetCheckSum() == checksum) {; 7107 return guess;; 7108 } else {; 7109 if (fCheckSum == checksum); 7110 return GetStreamerInfo(0, isTransient);; 7111 ; 7112 R__LOCKGUARD(gInterpreterMutex);; 7113 ; 7114 Int_t ninfos = fStreamerInfo->GetEntriesFast()-1;; 7115 for (Int_t i=-1;i<ninfos;++i) {; 7116 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7117 // so we have to use At and should not use UncheckedAt; 7118 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->UncheckedAt(i);; 7119 if (info && info->GetCheckSum() == checksum) {; 7120 // R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7121 info->BuildOld();; 7122 if (info->IsCompiled()) fLastReadInfo = info;; 7123 return info;; 7124 }; 7125 }; 7126 return nullptr;; 7127 }; 7128}; 7129 ; 7130////////////////////////////////////////////////////////////////////////////////; 7131/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7132 ; 7133TVirtualStreamerInfo *TClass::FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; 7134{; 7135 R__LOCKGUARD(gInterpreterMutex);; 7136 Int_t ninfos = arr->GetEntriesFast()-1;; 7137 for (Int_t i=-1;i<ninfos;i++) {; 7138 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7139 // so we have to use At and should not use UncheckedAt; 7140 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)arr->UncheckedAt(i);; 7141 if (!info) continue;; 7142 if (info->GetCheckSum() == checksum) {; 7143 R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7144 return info;; 7145 }; 7146 }; 7147 return nullptr;; 7148}; 7149 ; 7150////////////////////////////////////////////////////////////////////////////////; 7151/// Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:273592,checksum,checksum,273592,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,3,['checksum'],['checksum']
Security,"merInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TWebFile(const char* url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. The url; argument must be of the form: http://host.dom.ain/file.root.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. The preferred interface to this; constructor is via TFile::Open(). TWebFile(TUrl url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. Make sure url; is a valid TUrl object.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. ~TWebFile(); Cleanup. void Init(Bool_t readHeadOnly); Initialize a TWebFile object. void SetMsgReadBuffer1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TWebFile.html:24449,access,accessible,24449,root/html532/TWebFile.html,https://root.cern,https://root.cern/root/html532/TWebFile.html,2,['access'],['accessible']
Security,"merNVirtual_b);  ; Bool_t UnregisterObject (TObject *obj);  Unregister (remove) object from folders structures. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSniffer.html:5670,hash,hash,5670,doc/master/classTRootSniffer.html,https://root.cern,https://root.cern/doc/master/classTRootSniffer.html,1,['hash'],['hash']
Security,"mes of the data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.7.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one could produce images with requests: root.png, root.gif, root.jpeg. For example:; wget ""http://localhost:8080/Files/hsimple.root/hpx/root.png?w=500&h=500&opt=lego1"" -O lego1.png; For all such requests one could specify following parameters:. h - image height; w - image width; opt - draw options. 1.7.3 Methods execution; By default THttpServer starts in monitoring (read-only) mode and therefore forbid any methods execution. One could specify read-write mode when server is started:; serv = new THttpServer(""http:8080;rw"");; Or one could disable read-only mode with the call:; serv->SetReadOnly(kFALSE);; Or one could allow access to the folder, object or specific object methods with:; serv->Restrict(""/Histograms"", ""allow=admin""); // allow full access for user with 'admin' accout ; serv->Restrict(""/Histograms/hist1"", ""allow=all""); // allow full access for all users ; serv->Restrict(""/Histograms/hist1"", ""allow_method=Rebin""); // allow only Rebin method ; ‘exe.json’ accepts following parameters: - method - name of method to execute - prototype - method prototype (see TClass::GetMethodWithPrototype for details) - compact - compact parameter, used to compress return value - _ret_object_ - name of the object which should be returned as result of method execution (used together with remote TTree::Draw call); Example of retrieving object title:; [shell] wget 'http://localhost:8080/Objects/subfolder/obj/exe.json?method=GetTitle' -O title.json; Example of TTree::Draw method execution:; [shell] wget 'http://localhost:8080/Files/job1.root/ntuple/exe.json?method=Draw&prototype=""Option_t*""&opt=""px:py>>h1""&_ret_object_=h1' -O exe.json; One also used exe.bin method - in this case results o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:12954,access,access,12954,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,3,['access'],['access']
Security,"mes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; 221image below shows the ROOT color wheel in grayscale mode.; 222 ; 223Begin_Macro(source); 224{; 225 auto w = new TColorWheel();; 226 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 227 cw->GetCanvas()->SetGrayscale();; 228 w->SetCanvas(cw);; 229 w->Draw();; 230}; 231End_Macro; 232 ; 233\anchor C05; 234## Color palettes; 235It is often very useful to represent a variable with a color map. The concept; 236of ""color palette"" allows to do that. One color palette is active at any time.; 237This ""current palette"" is set using:; 238 ; 239~~~ {.cpp}; 240gStyle->SetPalette(...);; 241~~~; 242 ; 243This function has two parameters: the number of colors in the palette and an; 244array of containing the indices of colors in the palette. The following small; 245example demonstrates how to define and use the color palette:; 246 ; 247Begin_Macro(source); 248{; 249 auto c1 = new TCanvas(""c1"",""c1""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:7985,access,access,7985,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,2,['access'],['access']
Security,"mespaces in the ROOT type system.Definition TClass.h:81; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDataMember::GetDataTypeTDataType * GetDataType() constDefinition TDataMember.h:76; TDataType::SizeInt_t Size() constGet size of basic typedef'ed type.Definition TDataType.cxx:375; TExMap::Expandvoid Expand(Int_t newsize)Expand the TExMap.Definition TExMap.cxx:279; TExMap::GetSizeInt_t GetSize() constDefinition TExMap.h:71; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::CapacityInt_t Capacity() constDefinition TExMap.h:69; TExMap::Deletevoid Delete(Option_t *opt="""") overrideDelete all entries stored in the TExMap.Definition TExMap.cxx:164; THnBaseMultidimensional histogram base.Definition THnBase.h:43; THnBase::fEntriesDouble_t fEntriesNumber of entries, spread over chunks.Definition THnBase.h:48; THnBase::GetNdimensionsInt_t GetNdimensions() constDefinition THnBase.h:140; THnBase::ResetBasevoid ResetBase(Option_t *option="""")Clear the histogram.Definition THnBase.cxx:1327; THnBase::GetCalculateErrorsBool_t GetCalculateErrors() constDefinition THnBase.h:141; THnBase::fTsumw2Double_t fTsumw2Total sum of weights squared; -1 if no errors are calculated.Definition THnBase.h:50; THnBase::GetAxisTAxi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:39970,hash,hash,39970,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['hash'],['hash']
Security,"meter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPaveStats.html:2913,access,accessed,2913,root/html534/TPaveStats.html,https://root.cern,https://root.cern/root/html534/TPaveStats.html,3,['access'],['accessed']
Security,"meters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:42099,access,access,42099,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['access'],['access']
Security,"method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetValue(Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key, UInt_t& slot); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::opera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TExMap.html:2583,hash,hash,2583,root/html528/TExMap.html,https://root.cern,https://root.cern/root/html528/TExMap.html,1,['hash'],['hash']
Security,"method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetValue(Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key, UInt_t& slot); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator dele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TExMap.html:2583,hash,hash,2583,root/html530/TExMap.html,https://root.cern,https://root.cern/root/html530/TExMap.html,3,['hash'],['hash']
Security,"method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetValue(Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key, UInt_t& slot); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TExMap.html:2527,hash,hash,2527,root/html602/TExMap.html,https://root.cern,https://root.cern/root/html602/TExMap.html,2,['hash'],['hash']
Security,"metry MDI Geometry; TGMdiHorizontalWinResizer Horizontal Window Resizer; TGMdiMainFrame MDI main frame; TGMdiMenuBar MDI menu bar; TGMdiTitleBar MDI Title Bar; TGMdiTitleIcon MDI Title Icon; TGMdiVerticalWinResizer Vertical Window Resizer; TGMdiWinResizer Window Resizer; TGMenuBar Menu bar class; TGMenuEntry Menu entry class; TGMenuTitle Menu title class; TGMimeTypes Pool of mime type objects; TGMsgBox A message dialog box; TGNumberEntry Entry field widget for several numeric formats; TGNumberEntryField A text entry field used by a TGNumberEntry; TGNumberEntryLayout Layout manager for number entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGQt Interface to Qt GUI; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGSFile Read a ROOT file from the Google Storage cloud; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interfac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:84228,password,passwords,84228,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['password'],['passwords']
Security,"metry MDI Geometry; TGMdiHorizontalWinResizer Horizontal Window Resizer; TGMdiMainFrame MDI main frame; TGMdiMenuBar MDI menu bar; TGMdiTitleBar MDI Title Bar; TGMdiTitleIcon MDI Title Icon; TGMdiVerticalWinResizer Vertical Window Resizer; TGMdiWinResizer Window Resizer; TGMenuBar Menu bar class; TGMenuEntry Menu entry class; TGMenuTitle Menu title class; TGMimeTypes Pool of mime type objects; TGMsgBox A message dialog box; TGNumberEntry Entry field widget for several numeric formats; TGNumberEntryField A text entry field used by a TGNumberEntry; TGNumberEntryLayout Layout manager for number entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGQt Interface to Qt GUI; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider wid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:77163,password,passwords,77163,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,5,['password'],['passwords']
Security,"metry MDI Geometry; TGMdiHorizontalWinResizer Horizontal Window Resizer; TGMdiMainFrame MDI main frame; TGMdiMenuBar MDI menu bar; TGMdiTitleBar MDI Title Bar; TGMdiTitleIcon MDI Title Icon; TGMdiVerticalWinResizer Vertical Window Resizer; TGMdiWinResizer Window Resizer; TGMenuBar Menu bar class; TGMenuEntry Menu entry class; TGMenuTitle Menu title class; TGMimeTypes Pool of mime type objects; TGMsgBox A message dialog box; TGNumberEntry Entry field widget for several numeric formats; TGNumberEntryField A text entry field used by a TGNumberEntry; TGNumberEntryLayout Layout manager for number entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGQt Interface to Qt GUI; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider widget abstract base class; TGSpeedo Ba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:82113,password,passwords,82113,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['password'],['passwords']
Security,"mg_file file = STRUCT_FILE_INITIALIZER;; 11673 const char *range;; 11674 int64_t r1, r2;; 11675 int rc;; 11676 ; 11677 if (conn == NULL) {; 11678 return;; 11679 }; 11680 ; 11681 if (mg_stat(conn, path, &file.stat)) {; 11682 /* File already exists */; 11683 conn->status_code = 200;; 11684 ; 11685 if (file.stat.is_directory) {; 11686 /* This is an already existing directory,; 11687 * so there is nothing to do for the server. */; 11688 rc = 0;; 11689 ; 11690 } else {; 11691 /* File exists and is not a directory. */; 11692 /* Can it be replaced? */; 11693 ; 11694 /* Check if the server may write this file */; 11695 if (access(path, W_OK) == 0) {; 11696 /* Access granted */; 11697 rc = 1;; 11698 } else {; 11699 mg_send_http_error(; 11700 conn,; 11701 403,; 11702 ""Error: Put not possible\nReplacing %s is not allowed"",; 11703 path);; 11704 return;; 11705 }; 11706 }; 11707 } else {; 11708 /* File should be created */; 11709 conn->status_code = 201;; 11710 rc = put_dir(conn, path);; 11711 }; 11712 ; 11713 if (rc == 0) {; 11714 /* put_dir returns 0 if path is a directory */; 11715 ; 11716 /* Create response */; 11717 mg_response_header_start(conn, conn->status_code);; 11718 send_no_cache_header(conn);; 11719 send_additional_header(conn);; 11720 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11721 ; 11722 /* Send all headers - there is no body */; 11723 mg_response_header_send(conn);; 11724 ; 11725 /* Request to create a directory has been fulfilled successfully.; 11726 * No need to put a file. */; 11727 return;; 11728 }; 11729 ; 11730 if (rc == -1) {; 11731 /* put_dir returns -1 if the path is too long */; 11732 mg_send_http_error(conn,; 11733 414,; 11734 ""Error: Path too long\nput_dir(%s): %s"",; 11735 path,; 11736 strerror(ERRNO));; 11737 return;; 11738 }; 11739 ; 11740 if (rc == -2) {; 11741 /* put_dir returns -2 if the directory can not be created */; 11742 mg_send_http_error(conn,; 11743 500,; 11744 ""Error: Can not create directory\nput_dir(%s): %s"",; 11745 path",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:338369,access,access,338369,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"mg_file file = STRUCT_FILE_INITIALIZER;; 11674 const char *range;; 11675 int64_t r1, r2;; 11676 int rc;; 11677 ; 11678 if (conn == NULL) {; 11679 return;; 11680 }; 11681 ; 11682 if (mg_stat(conn, path, &file.stat)) {; 11683 /* File already exists */; 11684 conn->status_code = 200;; 11685 ; 11686 if (file.stat.is_directory) {; 11687 /* This is an already existing directory,; 11688 * so there is nothing to do for the server. */; 11689 rc = 0;; 11690 ; 11691 } else {; 11692 /* File exists and is not a directory. */; 11693 /* Can it be replaced? */; 11694 ; 11695 /* Check if the server may write this file */; 11696 if (access(path, W_OK) == 0) {; 11697 /* Access granted */; 11698 rc = 1;; 11699 } else {; 11700 mg_send_http_error(; 11701 conn,; 11702 403,; 11703 ""Error: Put not possible\nReplacing %s is not allowed"",; 11704 path);; 11705 return;; 11706 }; 11707 }; 11708 } else {; 11709 /* File should be created */; 11710 conn->status_code = 201;; 11711 rc = put_dir(conn, path);; 11712 }; 11713 ; 11714 if (rc == 0) {; 11715 /* put_dir returns 0 if path is a directory */; 11716 ; 11717 /* Create response */; 11718 mg_response_header_start(conn, conn->status_code);; 11719 send_no_cache_header(conn);; 11720 send_additional_header(conn);; 11721 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11722 ; 11723 /* Send all headers - there is no body */; 11724 mg_response_header_send(conn);; 11725 ; 11726 /* Request to create a directory has been fulfilled successfully.; 11727 * No need to put a file. */; 11728 return;; 11729 }; 11730 ; 11731 if (rc == -1) {; 11732 /* put_dir returns -1 if the path is too long */; 11733 mg_send_http_error(conn,; 11734 414,; 11735 ""Error: Path too long\nput_dir(%s): %s"",; 11736 path,; 11737 strerror(ERRNO));; 11738 return;; 11739 }; 11740 ; 11741 if (rc == -2) {; 11742 /* put_dir returns -2 if the directory can not be created */; 11743 mg_send_http_error(conn,; 11744 500,; 11745 ""Error: Can not create directory\nput_dir(%s): %s"",; 11746 path",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:338402,access,access,338402,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"min,zmax); The argument option (default=""QNR"") can be used to change the fit options.; ""Q"" means Quiet mode; ""N"" means do not show the result of the fit; ""R"" means fit the function in the specified function range. Note that the generated histograms are added to the list of objects; in the current directory. It is the user's responsability to delete; these histograms. Example: Assume a 3-d histogram h3; Root > h3->FitSlicesZ(); produces 4 TH2D histograms; with h3_0 containing parameter 0(Constant) for a Gaus fit; of each cell in X,Y projected along Z; with h3_1 containing parameter 1(Mean) for a gaus fit; with h3_2 containing parameter 2(StdDev) for a gaus fit; with h3_chi2 containing the chisquare/number of degrees of freedom for a gaus fit. Root > h3->Fit(0,15,22,0,0,10);; same as above, but only for bins 15 to 22 along X; and only for cells in X,Y for which the corresponding projection; along Z has more than cut bins filled. NOTE: To access the generated histograms in the current directory, do eg:; TH2D *h3_1 = (TH2D*)gDirectory->Get(""h3_1"");. Int_t GetBin(Int_t binx, Int_t biny, Int_t binz) const; See comments in TH1::GetBin. Double_t GetBinWithContent3(Double_t c, Int_t& binx, Int_t& biny, Int_t& binz, Int_t firstx = 0, Int_t lastx = 0, Int_t firsty = 0, Int_t lasty = 0, Int_t firstz = 0, Int_t lastz = 0, Double_t maxdiff = 0) const; Compute first cell (binx,biny,binz) in the range [firstx,lastx](firsty,lasty][firstz,lastz] for which; diff = abs(cell_content-c) <= maxdiff; In case several cells in the specified range with diff=0 are found; the first cell found is returned in binx,biny,binz.; In case several cells in the specified range satisfy diff <=maxdiff; the cell with the smallest difference is returned in binx,biny,binz.; In all cases the function returns the smallest difference. NOTE1: if firstx <= 0, firstx is set to bin 1; if (lastx < firstx then firstx is set to the number of bins in X; ie if firstx=0 and lastx=0 (default) the search is on all bins in X",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH3.html:36591,access,access,36591,root/html604/TH3.html,https://root.cern,https://root.cern/root/html604/TH3.html,1,['access'],['access']
Security,"mit(double low); voidSetUpperLimit(double up); voidSetValue(double val); doubleUpperLimit() const; doubleValue() const. Data Members; private:. boolfConst; doublefError; boolfFix; boolfLoLimValid; doublefLoLimit; stringfName; unsigned intfNum; boolfUpLimValid; doublefUpLimit; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitParameter(); default constructor standard with value/error = 0. {}. MinuitParameter(unsigned int num, const string& name, double val); constructor for constant Parameter. {}. MinuitParameter(unsigned int num, const string& name, double val, double err); constructor for standard Parameter. {}. MinuitParameter(unsigned int num, const string& name, double val, double err, double min, double max); constructor for limited Parameter. ~MinuitParameter(); {}. MinuitParameter(const ROOT::Minuit2::MinuitParameter& par); {}. MinuitParameter& operator=(const ROOT::Minuit2::MinuitParameter& par). unsigned int Number() const; access methods. {return fNum;}. const std::string & GetName() const; new API returning a string. { return fName; }. const char * Name() const; return const char * for mantaining backward compatibility. {return fName.c_str();}. double Value() const; {return fValue;}. double Error() const; {return fError;}. void SetValue(double val); interaction. {fValue = val;}. void SetError(double err); {fError = err;}. void SetLimits(double low, double up). void SetUpperLimit(double up). void SetLowerLimit(double low). void RemoveLimits(). void Fix(); {fFix = true;}. void Release(); {fFix = false;}. bool IsConst() const; state of Parameter (fixed/const/limited). {return fConst;}. bool IsFixed() const; {return fFix;}. bool HasLimits() const; {return fLoLimValid || fUpLimValid; }. bool HasLowerLimit() const; {return fLoLimValid; }. bool HasUpperLimit() const; {return fUpLimValid; }. double LowerLimit() const; {return fLoLimit;}. double UpperLimit() const; {return fUpLimit;}. » Last changed: root",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Minuit2__MinuitParameter.html:2792,access,access,2792,root/html530/ROOT__Minuit2__MinuitParameter.html,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MinuitParameter.html,2,['access'],['access']
Security,"mize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:174635,access,access,174635,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['access']
Security,"mize()!; 4664///; 4665 ; 4666TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4667{; 4668 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4669 ; 4670 // Version 0 is special, it means the currently loaded version.; 4671 // We need to set it at the beginning to be able to guess it correctly.; 4672 ; 4673 if (version == 0); 4674 version = fClassVersion;; 4675 ; 4676 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4677 // guaranteed it was built and compiled.; 4678 if (sinfo && sinfo->GetClassVersion() == version); 4679 return sinfo;; 4680 ; 4681 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4682 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4683 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4684 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4685 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4686 // to indicates they are not yet properly protection against mutli-thread access.; 4687 //; 4688 // However, the use of these functions is rare and mostly done at library loading time which should; 4689 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4690 // on that same TClass object.; 4691 //; 4692 // Summary: need careful review but risk of problem is extremely low.; 4693 ; 4694 R__LOCKGUARD(gInterpreterMutex);; 4695 ; 4696 return GetStreamerInfoImpl(version, isTransient);; 4697};; 4698 ; 4699// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4700// This routine assumes the global lock has been taken.; 4701TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4702{; 4703 // Warning: version may be -1 for an emulated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:177386,access,access,177386,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['access']
Security,"mmon one such as int, double, char or float it is nonetheless good practice to specify it as a template parameter to the action itself, like this: df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing x = 0 rather than x == 0:; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");. User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; Implementing custom actions with Book(); Through the Book() method, users can implement a custom action and have access to the same features that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; #include <ROOT/RDataFrame.hxx>; #include <memory>; ; class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;; ; public:; // We use a public type alias to advertise the type of the result of this action; using Result_t = int;; ; MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}; ; // Called before the event loop to retrieve the address of the result that will be filled/generated.; std::shared_ptr<int> GetResultPtr() const { return fFinalResult; }; ; // Called at the beginn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:65062,inject,inject,65062,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['inject'],['inject']
Security,mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrupted; TList*TDirectory::fListList of objects in memory; TSeqCollection*fMappedFilesList of memory mapped files; TSeqCollection*fMessageHandlersList of message handlers; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustCleanTrue if object destructor scans canvases; TStringTNamed::fNameobject identifier; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TPluginManager*fPluginManagerKeeps track of plugin library handlers; const TObject*fPrimitiveCurrently selected primitive; TSeqCollection*fProofsList of proof sessions; Bool_tfReadingObjectTrue while reading an object [Deprecated (will be removed in next release); TFolder*fRootFoldertop level folder //root; TSeqCollection*fSecContextsList of security contexts (TSecContext); TVirtualPad*fSelectPadCurrently selected pad; TSeqCollection*fSocketsList of network sockets; TSeqCollection*fSpecialsList of special objects; TSeqCollection*fStreamerInfoList of active StreamerInfo classes; TSeqCollection*fStylesList of styles; TStringfSvnBranchSubversion branch; TStringfSvnDateDate and time when make was run; Int_tfSvnRevisionSubversion revision number of built; TSeqCollection*fTasksList of tasks; Int_tfTimerTimer flag; TStringTNamed::fTitleobject title; TCollection*fTypesList of data types definition; TUUIDTDirectory::fUUIDUnique identifier; TProcessUUID*fUUIDsPointer to TProcessID managing TUUIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:18299,secur,security,18299,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,3,['secur'],['security']
Security,"modified = kTRUE;; 3153 ; 3154 } else {; 3155 ; 3156 if ( gSystem->GetPathInfo( depfilename, nullptr,(Long_t*) nullptr, nullptr, &file_time ) != 0 ) {; 3157 if (!canWrite) {; 3158 depdir = emergency_loc;; 3159 AssignAndDelete( depfilename, ConcatFileName(depdir, BaseName(libname_noext)) );; 3160 depfilename += ""_"" + extension + "".d"";; 3161 }; 3162 R__WriteDependencyFile(build_loc, depfilename, filename_fullpath, library, libname, extension, version_var_prefix, includes, defines, incPath);; 3163 }; 3164 }; 3165 ; 3166 if (!modified) {; 3167 ; 3168 // We need to check the dependencies; 3169 FILE * depfile = fopen(depfilename.Data(),""r"");; 3170 if (depfile==nullptr) {; 3171 // there is no accessible dependency file, let's assume the library has been; 3172 // modified; 3173 modified = kTRUE;; 3174 recompile = kTRUE;; 3175 ; 3176 } else {; 3177 ; 3178 TString version_var = libname + version_var_prefix;; 3179 ; 3180 Int_t sz = 256;; 3181 char *line = new char[sz];; 3182 line[0] = 0;; 3183 ; 3184 int c;; 3185 Int_t current = 0;; 3186 Int_t nested = 0;; 3187 Bool_t hasversion = false;; 3188 ; 3189 while ((c = fgetc(depfile)) != EOF) {; 3190 if (c=='#') {; 3191 // skip comment; 3192 while ((c = fgetc(depfile)) != EOF) {; 3193 if (c=='\n') {; 3194 break;; 3195 }; 3196 }; 3197 continue;; 3198 }; 3199 if (current && line[current-1]=='=' && strncmp(version_var.Data(),line,current)==0) {; 3200 ; 3201 // The next word will be the version number.; 3202 hasversion = kTRUE;; 3203 line[0] = 0;; 3204 current = 0;; 3205 } else if (isspace(c) && !nested) {; 3206 if (current) {; 3207 if (line[current-1]!=':') {; 3208 // ignore target; 3209 line[current] = 0;; 3210 ; 3211 Long_t filetime;; 3212 if (hasversion) {; 3213 modified |= strcmp(ROOT_RELEASE,line)!=0;; 3214 hasversion = kFALSE;; 3215 } else if ( gSystem->GetPathInfo( line, nullptr, (Long_t*)nullptr, nullptr, &filetime ) == 0 ) {; 3216 modified |= ( lib_time <= filetime );; 3217 }; 3218 }; 3219 }; 3220 current = 0;; 3221 line[0] = 0;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:106534,access,accessible,106534,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['access'],['accessible']
Security,"modtime)Return file stat information.Definition TFile.cxx:4543; TFile::GetBytesReadExtravirtual Long64_t GetBytesReadExtra() constDefinition TFile.h:242; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::kDisconnect@ kDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::GetArchiveTArchiveFile * GetArchive() constDefinition TFile.h:220; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::DirWriteKeysvirtual void DirWriteKeys(TDirectory *)Definition TFile.h:169; TFile::fFreeTList * fFreeFree segments linked list table.Definition TFile.h:93; TFile::ReadBufferAsyncvirtual Bool_t ReadBufferAsync(Long64_t offs, Int_t len)Definition TFile.cxx:5208; TFile::fWriteMutexstd::mutex fWriteMutex!Lock for writing baskets / keys into the file.Definition TFile.h:118; TFile::Deletevoid Del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:43030,hash,hashes,43030,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['hash'],['hashes']
Security,"mote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TApplication. ←; TRint. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the Process",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRint.html:13649,access,access,13649,root/html602/TRint.html,https://root.cern,https://root.cern/root/html602/TRint.html,1,['access'],['access']
Security,"mous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. _xmlParserCtxt*fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfParseCodeto keep track of the errorcodes; Bool_tfReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfStopErrorstop when parse error occurs; Bool_tfValidateto validate the parse context; TStringfValidateErrorparse error; TStringfValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TXMLParser. ←. TDOMParser. TSAXParser. Function documentation; TXMLParser(); Initializes parser variables. ~TXMLParser(); Cleanup. void SetValidate(Bool_t val = kTRUE); The parser will validate the xml file if val = true. void SetReplaceEntities(Bool_t val = kTRUE); The parser will replace/expand entities. void ReleaseUnderlying(); To release any existing document. void OnValidateError(const TString& message); This function is called when an error from the parser has occured.; Message is the parse error. void OnValidateWarning(const TString& message); This function is called when a warning from the parser has occured.; Message is the parse error. const char * GetParseCodeMessage(Int_t parseCode) const; Returns the parse code message. void InitializeContext(); Initialize parser parameters, such as, disactivate non-standards libxml1; features, on/off validation, clear error and warning messages. void StopParser(); Stops parsing. void SetParseCode(Int_t code); Set the parse code:; 0: Parse successful; -1: Attempt to parse a second file while a parse is in progress; -2: Parse context is not created; -3: An error occured while parsing file; -4: A fatal error occu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLParser.html:10922,validat,validate,10922,root/html602/TXMLParser.html,https://root.cern,https://root.cern/root/html602/TXMLParser.html,2,['validat'],['validate']
Security,"move object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TListOfEnums;  TListOfEnums (TClass *cl=nullptr);  Constructor. ;  ;  ~TListOfEnums () override;  Destructor. ;  ; TEnum * Find (DeclId_t id) const;  Return the TEnum corresponding to the Decl 'id' or NULL if it does not exist. ;  ; Bool_t IsLoaded () const;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnumsWithLock.html:4529,hash,hashlist,4529,doc/master/classTListOfEnumsWithLock.html,https://root.cern,https://root.cern/doc/master/classTListOfEnumsWithLock.html,1,['hash'],['hashlist']
Security,"mpl< T, true >;  CTBranchProxyBase class for all the proxy object ;  ►CTCollectionProxyInfo;  CAddress;  CEnvironSmall helper to save proxy environment in the event of recursive calls ;  CEnvironBase;  CInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CIteratorsSmall helper to implement the function to create,access and destroy iterators ;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValueSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< bool > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t > >;  CIterators;  CTFutureImpl;  CTRangeStaticCastTRangeStaticCast is an adaptater class that allows the typed iteration through a TCollection ;  ►CTSchemaRuleSet;  CTMatches;  ►CTStatusBitsChecker;  CRegistry;  CTTypedIterTTypedIter is a typed version of TIter ;  ►NExecutorUtilsThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental;  ►NDetail;  CTArgsMenuItem;  CTCheckedMenuItem;  CTHistBinIterIterates over the bins of a THist or THistImpl ;  CTHistBinPtrPoints to a histogram bin (or actually a THistBinRef) ;  CTHistBinRefRepresents a bin reference ;  CTHistBinStatConst view on a bin's statistical data ;  CTHistDataA THistImp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:12092,access,accesses,12092,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['access'],['accesses']
Security,"mple of a Graph with Error Bars"");; bar->AddButton(""tornado"", "".x graphics/tornado.C"", ""Examples of 3-D PolyMarkers"");; bar->AddButton(""geometry"", "".x geom/rootgeom.C"", ""Example of TGeoManager drawing"");; bar->AddButton(""file"", "".x io/file.C"", ""The ROOT File Format"");; bar->AddButton(""fildir"", "".x io/fildir.C"", ""The ROOT File, Directories and Keys"");; bar->AddButton(""tree"", "".x tree/tree.C"", ""The Tree Data Structure"");; bar->AddButton(""ntuple1"", "".x tree/ntuple1.C"", ""Ntuples and Selections"");; bar->AddButton(""benchmarks"", "".x legacy/benchmarks.C"", ""Runs several tests and produces an benchmark report"");; bar->AddButton(""rootmarks"", "".x legacy/rootmarks.C"", ""Prints an Estimated ROOTMARKS for Your Machine"");; bar->SetButtonWidth(90);; bar->Show();; gROOT->SaveContext();; }; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::SetButtonWidthvoid SetButtonWidth(UInt_t width)Sets the width in pixels for control bar button.Definition TControlBar.cxx:277; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; AuthorRene Brun ; Definition in file demos.C. tutorialsdemos.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxyg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/demos_8C.html:2933,access,access,2933,doc/master/demos_8C.html,https://root.cern,https://root.cern/doc/master/demos_8C.html,1,['access'],['access']
Security,"mplemented from TObject.; Definition at line 35 of file TObjString.cxx. ◆ CopyString(). TString TObjString::CopyString ; (; ); const. inline . Definition at line 37 of file TObjString.h. ◆ DeclFileName(). static const char * TObjString::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 50 of file TObjString.h. ◆ FillBuffer(). void TObjString::FillBuffer ; (; char *& ; buffer). inline . Definition at line 40 of file TObjString.h. ◆ GetName(). const char * TObjString::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 38 of file TObjString.h. ◆ GetString(). const TString & TObjString::GetString ; (; ); const. inline . Definition at line 46 of file TObjString.h. ◆ Hash(). ULong_t TObjString::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjString::HashULong_t Hash() const overrideReturn hash value for this object.Definition TObjString.h:39; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjString.html:12187,hash,hash,12187,doc/master/classTObjString.html,https://root.cern,https://root.cern/doc/master/classTObjString.html,1,['hash'],['hash']
Security,"ms are represented with a one dimensional; 4937/// structure.; 4938/// This has the advantage that all existing functions, such as; 4939/// GetBinContent, GetBinError, GetBinFunction work for all dimensions.; 4940///; 4941/// In case of a TH1x, returns binx directly.; 4942/// see TH1::GetBinXYZ for the inverse transformation.; 4943///; 4944/// Convention for numbering bins; 4945///; 4946/// For all histogram types: nbins, xlow, xup; 4947///; 4948/// - bin = 0; underflow bin; 4949/// - bin = 1; first bin with low-edge xlow INCLUDED; 4950/// - bin = nbins; last bin with upper-edge xup EXCLUDED; 4951/// - bin = nbins+1; overflow bin; 4952///; 4953/// In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 4954/// For example, assuming a 3-D histogram with binx,biny,binz, the function; 4955///; 4956/// ~~~ {.cpp}; 4957/// Int_t bin = h->GetBin(binx,biny,binz);; 4958/// ~~~; 4959///; 4960/// returns a global/linearized bin number. This global bin is useful; 4961/// to access the bin information independently of the dimension.; 4962 ; 4963Int_t TH1::GetBin(Int_t binx, Int_t, Int_t) const; 4964{; 4965 Int_t ofx = fXaxis.GetNbins() + 1; // overflow bin; 4966 if (binx < 0) binx = 0;; 4967 if (binx > ofx) binx = ofx;; 4968 ; 4969 return binx;; 4970}; 4971 ; 4972////////////////////////////////////////////////////////////////////////////////; 4973/// Return binx, biny, binz corresponding to the global bin number globalbin; 4974/// see TH1::GetBin function above; 4975 ; 4976void TH1::GetBinXYZ(Int_t binglobal, Int_t &binx, Int_t &biny, Int_t &binz) const; 4977{; 4978 Int_t nx = fXaxis.GetNbins()+2;; 4979 Int_t ny = fYaxis.GetNbins()+2;; 4980 ; 4981 if (GetDimension() == 1) {; 4982 binx = binglobal%nx;; 4983 biny = 0;; 4984 binz = 0;; 4985 return;; 4986 }; 4987 if (GetDimension() == 2) {; 4988 binx = binglobal%nx;; 4989 biny = ((binglobal-binx)/nx)%ny;; 4990 binz = 0;; 4991 return;; 4992 }; 4993 if (GetDimension() == 3) {; 4994 binx = binglobal%nx;; 4995 biny = ((bin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:201209,access,access,201209,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['access'],['access']
Security,"msg.Form("" The StreamerInfo of the base class %s (of class %s) read from %s%s\n""; 2967 "" refers to a checksum (%x) that can not be found neither in memory nor in the file.\n"",; 2968 otherBaseClass->GetName(), localClass.Data(),; 2969 file ? ""file "" : """", file ? file->GetName() : """",; 2970 localBase->GetBaseCheckSum(); 2971 );; 2972 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2973 otherBase->SetErrorMessage(msg);; 2974 continue;; 2975 }; 2976 if (localBaseInfo->CompareContent(otherBaseClass,0,kFALSE,kFALSE,file) ) {; 2977 // They are equivalent, no problem.; 2978 continue;; 2979 }; 2980 TString msg;; 2981 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 2982 "" has the same version (=%d) as the active class but a different checksum.\n""; 2983 "" You should update the version to ClassDef(%s,%d).\n""; 2984 "" The objects on this file might not be readable because:\n""; 2985 "" The in-memory layout version %d for class '%s' has a base class (%s) with checksum %x but the on-file layout version %d recorded the checksum value %x for this base class (%s)."",; 2986 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 2987 GetClassVersion(), GetName(), otherClass.Data(), otherBaseClass->GetCheckSum(),; 2988 GetClassVersion(), localBase->GetBaseCheckSum(), localClass.Data());; 2989 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2990 otherBase->SetErrorMessage(msg);; 2991 }; 2992 } else {; 2993 TStreamerBase *localBase = dynamic_cast<TStreamerBase*>(el);; 2994 TStreamerBase *otherBase = dynamic_cast<TStreamerBase*>(infoel);; 2995 if (!localBase || !otherBase) continue;; 2996 ; 2997 // We already have localBaseClass == otherBaseClass; 2998 TClass *otherBaseClass = localBase->GetClassPointer();; 2999 if (otherBaseClass->IsVersioned() && localBase->GetBaseVersion() != otherBase->GetBaseVersion()) {; 3000 TSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:119239,checksum,checksum,119239,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,2,['checksum'],['checksum']
Security,"much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:3283,access,access,3283,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,1,['access'],['access']
Security,"much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by speci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFractionFitter.html:3283,access,access,3283,root/html530/TFractionFitter.html,https://root.cern,https://root.cern/root/html530/TFractionFitter.html,5,['access'],['access']
Security,"n () const;  Get the field's description. ;  ; const std::string & GetFieldName () const;  ; virtual std::uint32_t GetFieldVersion () const;  Indicates an evolution of the mapping scheme from C++ type to columns. ;  ; std::size_t GetNRepetitions () const;  ; DescriptorId_t GetOnDiskId () const;  ; std::uint32_t GetOnDiskTypeChecksum () const;  Return checksum stored in the field descriptor; only valid after a call to ConnectPageSource(), if the field stored a type checksum. ;  ; std::uint32_t GetOnDiskTypeVersion () const;  Return the C++ type version stored in the field descriptor; only valid after a call to ConnectPageSource() ;  ; const RFieldBase * GetParent () const;  ; std::string GetQualifiedFieldName () const;  Returns the field name and parent field names separated by dots (""grandparent.parent.child"") ;  ; EState GetState () const;  ; ENTupleStructure GetStructure () const;  ; std::vector< RFieldBase * > GetSubFields ();  ; std::vector< const RFieldBase * > GetSubFields () const;  ; int GetTraits () const;  ; const std::string & GetTypeAlias () const;  ; virtual std::uint32_t GetTypeChecksum () const;  Return the current TClass reported checksum of this class. Only valid if kTraitTypeChecksum is set. ;  ; const std::string & GetTypeName () const;  ; virtual std::uint32_t GetTypeVersion () const;  Indicates an evolution of the C++ type itself. ;  ; virtual size_t GetValueSize () const =0;  The number of bytes taken by a value of the appropriate type. ;  ; bool HasDefaultColumnRepresentative () const;  Whether or not an explicit column representative was set. ;  ; bool HasReadCallbacks () const;  ; bool IsSimple () const;  ; RFieldBase & operator= (const RFieldBase &)=delete;  ; RFieldBase & operator= (RFieldBase &&)=default;  ; void SetColumnRepresentatives (const RColumnRepresentations::Selection_t &representatives);  Fixes a column representative. ;  ; void SetDescription (std::string_view description);  ; void SetOnDiskId (DescriptorId_t id);  ; virtual st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:5732,checksum,checksum,5732,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['checksum'],['checksum']
Security,"n * fStdExceptionHandler {nullptr};  ; TList * fTimers {nullptr};  ; TString fWdpath;  ; TFdSet * fWritemask {nullptr};  Files that should be checked for read events. ;  ; TFdSet * fWriteready {nullptr};  Files with reads waiting. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TDCacheFile.h>. Inheritance diagram for TDCacheSystem:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TDCacheSystem(). TDCacheSystem::TDCacheSystem ; (; ). Create helper class that allows directory access via dCache. ; Definition at line 610 of file TDCacheFile.cxx. ◆ ~TDCacheSystem(). TDCacheSystem::~TDCacheSystem ; (; ). inlineoverride . Definition at line 88 of file TDCacheFile.h. Member Function Documentation. ◆ AccessPathName(). Bool_t TDCacheSystem::AccessPathName ; (; const char * ; path, . EAccessMode ; mode . ). overridevirtual . Returns FALSE if one can access a file using the specified access mode. ; Mode is the same as for the Unix access(2) function. Attention, bizarre convention of return value!! ; Reimplemented from TSystem.; Definition at line 695 of file TDCacheFile.cxx. ◆ Class(). static TClass * TDCacheSystem::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDCacheSystem::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDCacheSystem::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 97 of file TDCacheFile.h. ◆ DeclFileName(). static const char * TDCacheSystem::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 97 of file TDCacheFile.h. ◆ FreeDirectory(). void TDCacheSystem::FreeDirectory ; (; void * ; dirp). overridevirtual . Close a directory. ; Reimplemented from TSystem.; Definition at line 658 of file TDCacheFile.cxx. ◆ Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheSystem.html:34012,access,access,34012,doc/master/classTDCacheSystem.html,https://root.cern,https://root.cern/doc/master/classTDCacheSystem.html,2,['access'],['access']
Security,"n ASCII form; uuid:<uuid> UUID of the file. tree:<name>,<entries>,<first>,<last>; meta-information about a tree in the file; the; should be in the form <subdir>/tree-name;'entries' is; the number of entries in the tree; 'first' and 'last'; define the entry range. obj:<name>,<class>,<entries>; meta-information about a generic object in the file;; the should be in the form <subdir>/obj-name; 'class'; is the object class; 'entries' is the number of occurences; for this object. idx:<index> Index of this file if sorting with index. Multiple occurences of 'tree:' or 'obj:' can be specified.; The initializations done via the input string are superseeded by the ones by other; parameters in the constructor, if any.; If no key is given, the token is interpreted as URL(s). void SetUUID(const char* uuid); Set the UUID to the value associated to the string 'uuid'. This is; useful to set the UUID to the one of the ROOT file during verification.; NB: we do not change the name in here, because this would screw up lists; of these objects hashed on the name. Those lists need to be rebuild.; TFileCollection does that in RemoveDuplicates. TUrl * GetCurrentUrl() const; Return the current url. TUrl * NextUrl(); Iterator function, start iteration by calling ResetUrl().; The first call to NextUrl() will return the 1st element,; the seconde the 2nd element etc. Returns 0 in case no more urls. TUrl * FindByUrl(const char* url, Bool_t withDeflt = kFALSE); Find an element from a URL. Returns 0 if not found. Bool_t AddUrl(const char* url, Bool_t infront = kFALSE); Add a new URL. If 'infront' is TRUE the new url is pushed at the beginning; of the list; otherwise is pushed back.; Returns kTRUE if successful, kFALSE otherwise. Bool_t RemoveUrl(const char* url); Remove an URL. Returns kTRUE if successful, kFALSE otherwise. Bool_t RemoveUrlAt(Int_t i); Remove URL at given position. Returns kTRUE on success, kFALSE on error. Bool_t SetCurrentUrl(const char* url); Set 'url' as current URL, if in the l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFileInfo.html:8368,hash,hashed,8368,root/html534/TFileInfo.html,https://root.cern,https://root.cern/root/html534/TFileInfo.html,3,['hash'],['hashed']
Security,"n TFile.cxx:950; TMVA::CrossValidationClass to perform cross validation, splitting the dataloader into folds.Definition CrossValidation.h:124; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddRegressionTreevoid AddRegressionTree(TTree *tree, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)Definition DataLoader.h:103; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddTargetvoid AddTarget(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:512; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TMVA::TMVAGuivoid TMVAGui(const char *fName=""TMVA.root"", TString dataset=""""); Factory.h; AuthorKim Albertsson (adapted from code originally by Andreas Hoecker) ; Definition in file TMVACrossValidationRegression.C. tutorialstmvaTMVACrossValidationRegression.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:22454,access,access,22454,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,2,['access'],['access']
Security,"n TInterpreter.h:215; TInterpreter::kUnknown@ kUnknownDefinition TInterpreter.h:214; TInterpreter::kWithClassDefInline@ kWithClassDefInlineDefinition TInterpreter.h:216; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::GetRootMapFilesvirtual TObjArray * GetRootMapFiles() const =0; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TInterpreter::kProcessing@ kProcessingDefinition TInterpreter.h:77; TInterpreter::kNoError@ kNoErrorDefinition TInterpreter.h:73; TInterpreter::kRecoverable@ kRecoverableDefinition TInterpreter.h:74; TInterpreter::kDangerous@ kDangerousDefinition TInterpreter.h:75; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfDataMembers::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a data member just by name or create it if its not already...Definition TListOfDataMembers.cxx:182; TListOfDataMembers::FindTDictionary * Find(DeclId_t id) constReturn (after creating it if necessary) the TDataMember describing the data member corresponding to t...Definition TListOfDataMembers.cxx:205; TListOfDataMembers::GetClassTClass * GetClass() constDefinition TListOfDataMembers.h:90; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfEnums::FindTEnum * Find(DeclId_t id) constReturn the TEnum corres",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:470297,access,access,470297,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['access'],['access']
Security,"n TInterpreter.h:412; TInterpreter::ClassInfo_ClassPropertyvirtual Long_t ClassInfo_ClassProperty(ClassInfo_t *) constDefinition TInterpreter.h:400; TInterpreter::ClassInfo_GetBaseOffsetvirtual Longptr_t ClassInfo_GetBaseOffset(ClassInfo_t *, ClassInfo_t *, void *=nullptr, bool=true) constDefinition TInterpreter.h:409; TInterpreter::ClassInfo_Destructvirtual void ClassInfo_Destruct(ClassInfo_t *, void *) constDefinition TInterpreter.h:404; TIsAProxyTIsAProxy implementation class.Definition TIsAProxy.h:27; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsWithLock::Classstatic TClass * Class(); TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::fClassTClass * fClassDefinition TListOfFunctionTemplates.h:40; TListOfFunctionTemplates::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a function just by name or create it if its not already in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionTemplates::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' into this collection.Definition TListOfFunctionTemplates.cxx:356; TListOfFunctionTemplates::Deletevoid Delete(Option_t *option="""") overrideDelete all TFunction object files.Definition TListOfFunctionTemplates.cxx:164; TListOfFunctionsA collection of TFunction objects desig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:356761,access,access,356761,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['access'],['access']
Security,"n TListOfFunctions.cxx:443; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::AddFirstvoid AddFirst(TObject *obj) overrideAdd object at the beginning of the list.Definition TList.cxx:98; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberInspector::Inspectvirtual void Inspect(TClass *cl, const char *parent, const char *name, const void *addr)Definition TMemberInspector.cxx:99; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodArgEach ROOT method (see TMethod) has a linked list of its arguments.Definition TMethodArg.h:36; TMethodArg::GetFullTypeNameconst char * GetFullTypeName() constGet full type description of method argument, e.g.: ""class TDirectory*"".Definition TMethodArg.cxx:74; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMethod::GetClassTClass * GetClass() constDefinition TMethod.h:55; TMethod::IsMenuItemEMenuItemKind IsMenuItem() constDefinition TMethod.h:56; TMethod::GetListOfMethodArgsvirtual TList * GetListOfMethodArgs()Returns methodarg list and additionally updates fDataMember in TMethod by calling FindDataMember();.Definition TMethod.cxx:307; TNamed::CloneTObject * Clone(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:359379,access,accessing,359379,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['access'],['accessing']
Security,"n TMacro.h:31; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cxx:615; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; c1return c1Definition legend1.C:41; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA_CNN_ClassificationDefinition TMVA_CNN_Classification.py:1; TMVA::Python_ExecutableTString Python_Executable()Function to find current Python executable used",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:65286,access,access,65286,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,2,['access'],['access']
Security,"n an object from the list of enums if and only if is has already been loaded in the list. ;  ; TClass * IsA () const override;  ; Bool_t IsLoaded () const;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:4234,hash,hashlist,4234,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['hash'],['hashlist']
Security,"n at line 3039 of file TAuthenticate.cxx. ◆ SetSecContext(). void TAuthenticate::SetSecContext ; (; TRootSecContext * ; ctx). inline . Definition at line 149 of file TAuthenticate.h. ◆ SetSecureAuthHook(). void TAuthenticate::SetSecureAuthHook ; (; SecureAuth_t ; func). static . Set secure authorization function. ; Definition at line 1393 of file TAuthenticate.cxx. ◆ SetTimeOut(). void TAuthenticate::SetTimeOut ; (; Int_t ; to). static . Set timeout (active if > 0) ; Definition at line 1369 of file TAuthenticate.cxx. ◆ Show(). void TAuthenticate::Show ; (; Option_t * ; opt = ""S""). static . Print info about the authentication sector. ; If 'opt' contains 's' or 'S' prints information about established TSecContext, else prints information about THostAuth (if 'opt' is 'p' or 'P', prints Proof related information) ; Definition at line 2219 of file TAuthenticate.cxx. ◆ SshAuth(). Int_t TAuthenticate::SshAuth ; (; TString & ; user). private . SSH client authentication code (no longer supported) ; Definition at line 1419 of file TAuthenticate.cxx. ◆ SshError(). Int_t TAuthenticate::SshError ; (; const char * ; errfile). private . ◆ Streamer(). void TAuthenticate::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TAuthenticate::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 207 of file TAuthenticate.h. Friends And Related Symbol Documentation. ◆ TRootAuth. friend class TRootAuth. friend . Definition at line 55 of file TAuthenticate.h. ◆ TRootSecContext. friend class TRootSecContext. friend . Definition at line 56 of file TAuthenticate.h. ◆ TSocket. friend class TSocket. friend . Definition at line 57 of file TAuthenticate.h. Member Data Documentation. ◆ fDetails. TString TAuthenticate::fDetails. private . Definition at line 63 of file TAuthenticate.h. ◆ fgAuthInfo. TList * TAuthenticate::fgAuthInfo = 0. staticprivate . Definition at line 9",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:41665,authenticat,authentication,41665,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"n attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_compCIter! do not persist; RooListProxy_compCSet; TIterator*_compRIter! do not persist; RooListProxy_compRSet; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProduct.html:34985,access,access,34985,root/html602/RooProduct.html,https://root.cern,https://root.cern/root/html602/RooProduct.html,2,['access'],['access']
Security,"n attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormulaVar.html:34159,access,access,34159,root/html534/RooFormulaVar.html,https://root.cern,https://root.cern/root/html534/RooFormulaVar.html,1,['access'],['access']
Security,"n be used by passing its socket in opensock.; If 'err' is defined, '*err' on return from a failed call contains an error code (see NetErrors.h).; Example:; TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3); creates an authenticated parallel socket of size 3 to a sockd server running on remote machine machine.fq.dn on port 5052; authentication will attempt protocol Kerberos first.; NB: may hang if the remote server is not of the correct type; at present TSocket has no way to find out the type of the remote server automatically; Returns pointer to an authenticated socket or 0 if creation or authentication is unsuccessful. ; Definition at line 1290 of file TSocket.cxx. ◆ CreateAuthSocket() [2/2]. TSocket * TSocket::CreateAuthSocket ; (; const char * ; user, . const char * ; url, . Int_t ; port, . Int_t ; size = 0, . Int_t ; tcpwindowsize = -1, . TSocket * ; opensock = nullptr, . Int_t * ; err = nullptr . ). static . Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ; url: [[proto][p][auth]://]host[/?options]; where proto = ""sockd"", ""rootd"", ""proofd"" indicates the type of remote server if missing ""sockd"" is assumed (""sockd"" indicates any remote server session using TServerSocket) [p] = for parallel sockets (forced internally for rootd) [auth] = ""up"" or ""k"" to force UsrPwd or Krb5 authentication [options] = ""m"" or ""s"", when proto=proofd indicates whether we are master or slave (used internally by TSlave); An already opened connection can be used by passing its socket in opensock.; If 'err' is defined, '*err' on return from a failed call contains an error code (see NetErrors.h).; Example:; TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3); creates an authenticated parallel socket of size 3 to a sockd server running on remote machine machine.fq.dn on port 5052; authentication will attempt protocol Kerberos first.; NB: may hang if the remote server is not of the correct type;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:25036,authenticat,authenticates,25036,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['authenticat'],['authenticates']
Security,"n col from this collection. void Streamer(TBuffer& b); Stream all objects in the collection to or from the I/O buffer. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). TCollection * GetCurrentCollection(); Return the globally accessible collection. void SetCurrentCollection(); Set this collection to be the globally accesible collection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). void operator=(const TCollection& ). virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* name) const; { return FindObject(name) != 0; }. Bool_t Contains(const TObject* obj) const; { return FindObject(obj) != 0; }. void Delete(Option_t* optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCollection.html:13287,access,accessible,13287,root/html528/TCollection.html,https://root.cern,https://root.cern/root/html528/TCollection.html,3,['access'],['accessible']
Security,"n ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooNumConvolution*_conv! Actual convolution calculation; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:42698,access,access,42698,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,1,['access'],['access']
Security,"n ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooCategoryProxy_catAccept/reject categort; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooRealProxy_effFuncEfficiency modeling function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEfficiency.html:42068,access,access,42068,root/html602/RooEfficiency.html,https://root.cern,https://root.cern/root/html602/RooEfficiency.html,2,['access'],['access']
Security,"n failed 1 in case of success ; Definition at line 1509 of file TAuthenticate.cxx. ◆ DeclFileName(). static const char * TAuthenticate::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 207 of file TAuthenticate.h. ◆ DecodeRSAPublic(). Int_t TAuthenticate::DecodeRSAPublic ; (; const char * ; rsapubexport, . R__rsa_NUMBER & ; n, . R__rsa_NUMBER & ; d, . char ** ; rsassl = nullptr . ). static . Store RSA public keys from export string rsaPubExport. ; Definition at line 2936 of file TAuthenticate.cxx. ◆ FileExpand(). void TAuthenticate::FileExpand ; (; const char * ; fexp, . FILE * ; ftmp . ). staticprivate . Expands include directives found in fexp files The expanded, temporary file, is pointed to by 'ftmp' and should be already open. ; To be called recursively. ; Definition at line 2093 of file TAuthenticate.cxx. ◆ GenRSAKeys(). Int_t TAuthenticate::GenRSAKeys ; (; ). private . Generate a valid pair of private/public RSA keys to protect for authentication token exchange. ; Definition at line 2501 of file TAuthenticate.cxx. ◆ GetAuthInfo(). TList * TAuthenticate::GetAuthInfo ; (; ). static . Static method returning the list with authentication details. ; Definition at line 1236 of file TAuthenticate.cxx. ◆ GetAuthMethod(). const char * TAuthenticate::GetAuthMethod ; (; Int_t ; idx). static . Static method returning the method corresponding to idx. ; Definition at line 1067 of file TAuthenticate.cxx. ◆ GetAuthMethodIdx(). Int_t TAuthenticate::GetAuthMethodIdx ; (; const char * ; meth). static . Static method returning the method index (which can be used to find the method in GetAuthMethod()). ; Returns -1 in case meth is not found. ; Definition at line 1082 of file TAuthenticate.cxx. ◆ GetAuthReUse(). Bool_t TAuthenticate::GetAuthReUse ; (; ). static . Static method returning the authentication reuse settings. ; Definition at line 1051 of file TAuthenticate.cxx. ◆ GetClientProtocol(). Int_t TAuthenticate::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:26002,authenticat,authentication,26002,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"n false;; 319 }; 320 ; 321 //-----------------------------------------------------------------------; 322 // Check if we have either version or checksum specified; 323 //////////////////////////////////////////////////////////////////////////; 324 ; 325 it1 = rule.find( ""version"" );; 326 it2 = rule.find( ""checksum"" );; 327 if( it1 == rule.end() && it2 == rule.end() ) {; 328 error_string = warning + "" - you need to specify either version or "";; 329 error_string += ""checksum"";; 330 return false;; 331 }; 332 ; 333 //-----------------------------------------------------------------------; 334 // Check if the checksum has been set to right value; 335 //////////////////////////////////////////////////////////////////////////; 336 ; 337 if( it2 != rule.end() ) {; 338 if( it2->second.size() < 2 || it2->second[0] != '[' ||; 339 it2->second[it2->second.size()-1] != ']' ) {; 340 error_string = warning + "" - a comma separated list of ints"";; 341 error_string += "" enclosed in square brackets expected"";; 342 error_string += "" as a value of checksum parameter"";; 343 return false;; 344 }; 345 ; 346 TSchemaRuleProcessor::SplitList( it2->second.substr( 1, it2->second.size()-2 ),; 347 lst );; 348 if( lst.empty() ) {; 349 error_string += warning + "" - the list of checksums is empty\n"";; 350 }; 351 ; 352 for( const auto& chk : lst ) {; 353 if( !TSchemaRuleProcessor::IsANumber(chk, true) ) {; 354 error_string = warning + "" - "" + chk + "" is not a valid value"";; 355 error_string += "" of checksum parameter - an integer (decimal/hex) expected"";; 356 return false;; 357 }; 358 }; 359 }; 360 ; 361 //-----------------------------------------------------------------------; 362 // Check if the version is correct; 363 //////////////////////////////////////////////////////////////////////////; 364 ; 365 std::pair<Int_t, Int_t> ver;; 366 if( it1 != rule.end() ) {; 367 if( it1->second.size() < 2 || it1->second[0] != '[' ||; 368 it1->second[it1->second.size()-1] != ']' ) {; 369 error_string = warning +",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html:12812,checksum,checksum,12812,doc/master/RConversionRuleParser_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html,2,['checksum'],['checksum']
Security,"n information of the function member. this overloading is unfortunate but I can't include Type.h here. * FunctionMemberSize will return the number of function members of; * this type; * @return number of function members. void GenerateDict(Reflex::DictionaryGenerator& generator) const. * GenerateDict will produce the dictionary information of this type; * @param generator a reference to the dictionary generator instance. bool HasBase(const Reflex::Type& cl) const. * HasBase will check whether this class has a base class given; * as argument; * @param cl the base-class to check for; * @return the Base info if it is found, an empty base otherwise (can be tested for bool). bool IsPrivate() const. * IsPrivate will check if the scope access is private; * @return true if scope access is private. bool IsProtected() const. * IsProtected will check if the scope access is protected; * @return true if scope access is protected. bool IsPublic() const. * IsPublic will check if the scope access is public; * @return true if scope access is public. Member LookupMember(const string& nam) const. * LookupMember will lookup a member in the current scope; * @param nam the string representation of the member to lookup; * @return if a matching member is found return it, otherwise return empty member. Type LookupType(const string& nam) const. * LookupType will lookup a type in the current scope; * @param nam the string representation of the type to lookup; * @return if a matching type is found return it, otherwise return empty type. Scope LookupScope(const string& nam) const. * LookupScope will lookup a scope in the current scope; * @param nam the string representation of the scope to lookup; * @return if a matching scope is found return it, otherwise return empty scope. Member MemberAt(size_t nth, Reflex::EMEMBERQUERY inh = INHERITEDMEMBERS_DEFAULT) const. * MemberAt will return the nth member of the type; * @param nth member; * @return reflection information nth member. Member MemberByNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Reflex__Scope.html:14337,access,access,14337,root/html526/Reflex__Scope.html,https://root.cern,https://root.cern/root/html526/Reflex__Scope.html,10,['access'],['access']
Security,"n making calls like TClass::GetClass(), etc.; Returns 0 if index points beyond last class name. int Classes(). { return fgTally; }. void Init(); { fgCursor = 0; SortTable(); }. void Add(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); Add a class to the class table (this is a static function). void Remove(const char* cname); Remove a class from the class table. This happens when a shared library; is unloaded (i.e. the dtor's of the global init objects are called). TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. VoidFuncPtr_t GetDict(const char *cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). VoidFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Terminate(); Deletes the class table (this static class function calls the dtor). TClassTable(). » Author: Fons Rademakers 11/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TClassTable.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2009-12-07 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClassTable.html:7775,hash,hash,7775,root/html526/TClassTable.html,https://root.cern,https://root.cern/root/html526/TClassTable.html,1,['hash'],['hash']
Security,"n name or contain the wild card '*'.; for the secure protocols. All lines must start in the first column. ; Definition at line 908 of file TAuthenticate.cxx. ◆ CheckProofAuth(). Bool_t TAuthenticate::CheckProofAuth ; (; Int_t ; cSec, . TString & ; det . ). static . Check if the authentication method can be attempted for the client. ; Definition at line 3541 of file TAuthenticate.cxx. ◆ Class(). static TClass * TAuthenticate::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TAuthenticate::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TAuthenticate::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 207 of file TAuthenticate.h. ◆ ClearAuth(). Int_t TAuthenticate::ClearAuth ; (; TString & ; user, . TString & ; passwd, . Bool_t & ; pwdhash . ). private . UsrPwd client authentication code. ; Returns 0 in case authentication failed 1 in case of success ; Definition at line 1509 of file TAuthenticate.cxx. ◆ DeclFileName(). static const char * TAuthenticate::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 207 of file TAuthenticate.h. ◆ DecodeRSAPublic(). Int_t TAuthenticate::DecodeRSAPublic ; (; const char * ; rsapubexport, . R__rsa_NUMBER & ; n, . R__rsa_NUMBER & ; d, . char ** ; rsassl = nullptr . ). static . Store RSA public keys from export string rsaPubExport. ; Definition at line 2936 of file TAuthenticate.cxx. ◆ FileExpand(). void TAuthenticate::FileExpand ; (; const char * ; fexp, . FILE * ; ftmp . ). staticprivate . Expands include directives found in fexp files The expanded, temporary file, is pointed to by 'ftmp' and should be already open. ; To be called recursively. ; Definition at line 2093 of file TAuthenticate.cxx. ◆ GenRSAKeys(). Int_t TAuthenticate::GenRSAKeys ; (; ). private . Generate a valid pair of private/public RSA keys to protect for auth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:24971,authenticat,authentication,24971,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"n object of TVirtualObject class representing the input data, guaranteed to hold the data members declared in the source property of the rule. buffer. in raw conversion rules, an object of TBuffer class holding the data member declared in source property of the rule. names of the data members of the target object declared in the target property of the rule declared to be the appropriate type; onfile.xxx. in normal conversion rules, names of the variables of basic types declared in the source property of the rule. 11.5.6.2 The C++ API; The schema evolution C++ API consists of two classes: ROOT::TSchemaRuleSet and ROOT::TSchemaRule. Objects of the TSchemaRule class represent the rules and their fields have exactly the same meaning as the ones of rules specified in the dictionaries. TSchemaRuleSet objects manage the sets of rules and ensure their consistency. There can be no conflicting rules in the rule sets. The rule sets are owned by the TClass objects corresponding to the target classes defined in the rules and can be accessed using TClass::{Get|Adopt}SchemaRules.; 11.5.7 Manual Schema Evolution; If you have written your own Streamer as described in the section “Streamers with Special Additions”, you will have to manually add code for each version and manage the evolution of your class. When you add or remove data members, you must modify the Streamer by hand. ROOT assumes that you have increased the class version number in the ClassDef statement and introduced the relevant test in the read part of the Streamer. For example, if a new version of the Event class above includes a new member: Int_t fNew the ClassDef statement should be changed to ClassDef(Event,2) and the following lines should be added to the read part of the Streamer:; if (R__v > 1) R__b >> fNew;; else fNew = 0; // set to some default value; If, in the same new version 2 you remove the member fH, you must add the following code to read the histogram object into some temporary object and delete it:; if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:504236,access,accessed,504236,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessed']
Security,"n one of the data member; 984 // was declared using a typedef _and_ the current class definition; 985 // uses a different typedef, we are unable to recalculate the; 986 // checksum as it was, because the information is missing from; 987 // the StreamerInfo, and for the same reason CompareContent can; 988 // not know whether this is okay or not ...; 989 //; 990 // Since this is such an unlikely scenario, let's complain; 991 // about it anyway (The class layout *may* have changed, we; 992 // don't know).; 993 ; 994 // if (this has only base classes) {; 995 // match = kTRUE;; 996 // }; 997 }; 998#endif; 999 } else {; 1000 // The on-file TStreamerInfo's checksum differs from the checksum of a TStreamerInfo on another file.; 1001 ; 1002 match = kFALSE;; 1003 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 1004 ; 1005 // In the case where the read-in TStreamerInfo does not; 1006 // match in the 'current' in memory TStreamerInfo for; 1007 // a non foreign class (we can not get here if this is; 1008 // a foreign class so we do not need to test it),; 1009 // we need to add this one more test since the CINT behaviour; 1010 // with enums changed over time, so verify the checksum ignoring; 1011 // members of type enum. We also used to not count the //[xyz] comment; 1012 // in the checksum, so test for that too.; 1013 if (fCheckSum == info->GetCheckSum(TClass::kCurrentCheckSum); 1014 || info->MatchLegacyCheckSum(fCheckSum); 1015 || GetCheckSum(TClass::kCurrentCheckSum) == info->fCheckSum; 1016 || MatchLegacyCheckSum(info->GetCheckSum()); 1017 || GetCheckSum(TClass::kCurrentCheckSum) == info->GetCheckSum(TClass::kCurrentCheckSum)); 1018 {; 1019 match = kTRUE;; 1020 }; 1021 if (fOldVersion <= 2) {; 1022 // Names of STL base classes was modified in vers==3. Allocators removed; 1023 // (We could be more specific (see test for the same case below); 1024 match = kTRUE;; 1025 }; 1026 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:37648,checksum,checksum,37648,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['checksum'],['checksum']
Security,"n parameter(s) with given name(s) in category(s) with given names putting remainder fraction formula in state with name ""remainder"" . SplitParamConstrained(var,cat,remainder) Make constrained split in parameter(s) with given name(s) in category(s) with given names putting remainder fraction formula in state with name ""remainder"" . Restrict(catName,stateNameList) Restrict build by only considered listed state names of category with given name. PyROOT; The RooSimWSTool::build() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 173 of file RooSimWSTool.cxx. ◆ executeBuild(). RooSimultaneous * RooSimWSTool::executeBuild ; (; const char * ; simPdfName, . ObjBuildConfig & ; obc, . bool ; verbose = true . ). protected . Internal build driver from validation ObjBuildConfig. ; Definition at line 378 of file RooSimWSTool.cxx. ◆ makeSplitName(). std::string RooSimWSTool::makeSplitName ; (; const RooArgSet & ; splitCatSet). protected . Construct name of composite split. ; Definition at line 612 of file RooSimWSTool.cxx. ◆ validateConfig(). std::unique_ptr< RooSimWSTool::ObjBuildConfig > RooSimWSTool::validateConfig ; (; BuildConfig & ; bc). protected . Validate build configuration. ; If not syntax errors or missing objects are found, return an ObjBuildConfig in which all names are replaced with object pointers. ; Definition at line 206 of file RooSimWSTool.cxx. Member Data Documentation. ◆ _ws. RooWorkspace* RooSimWSTool::_ws. protected . Definition at line 69 of file RooSimWSTool.h. Libraries for RooSimWSTool:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooSimWSTool.h; roofit/roofitcore/src/RooSimWSTool.cxx; /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/master_TMP/pyzdoc/_roofit.pyzdoc. RooSimWSTool. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:09 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimWSTool.html:8574,validat,validateConfig,8574,doc/master/classRooSimWSTool.html,https://root.cern,https://root.cern/doc/master/classRooSimWSTool.html,2,['validat'],['validateConfig']
Security,"n response of a timer timing out. ;  ; virtual void IconifyWindow ();  iconify window ;  ; TClass * IsA () const override;  ; virtual Bool_t IsMapped ();  Returns kTRUE if window is mapped on screen, kFALSE otherwise. ;  ; virtual void LowerWindow ();  lower window ;  ; void Print (Option_t *option="""") const override;  Print window id. ;  ; virtual void RaiseWindow ();  raise window ;  ; virtual void RequestFocus ();  request focus ;  ; virtual void SetBackgroundPixmap (Pixmap_t pixmap);  set background pixmap ;  ; virtual void SetName (const char *name);  ; virtual void SetWindowName (const char *name=nullptr);  Set window name. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGObject;  TGObject ();  ;  TGObject (const TGObject &tgo);  ;  ~TGObject () override;  TGObject destructor. ;  ; TGClient * GetClient () const;  ; Handle_t GetId () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison (TGObjects are equal if they have the same window identifier). ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Write this TGObject to a file using TImage, if filename's extension signals a valid TImage::EImageFileType, as defined by TImage::GetImageFileTypeFromFilename(). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEditQueryFrame.html:13135,hash,hash,13135,doc/master/classTEditQueryFrame.html,https://root.cern,https://root.cern/doc/master/classTEditQueryFrame.html,59,['hash'],['hash']
Security,"n separate them by ' ' (blank), for instance: ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+""; Examples: TFile* f1 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f2 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f3 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""TOKEN=AQoDYXdzEM///////////wEa8AHEYmCinjD+TsGEjtgKSMAT6wnY"");; If there is no authentication information in the 'options' argument (i.e. not AUTH=""...."") the values of the environmental variables S3_ACCESS_KEY and S3_SECRET_KEY (if set) are expected to contain the access key id and the secret access key, respectively. You have been provided with these credentials by your S3 service provider.; If neither the AUTH information is provided in the 'options' argument nor the environmental variables are set, we try to open the file without providing any authentication information to the server. This is useful when the file is set an access control that allows for any unidentified user to read the file. ; Definition at line 152 of file TS3WebFile.cxx. ◆ ~TS3WebFile(). virtual TS3WebFile::~TS3WebFile ; (; ). inlinevirtual . Definition at line 93 of file TS3WebFile.h. Member Function Documentation. ◆ Class(). static TClass * TS3WebFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TS3WebFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TS3WebFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 105 of file TS3WebFile.h. ◆ DeclFileName(). static const char * TS3WebFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 105 of file TS3WebFile.h. ◆ GetAccessKey(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:51239,authenticat,authentication,51239,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['authenticat'],['authentication']
Security,"n the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< bool > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t > >;  CIterators;  CTFutureImpl;  CTRangeStaticCastTRangeStaticCast is an adaptater class that allows the typed iteration through a TCollection ;  ►CTSchemaRuleSet;  CTMatches;  ►CTStatusBitsChecker;  CRegistry;  CTTypedIterTTypedIter is a typed version of TIter ;  ►NExecutorUtilsThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental;  ►NDetail;  CTArgsMenuItem;  CTCheckedMenuItem;  CTHistBinIterIterates over the bins of a THist or THistImpl ;  CTHistBinPtrPoints to a histogram bin (or actually a THistBinRef) ;  CTHistBinRefRepresents a bin reference ;  CTHistBinStatConst view on a bin's statistical data ;  CTHistDataA THistImplBase's data, provides accessors to all its statistics ;  CTHistImpl;  CTHistImplBaseInterface class for THistImpl ;  CTHistImplPrecisionAgnosticBaseBase class for THistImplBase that abstracts out the histogram's PRECISION ;  CTMenuArgument;  CTMenuItemClass contains info for producing menu item on the JS side ;  CTPadLinearUserCoordThe default, linear min/max coordinate system for TPad, TCanvas ;  CTPadUserCoordBase;  ►NHist;  CTCoordArray;  ►NInternal;  ►NDetail;  CTPadUserCoordBaseBase class for user coordinates (e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:13120,access,accessors,13120,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['access'],['accessors']
Security,"n this RooCmdArg. ;  ; RooLinkedList const & subArgs () const;  Return list of sub-arguments in this RooCmdArg. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCmdArg.html:3594,hash,hash,3594,doc/master/classRooCmdArg.html,https://root.cern,https://root.cern/doc/master/classRooCmdArg.html,1,['hash'],['hash']
Security,"n with the window like http://localhost:9635/win1/?key=<connection_key>#<session_key> When. ;  ; std::string GetUserArgs () const;  Returns configured user arguments for web window See SetUserArgs method for more details. ;  ; unsigned GetWidth () const;  returns configured window width (0 - default) actual window width can be different ;  ; int GetX () const;  returns configured window X position (-1 - default) ;  ; int GetY () const;  returns configured window Y position (-1 - default) ;  ; bool HasConnection (unsigned connid=0, bool only_active=true) const;  returns true if specified connection id exists ;  ; bool IsNativeOnlyConn () const;  returns true if only native (own-created) connections are allowed ;  ; bool IsRequireAuthKey () const;  returns true if authentication string is required ;  ; bool IsShown () const;  Returns true when window was shown at least once. ;  ; bool IsUseCurrentDir () const;  returns true if window can access local files via currentdir/ path of http server ;  ; int NumConnections (bool with_pending=false) const;  Returns current number of active clients connections. ;  ; void RecordData (const std::string &fname=""protocol.json"", const std::string &fprefix="""");  Configures recording of communication data in protocol file Provided filename will be used to store JSON array with names of written files - text or binary If data was send from client, ""send"" entry will be placed. ;  ; void Run (double tm=0.);  Run window functionality for specified time If no action can be performed - just sleep specified time. ;  ; void Send (unsigned connid, const std::string &data);  Sends data to specified connection. ;  ; void SendBinary (unsigned connid, const void *data, std::size_t len);  Send binary data to specified connection. ;  ; void SendBinary (unsigned connid, std::string &&data);  Send binary data to specified connection. ;  ; _R__DEPRECATED_LATER(""Use GetUrl() to get valid connection URL"") std _R__DEPRECATED_LATER(""Use GetAddr() to get vali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:5113,access,access,5113,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['access'],['access']
Security,"n with the window like http://localhost:9635/win1/?key=<connection_key>#<session_key> When. ;  ; std::string GetUserArgs () const;  Returns configured user arguments for web window See SetUserArgs method for more details. ;  ; unsigned GetWidth () const;  returns configured window width (0 - default) actual window width can be different ;  ; int GetX () const;  returns configured window X position (-1 - default) ;  ; int GetY () const;  returns configured window Y position (-1 - default) ;  ; bool HasConnection (unsigned connid=0, bool only_active=true) const;  returns true if specified connection id exists ;  ; bool IsNativeOnlyConn () const;  returns true if only native (own-created) connections are allowed ;  ; bool IsRequireAuthKey () const;  returns true if authentication string is required ;  ; bool IsShown () const;  Returns true when window was shown at least once. ;  ; bool IsUseCurrentDir () const;  returns true if window can access local files via currentdir/ path of http server ;  ; int NumConnections (bool with_pending=false) const;  Returns current number of active clients connections. ;  ; void RecordData (const std::string &fname=""protocol.json"", const std::string &fprefix="""");  Configures recording of communication data in protocol file Provided filename will be used to store JSON array with names of written files - text or binary If data was send from client, ""send"" entry will be placed. ;  ; void Run (double tm=0.);  Run window functionality for specified time If no action can be performed - just sleep specified time. ;  ; void Send (unsigned connid, const std::string &data);  Sends data to specified connection. ;  ; void SendBinary (unsigned connid, const void *data, std::size_t len);  Send binary data to specified connection. ;  ; void SendBinary (unsigned connid, std::string &&data);  Send binary data to specified connection. ;  ; void SetCallBacks (WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:5649,access,access,5649,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['access'],['access']
Security,"n"" header with; the signature of the request, generated using the user's secret access; key. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf). void ProcessHttpHeader(const TString& headerLine); This method is called by the super-class TWebFile when a HTTP header; for this file is retrieved. We scan the 'Server' header to detect the; type of S3 server this file is hosted on and to determine if it is; known to support multi-range HTTP GET requests. Some S3 servers (for; instance Amazon's) do not support that feature and when they; receive a multi-range request they sent back the whole file contents.; For this class, if the server do not support multirange requests; we issue multiple single-range requests instead. Bool_t GetCredentialsFromEnv(const char* accessKeyEnv, const char* secretKeyEnv, TString& outAccessKey, TString& outSecretKey); Sets the access and secret keys from the environmental variables, if; they are both set. TS3WebFile(). void SetAccessKey(const TString& accessKey); Modifiers of data members (to be used mainly by subclasses). { fS3Request.SetAccessKey(accessKey); }. void SetSecretKey(const TString& secretKey); { fS3Request.SetSecretKey(secretKey); }. TS3WebFile(const char* url, Option_t* options = """"); Constructors & Destructor. virtual ~TS3WebFile(); {}. const TString& GetAccessKey() const; Selectors. { return fS3Request.GetAccessKey(); }. const TString& GetSecretKey() const; { return fS3Request.GetSecretKey(); }. const TString& GetBucket() const; { return fS3Request.GetBucket(); }. const TString& GetObjectKey() const; { return fS3Request.GetObjectKey(); }. const TUrl& GetUrl() const; { return fUrl; }. » Author: Fabio Hernandez 22/01/2013 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TS3WebFile.h$ » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TS3WebFile.html:32726,access,accessKey,32726,root/html604/TS3WebFile.html,https://root.cern,https://root.cern/root/html604/TS3WebFile.html,2,['access'],['accessKey']
Security,"n"" header with; the signature of the request, generated using the user's secret access; key. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf). void ProcessHttpHeader(const TString& headerLine); This method is called by the super-class TWebFile when a HTTP header; for this file is retrieved. We scan the 'Server' header to detect the; type of S3 server this file is hosted on and to determine if it is; known to support multi-range HTTP GET requests. Some S3 servers (for; instance Amazon's) do not support that feature and when they; receive a multi-range request they sent back the whole file contents.; For this class, if the server do not support multirange requests; we issue multiple single-range requests instead. Bool_t GetCredentialsFromEnv(const char* accessKeyEnv, const char* secretKeyEnv, TString& outAccessKey, TString& outSecretKey); Sets the access and secret keys from the environmental variables, if; they are both set. TS3WebFile(). void SetAccessKey(const TString& accessKey); Modifiers of data members (to be used mainly by subclasses). { fS3Request.SetAccessKey(accessKey); }. void SetSecretKey(const TString& secretKey); { fS3Request.SetSecretKey(secretKey); }. TS3WebFile(const char* url, Option_t* options = """"); Constructors & Destructor. virtual ~TS3WebFile(); {}. const TString& GetAccessKey() const; Selectors. { return fS3Request.GetAccessKey(); }. const TString& GetSecretKey() const; { return fS3Request.GetSecretKey(); }. const TString& GetBucket() const; { return fS3Request.GetBucket(); }. const TString& GetObjectKey() const; { return fS3Request.GetObjectKey(); }. const TUrl& GetUrl() const; { return fUrl; }. » Author: Fabio Hernandez 22/01/2013 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TS3WebFile.h$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:32726,access,accessKey,32726,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,2,['access'],['accessKey']
Security,"n() const; hessian (inverse of covariance matrix). const std::vector<double>& IntParameters() const; Minuit internal representation. {return fIntParameters;}. const MnUserCovariance& IntCovariance() const; {return fIntCovariance;}. int CovarianceStatus() const; covariance matrix status (0 = not valid, 1 approximate, 2, full but made pos def, 3 accurate and not pos def. { return fCovStatus; }. const MnUserTransformation& Trafo() const; transformation internal <-> external. {return fParameters.Trafo();}. bool IsValid() const; {return fValid;}. bool HasCovariance() const; {return fCovarianceValid;}. bool HasGlobalCC() const; {return fGCCValid;}. double Fval() const; {return fFVal;}. double Edm() const; {return fEDM;}. unsigned int NFcn() const; {return fNFcn;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation ; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const string& name, double val, double err); add free Parameter. void Add(const string& name, double val, double err, double , double ); add limited Parameter. void Add(const string& , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void RemoveLimits(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void SetName(unsigned int iext, const string& name); { fParameters.SetName(iext,name); }. double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& , double ). void SetError(const string& , double ). void SetL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__MnUserParameterState.html:6073,access,access,6073,root/html534/ROOT__Minuit2__MnUserParameterState.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__MnUserParameterState.html,3,['access'],['access']
Security,"n() const; hessian (inverse of covariance matrix). const std::vector<double>& IntParameters() const; Minuit internal representation. {return fIntParameters;}. const MnUserCovariance& IntCovariance() const; {return fIntCovariance;}. int CovarianceStatus() const; covariance matrix status (0 = not valid, 1 approximate, 2, full but made pos def, 3 accurate and not pos def. { return fCovStatus; }. const MnUserTransformation& Trafo() const; transformation internal <-> external. {return fParameters.Trafo();}. bool IsValid() const; {return fValid;}. bool HasCovariance() const; {return fCovarianceValid;}. bool HasGlobalCC() const; {return fGCCValid;}. double Fval() const; {return fFVal;}. double Edm() const; {return fEDM;}. unsigned int NFcn() const; {return fNFcn;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation ; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const string& name, double val, double err); add free Parameter. void Add(const string& name, double val, double err, double , double ); add limited Parameter. void Add(const string& , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& , double ). void SetError(const string& , double ). void SetLimits(const string& , double , double ). void SetUpperLimit(const string& , double ). void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Minuit2__MnUserParameterState.html:6021,access,access,6021,root/html532/ROOT__Minuit2__MnUserParameterState.html,https://root.cern,https://root.cern/root/html532/ROOT__Minuit2__MnUserParameterState.html,1,['access'],['access']
Security,"n) const; Double_tGetMax() const; Double_tGetMean() const; Double_tGetMin() const; Int_tGetNbins() const; Double_tGetRndm(TRandom3&) const; Double_tGetStepSize() const; Double_tGetWidth() const; TMVA::IntervalInterval(const TMVA::Interval& other); TMVA::IntervalInterval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::Interval&operator=(const TMVA::Interval&); voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. Double_tfMaxthe constraints of the Interval; Double_tfMin; Int_tfNbinswhen >0 : number of bins (discrete interval); when ==0 continuous interval; static TMVA::MsgLogger*fgLoggermessage logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interval(Double_t min, Double_t max, Int_t nbins = 0). Interval(const TMVA::Interval& other). ~Interval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize() const; retuns the step size between the numbers of a ""discrete Interval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetMin() const; accessors. { return fMin; }. Double_t GetMax() const; { return fMax; }. Double_t GetWidth() const; { return fMax - fMin; }. Int_t GetNbins() const; { return fNbins; }. Double_t GetMean() const; { return (fMax + fMin)/2; }. void SetMax(Double_t m); { fMax = m; }. void SetMin(Double_t m); { fMin = m; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: Interval.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__Interval.html:2651,access,accessors,2651,root/html532/TMVA__Interval.html,https://root.cern,https://root.cern/root/html532/TMVA__Interval.html,1,['access'],['accessors']
Security,"n) const; Double_tGetMax() const; Double_tGetMean() const; Double_tGetMin() const; Int_tGetNbins() const; Double_tGetRndm(TRandom3&) const; Double_tGetStepSize() const; Double_tGetWidth() const; TMVA::IntervalInterval(const TMVA::Interval& other); TMVA::IntervalInterval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::Interval&operator=(const TMVA::Interval&); voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. Double_tfMaxthe constraints of the Interval; Double_tfMin; Int_tfNbinswhen >0 : number of bins (discrete interval); when ==0 continuous interval; static TMVA::MsgLogger*fgLoggermessage logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interval(Double_t min, Double_t max, Int_t nbins = 0). Interval(const TMVA::Interval& other). ~Interval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize() const; retuns the step size between the numbers of a ""discrete Interval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetMin() const; accessors. { return fMin; }. Double_t GetMax() const; { return fMax; }. Double_t GetWidth() const; { return fMax - fMin; }. Int_t GetNbins() const; { return fNbins; }. Double_t GetMean() const; { return (fMax + fMin)/2; }. void SetMax(Double_t m); { fMax = m; }. void SetMin(Double_t m); { fMin = m; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: Interval.h 40012 2011-06-27 16:03:11Z stelzer $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__Interval.html:2651,access,accessors,2651,root/html530/TMVA__Interval.html,https://root.cern,https://root.cern/root/html530/TMVA__Interval.html,1,['access'],['accessors']
Security,"n). ; Definition at line 4915 of file TClass.cxx. ◆ EscapeChars(). char * TClass::EscapeChars ; (; const char * ; text); const. Introduce an escape character (@) in front of a special chars. ; You need to use the result immediately before it is being overwritten. ; Definition at line 2568 of file TClass.cxx. ◆ FindClassOrBaseMethodWithId(). TMethod * TClass::FindClassOrBaseMethodWithId ; (; DeclId_t ; faddr). private . Find a method with decl id in this class or its bases. ; Definition at line 4440 of file TClass.cxx. ◆ FindConversionStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const char * ; onfile_classname, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ; Definition at line 7193 of file TClass.cxx. ◆ FindConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const TClass * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7204 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7066 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7036 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:67357,checksum,checksum,67357,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['checksum'],['checksum']
Security,"n). ; Definition at line 4982 of file TClass.cxx. ◆ EscapeChars(). char * TClass::EscapeChars ; (; const char * ; text); const. Introduce an escape character (@) in front of a special chars. ; You need to use the result immediately before it is being overwritten. ; Definition at line 2635 of file TClass.cxx. ◆ FindClassOrBaseMethodWithId(). TMethod * TClass::FindClassOrBaseMethodWithId ; (; DeclId_t ; faddr). private . Find a method with decl id in this class or its bases. ; Definition at line 4507 of file TClass.cxx. ◆ FindConversionStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const char * ; onfile_classname, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ; Definition at line 7260 of file TClass.cxx. ◆ FindConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const TClass * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7271 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7133 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7103 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:67358,checksum,checksum,67358,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['checksum'],['checksum']
Security,"n); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableValue(unsigned int ivar, double val); virtual boolSetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::GSLNLSMinimizerGSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer&); ROOT::Math::GSLNLSMinimizer&operator=(const ROOT::Math::GSLNLSMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. map<unsigned int,std::pair<double,double> >fBoundsmap specifying the bound using as key the parameter index; vector<double>fCovMatrixcov matrix (stored as cov[ i * dim + j] ; unsigned intfDimdimension of the function to be minimized ; doublefEdmedm value; vector<double>fErrors; ROOT::Math::GSLMultiFit*fGSLMultiFitpointer to GSL multi fit solver ; doublefLSToleranceLine Search Tolerance; doublefMinValminimum function value; unsigned intfNFreedimension of the internal function to be minimized ; vector<std::string>fNames; const ROOT::Math::FitMethodFunction*fObjFuncpointer to Least square function; vector<LSResidualFunc>fResiduals! transient Vector of the residual functions; unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLNLSMinimizer.html:4538,validat,validated,4538,root/html526/ROOT__Math__GSLNLSMinimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLNLSMinimizer.html,4,['validat'],['validated']
Security,"n*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. void*fDirpdirectory handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TWebSystem(); Create helper class that allows directory access via httpd.; The name must start with '-' to bypass the TSystem singleton check. Int_t MakeDirectory(const char* name); Make a directory via httpd. Not supported. void * OpenDirectory(const char* name); Open a directory via httpd. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp); Free directory via httpd. const char * GetDirEntry(void* dirp); Get directory entry via httpd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Int_t Unlink(const char* path); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Not supported for httpd. void * GetDirPtr() const; { return fDirp; }. TWebSystem(). virtual ~TWebSystem(); { }. » Author: Fons Rademakers 17/01/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TWebSystem.html:20553,access,access,20553,root/html604/TWebSystem.html,https://root.cern,https://root.cern/root/html604/TWebSystem.html,3,['access'],['access']
Security,"n, Bool_t caseSensitive); Search for string in text. If direction is true search forward.; Returns true if string is found. void SetFont(FontStruct_t font); Changes text entry font. Long_t ToScrYCoord(Long_t yCoord); Convert line number to screen coordinate. Long_t ToScrXCoord(Long_t xCoord, Long_t line); Convert column number in specified line to screen coordinate. Long_t ToObjYCoord(Long_t yCoord); Convert y screen coordinate to line number. Long_t ToObjXCoord(Long_t xCoord, Long_t line); Convert x screen coordinate to column in specified line. void Clear(Option_t* = """"); Clear text view widget. Bool_t LoadFile(const char* fname, long startpos = 0, long length = -1); Load a file in the text view widget. Return false in case file does not; exist. Bool_t LoadBuffer(const char* txtbuf); Load text from a text buffer. Return false in case of failure. Bool_t Copy(); Copy selected text to clipboard. Bool_t SelectAll(); Select all text in the viewer. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw lines in exposed region. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HandleTimer(TTimer* t); Handle scroll timer. Bool_t HandleButton(Event_t* event); Handle mouse button event in text editor. Bool_t HandleDoubleClick(Event_t* event); handle double click. Bool_t HandleMotion(Event_t* event); Handle mouse motion event in the text editor widget. Bool_t HandleSelectionClear(Event_t* event); Handle selection clear event. Bool_t HandleSelectionRequest(Event_t* event); Handle request to send current clipboard contents to requestor window. Bool_t HandleDNDDrop(TDNDData* data); Handle Drop event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle Drag position event. Atom_t HandleDNDEnter(Atom_t* typelist); Handle Drag Enter event. Bool_t HandleDNDLeave(); Handle Drag Leave event. void Mark(Long_t xPos, Long_t yPos); Mark a text region from xPos to yPos. void UnMark(); Clear marked region. void AdjustWidt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextView.html:26344,expose,exposed,26344,root/html528/TGTextView.html,https://root.cern,https://root.cern/root/html528/TGTextView.html,6,['expose'],['exposed']
Security,"n, like covariance or correlation matrix.; Note that all parameter values, limits, and step sizes are copied from the input fit function f1 (so they should be set before calling this method. This is particularly relevant for the step sizes, taken to be the ""error"" set on input, as a null step size usually fixes the corresponding parameter. That is protected against, but in such cases an arbitrary starting step size will be used, and the reliability of the fit should be questioned). If parameters are to be fixed, this should be done by specifying non-null parameter limits, with lower limits larger than upper limits.; On output, f1 contains the fitted parameters and errors, as well as the number of degrees of freedom, and the goodness-of-fit estimator as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. ; Definition at line 195 of file TBinomialEfficiencyFitter.cxx. ◆ GetFitter(). ROOT::Fit::Fitter * TBinomialEfficiencyFitter::GetFitter ; (; ). Provide access to the underlying fitter object. ; This may be useful e.g. for the retrieval of additional information (such as the output covariance matrix of the fit). ; Definition at line 162 of file TBinomialEfficiencyFitter.cxx. ◆ IsA(). TClass * TBinomialEfficiencyFitter::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 73 of file TBinomialEfficiencyFitter.h. ◆ Set(). void TBinomialEfficiencyFitter::Set ; (; const TH1 * ; numerator, . const TH1 * ; denominator . ). Initialize with a new set of inputs. ; Definition at line 139 of file TBinomialEfficiencyFitter.cxx. ◆ SetPrecision(). void TBinomialEfficiencyFitter::SetPrecision ; (; Double_t ; epsilon). Set the required integration precision, see TF1::Integral() ; Definition at line 152 of file TBinomialEfficiencyFitter.cxx. ◆ Streamer(). void TBinomialEfficiencyFitter::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html:18454,access,access,18454,doc/master/classTBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html,1,['access'],['access']
Security,"n->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3443}; 3444 ; 3445 ; 3446static void; 3447mg_cry_internal_wrap(const struct mg_connection *conn,; 3448 struct mg_context *ctx,; 3449 const char *func,; 3450 unsigned line,; 3451 const char *fmt,; 3452 ...); 3453{; 3454 va_list ap;; 345",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:101746,access,access,101746,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"n->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3444}; 3445 ; 3446 ; 3447static void; 3448mg_cry_internal_wrap(const struct mg_connection *conn,; 3449 struct mg_context *ctx,; 3450 const char *func,; 3451 unsigned line,; 3452 const char *fmt,; 3453 ...); 3454{; 3455 va_list ap;; 345",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:101778,access,access,101778,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"n. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <THashTable.h>. Inheritance diagram for THashTable:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ THashTable() [1/2]. THashTable::THashTable ; (; const THashTable & ; ). privatedelete . ◆ THashTable() [2/2]. THashTable::THashTable ; (; Int_t ; capacity = TCollection::kInitHashTableCapacity, . Int_t ; rehashlevel = 0 . ). Create a THashTable object. ; Capacity is the initial hashtable capacity (i.e. number of slots), by default kInitHashTableCapacity = 17, and rehashlevel is the value at which a rehash will be triggered. I.e. when the average size of the linked lists at a slot becomes longer than rehashlevel then the hashtable will be resized and refilled to reduce the collision rate to about 1. The higher the collision rate, i.e. the longer the linked lists, the longer lookup will take. If rehashlevel=0 the table will NOT automatically be rehashed. Use Rehash() for manual rehashing. ; Definition at line 43 of file THashTable.cxx. ◆ ~THashTable(). THashTable::~THashTable ; (; ). virtual . Delete a hashtable. ; Objects are not deleted unless the THashTable is the owner (set via SetOwner()). ; Definition at line 65 of file THashTable.cxx. Member Function Documentation. ◆ Add(). void THashTable::Add ; (; TObject * ; obj). overridevirtual . Add object to the hash table. ; Its position in the table will be determined by the value returned by its Hash() functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:16431,hash,hashtable,16431,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hashtable']
Security,"n. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter() loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes. Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; TGeoManager::GetMasterVolumeTGeoVolume * GetMasterVolume() constDefinition TGeoManager.h:511; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: ""The picture is strangely rotated; where are the coordinate axes?""; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:106598,validat,validation,106598,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['validat'],['validation']
Security,"n.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To impro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTable.html:10552,hash,hash,10552,root/html534/THashTable.html,https://root.cern,https://root.cern/root/html534/THashTable.html,3,['hash'],['hash']
Security,"n.ch/root/html/examples/V5.16.txt.html; To convert the source file MyCode.C to HTML, you can run; root[] THtml h; root[] h.Convert(""MyCode.C"", ""Look At My Code"", ""htmlout/"");; This will create the file htmlout/MyCode.C.html. The HTML page will have the title “Look At My Code”.; 27.3 Special Documentation Elements: Directives; A common documentation problem is the inclusion of images. They are usually generated externally, which poses problems with where to keep the images, and how to keep them up to date. THtml solves this by offering a few special documentation elements: macro and latex directives.; 27.3.1 Latex Directive; Documentation surrounded by the keywords BEGIN_LATEX / END_LATEX will be passed to ROOT Latex engine TLatex. The keywords can be written with small or capital letters (case insensitive). The output will be stored to an image file, which gets automatically included in the documentation.; // This function calculates BEGIN_LATEX; // F(x_{#frac{1}{2}}) = #prod(x < x_{#frac{1}{2}}) = #frac{1}{2}; // END_LATEX; THtml will inject the following picture:. The image file name is generated from the formula and will be unique for all the documentation. It is stored along-side the documentation, and it will be automatically regenerated when the documentation is updated. The handling of the Latex directive is done by the class TDocLatexDirective.; The BEGIN_LATEX keyword can take the following parameters:. fontsize: sets the TLatex font size. The default value is 16.; separator: sets a list of characters for which a new column will be started. This allows aligned, multi-line, multi-column layout, which can be useful for e.g. mathematical derivations. It is unset by default, meaning the Latex directive will only generate one column.; rseparator: like separator, but a regular expression. Columns start with a match of this regular expression. Only one of separator or rseparator can be given.; align: defines the alignment of the columns. Note that the column delim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1245473,inject,inject,1245473,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['inject'],['inject']
Security,"n::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashList.html:11206,hash,hashlist,11206,root/html528/THashList.html,https://root.cern,https://root.cern/root/html528/THashList.html,4,['hash'],['hashlist']
Security,"n; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non-negative integer, then; it is used as the fixed size of the array.; If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]); where nelem and nelem2 are non-negative integer) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new branch with the object of class classname at address addobj. WARNING:; Starting with Root version 3.01, the Branch function uses the new style; branches (TBranchElement). To get the old behaviour, you can:; - call BranchOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:52169,access,access,52169,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,2,['access'],['access']
Security,"n; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non-negative integer, then; it is used as the fixed size of the array.; If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]); where nelem and nelem2 are non-negative integer) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* Branch(const char* name, const char* classname, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new branch with the object of class classname at address addobj. WARNING:; Starting with Root version 3.01, the Branch function uses the new style; branches (TBranchElement). To get the old behaviour, you can:; - call BranchOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:48629,access,access,48629,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,2,['access'],['access']
Security,"n; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:43812,access,access,43812,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['access'],['access']
Security,"nBase> fActionPtr;; 179 ; 180 /// Triggers the event loop in the RLoopManager; 181 void TriggerRun();; 182 ; 183 /// Get the pointer to the encapsulated result.; 184 /// Ownership is not transferred to the caller.; 185 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 186 T *Get(); 187 {; 188 if (fActionPtr != nullptr && !fActionPtr->HasRun()); 189 TriggerRun();; 190 return fObjPtr.get();; 191 }; 192 ; 193 void ThrowIfNull(); 194 {; 195 if (fObjPtr == nullptr); 196 throw std::runtime_error(""Trying to access the contents of a null RResultPtr."");; 197 }; 198 ; 199 RResultPtr(std::shared_ptr<T> objPtr, RDFDetail::RLoopManager *lm,; 200 std::shared_ptr<RDFInternal::RActionBase> actionPtr); 201 : fLoopManager(lm), fObjPtr(std::move(objPtr)), fActionPtr(std::move(actionPtr)); 202 {; 203 }; 204 ; 205public:; 206 using Value_t = T; ///< Convenience alias to simplify access to proxied type; 207 static constexpr ULong64_t kOnce = 0ull; ///< Convenience definition to express a callback must be executed once; 208 ; 209 RResultPtr() = default;; 210 RResultPtr(const RResultPtr &) = default;; 211 RResultPtr(RResultPtr &&) = default;; 212 RResultPtr &operator=(const RResultPtr &) = default;; 213 RResultPtr &operator=(RResultPtr &&) = default;; 214 explicit operator bool() const { return bool(fObjPtr); }; 215 ; 216 /// Convert a RResultPtr<T2> to a RResultPtr<T>.; 217 ///; 218 /// Useful e.g. to store a number of RResultPtr<TH1D> and RResultPtr<TH2D> in a std::vector<RResultPtr<TH1>>.; 219 /// The requirements on T2 and T are the same as for conversion between std::shared_ptr<T2> and std::shared_ptr<T>.; 220 template <typename T2,; 221 std::enable_if_t<std::is_constructible<std::shared_ptr<T>, std::shared_ptr<T2>>::value, int> = 0>; 222 RResultPtr(const RResultPtr<T2> &r) : fLoopManager(r.fLoopManager), fObjPtr(r.fObjPtr), fActionPtr(r.fActionPtr); 223 {; 224 }; 225 ; 226 /// Get a const reference to the encapsulated object.; 227 /// Trigger",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:8293,access,access,8293,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['access'],['access']
Security,"nProxy::Initialize(Bool_t silent) const; virtual TGenCollectionProxy*TEmulatedCollectionProxy::InitializeEx(Bool_t silent); voidTEmulatedCollectionProxy::ReadItems(int nElements, TBuffer& b); voidReadMap(int nElements, TBuffer& b); voidTEmulatedCollectionProxy::Shrink(UInt_t nCurr, UInt_t left, Bool_t force); voidTEmulatedCollectionProxy::WriteItems(int nElements, TBuffer& b); voidWriteMap(int nElements, TBuffer& b). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedMapProxy.html:4589,access,accessors,4589,root/html532/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedMapProxy.html,2,['access'],['accessors']
Security,"n_DNN_CPU.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyKeras ] :␛[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 11200 training events and 2800 validation events; : Training Model Summary; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; dense (Dense) (None, 64) 512 ; ; dense_1 (Dense) (None, 64) 4160 ; ; dense_2 (Dense) (None, 64) 4160 ; ; dense_3 (Dense) (None, 64) 4160 ; ; dense_4 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 13122 (51.26 KB); Trainable params: 13122 (51.26 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; Epoch 1/20; ; 1/112 [..............................] - ETA: 1:09 - loss: 0.6923 - accuracy: 0.6000␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 21/112 [====>.........................] - ETA: 0s - loss: 0.6891 - accuracy: 0.5348 ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 42/112 [==========>...................] - ETA: 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:27026,validat,validation,27026,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['validat'],['validation']
Security,"n_DNN_CPU.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyKeras ] :␛[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 11200 training events and 2800 validation events; : Training Model Summary; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; dense (Dense) (None, 64) 512 ; ; dense_1 (Dense) (None, 64) 4160 ; ; dense_2 (Dense) (None, 64) 4160 ; ; dense_3 (Dense) (None, 64) 4160 ; ; dense_4 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 13122 (51.26 KB); Trainable params: 13122 (51.26 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; Epoch 1/20; ; 1/112 [..............................] - ETA: 1:13 - loss: 0.6918 - accuracy: 0.5600␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 24/112 [=====>........................] - ETA: 0s - loss: 0.6860 - accuracy: 0.5275 ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 46/112 [===========>..................] - ETA: 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:27466,validat,validation,27466,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['validat'],['validation']
Security,"n_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetAttributes(const TString& attributes); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Bool_tSetChecksum(const TString& checksum); voidSetCode(const TString& code); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEmbed(Bool_t embed); Bool_tSetFromRule(const char* rule); voidSetInclude(const TString& include); static voidTObject::SetObjectStat(Bool_t stat); voidSetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr); voidSetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr); voidSetRuleType(ROOT::TSchemaRule::RuleType_t type); voidSetSource(const TString& source); voidSetSourceClass(const TString& classname); voidSetTarget(const TString& target); voidSetTargetClass(const TString& classname); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetVersion(const TString& version); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTestChecksum(UInt_t checksum) const; Bool_tTestVersion(Int_t version) const; ROOT::TSchemaRuleTSchemaRule(); ROOT::TSchemaRuleTSchemaRule(const ROOT::TSchemaRule& rhs); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TSchemaRule.html:5889,checksum,checksum,5889,root/html602/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html602/ROOT__TSchemaRule.html,2,['checksum'],['checksum']
Security,"n_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(UInt_t code = 0) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:3863,checksum,checksum,3863,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,4,['checksum'],['checksum']
Security,"n_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:3900,checksum,checksum,3900,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,1,['checksum'],['checksum']
Security,"naSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; void*TGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCopyIterator; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteIterator; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; void*TGenCollectionProxy::fFunctionNextIterator; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextContainer accessors: generic iteration: next; TClass*TGenCollectionProxy::fOnFileClassOn file class; Bool_tTGenCollectionProxy::fPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >TGenCollectionProxy::fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >TGenCollectionProxy::fProxyListStack of recursive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedCollectionProxy.html:4945,access,accessors,4945,root/html534/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedCollectionProxy.html,6,['access'],['accessors']
Security,"nableImplicitMT();; ; // Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same; // folder as this tutorial; std::string dataset_spec = gROOT->GetTutorialsDir() + std::string(""/dataframe/df106_HiggsToFourLeptons_spec.json"");; ROOT::RDataFrame df = ROOT::RDF::Experimental::FromSpec(dataset_spec);; ; // Add the ProgressBar feature; ROOT::RDF::Experimental::AddProgressBar(df);; ; #ifndef __CLING__; // If this tutorial is compiled, rather than run as a ROOT macro, the interpreter needs to be fed the signatures; // of all the functions we want to JIT in our analysis, as well as any type used in those signatures.; // clang-format off; gInterpreter->Declare(; ""using ROOT::RVecF;""; ""bool GoodElectronsAndMuons(const ROOT::RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e,""; ""const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0);""; ""float ComputeInvariantMass(const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e);""; );; // clang-format on; #endif; ; // Perform the analysis; // Access metadata information that is stored in the JSON config file of the RDataFrame; // The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo`; // class; auto df_analysis =; df.DefinePerSample(""xsecs"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""xsecs""); }); .DefinePerSample(""lumi"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""lumi""); }); .DefinePerSample(""sumws"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""sumws""); }); .DefinePerSample(""sample_category"",; [](unsigned int slot, const RSampleInfo &id) { return id.GetS(""sample_category""); }); // Apply an MC correction for the ZZ decay due to missing gg->ZZ process; .DefinePerSample(""scale"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id) {; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }); // Select electr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:4306,access,accessible,4306,doc/master/df106__HiggsToFourLeptons_8C.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html,1,['access'],['accessible']
Security,"nal example let us apply two different cuts on branch ""MET"" and fill two different histograms with the ""pt_v"" of the filtered events. By now, you should be able to easily understand what is happening: RDataFrame d(""treeName"", ""file.root"");; auto h1 = d.Filter(""MET > 10"").Histo1D(""pt_v"");; auto h2 = d.Histo1D(""pt_v"");; h1->Draw(); // event loop is run once here; h2->Draw(""SAME""); // no need to run the event loop again; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; h1TH1F * h1Definition legend1.C:5; RDataFrame executes all above actions by running the event-loop only once. The trick is that actions are not executed at the moment they are called, but they are lazy, i.e. delayed until the moment one of their results is accessed through the smart pointer. At that time, the event loop is triggered and all results are produced simultaneously.; It is therefore good practice to declare all your transformations and actions before accessing their results, allowing RDataFrame to run the loop once and produce all results in one go. Going parallel; Let's say we would like to run the previous examples in parallel on several cores, dividing events fairly between cores. The only modification required to the snippets would be the addition of this line before constructing the main dataframe object: ROOT::EnableImplicitMT();; Simple as that. More details are given below. Working with collections and object selections; RDataFrame reads collections as the special type ROOT::RVec: for example, a column containing an array of floating point numbers can be read as a ROOT::RVecF. C-style arrays (with variable or static size), STL vectors and most other collection types can be read this way.; RVec is a container similar to std::vector (and can be used just like a std::vector) but it also offers a rich interface to operate on the array elements in a vectorised fashion, similarly to Python's NumPy arrays.; For example, to fill a histogr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:25514,access,accessing,25514,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['access'],['accessing']
Security,"nal, TClass *receiver_class, const char *slot);  Checking of consistency of sender/receiver methods/arguments. ;  ; static TString CompressName (const char *method_name);  Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in the method signature. ;  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TXMLParser; _xmlParserCtxt * fContext;  Parse the xml file. ;  ; Int_t fParseCode;  To keep track of the errorcodes. ;  ; Bool_t fReplaceEntities;  Replace entities. ;  ; Bool_t fStopError;  Stop when parse error occurs. ;  ; Bool_t fValidate;  To validate the parse context. ;  ; TString fValidateError;  Parse error. ;  ; TString fValidateWarning;  Parse warning. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TDOMParser.h>. Inheritance diagram for TDOMParser:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TDOMParser() [1/2]. TDOMParser::TDOMParser ; (; const TDOMParser & ; ). privatedelete . ◆ TDOMParser() [2/2]. TDOMParser::TDOMParser ; (; ). TDOMParser constructor. ; Definition at line 37 of file TDOMParser.cxx. ◆ ~TDOMParser(). TDOMParser::~TDOMParser ; (; ). override . TDOMParser destructor, it calls ReleaseUnderlying(). ; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDOMParser.html:16691,validat,validate,16691,doc/master/classTDOMParser.html,https://root.cern,https://root.cern/doc/master/classTDOMParser.html,1,['validat'],['validate']
Security,"nal, TClass *receiver_class, const char *slot);  Checking of consistency of sender/receiver methods/arguments. ;  ; static TString CompressName (const char *method_name);  Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in the method signature. ;  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TXMLParser; _xmlParserCtxt * fContext;  Parse the xml file. ;  ; Int_t fParseCode;  To keep track of the errorcodes. ;  ; Bool_t fReplaceEntities;  Replace entities. ;  ; Bool_t fStopError;  Stop when parse error occurs. ;  ; Bool_t fValidate;  To validate the parse context. ;  ; TString fValidateError;  Parse error. ;  ; TString fValidateWarning;  Parse warning. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TSAXParser.h>. Inheritance diagram for TSAXParser:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TSAXParser() [1/2]. TSAXParser::TSAXParser ; (; const TSAXParser & ; ). privatedelete . ◆ TSAXParser() [2/2]. TSAXParser::TSAXParser ; (; ). Create SAX parser. ; Definition at line 67 of file TSAXParser.cxx. ◆ ~TSAXParser(). TSAXParser::~TSAXParser ; (; ). override . TSAXParser desctructor. ; Definition at line 97 of file TSAXPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSAXParser.html:18663,validat,validate,18663,doc/master/classTSAXParser.html,https://root.cern,https://root.cern/doc/master/classTSAXParser.html,1,['validat'],['validate']
Security,"nal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(UInt_t code = 0) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetConte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQClass.html:6312,checksum,checksum,6312,root/html528/TQClass.html,https://root.cern,https://root.cern/root/html528/TQClass.html,3,['checksum'],['checksum']
Security,"nal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQClass.html:6315,checksum,checksum,6315,root/html534/TQClass.html,https://root.cern,https://root.cern/root/html534/TQClass.html,1,['checksum'],['checksum']
Security,"nally is added to the list. ; Definition at line 215 of file TSecContext.cxx. ◆ AsString(). const char * TSecContext::AsString ; (; TString & ; out). virtual . Returns short string with relevant information about this security context. ; Reimplemented in TRootSecContext.; Definition at line 313 of file TSecContext.cxx. ◆ Class(). static TClass * TSecContext::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSecContext::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSecContext::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 94 of file TSecContext.h. ◆ Cleanup(). void TSecContext::Cleanup ; (; ). private . Cleanup what is still active. ; Definition at line 160 of file TSecContext.cxx. ◆ CleanupSecContext(). Bool_t TSecContext::CleanupSecContext ; (; Bool_t ; all). privatevirtual . Ask remote client to cleanup security context 'ctx' If 'all', all sec context with the same host as ctx are cleaned. ; Reimplemented in TRootSecContext.; Definition at line 336 of file TSecContext.cxx. ◆ DeActivate(). void TSecContext::DeActivate ; (; Option_t * ; opt = ""CR""). virtual . Set OffSet to -1 and expiring Date to default Remove from the list If Opt contains ""C"" or ""c"", ask for remote cleanup If Opt contains ""R"" or ""r"", remove from the list Default Opt=""CR"". ; Reimplemented in TRootSecContext.; Definition at line 192 of file TSecContext.cxx. ◆ DeclFileName(). static const char * TSecContext::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 94 of file TSecContext.h. ◆ GetContext(). void * TSecContext::GetContext ; (; ); const. inline . Definition at line 73 of file TSecContext.h. ◆ GetExpDate(). TDatime TSecContext::GetExpDate ; (; ); const. inline . Definition at line 74 of file TSecContext.h. ◆ GetHost(). const char * TSecContext::GetHost ; (; ); const. inline . Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSecContext.html:14462,secur,security,14462,doc/master/classTSecContext.html,https://root.cern,https://root.cern/doc/master/classTSecContext.html,1,['secur'],['security']
Security,"nalysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 933event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 934On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 935ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 936~~~{.cpp}; 937ROOT::EnableImplicitMT();; 938ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 939ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 940auto histo1 = df1.Histo1D(""x"");; 941auto histo2 = df2.Histo1D(""y"");; 942 ; 943// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 944histo1->Draw(); // runs first multi-thread event loop; 945histo2->Draw(); // runs second multi-thread event loop; 946 ; 947// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 948ROOT::RDF::RunGraphs({histo1, histo2});; 949histo1->Draw(); // results can then be used as usual; 950~~~; 951 ; 952### Performance considerations; 953 ; 954To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 955For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 956Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 957should be preferred for performance-critical applications.; 958 ; 959Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 960See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 961 ; 962Just-in-time compilatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:54118,access,accessing,54118,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['accessing']
Security,"nalysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 973event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 974On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 975ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 976~~~{.cpp}; 977ROOT::EnableImplicitMT();; 978ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 979ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 980auto histo1 = df1.Histo1D(""x"");; 981auto histo2 = df2.Histo1D(""y"");; 982 ; 983// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 984histo1->Draw(); // runs first multi-thread event loop; 985histo2->Draw(); // runs second multi-thread event loop; 986 ; 987// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 988ROOT::RDF::RunGraphs({histo1, histo2});; 989histo1->Draw(); // results can then be used as usual; 990~~~; 991 ; 992### Performance considerations; 993 ; 994To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 995For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 996Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 997should be preferred for performance-critical applications.; 998 ; 999Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 1000See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 1001 ; 1002Just-in-time compila",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:55758,access,accessing,55758,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['accessing']
Security,"name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. RooLinkedListElem*RooLinkedList::createElement(TObject* obj, RooLinkedListElem* elem = 0); voidRooLinkedList::deleteElement(RooLinkedListElem*); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*RooLinkedList::findLink(const TObject* arg) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*RooLinkedList::_first! Link to first element of list; Int_tRooLinkedList::_hashThreshSize threshold for hashing; RooHashTable*RooLinkedList::_htableLink! Hash table by link pointer; RooHashTable*RooLinkedList::_htableName! Hash table by name ; RooLinkedListElem*RooLinkedList::_last! Link to last element of list; TStringRooLinkedList::_name; Int_tRooLinkedList::_sizeCurrent size of list; Bool_tRooLinkedList::_useNptr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRefCountList(); Default constructor construct lists with initial hash table size of 17. void Add(TObject* obj, Int_t count); Add object to list with given reference count increment; List takes ownership of object. Bool_t Remove(TObject* obj); Remove object from list and if reference count; reaches zero delete object itself as well. Bool_t RemoveAll(TObject* obj); Remove object from list and delete object itself; regardless of reference count. Int_t refCount(TObject* obj); Return reference count associated with 'obj'. RooRefCountList(). virtual ~RooRefCountList(); {}. void Add(TObject* arg); { Add(arg,1) ; }. » Last changed: Tue Mar 10 17:18:54 2015 » Last generated: 2015-03-10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRefCountList.html:6780,hash,hashing,6780,root/html534/RooRefCountList.html,https://root.cern,https://root.cern/root/html534/RooRefCountList.html,1,['hash'],['hashing']
Security,"name has the form of a multi dimension array (e.g. var[nelem][nelem2]) where nelem and nelem2 are non-negative integers) then it is used as a 2 dimensional array of fixed size.; In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after the type character. See TStreamerElement::GetRange() for further information.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory. On some platform, this is not always true of the member of a struct or a class, due to padding and alignment. Sorting your data member in order of decreasing sizeof usually leads to their being contiguous in memory. bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode. See an example of a Branch definition in the TTree constructor.; Note that in case the data type is an object, this branch can contain only this object.; Note that this function is invoked by TTree::Branch ; Definition at line 199 of file TBranch.cxx. ◆ TBranch() [4/4]. TBranch::TBranch ; (; TBranch * ; parent, . const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; basketsize = 32000, . Int_t ; compress = ROOT::RCompressionSetting::EAlgorithm::kInherit . ). Create a Branch as a child of another Branch. ; See documentation for TBranch::TBranch(TTree *, const char *, void *, const char *, Int_t, Int_t) ; Definition at line 252 of file TBranch.cxx. ◆ ~TBranch(). TBranch::~TBranch ; (; ). override . Destructor. ; Definition at line 450 of file TBranch.cxx. Member Function Documentation. ◆ AddBasket(). void TBranch::AddBasket ; (; TBasket & ; b, . bool ; ondisk, . Long",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:32640,access,access,32640,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['access'],['access']
Security,"name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]) where nelem and nelem2 are non-negative integer) then it is used as a 2 dimensional array of fixed size.; In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after the type character. See TStreamerElement::GetRange() for further information. Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory. On some platform, this is not always true of the member of a struct or a class, due to padding and alignment. Sorting your data member in order of decreasing sizeof usually leads to their being contiguous in memory. bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode. . Reimplemented in TTreeSQL.; Definition at line 1986 of file TTree.cxx. ◆ Branch() [12/13]. Int_t TTree::Branch ; (; TCollection * ; li, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99, . const char * ; name = """" . ). virtual . Create one branch for each element in the collection. ; Each entry in the collection becomes a top level branch if the corresponding class is not a collection. If it is a collection, the entry in the collection becomes in turn top level branches, etc. The splitlevel is decreased by 1 every time a new collection is found. For example if list is a TObjArray*; if splitlevel = 1, one top level branch is created for each element of the TObjArray.; if splitlevel = 2, one top level branch is created for each array element. if, in turn, one of the array elements is a TCollection, one top level branch will be created for each element of this collection. In case a coll",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:86828,access,access,86828,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['access']
Security,"name of top folder, default - ""ROOT""Definition THttpServer.h:45; THttpServer::SetDrawPagevoid SetDrawPage(const std::string &filename="""")Set drawing HTML page.Definition THttpServer.cxx:387; THttpServer::CreateItemBool_t CreateItem(const char *fullname, const char *title)Create item in sniffer.Definition THttpServer.cxx:1455; THttpServer::ExecuteHttpBool_t ExecuteHttp(std::shared_ptr< THttpCallArg > arg)Execute HTTP request.Definition THttpServer.cxx:642; THttpServer::HideBool_t Hide(const char *fullname, Bool_t hide=kTRUE)Hides folder or element from web gui.Definition THttpServer.cxx:1436; THttpServer::IsCorsCredentialsBool_t IsCorsCredentials() constReturns kTRUE if Access-Control-Allow-Credentials header should be used.Definition THttpServer.h:121; THttpServer::AddLocationvoid AddLocation(const char *prefix, const char *path)Add files location, which could be used in the server.Definition THttpServer.cxx:332; THttpServer::fLocationsstd::map< std::string, std::string > fLocations! list of local directories, which could be accessed via serverDefinition THttpServer.h:48; THttpServer::SubmitHttpBool_t SubmitHttp(std::shared_ptr< THttpCallArg > arg, Bool_t can_run_immediately=kFALSE)Submit HTTP request.Definition THttpServer.cxx:681; THttpServer::fMainThrdIdLong_t fMainThrdId! id of the thread for processing requestsDefinition THttpServer.h:38; THttpServer::fJSROOTSYSTString fJSROOTSYS! location of local JSROOT filesDefinition THttpServer.h:44; THttpServer::fTimerstd::unique_ptr< THttpTimer > fTimer! timer used to access main threadDefinition THttpServer.h:35; THttpServer::fWSOnlyBool_t fWSOnly! when true, handle only websockets / longpoll engineDefinition THttpServer.h:42; THttpServer::RegisterBool_t Register(const char *subfolder, TObject *obj)Register object in subfolder.Definition THttpServer.cxx:1243; THttpServer::fEnginesTList fEngines! engines which runs http serverDefinition THttpServer.h:34; THttpServer::SetCorsvoid SetCors(const std::string &domain=""*"")Enabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:61269,access,accessed,61269,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['access'],['accessed']
Security,"name; <TAttPad:fLeftMargin v=""0.100000""/>; <TAttPad:fRightMargin v=""0.100000""/>; <TAttPad:fBottomMargin v=""0.100000""/>; and so on; Usage of namespace increase size of xml file, but makes file more readable; and allows to produce DTD in the case, when in several classes data member has same name; Can be changed only for newly created file. Bool_t AddXmlComment(const char* comment); Add comment line on the top of the xml document; This line can only be seen in xml editor and cannot be accessed later; with TXMLFile methods. Bool_t AddXmlStyleSheet(const char* href, const char* type = ""text/css"", const char* title = 0, int alternate = -1, const char* media = 0, const char* charset = 0); Adds style sheet definition on the top of xml document; Creates <?xml-stylesheet alternate=""yes"" title=""compact"" href=""small-base.css"" type=""text/css""?>; Attributes href and type must be supplied,; other attributes: title, alternate, media, charset are optional; if alternate==0, attribyte alternate=""no"" will be created,; if alternate>0, attribute alternate=""yes""; if alternate<0, attribute will not be created; This style sheet definition cannot be later access with TXMLFile methods. Bool_t AddXmlLine(const char* line); Add just one line on the top of xml document; For instance, line can contain special xml processing instructions; Line should has correct xml syntax that later it can be decoded by xml parser; To be parsed later by TXMLFile again, this line should contain either; xml comments or xml processing instruction. Long64_t DirCreateEntry(TDirectory* ); Create key for directory entry in the key. TKeyXML* FindDirKey(TDirectory* dir); Serach for key which correspond to direcory dir. TDirectory* FindKeyDir(TDirectory* mother, Long64_t keyid); Find a directory in motherdir with a seek equal to keyid. Int_t DirReadKeys(TDirectory* ); Read keys for directory; Make sence only once, while next time no new subnodes will be created. void DirWriteKeys(TDirectory* ); Update key attributes. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLFile.html:31750,access,access,31750,root/html528/TXMLFile.html,https://root.cern,https://root.cern/root/html528/TXMLFile.html,6,['access'],['access']
Security,"nary *&dict, TDictionary const *curDict);  Retrieve the type of data stored by branch; put its dictionary into dict, return its type name. ;  ; static std::string GetElementTypeName (const std::type_info &ti);  Stringify the template argument. ;  ;  Protected Attributes inherited from ROOT::Internal::TTreeReaderValueBase; TString fBranchName;  Name of the branch to read data from. ;  ; TDictionary * fDict;  Type that the branch should contain. ;  ; bool fHaveLeaf: 1;  Whether the data is in a leaf. ;  ; bool fHaveStaticClassOffsets: 1;  Whether !fStaticClassOffsets.empty() ;  ; TLeaf * fLeaf = nullptr;  ; TString fLeafName;  ; bool fOpaqueRead {false};  If true, the reader will not do any type-checking against the actual type held by the branch. ;  ; Detail::TBranchProxy * fProxy = nullptr;  Proxy for this branch, owned by TTreeReader. ;  ; Read_t fProxyReadFunc = &TTreeReaderValueBase::ProxyReadDefaultImpl;  ! Pointer to the Read implementation to use. ;  ; EReadStatus fReadStatus: 2;  Read status of this data access. ;  ; ESetupStatus fSetupStatus = kSetupNotSetup;  Setup status of this data access. ;  ; std::vector< Long64_t > fStaticClassOffsets;  ; TTreeReader * fTreeReader;  Tree reader we belong to. ;  . #include <TTreeReaderValue.h>. Inheritance diagram for TTreeReaderValue< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ NonConstT_t. template<typename T > . using TTreeReaderValue< T >::NonConstT_t = typename std::remove_const<T>::type. Definition at line 178 of file TTreeReaderValue.h. Constructor & Destructor Documentation. ◆ TTreeReaderValue() [1/2]. template<typename T > . TTreeReaderValue< T >::TTreeReaderValue ; (; ). delete . ◆ TTreeReaderValue() [2/2]. template<typename T > . TTreeReaderValue< T >::TTreeReaderValue ; (; TTreeReader & ; tr, . const char * ; branchname . ). inline . Definition at line 180 of file TTreeReaderValue.h. Member Function Documentation. ◆ Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReaderValue.html:5255,access,access,5255,doc/master/classTTreeReaderValue.html,https://root.cern,https://root.cern/doc/master/classTTreeReaderValue.html,1,['access'],['access']
Security,"nate any interaction in viewer. ;  ; Bool_t HandleDoubleClick (Event_t *event) override;  Handle mouse double click 'event'. ;  ; Bool_t HandleEvent (Event_t *event) override;  Handle generic Event_t type 'event' - provided to catch focus changes and terminate any interaction in viewer. ;  ; virtual Bool_t HandleExpose (Event_t *event);  Handle window expose 'event' - show. ;  ; Bool_t HandleFocusChange (Event_t *event) override;  Handle generic Event_t type 'event' - provided to catch focus changes and terminate any interaction in viewer. ;  ; Bool_t HandleKey (Event_t *event) override;  Handle keyboard 'event'. ;  ; Bool_t HandleMotion (Event_t *event) override;  Handle mouse motion 'event'. ;  ; Bool_t HandleTimer (TTimer *t) override;  If mouse delay timer times out emit signal. ;  ; virtual void PopupContextMenu (TGLPhysicalShape *pshp, Event_t *event, Int_t gx, Int_t gy);  Popup context menu. ;  ; virtual void RemoveTooltip ();  Hide the tooltip. ;  ; void Repaint () override;  Handle window expose 'event' - show. ;  ; void SetArcBall (Bool_t a);  ; void SetDoInternalSelection (Bool_t x);  ; void SetMouseOverSelectDelay (Int_t ms);  Set delay of mouse-over probe (highlight). ;  ; void SetMouseOverTooltipDelay (Int_t ms);  Set delay of tooltip timer. ;  ; void SetSecSelType (Int_t t);  ; void SetTooltipPixelTolerance (Int_t t);  ; virtual void StartMouseTimer ();  Start mouse timer in single-shot mode. ;  ; virtual void StopMouseTimer ();  Make sure mouse timers are not running. ;  ; virtual void TriggerTooltip (const char *text);  Trigger display of tooltip. ;  ;  Public Member Functions inherited from TGEventHandler;  TGEventHandler (const char *name, TGWindow *w, TObject *obj, const char *title="""");  ;  ~TGEventHandler () override;  ; void Activate ();  ; void DeActivate ();  ; virtual Bool_t HandleColormapChange (Event_t *);  ; virtual Bool_t HandleSelection (Event_t *);  ; virtual Bool_t HandleSelectionClear (Event_t *);  ; virtual Bool_t HandleSelectionReq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLEventHandler.html:2973,expose,expose,2973,doc/master/classTGLEventHandler.html,https://root.cern,https://root.cern/doc/master/classTGLEventHandler.html,1,['expose'],['expose']
Security,"nc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClass.html:45931,checksum,checksum,45931,root/html532/TClass.html,https://root.cern,https://root.cern/root/html532/TClass.html,8,['checksum'],['checksum']
Security,"nc);  Mark 'func' as being unloaded. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; Bool_t IsAscending ();  ; TObject * Remove (const TObjLinkPtr_t &lnk);  ; void RemoveLast () override;  Remove the last object of the list. ;  ; virtual void Sort (Bool_t order=kSortAscending);  Sort linked list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TSeqCollection; virtual ~TSeqCollection ();  ; void Add (TObject *obj) override;  ; TClass * IsA () const override;  ; virtual Bool_t IsSorted () const;  ; Int_t LastIndex () const;  ; Long64_t Merge (TCollection *list);  Merge this collection with all collections coming in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:6394,access,access,6394,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,1,['access'],['access']
Security,"nc);  Mark 'func' as being unloaded. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * Before (const TObject *obj) const override;  Returns the object before object obj. ;  ; TObject * First () const override;  Return the first object in the list. Returns 0 when list is empty. ;  ; virtual TObjLink * FirstLink () const;  ; TObject ** GetObjectRef (const TObject *obj) const override;  Return address of pointer to obj. ;  ; Bool_t IsAscending ();  ; TObject * La",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:4469,access,access,4469,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,1,['access'],['access']
Security,"nc_t());; 971 SetErrorHandler(ROOT::Internal::MinimalErrorHandler);; 972 ROOT::Internal::ReleaseDefaultErrorHandler();; 973 delete gSystem;; 974 ; 975 // ROOT-6022:; 976 // if (gInterpreterLib) dlclose(gInterpreterLib);; 977#ifdef R__COMPLETE_MEM_TERMINATION; 978 // On some 'newer' platform (Fedora Core 17+, Ubuntu 12), the; 979 // initialization order is (by default?) is 'wrong' and so we can't; 980 // delete the interpreter now .. because any of the static in the; 981 // interpreter's library have already been deleted.; 982 // On the link line, we must list the most dependent .o file; 983 // and end with the least dependent (LLVM libraries), unfortunately,; 984 // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; 985 // in the same order (hence doing libCore's before LLVM's and; 986 // vice et versa for both the destructor. We worked around the; 987 // initialization order by delay the TROOT creation until first use.; 988 // We can not do the same for destruction as we have no way of knowing; 989 // the last access ...; 990 // So for now, let's avoid delete TCling except in the special build; 991 // checking the completeness of the termination deletion.; 992 ; 993 // TODO: Should we do more cleanup here than just call delete?; 994 // Segfaults rootcling in some cases, debug and uncomment:; 995 //; 996 // delete fInterpreter;; 997 ; 998 // We cannot delete fCleanups because of the logic in atexit which needs it.; 999 SafeDelete(fCleanups);; 1000#endif; 1001 ; 1002#ifdef _MSC_VER; 1003 // usedToIdentifyRootClingByDlSym is available when TROOT is part of rootcling.; 1004 if (dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 1005 // deleting the interpreter makes things crash at exit in some cases; 1006 delete fInterpreter;; 1007 }; 1008#else; 1009 // deleting the interpreter makes things crash at exit in some cases; 1010 delete fInterpreter;; 1011#endif; 1012 ; 1013 // Prints memory stats; 1014 TStorage::PrintStatistics();; 1015 ; 1016 gROOTL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:39291,access,access,39291,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['access'],['access']
Security,"nce(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0). BinarySearchTree* GetBinaryTree( void ); accessors. { return fBinaryTree; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. MethodPDERS*& GetMethodPDERSThreadLocal(); This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. {TTHREAD_TLS(MethodPDERS*) fgThisPDERS(nullptr); return fgThisPDERS;}. » Author: Andreas Hoecker, Yair Mahalalel, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodPDERS.html:26958,access,accessors,26958,root/html604/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html,1,['access'],['accessors']
Security,"nce(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0). BinarySearchTree* GetBinaryTree( void ); accessors. { return fBinaryTree; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. MethodPDERS*& GetMethodPDERSThreadLocal(); This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. {TTHREAD_TLS(MethodPDERS*) fgThisPDERS(nullptr); return fgThisPDERS;}. » Author: Andreas Hoecker, Yair Mahalalel, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodPDERS.html:26950,access,accessors,26950,root/html602/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodPDERS.html,1,['access'],['accessors']
Security,nceCount() constDefinition TClass.h:467; TClass::fImplFileLineShort_t fImplFileLineDefinition TClass.h:216; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:81411,access,access,81411,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['access'],['access']
Security,"nced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArray*fAllRules! Array of all rules; UInt_tfCheckSumTarget class checksum; TClassReffClass! Target class pointer (for consistency checking); TStringfClassNameTarget class name; TObjArray*fPersistentRulesArray of the rules that will be embeded in the file; TObjArray*fRemainingRules! Array of non-persisten rules - just for cleanup purposes - owns the elements; Int_tfVersionTarget class version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSchemaRuleSet(). virtual ~TSchemaRuleSet(). Bool_t AddRule(ROOT::TSchemaRule* rule, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll, TString* errmsg = 0). Bool_t AddRules(ROOT::TSchemaRuleSet* rules, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll, TString* errmsg = 0). Bool_t HasRuleWithSourceClass(const TString& source) const. const TObjArray* FindRules(const TString& source) const. const TSchemaMatch* FindRules(const TString& source, Int_t version) const. const TSchemaMatch* FindRules(const TString& source, UInt_t checksum) const. const TSchemaMatch* FindRules(const TString& source, Int_t version, UInt_t checksum) const. TClass* GetClass(). UInt_t GetClassCheckSum() const. TString GetClassName() const. Int_t GetClassVersion() const. const TObjArray* GetRules() const. const TObjArray* GetPersistentRules() const. void RemoveRule(ROOT::TSchemaRule* rule). void RemoveRules(TObjArray* rules). void SetClass(TClass* cls). void ls(Option_t* option = """") const. void AsString(TString& out) const. » Last changed: root/core:$Id: TSchemaRuleSet.h 38140 2011-02-18 10:52:47Z pcanal $ » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__TSchemaRuleSet.html:7231,checksum,checksum,7231,root/html530/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html530/ROOT__TSchemaRuleSet.html,2,['checksum'],['checksum']
Security,"nced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArray*fAllRules! Array of all rules; UInt_tfCheckSumTarget class checksum; TClassReffClass! Target class pointer (for consistency checking); TStringfClassNameTarget class name; TObjArray*fPersistentRulesArray of the rules that will be embeded in the file; TObjArray*fRemainingRules! Array of non-persisten rules - just for cleanup purposes - owns the elements; Int_tfVersionTarget class version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSchemaRuleSet(). virtual ~TSchemaRuleSet(). Bool_t AddRule(ROOT::TSchemaRule* rule, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll, TString* errmsg = 0). Bool_t AddRules(ROOT::TSchemaRuleSet* rules, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll, TString* errmsg = 0). Bool_t HasRuleWithSourceClass(const TString& source) const. const TObjArray* FindRules(const TString& source) const. const TSchemaMatch* FindRules(const TString& source, Int_t version) const. const TSchemaMatch* FindRules(const TString& source, UInt_t checksum) const. const TSchemaMatch* FindRules(const TString& source, Int_t version, UInt_t checksum) const. TClass* GetClass(). UInt_t GetClassCheckSum() const. TString GetClassName() const. Int_t GetClassVersion() const. const TObjArray* GetRules() const. const TObjArray* GetPersistentRules() const. void RemoveRule(ROOT::TSchemaRule* rule). void RemoveRules(TObjArray* rules). void SetClass(TClass* cls). void ls(Option_t* option = """") const. void AsString(TString& out) const. » Last changed: root/core:$Id: TSchemaRuleSet.h 38140 2011-02-18 10:52:47Z pcanal $ » Last generated: 2011-11-03 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__TSchemaRuleSet.html:7231,checksum,checksum,7231,root/html532/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html532/ROOT__TSchemaRuleSet.html,2,['checksum'],['checksum']
Security,"nced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0); Constructor with hashing threshold. If collection size exceeds threshold; a hash table is added. RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'newArg'.; If 'oldArg' is not found in collection kFALSE is returned. TObject* FindObject(const char* name) const; Return pointer to obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooLinkedList.html:6766,hash,hash,6766,root/html528/RooLinkedList.html,https://root.cern,https://root.cern/root/html528/RooLinkedList.html,1,['hash'],['hash']
Security,"nced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0); Constructor with hashing threshold. If collection size exceeds threshold; a hash table is added.; if (htsize>0) {; cout << ""RooLinkedList::ctor htsize="" << htsize << endl ;; }. RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'newArg'.; If 'oldArg' is not found in collection kFALSE is returned. TObject* FindObject(const char* name) const; Return pointer to obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooLinkedList.html:6879,hash,hash-table,6879,root/html530/RooLinkedList.html,https://root.cern,https://root.cern/root/html530/RooLinkedList.html,1,['hash'],['hash-table']
Security,"nch(""Division"",Division,""Division/C"");; tree->Branch(""Nation"",Nation,""Nation/C"");; char line[80];; while (fgets(line,80,fp)) {; sscanf(&line[0],""%d %d %d %d %d %d %d %d %d %s %s"",; &Category,&Flag,&Age,&Service,&Children,&Grade,&Step,&Hrweek,&Cost,Division,Nation);; tree->Fill();; }; tree->Print();; tree->Write();. fclose(fp);; delete hfile;; }; The script opens the ASCII file, creates a ROOT file and a TTree. Then it creates branches with the TTree::Branch method. The first parameter of the Branch method is the branch name. The second parameter is the address from which the first leaf is to be read. Once the branches are defined, the script reads the data from the ASCII file into C variables and fills the tree. The ASCII file is closed, and the ROOT file is written to disk saving the tree. Remember, trees (and histograms) are created in the current directory, which is the file in our example. Hence a f->Write()saves the tree.; 12.3 Show an Entry with TTree::Show; An easy way to access one entry of a tree is the use the TTree::Show method. For example to look at the 10th entry in the cernstaff.root tree:; root[] TFile f(""cernstaff.root""); root[] T->Show(10); ======> EVENT:10; Category = 361; Flag = 15; Age = 51; Service = 29; Children = 0; Grade = 7; Step = 13; Hrweek = 40; Cost = 7599; Division = PS; Nation = FR; 12.4 Print the Tree Structure with TTree::Print; A helpful command to see the tree structure meaning the number of entries, the branches and the leaves, is TTree::Print.; root[] T->Print(); **********************************************************************; *Tree :T : staff data from ascii file *; *Entries :3354 : Total = 245417 bytes File Size = 59945*; * Tree compression factor = 2.90 *; **********************************************************************; *Br 0 :staff :Category/I:Flag:Age:Service:Children:Grade:... *; * | Cost *; *Entries :3354 : Total Size = 154237 bytes File Size = 32316 *; *Baskets : 3 : Basket Size = 32000 bytes Compression= 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:523931,access,access,523931,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"nclude <ctime>; 23#include <memory> // for placement new; 24#include <stdexcept>; 25#include <utility>; 26 ; 27#include <sqlite3.h>; 28 ; 29namespace {; 30 ; 31// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; 32// ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; 33// for ROOT -- an abstraction of the operating system interface.; 34//; 35// SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; 36// it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.; 44constexpr char const *gSQliteVfsName = ""ROOT-Davix-readonly"";; 45 ; 46////////////////////////////////////////////////////////////////////////////; 47/// Holds the state of an open sqlite database. Objects of this struct are created in VfsRdOnlyOpen(); 48/// and then passed by sqlite to the file I/O callbacks (read, close, etc.). This uses C style inheritance; 49/// where the struct starts with a sqlite3_file member (base class) which is extended by members related to; 50/// this particular VFS module. Every callback here thus casts the sqlite3_file input parameter to its ""derived""; 51/// type VfsRootFile.; 52struct VfsRootFile {; 53 VfsRootFile() = default;; 54 ; 55 sqlite3_file pFile;; 56 std::unique_ptr<ROOT::Internal::RRawFile> fR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:1862,access,access,1862,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,2,['access'],['access']
Security,"nction evaluations, but significantly reduces biases due to better sampling of the PDF. The integrator can be accessed from the outside using integrator(). This can be used to change the integration rules, so less/more function evaluations are performed. The target precision of the integrator can be set in the constructor. How to use it; There are two ways to use this class:; Manually wrap a PDF: RooBinSamplingPdf binSampler(""<name>"", ""title"", <binned observable of PDF>, <original PDF> [, <precision for integrator>]);; binSampler.fitTo(data);; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooBinSamplingPdfThe RooBinSamplingPdf is supposed to be used as an adapter between a continuous PDF and a binned dist...Definition RooBinSamplingPdf.h:28; RooBinSamplingPdf::integratorstd::unique_ptr< ROOT::Math::IntegratorOneDim > & integrator() constDirect access to the unique_ptr holding the integrator that's used to sample the bins.Definition RooBinSamplingPdf.cxx:278; RooBinSamplingPdf::observableconst RooAbsReal & observable() constDefinition RooBinSamplingPdf.h:111; When a PDF is wrapped with a RooBinSamplingPDF, just use the bin sampling PDF instead of the original one for fits or plotting etc. NoteThe binning will be taken from the observable. Make sure that this binning is the same as the one of the dataset that should be fit. Use RooRealVar::setBinning() to adapt it. Instruct test statistics to carry out this wrapping automatically: pdf.fitTo(data, IntegrateBins(<precision>));; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooBinSamplingPdf::pdfconst RooAbsPdf & pdf() constDefinition RooBinSamplingPdf.h:110; This method is especially useful when used with a simultaneous PDF, since each component will autom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:1969,access,access,1969,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['access'],['access']
Security,"nction for given set of observables. ; If no direct generator method is provided, this information will assist the accept/reject generator to operate more efficiently as it can skip the initial trial sampling phase to empirically find the function maximum ; Reimplemented from RooAbsReal.; Definition at line 95 of file RooBinSamplingPdf.h. ◆ initGenerator(). void RooBinSamplingPdf::initGenerator ; (; Int_t ; code). inlineoverridevirtual . Forwards to the PDF's implementation. ; Reimplemented from RooAbsPdf.; Definition at line 87 of file RooBinSamplingPdf.h. ◆ integrate(). double RooBinSamplingPdf::integrate ; (; const RooArgSet * ; normSet, . double ; low, . double ; high . ); const. private . Integrate the wrapped PDF using our current integrator, with given norm set and limits. ; Definition at line 302 of file RooBinSamplingPdf.cxx. ◆ integrator(). std::unique_ptr< ROOT::Math::IntegratorOneDim > & RooBinSamplingPdf::integrator ; (; ); const. Direct access to the unique_ptr holding the integrator that's used to sample the bins. ; This can be used to change options such as sampling accuracy or to entirely exchange the integrator.; Example: Use the 61-point Gauss-Kronrod integration rule; ROOT::Math::IntegratorOneDimOptions intOptions = pdf.integrator()->Options();; intOptions.SetNPoints(6); // 61-point integration rule; intOptions.SetRelTolerance(1.E-9); // Smaller tolerance -> more subdivisions; pdf.integrator()->SetOptions(intOptions);; ROOT::Math::BaseIntegratorOptions::SetRelTolerancevoid SetRelTolerance(double tol)set the relative toleranceDefinition IntegratorOptions.h:80; ROOT::Math::IntegratorOneDimOptionsNumerical one dimensional integration options.Definition IntegratorOptions.h:113; ROOT::Math::IntegratorOneDimOptions::SetNPointsvoid SetNPoints(unsigned int n)Set number of points for active integration rule.Definition IntegratorOptions.h:140; See alsoROOT::Math::IntegratorOneDim::SetOptions for more details on integration options. ; NoteWhen RooBinSampling",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:86648,access,access,86648,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['access'],['access']
Security,"nction template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:39073,access,accessible,39073,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['access'],['accessible']
Security,"nction*ROOT::Math::BasicMinimizer::TransformFunction() const; virtual intROOT::Math::BasicMinimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::BasicMinimizer::VariableName(unsigned int ivar) const; virtual const double*ROOT::Math::BasicMinimizer::X() const. protected:. boolROOT::Math::BasicMinimizer::CheckDimension() const; boolROOT::Math::BasicMinimizer::CheckObjFunction() const; ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidROOT::Math::BasicMinimizer::SetFinalValues(const double* x); voidROOT::Math::BasicMinimizer::SetMinValue(double val). private:. ROOT::Math::GSLMinimizerGSLMinimizer(const ROOT::Math::GSLMinimizer&); ROOT::Math::GSLMinimizer&operator=(const ROOT::Math::GSLMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:7038,validat,validated,7038,root/html534/ROOT__Math__GSLMinimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html,1,['validat'],['validated']
Security,"nction*ROOT::Math::BasicMinimizer::TransformFunction() const; virtual intROOT::Math::BasicMinimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::BasicMinimizer::VariableName(unsigned int ivar) const; virtual const double*ROOT::Math::BasicMinimizer::X() const. protected:. boolROOT::Math::BasicMinimizer::CheckDimension() const; boolROOT::Math::BasicMinimizer::CheckObjFunction() const; ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidROOT::Math::BasicMinimizer::SetFinalValues(const double* x); voidROOT::Math::BasicMinimizer::SetMinValue(double val). private:. ROOT::Math::GSLMinimizerGSLMinimizer(const ROOT::Math::GSLMinimizer&); ROOT::Math::GSLMinimizer&operator=(const ROOT::Math::GSLMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GSLMinimizer.html:7094,validat,validated,7094,root/html602/ROOT__Math__GSLMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GSLMinimizer.html,2,['validat'],['validated']
Security,"nction.; See also comments to SetEventList() function of TTree and TChain. If arrays are used in the selection critera, the entry entered in the; list are all the entries that have at least one element of the array that; satisfy the selection.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of ALL tracks in event with at least one track with; a positive fPy. To select only the elements that did match the original selection; use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(kTRUE);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy. Note: Use tree->SetEventList(0) if you do not want use the list as input. How to obtain more info from TTree::Draw. Once TTree::Draw has been called, it is possible to access useful; information still stored in the TTree object via the following functions:; -GetSelectedRows() // return the number of entries accepted by the; //selection expression. In case where no selection; //was specified, returns the number of entries processed.; -GetV1() //returns a pointer to the double array of V1; -GetV2() //returns a pointer to the double array of V2; -GetV3() //returns a pointer to the double array of V3; -GetW() //returns a pointer to the double array of Weights; //where weight equal the result of the selection expression.; where V1,V2,V3 correspond to the expressions in; TTree::Draw(""V1:V2:V3"",selection);. Example:; Root > ntuple->Draw(""py:px"",""pz>4"");; Root > TGraph *gr = new TGraph(ntuple->GetSelectedRows(),; ntuple->GetV2(), ntuple->GetV1());; Root > gr->Draw(""ap""); //draw graph in current pad; creates a TGraph object with a number of points corresponding to the; number of entries selected by the expression ""pz>4"", the x points of the graph; being the px values of the Tree and the y points the py values. Important n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:80221,access,access,80221,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['access'],['access']
